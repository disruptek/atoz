
import
  json, options, hashes, uri, strutils, tables, rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: AWS IoT
## version: 2015-05-28
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>AWS IoT</fullname> <p>AWS IoT provides secure, bi-directional communication between Internet-connected devices (such as sensors, actuators, embedded devices, or smart appliances) and the AWS cloud. You can discover your custom IoT-Data endpoint to communicate with, configure rules for data processing and integration with other services, organize resources associated with each device (Registry), configure logging, and create and manage policies and credentials to authenticate devices.</p> <p>For more information about how AWS IoT works, see the <a href="https://docs.aws.amazon.com/iot/latest/developerguide/aws-iot-how-it-works.html">Developer Guide</a>.</p> <p>For information about how to use the credentials provider for AWS IoT, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorizing-direct-aws.html">Authorizing Direct Calls to AWS Services</a>.</p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/iot/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_601389 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_601389](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_601389): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "iot.ap-northeast-1.amazonaws.com", "ap-southeast-1": "iot.ap-southeast-1.amazonaws.com",
                           "us-west-2": "iot.us-west-2.amazonaws.com",
                           "eu-west-2": "iot.eu-west-2.amazonaws.com", "ap-northeast-3": "iot.ap-northeast-3.amazonaws.com",
                           "eu-central-1": "iot.eu-central-1.amazonaws.com",
                           "us-east-2": "iot.us-east-2.amazonaws.com",
                           "us-east-1": "iot.us-east-1.amazonaws.com", "cn-northwest-1": "iot.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "iot.ap-south-1.amazonaws.com",
                           "eu-north-1": "iot.eu-north-1.amazonaws.com", "ap-northeast-2": "iot.ap-northeast-2.amazonaws.com",
                           "us-west-1": "iot.us-west-1.amazonaws.com",
                           "us-gov-east-1": "iot.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "iot.eu-west-3.amazonaws.com",
                           "cn-north-1": "iot.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "iot.sa-east-1.amazonaws.com",
                           "eu-west-1": "iot.eu-west-1.amazonaws.com",
                           "us-gov-west-1": "iot.us-gov-west-1.amazonaws.com", "ap-southeast-2": "iot.ap-southeast-2.amazonaws.com",
                           "ca-central-1": "iot.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "iot.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "iot.ap-southeast-1.amazonaws.com",
      "us-west-2": "iot.us-west-2.amazonaws.com",
      "eu-west-2": "iot.eu-west-2.amazonaws.com",
      "ap-northeast-3": "iot.ap-northeast-3.amazonaws.com",
      "eu-central-1": "iot.eu-central-1.amazonaws.com",
      "us-east-2": "iot.us-east-2.amazonaws.com",
      "us-east-1": "iot.us-east-1.amazonaws.com",
      "cn-northwest-1": "iot.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "iot.ap-south-1.amazonaws.com",
      "eu-north-1": "iot.eu-north-1.amazonaws.com",
      "ap-northeast-2": "iot.ap-northeast-2.amazonaws.com",
      "us-west-1": "iot.us-west-1.amazonaws.com",
      "us-gov-east-1": "iot.us-gov-east-1.amazonaws.com",
      "eu-west-3": "iot.eu-west-3.amazonaws.com",
      "cn-north-1": "iot.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "iot.sa-east-1.amazonaws.com",
      "eu-west-1": "iot.eu-west-1.amazonaws.com",
      "us-gov-west-1": "iot.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "iot.ap-southeast-2.amazonaws.com",
      "ca-central-1": "iot.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "iot"
method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_AcceptCertificateTransfer_601727 = ref object of OpenApiRestCall_601389
proc url_AcceptCertificateTransfer_601729(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/accept-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AcceptCertificateTransfer_601728(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_601855 = path.getOrDefault("certificateId")
  valid_601855 = validateParameter(valid_601855, JString, required = true,
                                 default = nil)
  if valid_601855 != nil:
    section.add "certificateId", valid_601855
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_601856 = query.getOrDefault("setAsActive")
  valid_601856 = validateParameter(valid_601856, JBool, required = false, default = nil)
  if valid_601856 != nil:
    section.add "setAsActive", valid_601856
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_601857 = header.getOrDefault("X-Amz-Signature")
  valid_601857 = validateParameter(valid_601857, JString, required = false,
                                 default = nil)
  if valid_601857 != nil:
    section.add "X-Amz-Signature", valid_601857
  var valid_601858 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601858 = validateParameter(valid_601858, JString, required = false,
                                 default = nil)
  if valid_601858 != nil:
    section.add "X-Amz-Content-Sha256", valid_601858
  var valid_601859 = header.getOrDefault("X-Amz-Date")
  valid_601859 = validateParameter(valid_601859, JString, required = false,
                                 default = nil)
  if valid_601859 != nil:
    section.add "X-Amz-Date", valid_601859
  var valid_601860 = header.getOrDefault("X-Amz-Credential")
  valid_601860 = validateParameter(valid_601860, JString, required = false,
                                 default = nil)
  if valid_601860 != nil:
    section.add "X-Amz-Credential", valid_601860
  var valid_601861 = header.getOrDefault("X-Amz-Security-Token")
  valid_601861 = validateParameter(valid_601861, JString, required = false,
                                 default = nil)
  if valid_601861 != nil:
    section.add "X-Amz-Security-Token", valid_601861
  var valid_601862 = header.getOrDefault("X-Amz-Algorithm")
  valid_601862 = validateParameter(valid_601862, JString, required = false,
                                 default = nil)
  if valid_601862 != nil:
    section.add "X-Amz-Algorithm", valid_601862
  var valid_601863 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601863 = validateParameter(valid_601863, JString, required = false,
                                 default = nil)
  if valid_601863 != nil:
    section.add "X-Amz-SignedHeaders", valid_601863
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601886: Call_AcceptCertificateTransfer_601727; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ## 
  let valid = call_601886.validator(path, query, header, formData, body)
  let scheme = call_601886.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601886.url(scheme.get, call_601886.host, call_601886.base,
                         call_601886.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601886, url, valid)

proc call*(call_601957: Call_AcceptCertificateTransfer_601727;
          certificateId: string; setAsActive: bool = false): Recallable =
  ## acceptCertificateTransfer
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_601958 = newJObject()
  var query_601960 = newJObject()
  add(query_601960, "setAsActive", newJBool(setAsActive))
  add(path_601958, "certificateId", newJString(certificateId))
  result = call_601957.call(path_601958, query_601960, nil, nil, nil)

var acceptCertificateTransfer* = Call_AcceptCertificateTransfer_601727(
    name: "acceptCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/accept-certificate-transfer/{certificateId}",
    validator: validate_AcceptCertificateTransfer_601728, base: "/",
    url: url_AcceptCertificateTransfer_601729,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_AddThingToBillingGroup_601999 = ref object of OpenApiRestCall_601389
proc url_AddThingToBillingGroup_602001(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_AddThingToBillingGroup_602000(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a thing to a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602002 = header.getOrDefault("X-Amz-Signature")
  valid_602002 = validateParameter(valid_602002, JString, required = false,
                                 default = nil)
  if valid_602002 != nil:
    section.add "X-Amz-Signature", valid_602002
  var valid_602003 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602003 = validateParameter(valid_602003, JString, required = false,
                                 default = nil)
  if valid_602003 != nil:
    section.add "X-Amz-Content-Sha256", valid_602003
  var valid_602004 = header.getOrDefault("X-Amz-Date")
  valid_602004 = validateParameter(valid_602004, JString, required = false,
                                 default = nil)
  if valid_602004 != nil:
    section.add "X-Amz-Date", valid_602004
  var valid_602005 = header.getOrDefault("X-Amz-Credential")
  valid_602005 = validateParameter(valid_602005, JString, required = false,
                                 default = nil)
  if valid_602005 != nil:
    section.add "X-Amz-Credential", valid_602005
  var valid_602006 = header.getOrDefault("X-Amz-Security-Token")
  valid_602006 = validateParameter(valid_602006, JString, required = false,
                                 default = nil)
  if valid_602006 != nil:
    section.add "X-Amz-Security-Token", valid_602006
  var valid_602007 = header.getOrDefault("X-Amz-Algorithm")
  valid_602007 = validateParameter(valid_602007, JString, required = false,
                                 default = nil)
  if valid_602007 != nil:
    section.add "X-Amz-Algorithm", valid_602007
  var valid_602008 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602008 = validateParameter(valid_602008, JString, required = false,
                                 default = nil)
  if valid_602008 != nil:
    section.add "X-Amz-SignedHeaders", valid_602008
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602010: Call_AddThingToBillingGroup_601999; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a thing to a billing group.
  ## 
  let valid = call_602010.validator(path, query, header, formData, body)
  let scheme = call_602010.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602010.url(scheme.get, call_602010.host, call_602010.base,
                         call_602010.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602010, url, valid)

proc call*(call_602011: Call_AddThingToBillingGroup_601999; body: JsonNode): Recallable =
  ## addThingToBillingGroup
  ## Adds a thing to a billing group.
  ##   body: JObject (required)
  var body_602012 = newJObject()
  if body != nil:
    body_602012 = body
  result = call_602011.call(nil, nil, nil, nil, body_602012)

var addThingToBillingGroup* = Call_AddThingToBillingGroup_601999(
    name: "addThingToBillingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/billing-groups/addThingToBillingGroup",
    validator: validate_AddThingToBillingGroup_602000, base: "/",
    url: url_AddThingToBillingGroup_602001, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AddThingToThingGroup_602013 = ref object of OpenApiRestCall_601389
proc url_AddThingToThingGroup_602015(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_AddThingToThingGroup_602014(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a thing to a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602016 = header.getOrDefault("X-Amz-Signature")
  valid_602016 = validateParameter(valid_602016, JString, required = false,
                                 default = nil)
  if valid_602016 != nil:
    section.add "X-Amz-Signature", valid_602016
  var valid_602017 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602017 = validateParameter(valid_602017, JString, required = false,
                                 default = nil)
  if valid_602017 != nil:
    section.add "X-Amz-Content-Sha256", valid_602017
  var valid_602018 = header.getOrDefault("X-Amz-Date")
  valid_602018 = validateParameter(valid_602018, JString, required = false,
                                 default = nil)
  if valid_602018 != nil:
    section.add "X-Amz-Date", valid_602018
  var valid_602019 = header.getOrDefault("X-Amz-Credential")
  valid_602019 = validateParameter(valid_602019, JString, required = false,
                                 default = nil)
  if valid_602019 != nil:
    section.add "X-Amz-Credential", valid_602019
  var valid_602020 = header.getOrDefault("X-Amz-Security-Token")
  valid_602020 = validateParameter(valid_602020, JString, required = false,
                                 default = nil)
  if valid_602020 != nil:
    section.add "X-Amz-Security-Token", valid_602020
  var valid_602021 = header.getOrDefault("X-Amz-Algorithm")
  valid_602021 = validateParameter(valid_602021, JString, required = false,
                                 default = nil)
  if valid_602021 != nil:
    section.add "X-Amz-Algorithm", valid_602021
  var valid_602022 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602022 = validateParameter(valid_602022, JString, required = false,
                                 default = nil)
  if valid_602022 != nil:
    section.add "X-Amz-SignedHeaders", valid_602022
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602024: Call_AddThingToThingGroup_602013; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a thing to a thing group.
  ## 
  let valid = call_602024.validator(path, query, header, formData, body)
  let scheme = call_602024.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602024.url(scheme.get, call_602024.host, call_602024.base,
                         call_602024.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602024, url, valid)

proc call*(call_602025: Call_AddThingToThingGroup_602013; body: JsonNode): Recallable =
  ## addThingToThingGroup
  ## Adds a thing to a thing group.
  ##   body: JObject (required)
  var body_602026 = newJObject()
  if body != nil:
    body_602026 = body
  result = call_602025.call(nil, nil, nil, nil, body_602026)

var addThingToThingGroup* = Call_AddThingToThingGroup_602013(
    name: "addThingToThingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/addThingToThingGroup",
    validator: validate_AddThingToThingGroup_602014, base: "/",
    url: url_AddThingToThingGroup_602015, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AssociateTargetsWithJob_602027 = ref object of OpenApiRestCall_601389
proc url_AssociateTargetsWithJob_602029(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/targets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AssociateTargetsWithJob_602028(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_602030 = path.getOrDefault("jobId")
  valid_602030 = validateParameter(valid_602030, JString, required = true,
                                 default = nil)
  if valid_602030 != nil:
    section.add "jobId", valid_602030
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602031 = header.getOrDefault("X-Amz-Signature")
  valid_602031 = validateParameter(valid_602031, JString, required = false,
                                 default = nil)
  if valid_602031 != nil:
    section.add "X-Amz-Signature", valid_602031
  var valid_602032 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602032 = validateParameter(valid_602032, JString, required = false,
                                 default = nil)
  if valid_602032 != nil:
    section.add "X-Amz-Content-Sha256", valid_602032
  var valid_602033 = header.getOrDefault("X-Amz-Date")
  valid_602033 = validateParameter(valid_602033, JString, required = false,
                                 default = nil)
  if valid_602033 != nil:
    section.add "X-Amz-Date", valid_602033
  var valid_602034 = header.getOrDefault("X-Amz-Credential")
  valid_602034 = validateParameter(valid_602034, JString, required = false,
                                 default = nil)
  if valid_602034 != nil:
    section.add "X-Amz-Credential", valid_602034
  var valid_602035 = header.getOrDefault("X-Amz-Security-Token")
  valid_602035 = validateParameter(valid_602035, JString, required = false,
                                 default = nil)
  if valid_602035 != nil:
    section.add "X-Amz-Security-Token", valid_602035
  var valid_602036 = header.getOrDefault("X-Amz-Algorithm")
  valid_602036 = validateParameter(valid_602036, JString, required = false,
                                 default = nil)
  if valid_602036 != nil:
    section.add "X-Amz-Algorithm", valid_602036
  var valid_602037 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602037 = validateParameter(valid_602037, JString, required = false,
                                 default = nil)
  if valid_602037 != nil:
    section.add "X-Amz-SignedHeaders", valid_602037
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602039: Call_AssociateTargetsWithJob_602027; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ## 
  let valid = call_602039.validator(path, query, header, formData, body)
  let scheme = call_602039.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602039.url(scheme.get, call_602039.host, call_602039.base,
                         call_602039.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602039, url, valid)

proc call*(call_602040: Call_AssociateTargetsWithJob_602027; jobId: string;
          body: JsonNode): Recallable =
  ## associateTargetsWithJob
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   body: JObject (required)
  var path_602041 = newJObject()
  var body_602042 = newJObject()
  add(path_602041, "jobId", newJString(jobId))
  if body != nil:
    body_602042 = body
  result = call_602040.call(path_602041, nil, nil, nil, body_602042)

var associateTargetsWithJob* = Call_AssociateTargetsWithJob_602027(
    name: "associateTargetsWithJob", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/jobs/{jobId}/targets",
    validator: validate_AssociateTargetsWithJob_602028, base: "/",
    url: url_AssociateTargetsWithJob_602029, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachPolicy_602043 = ref object of OpenApiRestCall_601389
proc url_AttachPolicy_602045(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/target-policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachPolicy_602044(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Attaches a policy to the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to attach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_602046 = path.getOrDefault("policyName")
  valid_602046 = validateParameter(valid_602046, JString, required = true,
                                 default = nil)
  if valid_602046 != nil:
    section.add "policyName", valid_602046
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602047 = header.getOrDefault("X-Amz-Signature")
  valid_602047 = validateParameter(valid_602047, JString, required = false,
                                 default = nil)
  if valid_602047 != nil:
    section.add "X-Amz-Signature", valid_602047
  var valid_602048 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602048 = validateParameter(valid_602048, JString, required = false,
                                 default = nil)
  if valid_602048 != nil:
    section.add "X-Amz-Content-Sha256", valid_602048
  var valid_602049 = header.getOrDefault("X-Amz-Date")
  valid_602049 = validateParameter(valid_602049, JString, required = false,
                                 default = nil)
  if valid_602049 != nil:
    section.add "X-Amz-Date", valid_602049
  var valid_602050 = header.getOrDefault("X-Amz-Credential")
  valid_602050 = validateParameter(valid_602050, JString, required = false,
                                 default = nil)
  if valid_602050 != nil:
    section.add "X-Amz-Credential", valid_602050
  var valid_602051 = header.getOrDefault("X-Amz-Security-Token")
  valid_602051 = validateParameter(valid_602051, JString, required = false,
                                 default = nil)
  if valid_602051 != nil:
    section.add "X-Amz-Security-Token", valid_602051
  var valid_602052 = header.getOrDefault("X-Amz-Algorithm")
  valid_602052 = validateParameter(valid_602052, JString, required = false,
                                 default = nil)
  if valid_602052 != nil:
    section.add "X-Amz-Algorithm", valid_602052
  var valid_602053 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602053 = validateParameter(valid_602053, JString, required = false,
                                 default = nil)
  if valid_602053 != nil:
    section.add "X-Amz-SignedHeaders", valid_602053
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602055: Call_AttachPolicy_602043; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Attaches a policy to the specified target.
  ## 
  let valid = call_602055.validator(path, query, header, formData, body)
  let scheme = call_602055.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602055.url(scheme.get, call_602055.host, call_602055.base,
                         call_602055.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602055, url, valid)

proc call*(call_602056: Call_AttachPolicy_602043; policyName: string; body: JsonNode): Recallable =
  ## attachPolicy
  ## Attaches a policy to the specified target.
  ##   policyName: string (required)
  ##             : The name of the policy to attach.
  ##   body: JObject (required)
  var path_602057 = newJObject()
  var body_602058 = newJObject()
  add(path_602057, "policyName", newJString(policyName))
  if body != nil:
    body_602058 = body
  result = call_602056.call(path_602057, nil, nil, nil, body_602058)

var attachPolicy* = Call_AttachPolicy_602043(name: "attachPolicy",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/target-policies/{policyName}", validator: validate_AttachPolicy_602044,
    base: "/", url: url_AttachPolicy_602045, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachPolicy_602059 = ref object of OpenApiRestCall_601389
proc url_DetachPolicy_602061(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/target-policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachPolicy_602060(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Detaches a policy from the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy to detach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_602062 = path.getOrDefault("policyName")
  valid_602062 = validateParameter(valid_602062, JString, required = true,
                                 default = nil)
  if valid_602062 != nil:
    section.add "policyName", valid_602062
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602063 = header.getOrDefault("X-Amz-Signature")
  valid_602063 = validateParameter(valid_602063, JString, required = false,
                                 default = nil)
  if valid_602063 != nil:
    section.add "X-Amz-Signature", valid_602063
  var valid_602064 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602064 = validateParameter(valid_602064, JString, required = false,
                                 default = nil)
  if valid_602064 != nil:
    section.add "X-Amz-Content-Sha256", valid_602064
  var valid_602065 = header.getOrDefault("X-Amz-Date")
  valid_602065 = validateParameter(valid_602065, JString, required = false,
                                 default = nil)
  if valid_602065 != nil:
    section.add "X-Amz-Date", valid_602065
  var valid_602066 = header.getOrDefault("X-Amz-Credential")
  valid_602066 = validateParameter(valid_602066, JString, required = false,
                                 default = nil)
  if valid_602066 != nil:
    section.add "X-Amz-Credential", valid_602066
  var valid_602067 = header.getOrDefault("X-Amz-Security-Token")
  valid_602067 = validateParameter(valid_602067, JString, required = false,
                                 default = nil)
  if valid_602067 != nil:
    section.add "X-Amz-Security-Token", valid_602067
  var valid_602068 = header.getOrDefault("X-Amz-Algorithm")
  valid_602068 = validateParameter(valid_602068, JString, required = false,
                                 default = nil)
  if valid_602068 != nil:
    section.add "X-Amz-Algorithm", valid_602068
  var valid_602069 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602069 = validateParameter(valid_602069, JString, required = false,
                                 default = nil)
  if valid_602069 != nil:
    section.add "X-Amz-SignedHeaders", valid_602069
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602071: Call_DetachPolicy_602059; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Detaches a policy from the specified target.
  ## 
  let valid = call_602071.validator(path, query, header, formData, body)
  let scheme = call_602071.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602071.url(scheme.get, call_602071.host, call_602071.base,
                         call_602071.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602071, url, valid)

proc call*(call_602072: Call_DetachPolicy_602059; policyName: string; body: JsonNode): Recallable =
  ## detachPolicy
  ## Detaches a policy from the specified target.
  ##   policyName: string (required)
  ##             : The policy to detach.
  ##   body: JObject (required)
  var path_602073 = newJObject()
  var body_602074 = newJObject()
  add(path_602073, "policyName", newJString(policyName))
  if body != nil:
    body_602074 = body
  result = call_602072.call(path_602073, nil, nil, nil, body_602074)

var detachPolicy* = Call_DetachPolicy_602059(name: "detachPolicy",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/target-policies/{policyName}", validator: validate_DetachPolicy_602060,
    base: "/", url: url_DetachPolicy_602061, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachPrincipalPolicy_602075 = ref object of OpenApiRestCall_601389
proc url_AttachPrincipalPolicy_602077(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/principal-policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "#x-amzn-iot-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachPrincipalPolicy_602076(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_602078 = path.getOrDefault("policyName")
  valid_602078 = validateParameter(valid_602078, JString, required = true,
                                 default = nil)
  if valid_602078 != nil:
    section.add "policyName", valid_602078
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602079 = header.getOrDefault("X-Amz-Signature")
  valid_602079 = validateParameter(valid_602079, JString, required = false,
                                 default = nil)
  if valid_602079 != nil:
    section.add "X-Amz-Signature", valid_602079
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_602080 = header.getOrDefault("x-amzn-iot-principal")
  valid_602080 = validateParameter(valid_602080, JString, required = true,
                                 default = nil)
  if valid_602080 != nil:
    section.add "x-amzn-iot-principal", valid_602080
  var valid_602081 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602081 = validateParameter(valid_602081, JString, required = false,
                                 default = nil)
  if valid_602081 != nil:
    section.add "X-Amz-Content-Sha256", valid_602081
  var valid_602082 = header.getOrDefault("X-Amz-Date")
  valid_602082 = validateParameter(valid_602082, JString, required = false,
                                 default = nil)
  if valid_602082 != nil:
    section.add "X-Amz-Date", valid_602082
  var valid_602083 = header.getOrDefault("X-Amz-Credential")
  valid_602083 = validateParameter(valid_602083, JString, required = false,
                                 default = nil)
  if valid_602083 != nil:
    section.add "X-Amz-Credential", valid_602083
  var valid_602084 = header.getOrDefault("X-Amz-Security-Token")
  valid_602084 = validateParameter(valid_602084, JString, required = false,
                                 default = nil)
  if valid_602084 != nil:
    section.add "X-Amz-Security-Token", valid_602084
  var valid_602085 = header.getOrDefault("X-Amz-Algorithm")
  valid_602085 = validateParameter(valid_602085, JString, required = false,
                                 default = nil)
  if valid_602085 != nil:
    section.add "X-Amz-Algorithm", valid_602085
  var valid_602086 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602086 = validateParameter(valid_602086, JString, required = false,
                                 default = nil)
  if valid_602086 != nil:
    section.add "X-Amz-SignedHeaders", valid_602086
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602087: Call_AttachPrincipalPolicy_602075; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ## 
  let valid = call_602087.validator(path, query, header, formData, body)
  let scheme = call_602087.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602087.url(scheme.get, call_602087.host, call_602087.base,
                         call_602087.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602087, url, valid)

proc call*(call_602088: Call_AttachPrincipalPolicy_602075; policyName: string): Recallable =
  ## attachPrincipalPolicy
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ##   policyName: string (required)
  ##             : The policy name.
  var path_602089 = newJObject()
  add(path_602089, "policyName", newJString(policyName))
  result = call_602088.call(path_602089, nil, nil, nil, nil)

var attachPrincipalPolicy* = Call_AttachPrincipalPolicy_602075(
    name: "attachPrincipalPolicy", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/principal-policies/{policyName}#x-amzn-iot-principal",
    validator: validate_AttachPrincipalPolicy_602076, base: "/",
    url: url_AttachPrincipalPolicy_602077, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachPrincipalPolicy_602090 = ref object of OpenApiRestCall_601389
proc url_DetachPrincipalPolicy_602092(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/principal-policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "#x-amzn-iot-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachPrincipalPolicy_602091(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to detach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_602093 = path.getOrDefault("policyName")
  valid_602093 = validateParameter(valid_602093, JString, required = true,
                                 default = nil)
  if valid_602093 != nil:
    section.add "policyName", valid_602093
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : <p>The principal.</p> <p>If the principal is a certificate, specify the certificate ARN. If the principal is an Amazon Cognito identity, specify the identity ID.</p>
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602094 = header.getOrDefault("X-Amz-Signature")
  valid_602094 = validateParameter(valid_602094, JString, required = false,
                                 default = nil)
  if valid_602094 != nil:
    section.add "X-Amz-Signature", valid_602094
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_602095 = header.getOrDefault("x-amzn-iot-principal")
  valid_602095 = validateParameter(valid_602095, JString, required = true,
                                 default = nil)
  if valid_602095 != nil:
    section.add "x-amzn-iot-principal", valid_602095
  var valid_602096 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602096 = validateParameter(valid_602096, JString, required = false,
                                 default = nil)
  if valid_602096 != nil:
    section.add "X-Amz-Content-Sha256", valid_602096
  var valid_602097 = header.getOrDefault("X-Amz-Date")
  valid_602097 = validateParameter(valid_602097, JString, required = false,
                                 default = nil)
  if valid_602097 != nil:
    section.add "X-Amz-Date", valid_602097
  var valid_602098 = header.getOrDefault("X-Amz-Credential")
  valid_602098 = validateParameter(valid_602098, JString, required = false,
                                 default = nil)
  if valid_602098 != nil:
    section.add "X-Amz-Credential", valid_602098
  var valid_602099 = header.getOrDefault("X-Amz-Security-Token")
  valid_602099 = validateParameter(valid_602099, JString, required = false,
                                 default = nil)
  if valid_602099 != nil:
    section.add "X-Amz-Security-Token", valid_602099
  var valid_602100 = header.getOrDefault("X-Amz-Algorithm")
  valid_602100 = validateParameter(valid_602100, JString, required = false,
                                 default = nil)
  if valid_602100 != nil:
    section.add "X-Amz-Algorithm", valid_602100
  var valid_602101 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602101 = validateParameter(valid_602101, JString, required = false,
                                 default = nil)
  if valid_602101 != nil:
    section.add "X-Amz-SignedHeaders", valid_602101
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602102: Call_DetachPrincipalPolicy_602090; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ## 
  let valid = call_602102.validator(path, query, header, formData, body)
  let scheme = call_602102.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602102.url(scheme.get, call_602102.host, call_602102.base,
                         call_602102.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602102, url, valid)

proc call*(call_602103: Call_DetachPrincipalPolicy_602090; policyName: string): Recallable =
  ## detachPrincipalPolicy
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ##   policyName: string (required)
  ##             : The name of the policy to detach.
  var path_602104 = newJObject()
  add(path_602104, "policyName", newJString(policyName))
  result = call_602103.call(path_602104, nil, nil, nil, nil)

var detachPrincipalPolicy* = Call_DetachPrincipalPolicy_602090(
    name: "detachPrincipalPolicy", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/principal-policies/{policyName}#x-amzn-iot-principal",
    validator: validate_DetachPrincipalPolicy_602091, base: "/",
    url: url_DetachPrincipalPolicy_602092, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachSecurityProfile_602105 = ref object of OpenApiRestCall_601389
proc url_AttachSecurityProfile_602107(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"), (
        kind: ConstantSegment, value: "/targets#securityProfileTargetArn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachSecurityProfile_602106(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile that is attached.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_602108 = path.getOrDefault("securityProfileName")
  valid_602108 = validateParameter(valid_602108, JString, required = true,
                                 default = nil)
  if valid_602108 != nil:
    section.add "securityProfileName", valid_602108
  result.add "path", section
  ## parameters in `query` object:
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the target (thing group) to which the security profile is attached.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_602109 = query.getOrDefault("securityProfileTargetArn")
  valid_602109 = validateParameter(valid_602109, JString, required = true,
                                 default = nil)
  if valid_602109 != nil:
    section.add "securityProfileTargetArn", valid_602109
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602110 = header.getOrDefault("X-Amz-Signature")
  valid_602110 = validateParameter(valid_602110, JString, required = false,
                                 default = nil)
  if valid_602110 != nil:
    section.add "X-Amz-Signature", valid_602110
  var valid_602111 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602111 = validateParameter(valid_602111, JString, required = false,
                                 default = nil)
  if valid_602111 != nil:
    section.add "X-Amz-Content-Sha256", valid_602111
  var valid_602112 = header.getOrDefault("X-Amz-Date")
  valid_602112 = validateParameter(valid_602112, JString, required = false,
                                 default = nil)
  if valid_602112 != nil:
    section.add "X-Amz-Date", valid_602112
  var valid_602113 = header.getOrDefault("X-Amz-Credential")
  valid_602113 = validateParameter(valid_602113, JString, required = false,
                                 default = nil)
  if valid_602113 != nil:
    section.add "X-Amz-Credential", valid_602113
  var valid_602114 = header.getOrDefault("X-Amz-Security-Token")
  valid_602114 = validateParameter(valid_602114, JString, required = false,
                                 default = nil)
  if valid_602114 != nil:
    section.add "X-Amz-Security-Token", valid_602114
  var valid_602115 = header.getOrDefault("X-Amz-Algorithm")
  valid_602115 = validateParameter(valid_602115, JString, required = false,
                                 default = nil)
  if valid_602115 != nil:
    section.add "X-Amz-Algorithm", valid_602115
  var valid_602116 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602116 = validateParameter(valid_602116, JString, required = false,
                                 default = nil)
  if valid_602116 != nil:
    section.add "X-Amz-SignedHeaders", valid_602116
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602117: Call_AttachSecurityProfile_602105; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ## 
  let valid = call_602117.validator(path, query, header, formData, body)
  let scheme = call_602117.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602117.url(scheme.get, call_602117.host, call_602117.base,
                         call_602117.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602117, url, valid)

proc call*(call_602118: Call_AttachSecurityProfile_602105;
          securityProfileTargetArn: string; securityProfileName: string): Recallable =
  ## attachSecurityProfile
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the target (thing group) to which the security profile is attached.
  ##   securityProfileName: string (required)
  ##                      : The security profile that is attached.
  var path_602119 = newJObject()
  var query_602120 = newJObject()
  add(query_602120, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(path_602119, "securityProfileName", newJString(securityProfileName))
  result = call_602118.call(path_602119, query_602120, nil, nil, nil)

var attachSecurityProfile* = Call_AttachSecurityProfile_602105(
    name: "attachSecurityProfile", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}/targets#securityProfileTargetArn",
    validator: validate_AttachSecurityProfile_602106, base: "/",
    url: url_AttachSecurityProfile_602107, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachSecurityProfile_602121 = ref object of OpenApiRestCall_601389
proc url_DetachSecurityProfile_602123(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"), (
        kind: ConstantSegment, value: "/targets#securityProfileTargetArn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachSecurityProfile_602122(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile that is detached.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_602124 = path.getOrDefault("securityProfileName")
  valid_602124 = validateParameter(valid_602124, JString, required = true,
                                 default = nil)
  if valid_602124 != nil:
    section.add "securityProfileName", valid_602124
  result.add "path", section
  ## parameters in `query` object:
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the thing group from which the security profile is detached.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_602125 = query.getOrDefault("securityProfileTargetArn")
  valid_602125 = validateParameter(valid_602125, JString, required = true,
                                 default = nil)
  if valid_602125 != nil:
    section.add "securityProfileTargetArn", valid_602125
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602126 = header.getOrDefault("X-Amz-Signature")
  valid_602126 = validateParameter(valid_602126, JString, required = false,
                                 default = nil)
  if valid_602126 != nil:
    section.add "X-Amz-Signature", valid_602126
  var valid_602127 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602127 = validateParameter(valid_602127, JString, required = false,
                                 default = nil)
  if valid_602127 != nil:
    section.add "X-Amz-Content-Sha256", valid_602127
  var valid_602128 = header.getOrDefault("X-Amz-Date")
  valid_602128 = validateParameter(valid_602128, JString, required = false,
                                 default = nil)
  if valid_602128 != nil:
    section.add "X-Amz-Date", valid_602128
  var valid_602129 = header.getOrDefault("X-Amz-Credential")
  valid_602129 = validateParameter(valid_602129, JString, required = false,
                                 default = nil)
  if valid_602129 != nil:
    section.add "X-Amz-Credential", valid_602129
  var valid_602130 = header.getOrDefault("X-Amz-Security-Token")
  valid_602130 = validateParameter(valid_602130, JString, required = false,
                                 default = nil)
  if valid_602130 != nil:
    section.add "X-Amz-Security-Token", valid_602130
  var valid_602131 = header.getOrDefault("X-Amz-Algorithm")
  valid_602131 = validateParameter(valid_602131, JString, required = false,
                                 default = nil)
  if valid_602131 != nil:
    section.add "X-Amz-Algorithm", valid_602131
  var valid_602132 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602132 = validateParameter(valid_602132, JString, required = false,
                                 default = nil)
  if valid_602132 != nil:
    section.add "X-Amz-SignedHeaders", valid_602132
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602133: Call_DetachSecurityProfile_602121; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ## 
  let valid = call_602133.validator(path, query, header, formData, body)
  let scheme = call_602133.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602133.url(scheme.get, call_602133.host, call_602133.base,
                         call_602133.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602133, url, valid)

proc call*(call_602134: Call_DetachSecurityProfile_602121;
          securityProfileTargetArn: string; securityProfileName: string): Recallable =
  ## detachSecurityProfile
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the thing group from which the security profile is detached.
  ##   securityProfileName: string (required)
  ##                      : The security profile that is detached.
  var path_602135 = newJObject()
  var query_602136 = newJObject()
  add(query_602136, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(path_602135, "securityProfileName", newJString(securityProfileName))
  result = call_602134.call(path_602135, query_602136, nil, nil, nil)

var detachSecurityProfile* = Call_DetachSecurityProfile_602121(
    name: "detachSecurityProfile", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}/targets#securityProfileTargetArn",
    validator: validate_DetachSecurityProfile_602122, base: "/",
    url: url_DetachSecurityProfile_602123, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachThingPrincipal_602137 = ref object of OpenApiRestCall_601389
proc url_AttachThingPrincipal_602139(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals#x-amzn-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachThingPrincipal_602138(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_602140 = path.getOrDefault("thingName")
  valid_602140 = validateParameter(valid_602140, JString, required = true,
                                 default = nil)
  if valid_602140 != nil:
    section.add "thingName", valid_602140
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602141 = header.getOrDefault("X-Amz-Signature")
  valid_602141 = validateParameter(valid_602141, JString, required = false,
                                 default = nil)
  if valid_602141 != nil:
    section.add "X-Amz-Signature", valid_602141
  var valid_602142 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602142 = validateParameter(valid_602142, JString, required = false,
                                 default = nil)
  if valid_602142 != nil:
    section.add "X-Amz-Content-Sha256", valid_602142
  var valid_602143 = header.getOrDefault("X-Amz-Date")
  valid_602143 = validateParameter(valid_602143, JString, required = false,
                                 default = nil)
  if valid_602143 != nil:
    section.add "X-Amz-Date", valid_602143
  var valid_602144 = header.getOrDefault("X-Amz-Credential")
  valid_602144 = validateParameter(valid_602144, JString, required = false,
                                 default = nil)
  if valid_602144 != nil:
    section.add "X-Amz-Credential", valid_602144
  var valid_602145 = header.getOrDefault("X-Amz-Security-Token")
  valid_602145 = validateParameter(valid_602145, JString, required = false,
                                 default = nil)
  if valid_602145 != nil:
    section.add "X-Amz-Security-Token", valid_602145
  var valid_602146 = header.getOrDefault("X-Amz-Algorithm")
  valid_602146 = validateParameter(valid_602146, JString, required = false,
                                 default = nil)
  if valid_602146 != nil:
    section.add "X-Amz-Algorithm", valid_602146
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_602147 = header.getOrDefault("x-amzn-principal")
  valid_602147 = validateParameter(valid_602147, JString, required = true,
                                 default = nil)
  if valid_602147 != nil:
    section.add "x-amzn-principal", valid_602147
  var valid_602148 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602148 = validateParameter(valid_602148, JString, required = false,
                                 default = nil)
  if valid_602148 != nil:
    section.add "X-Amz-SignedHeaders", valid_602148
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602149: Call_AttachThingPrincipal_602137; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  let valid = call_602149.validator(path, query, header, formData, body)
  let scheme = call_602149.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602149.url(scheme.get, call_602149.host, call_602149.base,
                         call_602149.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602149, url, valid)

proc call*(call_602150: Call_AttachThingPrincipal_602137; thingName: string): Recallable =
  ## attachThingPrincipal
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_602151 = newJObject()
  add(path_602151, "thingName", newJString(thingName))
  result = call_602150.call(path_602151, nil, nil, nil, nil)

var attachThingPrincipal* = Call_AttachThingPrincipal_602137(
    name: "attachThingPrincipal", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/things/{thingName}/principals#x-amzn-principal",
    validator: validate_AttachThingPrincipal_602138, base: "/",
    url: url_AttachThingPrincipal_602139, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachThingPrincipal_602152 = ref object of OpenApiRestCall_601389
proc url_DetachThingPrincipal_602154(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals#x-amzn-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachThingPrincipal_602153(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_602155 = path.getOrDefault("thingName")
  valid_602155 = validateParameter(valid_602155, JString, required = true,
                                 default = nil)
  if valid_602155 != nil:
    section.add "thingName", valid_602155
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602156 = header.getOrDefault("X-Amz-Signature")
  valid_602156 = validateParameter(valid_602156, JString, required = false,
                                 default = nil)
  if valid_602156 != nil:
    section.add "X-Amz-Signature", valid_602156
  var valid_602157 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602157 = validateParameter(valid_602157, JString, required = false,
                                 default = nil)
  if valid_602157 != nil:
    section.add "X-Amz-Content-Sha256", valid_602157
  var valid_602158 = header.getOrDefault("X-Amz-Date")
  valid_602158 = validateParameter(valid_602158, JString, required = false,
                                 default = nil)
  if valid_602158 != nil:
    section.add "X-Amz-Date", valid_602158
  var valid_602159 = header.getOrDefault("X-Amz-Credential")
  valid_602159 = validateParameter(valid_602159, JString, required = false,
                                 default = nil)
  if valid_602159 != nil:
    section.add "X-Amz-Credential", valid_602159
  var valid_602160 = header.getOrDefault("X-Amz-Security-Token")
  valid_602160 = validateParameter(valid_602160, JString, required = false,
                                 default = nil)
  if valid_602160 != nil:
    section.add "X-Amz-Security-Token", valid_602160
  var valid_602161 = header.getOrDefault("X-Amz-Algorithm")
  valid_602161 = validateParameter(valid_602161, JString, required = false,
                                 default = nil)
  if valid_602161 != nil:
    section.add "X-Amz-Algorithm", valid_602161
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_602162 = header.getOrDefault("x-amzn-principal")
  valid_602162 = validateParameter(valid_602162, JString, required = true,
                                 default = nil)
  if valid_602162 != nil:
    section.add "x-amzn-principal", valid_602162
  var valid_602163 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602163 = validateParameter(valid_602163, JString, required = false,
                                 default = nil)
  if valid_602163 != nil:
    section.add "X-Amz-SignedHeaders", valid_602163
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602164: Call_DetachThingPrincipal_602152; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ## 
  let valid = call_602164.validator(path, query, header, formData, body)
  let scheme = call_602164.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602164.url(scheme.get, call_602164.host, call_602164.base,
                         call_602164.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602164, url, valid)

proc call*(call_602165: Call_DetachThingPrincipal_602152; thingName: string): Recallable =
  ## detachThingPrincipal
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_602166 = newJObject()
  add(path_602166, "thingName", newJString(thingName))
  result = call_602165.call(path_602166, nil, nil, nil, nil)

var detachThingPrincipal* = Call_DetachThingPrincipal_602152(
    name: "detachThingPrincipal", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/things/{thingName}/principals#x-amzn-principal",
    validator: validate_DetachThingPrincipal_602153, base: "/",
    url: url_DetachThingPrincipal_602154, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelAuditMitigationActionsTask_602167 = ref object of OpenApiRestCall_601389
proc url_CancelAuditMitigationActionsTask_602169(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelAuditMitigationActionsTask_602168(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The unique identifier for the task that you want to cancel. 
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_602170 = path.getOrDefault("taskId")
  valid_602170 = validateParameter(valid_602170, JString, required = true,
                                 default = nil)
  if valid_602170 != nil:
    section.add "taskId", valid_602170
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602171 = header.getOrDefault("X-Amz-Signature")
  valid_602171 = validateParameter(valid_602171, JString, required = false,
                                 default = nil)
  if valid_602171 != nil:
    section.add "X-Amz-Signature", valid_602171
  var valid_602172 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602172 = validateParameter(valid_602172, JString, required = false,
                                 default = nil)
  if valid_602172 != nil:
    section.add "X-Amz-Content-Sha256", valid_602172
  var valid_602173 = header.getOrDefault("X-Amz-Date")
  valid_602173 = validateParameter(valid_602173, JString, required = false,
                                 default = nil)
  if valid_602173 != nil:
    section.add "X-Amz-Date", valid_602173
  var valid_602174 = header.getOrDefault("X-Amz-Credential")
  valid_602174 = validateParameter(valid_602174, JString, required = false,
                                 default = nil)
  if valid_602174 != nil:
    section.add "X-Amz-Credential", valid_602174
  var valid_602175 = header.getOrDefault("X-Amz-Security-Token")
  valid_602175 = validateParameter(valid_602175, JString, required = false,
                                 default = nil)
  if valid_602175 != nil:
    section.add "X-Amz-Security-Token", valid_602175
  var valid_602176 = header.getOrDefault("X-Amz-Algorithm")
  valid_602176 = validateParameter(valid_602176, JString, required = false,
                                 default = nil)
  if valid_602176 != nil:
    section.add "X-Amz-Algorithm", valid_602176
  var valid_602177 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602177 = validateParameter(valid_602177, JString, required = false,
                                 default = nil)
  if valid_602177 != nil:
    section.add "X-Amz-SignedHeaders", valid_602177
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602178: Call_CancelAuditMitigationActionsTask_602167;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ## 
  let valid = call_602178.validator(path, query, header, formData, body)
  let scheme = call_602178.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602178.url(scheme.get, call_602178.host, call_602178.base,
                         call_602178.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602178, url, valid)

proc call*(call_602179: Call_CancelAuditMitigationActionsTask_602167;
          taskId: string): Recallable =
  ## cancelAuditMitigationActionsTask
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ##   taskId: string (required)
  ##         : The unique identifier for the task that you want to cancel. 
  var path_602180 = newJObject()
  add(path_602180, "taskId", newJString(taskId))
  result = call_602179.call(path_602180, nil, nil, nil, nil)

var cancelAuditMitigationActionsTask* = Call_CancelAuditMitigationActionsTask_602167(
    name: "cancelAuditMitigationActionsTask", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/tasks/{taskId}/cancel",
    validator: validate_CancelAuditMitigationActionsTask_602168, base: "/",
    url: url_CancelAuditMitigationActionsTask_602169,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelAuditTask_602181 = ref object of OpenApiRestCall_601389
proc url_CancelAuditTask_602183(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelAuditTask_602182(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_602184 = path.getOrDefault("taskId")
  valid_602184 = validateParameter(valid_602184, JString, required = true,
                                 default = nil)
  if valid_602184 != nil:
    section.add "taskId", valid_602184
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602185 = header.getOrDefault("X-Amz-Signature")
  valid_602185 = validateParameter(valid_602185, JString, required = false,
                                 default = nil)
  if valid_602185 != nil:
    section.add "X-Amz-Signature", valid_602185
  var valid_602186 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602186 = validateParameter(valid_602186, JString, required = false,
                                 default = nil)
  if valid_602186 != nil:
    section.add "X-Amz-Content-Sha256", valid_602186
  var valid_602187 = header.getOrDefault("X-Amz-Date")
  valid_602187 = validateParameter(valid_602187, JString, required = false,
                                 default = nil)
  if valid_602187 != nil:
    section.add "X-Amz-Date", valid_602187
  var valid_602188 = header.getOrDefault("X-Amz-Credential")
  valid_602188 = validateParameter(valid_602188, JString, required = false,
                                 default = nil)
  if valid_602188 != nil:
    section.add "X-Amz-Credential", valid_602188
  var valid_602189 = header.getOrDefault("X-Amz-Security-Token")
  valid_602189 = validateParameter(valid_602189, JString, required = false,
                                 default = nil)
  if valid_602189 != nil:
    section.add "X-Amz-Security-Token", valid_602189
  var valid_602190 = header.getOrDefault("X-Amz-Algorithm")
  valid_602190 = validateParameter(valid_602190, JString, required = false,
                                 default = nil)
  if valid_602190 != nil:
    section.add "X-Amz-Algorithm", valid_602190
  var valid_602191 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602191 = validateParameter(valid_602191, JString, required = false,
                                 default = nil)
  if valid_602191 != nil:
    section.add "X-Amz-SignedHeaders", valid_602191
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602192: Call_CancelAuditTask_602181; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ## 
  let valid = call_602192.validator(path, query, header, formData, body)
  let scheme = call_602192.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602192.url(scheme.get, call_602192.host, call_602192.base,
                         call_602192.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602192, url, valid)

proc call*(call_602193: Call_CancelAuditTask_602181; taskId: string): Recallable =
  ## cancelAuditTask
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ##   taskId: string (required)
  ##         : The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
  var path_602194 = newJObject()
  add(path_602194, "taskId", newJString(taskId))
  result = call_602193.call(path_602194, nil, nil, nil, nil)

var cancelAuditTask* = Call_CancelAuditTask_602181(name: "cancelAuditTask",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/audit/tasks/{taskId}/cancel", validator: validate_CancelAuditTask_602182,
    base: "/", url: url_CancelAuditTask_602183, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelCertificateTransfer_602195 = ref object of OpenApiRestCall_601389
proc url_CancelCertificateTransfer_602197(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cancel-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelCertificateTransfer_602196(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_602198 = path.getOrDefault("certificateId")
  valid_602198 = validateParameter(valid_602198, JString, required = true,
                                 default = nil)
  if valid_602198 != nil:
    section.add "certificateId", valid_602198
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602199 = header.getOrDefault("X-Amz-Signature")
  valid_602199 = validateParameter(valid_602199, JString, required = false,
                                 default = nil)
  if valid_602199 != nil:
    section.add "X-Amz-Signature", valid_602199
  var valid_602200 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602200 = validateParameter(valid_602200, JString, required = false,
                                 default = nil)
  if valid_602200 != nil:
    section.add "X-Amz-Content-Sha256", valid_602200
  var valid_602201 = header.getOrDefault("X-Amz-Date")
  valid_602201 = validateParameter(valid_602201, JString, required = false,
                                 default = nil)
  if valid_602201 != nil:
    section.add "X-Amz-Date", valid_602201
  var valid_602202 = header.getOrDefault("X-Amz-Credential")
  valid_602202 = validateParameter(valid_602202, JString, required = false,
                                 default = nil)
  if valid_602202 != nil:
    section.add "X-Amz-Credential", valid_602202
  var valid_602203 = header.getOrDefault("X-Amz-Security-Token")
  valid_602203 = validateParameter(valid_602203, JString, required = false,
                                 default = nil)
  if valid_602203 != nil:
    section.add "X-Amz-Security-Token", valid_602203
  var valid_602204 = header.getOrDefault("X-Amz-Algorithm")
  valid_602204 = validateParameter(valid_602204, JString, required = false,
                                 default = nil)
  if valid_602204 != nil:
    section.add "X-Amz-Algorithm", valid_602204
  var valid_602205 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602205 = validateParameter(valid_602205, JString, required = false,
                                 default = nil)
  if valid_602205 != nil:
    section.add "X-Amz-SignedHeaders", valid_602205
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602206: Call_CancelCertificateTransfer_602195; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ## 
  let valid = call_602206.validator(path, query, header, formData, body)
  let scheme = call_602206.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602206.url(scheme.get, call_602206.host, call_602206.base,
                         call_602206.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602206, url, valid)

proc call*(call_602207: Call_CancelCertificateTransfer_602195;
          certificateId: string): Recallable =
  ## cancelCertificateTransfer
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_602208 = newJObject()
  add(path_602208, "certificateId", newJString(certificateId))
  result = call_602207.call(path_602208, nil, nil, nil, nil)

var cancelCertificateTransfer* = Call_CancelCertificateTransfer_602195(
    name: "cancelCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/cancel-certificate-transfer/{certificateId}",
    validator: validate_CancelCertificateTransfer_602196, base: "/",
    url: url_CancelCertificateTransfer_602197,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelJob_602209 = ref object of OpenApiRestCall_601389
proc url_CancelJob_602211(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelJob_602210(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_602212 = path.getOrDefault("jobId")
  valid_602212 = validateParameter(valid_602212, JString, required = true,
                                 default = nil)
  if valid_602212 != nil:
    section.add "jobId", valid_602212
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
  section = newJObject()
  var valid_602213 = query.getOrDefault("force")
  valid_602213 = validateParameter(valid_602213, JBool, required = false, default = nil)
  if valid_602213 != nil:
    section.add "force", valid_602213
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602214 = header.getOrDefault("X-Amz-Signature")
  valid_602214 = validateParameter(valid_602214, JString, required = false,
                                 default = nil)
  if valid_602214 != nil:
    section.add "X-Amz-Signature", valid_602214
  var valid_602215 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602215 = validateParameter(valid_602215, JString, required = false,
                                 default = nil)
  if valid_602215 != nil:
    section.add "X-Amz-Content-Sha256", valid_602215
  var valid_602216 = header.getOrDefault("X-Amz-Date")
  valid_602216 = validateParameter(valid_602216, JString, required = false,
                                 default = nil)
  if valid_602216 != nil:
    section.add "X-Amz-Date", valid_602216
  var valid_602217 = header.getOrDefault("X-Amz-Credential")
  valid_602217 = validateParameter(valid_602217, JString, required = false,
                                 default = nil)
  if valid_602217 != nil:
    section.add "X-Amz-Credential", valid_602217
  var valid_602218 = header.getOrDefault("X-Amz-Security-Token")
  valid_602218 = validateParameter(valid_602218, JString, required = false,
                                 default = nil)
  if valid_602218 != nil:
    section.add "X-Amz-Security-Token", valid_602218
  var valid_602219 = header.getOrDefault("X-Amz-Algorithm")
  valid_602219 = validateParameter(valid_602219, JString, required = false,
                                 default = nil)
  if valid_602219 != nil:
    section.add "X-Amz-Algorithm", valid_602219
  var valid_602220 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602220 = validateParameter(valid_602220, JString, required = false,
                                 default = nil)
  if valid_602220 != nil:
    section.add "X-Amz-SignedHeaders", valid_602220
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602222: Call_CancelJob_602209; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a job.
  ## 
  let valid = call_602222.validator(path, query, header, formData, body)
  let scheme = call_602222.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602222.url(scheme.get, call_602222.host, call_602222.base,
                         call_602222.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602222, url, valid)

proc call*(call_602223: Call_CancelJob_602209; jobId: string; body: JsonNode;
          force: bool = false): Recallable =
  ## cancelJob
  ## Cancels a job.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   force: bool
  ##        : <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
  ##   body: JObject (required)
  var path_602224 = newJObject()
  var query_602225 = newJObject()
  var body_602226 = newJObject()
  add(path_602224, "jobId", newJString(jobId))
  add(query_602225, "force", newJBool(force))
  if body != nil:
    body_602226 = body
  result = call_602223.call(path_602224, query_602225, nil, nil, body_602226)

var cancelJob* = Call_CancelJob_602209(name: "cancelJob", meth: HttpMethod.HttpPut,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}/cancel",
                                    validator: validate_CancelJob_602210,
                                    base: "/", url: url_CancelJob_602211,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelJobExecution_602227 = ref object of OpenApiRestCall_601389
proc url_CancelJobExecution_602229(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelJobExecution_602228(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Cancels the execution of a job for a given thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The ID of the job to be canceled.
  ##   thingName: JString (required)
  ##            : The name of the thing whose execution of the job will be canceled.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_602230 = path.getOrDefault("jobId")
  valid_602230 = validateParameter(valid_602230, JString, required = true,
                                 default = nil)
  if valid_602230 != nil:
    section.add "jobId", valid_602230
  var valid_602231 = path.getOrDefault("thingName")
  valid_602231 = validateParameter(valid_602231, JString, required = true,
                                 default = nil)
  if valid_602231 != nil:
    section.add "thingName", valid_602231
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
  section = newJObject()
  var valid_602232 = query.getOrDefault("force")
  valid_602232 = validateParameter(valid_602232, JBool, required = false, default = nil)
  if valid_602232 != nil:
    section.add "force", valid_602232
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602233 = header.getOrDefault("X-Amz-Signature")
  valid_602233 = validateParameter(valid_602233, JString, required = false,
                                 default = nil)
  if valid_602233 != nil:
    section.add "X-Amz-Signature", valid_602233
  var valid_602234 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602234 = validateParameter(valid_602234, JString, required = false,
                                 default = nil)
  if valid_602234 != nil:
    section.add "X-Amz-Content-Sha256", valid_602234
  var valid_602235 = header.getOrDefault("X-Amz-Date")
  valid_602235 = validateParameter(valid_602235, JString, required = false,
                                 default = nil)
  if valid_602235 != nil:
    section.add "X-Amz-Date", valid_602235
  var valid_602236 = header.getOrDefault("X-Amz-Credential")
  valid_602236 = validateParameter(valid_602236, JString, required = false,
                                 default = nil)
  if valid_602236 != nil:
    section.add "X-Amz-Credential", valid_602236
  var valid_602237 = header.getOrDefault("X-Amz-Security-Token")
  valid_602237 = validateParameter(valid_602237, JString, required = false,
                                 default = nil)
  if valid_602237 != nil:
    section.add "X-Amz-Security-Token", valid_602237
  var valid_602238 = header.getOrDefault("X-Amz-Algorithm")
  valid_602238 = validateParameter(valid_602238, JString, required = false,
                                 default = nil)
  if valid_602238 != nil:
    section.add "X-Amz-Algorithm", valid_602238
  var valid_602239 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602239 = validateParameter(valid_602239, JString, required = false,
                                 default = nil)
  if valid_602239 != nil:
    section.add "X-Amz-SignedHeaders", valid_602239
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602241: Call_CancelJobExecution_602227; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels the execution of a job for a given thing.
  ## 
  let valid = call_602241.validator(path, query, header, formData, body)
  let scheme = call_602241.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602241.url(scheme.get, call_602241.host, call_602241.base,
                         call_602241.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602241, url, valid)

proc call*(call_602242: Call_CancelJobExecution_602227; jobId: string;
          thingName: string; body: JsonNode; force: bool = false): Recallable =
  ## cancelJobExecution
  ## Cancels the execution of a job for a given thing.
  ##   jobId: string (required)
  ##        : The ID of the job to be canceled.
  ##   thingName: string (required)
  ##            : The name of the thing whose execution of the job will be canceled.
  ##   force: bool
  ##        : <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
  ##   body: JObject (required)
  var path_602243 = newJObject()
  var query_602244 = newJObject()
  var body_602245 = newJObject()
  add(path_602243, "jobId", newJString(jobId))
  add(path_602243, "thingName", newJString(thingName))
  add(query_602244, "force", newJBool(force))
  if body != nil:
    body_602245 = body
  result = call_602242.call(path_602243, query_602244, nil, nil, body_602245)

var cancelJobExecution* = Call_CancelJobExecution_602227(
    name: "cancelJobExecution", meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/things/{thingName}/jobs/{jobId}/cancel",
    validator: validate_CancelJobExecution_602228, base: "/",
    url: url_CancelJobExecution_602229, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetDefaultAuthorizer_602258 = ref object of OpenApiRestCall_601389
proc url_SetDefaultAuthorizer_602260(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetDefaultAuthorizer_602259(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602261 = header.getOrDefault("X-Amz-Signature")
  valid_602261 = validateParameter(valid_602261, JString, required = false,
                                 default = nil)
  if valid_602261 != nil:
    section.add "X-Amz-Signature", valid_602261
  var valid_602262 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602262 = validateParameter(valid_602262, JString, required = false,
                                 default = nil)
  if valid_602262 != nil:
    section.add "X-Amz-Content-Sha256", valid_602262
  var valid_602263 = header.getOrDefault("X-Amz-Date")
  valid_602263 = validateParameter(valid_602263, JString, required = false,
                                 default = nil)
  if valid_602263 != nil:
    section.add "X-Amz-Date", valid_602263
  var valid_602264 = header.getOrDefault("X-Amz-Credential")
  valid_602264 = validateParameter(valid_602264, JString, required = false,
                                 default = nil)
  if valid_602264 != nil:
    section.add "X-Amz-Credential", valid_602264
  var valid_602265 = header.getOrDefault("X-Amz-Security-Token")
  valid_602265 = validateParameter(valid_602265, JString, required = false,
                                 default = nil)
  if valid_602265 != nil:
    section.add "X-Amz-Security-Token", valid_602265
  var valid_602266 = header.getOrDefault("X-Amz-Algorithm")
  valid_602266 = validateParameter(valid_602266, JString, required = false,
                                 default = nil)
  if valid_602266 != nil:
    section.add "X-Amz-Algorithm", valid_602266
  var valid_602267 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602267 = validateParameter(valid_602267, JString, required = false,
                                 default = nil)
  if valid_602267 != nil:
    section.add "X-Amz-SignedHeaders", valid_602267
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602269: Call_SetDefaultAuthorizer_602258; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ## 
  let valid = call_602269.validator(path, query, header, formData, body)
  let scheme = call_602269.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602269.url(scheme.get, call_602269.host, call_602269.base,
                         call_602269.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602269, url, valid)

proc call*(call_602270: Call_SetDefaultAuthorizer_602258; body: JsonNode): Recallable =
  ## setDefaultAuthorizer
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ##   body: JObject (required)
  var body_602271 = newJObject()
  if body != nil:
    body_602271 = body
  result = call_602270.call(nil, nil, nil, nil, body_602271)

var setDefaultAuthorizer* = Call_SetDefaultAuthorizer_602258(
    name: "setDefaultAuthorizer", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_SetDefaultAuthorizer_602259, base: "/",
    url: url_SetDefaultAuthorizer_602260, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeDefaultAuthorizer_602246 = ref object of OpenApiRestCall_601389
proc url_DescribeDefaultAuthorizer_602248(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeDefaultAuthorizer_602247(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes the default authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602249 = header.getOrDefault("X-Amz-Signature")
  valid_602249 = validateParameter(valid_602249, JString, required = false,
                                 default = nil)
  if valid_602249 != nil:
    section.add "X-Amz-Signature", valid_602249
  var valid_602250 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602250 = validateParameter(valid_602250, JString, required = false,
                                 default = nil)
  if valid_602250 != nil:
    section.add "X-Amz-Content-Sha256", valid_602250
  var valid_602251 = header.getOrDefault("X-Amz-Date")
  valid_602251 = validateParameter(valid_602251, JString, required = false,
                                 default = nil)
  if valid_602251 != nil:
    section.add "X-Amz-Date", valid_602251
  var valid_602252 = header.getOrDefault("X-Amz-Credential")
  valid_602252 = validateParameter(valid_602252, JString, required = false,
                                 default = nil)
  if valid_602252 != nil:
    section.add "X-Amz-Credential", valid_602252
  var valid_602253 = header.getOrDefault("X-Amz-Security-Token")
  valid_602253 = validateParameter(valid_602253, JString, required = false,
                                 default = nil)
  if valid_602253 != nil:
    section.add "X-Amz-Security-Token", valid_602253
  var valid_602254 = header.getOrDefault("X-Amz-Algorithm")
  valid_602254 = validateParameter(valid_602254, JString, required = false,
                                 default = nil)
  if valid_602254 != nil:
    section.add "X-Amz-Algorithm", valid_602254
  var valid_602255 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602255 = validateParameter(valid_602255, JString, required = false,
                                 default = nil)
  if valid_602255 != nil:
    section.add "X-Amz-SignedHeaders", valid_602255
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602256: Call_DescribeDefaultAuthorizer_602246; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes the default authorizer.
  ## 
  let valid = call_602256.validator(path, query, header, formData, body)
  let scheme = call_602256.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602256.url(scheme.get, call_602256.host, call_602256.base,
                         call_602256.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602256, url, valid)

proc call*(call_602257: Call_DescribeDefaultAuthorizer_602246): Recallable =
  ## describeDefaultAuthorizer
  ## Describes the default authorizer.
  result = call_602257.call(nil, nil, nil, nil, nil)

var describeDefaultAuthorizer* = Call_DescribeDefaultAuthorizer_602246(
    name: "describeDefaultAuthorizer", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_DescribeDefaultAuthorizer_602247, base: "/",
    url: url_DescribeDefaultAuthorizer_602248,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ClearDefaultAuthorizer_602272 = ref object of OpenApiRestCall_601389
proc url_ClearDefaultAuthorizer_602274(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ClearDefaultAuthorizer_602273(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Clears the default authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602275 = header.getOrDefault("X-Amz-Signature")
  valid_602275 = validateParameter(valid_602275, JString, required = false,
                                 default = nil)
  if valid_602275 != nil:
    section.add "X-Amz-Signature", valid_602275
  var valid_602276 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602276 = validateParameter(valid_602276, JString, required = false,
                                 default = nil)
  if valid_602276 != nil:
    section.add "X-Amz-Content-Sha256", valid_602276
  var valid_602277 = header.getOrDefault("X-Amz-Date")
  valid_602277 = validateParameter(valid_602277, JString, required = false,
                                 default = nil)
  if valid_602277 != nil:
    section.add "X-Amz-Date", valid_602277
  var valid_602278 = header.getOrDefault("X-Amz-Credential")
  valid_602278 = validateParameter(valid_602278, JString, required = false,
                                 default = nil)
  if valid_602278 != nil:
    section.add "X-Amz-Credential", valid_602278
  var valid_602279 = header.getOrDefault("X-Amz-Security-Token")
  valid_602279 = validateParameter(valid_602279, JString, required = false,
                                 default = nil)
  if valid_602279 != nil:
    section.add "X-Amz-Security-Token", valid_602279
  var valid_602280 = header.getOrDefault("X-Amz-Algorithm")
  valid_602280 = validateParameter(valid_602280, JString, required = false,
                                 default = nil)
  if valid_602280 != nil:
    section.add "X-Amz-Algorithm", valid_602280
  var valid_602281 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602281 = validateParameter(valid_602281, JString, required = false,
                                 default = nil)
  if valid_602281 != nil:
    section.add "X-Amz-SignedHeaders", valid_602281
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602282: Call_ClearDefaultAuthorizer_602272; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Clears the default authorizer.
  ## 
  let valid = call_602282.validator(path, query, header, formData, body)
  let scheme = call_602282.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602282.url(scheme.get, call_602282.host, call_602282.base,
                         call_602282.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602282, url, valid)

proc call*(call_602283: Call_ClearDefaultAuthorizer_602272): Recallable =
  ## clearDefaultAuthorizer
  ## Clears the default authorizer.
  result = call_602283.call(nil, nil, nil, nil, nil)

var clearDefaultAuthorizer* = Call_ClearDefaultAuthorizer_602272(
    name: "clearDefaultAuthorizer", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_ClearDefaultAuthorizer_602273, base: "/",
    url: url_ClearDefaultAuthorizer_602274, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ConfirmTopicRuleDestination_602284 = ref object of OpenApiRestCall_601389
proc url_ConfirmTopicRuleDestination_602286(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "confirmationToken" in path,
        "`confirmationToken` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/confirmdestination/"),
               (kind: VariableSegment, value: "confirmationToken")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ConfirmTopicRuleDestination_602285(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Confirms a topic rule destination. When you create a rule requiring a destination, AWS IoT sends a confirmation message to the endpoint or base address you specify. The message includes a token which you pass back when calling <code>ConfirmTopicRuleDestination</code> to confirm that you own or have access to the endpoint.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   confirmationToken: JString (required)
  ##                    : The token used to confirm ownership or access to the topic rule confirmation URL.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `confirmationToken` field"
  var valid_602287 = path.getOrDefault("confirmationToken")
  valid_602287 = validateParameter(valid_602287, JString, required = true,
                                 default = nil)
  if valid_602287 != nil:
    section.add "confirmationToken", valid_602287
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602288 = header.getOrDefault("X-Amz-Signature")
  valid_602288 = validateParameter(valid_602288, JString, required = false,
                                 default = nil)
  if valid_602288 != nil:
    section.add "X-Amz-Signature", valid_602288
  var valid_602289 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602289 = validateParameter(valid_602289, JString, required = false,
                                 default = nil)
  if valid_602289 != nil:
    section.add "X-Amz-Content-Sha256", valid_602289
  var valid_602290 = header.getOrDefault("X-Amz-Date")
  valid_602290 = validateParameter(valid_602290, JString, required = false,
                                 default = nil)
  if valid_602290 != nil:
    section.add "X-Amz-Date", valid_602290
  var valid_602291 = header.getOrDefault("X-Amz-Credential")
  valid_602291 = validateParameter(valid_602291, JString, required = false,
                                 default = nil)
  if valid_602291 != nil:
    section.add "X-Amz-Credential", valid_602291
  var valid_602292 = header.getOrDefault("X-Amz-Security-Token")
  valid_602292 = validateParameter(valid_602292, JString, required = false,
                                 default = nil)
  if valid_602292 != nil:
    section.add "X-Amz-Security-Token", valid_602292
  var valid_602293 = header.getOrDefault("X-Amz-Algorithm")
  valid_602293 = validateParameter(valid_602293, JString, required = false,
                                 default = nil)
  if valid_602293 != nil:
    section.add "X-Amz-Algorithm", valid_602293
  var valid_602294 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602294 = validateParameter(valid_602294, JString, required = false,
                                 default = nil)
  if valid_602294 != nil:
    section.add "X-Amz-SignedHeaders", valid_602294
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602295: Call_ConfirmTopicRuleDestination_602284; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Confirms a topic rule destination. When you create a rule requiring a destination, AWS IoT sends a confirmation message to the endpoint or base address you specify. The message includes a token which you pass back when calling <code>ConfirmTopicRuleDestination</code> to confirm that you own or have access to the endpoint.
  ## 
  let valid = call_602295.validator(path, query, header, formData, body)
  let scheme = call_602295.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602295.url(scheme.get, call_602295.host, call_602295.base,
                         call_602295.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602295, url, valid)

proc call*(call_602296: Call_ConfirmTopicRuleDestination_602284;
          confirmationToken: string): Recallable =
  ## confirmTopicRuleDestination
  ## Confirms a topic rule destination. When you create a rule requiring a destination, AWS IoT sends a confirmation message to the endpoint or base address you specify. The message includes a token which you pass back when calling <code>ConfirmTopicRuleDestination</code> to confirm that you own or have access to the endpoint.
  ##   confirmationToken: string (required)
  ##                    : The token used to confirm ownership or access to the topic rule confirmation URL.
  var path_602297 = newJObject()
  add(path_602297, "confirmationToken", newJString(confirmationToken))
  result = call_602296.call(path_602297, nil, nil, nil, nil)

var confirmTopicRuleDestination* = Call_ConfirmTopicRuleDestination_602284(
    name: "confirmTopicRuleDestination", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/confirmdestination/{confirmationToken}",
    validator: validate_ConfirmTopicRuleDestination_602285, base: "/",
    url: url_ConfirmTopicRuleDestination_602286,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateAuthorizer_602312 = ref object of OpenApiRestCall_601389
proc url_UpdateAuthorizer_602314(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateAuthorizer_602313(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Updates an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_602315 = path.getOrDefault("authorizerName")
  valid_602315 = validateParameter(valid_602315, JString, required = true,
                                 default = nil)
  if valid_602315 != nil:
    section.add "authorizerName", valid_602315
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602316 = header.getOrDefault("X-Amz-Signature")
  valid_602316 = validateParameter(valid_602316, JString, required = false,
                                 default = nil)
  if valid_602316 != nil:
    section.add "X-Amz-Signature", valid_602316
  var valid_602317 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602317 = validateParameter(valid_602317, JString, required = false,
                                 default = nil)
  if valid_602317 != nil:
    section.add "X-Amz-Content-Sha256", valid_602317
  var valid_602318 = header.getOrDefault("X-Amz-Date")
  valid_602318 = validateParameter(valid_602318, JString, required = false,
                                 default = nil)
  if valid_602318 != nil:
    section.add "X-Amz-Date", valid_602318
  var valid_602319 = header.getOrDefault("X-Amz-Credential")
  valid_602319 = validateParameter(valid_602319, JString, required = false,
                                 default = nil)
  if valid_602319 != nil:
    section.add "X-Amz-Credential", valid_602319
  var valid_602320 = header.getOrDefault("X-Amz-Security-Token")
  valid_602320 = validateParameter(valid_602320, JString, required = false,
                                 default = nil)
  if valid_602320 != nil:
    section.add "X-Amz-Security-Token", valid_602320
  var valid_602321 = header.getOrDefault("X-Amz-Algorithm")
  valid_602321 = validateParameter(valid_602321, JString, required = false,
                                 default = nil)
  if valid_602321 != nil:
    section.add "X-Amz-Algorithm", valid_602321
  var valid_602322 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602322 = validateParameter(valid_602322, JString, required = false,
                                 default = nil)
  if valid_602322 != nil:
    section.add "X-Amz-SignedHeaders", valid_602322
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602324: Call_UpdateAuthorizer_602312; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an authorizer.
  ## 
  let valid = call_602324.validator(path, query, header, formData, body)
  let scheme = call_602324.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602324.url(scheme.get, call_602324.host, call_602324.base,
                         call_602324.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602324, url, valid)

proc call*(call_602325: Call_UpdateAuthorizer_602312; authorizerName: string;
          body: JsonNode): Recallable =
  ## updateAuthorizer
  ## Updates an authorizer.
  ##   authorizerName: string (required)
  ##                 : The authorizer name.
  ##   body: JObject (required)
  var path_602326 = newJObject()
  var body_602327 = newJObject()
  add(path_602326, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_602327 = body
  result = call_602325.call(path_602326, nil, nil, nil, body_602327)

var updateAuthorizer* = Call_UpdateAuthorizer_602312(name: "updateAuthorizer",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_UpdateAuthorizer_602313,
    base: "/", url: url_UpdateAuthorizer_602314,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateAuthorizer_602328 = ref object of OpenApiRestCall_601389
proc url_CreateAuthorizer_602330(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateAuthorizer_602329(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Creates an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_602331 = path.getOrDefault("authorizerName")
  valid_602331 = validateParameter(valid_602331, JString, required = true,
                                 default = nil)
  if valid_602331 != nil:
    section.add "authorizerName", valid_602331
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602332 = header.getOrDefault("X-Amz-Signature")
  valid_602332 = validateParameter(valid_602332, JString, required = false,
                                 default = nil)
  if valid_602332 != nil:
    section.add "X-Amz-Signature", valid_602332
  var valid_602333 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602333 = validateParameter(valid_602333, JString, required = false,
                                 default = nil)
  if valid_602333 != nil:
    section.add "X-Amz-Content-Sha256", valid_602333
  var valid_602334 = header.getOrDefault("X-Amz-Date")
  valid_602334 = validateParameter(valid_602334, JString, required = false,
                                 default = nil)
  if valid_602334 != nil:
    section.add "X-Amz-Date", valid_602334
  var valid_602335 = header.getOrDefault("X-Amz-Credential")
  valid_602335 = validateParameter(valid_602335, JString, required = false,
                                 default = nil)
  if valid_602335 != nil:
    section.add "X-Amz-Credential", valid_602335
  var valid_602336 = header.getOrDefault("X-Amz-Security-Token")
  valid_602336 = validateParameter(valid_602336, JString, required = false,
                                 default = nil)
  if valid_602336 != nil:
    section.add "X-Amz-Security-Token", valid_602336
  var valid_602337 = header.getOrDefault("X-Amz-Algorithm")
  valid_602337 = validateParameter(valid_602337, JString, required = false,
                                 default = nil)
  if valid_602337 != nil:
    section.add "X-Amz-Algorithm", valid_602337
  var valid_602338 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602338 = validateParameter(valid_602338, JString, required = false,
                                 default = nil)
  if valid_602338 != nil:
    section.add "X-Amz-SignedHeaders", valid_602338
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602340: Call_CreateAuthorizer_602328; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates an authorizer.
  ## 
  let valid = call_602340.validator(path, query, header, formData, body)
  let scheme = call_602340.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602340.url(scheme.get, call_602340.host, call_602340.base,
                         call_602340.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602340, url, valid)

proc call*(call_602341: Call_CreateAuthorizer_602328; authorizerName: string;
          body: JsonNode): Recallable =
  ## createAuthorizer
  ## Creates an authorizer.
  ##   authorizerName: string (required)
  ##                 : The authorizer name.
  ##   body: JObject (required)
  var path_602342 = newJObject()
  var body_602343 = newJObject()
  add(path_602342, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_602343 = body
  result = call_602341.call(path_602342, nil, nil, nil, body_602343)

var createAuthorizer* = Call_CreateAuthorizer_602328(name: "createAuthorizer",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_CreateAuthorizer_602329,
    base: "/", url: url_CreateAuthorizer_602330,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuthorizer_602298 = ref object of OpenApiRestCall_601389
proc url_DescribeAuthorizer_602300(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuthorizer_602299(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Describes an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The name of the authorizer to describe.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_602301 = path.getOrDefault("authorizerName")
  valid_602301 = validateParameter(valid_602301, JString, required = true,
                                 default = nil)
  if valid_602301 != nil:
    section.add "authorizerName", valid_602301
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602302 = header.getOrDefault("X-Amz-Signature")
  valid_602302 = validateParameter(valid_602302, JString, required = false,
                                 default = nil)
  if valid_602302 != nil:
    section.add "X-Amz-Signature", valid_602302
  var valid_602303 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602303 = validateParameter(valid_602303, JString, required = false,
                                 default = nil)
  if valid_602303 != nil:
    section.add "X-Amz-Content-Sha256", valid_602303
  var valid_602304 = header.getOrDefault("X-Amz-Date")
  valid_602304 = validateParameter(valid_602304, JString, required = false,
                                 default = nil)
  if valid_602304 != nil:
    section.add "X-Amz-Date", valid_602304
  var valid_602305 = header.getOrDefault("X-Amz-Credential")
  valid_602305 = validateParameter(valid_602305, JString, required = false,
                                 default = nil)
  if valid_602305 != nil:
    section.add "X-Amz-Credential", valid_602305
  var valid_602306 = header.getOrDefault("X-Amz-Security-Token")
  valid_602306 = validateParameter(valid_602306, JString, required = false,
                                 default = nil)
  if valid_602306 != nil:
    section.add "X-Amz-Security-Token", valid_602306
  var valid_602307 = header.getOrDefault("X-Amz-Algorithm")
  valid_602307 = validateParameter(valid_602307, JString, required = false,
                                 default = nil)
  if valid_602307 != nil:
    section.add "X-Amz-Algorithm", valid_602307
  var valid_602308 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602308 = validateParameter(valid_602308, JString, required = false,
                                 default = nil)
  if valid_602308 != nil:
    section.add "X-Amz-SignedHeaders", valid_602308
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602309: Call_DescribeAuthorizer_602298; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes an authorizer.
  ## 
  let valid = call_602309.validator(path, query, header, formData, body)
  let scheme = call_602309.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602309.url(scheme.get, call_602309.host, call_602309.base,
                         call_602309.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602309, url, valid)

proc call*(call_602310: Call_DescribeAuthorizer_602298; authorizerName: string): Recallable =
  ## describeAuthorizer
  ## Describes an authorizer.
  ##   authorizerName: string (required)
  ##                 : The name of the authorizer to describe.
  var path_602311 = newJObject()
  add(path_602311, "authorizerName", newJString(authorizerName))
  result = call_602310.call(path_602311, nil, nil, nil, nil)

var describeAuthorizer* = Call_DescribeAuthorizer_602298(
    name: "describeAuthorizer", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_DescribeAuthorizer_602299,
    base: "/", url: url_DescribeAuthorizer_602300,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteAuthorizer_602344 = ref object of OpenApiRestCall_601389
proc url_DeleteAuthorizer_602346(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteAuthorizer_602345(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Deletes an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The name of the authorizer to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_602347 = path.getOrDefault("authorizerName")
  valid_602347 = validateParameter(valid_602347, JString, required = true,
                                 default = nil)
  if valid_602347 != nil:
    section.add "authorizerName", valid_602347
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602348 = header.getOrDefault("X-Amz-Signature")
  valid_602348 = validateParameter(valid_602348, JString, required = false,
                                 default = nil)
  if valid_602348 != nil:
    section.add "X-Amz-Signature", valid_602348
  var valid_602349 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602349 = validateParameter(valid_602349, JString, required = false,
                                 default = nil)
  if valid_602349 != nil:
    section.add "X-Amz-Content-Sha256", valid_602349
  var valid_602350 = header.getOrDefault("X-Amz-Date")
  valid_602350 = validateParameter(valid_602350, JString, required = false,
                                 default = nil)
  if valid_602350 != nil:
    section.add "X-Amz-Date", valid_602350
  var valid_602351 = header.getOrDefault("X-Amz-Credential")
  valid_602351 = validateParameter(valid_602351, JString, required = false,
                                 default = nil)
  if valid_602351 != nil:
    section.add "X-Amz-Credential", valid_602351
  var valid_602352 = header.getOrDefault("X-Amz-Security-Token")
  valid_602352 = validateParameter(valid_602352, JString, required = false,
                                 default = nil)
  if valid_602352 != nil:
    section.add "X-Amz-Security-Token", valid_602352
  var valid_602353 = header.getOrDefault("X-Amz-Algorithm")
  valid_602353 = validateParameter(valid_602353, JString, required = false,
                                 default = nil)
  if valid_602353 != nil:
    section.add "X-Amz-Algorithm", valid_602353
  var valid_602354 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602354 = validateParameter(valid_602354, JString, required = false,
                                 default = nil)
  if valid_602354 != nil:
    section.add "X-Amz-SignedHeaders", valid_602354
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602355: Call_DeleteAuthorizer_602344; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an authorizer.
  ## 
  let valid = call_602355.validator(path, query, header, formData, body)
  let scheme = call_602355.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602355.url(scheme.get, call_602355.host, call_602355.base,
                         call_602355.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602355, url, valid)

proc call*(call_602356: Call_DeleteAuthorizer_602344; authorizerName: string): Recallable =
  ## deleteAuthorizer
  ## Deletes an authorizer.
  ##   authorizerName: string (required)
  ##                 : The name of the authorizer to delete.
  var path_602357 = newJObject()
  add(path_602357, "authorizerName", newJString(authorizerName))
  result = call_602356.call(path_602357, nil, nil, nil, nil)

var deleteAuthorizer* = Call_DeleteAuthorizer_602344(name: "deleteAuthorizer",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_DeleteAuthorizer_602345,
    base: "/", url: url_DeleteAuthorizer_602346,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateBillingGroup_602372 = ref object of OpenApiRestCall_601389
proc url_CreateBillingGroup_602374(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateBillingGroup_602373(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Creates a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name you wish to give to the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_602375 = path.getOrDefault("billingGroupName")
  valid_602375 = validateParameter(valid_602375, JString, required = true,
                                 default = nil)
  if valid_602375 != nil:
    section.add "billingGroupName", valid_602375
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602376 = header.getOrDefault("X-Amz-Signature")
  valid_602376 = validateParameter(valid_602376, JString, required = false,
                                 default = nil)
  if valid_602376 != nil:
    section.add "X-Amz-Signature", valid_602376
  var valid_602377 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602377 = validateParameter(valid_602377, JString, required = false,
                                 default = nil)
  if valid_602377 != nil:
    section.add "X-Amz-Content-Sha256", valid_602377
  var valid_602378 = header.getOrDefault("X-Amz-Date")
  valid_602378 = validateParameter(valid_602378, JString, required = false,
                                 default = nil)
  if valid_602378 != nil:
    section.add "X-Amz-Date", valid_602378
  var valid_602379 = header.getOrDefault("X-Amz-Credential")
  valid_602379 = validateParameter(valid_602379, JString, required = false,
                                 default = nil)
  if valid_602379 != nil:
    section.add "X-Amz-Credential", valid_602379
  var valid_602380 = header.getOrDefault("X-Amz-Security-Token")
  valid_602380 = validateParameter(valid_602380, JString, required = false,
                                 default = nil)
  if valid_602380 != nil:
    section.add "X-Amz-Security-Token", valid_602380
  var valid_602381 = header.getOrDefault("X-Amz-Algorithm")
  valid_602381 = validateParameter(valid_602381, JString, required = false,
                                 default = nil)
  if valid_602381 != nil:
    section.add "X-Amz-Algorithm", valid_602381
  var valid_602382 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602382 = validateParameter(valid_602382, JString, required = false,
                                 default = nil)
  if valid_602382 != nil:
    section.add "X-Amz-SignedHeaders", valid_602382
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602384: Call_CreateBillingGroup_602372; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a billing group.
  ## 
  let valid = call_602384.validator(path, query, header, formData, body)
  let scheme = call_602384.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602384.url(scheme.get, call_602384.host, call_602384.base,
                         call_602384.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602384, url, valid)

proc call*(call_602385: Call_CreateBillingGroup_602372; body: JsonNode;
          billingGroupName: string): Recallable =
  ## createBillingGroup
  ## Creates a billing group.
  ##   body: JObject (required)
  ##   billingGroupName: string (required)
  ##                   : The name you wish to give to the billing group.
  var path_602386 = newJObject()
  var body_602387 = newJObject()
  if body != nil:
    body_602387 = body
  add(path_602386, "billingGroupName", newJString(billingGroupName))
  result = call_602385.call(path_602386, nil, nil, nil, body_602387)

var createBillingGroup* = Call_CreateBillingGroup_602372(
    name: "createBillingGroup", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_CreateBillingGroup_602373, base: "/",
    url: url_CreateBillingGroup_602374, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeBillingGroup_602358 = ref object of OpenApiRestCall_601389
proc url_DescribeBillingGroup_602360(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeBillingGroup_602359(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_602361 = path.getOrDefault("billingGroupName")
  valid_602361 = validateParameter(valid_602361, JString, required = true,
                                 default = nil)
  if valid_602361 != nil:
    section.add "billingGroupName", valid_602361
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602362 = header.getOrDefault("X-Amz-Signature")
  valid_602362 = validateParameter(valid_602362, JString, required = false,
                                 default = nil)
  if valid_602362 != nil:
    section.add "X-Amz-Signature", valid_602362
  var valid_602363 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602363 = validateParameter(valid_602363, JString, required = false,
                                 default = nil)
  if valid_602363 != nil:
    section.add "X-Amz-Content-Sha256", valid_602363
  var valid_602364 = header.getOrDefault("X-Amz-Date")
  valid_602364 = validateParameter(valid_602364, JString, required = false,
                                 default = nil)
  if valid_602364 != nil:
    section.add "X-Amz-Date", valid_602364
  var valid_602365 = header.getOrDefault("X-Amz-Credential")
  valid_602365 = validateParameter(valid_602365, JString, required = false,
                                 default = nil)
  if valid_602365 != nil:
    section.add "X-Amz-Credential", valid_602365
  var valid_602366 = header.getOrDefault("X-Amz-Security-Token")
  valid_602366 = validateParameter(valid_602366, JString, required = false,
                                 default = nil)
  if valid_602366 != nil:
    section.add "X-Amz-Security-Token", valid_602366
  var valid_602367 = header.getOrDefault("X-Amz-Algorithm")
  valid_602367 = validateParameter(valid_602367, JString, required = false,
                                 default = nil)
  if valid_602367 != nil:
    section.add "X-Amz-Algorithm", valid_602367
  var valid_602368 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602368 = validateParameter(valid_602368, JString, required = false,
                                 default = nil)
  if valid_602368 != nil:
    section.add "X-Amz-SignedHeaders", valid_602368
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602369: Call_DescribeBillingGroup_602358; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about a billing group.
  ## 
  let valid = call_602369.validator(path, query, header, formData, body)
  let scheme = call_602369.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602369.url(scheme.get, call_602369.host, call_602369.base,
                         call_602369.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602369, url, valid)

proc call*(call_602370: Call_DescribeBillingGroup_602358; billingGroupName: string): Recallable =
  ## describeBillingGroup
  ## Returns information about a billing group.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_602371 = newJObject()
  add(path_602371, "billingGroupName", newJString(billingGroupName))
  result = call_602370.call(path_602371, nil, nil, nil, nil)

var describeBillingGroup* = Call_DescribeBillingGroup_602358(
    name: "describeBillingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_DescribeBillingGroup_602359, base: "/",
    url: url_DescribeBillingGroup_602360, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateBillingGroup_602404 = ref object of OpenApiRestCall_601389
proc url_UpdateBillingGroup_602406(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateBillingGroup_602405(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Updates information about the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_602407 = path.getOrDefault("billingGroupName")
  valid_602407 = validateParameter(valid_602407, JString, required = true,
                                 default = nil)
  if valid_602407 != nil:
    section.add "billingGroupName", valid_602407
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602408 = header.getOrDefault("X-Amz-Signature")
  valid_602408 = validateParameter(valid_602408, JString, required = false,
                                 default = nil)
  if valid_602408 != nil:
    section.add "X-Amz-Signature", valid_602408
  var valid_602409 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602409 = validateParameter(valid_602409, JString, required = false,
                                 default = nil)
  if valid_602409 != nil:
    section.add "X-Amz-Content-Sha256", valid_602409
  var valid_602410 = header.getOrDefault("X-Amz-Date")
  valid_602410 = validateParameter(valid_602410, JString, required = false,
                                 default = nil)
  if valid_602410 != nil:
    section.add "X-Amz-Date", valid_602410
  var valid_602411 = header.getOrDefault("X-Amz-Credential")
  valid_602411 = validateParameter(valid_602411, JString, required = false,
                                 default = nil)
  if valid_602411 != nil:
    section.add "X-Amz-Credential", valid_602411
  var valid_602412 = header.getOrDefault("X-Amz-Security-Token")
  valid_602412 = validateParameter(valid_602412, JString, required = false,
                                 default = nil)
  if valid_602412 != nil:
    section.add "X-Amz-Security-Token", valid_602412
  var valid_602413 = header.getOrDefault("X-Amz-Algorithm")
  valid_602413 = validateParameter(valid_602413, JString, required = false,
                                 default = nil)
  if valid_602413 != nil:
    section.add "X-Amz-Algorithm", valid_602413
  var valid_602414 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602414 = validateParameter(valid_602414, JString, required = false,
                                 default = nil)
  if valid_602414 != nil:
    section.add "X-Amz-SignedHeaders", valid_602414
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602416: Call_UpdateBillingGroup_602404; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates information about the billing group.
  ## 
  let valid = call_602416.validator(path, query, header, formData, body)
  let scheme = call_602416.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602416.url(scheme.get, call_602416.host, call_602416.base,
                         call_602416.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602416, url, valid)

proc call*(call_602417: Call_UpdateBillingGroup_602404; body: JsonNode;
          billingGroupName: string): Recallable =
  ## updateBillingGroup
  ## Updates information about the billing group.
  ##   body: JObject (required)
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_602418 = newJObject()
  var body_602419 = newJObject()
  if body != nil:
    body_602419 = body
  add(path_602418, "billingGroupName", newJString(billingGroupName))
  result = call_602417.call(path_602418, nil, nil, nil, body_602419)

var updateBillingGroup* = Call_UpdateBillingGroup_602404(
    name: "updateBillingGroup", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_UpdateBillingGroup_602405, base: "/",
    url: url_UpdateBillingGroup_602406, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteBillingGroup_602388 = ref object of OpenApiRestCall_601389
proc url_DeleteBillingGroup_602390(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteBillingGroup_602389(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deletes the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_602391 = path.getOrDefault("billingGroupName")
  valid_602391 = validateParameter(valid_602391, JString, required = true,
                                 default = nil)
  if valid_602391 != nil:
    section.add "billingGroupName", valid_602391
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.
  section = newJObject()
  var valid_602392 = query.getOrDefault("expectedVersion")
  valid_602392 = validateParameter(valid_602392, JInt, required = false, default = nil)
  if valid_602392 != nil:
    section.add "expectedVersion", valid_602392
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602393 = header.getOrDefault("X-Amz-Signature")
  valid_602393 = validateParameter(valid_602393, JString, required = false,
                                 default = nil)
  if valid_602393 != nil:
    section.add "X-Amz-Signature", valid_602393
  var valid_602394 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602394 = validateParameter(valid_602394, JString, required = false,
                                 default = nil)
  if valid_602394 != nil:
    section.add "X-Amz-Content-Sha256", valid_602394
  var valid_602395 = header.getOrDefault("X-Amz-Date")
  valid_602395 = validateParameter(valid_602395, JString, required = false,
                                 default = nil)
  if valid_602395 != nil:
    section.add "X-Amz-Date", valid_602395
  var valid_602396 = header.getOrDefault("X-Amz-Credential")
  valid_602396 = validateParameter(valid_602396, JString, required = false,
                                 default = nil)
  if valid_602396 != nil:
    section.add "X-Amz-Credential", valid_602396
  var valid_602397 = header.getOrDefault("X-Amz-Security-Token")
  valid_602397 = validateParameter(valid_602397, JString, required = false,
                                 default = nil)
  if valid_602397 != nil:
    section.add "X-Amz-Security-Token", valid_602397
  var valid_602398 = header.getOrDefault("X-Amz-Algorithm")
  valid_602398 = validateParameter(valid_602398, JString, required = false,
                                 default = nil)
  if valid_602398 != nil:
    section.add "X-Amz-Algorithm", valid_602398
  var valid_602399 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602399 = validateParameter(valid_602399, JString, required = false,
                                 default = nil)
  if valid_602399 != nil:
    section.add "X-Amz-SignedHeaders", valid_602399
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602400: Call_DeleteBillingGroup_602388; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the billing group.
  ## 
  let valid = call_602400.validator(path, query, header, formData, body)
  let scheme = call_602400.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602400.url(scheme.get, call_602400.host, call_602400.base,
                         call_602400.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602400, url, valid)

proc call*(call_602401: Call_DeleteBillingGroup_602388; billingGroupName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteBillingGroup
  ## Deletes the billing group.
  ##   expectedVersion: int
  ##                  : The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_602402 = newJObject()
  var query_602403 = newJObject()
  add(query_602403, "expectedVersion", newJInt(expectedVersion))
  add(path_602402, "billingGroupName", newJString(billingGroupName))
  result = call_602401.call(path_602402, query_602403, nil, nil, nil)

var deleteBillingGroup* = Call_DeleteBillingGroup_602388(
    name: "deleteBillingGroup", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_DeleteBillingGroup_602389, base: "/",
    url: url_DeleteBillingGroup_602390, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateCertificateFromCsr_602436 = ref object of OpenApiRestCall_601389
proc url_CreateCertificateFromCsr_602438(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateCertificateFromCsr_602437(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_602439 = query.getOrDefault("setAsActive")
  valid_602439 = validateParameter(valid_602439, JBool, required = false, default = nil)
  if valid_602439 != nil:
    section.add "setAsActive", valid_602439
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602440 = header.getOrDefault("X-Amz-Signature")
  valid_602440 = validateParameter(valid_602440, JString, required = false,
                                 default = nil)
  if valid_602440 != nil:
    section.add "X-Amz-Signature", valid_602440
  var valid_602441 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602441 = validateParameter(valid_602441, JString, required = false,
                                 default = nil)
  if valid_602441 != nil:
    section.add "X-Amz-Content-Sha256", valid_602441
  var valid_602442 = header.getOrDefault("X-Amz-Date")
  valid_602442 = validateParameter(valid_602442, JString, required = false,
                                 default = nil)
  if valid_602442 != nil:
    section.add "X-Amz-Date", valid_602442
  var valid_602443 = header.getOrDefault("X-Amz-Credential")
  valid_602443 = validateParameter(valid_602443, JString, required = false,
                                 default = nil)
  if valid_602443 != nil:
    section.add "X-Amz-Credential", valid_602443
  var valid_602444 = header.getOrDefault("X-Amz-Security-Token")
  valid_602444 = validateParameter(valid_602444, JString, required = false,
                                 default = nil)
  if valid_602444 != nil:
    section.add "X-Amz-Security-Token", valid_602444
  var valid_602445 = header.getOrDefault("X-Amz-Algorithm")
  valid_602445 = validateParameter(valid_602445, JString, required = false,
                                 default = nil)
  if valid_602445 != nil:
    section.add "X-Amz-Algorithm", valid_602445
  var valid_602446 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602446 = validateParameter(valid_602446, JString, required = false,
                                 default = nil)
  if valid_602446 != nil:
    section.add "X-Amz-SignedHeaders", valid_602446
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602448: Call_CreateCertificateFromCsr_602436; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ## 
  let valid = call_602448.validator(path, query, header, formData, body)
  let scheme = call_602448.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602448.url(scheme.get, call_602448.host, call_602448.base,
                         call_602448.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602448, url, valid)

proc call*(call_602449: Call_CreateCertificateFromCsr_602436; body: JsonNode;
          setAsActive: bool = false): Recallable =
  ## createCertificateFromCsr
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  ##   body: JObject (required)
  var query_602450 = newJObject()
  var body_602451 = newJObject()
  add(query_602450, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_602451 = body
  result = call_602449.call(nil, query_602450, nil, nil, body_602451)

var createCertificateFromCsr* = Call_CreateCertificateFromCsr_602436(
    name: "createCertificateFromCsr", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/certificates",
    validator: validate_CreateCertificateFromCsr_602437, base: "/",
    url: url_CreateCertificateFromCsr_602438, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCertificates_602420 = ref object of OpenApiRestCall_601389
proc url_ListCertificates_602422(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListCertificates_602421(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_602423 = query.getOrDefault("isAscendingOrder")
  valid_602423 = validateParameter(valid_602423, JBool, required = false, default = nil)
  if valid_602423 != nil:
    section.add "isAscendingOrder", valid_602423
  var valid_602424 = query.getOrDefault("pageSize")
  valid_602424 = validateParameter(valid_602424, JInt, required = false, default = nil)
  if valid_602424 != nil:
    section.add "pageSize", valid_602424
  var valid_602425 = query.getOrDefault("marker")
  valid_602425 = validateParameter(valid_602425, JString, required = false,
                                 default = nil)
  if valid_602425 != nil:
    section.add "marker", valid_602425
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602426 = header.getOrDefault("X-Amz-Signature")
  valid_602426 = validateParameter(valid_602426, JString, required = false,
                                 default = nil)
  if valid_602426 != nil:
    section.add "X-Amz-Signature", valid_602426
  var valid_602427 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602427 = validateParameter(valid_602427, JString, required = false,
                                 default = nil)
  if valid_602427 != nil:
    section.add "X-Amz-Content-Sha256", valid_602427
  var valid_602428 = header.getOrDefault("X-Amz-Date")
  valid_602428 = validateParameter(valid_602428, JString, required = false,
                                 default = nil)
  if valid_602428 != nil:
    section.add "X-Amz-Date", valid_602428
  var valid_602429 = header.getOrDefault("X-Amz-Credential")
  valid_602429 = validateParameter(valid_602429, JString, required = false,
                                 default = nil)
  if valid_602429 != nil:
    section.add "X-Amz-Credential", valid_602429
  var valid_602430 = header.getOrDefault("X-Amz-Security-Token")
  valid_602430 = validateParameter(valid_602430, JString, required = false,
                                 default = nil)
  if valid_602430 != nil:
    section.add "X-Amz-Security-Token", valid_602430
  var valid_602431 = header.getOrDefault("X-Amz-Algorithm")
  valid_602431 = validateParameter(valid_602431, JString, required = false,
                                 default = nil)
  if valid_602431 != nil:
    section.add "X-Amz-Algorithm", valid_602431
  var valid_602432 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602432 = validateParameter(valid_602432, JString, required = false,
                                 default = nil)
  if valid_602432 != nil:
    section.add "X-Amz-SignedHeaders", valid_602432
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602433: Call_ListCertificates_602420; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  let valid = call_602433.validator(path, query, header, formData, body)
  let scheme = call_602433.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602433.url(scheme.get, call_602433.host, call_602433.base,
                         call_602433.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602433, url, valid)

proc call*(call_602434: Call_ListCertificates_602420;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listCertificates
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_602435 = newJObject()
  add(query_602435, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_602435, "pageSize", newJInt(pageSize))
  add(query_602435, "marker", newJString(marker))
  result = call_602434.call(nil, query_602435, nil, nil, nil)

var listCertificates* = Call_ListCertificates_602420(name: "listCertificates",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/certificates",
    validator: validate_ListCertificates_602421, base: "/",
    url: url_ListCertificates_602422, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateDomainConfiguration_602466 = ref object of OpenApiRestCall_601389
proc url_UpdateDomainConfiguration_602468(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "domainConfigurationName" in path,
        "`domainConfigurationName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/domainConfigurations/"),
               (kind: VariableSegment, value: "domainConfigurationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateDomainConfiguration_602467(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Updates values stored in the domain configuration. Domain configurations for default endpoints can't be updated.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   domainConfigurationName: JString (required)
  ##                          : The name of the domain configuration to be updated.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `domainConfigurationName` field"
  var valid_602469 = path.getOrDefault("domainConfigurationName")
  valid_602469 = validateParameter(valid_602469, JString, required = true,
                                 default = nil)
  if valid_602469 != nil:
    section.add "domainConfigurationName", valid_602469
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602470 = header.getOrDefault("X-Amz-Signature")
  valid_602470 = validateParameter(valid_602470, JString, required = false,
                                 default = nil)
  if valid_602470 != nil:
    section.add "X-Amz-Signature", valid_602470
  var valid_602471 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602471 = validateParameter(valid_602471, JString, required = false,
                                 default = nil)
  if valid_602471 != nil:
    section.add "X-Amz-Content-Sha256", valid_602471
  var valid_602472 = header.getOrDefault("X-Amz-Date")
  valid_602472 = validateParameter(valid_602472, JString, required = false,
                                 default = nil)
  if valid_602472 != nil:
    section.add "X-Amz-Date", valid_602472
  var valid_602473 = header.getOrDefault("X-Amz-Credential")
  valid_602473 = validateParameter(valid_602473, JString, required = false,
                                 default = nil)
  if valid_602473 != nil:
    section.add "X-Amz-Credential", valid_602473
  var valid_602474 = header.getOrDefault("X-Amz-Security-Token")
  valid_602474 = validateParameter(valid_602474, JString, required = false,
                                 default = nil)
  if valid_602474 != nil:
    section.add "X-Amz-Security-Token", valid_602474
  var valid_602475 = header.getOrDefault("X-Amz-Algorithm")
  valid_602475 = validateParameter(valid_602475, JString, required = false,
                                 default = nil)
  if valid_602475 != nil:
    section.add "X-Amz-Algorithm", valid_602475
  var valid_602476 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602476 = validateParameter(valid_602476, JString, required = false,
                                 default = nil)
  if valid_602476 != nil:
    section.add "X-Amz-SignedHeaders", valid_602476
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602478: Call_UpdateDomainConfiguration_602466; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Updates values stored in the domain configuration. Domain configurations for default endpoints can't be updated.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_602478.validator(path, query, header, formData, body)
  let scheme = call_602478.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602478.url(scheme.get, call_602478.host, call_602478.base,
                         call_602478.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602478, url, valid)

proc call*(call_602479: Call_UpdateDomainConfiguration_602466; body: JsonNode;
          domainConfigurationName: string): Recallable =
  ## updateDomainConfiguration
  ## <p>Updates values stored in the domain configuration. Domain configurations for default endpoints can't be updated.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   body: JObject (required)
  ##   domainConfigurationName: string (required)
  ##                          : The name of the domain configuration to be updated.
  var path_602480 = newJObject()
  var body_602481 = newJObject()
  if body != nil:
    body_602481 = body
  add(path_602480, "domainConfigurationName", newJString(domainConfigurationName))
  result = call_602479.call(path_602480, nil, nil, nil, body_602481)

var updateDomainConfiguration* = Call_UpdateDomainConfiguration_602466(
    name: "updateDomainConfiguration", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/domainConfigurations/{domainConfigurationName}",
    validator: validate_UpdateDomainConfiguration_602467, base: "/",
    url: url_UpdateDomainConfiguration_602468,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateDomainConfiguration_602482 = ref object of OpenApiRestCall_601389
proc url_CreateDomainConfiguration_602484(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "domainConfigurationName" in path,
        "`domainConfigurationName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/domainConfigurations/"),
               (kind: VariableSegment, value: "domainConfigurationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateDomainConfiguration_602483(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   domainConfigurationName: JString (required)
  ##                          : The name of the domain configuration. This value must be unique to a region.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `domainConfigurationName` field"
  var valid_602485 = path.getOrDefault("domainConfigurationName")
  valid_602485 = validateParameter(valid_602485, JString, required = true,
                                 default = nil)
  if valid_602485 != nil:
    section.add "domainConfigurationName", valid_602485
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602486 = header.getOrDefault("X-Amz-Signature")
  valid_602486 = validateParameter(valid_602486, JString, required = false,
                                 default = nil)
  if valid_602486 != nil:
    section.add "X-Amz-Signature", valid_602486
  var valid_602487 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602487 = validateParameter(valid_602487, JString, required = false,
                                 default = nil)
  if valid_602487 != nil:
    section.add "X-Amz-Content-Sha256", valid_602487
  var valid_602488 = header.getOrDefault("X-Amz-Date")
  valid_602488 = validateParameter(valid_602488, JString, required = false,
                                 default = nil)
  if valid_602488 != nil:
    section.add "X-Amz-Date", valid_602488
  var valid_602489 = header.getOrDefault("X-Amz-Credential")
  valid_602489 = validateParameter(valid_602489, JString, required = false,
                                 default = nil)
  if valid_602489 != nil:
    section.add "X-Amz-Credential", valid_602489
  var valid_602490 = header.getOrDefault("X-Amz-Security-Token")
  valid_602490 = validateParameter(valid_602490, JString, required = false,
                                 default = nil)
  if valid_602490 != nil:
    section.add "X-Amz-Security-Token", valid_602490
  var valid_602491 = header.getOrDefault("X-Amz-Algorithm")
  valid_602491 = validateParameter(valid_602491, JString, required = false,
                                 default = nil)
  if valid_602491 != nil:
    section.add "X-Amz-Algorithm", valid_602491
  var valid_602492 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602492 = validateParameter(valid_602492, JString, required = false,
                                 default = nil)
  if valid_602492 != nil:
    section.add "X-Amz-SignedHeaders", valid_602492
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602494: Call_CreateDomainConfiguration_602482; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_602494.validator(path, query, header, formData, body)
  let scheme = call_602494.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602494.url(scheme.get, call_602494.host, call_602494.base,
                         call_602494.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602494, url, valid)

proc call*(call_602495: Call_CreateDomainConfiguration_602482; body: JsonNode;
          domainConfigurationName: string): Recallable =
  ## createDomainConfiguration
  ## <p>Creates a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   body: JObject (required)
  ##   domainConfigurationName: string (required)
  ##                          : The name of the domain configuration. This value must be unique to a region.
  var path_602496 = newJObject()
  var body_602497 = newJObject()
  if body != nil:
    body_602497 = body
  add(path_602496, "domainConfigurationName", newJString(domainConfigurationName))
  result = call_602495.call(path_602496, nil, nil, nil, body_602497)

var createDomainConfiguration* = Call_CreateDomainConfiguration_602482(
    name: "createDomainConfiguration", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/domainConfigurations/{domainConfigurationName}",
    validator: validate_CreateDomainConfiguration_602483, base: "/",
    url: url_CreateDomainConfiguration_602484,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeDomainConfiguration_602452 = ref object of OpenApiRestCall_601389
proc url_DescribeDomainConfiguration_602454(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "domainConfigurationName" in path,
        "`domainConfigurationName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/domainConfigurations/"),
               (kind: VariableSegment, value: "domainConfigurationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeDomainConfiguration_602453(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Gets summary information about a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   domainConfigurationName: JString (required)
  ##                          : The name of the domain configuration.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `domainConfigurationName` field"
  var valid_602455 = path.getOrDefault("domainConfigurationName")
  valid_602455 = validateParameter(valid_602455, JString, required = true,
                                 default = nil)
  if valid_602455 != nil:
    section.add "domainConfigurationName", valid_602455
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602456 = header.getOrDefault("X-Amz-Signature")
  valid_602456 = validateParameter(valid_602456, JString, required = false,
                                 default = nil)
  if valid_602456 != nil:
    section.add "X-Amz-Signature", valid_602456
  var valid_602457 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602457 = validateParameter(valid_602457, JString, required = false,
                                 default = nil)
  if valid_602457 != nil:
    section.add "X-Amz-Content-Sha256", valid_602457
  var valid_602458 = header.getOrDefault("X-Amz-Date")
  valid_602458 = validateParameter(valid_602458, JString, required = false,
                                 default = nil)
  if valid_602458 != nil:
    section.add "X-Amz-Date", valid_602458
  var valid_602459 = header.getOrDefault("X-Amz-Credential")
  valid_602459 = validateParameter(valid_602459, JString, required = false,
                                 default = nil)
  if valid_602459 != nil:
    section.add "X-Amz-Credential", valid_602459
  var valid_602460 = header.getOrDefault("X-Amz-Security-Token")
  valid_602460 = validateParameter(valid_602460, JString, required = false,
                                 default = nil)
  if valid_602460 != nil:
    section.add "X-Amz-Security-Token", valid_602460
  var valid_602461 = header.getOrDefault("X-Amz-Algorithm")
  valid_602461 = validateParameter(valid_602461, JString, required = false,
                                 default = nil)
  if valid_602461 != nil:
    section.add "X-Amz-Algorithm", valid_602461
  var valid_602462 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602462 = validateParameter(valid_602462, JString, required = false,
                                 default = nil)
  if valid_602462 != nil:
    section.add "X-Amz-SignedHeaders", valid_602462
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602463: Call_DescribeDomainConfiguration_602452; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Gets summary information about a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_602463.validator(path, query, header, formData, body)
  let scheme = call_602463.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602463.url(scheme.get, call_602463.host, call_602463.base,
                         call_602463.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602463, url, valid)

proc call*(call_602464: Call_DescribeDomainConfiguration_602452;
          domainConfigurationName: string): Recallable =
  ## describeDomainConfiguration
  ## <p>Gets summary information about a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   domainConfigurationName: string (required)
  ##                          : The name of the domain configuration.
  var path_602465 = newJObject()
  add(path_602465, "domainConfigurationName", newJString(domainConfigurationName))
  result = call_602464.call(path_602465, nil, nil, nil, nil)

var describeDomainConfiguration* = Call_DescribeDomainConfiguration_602452(
    name: "describeDomainConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/domainConfigurations/{domainConfigurationName}",
    validator: validate_DescribeDomainConfiguration_602453, base: "/",
    url: url_DescribeDomainConfiguration_602454,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteDomainConfiguration_602498 = ref object of OpenApiRestCall_601389
proc url_DeleteDomainConfiguration_602500(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "domainConfigurationName" in path,
        "`domainConfigurationName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/domainConfigurations/"),
               (kind: VariableSegment, value: "domainConfigurationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteDomainConfiguration_602499(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   domainConfigurationName: JString (required)
  ##                          : The name of the domain configuration to be deleted.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `domainConfigurationName` field"
  var valid_602501 = path.getOrDefault("domainConfigurationName")
  valid_602501 = validateParameter(valid_602501, JString, required = true,
                                 default = nil)
  if valid_602501 != nil:
    section.add "domainConfigurationName", valid_602501
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602502 = header.getOrDefault("X-Amz-Signature")
  valid_602502 = validateParameter(valid_602502, JString, required = false,
                                 default = nil)
  if valid_602502 != nil:
    section.add "X-Amz-Signature", valid_602502
  var valid_602503 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602503 = validateParameter(valid_602503, JString, required = false,
                                 default = nil)
  if valid_602503 != nil:
    section.add "X-Amz-Content-Sha256", valid_602503
  var valid_602504 = header.getOrDefault("X-Amz-Date")
  valid_602504 = validateParameter(valid_602504, JString, required = false,
                                 default = nil)
  if valid_602504 != nil:
    section.add "X-Amz-Date", valid_602504
  var valid_602505 = header.getOrDefault("X-Amz-Credential")
  valid_602505 = validateParameter(valid_602505, JString, required = false,
                                 default = nil)
  if valid_602505 != nil:
    section.add "X-Amz-Credential", valid_602505
  var valid_602506 = header.getOrDefault("X-Amz-Security-Token")
  valid_602506 = validateParameter(valid_602506, JString, required = false,
                                 default = nil)
  if valid_602506 != nil:
    section.add "X-Amz-Security-Token", valid_602506
  var valid_602507 = header.getOrDefault("X-Amz-Algorithm")
  valid_602507 = validateParameter(valid_602507, JString, required = false,
                                 default = nil)
  if valid_602507 != nil:
    section.add "X-Amz-Algorithm", valid_602507
  var valid_602508 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602508 = validateParameter(valid_602508, JString, required = false,
                                 default = nil)
  if valid_602508 != nil:
    section.add "X-Amz-SignedHeaders", valid_602508
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602509: Call_DeleteDomainConfiguration_602498; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_602509.validator(path, query, header, formData, body)
  let scheme = call_602509.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602509.url(scheme.get, call_602509.host, call_602509.base,
                         call_602509.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602509, url, valid)

proc call*(call_602510: Call_DeleteDomainConfiguration_602498;
          domainConfigurationName: string): Recallable =
  ## deleteDomainConfiguration
  ## <p>Deletes the specified domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   domainConfigurationName: string (required)
  ##                          : The name of the domain configuration to be deleted.
  var path_602511 = newJObject()
  add(path_602511, "domainConfigurationName", newJString(domainConfigurationName))
  result = call_602510.call(path_602511, nil, nil, nil, nil)

var deleteDomainConfiguration* = Call_DeleteDomainConfiguration_602498(
    name: "deleteDomainConfiguration", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/domainConfigurations/{domainConfigurationName}",
    validator: validate_DeleteDomainConfiguration_602499, base: "/",
    url: url_DeleteDomainConfiguration_602500,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateDynamicThingGroup_602512 = ref object of OpenApiRestCall_601389
proc url_CreateDynamicThingGroup_602514(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateDynamicThingGroup_602513(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The dynamic thing group name to create.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_602515 = path.getOrDefault("thingGroupName")
  valid_602515 = validateParameter(valid_602515, JString, required = true,
                                 default = nil)
  if valid_602515 != nil:
    section.add "thingGroupName", valid_602515
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602516 = header.getOrDefault("X-Amz-Signature")
  valid_602516 = validateParameter(valid_602516, JString, required = false,
                                 default = nil)
  if valid_602516 != nil:
    section.add "X-Amz-Signature", valid_602516
  var valid_602517 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602517 = validateParameter(valid_602517, JString, required = false,
                                 default = nil)
  if valid_602517 != nil:
    section.add "X-Amz-Content-Sha256", valid_602517
  var valid_602518 = header.getOrDefault("X-Amz-Date")
  valid_602518 = validateParameter(valid_602518, JString, required = false,
                                 default = nil)
  if valid_602518 != nil:
    section.add "X-Amz-Date", valid_602518
  var valid_602519 = header.getOrDefault("X-Amz-Credential")
  valid_602519 = validateParameter(valid_602519, JString, required = false,
                                 default = nil)
  if valid_602519 != nil:
    section.add "X-Amz-Credential", valid_602519
  var valid_602520 = header.getOrDefault("X-Amz-Security-Token")
  valid_602520 = validateParameter(valid_602520, JString, required = false,
                                 default = nil)
  if valid_602520 != nil:
    section.add "X-Amz-Security-Token", valid_602520
  var valid_602521 = header.getOrDefault("X-Amz-Algorithm")
  valid_602521 = validateParameter(valid_602521, JString, required = false,
                                 default = nil)
  if valid_602521 != nil:
    section.add "X-Amz-Algorithm", valid_602521
  var valid_602522 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602522 = validateParameter(valid_602522, JString, required = false,
                                 default = nil)
  if valid_602522 != nil:
    section.add "X-Amz-SignedHeaders", valid_602522
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602524: Call_CreateDynamicThingGroup_602512; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a dynamic thing group.
  ## 
  let valid = call_602524.validator(path, query, header, formData, body)
  let scheme = call_602524.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602524.url(scheme.get, call_602524.host, call_602524.base,
                         call_602524.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602524, url, valid)

proc call*(call_602525: Call_CreateDynamicThingGroup_602512;
          thingGroupName: string; body: JsonNode): Recallable =
  ## createDynamicThingGroup
  ## Creates a dynamic thing group.
  ##   thingGroupName: string (required)
  ##                 : The dynamic thing group name to create.
  ##   body: JObject (required)
  var path_602526 = newJObject()
  var body_602527 = newJObject()
  add(path_602526, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_602527 = body
  result = call_602525.call(path_602526, nil, nil, nil, body_602527)

var createDynamicThingGroup* = Call_CreateDynamicThingGroup_602512(
    name: "createDynamicThingGroup", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_CreateDynamicThingGroup_602513, base: "/",
    url: url_CreateDynamicThingGroup_602514, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateDynamicThingGroup_602544 = ref object of OpenApiRestCall_601389
proc url_UpdateDynamicThingGroup_602546(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateDynamicThingGroup_602545(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the dynamic thing group to update.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_602547 = path.getOrDefault("thingGroupName")
  valid_602547 = validateParameter(valid_602547, JString, required = true,
                                 default = nil)
  if valid_602547 != nil:
    section.add "thingGroupName", valid_602547
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602548 = header.getOrDefault("X-Amz-Signature")
  valid_602548 = validateParameter(valid_602548, JString, required = false,
                                 default = nil)
  if valid_602548 != nil:
    section.add "X-Amz-Signature", valid_602548
  var valid_602549 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602549 = validateParameter(valid_602549, JString, required = false,
                                 default = nil)
  if valid_602549 != nil:
    section.add "X-Amz-Content-Sha256", valid_602549
  var valid_602550 = header.getOrDefault("X-Amz-Date")
  valid_602550 = validateParameter(valid_602550, JString, required = false,
                                 default = nil)
  if valid_602550 != nil:
    section.add "X-Amz-Date", valid_602550
  var valid_602551 = header.getOrDefault("X-Amz-Credential")
  valid_602551 = validateParameter(valid_602551, JString, required = false,
                                 default = nil)
  if valid_602551 != nil:
    section.add "X-Amz-Credential", valid_602551
  var valid_602552 = header.getOrDefault("X-Amz-Security-Token")
  valid_602552 = validateParameter(valid_602552, JString, required = false,
                                 default = nil)
  if valid_602552 != nil:
    section.add "X-Amz-Security-Token", valid_602552
  var valid_602553 = header.getOrDefault("X-Amz-Algorithm")
  valid_602553 = validateParameter(valid_602553, JString, required = false,
                                 default = nil)
  if valid_602553 != nil:
    section.add "X-Amz-Algorithm", valid_602553
  var valid_602554 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602554 = validateParameter(valid_602554, JString, required = false,
                                 default = nil)
  if valid_602554 != nil:
    section.add "X-Amz-SignedHeaders", valid_602554
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602556: Call_UpdateDynamicThingGroup_602544; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a dynamic thing group.
  ## 
  let valid = call_602556.validator(path, query, header, formData, body)
  let scheme = call_602556.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602556.url(scheme.get, call_602556.host, call_602556.base,
                         call_602556.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602556, url, valid)

proc call*(call_602557: Call_UpdateDynamicThingGroup_602544;
          thingGroupName: string; body: JsonNode): Recallable =
  ## updateDynamicThingGroup
  ## Updates a dynamic thing group.
  ##   thingGroupName: string (required)
  ##                 : The name of the dynamic thing group to update.
  ##   body: JObject (required)
  var path_602558 = newJObject()
  var body_602559 = newJObject()
  add(path_602558, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_602559 = body
  result = call_602557.call(path_602558, nil, nil, nil, body_602559)

var updateDynamicThingGroup* = Call_UpdateDynamicThingGroup_602544(
    name: "updateDynamicThingGroup", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_UpdateDynamicThingGroup_602545, base: "/",
    url: url_UpdateDynamicThingGroup_602546, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteDynamicThingGroup_602528 = ref object of OpenApiRestCall_601389
proc url_DeleteDynamicThingGroup_602530(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteDynamicThingGroup_602529(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the dynamic thing group to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_602531 = path.getOrDefault("thingGroupName")
  valid_602531 = validateParameter(valid_602531, JString, required = true,
                                 default = nil)
  if valid_602531 != nil:
    section.add "thingGroupName", valid_602531
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the dynamic thing group to delete.
  section = newJObject()
  var valid_602532 = query.getOrDefault("expectedVersion")
  valid_602532 = validateParameter(valid_602532, JInt, required = false, default = nil)
  if valid_602532 != nil:
    section.add "expectedVersion", valid_602532
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602533 = header.getOrDefault("X-Amz-Signature")
  valid_602533 = validateParameter(valid_602533, JString, required = false,
                                 default = nil)
  if valid_602533 != nil:
    section.add "X-Amz-Signature", valid_602533
  var valid_602534 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602534 = validateParameter(valid_602534, JString, required = false,
                                 default = nil)
  if valid_602534 != nil:
    section.add "X-Amz-Content-Sha256", valid_602534
  var valid_602535 = header.getOrDefault("X-Amz-Date")
  valid_602535 = validateParameter(valid_602535, JString, required = false,
                                 default = nil)
  if valid_602535 != nil:
    section.add "X-Amz-Date", valid_602535
  var valid_602536 = header.getOrDefault("X-Amz-Credential")
  valid_602536 = validateParameter(valid_602536, JString, required = false,
                                 default = nil)
  if valid_602536 != nil:
    section.add "X-Amz-Credential", valid_602536
  var valid_602537 = header.getOrDefault("X-Amz-Security-Token")
  valid_602537 = validateParameter(valid_602537, JString, required = false,
                                 default = nil)
  if valid_602537 != nil:
    section.add "X-Amz-Security-Token", valid_602537
  var valid_602538 = header.getOrDefault("X-Amz-Algorithm")
  valid_602538 = validateParameter(valid_602538, JString, required = false,
                                 default = nil)
  if valid_602538 != nil:
    section.add "X-Amz-Algorithm", valid_602538
  var valid_602539 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602539 = validateParameter(valid_602539, JString, required = false,
                                 default = nil)
  if valid_602539 != nil:
    section.add "X-Amz-SignedHeaders", valid_602539
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602540: Call_DeleteDynamicThingGroup_602528; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a dynamic thing group.
  ## 
  let valid = call_602540.validator(path, query, header, formData, body)
  let scheme = call_602540.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602540.url(scheme.get, call_602540.host, call_602540.base,
                         call_602540.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602540, url, valid)

proc call*(call_602541: Call_DeleteDynamicThingGroup_602528;
          thingGroupName: string; expectedVersion: int = 0): Recallable =
  ## deleteDynamicThingGroup
  ## Deletes a dynamic thing group.
  ##   expectedVersion: int
  ##                  : The expected version of the dynamic thing group to delete.
  ##   thingGroupName: string (required)
  ##                 : The name of the dynamic thing group to delete.
  var path_602542 = newJObject()
  var query_602543 = newJObject()
  add(query_602543, "expectedVersion", newJInt(expectedVersion))
  add(path_602542, "thingGroupName", newJString(thingGroupName))
  result = call_602541.call(path_602542, query_602543, nil, nil, nil)

var deleteDynamicThingGroup* = Call_DeleteDynamicThingGroup_602528(
    name: "deleteDynamicThingGroup", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_DeleteDynamicThingGroup_602529, base: "/",
    url: url_DeleteDynamicThingGroup_602530, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateJob_602574 = ref object of OpenApiRestCall_601389
proc url_CreateJob_602576(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateJob_602575(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_602577 = path.getOrDefault("jobId")
  valid_602577 = validateParameter(valid_602577, JString, required = true,
                                 default = nil)
  if valid_602577 != nil:
    section.add "jobId", valid_602577
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602578 = header.getOrDefault("X-Amz-Signature")
  valid_602578 = validateParameter(valid_602578, JString, required = false,
                                 default = nil)
  if valid_602578 != nil:
    section.add "X-Amz-Signature", valid_602578
  var valid_602579 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602579 = validateParameter(valid_602579, JString, required = false,
                                 default = nil)
  if valid_602579 != nil:
    section.add "X-Amz-Content-Sha256", valid_602579
  var valid_602580 = header.getOrDefault("X-Amz-Date")
  valid_602580 = validateParameter(valid_602580, JString, required = false,
                                 default = nil)
  if valid_602580 != nil:
    section.add "X-Amz-Date", valid_602580
  var valid_602581 = header.getOrDefault("X-Amz-Credential")
  valid_602581 = validateParameter(valid_602581, JString, required = false,
                                 default = nil)
  if valid_602581 != nil:
    section.add "X-Amz-Credential", valid_602581
  var valid_602582 = header.getOrDefault("X-Amz-Security-Token")
  valid_602582 = validateParameter(valid_602582, JString, required = false,
                                 default = nil)
  if valid_602582 != nil:
    section.add "X-Amz-Security-Token", valid_602582
  var valid_602583 = header.getOrDefault("X-Amz-Algorithm")
  valid_602583 = validateParameter(valid_602583, JString, required = false,
                                 default = nil)
  if valid_602583 != nil:
    section.add "X-Amz-Algorithm", valid_602583
  var valid_602584 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602584 = validateParameter(valid_602584, JString, required = false,
                                 default = nil)
  if valid_602584 != nil:
    section.add "X-Amz-SignedHeaders", valid_602584
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602586: Call_CreateJob_602574; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a job.
  ## 
  let valid = call_602586.validator(path, query, header, formData, body)
  let scheme = call_602586.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602586.url(scheme.get, call_602586.host, call_602586.base,
                         call_602586.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602586, url, valid)

proc call*(call_602587: Call_CreateJob_602574; jobId: string; body: JsonNode): Recallable =
  ## createJob
  ## Creates a job.
  ##   jobId: string (required)
  ##        : A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
  ##   body: JObject (required)
  var path_602588 = newJObject()
  var body_602589 = newJObject()
  add(path_602588, "jobId", newJString(jobId))
  if body != nil:
    body_602589 = body
  result = call_602587.call(path_602588, nil, nil, nil, body_602589)

var createJob* = Call_CreateJob_602574(name: "createJob", meth: HttpMethod.HttpPut,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_CreateJob_602575,
                                    base: "/", url: url_CreateJob_602576,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeJob_602560 = ref object of OpenApiRestCall_601389
proc url_DescribeJob_602562(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeJob_602561(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_602563 = path.getOrDefault("jobId")
  valid_602563 = validateParameter(valid_602563, JString, required = true,
                                 default = nil)
  if valid_602563 != nil:
    section.add "jobId", valid_602563
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602564 = header.getOrDefault("X-Amz-Signature")
  valid_602564 = validateParameter(valid_602564, JString, required = false,
                                 default = nil)
  if valid_602564 != nil:
    section.add "X-Amz-Signature", valid_602564
  var valid_602565 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602565 = validateParameter(valid_602565, JString, required = false,
                                 default = nil)
  if valid_602565 != nil:
    section.add "X-Amz-Content-Sha256", valid_602565
  var valid_602566 = header.getOrDefault("X-Amz-Date")
  valid_602566 = validateParameter(valid_602566, JString, required = false,
                                 default = nil)
  if valid_602566 != nil:
    section.add "X-Amz-Date", valid_602566
  var valid_602567 = header.getOrDefault("X-Amz-Credential")
  valid_602567 = validateParameter(valid_602567, JString, required = false,
                                 default = nil)
  if valid_602567 != nil:
    section.add "X-Amz-Credential", valid_602567
  var valid_602568 = header.getOrDefault("X-Amz-Security-Token")
  valid_602568 = validateParameter(valid_602568, JString, required = false,
                                 default = nil)
  if valid_602568 != nil:
    section.add "X-Amz-Security-Token", valid_602568
  var valid_602569 = header.getOrDefault("X-Amz-Algorithm")
  valid_602569 = validateParameter(valid_602569, JString, required = false,
                                 default = nil)
  if valid_602569 != nil:
    section.add "X-Amz-Algorithm", valid_602569
  var valid_602570 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602570 = validateParameter(valid_602570, JString, required = false,
                                 default = nil)
  if valid_602570 != nil:
    section.add "X-Amz-SignedHeaders", valid_602570
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602571: Call_DescribeJob_602560; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a job.
  ## 
  let valid = call_602571.validator(path, query, header, formData, body)
  let scheme = call_602571.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602571.url(scheme.get, call_602571.host, call_602571.base,
                         call_602571.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602571, url, valid)

proc call*(call_602572: Call_DescribeJob_602560; jobId: string): Recallable =
  ## describeJob
  ## Describes a job.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  var path_602573 = newJObject()
  add(path_602573, "jobId", newJString(jobId))
  result = call_602572.call(path_602573, nil, nil, nil, nil)

var describeJob* = Call_DescribeJob_602560(name: "describeJob",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/jobs/{jobId}",
                                        validator: validate_DescribeJob_602561,
                                        base: "/", url: url_DescribeJob_602562,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateJob_602606 = ref object of OpenApiRestCall_601389
proc url_UpdateJob_602608(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateJob_602607(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates supported fields of the specified job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The ID of the job to be updated.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_602609 = path.getOrDefault("jobId")
  valid_602609 = validateParameter(valid_602609, JString, required = true,
                                 default = nil)
  if valid_602609 != nil:
    section.add "jobId", valid_602609
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602610 = header.getOrDefault("X-Amz-Signature")
  valid_602610 = validateParameter(valid_602610, JString, required = false,
                                 default = nil)
  if valid_602610 != nil:
    section.add "X-Amz-Signature", valid_602610
  var valid_602611 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602611 = validateParameter(valid_602611, JString, required = false,
                                 default = nil)
  if valid_602611 != nil:
    section.add "X-Amz-Content-Sha256", valid_602611
  var valid_602612 = header.getOrDefault("X-Amz-Date")
  valid_602612 = validateParameter(valid_602612, JString, required = false,
                                 default = nil)
  if valid_602612 != nil:
    section.add "X-Amz-Date", valid_602612
  var valid_602613 = header.getOrDefault("X-Amz-Credential")
  valid_602613 = validateParameter(valid_602613, JString, required = false,
                                 default = nil)
  if valid_602613 != nil:
    section.add "X-Amz-Credential", valid_602613
  var valid_602614 = header.getOrDefault("X-Amz-Security-Token")
  valid_602614 = validateParameter(valid_602614, JString, required = false,
                                 default = nil)
  if valid_602614 != nil:
    section.add "X-Amz-Security-Token", valid_602614
  var valid_602615 = header.getOrDefault("X-Amz-Algorithm")
  valid_602615 = validateParameter(valid_602615, JString, required = false,
                                 default = nil)
  if valid_602615 != nil:
    section.add "X-Amz-Algorithm", valid_602615
  var valid_602616 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602616 = validateParameter(valid_602616, JString, required = false,
                                 default = nil)
  if valid_602616 != nil:
    section.add "X-Amz-SignedHeaders", valid_602616
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602618: Call_UpdateJob_602606; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates supported fields of the specified job.
  ## 
  let valid = call_602618.validator(path, query, header, formData, body)
  let scheme = call_602618.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602618.url(scheme.get, call_602618.host, call_602618.base,
                         call_602618.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602618, url, valid)

proc call*(call_602619: Call_UpdateJob_602606; jobId: string; body: JsonNode): Recallable =
  ## updateJob
  ## Updates supported fields of the specified job.
  ##   jobId: string (required)
  ##        : The ID of the job to be updated.
  ##   body: JObject (required)
  var path_602620 = newJObject()
  var body_602621 = newJObject()
  add(path_602620, "jobId", newJString(jobId))
  if body != nil:
    body_602621 = body
  result = call_602619.call(path_602620, nil, nil, nil, body_602621)

var updateJob* = Call_UpdateJob_602606(name: "updateJob", meth: HttpMethod.HttpPatch,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_UpdateJob_602607,
                                    base: "/", url: url_UpdateJob_602608,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteJob_602590 = ref object of OpenApiRestCall_601389
proc url_DeleteJob_602592(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteJob_602591(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_602593 = path.getOrDefault("jobId")
  valid_602593 = validateParameter(valid_602593, JString, required = true,
                                 default = nil)
  if valid_602593 != nil:
    section.add "jobId", valid_602593
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
  section = newJObject()
  var valid_602594 = query.getOrDefault("force")
  valid_602594 = validateParameter(valid_602594, JBool, required = false, default = nil)
  if valid_602594 != nil:
    section.add "force", valid_602594
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602595 = header.getOrDefault("X-Amz-Signature")
  valid_602595 = validateParameter(valid_602595, JString, required = false,
                                 default = nil)
  if valid_602595 != nil:
    section.add "X-Amz-Signature", valid_602595
  var valid_602596 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602596 = validateParameter(valid_602596, JString, required = false,
                                 default = nil)
  if valid_602596 != nil:
    section.add "X-Amz-Content-Sha256", valid_602596
  var valid_602597 = header.getOrDefault("X-Amz-Date")
  valid_602597 = validateParameter(valid_602597, JString, required = false,
                                 default = nil)
  if valid_602597 != nil:
    section.add "X-Amz-Date", valid_602597
  var valid_602598 = header.getOrDefault("X-Amz-Credential")
  valid_602598 = validateParameter(valid_602598, JString, required = false,
                                 default = nil)
  if valid_602598 != nil:
    section.add "X-Amz-Credential", valid_602598
  var valid_602599 = header.getOrDefault("X-Amz-Security-Token")
  valid_602599 = validateParameter(valid_602599, JString, required = false,
                                 default = nil)
  if valid_602599 != nil:
    section.add "X-Amz-Security-Token", valid_602599
  var valid_602600 = header.getOrDefault("X-Amz-Algorithm")
  valid_602600 = validateParameter(valid_602600, JString, required = false,
                                 default = nil)
  if valid_602600 != nil:
    section.add "X-Amz-Algorithm", valid_602600
  var valid_602601 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602601 = validateParameter(valid_602601, JString, required = false,
                                 default = nil)
  if valid_602601 != nil:
    section.add "X-Amz-SignedHeaders", valid_602601
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602602: Call_DeleteJob_602590; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ## 
  let valid = call_602602.validator(path, query, header, formData, body)
  let scheme = call_602602.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602602.url(scheme.get, call_602602.host, call_602602.base,
                         call_602602.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602602, url, valid)

proc call*(call_602603: Call_DeleteJob_602590; jobId: string; force: bool = false): Recallable =
  ## deleteJob
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ##   jobId: string (required)
  ##        : <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
  ##   force: bool
  ##        : <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
  var path_602604 = newJObject()
  var query_602605 = newJObject()
  add(path_602604, "jobId", newJString(jobId))
  add(query_602605, "force", newJBool(force))
  result = call_602603.call(path_602604, query_602605, nil, nil, nil)

var deleteJob* = Call_DeleteJob_602590(name: "deleteJob",
                                    meth: HttpMethod.HttpDelete,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_DeleteJob_602591,
                                    base: "/", url: url_DeleteJob_602592,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateKeysAndCertificate_602622 = ref object of OpenApiRestCall_601389
proc url_CreateKeysAndCertificate_602624(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateKeysAndCertificate_602623(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key. You can also call <code>CreateKeysAndCertificate</code> over MQTT from a device, for more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-wo-cert.html#provision-mqtt-api">Provisioning MQTT API</a>.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_602625 = query.getOrDefault("setAsActive")
  valid_602625 = validateParameter(valid_602625, JBool, required = false, default = nil)
  if valid_602625 != nil:
    section.add "setAsActive", valid_602625
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602626 = header.getOrDefault("X-Amz-Signature")
  valid_602626 = validateParameter(valid_602626, JString, required = false,
                                 default = nil)
  if valid_602626 != nil:
    section.add "X-Amz-Signature", valid_602626
  var valid_602627 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602627 = validateParameter(valid_602627, JString, required = false,
                                 default = nil)
  if valid_602627 != nil:
    section.add "X-Amz-Content-Sha256", valid_602627
  var valid_602628 = header.getOrDefault("X-Amz-Date")
  valid_602628 = validateParameter(valid_602628, JString, required = false,
                                 default = nil)
  if valid_602628 != nil:
    section.add "X-Amz-Date", valid_602628
  var valid_602629 = header.getOrDefault("X-Amz-Credential")
  valid_602629 = validateParameter(valid_602629, JString, required = false,
                                 default = nil)
  if valid_602629 != nil:
    section.add "X-Amz-Credential", valid_602629
  var valid_602630 = header.getOrDefault("X-Amz-Security-Token")
  valid_602630 = validateParameter(valid_602630, JString, required = false,
                                 default = nil)
  if valid_602630 != nil:
    section.add "X-Amz-Security-Token", valid_602630
  var valid_602631 = header.getOrDefault("X-Amz-Algorithm")
  valid_602631 = validateParameter(valid_602631, JString, required = false,
                                 default = nil)
  if valid_602631 != nil:
    section.add "X-Amz-Algorithm", valid_602631
  var valid_602632 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602632 = validateParameter(valid_602632, JString, required = false,
                                 default = nil)
  if valid_602632 != nil:
    section.add "X-Amz-SignedHeaders", valid_602632
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602633: Call_CreateKeysAndCertificate_602622; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key. You can also call <code>CreateKeysAndCertificate</code> over MQTT from a device, for more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-wo-cert.html#provision-mqtt-api">Provisioning MQTT API</a>.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ## 
  let valid = call_602633.validator(path, query, header, formData, body)
  let scheme = call_602633.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602633.url(scheme.get, call_602633.host, call_602633.base,
                         call_602633.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602633, url, valid)

proc call*(call_602634: Call_CreateKeysAndCertificate_602622;
          setAsActive: bool = false): Recallable =
  ## createKeysAndCertificate
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key. You can also call <code>CreateKeysAndCertificate</code> over MQTT from a device, for more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-wo-cert.html#provision-mqtt-api">Provisioning MQTT API</a>.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  var query_602635 = newJObject()
  add(query_602635, "setAsActive", newJBool(setAsActive))
  result = call_602634.call(nil, query_602635, nil, nil, nil)

var createKeysAndCertificate* = Call_CreateKeysAndCertificate_602622(
    name: "createKeysAndCertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/keys-and-certificate",
    validator: validate_CreateKeysAndCertificate_602623, base: "/",
    url: url_CreateKeysAndCertificate_602624, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateMitigationAction_602650 = ref object of OpenApiRestCall_601389
proc url_CreateMitigationAction_602652(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateMitigationAction_602651(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_602653 = path.getOrDefault("actionName")
  valid_602653 = validateParameter(valid_602653, JString, required = true,
                                 default = nil)
  if valid_602653 != nil:
    section.add "actionName", valid_602653
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602654 = header.getOrDefault("X-Amz-Signature")
  valid_602654 = validateParameter(valid_602654, JString, required = false,
                                 default = nil)
  if valid_602654 != nil:
    section.add "X-Amz-Signature", valid_602654
  var valid_602655 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602655 = validateParameter(valid_602655, JString, required = false,
                                 default = nil)
  if valid_602655 != nil:
    section.add "X-Amz-Content-Sha256", valid_602655
  var valid_602656 = header.getOrDefault("X-Amz-Date")
  valid_602656 = validateParameter(valid_602656, JString, required = false,
                                 default = nil)
  if valid_602656 != nil:
    section.add "X-Amz-Date", valid_602656
  var valid_602657 = header.getOrDefault("X-Amz-Credential")
  valid_602657 = validateParameter(valid_602657, JString, required = false,
                                 default = nil)
  if valid_602657 != nil:
    section.add "X-Amz-Credential", valid_602657
  var valid_602658 = header.getOrDefault("X-Amz-Security-Token")
  valid_602658 = validateParameter(valid_602658, JString, required = false,
                                 default = nil)
  if valid_602658 != nil:
    section.add "X-Amz-Security-Token", valid_602658
  var valid_602659 = header.getOrDefault("X-Amz-Algorithm")
  valid_602659 = validateParameter(valid_602659, JString, required = false,
                                 default = nil)
  if valid_602659 != nil:
    section.add "X-Amz-Algorithm", valid_602659
  var valid_602660 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602660 = validateParameter(valid_602660, JString, required = false,
                                 default = nil)
  if valid_602660 != nil:
    section.add "X-Amz-SignedHeaders", valid_602660
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602662: Call_CreateMitigationAction_602650; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ## 
  let valid = call_602662.validator(path, query, header, formData, body)
  let scheme = call_602662.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602662.url(scheme.get, call_602662.host, call_602662.base,
                         call_602662.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602662, url, valid)

proc call*(call_602663: Call_CreateMitigationAction_602650; actionName: string;
          body: JsonNode): Recallable =
  ## createMitigationAction
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ##   actionName: string (required)
  ##             : A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).
  ##   body: JObject (required)
  var path_602664 = newJObject()
  var body_602665 = newJObject()
  add(path_602664, "actionName", newJString(actionName))
  if body != nil:
    body_602665 = body
  result = call_602663.call(path_602664, nil, nil, nil, body_602665)

var createMitigationAction* = Call_CreateMitigationAction_602650(
    name: "createMitigationAction", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_CreateMitigationAction_602651, base: "/",
    url: url_CreateMitigationAction_602652, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeMitigationAction_602636 = ref object of OpenApiRestCall_601389
proc url_DescribeMitigationAction_602638(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeMitigationAction_602637(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a mitigation action.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The friendly name that uniquely identifies the mitigation action.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_602639 = path.getOrDefault("actionName")
  valid_602639 = validateParameter(valid_602639, JString, required = true,
                                 default = nil)
  if valid_602639 != nil:
    section.add "actionName", valid_602639
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602640 = header.getOrDefault("X-Amz-Signature")
  valid_602640 = validateParameter(valid_602640, JString, required = false,
                                 default = nil)
  if valid_602640 != nil:
    section.add "X-Amz-Signature", valid_602640
  var valid_602641 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602641 = validateParameter(valid_602641, JString, required = false,
                                 default = nil)
  if valid_602641 != nil:
    section.add "X-Amz-Content-Sha256", valid_602641
  var valid_602642 = header.getOrDefault("X-Amz-Date")
  valid_602642 = validateParameter(valid_602642, JString, required = false,
                                 default = nil)
  if valid_602642 != nil:
    section.add "X-Amz-Date", valid_602642
  var valid_602643 = header.getOrDefault("X-Amz-Credential")
  valid_602643 = validateParameter(valid_602643, JString, required = false,
                                 default = nil)
  if valid_602643 != nil:
    section.add "X-Amz-Credential", valid_602643
  var valid_602644 = header.getOrDefault("X-Amz-Security-Token")
  valid_602644 = validateParameter(valid_602644, JString, required = false,
                                 default = nil)
  if valid_602644 != nil:
    section.add "X-Amz-Security-Token", valid_602644
  var valid_602645 = header.getOrDefault("X-Amz-Algorithm")
  valid_602645 = validateParameter(valid_602645, JString, required = false,
                                 default = nil)
  if valid_602645 != nil:
    section.add "X-Amz-Algorithm", valid_602645
  var valid_602646 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602646 = validateParameter(valid_602646, JString, required = false,
                                 default = nil)
  if valid_602646 != nil:
    section.add "X-Amz-SignedHeaders", valid_602646
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602647: Call_DescribeMitigationAction_602636; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a mitigation action.
  ## 
  let valid = call_602647.validator(path, query, header, formData, body)
  let scheme = call_602647.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602647.url(scheme.get, call_602647.host, call_602647.base,
                         call_602647.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602647, url, valid)

proc call*(call_602648: Call_DescribeMitigationAction_602636; actionName: string): Recallable =
  ## describeMitigationAction
  ## Gets information about a mitigation action.
  ##   actionName: string (required)
  ##             : The friendly name that uniquely identifies the mitigation action.
  var path_602649 = newJObject()
  add(path_602649, "actionName", newJString(actionName))
  result = call_602648.call(path_602649, nil, nil, nil, nil)

var describeMitigationAction* = Call_DescribeMitigationAction_602636(
    name: "describeMitigationAction", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_DescribeMitigationAction_602637, base: "/",
    url: url_DescribeMitigationAction_602638, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateMitigationAction_602680 = ref object of OpenApiRestCall_601389
proc url_UpdateMitigationAction_602682(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateMitigationAction_602681(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the definition for the specified mitigation action.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_602683 = path.getOrDefault("actionName")
  valid_602683 = validateParameter(valid_602683, JString, required = true,
                                 default = nil)
  if valid_602683 != nil:
    section.add "actionName", valid_602683
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602684 = header.getOrDefault("X-Amz-Signature")
  valid_602684 = validateParameter(valid_602684, JString, required = false,
                                 default = nil)
  if valid_602684 != nil:
    section.add "X-Amz-Signature", valid_602684
  var valid_602685 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602685 = validateParameter(valid_602685, JString, required = false,
                                 default = nil)
  if valid_602685 != nil:
    section.add "X-Amz-Content-Sha256", valid_602685
  var valid_602686 = header.getOrDefault("X-Amz-Date")
  valid_602686 = validateParameter(valid_602686, JString, required = false,
                                 default = nil)
  if valid_602686 != nil:
    section.add "X-Amz-Date", valid_602686
  var valid_602687 = header.getOrDefault("X-Amz-Credential")
  valid_602687 = validateParameter(valid_602687, JString, required = false,
                                 default = nil)
  if valid_602687 != nil:
    section.add "X-Amz-Credential", valid_602687
  var valid_602688 = header.getOrDefault("X-Amz-Security-Token")
  valid_602688 = validateParameter(valid_602688, JString, required = false,
                                 default = nil)
  if valid_602688 != nil:
    section.add "X-Amz-Security-Token", valid_602688
  var valid_602689 = header.getOrDefault("X-Amz-Algorithm")
  valid_602689 = validateParameter(valid_602689, JString, required = false,
                                 default = nil)
  if valid_602689 != nil:
    section.add "X-Amz-Algorithm", valid_602689
  var valid_602690 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602690 = validateParameter(valid_602690, JString, required = false,
                                 default = nil)
  if valid_602690 != nil:
    section.add "X-Amz-SignedHeaders", valid_602690
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602692: Call_UpdateMitigationAction_602680; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the definition for the specified mitigation action.
  ## 
  let valid = call_602692.validator(path, query, header, formData, body)
  let scheme = call_602692.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602692.url(scheme.get, call_602692.host, call_602692.base,
                         call_602692.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602692, url, valid)

proc call*(call_602693: Call_UpdateMitigationAction_602680; actionName: string;
          body: JsonNode): Recallable =
  ## updateMitigationAction
  ## Updates the definition for the specified mitigation action.
  ##   actionName: string (required)
  ##             : The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.
  ##   body: JObject (required)
  var path_602694 = newJObject()
  var body_602695 = newJObject()
  add(path_602694, "actionName", newJString(actionName))
  if body != nil:
    body_602695 = body
  result = call_602693.call(path_602694, nil, nil, nil, body_602695)

var updateMitigationAction* = Call_UpdateMitigationAction_602680(
    name: "updateMitigationAction", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_UpdateMitigationAction_602681, base: "/",
    url: url_UpdateMitigationAction_602682, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteMitigationAction_602666 = ref object of OpenApiRestCall_601389
proc url_DeleteMitigationAction_602668(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteMitigationAction_602667(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a defined mitigation action from your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The name of the mitigation action that you want to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_602669 = path.getOrDefault("actionName")
  valid_602669 = validateParameter(valid_602669, JString, required = true,
                                 default = nil)
  if valid_602669 != nil:
    section.add "actionName", valid_602669
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602670 = header.getOrDefault("X-Amz-Signature")
  valid_602670 = validateParameter(valid_602670, JString, required = false,
                                 default = nil)
  if valid_602670 != nil:
    section.add "X-Amz-Signature", valid_602670
  var valid_602671 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602671 = validateParameter(valid_602671, JString, required = false,
                                 default = nil)
  if valid_602671 != nil:
    section.add "X-Amz-Content-Sha256", valid_602671
  var valid_602672 = header.getOrDefault("X-Amz-Date")
  valid_602672 = validateParameter(valid_602672, JString, required = false,
                                 default = nil)
  if valid_602672 != nil:
    section.add "X-Amz-Date", valid_602672
  var valid_602673 = header.getOrDefault("X-Amz-Credential")
  valid_602673 = validateParameter(valid_602673, JString, required = false,
                                 default = nil)
  if valid_602673 != nil:
    section.add "X-Amz-Credential", valid_602673
  var valid_602674 = header.getOrDefault("X-Amz-Security-Token")
  valid_602674 = validateParameter(valid_602674, JString, required = false,
                                 default = nil)
  if valid_602674 != nil:
    section.add "X-Amz-Security-Token", valid_602674
  var valid_602675 = header.getOrDefault("X-Amz-Algorithm")
  valid_602675 = validateParameter(valid_602675, JString, required = false,
                                 default = nil)
  if valid_602675 != nil:
    section.add "X-Amz-Algorithm", valid_602675
  var valid_602676 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602676 = validateParameter(valid_602676, JString, required = false,
                                 default = nil)
  if valid_602676 != nil:
    section.add "X-Amz-SignedHeaders", valid_602676
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602677: Call_DeleteMitigationAction_602666; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a defined mitigation action from your AWS account.
  ## 
  let valid = call_602677.validator(path, query, header, formData, body)
  let scheme = call_602677.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602677.url(scheme.get, call_602677.host, call_602677.base,
                         call_602677.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602677, url, valid)

proc call*(call_602678: Call_DeleteMitigationAction_602666; actionName: string): Recallable =
  ## deleteMitigationAction
  ## Deletes a defined mitigation action from your AWS account.
  ##   actionName: string (required)
  ##             : The name of the mitigation action that you want to delete.
  var path_602679 = newJObject()
  add(path_602679, "actionName", newJString(actionName))
  result = call_602678.call(path_602679, nil, nil, nil, nil)

var deleteMitigationAction* = Call_DeleteMitigationAction_602666(
    name: "deleteMitigationAction", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_DeleteMitigationAction_602667, base: "/",
    url: url_DeleteMitigationAction_602668, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateOTAUpdate_602710 = ref object of OpenApiRestCall_601389
proc url_CreateOTAUpdate_602712(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateOTAUpdate_602711(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The ID of the OTA update to be created.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_602713 = path.getOrDefault("otaUpdateId")
  valid_602713 = validateParameter(valid_602713, JString, required = true,
                                 default = nil)
  if valid_602713 != nil:
    section.add "otaUpdateId", valid_602713
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602714 = header.getOrDefault("X-Amz-Signature")
  valid_602714 = validateParameter(valid_602714, JString, required = false,
                                 default = nil)
  if valid_602714 != nil:
    section.add "X-Amz-Signature", valid_602714
  var valid_602715 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602715 = validateParameter(valid_602715, JString, required = false,
                                 default = nil)
  if valid_602715 != nil:
    section.add "X-Amz-Content-Sha256", valid_602715
  var valid_602716 = header.getOrDefault("X-Amz-Date")
  valid_602716 = validateParameter(valid_602716, JString, required = false,
                                 default = nil)
  if valid_602716 != nil:
    section.add "X-Amz-Date", valid_602716
  var valid_602717 = header.getOrDefault("X-Amz-Credential")
  valid_602717 = validateParameter(valid_602717, JString, required = false,
                                 default = nil)
  if valid_602717 != nil:
    section.add "X-Amz-Credential", valid_602717
  var valid_602718 = header.getOrDefault("X-Amz-Security-Token")
  valid_602718 = validateParameter(valid_602718, JString, required = false,
                                 default = nil)
  if valid_602718 != nil:
    section.add "X-Amz-Security-Token", valid_602718
  var valid_602719 = header.getOrDefault("X-Amz-Algorithm")
  valid_602719 = validateParameter(valid_602719, JString, required = false,
                                 default = nil)
  if valid_602719 != nil:
    section.add "X-Amz-Algorithm", valid_602719
  var valid_602720 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602720 = validateParameter(valid_602720, JString, required = false,
                                 default = nil)
  if valid_602720 != nil:
    section.add "X-Amz-SignedHeaders", valid_602720
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602722: Call_CreateOTAUpdate_602710; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ## 
  let valid = call_602722.validator(path, query, header, formData, body)
  let scheme = call_602722.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602722.url(scheme.get, call_602722.host, call_602722.base,
                         call_602722.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602722, url, valid)

proc call*(call_602723: Call_CreateOTAUpdate_602710; body: JsonNode;
          otaUpdateId: string): Recallable =
  ## createOTAUpdate
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ##   body: JObject (required)
  ##   otaUpdateId: string (required)
  ##              : The ID of the OTA update to be created.
  var path_602724 = newJObject()
  var body_602725 = newJObject()
  if body != nil:
    body_602725 = body
  add(path_602724, "otaUpdateId", newJString(otaUpdateId))
  result = call_602723.call(path_602724, nil, nil, nil, body_602725)

var createOTAUpdate* = Call_CreateOTAUpdate_602710(name: "createOTAUpdate",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_CreateOTAUpdate_602711,
    base: "/", url: url_CreateOTAUpdate_602712, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetOTAUpdate_602696 = ref object of OpenApiRestCall_601389
proc url_GetOTAUpdate_602698(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOTAUpdate_602697(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets an OTA update.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The OTA update ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_602699 = path.getOrDefault("otaUpdateId")
  valid_602699 = validateParameter(valid_602699, JString, required = true,
                                 default = nil)
  if valid_602699 != nil:
    section.add "otaUpdateId", valid_602699
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602700 = header.getOrDefault("X-Amz-Signature")
  valid_602700 = validateParameter(valid_602700, JString, required = false,
                                 default = nil)
  if valid_602700 != nil:
    section.add "X-Amz-Signature", valid_602700
  var valid_602701 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602701 = validateParameter(valid_602701, JString, required = false,
                                 default = nil)
  if valid_602701 != nil:
    section.add "X-Amz-Content-Sha256", valid_602701
  var valid_602702 = header.getOrDefault("X-Amz-Date")
  valid_602702 = validateParameter(valid_602702, JString, required = false,
                                 default = nil)
  if valid_602702 != nil:
    section.add "X-Amz-Date", valid_602702
  var valid_602703 = header.getOrDefault("X-Amz-Credential")
  valid_602703 = validateParameter(valid_602703, JString, required = false,
                                 default = nil)
  if valid_602703 != nil:
    section.add "X-Amz-Credential", valid_602703
  var valid_602704 = header.getOrDefault("X-Amz-Security-Token")
  valid_602704 = validateParameter(valid_602704, JString, required = false,
                                 default = nil)
  if valid_602704 != nil:
    section.add "X-Amz-Security-Token", valid_602704
  var valid_602705 = header.getOrDefault("X-Amz-Algorithm")
  valid_602705 = validateParameter(valid_602705, JString, required = false,
                                 default = nil)
  if valid_602705 != nil:
    section.add "X-Amz-Algorithm", valid_602705
  var valid_602706 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602706 = validateParameter(valid_602706, JString, required = false,
                                 default = nil)
  if valid_602706 != nil:
    section.add "X-Amz-SignedHeaders", valid_602706
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602707: Call_GetOTAUpdate_602696; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets an OTA update.
  ## 
  let valid = call_602707.validator(path, query, header, formData, body)
  let scheme = call_602707.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602707.url(scheme.get, call_602707.host, call_602707.base,
                         call_602707.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602707, url, valid)

proc call*(call_602708: Call_GetOTAUpdate_602696; otaUpdateId: string): Recallable =
  ## getOTAUpdate
  ## Gets an OTA update.
  ##   otaUpdateId: string (required)
  ##              : The OTA update ID.
  var path_602709 = newJObject()
  add(path_602709, "otaUpdateId", newJString(otaUpdateId))
  result = call_602708.call(path_602709, nil, nil, nil, nil)

var getOTAUpdate* = Call_GetOTAUpdate_602696(name: "getOTAUpdate",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_GetOTAUpdate_602697,
    base: "/", url: url_GetOTAUpdate_602698, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteOTAUpdate_602726 = ref object of OpenApiRestCall_601389
proc url_DeleteOTAUpdate_602728(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOTAUpdate_602727(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Delete an OTA update.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The OTA update ID to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_602729 = path.getOrDefault("otaUpdateId")
  valid_602729 = validateParameter(valid_602729, JString, required = true,
                                 default = nil)
  if valid_602729 != nil:
    section.add "otaUpdateId", valid_602729
  result.add "path", section
  ## parameters in `query` object:
  ##   deleteStream: JBool
  ##               : Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.
  ##   forceDeleteAWSJob: JBool
  ##                    : Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.
  section = newJObject()
  var valid_602730 = query.getOrDefault("deleteStream")
  valid_602730 = validateParameter(valid_602730, JBool, required = false, default = nil)
  if valid_602730 != nil:
    section.add "deleteStream", valid_602730
  var valid_602731 = query.getOrDefault("forceDeleteAWSJob")
  valid_602731 = validateParameter(valid_602731, JBool, required = false, default = nil)
  if valid_602731 != nil:
    section.add "forceDeleteAWSJob", valid_602731
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602732 = header.getOrDefault("X-Amz-Signature")
  valid_602732 = validateParameter(valid_602732, JString, required = false,
                                 default = nil)
  if valid_602732 != nil:
    section.add "X-Amz-Signature", valid_602732
  var valid_602733 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602733 = validateParameter(valid_602733, JString, required = false,
                                 default = nil)
  if valid_602733 != nil:
    section.add "X-Amz-Content-Sha256", valid_602733
  var valid_602734 = header.getOrDefault("X-Amz-Date")
  valid_602734 = validateParameter(valid_602734, JString, required = false,
                                 default = nil)
  if valid_602734 != nil:
    section.add "X-Amz-Date", valid_602734
  var valid_602735 = header.getOrDefault("X-Amz-Credential")
  valid_602735 = validateParameter(valid_602735, JString, required = false,
                                 default = nil)
  if valid_602735 != nil:
    section.add "X-Amz-Credential", valid_602735
  var valid_602736 = header.getOrDefault("X-Amz-Security-Token")
  valid_602736 = validateParameter(valid_602736, JString, required = false,
                                 default = nil)
  if valid_602736 != nil:
    section.add "X-Amz-Security-Token", valid_602736
  var valid_602737 = header.getOrDefault("X-Amz-Algorithm")
  valid_602737 = validateParameter(valid_602737, JString, required = false,
                                 default = nil)
  if valid_602737 != nil:
    section.add "X-Amz-Algorithm", valid_602737
  var valid_602738 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602738 = validateParameter(valid_602738, JString, required = false,
                                 default = nil)
  if valid_602738 != nil:
    section.add "X-Amz-SignedHeaders", valid_602738
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602739: Call_DeleteOTAUpdate_602726; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete an OTA update.
  ## 
  let valid = call_602739.validator(path, query, header, formData, body)
  let scheme = call_602739.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602739.url(scheme.get, call_602739.host, call_602739.base,
                         call_602739.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602739, url, valid)

proc call*(call_602740: Call_DeleteOTAUpdate_602726; otaUpdateId: string;
          deleteStream: bool = false; forceDeleteAWSJob: bool = false): Recallable =
  ## deleteOTAUpdate
  ## Delete an OTA update.
  ##   deleteStream: bool
  ##               : Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.
  ##   otaUpdateId: string (required)
  ##              : The OTA update ID to delete.
  ##   forceDeleteAWSJob: bool
  ##                    : Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.
  var path_602741 = newJObject()
  var query_602742 = newJObject()
  add(query_602742, "deleteStream", newJBool(deleteStream))
  add(path_602741, "otaUpdateId", newJString(otaUpdateId))
  add(query_602742, "forceDeleteAWSJob", newJBool(forceDeleteAWSJob))
  result = call_602740.call(path_602741, query_602742, nil, nil, nil)

var deleteOTAUpdate* = Call_DeleteOTAUpdate_602726(name: "deleteOTAUpdate",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_DeleteOTAUpdate_602727,
    base: "/", url: url_DeleteOTAUpdate_602728, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreatePolicy_602757 = ref object of OpenApiRestCall_601389
proc url_CreatePolicy_602759(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreatePolicy_602758(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_602760 = path.getOrDefault("policyName")
  valid_602760 = validateParameter(valid_602760, JString, required = true,
                                 default = nil)
  if valid_602760 != nil:
    section.add "policyName", valid_602760
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602761 = header.getOrDefault("X-Amz-Signature")
  valid_602761 = validateParameter(valid_602761, JString, required = false,
                                 default = nil)
  if valid_602761 != nil:
    section.add "X-Amz-Signature", valid_602761
  var valid_602762 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602762 = validateParameter(valid_602762, JString, required = false,
                                 default = nil)
  if valid_602762 != nil:
    section.add "X-Amz-Content-Sha256", valid_602762
  var valid_602763 = header.getOrDefault("X-Amz-Date")
  valid_602763 = validateParameter(valid_602763, JString, required = false,
                                 default = nil)
  if valid_602763 != nil:
    section.add "X-Amz-Date", valid_602763
  var valid_602764 = header.getOrDefault("X-Amz-Credential")
  valid_602764 = validateParameter(valid_602764, JString, required = false,
                                 default = nil)
  if valid_602764 != nil:
    section.add "X-Amz-Credential", valid_602764
  var valid_602765 = header.getOrDefault("X-Amz-Security-Token")
  valid_602765 = validateParameter(valid_602765, JString, required = false,
                                 default = nil)
  if valid_602765 != nil:
    section.add "X-Amz-Security-Token", valid_602765
  var valid_602766 = header.getOrDefault("X-Amz-Algorithm")
  valid_602766 = validateParameter(valid_602766, JString, required = false,
                                 default = nil)
  if valid_602766 != nil:
    section.add "X-Amz-Algorithm", valid_602766
  var valid_602767 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602767 = validateParameter(valid_602767, JString, required = false,
                                 default = nil)
  if valid_602767 != nil:
    section.add "X-Amz-SignedHeaders", valid_602767
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602769: Call_CreatePolicy_602757; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ## 
  let valid = call_602769.validator(path, query, header, formData, body)
  let scheme = call_602769.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602769.url(scheme.get, call_602769.host, call_602769.base,
                         call_602769.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602769, url, valid)

proc call*(call_602770: Call_CreatePolicy_602757; policyName: string; body: JsonNode): Recallable =
  ## createPolicy
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ##   policyName: string (required)
  ##             : The policy name.
  ##   body: JObject (required)
  var path_602771 = newJObject()
  var body_602772 = newJObject()
  add(path_602771, "policyName", newJString(policyName))
  if body != nil:
    body_602772 = body
  result = call_602770.call(path_602771, nil, nil, nil, body_602772)

var createPolicy* = Call_CreatePolicy_602757(name: "createPolicy",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/policies/{policyName}", validator: validate_CreatePolicy_602758,
    base: "/", url: url_CreatePolicy_602759, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPolicy_602743 = ref object of OpenApiRestCall_601389
proc url_GetPolicy_602745(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetPolicy_602744(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the specified policy with the policy document of the default version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_602746 = path.getOrDefault("policyName")
  valid_602746 = validateParameter(valid_602746, JString, required = true,
                                 default = nil)
  if valid_602746 != nil:
    section.add "policyName", valid_602746
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602747 = header.getOrDefault("X-Amz-Signature")
  valid_602747 = validateParameter(valid_602747, JString, required = false,
                                 default = nil)
  if valid_602747 != nil:
    section.add "X-Amz-Signature", valid_602747
  var valid_602748 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602748 = validateParameter(valid_602748, JString, required = false,
                                 default = nil)
  if valid_602748 != nil:
    section.add "X-Amz-Content-Sha256", valid_602748
  var valid_602749 = header.getOrDefault("X-Amz-Date")
  valid_602749 = validateParameter(valid_602749, JString, required = false,
                                 default = nil)
  if valid_602749 != nil:
    section.add "X-Amz-Date", valid_602749
  var valid_602750 = header.getOrDefault("X-Amz-Credential")
  valid_602750 = validateParameter(valid_602750, JString, required = false,
                                 default = nil)
  if valid_602750 != nil:
    section.add "X-Amz-Credential", valid_602750
  var valid_602751 = header.getOrDefault("X-Amz-Security-Token")
  valid_602751 = validateParameter(valid_602751, JString, required = false,
                                 default = nil)
  if valid_602751 != nil:
    section.add "X-Amz-Security-Token", valid_602751
  var valid_602752 = header.getOrDefault("X-Amz-Algorithm")
  valid_602752 = validateParameter(valid_602752, JString, required = false,
                                 default = nil)
  if valid_602752 != nil:
    section.add "X-Amz-Algorithm", valid_602752
  var valid_602753 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602753 = validateParameter(valid_602753, JString, required = false,
                                 default = nil)
  if valid_602753 != nil:
    section.add "X-Amz-SignedHeaders", valid_602753
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602754: Call_GetPolicy_602743; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified policy with the policy document of the default version.
  ## 
  let valid = call_602754.validator(path, query, header, formData, body)
  let scheme = call_602754.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602754.url(scheme.get, call_602754.host, call_602754.base,
                         call_602754.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602754, url, valid)

proc call*(call_602755: Call_GetPolicy_602743; policyName: string): Recallable =
  ## getPolicy
  ## Gets information about the specified policy with the policy document of the default version.
  ##   policyName: string (required)
  ##             : The name of the policy.
  var path_602756 = newJObject()
  add(path_602756, "policyName", newJString(policyName))
  result = call_602755.call(path_602756, nil, nil, nil, nil)

var getPolicy* = Call_GetPolicy_602743(name: "getPolicy", meth: HttpMethod.HttpGet,
                                    host: "iot.amazonaws.com",
                                    route: "/policies/{policyName}",
                                    validator: validate_GetPolicy_602744,
                                    base: "/", url: url_GetPolicy_602745,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeletePolicy_602773 = ref object of OpenApiRestCall_601389
proc url_DeletePolicy_602775(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeletePolicy_602774(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_602776 = path.getOrDefault("policyName")
  valid_602776 = validateParameter(valid_602776, JString, required = true,
                                 default = nil)
  if valid_602776 != nil:
    section.add "policyName", valid_602776
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602777 = header.getOrDefault("X-Amz-Signature")
  valid_602777 = validateParameter(valid_602777, JString, required = false,
                                 default = nil)
  if valid_602777 != nil:
    section.add "X-Amz-Signature", valid_602777
  var valid_602778 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602778 = validateParameter(valid_602778, JString, required = false,
                                 default = nil)
  if valid_602778 != nil:
    section.add "X-Amz-Content-Sha256", valid_602778
  var valid_602779 = header.getOrDefault("X-Amz-Date")
  valid_602779 = validateParameter(valid_602779, JString, required = false,
                                 default = nil)
  if valid_602779 != nil:
    section.add "X-Amz-Date", valid_602779
  var valid_602780 = header.getOrDefault("X-Amz-Credential")
  valid_602780 = validateParameter(valid_602780, JString, required = false,
                                 default = nil)
  if valid_602780 != nil:
    section.add "X-Amz-Credential", valid_602780
  var valid_602781 = header.getOrDefault("X-Amz-Security-Token")
  valid_602781 = validateParameter(valid_602781, JString, required = false,
                                 default = nil)
  if valid_602781 != nil:
    section.add "X-Amz-Security-Token", valid_602781
  var valid_602782 = header.getOrDefault("X-Amz-Algorithm")
  valid_602782 = validateParameter(valid_602782, JString, required = false,
                                 default = nil)
  if valid_602782 != nil:
    section.add "X-Amz-Algorithm", valid_602782
  var valid_602783 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602783 = validateParameter(valid_602783, JString, required = false,
                                 default = nil)
  if valid_602783 != nil:
    section.add "X-Amz-SignedHeaders", valid_602783
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602784: Call_DeletePolicy_602773; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ## 
  let valid = call_602784.validator(path, query, header, formData, body)
  let scheme = call_602784.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602784.url(scheme.get, call_602784.host, call_602784.base,
                         call_602784.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602784, url, valid)

proc call*(call_602785: Call_DeletePolicy_602773; policyName: string): Recallable =
  ## deletePolicy
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ##   policyName: string (required)
  ##             : The name of the policy to delete.
  var path_602786 = newJObject()
  add(path_602786, "policyName", newJString(policyName))
  result = call_602785.call(path_602786, nil, nil, nil, nil)

var deletePolicy* = Call_DeletePolicy_602773(name: "deletePolicy",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/policies/{policyName}", validator: validate_DeletePolicy_602774,
    base: "/", url: url_DeletePolicy_602775, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreatePolicyVersion_602801 = ref object of OpenApiRestCall_601389
proc url_CreatePolicyVersion_602803(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreatePolicyVersion_602802(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_602804 = path.getOrDefault("policyName")
  valid_602804 = validateParameter(valid_602804, JString, required = true,
                                 default = nil)
  if valid_602804 != nil:
    section.add "policyName", valid_602804
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsDefault: JBool
  ##               : Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
  section = newJObject()
  var valid_602805 = query.getOrDefault("setAsDefault")
  valid_602805 = validateParameter(valid_602805, JBool, required = false, default = nil)
  if valid_602805 != nil:
    section.add "setAsDefault", valid_602805
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602806 = header.getOrDefault("X-Amz-Signature")
  valid_602806 = validateParameter(valid_602806, JString, required = false,
                                 default = nil)
  if valid_602806 != nil:
    section.add "X-Amz-Signature", valid_602806
  var valid_602807 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602807 = validateParameter(valid_602807, JString, required = false,
                                 default = nil)
  if valid_602807 != nil:
    section.add "X-Amz-Content-Sha256", valid_602807
  var valid_602808 = header.getOrDefault("X-Amz-Date")
  valid_602808 = validateParameter(valid_602808, JString, required = false,
                                 default = nil)
  if valid_602808 != nil:
    section.add "X-Amz-Date", valid_602808
  var valid_602809 = header.getOrDefault("X-Amz-Credential")
  valid_602809 = validateParameter(valid_602809, JString, required = false,
                                 default = nil)
  if valid_602809 != nil:
    section.add "X-Amz-Credential", valid_602809
  var valid_602810 = header.getOrDefault("X-Amz-Security-Token")
  valid_602810 = validateParameter(valid_602810, JString, required = false,
                                 default = nil)
  if valid_602810 != nil:
    section.add "X-Amz-Security-Token", valid_602810
  var valid_602811 = header.getOrDefault("X-Amz-Algorithm")
  valid_602811 = validateParameter(valid_602811, JString, required = false,
                                 default = nil)
  if valid_602811 != nil:
    section.add "X-Amz-Algorithm", valid_602811
  var valid_602812 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602812 = validateParameter(valid_602812, JString, required = false,
                                 default = nil)
  if valid_602812 != nil:
    section.add "X-Amz-SignedHeaders", valid_602812
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602814: Call_CreatePolicyVersion_602801; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ## 
  let valid = call_602814.validator(path, query, header, formData, body)
  let scheme = call_602814.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602814.url(scheme.get, call_602814.host, call_602814.base,
                         call_602814.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602814, url, valid)

proc call*(call_602815: Call_CreatePolicyVersion_602801; policyName: string;
          body: JsonNode; setAsDefault: bool = false): Recallable =
  ## createPolicyVersion
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ##   policyName: string (required)
  ##             : The policy name.
  ##   setAsDefault: bool
  ##               : Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
  ##   body: JObject (required)
  var path_602816 = newJObject()
  var query_602817 = newJObject()
  var body_602818 = newJObject()
  add(path_602816, "policyName", newJString(policyName))
  add(query_602817, "setAsDefault", newJBool(setAsDefault))
  if body != nil:
    body_602818 = body
  result = call_602815.call(path_602816, query_602817, nil, nil, body_602818)

var createPolicyVersion* = Call_CreatePolicyVersion_602801(
    name: "createPolicyVersion", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/policies/{policyName}/version",
    validator: validate_CreatePolicyVersion_602802, base: "/",
    url: url_CreatePolicyVersion_602803, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicyVersions_602787 = ref object of OpenApiRestCall_601389
proc url_ListPolicyVersions_602789(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListPolicyVersions_602788(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Lists the versions of the specified policy and identifies the default version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_602790 = path.getOrDefault("policyName")
  valid_602790 = validateParameter(valid_602790, JString, required = true,
                                 default = nil)
  if valid_602790 != nil:
    section.add "policyName", valid_602790
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602791 = header.getOrDefault("X-Amz-Signature")
  valid_602791 = validateParameter(valid_602791, JString, required = false,
                                 default = nil)
  if valid_602791 != nil:
    section.add "X-Amz-Signature", valid_602791
  var valid_602792 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602792 = validateParameter(valid_602792, JString, required = false,
                                 default = nil)
  if valid_602792 != nil:
    section.add "X-Amz-Content-Sha256", valid_602792
  var valid_602793 = header.getOrDefault("X-Amz-Date")
  valid_602793 = validateParameter(valid_602793, JString, required = false,
                                 default = nil)
  if valid_602793 != nil:
    section.add "X-Amz-Date", valid_602793
  var valid_602794 = header.getOrDefault("X-Amz-Credential")
  valid_602794 = validateParameter(valid_602794, JString, required = false,
                                 default = nil)
  if valid_602794 != nil:
    section.add "X-Amz-Credential", valid_602794
  var valid_602795 = header.getOrDefault("X-Amz-Security-Token")
  valid_602795 = validateParameter(valid_602795, JString, required = false,
                                 default = nil)
  if valid_602795 != nil:
    section.add "X-Amz-Security-Token", valid_602795
  var valid_602796 = header.getOrDefault("X-Amz-Algorithm")
  valid_602796 = validateParameter(valid_602796, JString, required = false,
                                 default = nil)
  if valid_602796 != nil:
    section.add "X-Amz-Algorithm", valid_602796
  var valid_602797 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602797 = validateParameter(valid_602797, JString, required = false,
                                 default = nil)
  if valid_602797 != nil:
    section.add "X-Amz-SignedHeaders", valid_602797
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602798: Call_ListPolicyVersions_602787; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the versions of the specified policy and identifies the default version.
  ## 
  let valid = call_602798.validator(path, query, header, formData, body)
  let scheme = call_602798.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602798.url(scheme.get, call_602798.host, call_602798.base,
                         call_602798.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602798, url, valid)

proc call*(call_602799: Call_ListPolicyVersions_602787; policyName: string): Recallable =
  ## listPolicyVersions
  ## Lists the versions of the specified policy and identifies the default version.
  ##   policyName: string (required)
  ##             : The policy name.
  var path_602800 = newJObject()
  add(path_602800, "policyName", newJString(policyName))
  result = call_602799.call(path_602800, nil, nil, nil, nil)

var listPolicyVersions* = Call_ListPolicyVersions_602787(
    name: "listPolicyVersions", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version",
    validator: validate_ListPolicyVersions_602788, base: "/",
    url: url_ListPolicyVersions_602789, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateProvisioningClaim_602819 = ref object of OpenApiRestCall_601389
proc url_CreateProvisioningClaim_602821(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/provisioning-claim")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateProvisioningClaim_602820(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a provisioning claim.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the provisioning template to use.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_602822 = path.getOrDefault("templateName")
  valid_602822 = validateParameter(valid_602822, JString, required = true,
                                 default = nil)
  if valid_602822 != nil:
    section.add "templateName", valid_602822
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602823 = header.getOrDefault("X-Amz-Signature")
  valid_602823 = validateParameter(valid_602823, JString, required = false,
                                 default = nil)
  if valid_602823 != nil:
    section.add "X-Amz-Signature", valid_602823
  var valid_602824 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602824 = validateParameter(valid_602824, JString, required = false,
                                 default = nil)
  if valid_602824 != nil:
    section.add "X-Amz-Content-Sha256", valid_602824
  var valid_602825 = header.getOrDefault("X-Amz-Date")
  valid_602825 = validateParameter(valid_602825, JString, required = false,
                                 default = nil)
  if valid_602825 != nil:
    section.add "X-Amz-Date", valid_602825
  var valid_602826 = header.getOrDefault("X-Amz-Credential")
  valid_602826 = validateParameter(valid_602826, JString, required = false,
                                 default = nil)
  if valid_602826 != nil:
    section.add "X-Amz-Credential", valid_602826
  var valid_602827 = header.getOrDefault("X-Amz-Security-Token")
  valid_602827 = validateParameter(valid_602827, JString, required = false,
                                 default = nil)
  if valid_602827 != nil:
    section.add "X-Amz-Security-Token", valid_602827
  var valid_602828 = header.getOrDefault("X-Amz-Algorithm")
  valid_602828 = validateParameter(valid_602828, JString, required = false,
                                 default = nil)
  if valid_602828 != nil:
    section.add "X-Amz-Algorithm", valid_602828
  var valid_602829 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602829 = validateParameter(valid_602829, JString, required = false,
                                 default = nil)
  if valid_602829 != nil:
    section.add "X-Amz-SignedHeaders", valid_602829
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602830: Call_CreateProvisioningClaim_602819; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a provisioning claim.
  ## 
  let valid = call_602830.validator(path, query, header, formData, body)
  let scheme = call_602830.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602830.url(scheme.get, call_602830.host, call_602830.base,
                         call_602830.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602830, url, valid)

proc call*(call_602831: Call_CreateProvisioningClaim_602819; templateName: string): Recallable =
  ## createProvisioningClaim
  ## Creates a provisioning claim.
  ##   templateName: string (required)
  ##               : The name of the provisioning template to use.
  var path_602832 = newJObject()
  add(path_602832, "templateName", newJString(templateName))
  result = call_602831.call(path_602832, nil, nil, nil, nil)

var createProvisioningClaim* = Call_CreateProvisioningClaim_602819(
    name: "createProvisioningClaim", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/provisioning-claim",
    validator: validate_CreateProvisioningClaim_602820, base: "/",
    url: url_CreateProvisioningClaim_602821, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateProvisioningTemplate_602848 = ref object of OpenApiRestCall_601389
proc url_CreateProvisioningTemplate_602850(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateProvisioningTemplate_602849(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602851 = header.getOrDefault("X-Amz-Signature")
  valid_602851 = validateParameter(valid_602851, JString, required = false,
                                 default = nil)
  if valid_602851 != nil:
    section.add "X-Amz-Signature", valid_602851
  var valid_602852 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602852 = validateParameter(valid_602852, JString, required = false,
                                 default = nil)
  if valid_602852 != nil:
    section.add "X-Amz-Content-Sha256", valid_602852
  var valid_602853 = header.getOrDefault("X-Amz-Date")
  valid_602853 = validateParameter(valid_602853, JString, required = false,
                                 default = nil)
  if valid_602853 != nil:
    section.add "X-Amz-Date", valid_602853
  var valid_602854 = header.getOrDefault("X-Amz-Credential")
  valid_602854 = validateParameter(valid_602854, JString, required = false,
                                 default = nil)
  if valid_602854 != nil:
    section.add "X-Amz-Credential", valid_602854
  var valid_602855 = header.getOrDefault("X-Amz-Security-Token")
  valid_602855 = validateParameter(valid_602855, JString, required = false,
                                 default = nil)
  if valid_602855 != nil:
    section.add "X-Amz-Security-Token", valid_602855
  var valid_602856 = header.getOrDefault("X-Amz-Algorithm")
  valid_602856 = validateParameter(valid_602856, JString, required = false,
                                 default = nil)
  if valid_602856 != nil:
    section.add "X-Amz-Algorithm", valid_602856
  var valid_602857 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602857 = validateParameter(valid_602857, JString, required = false,
                                 default = nil)
  if valid_602857 != nil:
    section.add "X-Amz-SignedHeaders", valid_602857
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602859: Call_CreateProvisioningTemplate_602848; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a fleet provisioning template.
  ## 
  let valid = call_602859.validator(path, query, header, formData, body)
  let scheme = call_602859.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602859.url(scheme.get, call_602859.host, call_602859.base,
                         call_602859.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602859, url, valid)

proc call*(call_602860: Call_CreateProvisioningTemplate_602848; body: JsonNode): Recallable =
  ## createProvisioningTemplate
  ## Creates a fleet provisioning template.
  ##   body: JObject (required)
  var body_602861 = newJObject()
  if body != nil:
    body_602861 = body
  result = call_602860.call(nil, nil, nil, nil, body_602861)

var createProvisioningTemplate* = Call_CreateProvisioningTemplate_602848(
    name: "createProvisioningTemplate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/provisioning-templates",
    validator: validate_CreateProvisioningTemplate_602849, base: "/",
    url: url_CreateProvisioningTemplate_602850,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListProvisioningTemplates_602833 = ref object of OpenApiRestCall_601389
proc url_ListProvisioningTemplates_602835(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListProvisioningTemplates_602834(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the fleet provisioning templates in your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_602836 = query.getOrDefault("nextToken")
  valid_602836 = validateParameter(valid_602836, JString, required = false,
                                 default = nil)
  if valid_602836 != nil:
    section.add "nextToken", valid_602836
  var valid_602837 = query.getOrDefault("maxResults")
  valid_602837 = validateParameter(valid_602837, JInt, required = false, default = nil)
  if valid_602837 != nil:
    section.add "maxResults", valid_602837
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602838 = header.getOrDefault("X-Amz-Signature")
  valid_602838 = validateParameter(valid_602838, JString, required = false,
                                 default = nil)
  if valid_602838 != nil:
    section.add "X-Amz-Signature", valid_602838
  var valid_602839 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602839 = validateParameter(valid_602839, JString, required = false,
                                 default = nil)
  if valid_602839 != nil:
    section.add "X-Amz-Content-Sha256", valid_602839
  var valid_602840 = header.getOrDefault("X-Amz-Date")
  valid_602840 = validateParameter(valid_602840, JString, required = false,
                                 default = nil)
  if valid_602840 != nil:
    section.add "X-Amz-Date", valid_602840
  var valid_602841 = header.getOrDefault("X-Amz-Credential")
  valid_602841 = validateParameter(valid_602841, JString, required = false,
                                 default = nil)
  if valid_602841 != nil:
    section.add "X-Amz-Credential", valid_602841
  var valid_602842 = header.getOrDefault("X-Amz-Security-Token")
  valid_602842 = validateParameter(valid_602842, JString, required = false,
                                 default = nil)
  if valid_602842 != nil:
    section.add "X-Amz-Security-Token", valid_602842
  var valid_602843 = header.getOrDefault("X-Amz-Algorithm")
  valid_602843 = validateParameter(valid_602843, JString, required = false,
                                 default = nil)
  if valid_602843 != nil:
    section.add "X-Amz-Algorithm", valid_602843
  var valid_602844 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602844 = validateParameter(valid_602844, JString, required = false,
                                 default = nil)
  if valid_602844 != nil:
    section.add "X-Amz-SignedHeaders", valid_602844
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602845: Call_ListProvisioningTemplates_602833; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the fleet provisioning templates in your AWS account.
  ## 
  let valid = call_602845.validator(path, query, header, formData, body)
  let scheme = call_602845.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602845.url(scheme.get, call_602845.host, call_602845.base,
                         call_602845.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602845, url, valid)

proc call*(call_602846: Call_ListProvisioningTemplates_602833;
          nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listProvisioningTemplates
  ## Lists the fleet provisioning templates in your AWS account.
  ##   nextToken: string
  ##            : A token to retrieve the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_602847 = newJObject()
  add(query_602847, "nextToken", newJString(nextToken))
  add(query_602847, "maxResults", newJInt(maxResults))
  result = call_602846.call(nil, query_602847, nil, nil, nil)

var listProvisioningTemplates* = Call_ListProvisioningTemplates_602833(
    name: "listProvisioningTemplates", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/provisioning-templates",
    validator: validate_ListProvisioningTemplates_602834, base: "/",
    url: url_ListProvisioningTemplates_602835,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateProvisioningTemplateVersion_602879 = ref object of OpenApiRestCall_601389
proc url_CreateProvisioningTemplateVersion_602881(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/versions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateProvisioningTemplateVersion_602880(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new version of a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_602882 = path.getOrDefault("templateName")
  valid_602882 = validateParameter(valid_602882, JString, required = true,
                                 default = nil)
  if valid_602882 != nil:
    section.add "templateName", valid_602882
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsDefault: JBool
  ##               : Sets a fleet provision template version as the default version.
  section = newJObject()
  var valid_602883 = query.getOrDefault("setAsDefault")
  valid_602883 = validateParameter(valid_602883, JBool, required = false, default = nil)
  if valid_602883 != nil:
    section.add "setAsDefault", valid_602883
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602884 = header.getOrDefault("X-Amz-Signature")
  valid_602884 = validateParameter(valid_602884, JString, required = false,
                                 default = nil)
  if valid_602884 != nil:
    section.add "X-Amz-Signature", valid_602884
  var valid_602885 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602885 = validateParameter(valid_602885, JString, required = false,
                                 default = nil)
  if valid_602885 != nil:
    section.add "X-Amz-Content-Sha256", valid_602885
  var valid_602886 = header.getOrDefault("X-Amz-Date")
  valid_602886 = validateParameter(valid_602886, JString, required = false,
                                 default = nil)
  if valid_602886 != nil:
    section.add "X-Amz-Date", valid_602886
  var valid_602887 = header.getOrDefault("X-Amz-Credential")
  valid_602887 = validateParameter(valid_602887, JString, required = false,
                                 default = nil)
  if valid_602887 != nil:
    section.add "X-Amz-Credential", valid_602887
  var valid_602888 = header.getOrDefault("X-Amz-Security-Token")
  valid_602888 = validateParameter(valid_602888, JString, required = false,
                                 default = nil)
  if valid_602888 != nil:
    section.add "X-Amz-Security-Token", valid_602888
  var valid_602889 = header.getOrDefault("X-Amz-Algorithm")
  valid_602889 = validateParameter(valid_602889, JString, required = false,
                                 default = nil)
  if valid_602889 != nil:
    section.add "X-Amz-Algorithm", valid_602889
  var valid_602890 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602890 = validateParameter(valid_602890, JString, required = false,
                                 default = nil)
  if valid_602890 != nil:
    section.add "X-Amz-SignedHeaders", valid_602890
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602892: Call_CreateProvisioningTemplateVersion_602879;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Creates a new version of a fleet provisioning template.
  ## 
  let valid = call_602892.validator(path, query, header, formData, body)
  let scheme = call_602892.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602892.url(scheme.get, call_602892.host, call_602892.base,
                         call_602892.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602892, url, valid)

proc call*(call_602893: Call_CreateProvisioningTemplateVersion_602879;
          body: JsonNode; templateName: string; setAsDefault: bool = false): Recallable =
  ## createProvisioningTemplateVersion
  ## Creates a new version of a fleet provisioning template.
  ##   setAsDefault: bool
  ##               : Sets a fleet provision template version as the default version.
  ##   body: JObject (required)
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template.
  var path_602894 = newJObject()
  var query_602895 = newJObject()
  var body_602896 = newJObject()
  add(query_602895, "setAsDefault", newJBool(setAsDefault))
  if body != nil:
    body_602896 = body
  add(path_602894, "templateName", newJString(templateName))
  result = call_602893.call(path_602894, query_602895, nil, nil, body_602896)

var createProvisioningTemplateVersion* = Call_CreateProvisioningTemplateVersion_602879(
    name: "createProvisioningTemplateVersion", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/versions",
    validator: validate_CreateProvisioningTemplateVersion_602880, base: "/",
    url: url_CreateProvisioningTemplateVersion_602881,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListProvisioningTemplateVersions_602862 = ref object of OpenApiRestCall_601389
proc url_ListProvisioningTemplateVersions_602864(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/versions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListProvisioningTemplateVersions_602863(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## A list of fleet provisioning template versions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_602865 = path.getOrDefault("templateName")
  valid_602865 = validateParameter(valid_602865, JString, required = true,
                                 default = nil)
  if valid_602865 != nil:
    section.add "templateName", valid_602865
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_602866 = query.getOrDefault("nextToken")
  valid_602866 = validateParameter(valid_602866, JString, required = false,
                                 default = nil)
  if valid_602866 != nil:
    section.add "nextToken", valid_602866
  var valid_602867 = query.getOrDefault("maxResults")
  valid_602867 = validateParameter(valid_602867, JInt, required = false, default = nil)
  if valid_602867 != nil:
    section.add "maxResults", valid_602867
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602868 = header.getOrDefault("X-Amz-Signature")
  valid_602868 = validateParameter(valid_602868, JString, required = false,
                                 default = nil)
  if valid_602868 != nil:
    section.add "X-Amz-Signature", valid_602868
  var valid_602869 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602869 = validateParameter(valid_602869, JString, required = false,
                                 default = nil)
  if valid_602869 != nil:
    section.add "X-Amz-Content-Sha256", valid_602869
  var valid_602870 = header.getOrDefault("X-Amz-Date")
  valid_602870 = validateParameter(valid_602870, JString, required = false,
                                 default = nil)
  if valid_602870 != nil:
    section.add "X-Amz-Date", valid_602870
  var valid_602871 = header.getOrDefault("X-Amz-Credential")
  valid_602871 = validateParameter(valid_602871, JString, required = false,
                                 default = nil)
  if valid_602871 != nil:
    section.add "X-Amz-Credential", valid_602871
  var valid_602872 = header.getOrDefault("X-Amz-Security-Token")
  valid_602872 = validateParameter(valid_602872, JString, required = false,
                                 default = nil)
  if valid_602872 != nil:
    section.add "X-Amz-Security-Token", valid_602872
  var valid_602873 = header.getOrDefault("X-Amz-Algorithm")
  valid_602873 = validateParameter(valid_602873, JString, required = false,
                                 default = nil)
  if valid_602873 != nil:
    section.add "X-Amz-Algorithm", valid_602873
  var valid_602874 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602874 = validateParameter(valid_602874, JString, required = false,
                                 default = nil)
  if valid_602874 != nil:
    section.add "X-Amz-SignedHeaders", valid_602874
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602875: Call_ListProvisioningTemplateVersions_602862;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## A list of fleet provisioning template versions.
  ## 
  let valid = call_602875.validator(path, query, header, formData, body)
  let scheme = call_602875.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602875.url(scheme.get, call_602875.host, call_602875.base,
                         call_602875.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602875, url, valid)

proc call*(call_602876: Call_ListProvisioningTemplateVersions_602862;
          templateName: string; nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listProvisioningTemplateVersions
  ## A list of fleet provisioning template versions.
  ##   nextToken: string
  ##            : A token to retrieve the next set of results.
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_602877 = newJObject()
  var query_602878 = newJObject()
  add(query_602878, "nextToken", newJString(nextToken))
  add(path_602877, "templateName", newJString(templateName))
  add(query_602878, "maxResults", newJInt(maxResults))
  result = call_602876.call(path_602877, query_602878, nil, nil, nil)

var listProvisioningTemplateVersions* = Call_ListProvisioningTemplateVersions_602862(
    name: "listProvisioningTemplateVersions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/versions",
    validator: validate_ListProvisioningTemplateVersions_602863, base: "/",
    url: url_ListProvisioningTemplateVersions_602864,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateRoleAlias_602911 = ref object of OpenApiRestCall_601389
proc url_UpdateRoleAlias_602913(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateRoleAlias_602912(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Updates a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_602914 = path.getOrDefault("roleAlias")
  valid_602914 = validateParameter(valid_602914, JString, required = true,
                                 default = nil)
  if valid_602914 != nil:
    section.add "roleAlias", valid_602914
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602915 = header.getOrDefault("X-Amz-Signature")
  valid_602915 = validateParameter(valid_602915, JString, required = false,
                                 default = nil)
  if valid_602915 != nil:
    section.add "X-Amz-Signature", valid_602915
  var valid_602916 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602916 = validateParameter(valid_602916, JString, required = false,
                                 default = nil)
  if valid_602916 != nil:
    section.add "X-Amz-Content-Sha256", valid_602916
  var valid_602917 = header.getOrDefault("X-Amz-Date")
  valid_602917 = validateParameter(valid_602917, JString, required = false,
                                 default = nil)
  if valid_602917 != nil:
    section.add "X-Amz-Date", valid_602917
  var valid_602918 = header.getOrDefault("X-Amz-Credential")
  valid_602918 = validateParameter(valid_602918, JString, required = false,
                                 default = nil)
  if valid_602918 != nil:
    section.add "X-Amz-Credential", valid_602918
  var valid_602919 = header.getOrDefault("X-Amz-Security-Token")
  valid_602919 = validateParameter(valid_602919, JString, required = false,
                                 default = nil)
  if valid_602919 != nil:
    section.add "X-Amz-Security-Token", valid_602919
  var valid_602920 = header.getOrDefault("X-Amz-Algorithm")
  valid_602920 = validateParameter(valid_602920, JString, required = false,
                                 default = nil)
  if valid_602920 != nil:
    section.add "X-Amz-Algorithm", valid_602920
  var valid_602921 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602921 = validateParameter(valid_602921, JString, required = false,
                                 default = nil)
  if valid_602921 != nil:
    section.add "X-Amz-SignedHeaders", valid_602921
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602923: Call_UpdateRoleAlias_602911; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a role alias.
  ## 
  let valid = call_602923.validator(path, query, header, formData, body)
  let scheme = call_602923.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602923.url(scheme.get, call_602923.host, call_602923.base,
                         call_602923.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602923, url, valid)

proc call*(call_602924: Call_UpdateRoleAlias_602911; roleAlias: string;
          body: JsonNode): Recallable =
  ## updateRoleAlias
  ## Updates a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias to update.
  ##   body: JObject (required)
  var path_602925 = newJObject()
  var body_602926 = newJObject()
  add(path_602925, "roleAlias", newJString(roleAlias))
  if body != nil:
    body_602926 = body
  result = call_602924.call(path_602925, nil, nil, nil, body_602926)

var updateRoleAlias* = Call_UpdateRoleAlias_602911(name: "updateRoleAlias",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_UpdateRoleAlias_602912,
    base: "/", url: url_UpdateRoleAlias_602913, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateRoleAlias_602927 = ref object of OpenApiRestCall_601389
proc url_CreateRoleAlias_602929(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateRoleAlias_602928(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias that points to a role ARN. This allows you to change the role without having to update the device.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_602930 = path.getOrDefault("roleAlias")
  valid_602930 = validateParameter(valid_602930, JString, required = true,
                                 default = nil)
  if valid_602930 != nil:
    section.add "roleAlias", valid_602930
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602931 = header.getOrDefault("X-Amz-Signature")
  valid_602931 = validateParameter(valid_602931, JString, required = false,
                                 default = nil)
  if valid_602931 != nil:
    section.add "X-Amz-Signature", valid_602931
  var valid_602932 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602932 = validateParameter(valid_602932, JString, required = false,
                                 default = nil)
  if valid_602932 != nil:
    section.add "X-Amz-Content-Sha256", valid_602932
  var valid_602933 = header.getOrDefault("X-Amz-Date")
  valid_602933 = validateParameter(valid_602933, JString, required = false,
                                 default = nil)
  if valid_602933 != nil:
    section.add "X-Amz-Date", valid_602933
  var valid_602934 = header.getOrDefault("X-Amz-Credential")
  valid_602934 = validateParameter(valid_602934, JString, required = false,
                                 default = nil)
  if valid_602934 != nil:
    section.add "X-Amz-Credential", valid_602934
  var valid_602935 = header.getOrDefault("X-Amz-Security-Token")
  valid_602935 = validateParameter(valid_602935, JString, required = false,
                                 default = nil)
  if valid_602935 != nil:
    section.add "X-Amz-Security-Token", valid_602935
  var valid_602936 = header.getOrDefault("X-Amz-Algorithm")
  valid_602936 = validateParameter(valid_602936, JString, required = false,
                                 default = nil)
  if valid_602936 != nil:
    section.add "X-Amz-Algorithm", valid_602936
  var valid_602937 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602937 = validateParameter(valid_602937, JString, required = false,
                                 default = nil)
  if valid_602937 != nil:
    section.add "X-Amz-SignedHeaders", valid_602937
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602939: Call_CreateRoleAlias_602927; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a role alias.
  ## 
  let valid = call_602939.validator(path, query, header, formData, body)
  let scheme = call_602939.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602939.url(scheme.get, call_602939.host, call_602939.base,
                         call_602939.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602939, url, valid)

proc call*(call_602940: Call_CreateRoleAlias_602927; roleAlias: string;
          body: JsonNode): Recallable =
  ## createRoleAlias
  ## Creates a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias that points to a role ARN. This allows you to change the role without having to update the device.
  ##   body: JObject (required)
  var path_602941 = newJObject()
  var body_602942 = newJObject()
  add(path_602941, "roleAlias", newJString(roleAlias))
  if body != nil:
    body_602942 = body
  result = call_602940.call(path_602941, nil, nil, nil, body_602942)

var createRoleAlias* = Call_CreateRoleAlias_602927(name: "createRoleAlias",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_CreateRoleAlias_602928,
    base: "/", url: url_CreateRoleAlias_602929, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeRoleAlias_602897 = ref object of OpenApiRestCall_601389
proc url_DescribeRoleAlias_602899(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeRoleAlias_602898(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Describes a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to describe.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_602900 = path.getOrDefault("roleAlias")
  valid_602900 = validateParameter(valid_602900, JString, required = true,
                                 default = nil)
  if valid_602900 != nil:
    section.add "roleAlias", valid_602900
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602901 = header.getOrDefault("X-Amz-Signature")
  valid_602901 = validateParameter(valid_602901, JString, required = false,
                                 default = nil)
  if valid_602901 != nil:
    section.add "X-Amz-Signature", valid_602901
  var valid_602902 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602902 = validateParameter(valid_602902, JString, required = false,
                                 default = nil)
  if valid_602902 != nil:
    section.add "X-Amz-Content-Sha256", valid_602902
  var valid_602903 = header.getOrDefault("X-Amz-Date")
  valid_602903 = validateParameter(valid_602903, JString, required = false,
                                 default = nil)
  if valid_602903 != nil:
    section.add "X-Amz-Date", valid_602903
  var valid_602904 = header.getOrDefault("X-Amz-Credential")
  valid_602904 = validateParameter(valid_602904, JString, required = false,
                                 default = nil)
  if valid_602904 != nil:
    section.add "X-Amz-Credential", valid_602904
  var valid_602905 = header.getOrDefault("X-Amz-Security-Token")
  valid_602905 = validateParameter(valid_602905, JString, required = false,
                                 default = nil)
  if valid_602905 != nil:
    section.add "X-Amz-Security-Token", valid_602905
  var valid_602906 = header.getOrDefault("X-Amz-Algorithm")
  valid_602906 = validateParameter(valid_602906, JString, required = false,
                                 default = nil)
  if valid_602906 != nil:
    section.add "X-Amz-Algorithm", valid_602906
  var valid_602907 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602907 = validateParameter(valid_602907, JString, required = false,
                                 default = nil)
  if valid_602907 != nil:
    section.add "X-Amz-SignedHeaders", valid_602907
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602908: Call_DescribeRoleAlias_602897; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a role alias.
  ## 
  let valid = call_602908.validator(path, query, header, formData, body)
  let scheme = call_602908.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602908.url(scheme.get, call_602908.host, call_602908.base,
                         call_602908.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602908, url, valid)

proc call*(call_602909: Call_DescribeRoleAlias_602897; roleAlias: string): Recallable =
  ## describeRoleAlias
  ## Describes a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias to describe.
  var path_602910 = newJObject()
  add(path_602910, "roleAlias", newJString(roleAlias))
  result = call_602909.call(path_602910, nil, nil, nil, nil)

var describeRoleAlias* = Call_DescribeRoleAlias_602897(name: "describeRoleAlias",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_DescribeRoleAlias_602898,
    base: "/", url: url_DescribeRoleAlias_602899,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRoleAlias_602943 = ref object of OpenApiRestCall_601389
proc url_DeleteRoleAlias_602945(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteRoleAlias_602944(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes a role alias
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_602946 = path.getOrDefault("roleAlias")
  valid_602946 = validateParameter(valid_602946, JString, required = true,
                                 default = nil)
  if valid_602946 != nil:
    section.add "roleAlias", valid_602946
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602947 = header.getOrDefault("X-Amz-Signature")
  valid_602947 = validateParameter(valid_602947, JString, required = false,
                                 default = nil)
  if valid_602947 != nil:
    section.add "X-Amz-Signature", valid_602947
  var valid_602948 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602948 = validateParameter(valid_602948, JString, required = false,
                                 default = nil)
  if valid_602948 != nil:
    section.add "X-Amz-Content-Sha256", valid_602948
  var valid_602949 = header.getOrDefault("X-Amz-Date")
  valid_602949 = validateParameter(valid_602949, JString, required = false,
                                 default = nil)
  if valid_602949 != nil:
    section.add "X-Amz-Date", valid_602949
  var valid_602950 = header.getOrDefault("X-Amz-Credential")
  valid_602950 = validateParameter(valid_602950, JString, required = false,
                                 default = nil)
  if valid_602950 != nil:
    section.add "X-Amz-Credential", valid_602950
  var valid_602951 = header.getOrDefault("X-Amz-Security-Token")
  valid_602951 = validateParameter(valid_602951, JString, required = false,
                                 default = nil)
  if valid_602951 != nil:
    section.add "X-Amz-Security-Token", valid_602951
  var valid_602952 = header.getOrDefault("X-Amz-Algorithm")
  valid_602952 = validateParameter(valid_602952, JString, required = false,
                                 default = nil)
  if valid_602952 != nil:
    section.add "X-Amz-Algorithm", valid_602952
  var valid_602953 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602953 = validateParameter(valid_602953, JString, required = false,
                                 default = nil)
  if valid_602953 != nil:
    section.add "X-Amz-SignedHeaders", valid_602953
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602954: Call_DeleteRoleAlias_602943; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a role alias
  ## 
  let valid = call_602954.validator(path, query, header, formData, body)
  let scheme = call_602954.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602954.url(scheme.get, call_602954.host, call_602954.base,
                         call_602954.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602954, url, valid)

proc call*(call_602955: Call_DeleteRoleAlias_602943; roleAlias: string): Recallable =
  ## deleteRoleAlias
  ## Deletes a role alias
  ##   roleAlias: string (required)
  ##            : The role alias to delete.
  var path_602956 = newJObject()
  add(path_602956, "roleAlias", newJString(roleAlias))
  result = call_602955.call(path_602956, nil, nil, nil, nil)

var deleteRoleAlias* = Call_DeleteRoleAlias_602943(name: "deleteRoleAlias",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_DeleteRoleAlias_602944,
    base: "/", url: url_DeleteRoleAlias_602945, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateScheduledAudit_602971 = ref object of OpenApiRestCall_601389
proc url_CreateScheduledAudit_602973(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateScheduledAudit_602972(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled audit that is run at a specified time interval.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name you want to give to the scheduled audit. (Max. 128 chars)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_602974 = path.getOrDefault("scheduledAuditName")
  valid_602974 = validateParameter(valid_602974, JString, required = true,
                                 default = nil)
  if valid_602974 != nil:
    section.add "scheduledAuditName", valid_602974
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602975 = header.getOrDefault("X-Amz-Signature")
  valid_602975 = validateParameter(valid_602975, JString, required = false,
                                 default = nil)
  if valid_602975 != nil:
    section.add "X-Amz-Signature", valid_602975
  var valid_602976 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602976 = validateParameter(valid_602976, JString, required = false,
                                 default = nil)
  if valid_602976 != nil:
    section.add "X-Amz-Content-Sha256", valid_602976
  var valid_602977 = header.getOrDefault("X-Amz-Date")
  valid_602977 = validateParameter(valid_602977, JString, required = false,
                                 default = nil)
  if valid_602977 != nil:
    section.add "X-Amz-Date", valid_602977
  var valid_602978 = header.getOrDefault("X-Amz-Credential")
  valid_602978 = validateParameter(valid_602978, JString, required = false,
                                 default = nil)
  if valid_602978 != nil:
    section.add "X-Amz-Credential", valid_602978
  var valid_602979 = header.getOrDefault("X-Amz-Security-Token")
  valid_602979 = validateParameter(valid_602979, JString, required = false,
                                 default = nil)
  if valid_602979 != nil:
    section.add "X-Amz-Security-Token", valid_602979
  var valid_602980 = header.getOrDefault("X-Amz-Algorithm")
  valid_602980 = validateParameter(valid_602980, JString, required = false,
                                 default = nil)
  if valid_602980 != nil:
    section.add "X-Amz-Algorithm", valid_602980
  var valid_602981 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602981 = validateParameter(valid_602981, JString, required = false,
                                 default = nil)
  if valid_602981 != nil:
    section.add "X-Amz-SignedHeaders", valid_602981
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_602983: Call_CreateScheduledAudit_602971; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled audit that is run at a specified time interval.
  ## 
  let valid = call_602983.validator(path, query, header, formData, body)
  let scheme = call_602983.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602983.url(scheme.get, call_602983.host, call_602983.base,
                         call_602983.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602983, url, valid)

proc call*(call_602984: Call_CreateScheduledAudit_602971;
          scheduledAuditName: string; body: JsonNode): Recallable =
  ## createScheduledAudit
  ## Creates a scheduled audit that is run at a specified time interval.
  ##   scheduledAuditName: string (required)
  ##                     : The name you want to give to the scheduled audit. (Max. 128 chars)
  ##   body: JObject (required)
  var path_602985 = newJObject()
  var body_602986 = newJObject()
  add(path_602985, "scheduledAuditName", newJString(scheduledAuditName))
  if body != nil:
    body_602986 = body
  result = call_602984.call(path_602985, nil, nil, nil, body_602986)

var createScheduledAudit* = Call_CreateScheduledAudit_602971(
    name: "createScheduledAudit", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_CreateScheduledAudit_602972, base: "/",
    url: url_CreateScheduledAudit_602973, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeScheduledAudit_602957 = ref object of OpenApiRestCall_601389
proc url_DescribeScheduledAudit_602959(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeScheduledAudit_602958(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a scheduled audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit whose information you want to get.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_602960 = path.getOrDefault("scheduledAuditName")
  valid_602960 = validateParameter(valid_602960, JString, required = true,
                                 default = nil)
  if valid_602960 != nil:
    section.add "scheduledAuditName", valid_602960
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602961 = header.getOrDefault("X-Amz-Signature")
  valid_602961 = validateParameter(valid_602961, JString, required = false,
                                 default = nil)
  if valid_602961 != nil:
    section.add "X-Amz-Signature", valid_602961
  var valid_602962 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602962 = validateParameter(valid_602962, JString, required = false,
                                 default = nil)
  if valid_602962 != nil:
    section.add "X-Amz-Content-Sha256", valid_602962
  var valid_602963 = header.getOrDefault("X-Amz-Date")
  valid_602963 = validateParameter(valid_602963, JString, required = false,
                                 default = nil)
  if valid_602963 != nil:
    section.add "X-Amz-Date", valid_602963
  var valid_602964 = header.getOrDefault("X-Amz-Credential")
  valid_602964 = validateParameter(valid_602964, JString, required = false,
                                 default = nil)
  if valid_602964 != nil:
    section.add "X-Amz-Credential", valid_602964
  var valid_602965 = header.getOrDefault("X-Amz-Security-Token")
  valid_602965 = validateParameter(valid_602965, JString, required = false,
                                 default = nil)
  if valid_602965 != nil:
    section.add "X-Amz-Security-Token", valid_602965
  var valid_602966 = header.getOrDefault("X-Amz-Algorithm")
  valid_602966 = validateParameter(valid_602966, JString, required = false,
                                 default = nil)
  if valid_602966 != nil:
    section.add "X-Amz-Algorithm", valid_602966
  var valid_602967 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602967 = validateParameter(valid_602967, JString, required = false,
                                 default = nil)
  if valid_602967 != nil:
    section.add "X-Amz-SignedHeaders", valid_602967
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602968: Call_DescribeScheduledAudit_602957; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a scheduled audit.
  ## 
  let valid = call_602968.validator(path, query, header, formData, body)
  let scheme = call_602968.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602968.url(scheme.get, call_602968.host, call_602968.base,
                         call_602968.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602968, url, valid)

proc call*(call_602969: Call_DescribeScheduledAudit_602957;
          scheduledAuditName: string): Recallable =
  ## describeScheduledAudit
  ## Gets information about a scheduled audit.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit whose information you want to get.
  var path_602970 = newJObject()
  add(path_602970, "scheduledAuditName", newJString(scheduledAuditName))
  result = call_602969.call(path_602970, nil, nil, nil, nil)

var describeScheduledAudit* = Call_DescribeScheduledAudit_602957(
    name: "describeScheduledAudit", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_DescribeScheduledAudit_602958, base: "/",
    url: url_DescribeScheduledAudit_602959, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateScheduledAudit_603001 = ref object of OpenApiRestCall_601389
proc url_UpdateScheduledAudit_603003(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateScheduledAudit_603002(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit. (Max. 128 chars)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_603004 = path.getOrDefault("scheduledAuditName")
  valid_603004 = validateParameter(valid_603004, JString, required = true,
                                 default = nil)
  if valid_603004 != nil:
    section.add "scheduledAuditName", valid_603004
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603005 = header.getOrDefault("X-Amz-Signature")
  valid_603005 = validateParameter(valid_603005, JString, required = false,
                                 default = nil)
  if valid_603005 != nil:
    section.add "X-Amz-Signature", valid_603005
  var valid_603006 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603006 = validateParameter(valid_603006, JString, required = false,
                                 default = nil)
  if valid_603006 != nil:
    section.add "X-Amz-Content-Sha256", valid_603006
  var valid_603007 = header.getOrDefault("X-Amz-Date")
  valid_603007 = validateParameter(valid_603007, JString, required = false,
                                 default = nil)
  if valid_603007 != nil:
    section.add "X-Amz-Date", valid_603007
  var valid_603008 = header.getOrDefault("X-Amz-Credential")
  valid_603008 = validateParameter(valid_603008, JString, required = false,
                                 default = nil)
  if valid_603008 != nil:
    section.add "X-Amz-Credential", valid_603008
  var valid_603009 = header.getOrDefault("X-Amz-Security-Token")
  valid_603009 = validateParameter(valid_603009, JString, required = false,
                                 default = nil)
  if valid_603009 != nil:
    section.add "X-Amz-Security-Token", valid_603009
  var valid_603010 = header.getOrDefault("X-Amz-Algorithm")
  valid_603010 = validateParameter(valid_603010, JString, required = false,
                                 default = nil)
  if valid_603010 != nil:
    section.add "X-Amz-Algorithm", valid_603010
  var valid_603011 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603011 = validateParameter(valid_603011, JString, required = false,
                                 default = nil)
  if valid_603011 != nil:
    section.add "X-Amz-SignedHeaders", valid_603011
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603013: Call_UpdateScheduledAudit_603001; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ## 
  let valid = call_603013.validator(path, query, header, formData, body)
  let scheme = call_603013.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603013.url(scheme.get, call_603013.host, call_603013.base,
                         call_603013.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603013, url, valid)

proc call*(call_603014: Call_UpdateScheduledAudit_603001;
          scheduledAuditName: string; body: JsonNode): Recallable =
  ## updateScheduledAudit
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit. (Max. 128 chars)
  ##   body: JObject (required)
  var path_603015 = newJObject()
  var body_603016 = newJObject()
  add(path_603015, "scheduledAuditName", newJString(scheduledAuditName))
  if body != nil:
    body_603016 = body
  result = call_603014.call(path_603015, nil, nil, nil, body_603016)

var updateScheduledAudit* = Call_UpdateScheduledAudit_603001(
    name: "updateScheduledAudit", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_UpdateScheduledAudit_603002, base: "/",
    url: url_UpdateScheduledAudit_603003, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteScheduledAudit_602987 = ref object of OpenApiRestCall_601389
proc url_DeleteScheduledAudit_602989(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteScheduledAudit_602988(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit you want to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_602990 = path.getOrDefault("scheduledAuditName")
  valid_602990 = validateParameter(valid_602990, JString, required = true,
                                 default = nil)
  if valid_602990 != nil:
    section.add "scheduledAuditName", valid_602990
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602991 = header.getOrDefault("X-Amz-Signature")
  valid_602991 = validateParameter(valid_602991, JString, required = false,
                                 default = nil)
  if valid_602991 != nil:
    section.add "X-Amz-Signature", valid_602991
  var valid_602992 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602992 = validateParameter(valid_602992, JString, required = false,
                                 default = nil)
  if valid_602992 != nil:
    section.add "X-Amz-Content-Sha256", valid_602992
  var valid_602993 = header.getOrDefault("X-Amz-Date")
  valid_602993 = validateParameter(valid_602993, JString, required = false,
                                 default = nil)
  if valid_602993 != nil:
    section.add "X-Amz-Date", valid_602993
  var valid_602994 = header.getOrDefault("X-Amz-Credential")
  valid_602994 = validateParameter(valid_602994, JString, required = false,
                                 default = nil)
  if valid_602994 != nil:
    section.add "X-Amz-Credential", valid_602994
  var valid_602995 = header.getOrDefault("X-Amz-Security-Token")
  valid_602995 = validateParameter(valid_602995, JString, required = false,
                                 default = nil)
  if valid_602995 != nil:
    section.add "X-Amz-Security-Token", valid_602995
  var valid_602996 = header.getOrDefault("X-Amz-Algorithm")
  valid_602996 = validateParameter(valid_602996, JString, required = false,
                                 default = nil)
  if valid_602996 != nil:
    section.add "X-Amz-Algorithm", valid_602996
  var valid_602997 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602997 = validateParameter(valid_602997, JString, required = false,
                                 default = nil)
  if valid_602997 != nil:
    section.add "X-Amz-SignedHeaders", valid_602997
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602998: Call_DeleteScheduledAudit_602987; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled audit.
  ## 
  let valid = call_602998.validator(path, query, header, formData, body)
  let scheme = call_602998.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602998.url(scheme.get, call_602998.host, call_602998.base,
                         call_602998.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602998, url, valid)

proc call*(call_602999: Call_DeleteScheduledAudit_602987;
          scheduledAuditName: string): Recallable =
  ## deleteScheduledAudit
  ## Deletes a scheduled audit.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit you want to delete.
  var path_603000 = newJObject()
  add(path_603000, "scheduledAuditName", newJString(scheduledAuditName))
  result = call_602999.call(path_603000, nil, nil, nil, nil)

var deleteScheduledAudit* = Call_DeleteScheduledAudit_602987(
    name: "deleteScheduledAudit", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_DeleteScheduledAudit_602988, base: "/",
    url: url_DeleteScheduledAudit_602989, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateSecurityProfile_603031 = ref object of OpenApiRestCall_601389
proc url_CreateSecurityProfile_603033(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateSecurityProfile_603032(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name you are giving to the security profile.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_603034 = path.getOrDefault("securityProfileName")
  valid_603034 = validateParameter(valid_603034, JString, required = true,
                                 default = nil)
  if valid_603034 != nil:
    section.add "securityProfileName", valid_603034
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603035 = header.getOrDefault("X-Amz-Signature")
  valid_603035 = validateParameter(valid_603035, JString, required = false,
                                 default = nil)
  if valid_603035 != nil:
    section.add "X-Amz-Signature", valid_603035
  var valid_603036 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603036 = validateParameter(valid_603036, JString, required = false,
                                 default = nil)
  if valid_603036 != nil:
    section.add "X-Amz-Content-Sha256", valid_603036
  var valid_603037 = header.getOrDefault("X-Amz-Date")
  valid_603037 = validateParameter(valid_603037, JString, required = false,
                                 default = nil)
  if valid_603037 != nil:
    section.add "X-Amz-Date", valid_603037
  var valid_603038 = header.getOrDefault("X-Amz-Credential")
  valid_603038 = validateParameter(valid_603038, JString, required = false,
                                 default = nil)
  if valid_603038 != nil:
    section.add "X-Amz-Credential", valid_603038
  var valid_603039 = header.getOrDefault("X-Amz-Security-Token")
  valid_603039 = validateParameter(valid_603039, JString, required = false,
                                 default = nil)
  if valid_603039 != nil:
    section.add "X-Amz-Security-Token", valid_603039
  var valid_603040 = header.getOrDefault("X-Amz-Algorithm")
  valid_603040 = validateParameter(valid_603040, JString, required = false,
                                 default = nil)
  if valid_603040 != nil:
    section.add "X-Amz-Algorithm", valid_603040
  var valid_603041 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603041 = validateParameter(valid_603041, JString, required = false,
                                 default = nil)
  if valid_603041 != nil:
    section.add "X-Amz-SignedHeaders", valid_603041
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603043: Call_CreateSecurityProfile_603031; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Device Defender security profile.
  ## 
  let valid = call_603043.validator(path, query, header, formData, body)
  let scheme = call_603043.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603043.url(scheme.get, call_603043.host, call_603043.base,
                         call_603043.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603043, url, valid)

proc call*(call_603044: Call_CreateSecurityProfile_603031; body: JsonNode;
          securityProfileName: string): Recallable =
  ## createSecurityProfile
  ## Creates a Device Defender security profile.
  ##   body: JObject (required)
  ##   securityProfileName: string (required)
  ##                      : The name you are giving to the security profile.
  var path_603045 = newJObject()
  var body_603046 = newJObject()
  if body != nil:
    body_603046 = body
  add(path_603045, "securityProfileName", newJString(securityProfileName))
  result = call_603044.call(path_603045, nil, nil, nil, body_603046)

var createSecurityProfile* = Call_CreateSecurityProfile_603031(
    name: "createSecurityProfile", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_CreateSecurityProfile_603032, base: "/",
    url: url_CreateSecurityProfile_603033, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeSecurityProfile_603017 = ref object of OpenApiRestCall_601389
proc url_DescribeSecurityProfile_603019(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeSecurityProfile_603018(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile whose information you want to get.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_603020 = path.getOrDefault("securityProfileName")
  valid_603020 = validateParameter(valid_603020, JString, required = true,
                                 default = nil)
  if valid_603020 != nil:
    section.add "securityProfileName", valid_603020
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603021 = header.getOrDefault("X-Amz-Signature")
  valid_603021 = validateParameter(valid_603021, JString, required = false,
                                 default = nil)
  if valid_603021 != nil:
    section.add "X-Amz-Signature", valid_603021
  var valid_603022 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603022 = validateParameter(valid_603022, JString, required = false,
                                 default = nil)
  if valid_603022 != nil:
    section.add "X-Amz-Content-Sha256", valid_603022
  var valid_603023 = header.getOrDefault("X-Amz-Date")
  valid_603023 = validateParameter(valid_603023, JString, required = false,
                                 default = nil)
  if valid_603023 != nil:
    section.add "X-Amz-Date", valid_603023
  var valid_603024 = header.getOrDefault("X-Amz-Credential")
  valid_603024 = validateParameter(valid_603024, JString, required = false,
                                 default = nil)
  if valid_603024 != nil:
    section.add "X-Amz-Credential", valid_603024
  var valid_603025 = header.getOrDefault("X-Amz-Security-Token")
  valid_603025 = validateParameter(valid_603025, JString, required = false,
                                 default = nil)
  if valid_603025 != nil:
    section.add "X-Amz-Security-Token", valid_603025
  var valid_603026 = header.getOrDefault("X-Amz-Algorithm")
  valid_603026 = validateParameter(valid_603026, JString, required = false,
                                 default = nil)
  if valid_603026 != nil:
    section.add "X-Amz-Algorithm", valid_603026
  var valid_603027 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603027 = validateParameter(valid_603027, JString, required = false,
                                 default = nil)
  if valid_603027 != nil:
    section.add "X-Amz-SignedHeaders", valid_603027
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603028: Call_DescribeSecurityProfile_603017; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a Device Defender security profile.
  ## 
  let valid = call_603028.validator(path, query, header, formData, body)
  let scheme = call_603028.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603028.url(scheme.get, call_603028.host, call_603028.base,
                         call_603028.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603028, url, valid)

proc call*(call_603029: Call_DescribeSecurityProfile_603017;
          securityProfileName: string): Recallable =
  ## describeSecurityProfile
  ## Gets information about a Device Defender security profile.
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile whose information you want to get.
  var path_603030 = newJObject()
  add(path_603030, "securityProfileName", newJString(securityProfileName))
  result = call_603029.call(path_603030, nil, nil, nil, nil)

var describeSecurityProfile* = Call_DescribeSecurityProfile_603017(
    name: "describeSecurityProfile", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_DescribeSecurityProfile_603018, base: "/",
    url: url_DescribeSecurityProfile_603019, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateSecurityProfile_603063 = ref object of OpenApiRestCall_601389
proc url_UpdateSecurityProfile_603065(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateSecurityProfile_603064(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile you want to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_603066 = path.getOrDefault("securityProfileName")
  valid_603066 = validateParameter(valid_603066, JString, required = true,
                                 default = nil)
  if valid_603066 != nil:
    section.add "securityProfileName", valid_603066
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  section = newJObject()
  var valid_603067 = query.getOrDefault("expectedVersion")
  valid_603067 = validateParameter(valid_603067, JInt, required = false, default = nil)
  if valid_603067 != nil:
    section.add "expectedVersion", valid_603067
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603068 = header.getOrDefault("X-Amz-Signature")
  valid_603068 = validateParameter(valid_603068, JString, required = false,
                                 default = nil)
  if valid_603068 != nil:
    section.add "X-Amz-Signature", valid_603068
  var valid_603069 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603069 = validateParameter(valid_603069, JString, required = false,
                                 default = nil)
  if valid_603069 != nil:
    section.add "X-Amz-Content-Sha256", valid_603069
  var valid_603070 = header.getOrDefault("X-Amz-Date")
  valid_603070 = validateParameter(valid_603070, JString, required = false,
                                 default = nil)
  if valid_603070 != nil:
    section.add "X-Amz-Date", valid_603070
  var valid_603071 = header.getOrDefault("X-Amz-Credential")
  valid_603071 = validateParameter(valid_603071, JString, required = false,
                                 default = nil)
  if valid_603071 != nil:
    section.add "X-Amz-Credential", valid_603071
  var valid_603072 = header.getOrDefault("X-Amz-Security-Token")
  valid_603072 = validateParameter(valid_603072, JString, required = false,
                                 default = nil)
  if valid_603072 != nil:
    section.add "X-Amz-Security-Token", valid_603072
  var valid_603073 = header.getOrDefault("X-Amz-Algorithm")
  valid_603073 = validateParameter(valid_603073, JString, required = false,
                                 default = nil)
  if valid_603073 != nil:
    section.add "X-Amz-Algorithm", valid_603073
  var valid_603074 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603074 = validateParameter(valid_603074, JString, required = false,
                                 default = nil)
  if valid_603074 != nil:
    section.add "X-Amz-SignedHeaders", valid_603074
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603076: Call_UpdateSecurityProfile_603063; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a Device Defender security profile.
  ## 
  let valid = call_603076.validator(path, query, header, formData, body)
  let scheme = call_603076.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603076.url(scheme.get, call_603076.host, call_603076.base,
                         call_603076.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603076, url, valid)

proc call*(call_603077: Call_UpdateSecurityProfile_603063; body: JsonNode;
          securityProfileName: string; expectedVersion: int = 0): Recallable =
  ## updateSecurityProfile
  ## Updates a Device Defender security profile.
  ##   expectedVersion: int
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  ##   body: JObject (required)
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile you want to update.
  var path_603078 = newJObject()
  var query_603079 = newJObject()
  var body_603080 = newJObject()
  add(query_603079, "expectedVersion", newJInt(expectedVersion))
  if body != nil:
    body_603080 = body
  add(path_603078, "securityProfileName", newJString(securityProfileName))
  result = call_603077.call(path_603078, query_603079, nil, nil, body_603080)

var updateSecurityProfile* = Call_UpdateSecurityProfile_603063(
    name: "updateSecurityProfile", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_UpdateSecurityProfile_603064, base: "/",
    url: url_UpdateSecurityProfile_603065, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteSecurityProfile_603047 = ref object of OpenApiRestCall_601389
proc url_DeleteSecurityProfile_603049(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteSecurityProfile_603048(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile to be deleted.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_603050 = path.getOrDefault("securityProfileName")
  valid_603050 = validateParameter(valid_603050, JString, required = true,
                                 default = nil)
  if valid_603050 != nil:
    section.add "securityProfileName", valid_603050
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  section = newJObject()
  var valid_603051 = query.getOrDefault("expectedVersion")
  valid_603051 = validateParameter(valid_603051, JInt, required = false, default = nil)
  if valid_603051 != nil:
    section.add "expectedVersion", valid_603051
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603052 = header.getOrDefault("X-Amz-Signature")
  valid_603052 = validateParameter(valid_603052, JString, required = false,
                                 default = nil)
  if valid_603052 != nil:
    section.add "X-Amz-Signature", valid_603052
  var valid_603053 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603053 = validateParameter(valid_603053, JString, required = false,
                                 default = nil)
  if valid_603053 != nil:
    section.add "X-Amz-Content-Sha256", valid_603053
  var valid_603054 = header.getOrDefault("X-Amz-Date")
  valid_603054 = validateParameter(valid_603054, JString, required = false,
                                 default = nil)
  if valid_603054 != nil:
    section.add "X-Amz-Date", valid_603054
  var valid_603055 = header.getOrDefault("X-Amz-Credential")
  valid_603055 = validateParameter(valid_603055, JString, required = false,
                                 default = nil)
  if valid_603055 != nil:
    section.add "X-Amz-Credential", valid_603055
  var valid_603056 = header.getOrDefault("X-Amz-Security-Token")
  valid_603056 = validateParameter(valid_603056, JString, required = false,
                                 default = nil)
  if valid_603056 != nil:
    section.add "X-Amz-Security-Token", valid_603056
  var valid_603057 = header.getOrDefault("X-Amz-Algorithm")
  valid_603057 = validateParameter(valid_603057, JString, required = false,
                                 default = nil)
  if valid_603057 != nil:
    section.add "X-Amz-Algorithm", valid_603057
  var valid_603058 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603058 = validateParameter(valid_603058, JString, required = false,
                                 default = nil)
  if valid_603058 != nil:
    section.add "X-Amz-SignedHeaders", valid_603058
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603059: Call_DeleteSecurityProfile_603047; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a Device Defender security profile.
  ## 
  let valid = call_603059.validator(path, query, header, formData, body)
  let scheme = call_603059.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603059.url(scheme.get, call_603059.host, call_603059.base,
                         call_603059.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603059, url, valid)

proc call*(call_603060: Call_DeleteSecurityProfile_603047;
          securityProfileName: string; expectedVersion: int = 0): Recallable =
  ## deleteSecurityProfile
  ## Deletes a Device Defender security profile.
  ##   expectedVersion: int
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile to be deleted.
  var path_603061 = newJObject()
  var query_603062 = newJObject()
  add(query_603062, "expectedVersion", newJInt(expectedVersion))
  add(path_603061, "securityProfileName", newJString(securityProfileName))
  result = call_603060.call(path_603061, query_603062, nil, nil, nil)

var deleteSecurityProfile* = Call_DeleteSecurityProfile_603047(
    name: "deleteSecurityProfile", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_DeleteSecurityProfile_603048, base: "/",
    url: url_DeleteSecurityProfile_603049, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateStream_603095 = ref object of OpenApiRestCall_601389
proc url_UpdateStream_603097(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateStream_603096(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing stream. The stream version will be incremented by one.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_603098 = path.getOrDefault("streamId")
  valid_603098 = validateParameter(valid_603098, JString, required = true,
                                 default = nil)
  if valid_603098 != nil:
    section.add "streamId", valid_603098
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603099 = header.getOrDefault("X-Amz-Signature")
  valid_603099 = validateParameter(valid_603099, JString, required = false,
                                 default = nil)
  if valid_603099 != nil:
    section.add "X-Amz-Signature", valid_603099
  var valid_603100 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603100 = validateParameter(valid_603100, JString, required = false,
                                 default = nil)
  if valid_603100 != nil:
    section.add "X-Amz-Content-Sha256", valid_603100
  var valid_603101 = header.getOrDefault("X-Amz-Date")
  valid_603101 = validateParameter(valid_603101, JString, required = false,
                                 default = nil)
  if valid_603101 != nil:
    section.add "X-Amz-Date", valid_603101
  var valid_603102 = header.getOrDefault("X-Amz-Credential")
  valid_603102 = validateParameter(valid_603102, JString, required = false,
                                 default = nil)
  if valid_603102 != nil:
    section.add "X-Amz-Credential", valid_603102
  var valid_603103 = header.getOrDefault("X-Amz-Security-Token")
  valid_603103 = validateParameter(valid_603103, JString, required = false,
                                 default = nil)
  if valid_603103 != nil:
    section.add "X-Amz-Security-Token", valid_603103
  var valid_603104 = header.getOrDefault("X-Amz-Algorithm")
  valid_603104 = validateParameter(valid_603104, JString, required = false,
                                 default = nil)
  if valid_603104 != nil:
    section.add "X-Amz-Algorithm", valid_603104
  var valid_603105 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603105 = validateParameter(valid_603105, JString, required = false,
                                 default = nil)
  if valid_603105 != nil:
    section.add "X-Amz-SignedHeaders", valid_603105
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603107: Call_UpdateStream_603095; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing stream. The stream version will be incremented by one.
  ## 
  let valid = call_603107.validator(path, query, header, formData, body)
  let scheme = call_603107.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603107.url(scheme.get, call_603107.host, call_603107.base,
                         call_603107.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603107, url, valid)

proc call*(call_603108: Call_UpdateStream_603095; streamId: string; body: JsonNode): Recallable =
  ## updateStream
  ## Updates an existing stream. The stream version will be incremented by one.
  ##   streamId: string (required)
  ##           : The stream ID.
  ##   body: JObject (required)
  var path_603109 = newJObject()
  var body_603110 = newJObject()
  add(path_603109, "streamId", newJString(streamId))
  if body != nil:
    body_603110 = body
  result = call_603108.call(path_603109, nil, nil, nil, body_603110)

var updateStream* = Call_UpdateStream_603095(name: "updateStream",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_UpdateStream_603096,
    base: "/", url: url_UpdateStream_603097, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateStream_603111 = ref object of OpenApiRestCall_601389
proc url_CreateStream_603113(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateStream_603112(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_603114 = path.getOrDefault("streamId")
  valid_603114 = validateParameter(valid_603114, JString, required = true,
                                 default = nil)
  if valid_603114 != nil:
    section.add "streamId", valid_603114
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603115 = header.getOrDefault("X-Amz-Signature")
  valid_603115 = validateParameter(valid_603115, JString, required = false,
                                 default = nil)
  if valid_603115 != nil:
    section.add "X-Amz-Signature", valid_603115
  var valid_603116 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603116 = validateParameter(valid_603116, JString, required = false,
                                 default = nil)
  if valid_603116 != nil:
    section.add "X-Amz-Content-Sha256", valid_603116
  var valid_603117 = header.getOrDefault("X-Amz-Date")
  valid_603117 = validateParameter(valid_603117, JString, required = false,
                                 default = nil)
  if valid_603117 != nil:
    section.add "X-Amz-Date", valid_603117
  var valid_603118 = header.getOrDefault("X-Amz-Credential")
  valid_603118 = validateParameter(valid_603118, JString, required = false,
                                 default = nil)
  if valid_603118 != nil:
    section.add "X-Amz-Credential", valid_603118
  var valid_603119 = header.getOrDefault("X-Amz-Security-Token")
  valid_603119 = validateParameter(valid_603119, JString, required = false,
                                 default = nil)
  if valid_603119 != nil:
    section.add "X-Amz-Security-Token", valid_603119
  var valid_603120 = header.getOrDefault("X-Amz-Algorithm")
  valid_603120 = validateParameter(valid_603120, JString, required = false,
                                 default = nil)
  if valid_603120 != nil:
    section.add "X-Amz-Algorithm", valid_603120
  var valid_603121 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603121 = validateParameter(valid_603121, JString, required = false,
                                 default = nil)
  if valid_603121 != nil:
    section.add "X-Amz-SignedHeaders", valid_603121
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603123: Call_CreateStream_603111; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.
  ## 
  let valid = call_603123.validator(path, query, header, formData, body)
  let scheme = call_603123.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603123.url(scheme.get, call_603123.host, call_603123.base,
                         call_603123.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603123, url, valid)

proc call*(call_603124: Call_CreateStream_603111; streamId: string; body: JsonNode): Recallable =
  ## createStream
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  ##   body: JObject (required)
  var path_603125 = newJObject()
  var body_603126 = newJObject()
  add(path_603125, "streamId", newJString(streamId))
  if body != nil:
    body_603126 = body
  result = call_603124.call(path_603125, nil, nil, nil, body_603126)

var createStream* = Call_CreateStream_603111(name: "createStream",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_CreateStream_603112,
    base: "/", url: url_CreateStream_603113, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeStream_603081 = ref object of OpenApiRestCall_601389
proc url_DescribeStream_603083(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeStream_603082(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets information about a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_603084 = path.getOrDefault("streamId")
  valid_603084 = validateParameter(valid_603084, JString, required = true,
                                 default = nil)
  if valid_603084 != nil:
    section.add "streamId", valid_603084
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603085 = header.getOrDefault("X-Amz-Signature")
  valid_603085 = validateParameter(valid_603085, JString, required = false,
                                 default = nil)
  if valid_603085 != nil:
    section.add "X-Amz-Signature", valid_603085
  var valid_603086 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603086 = validateParameter(valid_603086, JString, required = false,
                                 default = nil)
  if valid_603086 != nil:
    section.add "X-Amz-Content-Sha256", valid_603086
  var valid_603087 = header.getOrDefault("X-Amz-Date")
  valid_603087 = validateParameter(valid_603087, JString, required = false,
                                 default = nil)
  if valid_603087 != nil:
    section.add "X-Amz-Date", valid_603087
  var valid_603088 = header.getOrDefault("X-Amz-Credential")
  valid_603088 = validateParameter(valid_603088, JString, required = false,
                                 default = nil)
  if valid_603088 != nil:
    section.add "X-Amz-Credential", valid_603088
  var valid_603089 = header.getOrDefault("X-Amz-Security-Token")
  valid_603089 = validateParameter(valid_603089, JString, required = false,
                                 default = nil)
  if valid_603089 != nil:
    section.add "X-Amz-Security-Token", valid_603089
  var valid_603090 = header.getOrDefault("X-Amz-Algorithm")
  valid_603090 = validateParameter(valid_603090, JString, required = false,
                                 default = nil)
  if valid_603090 != nil:
    section.add "X-Amz-Algorithm", valid_603090
  var valid_603091 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603091 = validateParameter(valid_603091, JString, required = false,
                                 default = nil)
  if valid_603091 != nil:
    section.add "X-Amz-SignedHeaders", valid_603091
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603092: Call_DescribeStream_603081; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a stream.
  ## 
  let valid = call_603092.validator(path, query, header, formData, body)
  let scheme = call_603092.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603092.url(scheme.get, call_603092.host, call_603092.base,
                         call_603092.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603092, url, valid)

proc call*(call_603093: Call_DescribeStream_603081; streamId: string): Recallable =
  ## describeStream
  ## Gets information about a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_603094 = newJObject()
  add(path_603094, "streamId", newJString(streamId))
  result = call_603093.call(path_603094, nil, nil, nil, nil)

var describeStream* = Call_DescribeStream_603081(name: "describeStream",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_DescribeStream_603082,
    base: "/", url: url_DescribeStream_603083, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteStream_603127 = ref object of OpenApiRestCall_601389
proc url_DeleteStream_603129(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteStream_603128(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_603130 = path.getOrDefault("streamId")
  valid_603130 = validateParameter(valid_603130, JString, required = true,
                                 default = nil)
  if valid_603130 != nil:
    section.add "streamId", valid_603130
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603131 = header.getOrDefault("X-Amz-Signature")
  valid_603131 = validateParameter(valid_603131, JString, required = false,
                                 default = nil)
  if valid_603131 != nil:
    section.add "X-Amz-Signature", valid_603131
  var valid_603132 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603132 = validateParameter(valid_603132, JString, required = false,
                                 default = nil)
  if valid_603132 != nil:
    section.add "X-Amz-Content-Sha256", valid_603132
  var valid_603133 = header.getOrDefault("X-Amz-Date")
  valid_603133 = validateParameter(valid_603133, JString, required = false,
                                 default = nil)
  if valid_603133 != nil:
    section.add "X-Amz-Date", valid_603133
  var valid_603134 = header.getOrDefault("X-Amz-Credential")
  valid_603134 = validateParameter(valid_603134, JString, required = false,
                                 default = nil)
  if valid_603134 != nil:
    section.add "X-Amz-Credential", valid_603134
  var valid_603135 = header.getOrDefault("X-Amz-Security-Token")
  valid_603135 = validateParameter(valid_603135, JString, required = false,
                                 default = nil)
  if valid_603135 != nil:
    section.add "X-Amz-Security-Token", valid_603135
  var valid_603136 = header.getOrDefault("X-Amz-Algorithm")
  valid_603136 = validateParameter(valid_603136, JString, required = false,
                                 default = nil)
  if valid_603136 != nil:
    section.add "X-Amz-Algorithm", valid_603136
  var valid_603137 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603137 = validateParameter(valid_603137, JString, required = false,
                                 default = nil)
  if valid_603137 != nil:
    section.add "X-Amz-SignedHeaders", valid_603137
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603138: Call_DeleteStream_603127; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a stream.
  ## 
  let valid = call_603138.validator(path, query, header, formData, body)
  let scheme = call_603138.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603138.url(scheme.get, call_603138.host, call_603138.base,
                         call_603138.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603138, url, valid)

proc call*(call_603139: Call_DeleteStream_603127; streamId: string): Recallable =
  ## deleteStream
  ## Deletes a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_603140 = newJObject()
  add(path_603140, "streamId", newJString(streamId))
  result = call_603139.call(path_603140, nil, nil, nil, nil)

var deleteStream* = Call_DeleteStream_603127(name: "deleteStream",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_DeleteStream_603128,
    base: "/", url: url_DeleteStream_603129, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThing_603155 = ref object of OpenApiRestCall_601389
proc url_CreateThing_603157(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateThing_603156(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to create.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_603158 = path.getOrDefault("thingName")
  valid_603158 = validateParameter(valid_603158, JString, required = true,
                                 default = nil)
  if valid_603158 != nil:
    section.add "thingName", valid_603158
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603159 = header.getOrDefault("X-Amz-Signature")
  valid_603159 = validateParameter(valid_603159, JString, required = false,
                                 default = nil)
  if valid_603159 != nil:
    section.add "X-Amz-Signature", valid_603159
  var valid_603160 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603160 = validateParameter(valid_603160, JString, required = false,
                                 default = nil)
  if valid_603160 != nil:
    section.add "X-Amz-Content-Sha256", valid_603160
  var valid_603161 = header.getOrDefault("X-Amz-Date")
  valid_603161 = validateParameter(valid_603161, JString, required = false,
                                 default = nil)
  if valid_603161 != nil:
    section.add "X-Amz-Date", valid_603161
  var valid_603162 = header.getOrDefault("X-Amz-Credential")
  valid_603162 = validateParameter(valid_603162, JString, required = false,
                                 default = nil)
  if valid_603162 != nil:
    section.add "X-Amz-Credential", valid_603162
  var valid_603163 = header.getOrDefault("X-Amz-Security-Token")
  valid_603163 = validateParameter(valid_603163, JString, required = false,
                                 default = nil)
  if valid_603163 != nil:
    section.add "X-Amz-Security-Token", valid_603163
  var valid_603164 = header.getOrDefault("X-Amz-Algorithm")
  valid_603164 = validateParameter(valid_603164, JString, required = false,
                                 default = nil)
  if valid_603164 != nil:
    section.add "X-Amz-Algorithm", valid_603164
  var valid_603165 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603165 = validateParameter(valid_603165, JString, required = false,
                                 default = nil)
  if valid_603165 != nil:
    section.add "X-Amz-SignedHeaders", valid_603165
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603167: Call_CreateThing_603155; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  let valid = call_603167.validator(path, query, header, formData, body)
  let scheme = call_603167.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603167.url(scheme.get, call_603167.host, call_603167.base,
                         call_603167.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603167, url, valid)

proc call*(call_603168: Call_CreateThing_603155; thingName: string; body: JsonNode): Recallable =
  ## createThing
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing to create.
  ##   body: JObject (required)
  var path_603169 = newJObject()
  var body_603170 = newJObject()
  add(path_603169, "thingName", newJString(thingName))
  if body != nil:
    body_603170 = body
  result = call_603168.call(path_603169, nil, nil, nil, body_603170)

var createThing* = Call_CreateThing_603155(name: "createThing",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_CreateThing_603156,
                                        base: "/", url: url_CreateThing_603157,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThing_603141 = ref object of OpenApiRestCall_601389
proc url_DescribeThing_603143(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThing_603142(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the specified thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_603144 = path.getOrDefault("thingName")
  valid_603144 = validateParameter(valid_603144, JString, required = true,
                                 default = nil)
  if valid_603144 != nil:
    section.add "thingName", valid_603144
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603145 = header.getOrDefault("X-Amz-Signature")
  valid_603145 = validateParameter(valid_603145, JString, required = false,
                                 default = nil)
  if valid_603145 != nil:
    section.add "X-Amz-Signature", valid_603145
  var valid_603146 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603146 = validateParameter(valid_603146, JString, required = false,
                                 default = nil)
  if valid_603146 != nil:
    section.add "X-Amz-Content-Sha256", valid_603146
  var valid_603147 = header.getOrDefault("X-Amz-Date")
  valid_603147 = validateParameter(valid_603147, JString, required = false,
                                 default = nil)
  if valid_603147 != nil:
    section.add "X-Amz-Date", valid_603147
  var valid_603148 = header.getOrDefault("X-Amz-Credential")
  valid_603148 = validateParameter(valid_603148, JString, required = false,
                                 default = nil)
  if valid_603148 != nil:
    section.add "X-Amz-Credential", valid_603148
  var valid_603149 = header.getOrDefault("X-Amz-Security-Token")
  valid_603149 = validateParameter(valid_603149, JString, required = false,
                                 default = nil)
  if valid_603149 != nil:
    section.add "X-Amz-Security-Token", valid_603149
  var valid_603150 = header.getOrDefault("X-Amz-Algorithm")
  valid_603150 = validateParameter(valid_603150, JString, required = false,
                                 default = nil)
  if valid_603150 != nil:
    section.add "X-Amz-Algorithm", valid_603150
  var valid_603151 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603151 = validateParameter(valid_603151, JString, required = false,
                                 default = nil)
  if valid_603151 != nil:
    section.add "X-Amz-SignedHeaders", valid_603151
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603152: Call_DescribeThing_603141; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified thing.
  ## 
  let valid = call_603152.validator(path, query, header, formData, body)
  let scheme = call_603152.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603152.url(scheme.get, call_603152.host, call_603152.base,
                         call_603152.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603152, url, valid)

proc call*(call_603153: Call_DescribeThing_603141; thingName: string): Recallable =
  ## describeThing
  ## Gets information about the specified thing.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_603154 = newJObject()
  add(path_603154, "thingName", newJString(thingName))
  result = call_603153.call(path_603154, nil, nil, nil, nil)

var describeThing* = Call_DescribeThing_603141(name: "describeThing",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/things/{thingName}", validator: validate_DescribeThing_603142,
    base: "/", url: url_DescribeThing_603143, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThing_603187 = ref object of OpenApiRestCall_601389
proc url_UpdateThing_603189(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateThing_603188(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the data for a thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_603190 = path.getOrDefault("thingName")
  valid_603190 = validateParameter(valid_603190, JString, required = true,
                                 default = nil)
  if valid_603190 != nil:
    section.add "thingName", valid_603190
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603191 = header.getOrDefault("X-Amz-Signature")
  valid_603191 = validateParameter(valid_603191, JString, required = false,
                                 default = nil)
  if valid_603191 != nil:
    section.add "X-Amz-Signature", valid_603191
  var valid_603192 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603192 = validateParameter(valid_603192, JString, required = false,
                                 default = nil)
  if valid_603192 != nil:
    section.add "X-Amz-Content-Sha256", valid_603192
  var valid_603193 = header.getOrDefault("X-Amz-Date")
  valid_603193 = validateParameter(valid_603193, JString, required = false,
                                 default = nil)
  if valid_603193 != nil:
    section.add "X-Amz-Date", valid_603193
  var valid_603194 = header.getOrDefault("X-Amz-Credential")
  valid_603194 = validateParameter(valid_603194, JString, required = false,
                                 default = nil)
  if valid_603194 != nil:
    section.add "X-Amz-Credential", valid_603194
  var valid_603195 = header.getOrDefault("X-Amz-Security-Token")
  valid_603195 = validateParameter(valid_603195, JString, required = false,
                                 default = nil)
  if valid_603195 != nil:
    section.add "X-Amz-Security-Token", valid_603195
  var valid_603196 = header.getOrDefault("X-Amz-Algorithm")
  valid_603196 = validateParameter(valid_603196, JString, required = false,
                                 default = nil)
  if valid_603196 != nil:
    section.add "X-Amz-Algorithm", valid_603196
  var valid_603197 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603197 = validateParameter(valid_603197, JString, required = false,
                                 default = nil)
  if valid_603197 != nil:
    section.add "X-Amz-SignedHeaders", valid_603197
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603199: Call_UpdateThing_603187; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the data for a thing.
  ## 
  let valid = call_603199.validator(path, query, header, formData, body)
  let scheme = call_603199.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603199.url(scheme.get, call_603199.host, call_603199.base,
                         call_603199.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603199, url, valid)

proc call*(call_603200: Call_UpdateThing_603187; thingName: string; body: JsonNode): Recallable =
  ## updateThing
  ## Updates the data for a thing.
  ##   thingName: string (required)
  ##            : The name of the thing to update.
  ##   body: JObject (required)
  var path_603201 = newJObject()
  var body_603202 = newJObject()
  add(path_603201, "thingName", newJString(thingName))
  if body != nil:
    body_603202 = body
  result = call_603200.call(path_603201, nil, nil, nil, body_603202)

var updateThing* = Call_UpdateThing_603187(name: "updateThing",
                                        meth: HttpMethod.HttpPatch,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_UpdateThing_603188,
                                        base: "/", url: url_UpdateThing_603189,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThing_603171 = ref object of OpenApiRestCall_601389
proc url_DeleteThing_603173(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteThing_603172(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_603174 = path.getOrDefault("thingName")
  valid_603174 = validateParameter(valid_603174, JString, required = true,
                                 default = nil)
  if valid_603174 != nil:
    section.add "thingName", valid_603174
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.
  section = newJObject()
  var valid_603175 = query.getOrDefault("expectedVersion")
  valid_603175 = validateParameter(valid_603175, JInt, required = false, default = nil)
  if valid_603175 != nil:
    section.add "expectedVersion", valid_603175
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603176 = header.getOrDefault("X-Amz-Signature")
  valid_603176 = validateParameter(valid_603176, JString, required = false,
                                 default = nil)
  if valid_603176 != nil:
    section.add "X-Amz-Signature", valid_603176
  var valid_603177 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603177 = validateParameter(valid_603177, JString, required = false,
                                 default = nil)
  if valid_603177 != nil:
    section.add "X-Amz-Content-Sha256", valid_603177
  var valid_603178 = header.getOrDefault("X-Amz-Date")
  valid_603178 = validateParameter(valid_603178, JString, required = false,
                                 default = nil)
  if valid_603178 != nil:
    section.add "X-Amz-Date", valid_603178
  var valid_603179 = header.getOrDefault("X-Amz-Credential")
  valid_603179 = validateParameter(valid_603179, JString, required = false,
                                 default = nil)
  if valid_603179 != nil:
    section.add "X-Amz-Credential", valid_603179
  var valid_603180 = header.getOrDefault("X-Amz-Security-Token")
  valid_603180 = validateParameter(valid_603180, JString, required = false,
                                 default = nil)
  if valid_603180 != nil:
    section.add "X-Amz-Security-Token", valid_603180
  var valid_603181 = header.getOrDefault("X-Amz-Algorithm")
  valid_603181 = validateParameter(valid_603181, JString, required = false,
                                 default = nil)
  if valid_603181 != nil:
    section.add "X-Amz-Algorithm", valid_603181
  var valid_603182 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603182 = validateParameter(valid_603182, JString, required = false,
                                 default = nil)
  if valid_603182 != nil:
    section.add "X-Amz-SignedHeaders", valid_603182
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603183: Call_DeleteThing_603171; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ## 
  let valid = call_603183.validator(path, query, header, formData, body)
  let scheme = call_603183.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603183.url(scheme.get, call_603183.host, call_603183.base,
                         call_603183.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603183, url, valid)

proc call*(call_603184: Call_DeleteThing_603171; thingName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteThing
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ##   expectedVersion: int
  ##                  : The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.
  ##   thingName: string (required)
  ##            : The name of the thing to delete.
  var path_603185 = newJObject()
  var query_603186 = newJObject()
  add(query_603186, "expectedVersion", newJInt(expectedVersion))
  add(path_603185, "thingName", newJString(thingName))
  result = call_603184.call(path_603185, query_603186, nil, nil, nil)

var deleteThing* = Call_DeleteThing_603171(name: "deleteThing",
                                        meth: HttpMethod.HttpDelete,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_DeleteThing_603172,
                                        base: "/", url: url_DeleteThing_603173,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThingGroup_603217 = ref object of OpenApiRestCall_601389
proc url_CreateThingGroup_603219(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateThingGroup_603218(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group name to create.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_603220 = path.getOrDefault("thingGroupName")
  valid_603220 = validateParameter(valid_603220, JString, required = true,
                                 default = nil)
  if valid_603220 != nil:
    section.add "thingGroupName", valid_603220
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603221 = header.getOrDefault("X-Amz-Signature")
  valid_603221 = validateParameter(valid_603221, JString, required = false,
                                 default = nil)
  if valid_603221 != nil:
    section.add "X-Amz-Signature", valid_603221
  var valid_603222 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603222 = validateParameter(valid_603222, JString, required = false,
                                 default = nil)
  if valid_603222 != nil:
    section.add "X-Amz-Content-Sha256", valid_603222
  var valid_603223 = header.getOrDefault("X-Amz-Date")
  valid_603223 = validateParameter(valid_603223, JString, required = false,
                                 default = nil)
  if valid_603223 != nil:
    section.add "X-Amz-Date", valid_603223
  var valid_603224 = header.getOrDefault("X-Amz-Credential")
  valid_603224 = validateParameter(valid_603224, JString, required = false,
                                 default = nil)
  if valid_603224 != nil:
    section.add "X-Amz-Credential", valid_603224
  var valid_603225 = header.getOrDefault("X-Amz-Security-Token")
  valid_603225 = validateParameter(valid_603225, JString, required = false,
                                 default = nil)
  if valid_603225 != nil:
    section.add "X-Amz-Security-Token", valid_603225
  var valid_603226 = header.getOrDefault("X-Amz-Algorithm")
  valid_603226 = validateParameter(valid_603226, JString, required = false,
                                 default = nil)
  if valid_603226 != nil:
    section.add "X-Amz-Algorithm", valid_603226
  var valid_603227 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603227 = validateParameter(valid_603227, JString, required = false,
                                 default = nil)
  if valid_603227 != nil:
    section.add "X-Amz-SignedHeaders", valid_603227
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603229: Call_CreateThingGroup_603217; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  let valid = call_603229.validator(path, query, header, formData, body)
  let scheme = call_603229.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603229.url(scheme.get, call_603229.host, call_603229.base,
                         call_603229.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603229, url, valid)

proc call*(call_603230: Call_CreateThingGroup_603217; thingGroupName: string;
          body: JsonNode): Recallable =
  ## createThingGroup
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ##   thingGroupName: string (required)
  ##                 : The thing group name to create.
  ##   body: JObject (required)
  var path_603231 = newJObject()
  var body_603232 = newJObject()
  add(path_603231, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_603232 = body
  result = call_603230.call(path_603231, nil, nil, nil, body_603232)

var createThingGroup* = Call_CreateThingGroup_603217(name: "createThingGroup",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_CreateThingGroup_603218,
    base: "/", url: url_CreateThingGroup_603219,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingGroup_603203 = ref object of OpenApiRestCall_601389
proc url_DescribeThingGroup_603205(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThingGroup_603204(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Describe a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the thing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_603206 = path.getOrDefault("thingGroupName")
  valid_603206 = validateParameter(valid_603206, JString, required = true,
                                 default = nil)
  if valid_603206 != nil:
    section.add "thingGroupName", valid_603206
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603207 = header.getOrDefault("X-Amz-Signature")
  valid_603207 = validateParameter(valid_603207, JString, required = false,
                                 default = nil)
  if valid_603207 != nil:
    section.add "X-Amz-Signature", valid_603207
  var valid_603208 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603208 = validateParameter(valid_603208, JString, required = false,
                                 default = nil)
  if valid_603208 != nil:
    section.add "X-Amz-Content-Sha256", valid_603208
  var valid_603209 = header.getOrDefault("X-Amz-Date")
  valid_603209 = validateParameter(valid_603209, JString, required = false,
                                 default = nil)
  if valid_603209 != nil:
    section.add "X-Amz-Date", valid_603209
  var valid_603210 = header.getOrDefault("X-Amz-Credential")
  valid_603210 = validateParameter(valid_603210, JString, required = false,
                                 default = nil)
  if valid_603210 != nil:
    section.add "X-Amz-Credential", valid_603210
  var valid_603211 = header.getOrDefault("X-Amz-Security-Token")
  valid_603211 = validateParameter(valid_603211, JString, required = false,
                                 default = nil)
  if valid_603211 != nil:
    section.add "X-Amz-Security-Token", valid_603211
  var valid_603212 = header.getOrDefault("X-Amz-Algorithm")
  valid_603212 = validateParameter(valid_603212, JString, required = false,
                                 default = nil)
  if valid_603212 != nil:
    section.add "X-Amz-Algorithm", valid_603212
  var valid_603213 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603213 = validateParameter(valid_603213, JString, required = false,
                                 default = nil)
  if valid_603213 != nil:
    section.add "X-Amz-SignedHeaders", valid_603213
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603214: Call_DescribeThingGroup_603203; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describe a thing group.
  ## 
  let valid = call_603214.validator(path, query, header, formData, body)
  let scheme = call_603214.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603214.url(scheme.get, call_603214.host, call_603214.base,
                         call_603214.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603214, url, valid)

proc call*(call_603215: Call_DescribeThingGroup_603203; thingGroupName: string): Recallable =
  ## describeThingGroup
  ## Describe a thing group.
  ##   thingGroupName: string (required)
  ##                 : The name of the thing group.
  var path_603216 = newJObject()
  add(path_603216, "thingGroupName", newJString(thingGroupName))
  result = call_603215.call(path_603216, nil, nil, nil, nil)

var describeThingGroup* = Call_DescribeThingGroup_603203(
    name: "describeThingGroup", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}",
    validator: validate_DescribeThingGroup_603204, base: "/",
    url: url_DescribeThingGroup_603205, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThingGroup_603249 = ref object of OpenApiRestCall_601389
proc url_UpdateThingGroup_603251(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateThingGroup_603250(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Update a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group to update.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_603252 = path.getOrDefault("thingGroupName")
  valid_603252 = validateParameter(valid_603252, JString, required = true,
                                 default = nil)
  if valid_603252 != nil:
    section.add "thingGroupName", valid_603252
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603253 = header.getOrDefault("X-Amz-Signature")
  valid_603253 = validateParameter(valid_603253, JString, required = false,
                                 default = nil)
  if valid_603253 != nil:
    section.add "X-Amz-Signature", valid_603253
  var valid_603254 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603254 = validateParameter(valid_603254, JString, required = false,
                                 default = nil)
  if valid_603254 != nil:
    section.add "X-Amz-Content-Sha256", valid_603254
  var valid_603255 = header.getOrDefault("X-Amz-Date")
  valid_603255 = validateParameter(valid_603255, JString, required = false,
                                 default = nil)
  if valid_603255 != nil:
    section.add "X-Amz-Date", valid_603255
  var valid_603256 = header.getOrDefault("X-Amz-Credential")
  valid_603256 = validateParameter(valid_603256, JString, required = false,
                                 default = nil)
  if valid_603256 != nil:
    section.add "X-Amz-Credential", valid_603256
  var valid_603257 = header.getOrDefault("X-Amz-Security-Token")
  valid_603257 = validateParameter(valid_603257, JString, required = false,
                                 default = nil)
  if valid_603257 != nil:
    section.add "X-Amz-Security-Token", valid_603257
  var valid_603258 = header.getOrDefault("X-Amz-Algorithm")
  valid_603258 = validateParameter(valid_603258, JString, required = false,
                                 default = nil)
  if valid_603258 != nil:
    section.add "X-Amz-Algorithm", valid_603258
  var valid_603259 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603259 = validateParameter(valid_603259, JString, required = false,
                                 default = nil)
  if valid_603259 != nil:
    section.add "X-Amz-SignedHeaders", valid_603259
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603261: Call_UpdateThingGroup_603249; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update a thing group.
  ## 
  let valid = call_603261.validator(path, query, header, formData, body)
  let scheme = call_603261.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603261.url(scheme.get, call_603261.host, call_603261.base,
                         call_603261.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603261, url, valid)

proc call*(call_603262: Call_UpdateThingGroup_603249; thingGroupName: string;
          body: JsonNode): Recallable =
  ## updateThingGroup
  ## Update a thing group.
  ##   thingGroupName: string (required)
  ##                 : The thing group to update.
  ##   body: JObject (required)
  var path_603263 = newJObject()
  var body_603264 = newJObject()
  add(path_603263, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_603264 = body
  result = call_603262.call(path_603263, nil, nil, nil, body_603264)

var updateThingGroup* = Call_UpdateThingGroup_603249(name: "updateThingGroup",
    meth: HttpMethod.HttpPatch, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_UpdateThingGroup_603250,
    base: "/", url: url_UpdateThingGroup_603251,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThingGroup_603233 = ref object of OpenApiRestCall_601389
proc url_DeleteThingGroup_603235(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteThingGroup_603234(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Deletes a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the thing group to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_603236 = path.getOrDefault("thingGroupName")
  valid_603236 = validateParameter(valid_603236, JString, required = true,
                                 default = nil)
  if valid_603236 != nil:
    section.add "thingGroupName", valid_603236
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the thing group to delete.
  section = newJObject()
  var valid_603237 = query.getOrDefault("expectedVersion")
  valid_603237 = validateParameter(valid_603237, JInt, required = false, default = nil)
  if valid_603237 != nil:
    section.add "expectedVersion", valid_603237
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603238 = header.getOrDefault("X-Amz-Signature")
  valid_603238 = validateParameter(valid_603238, JString, required = false,
                                 default = nil)
  if valid_603238 != nil:
    section.add "X-Amz-Signature", valid_603238
  var valid_603239 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603239 = validateParameter(valid_603239, JString, required = false,
                                 default = nil)
  if valid_603239 != nil:
    section.add "X-Amz-Content-Sha256", valid_603239
  var valid_603240 = header.getOrDefault("X-Amz-Date")
  valid_603240 = validateParameter(valid_603240, JString, required = false,
                                 default = nil)
  if valid_603240 != nil:
    section.add "X-Amz-Date", valid_603240
  var valid_603241 = header.getOrDefault("X-Amz-Credential")
  valid_603241 = validateParameter(valid_603241, JString, required = false,
                                 default = nil)
  if valid_603241 != nil:
    section.add "X-Amz-Credential", valid_603241
  var valid_603242 = header.getOrDefault("X-Amz-Security-Token")
  valid_603242 = validateParameter(valid_603242, JString, required = false,
                                 default = nil)
  if valid_603242 != nil:
    section.add "X-Amz-Security-Token", valid_603242
  var valid_603243 = header.getOrDefault("X-Amz-Algorithm")
  valid_603243 = validateParameter(valid_603243, JString, required = false,
                                 default = nil)
  if valid_603243 != nil:
    section.add "X-Amz-Algorithm", valid_603243
  var valid_603244 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603244 = validateParameter(valid_603244, JString, required = false,
                                 default = nil)
  if valid_603244 != nil:
    section.add "X-Amz-SignedHeaders", valid_603244
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603245: Call_DeleteThingGroup_603233; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a thing group.
  ## 
  let valid = call_603245.validator(path, query, header, formData, body)
  let scheme = call_603245.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603245.url(scheme.get, call_603245.host, call_603245.base,
                         call_603245.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603245, url, valid)

proc call*(call_603246: Call_DeleteThingGroup_603233; thingGroupName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteThingGroup
  ## Deletes a thing group.
  ##   expectedVersion: int
  ##                  : The expected version of the thing group to delete.
  ##   thingGroupName: string (required)
  ##                 : The name of the thing group to delete.
  var path_603247 = newJObject()
  var query_603248 = newJObject()
  add(query_603248, "expectedVersion", newJInt(expectedVersion))
  add(path_603247, "thingGroupName", newJString(thingGroupName))
  result = call_603246.call(path_603247, query_603248, nil, nil, nil)

var deleteThingGroup* = Call_DeleteThingGroup_603233(name: "deleteThingGroup",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_DeleteThingGroup_603234,
    base: "/", url: url_DeleteThingGroup_603235,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThingType_603279 = ref object of OpenApiRestCall_601389
proc url_CreateThingType_603281(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateThingType_603280(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a new thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_603282 = path.getOrDefault("thingTypeName")
  valid_603282 = validateParameter(valid_603282, JString, required = true,
                                 default = nil)
  if valid_603282 != nil:
    section.add "thingTypeName", valid_603282
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603283 = header.getOrDefault("X-Amz-Signature")
  valid_603283 = validateParameter(valid_603283, JString, required = false,
                                 default = nil)
  if valid_603283 != nil:
    section.add "X-Amz-Signature", valid_603283
  var valid_603284 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603284 = validateParameter(valid_603284, JString, required = false,
                                 default = nil)
  if valid_603284 != nil:
    section.add "X-Amz-Content-Sha256", valid_603284
  var valid_603285 = header.getOrDefault("X-Amz-Date")
  valid_603285 = validateParameter(valid_603285, JString, required = false,
                                 default = nil)
  if valid_603285 != nil:
    section.add "X-Amz-Date", valid_603285
  var valid_603286 = header.getOrDefault("X-Amz-Credential")
  valid_603286 = validateParameter(valid_603286, JString, required = false,
                                 default = nil)
  if valid_603286 != nil:
    section.add "X-Amz-Credential", valid_603286
  var valid_603287 = header.getOrDefault("X-Amz-Security-Token")
  valid_603287 = validateParameter(valid_603287, JString, required = false,
                                 default = nil)
  if valid_603287 != nil:
    section.add "X-Amz-Security-Token", valid_603287
  var valid_603288 = header.getOrDefault("X-Amz-Algorithm")
  valid_603288 = validateParameter(valid_603288, JString, required = false,
                                 default = nil)
  if valid_603288 != nil:
    section.add "X-Amz-Algorithm", valid_603288
  var valid_603289 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603289 = validateParameter(valid_603289, JString, required = false,
                                 default = nil)
  if valid_603289 != nil:
    section.add "X-Amz-SignedHeaders", valid_603289
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603291: Call_CreateThingType_603279; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new thing type.
  ## 
  let valid = call_603291.validator(path, query, header, formData, body)
  let scheme = call_603291.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603291.url(scheme.get, call_603291.host, call_603291.base,
                         call_603291.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603291, url, valid)

proc call*(call_603292: Call_CreateThingType_603279; thingTypeName: string;
          body: JsonNode): Recallable =
  ## createThingType
  ## Creates a new thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  ##   body: JObject (required)
  var path_603293 = newJObject()
  var body_603294 = newJObject()
  add(path_603293, "thingTypeName", newJString(thingTypeName))
  if body != nil:
    body_603294 = body
  result = call_603292.call(path_603293, nil, nil, nil, body_603294)

var createThingType* = Call_CreateThingType_603279(name: "createThingType",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_CreateThingType_603280,
    base: "/", url: url_CreateThingType_603281, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingType_603265 = ref object of OpenApiRestCall_601389
proc url_DescribeThingType_603267(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThingType_603266(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Gets information about the specified thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_603268 = path.getOrDefault("thingTypeName")
  valid_603268 = validateParameter(valid_603268, JString, required = true,
                                 default = nil)
  if valid_603268 != nil:
    section.add "thingTypeName", valid_603268
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603269 = header.getOrDefault("X-Amz-Signature")
  valid_603269 = validateParameter(valid_603269, JString, required = false,
                                 default = nil)
  if valid_603269 != nil:
    section.add "X-Amz-Signature", valid_603269
  var valid_603270 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603270 = validateParameter(valid_603270, JString, required = false,
                                 default = nil)
  if valid_603270 != nil:
    section.add "X-Amz-Content-Sha256", valid_603270
  var valid_603271 = header.getOrDefault("X-Amz-Date")
  valid_603271 = validateParameter(valid_603271, JString, required = false,
                                 default = nil)
  if valid_603271 != nil:
    section.add "X-Amz-Date", valid_603271
  var valid_603272 = header.getOrDefault("X-Amz-Credential")
  valid_603272 = validateParameter(valid_603272, JString, required = false,
                                 default = nil)
  if valid_603272 != nil:
    section.add "X-Amz-Credential", valid_603272
  var valid_603273 = header.getOrDefault("X-Amz-Security-Token")
  valid_603273 = validateParameter(valid_603273, JString, required = false,
                                 default = nil)
  if valid_603273 != nil:
    section.add "X-Amz-Security-Token", valid_603273
  var valid_603274 = header.getOrDefault("X-Amz-Algorithm")
  valid_603274 = validateParameter(valid_603274, JString, required = false,
                                 default = nil)
  if valid_603274 != nil:
    section.add "X-Amz-Algorithm", valid_603274
  var valid_603275 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603275 = validateParameter(valid_603275, JString, required = false,
                                 default = nil)
  if valid_603275 != nil:
    section.add "X-Amz-SignedHeaders", valid_603275
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603276: Call_DescribeThingType_603265; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified thing type.
  ## 
  let valid = call_603276.validator(path, query, header, formData, body)
  let scheme = call_603276.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603276.url(scheme.get, call_603276.host, call_603276.base,
                         call_603276.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603276, url, valid)

proc call*(call_603277: Call_DescribeThingType_603265; thingTypeName: string): Recallable =
  ## describeThingType
  ## Gets information about the specified thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_603278 = newJObject()
  add(path_603278, "thingTypeName", newJString(thingTypeName))
  result = call_603277.call(path_603278, nil, nil, nil, nil)

var describeThingType* = Call_DescribeThingType_603265(name: "describeThingType",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_DescribeThingType_603266,
    base: "/", url: url_DescribeThingType_603267,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThingType_603295 = ref object of OpenApiRestCall_601389
proc url_DeleteThingType_603297(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteThingType_603296(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_603298 = path.getOrDefault("thingTypeName")
  valid_603298 = validateParameter(valid_603298, JString, required = true,
                                 default = nil)
  if valid_603298 != nil:
    section.add "thingTypeName", valid_603298
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603299 = header.getOrDefault("X-Amz-Signature")
  valid_603299 = validateParameter(valid_603299, JString, required = false,
                                 default = nil)
  if valid_603299 != nil:
    section.add "X-Amz-Signature", valid_603299
  var valid_603300 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603300 = validateParameter(valid_603300, JString, required = false,
                                 default = nil)
  if valid_603300 != nil:
    section.add "X-Amz-Content-Sha256", valid_603300
  var valid_603301 = header.getOrDefault("X-Amz-Date")
  valid_603301 = validateParameter(valid_603301, JString, required = false,
                                 default = nil)
  if valid_603301 != nil:
    section.add "X-Amz-Date", valid_603301
  var valid_603302 = header.getOrDefault("X-Amz-Credential")
  valid_603302 = validateParameter(valid_603302, JString, required = false,
                                 default = nil)
  if valid_603302 != nil:
    section.add "X-Amz-Credential", valid_603302
  var valid_603303 = header.getOrDefault("X-Amz-Security-Token")
  valid_603303 = validateParameter(valid_603303, JString, required = false,
                                 default = nil)
  if valid_603303 != nil:
    section.add "X-Amz-Security-Token", valid_603303
  var valid_603304 = header.getOrDefault("X-Amz-Algorithm")
  valid_603304 = validateParameter(valid_603304, JString, required = false,
                                 default = nil)
  if valid_603304 != nil:
    section.add "X-Amz-Algorithm", valid_603304
  var valid_603305 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603305 = validateParameter(valid_603305, JString, required = false,
                                 default = nil)
  if valid_603305 != nil:
    section.add "X-Amz-SignedHeaders", valid_603305
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603306: Call_DeleteThingType_603295; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ## 
  let valid = call_603306.validator(path, query, header, formData, body)
  let scheme = call_603306.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603306.url(scheme.get, call_603306.host, call_603306.base,
                         call_603306.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603306, url, valid)

proc call*(call_603307: Call_DeleteThingType_603295; thingTypeName: string): Recallable =
  ## deleteThingType
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_603308 = newJObject()
  add(path_603308, "thingTypeName", newJString(thingTypeName))
  result = call_603307.call(path_603308, nil, nil, nil, nil)

var deleteThingType* = Call_DeleteThingType_603295(name: "deleteThingType",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_DeleteThingType_603296,
    base: "/", url: url_DeleteThingType_603297, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateTopicRule_603323 = ref object of OpenApiRestCall_601389
proc url_CreateTopicRule_603325(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateTopicRule_603324(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_603326 = path.getOrDefault("ruleName")
  valid_603326 = validateParameter(valid_603326, JString, required = true,
                                 default = nil)
  if valid_603326 != nil:
    section.add "ruleName", valid_603326
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   x-amz-tagging: JString
  ##                : <p>Metadata which can be used to manage the topic rule.</p> <note> <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p> <p>For the CLI command-line parameter use format: --tags "key1=value1&amp;key2=value2..."</p> <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p> </note>
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603327 = header.getOrDefault("x-amz-tagging")
  valid_603327 = validateParameter(valid_603327, JString, required = false,
                                 default = nil)
  if valid_603327 != nil:
    section.add "x-amz-tagging", valid_603327
  var valid_603328 = header.getOrDefault("X-Amz-Signature")
  valid_603328 = validateParameter(valid_603328, JString, required = false,
                                 default = nil)
  if valid_603328 != nil:
    section.add "X-Amz-Signature", valid_603328
  var valid_603329 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603329 = validateParameter(valid_603329, JString, required = false,
                                 default = nil)
  if valid_603329 != nil:
    section.add "X-Amz-Content-Sha256", valid_603329
  var valid_603330 = header.getOrDefault("X-Amz-Date")
  valid_603330 = validateParameter(valid_603330, JString, required = false,
                                 default = nil)
  if valid_603330 != nil:
    section.add "X-Amz-Date", valid_603330
  var valid_603331 = header.getOrDefault("X-Amz-Credential")
  valid_603331 = validateParameter(valid_603331, JString, required = false,
                                 default = nil)
  if valid_603331 != nil:
    section.add "X-Amz-Credential", valid_603331
  var valid_603332 = header.getOrDefault("X-Amz-Security-Token")
  valid_603332 = validateParameter(valid_603332, JString, required = false,
                                 default = nil)
  if valid_603332 != nil:
    section.add "X-Amz-Security-Token", valid_603332
  var valid_603333 = header.getOrDefault("X-Amz-Algorithm")
  valid_603333 = validateParameter(valid_603333, JString, required = false,
                                 default = nil)
  if valid_603333 != nil:
    section.add "X-Amz-Algorithm", valid_603333
  var valid_603334 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603334 = validateParameter(valid_603334, JString, required = false,
                                 default = nil)
  if valid_603334 != nil:
    section.add "X-Amz-SignedHeaders", valid_603334
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603336: Call_CreateTopicRule_603323; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  let valid = call_603336.validator(path, query, header, formData, body)
  let scheme = call_603336.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603336.url(scheme.get, call_603336.host, call_603336.base,
                         call_603336.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603336, url, valid)

proc call*(call_603337: Call_CreateTopicRule_603323; ruleName: string; body: JsonNode): Recallable =
  ## createTopicRule
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  ##   body: JObject (required)
  var path_603338 = newJObject()
  var body_603339 = newJObject()
  add(path_603338, "ruleName", newJString(ruleName))
  if body != nil:
    body_603339 = body
  result = call_603337.call(path_603338, nil, nil, nil, body_603339)

var createTopicRule* = Call_CreateTopicRule_603323(name: "createTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_CreateTopicRule_603324,
    base: "/", url: url_CreateTopicRule_603325, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetTopicRule_603309 = ref object of OpenApiRestCall_601389
proc url_GetTopicRule_603311(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTopicRule_603310(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_603312 = path.getOrDefault("ruleName")
  valid_603312 = validateParameter(valid_603312, JString, required = true,
                                 default = nil)
  if valid_603312 != nil:
    section.add "ruleName", valid_603312
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603313 = header.getOrDefault("X-Amz-Signature")
  valid_603313 = validateParameter(valid_603313, JString, required = false,
                                 default = nil)
  if valid_603313 != nil:
    section.add "X-Amz-Signature", valid_603313
  var valid_603314 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603314 = validateParameter(valid_603314, JString, required = false,
                                 default = nil)
  if valid_603314 != nil:
    section.add "X-Amz-Content-Sha256", valid_603314
  var valid_603315 = header.getOrDefault("X-Amz-Date")
  valid_603315 = validateParameter(valid_603315, JString, required = false,
                                 default = nil)
  if valid_603315 != nil:
    section.add "X-Amz-Date", valid_603315
  var valid_603316 = header.getOrDefault("X-Amz-Credential")
  valid_603316 = validateParameter(valid_603316, JString, required = false,
                                 default = nil)
  if valid_603316 != nil:
    section.add "X-Amz-Credential", valid_603316
  var valid_603317 = header.getOrDefault("X-Amz-Security-Token")
  valid_603317 = validateParameter(valid_603317, JString, required = false,
                                 default = nil)
  if valid_603317 != nil:
    section.add "X-Amz-Security-Token", valid_603317
  var valid_603318 = header.getOrDefault("X-Amz-Algorithm")
  valid_603318 = validateParameter(valid_603318, JString, required = false,
                                 default = nil)
  if valid_603318 != nil:
    section.add "X-Amz-Algorithm", valid_603318
  var valid_603319 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603319 = validateParameter(valid_603319, JString, required = false,
                                 default = nil)
  if valid_603319 != nil:
    section.add "X-Amz-SignedHeaders", valid_603319
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603320: Call_GetTopicRule_603309; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the rule.
  ## 
  let valid = call_603320.validator(path, query, header, formData, body)
  let scheme = call_603320.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603320.url(scheme.get, call_603320.host, call_603320.base,
                         call_603320.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603320, url, valid)

proc call*(call_603321: Call_GetTopicRule_603309; ruleName: string): Recallable =
  ## getTopicRule
  ## Gets information about the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  var path_603322 = newJObject()
  add(path_603322, "ruleName", newJString(ruleName))
  result = call_603321.call(path_603322, nil, nil, nil, nil)

var getTopicRule* = Call_GetTopicRule_603309(name: "getTopicRule",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/rules/{ruleName}",
    validator: validate_GetTopicRule_603310, base: "/", url: url_GetTopicRule_603311,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReplaceTopicRule_603354 = ref object of OpenApiRestCall_601389
proc url_ReplaceTopicRule_603356(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ReplaceTopicRule_603355(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_603357 = path.getOrDefault("ruleName")
  valid_603357 = validateParameter(valid_603357, JString, required = true,
                                 default = nil)
  if valid_603357 != nil:
    section.add "ruleName", valid_603357
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603358 = header.getOrDefault("X-Amz-Signature")
  valid_603358 = validateParameter(valid_603358, JString, required = false,
                                 default = nil)
  if valid_603358 != nil:
    section.add "X-Amz-Signature", valid_603358
  var valid_603359 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603359 = validateParameter(valid_603359, JString, required = false,
                                 default = nil)
  if valid_603359 != nil:
    section.add "X-Amz-Content-Sha256", valid_603359
  var valid_603360 = header.getOrDefault("X-Amz-Date")
  valid_603360 = validateParameter(valid_603360, JString, required = false,
                                 default = nil)
  if valid_603360 != nil:
    section.add "X-Amz-Date", valid_603360
  var valid_603361 = header.getOrDefault("X-Amz-Credential")
  valid_603361 = validateParameter(valid_603361, JString, required = false,
                                 default = nil)
  if valid_603361 != nil:
    section.add "X-Amz-Credential", valid_603361
  var valid_603362 = header.getOrDefault("X-Amz-Security-Token")
  valid_603362 = validateParameter(valid_603362, JString, required = false,
                                 default = nil)
  if valid_603362 != nil:
    section.add "X-Amz-Security-Token", valid_603362
  var valid_603363 = header.getOrDefault("X-Amz-Algorithm")
  valid_603363 = validateParameter(valid_603363, JString, required = false,
                                 default = nil)
  if valid_603363 != nil:
    section.add "X-Amz-Algorithm", valid_603363
  var valid_603364 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603364 = validateParameter(valid_603364, JString, required = false,
                                 default = nil)
  if valid_603364 != nil:
    section.add "X-Amz-SignedHeaders", valid_603364
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603366: Call_ReplaceTopicRule_603354; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  let valid = call_603366.validator(path, query, header, formData, body)
  let scheme = call_603366.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603366.url(scheme.get, call_603366.host, call_603366.base,
                         call_603366.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603366, url, valid)

proc call*(call_603367: Call_ReplaceTopicRule_603354; ruleName: string;
          body: JsonNode): Recallable =
  ## replaceTopicRule
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  ##   body: JObject (required)
  var path_603368 = newJObject()
  var body_603369 = newJObject()
  add(path_603368, "ruleName", newJString(ruleName))
  if body != nil:
    body_603369 = body
  result = call_603367.call(path_603368, nil, nil, nil, body_603369)

var replaceTopicRule* = Call_ReplaceTopicRule_603354(name: "replaceTopicRule",
    meth: HttpMethod.HttpPatch, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_ReplaceTopicRule_603355,
    base: "/", url: url_ReplaceTopicRule_603356,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteTopicRule_603340 = ref object of OpenApiRestCall_601389
proc url_DeleteTopicRule_603342(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTopicRule_603341(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_603343 = path.getOrDefault("ruleName")
  valid_603343 = validateParameter(valid_603343, JString, required = true,
                                 default = nil)
  if valid_603343 != nil:
    section.add "ruleName", valid_603343
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603344 = header.getOrDefault("X-Amz-Signature")
  valid_603344 = validateParameter(valid_603344, JString, required = false,
                                 default = nil)
  if valid_603344 != nil:
    section.add "X-Amz-Signature", valid_603344
  var valid_603345 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603345 = validateParameter(valid_603345, JString, required = false,
                                 default = nil)
  if valid_603345 != nil:
    section.add "X-Amz-Content-Sha256", valid_603345
  var valid_603346 = header.getOrDefault("X-Amz-Date")
  valid_603346 = validateParameter(valid_603346, JString, required = false,
                                 default = nil)
  if valid_603346 != nil:
    section.add "X-Amz-Date", valid_603346
  var valid_603347 = header.getOrDefault("X-Amz-Credential")
  valid_603347 = validateParameter(valid_603347, JString, required = false,
                                 default = nil)
  if valid_603347 != nil:
    section.add "X-Amz-Credential", valid_603347
  var valid_603348 = header.getOrDefault("X-Amz-Security-Token")
  valid_603348 = validateParameter(valid_603348, JString, required = false,
                                 default = nil)
  if valid_603348 != nil:
    section.add "X-Amz-Security-Token", valid_603348
  var valid_603349 = header.getOrDefault("X-Amz-Algorithm")
  valid_603349 = validateParameter(valid_603349, JString, required = false,
                                 default = nil)
  if valid_603349 != nil:
    section.add "X-Amz-Algorithm", valid_603349
  var valid_603350 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603350 = validateParameter(valid_603350, JString, required = false,
                                 default = nil)
  if valid_603350 != nil:
    section.add "X-Amz-SignedHeaders", valid_603350
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603351: Call_DeleteTopicRule_603340; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the rule.
  ## 
  let valid = call_603351.validator(path, query, header, formData, body)
  let scheme = call_603351.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603351.url(scheme.get, call_603351.host, call_603351.base,
                         call_603351.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603351, url, valid)

proc call*(call_603352: Call_DeleteTopicRule_603340; ruleName: string): Recallable =
  ## deleteTopicRule
  ## Deletes the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  var path_603353 = newJObject()
  add(path_603353, "ruleName", newJString(ruleName))
  result = call_603352.call(path_603353, nil, nil, nil, nil)

var deleteTopicRule* = Call_DeleteTopicRule_603340(name: "deleteTopicRule",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_DeleteTopicRule_603341,
    base: "/", url: url_DeleteTopicRule_603342, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateTopicRuleDestination_603385 = ref object of OpenApiRestCall_601389
proc url_CreateTopicRuleDestination_603387(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateTopicRuleDestination_603386(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a topic rule destination. The destination must be confirmed prior to use.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603388 = header.getOrDefault("X-Amz-Signature")
  valid_603388 = validateParameter(valid_603388, JString, required = false,
                                 default = nil)
  if valid_603388 != nil:
    section.add "X-Amz-Signature", valid_603388
  var valid_603389 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603389 = validateParameter(valid_603389, JString, required = false,
                                 default = nil)
  if valid_603389 != nil:
    section.add "X-Amz-Content-Sha256", valid_603389
  var valid_603390 = header.getOrDefault("X-Amz-Date")
  valid_603390 = validateParameter(valid_603390, JString, required = false,
                                 default = nil)
  if valid_603390 != nil:
    section.add "X-Amz-Date", valid_603390
  var valid_603391 = header.getOrDefault("X-Amz-Credential")
  valid_603391 = validateParameter(valid_603391, JString, required = false,
                                 default = nil)
  if valid_603391 != nil:
    section.add "X-Amz-Credential", valid_603391
  var valid_603392 = header.getOrDefault("X-Amz-Security-Token")
  valid_603392 = validateParameter(valid_603392, JString, required = false,
                                 default = nil)
  if valid_603392 != nil:
    section.add "X-Amz-Security-Token", valid_603392
  var valid_603393 = header.getOrDefault("X-Amz-Algorithm")
  valid_603393 = validateParameter(valid_603393, JString, required = false,
                                 default = nil)
  if valid_603393 != nil:
    section.add "X-Amz-Algorithm", valid_603393
  var valid_603394 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603394 = validateParameter(valid_603394, JString, required = false,
                                 default = nil)
  if valid_603394 != nil:
    section.add "X-Amz-SignedHeaders", valid_603394
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603396: Call_CreateTopicRuleDestination_603385; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a topic rule destination. The destination must be confirmed prior to use.
  ## 
  let valid = call_603396.validator(path, query, header, formData, body)
  let scheme = call_603396.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603396.url(scheme.get, call_603396.host, call_603396.base,
                         call_603396.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603396, url, valid)

proc call*(call_603397: Call_CreateTopicRuleDestination_603385; body: JsonNode): Recallable =
  ## createTopicRuleDestination
  ## Creates a topic rule destination. The destination must be confirmed prior to use.
  ##   body: JObject (required)
  var body_603398 = newJObject()
  if body != nil:
    body_603398 = body
  result = call_603397.call(nil, nil, nil, nil, body_603398)

var createTopicRuleDestination* = Call_CreateTopicRuleDestination_603385(
    name: "createTopicRuleDestination", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/destinations",
    validator: validate_CreateTopicRuleDestination_603386, base: "/",
    url: url_CreateTopicRuleDestination_603387,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTopicRuleDestinations_603370 = ref object of OpenApiRestCall_601389
proc url_ListTopicRuleDestinations_603372(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListTopicRuleDestinations_603371(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all the topic rule destinations in your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_603373 = query.getOrDefault("nextToken")
  valid_603373 = validateParameter(valid_603373, JString, required = false,
                                 default = nil)
  if valid_603373 != nil:
    section.add "nextToken", valid_603373
  var valid_603374 = query.getOrDefault("maxResults")
  valid_603374 = validateParameter(valid_603374, JInt, required = false, default = nil)
  if valid_603374 != nil:
    section.add "maxResults", valid_603374
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603375 = header.getOrDefault("X-Amz-Signature")
  valid_603375 = validateParameter(valid_603375, JString, required = false,
                                 default = nil)
  if valid_603375 != nil:
    section.add "X-Amz-Signature", valid_603375
  var valid_603376 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603376 = validateParameter(valid_603376, JString, required = false,
                                 default = nil)
  if valid_603376 != nil:
    section.add "X-Amz-Content-Sha256", valid_603376
  var valid_603377 = header.getOrDefault("X-Amz-Date")
  valid_603377 = validateParameter(valid_603377, JString, required = false,
                                 default = nil)
  if valid_603377 != nil:
    section.add "X-Amz-Date", valid_603377
  var valid_603378 = header.getOrDefault("X-Amz-Credential")
  valid_603378 = validateParameter(valid_603378, JString, required = false,
                                 default = nil)
  if valid_603378 != nil:
    section.add "X-Amz-Credential", valid_603378
  var valid_603379 = header.getOrDefault("X-Amz-Security-Token")
  valid_603379 = validateParameter(valid_603379, JString, required = false,
                                 default = nil)
  if valid_603379 != nil:
    section.add "X-Amz-Security-Token", valid_603379
  var valid_603380 = header.getOrDefault("X-Amz-Algorithm")
  valid_603380 = validateParameter(valid_603380, JString, required = false,
                                 default = nil)
  if valid_603380 != nil:
    section.add "X-Amz-Algorithm", valid_603380
  var valid_603381 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603381 = validateParameter(valid_603381, JString, required = false,
                                 default = nil)
  if valid_603381 != nil:
    section.add "X-Amz-SignedHeaders", valid_603381
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603382: Call_ListTopicRuleDestinations_603370; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all the topic rule destinations in your AWS account.
  ## 
  let valid = call_603382.validator(path, query, header, formData, body)
  let scheme = call_603382.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603382.url(scheme.get, call_603382.host, call_603382.base,
                         call_603382.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603382, url, valid)

proc call*(call_603383: Call_ListTopicRuleDestinations_603370;
          nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listTopicRuleDestinations
  ## Lists all the topic rule destinations in your AWS account.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_603384 = newJObject()
  add(query_603384, "nextToken", newJString(nextToken))
  add(query_603384, "maxResults", newJInt(maxResults))
  result = call_603383.call(nil, query_603384, nil, nil, nil)

var listTopicRuleDestinations* = Call_ListTopicRuleDestinations_603370(
    name: "listTopicRuleDestinations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/destinations",
    validator: validate_ListTopicRuleDestinations_603371, base: "/",
    url: url_ListTopicRuleDestinations_603372,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateTopicRuleDestination_603399 = ref object of OpenApiRestCall_601389
proc url_UpdateTopicRuleDestination_603401(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateTopicRuleDestination_603400(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a topic rule destination. You use this to change the status, endpoint URL, or confirmation URL of the destination.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603402 = header.getOrDefault("X-Amz-Signature")
  valid_603402 = validateParameter(valid_603402, JString, required = false,
                                 default = nil)
  if valid_603402 != nil:
    section.add "X-Amz-Signature", valid_603402
  var valid_603403 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603403 = validateParameter(valid_603403, JString, required = false,
                                 default = nil)
  if valid_603403 != nil:
    section.add "X-Amz-Content-Sha256", valid_603403
  var valid_603404 = header.getOrDefault("X-Amz-Date")
  valid_603404 = validateParameter(valid_603404, JString, required = false,
                                 default = nil)
  if valid_603404 != nil:
    section.add "X-Amz-Date", valid_603404
  var valid_603405 = header.getOrDefault("X-Amz-Credential")
  valid_603405 = validateParameter(valid_603405, JString, required = false,
                                 default = nil)
  if valid_603405 != nil:
    section.add "X-Amz-Credential", valid_603405
  var valid_603406 = header.getOrDefault("X-Amz-Security-Token")
  valid_603406 = validateParameter(valid_603406, JString, required = false,
                                 default = nil)
  if valid_603406 != nil:
    section.add "X-Amz-Security-Token", valid_603406
  var valid_603407 = header.getOrDefault("X-Amz-Algorithm")
  valid_603407 = validateParameter(valid_603407, JString, required = false,
                                 default = nil)
  if valid_603407 != nil:
    section.add "X-Amz-Algorithm", valid_603407
  var valid_603408 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603408 = validateParameter(valid_603408, JString, required = false,
                                 default = nil)
  if valid_603408 != nil:
    section.add "X-Amz-SignedHeaders", valid_603408
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603410: Call_UpdateTopicRuleDestination_603399; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a topic rule destination. You use this to change the status, endpoint URL, or confirmation URL of the destination.
  ## 
  let valid = call_603410.validator(path, query, header, formData, body)
  let scheme = call_603410.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603410.url(scheme.get, call_603410.host, call_603410.base,
                         call_603410.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603410, url, valid)

proc call*(call_603411: Call_UpdateTopicRuleDestination_603399; body: JsonNode): Recallable =
  ## updateTopicRuleDestination
  ## Updates a topic rule destination. You use this to change the status, endpoint URL, or confirmation URL of the destination.
  ##   body: JObject (required)
  var body_603412 = newJObject()
  if body != nil:
    body_603412 = body
  result = call_603411.call(nil, nil, nil, nil, body_603412)

var updateTopicRuleDestination* = Call_UpdateTopicRuleDestination_603399(
    name: "updateTopicRuleDestination", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/destinations",
    validator: validate_UpdateTopicRuleDestination_603400, base: "/",
    url: url_UpdateTopicRuleDestination_603401,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAccountAuditConfiguration_603413 = ref object of OpenApiRestCall_601389
proc url_DescribeAccountAuditConfiguration_603415(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeAccountAuditConfiguration_603414(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603416 = header.getOrDefault("X-Amz-Signature")
  valid_603416 = validateParameter(valid_603416, JString, required = false,
                                 default = nil)
  if valid_603416 != nil:
    section.add "X-Amz-Signature", valid_603416
  var valid_603417 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603417 = validateParameter(valid_603417, JString, required = false,
                                 default = nil)
  if valid_603417 != nil:
    section.add "X-Amz-Content-Sha256", valid_603417
  var valid_603418 = header.getOrDefault("X-Amz-Date")
  valid_603418 = validateParameter(valid_603418, JString, required = false,
                                 default = nil)
  if valid_603418 != nil:
    section.add "X-Amz-Date", valid_603418
  var valid_603419 = header.getOrDefault("X-Amz-Credential")
  valid_603419 = validateParameter(valid_603419, JString, required = false,
                                 default = nil)
  if valid_603419 != nil:
    section.add "X-Amz-Credential", valid_603419
  var valid_603420 = header.getOrDefault("X-Amz-Security-Token")
  valid_603420 = validateParameter(valid_603420, JString, required = false,
                                 default = nil)
  if valid_603420 != nil:
    section.add "X-Amz-Security-Token", valid_603420
  var valid_603421 = header.getOrDefault("X-Amz-Algorithm")
  valid_603421 = validateParameter(valid_603421, JString, required = false,
                                 default = nil)
  if valid_603421 != nil:
    section.add "X-Amz-Algorithm", valid_603421
  var valid_603422 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603422 = validateParameter(valid_603422, JString, required = false,
                                 default = nil)
  if valid_603422 != nil:
    section.add "X-Amz-SignedHeaders", valid_603422
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603423: Call_DescribeAccountAuditConfiguration_603413;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  let valid = call_603423.validator(path, query, header, formData, body)
  let scheme = call_603423.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603423.url(scheme.get, call_603423.host, call_603423.base,
                         call_603423.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603423, url, valid)

proc call*(call_603424: Call_DescribeAccountAuditConfiguration_603413): Recallable =
  ## describeAccountAuditConfiguration
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  result = call_603424.call(nil, nil, nil, nil, nil)

var describeAccountAuditConfiguration* = Call_DescribeAccountAuditConfiguration_603413(
    name: "describeAccountAuditConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_DescribeAccountAuditConfiguration_603414, base: "/",
    url: url_DescribeAccountAuditConfiguration_603415,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateAccountAuditConfiguration_603439 = ref object of OpenApiRestCall_601389
proc url_UpdateAccountAuditConfiguration_603441(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateAccountAuditConfiguration_603440(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603442 = header.getOrDefault("X-Amz-Signature")
  valid_603442 = validateParameter(valid_603442, JString, required = false,
                                 default = nil)
  if valid_603442 != nil:
    section.add "X-Amz-Signature", valid_603442
  var valid_603443 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603443 = validateParameter(valid_603443, JString, required = false,
                                 default = nil)
  if valid_603443 != nil:
    section.add "X-Amz-Content-Sha256", valid_603443
  var valid_603444 = header.getOrDefault("X-Amz-Date")
  valid_603444 = validateParameter(valid_603444, JString, required = false,
                                 default = nil)
  if valid_603444 != nil:
    section.add "X-Amz-Date", valid_603444
  var valid_603445 = header.getOrDefault("X-Amz-Credential")
  valid_603445 = validateParameter(valid_603445, JString, required = false,
                                 default = nil)
  if valid_603445 != nil:
    section.add "X-Amz-Credential", valid_603445
  var valid_603446 = header.getOrDefault("X-Amz-Security-Token")
  valid_603446 = validateParameter(valid_603446, JString, required = false,
                                 default = nil)
  if valid_603446 != nil:
    section.add "X-Amz-Security-Token", valid_603446
  var valid_603447 = header.getOrDefault("X-Amz-Algorithm")
  valid_603447 = validateParameter(valid_603447, JString, required = false,
                                 default = nil)
  if valid_603447 != nil:
    section.add "X-Amz-Algorithm", valid_603447
  var valid_603448 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603448 = validateParameter(valid_603448, JString, required = false,
                                 default = nil)
  if valid_603448 != nil:
    section.add "X-Amz-SignedHeaders", valid_603448
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603450: Call_UpdateAccountAuditConfiguration_603439;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  let valid = call_603450.validator(path, query, header, formData, body)
  let scheme = call_603450.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603450.url(scheme.get, call_603450.host, call_603450.base,
                         call_603450.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603450, url, valid)

proc call*(call_603451: Call_UpdateAccountAuditConfiguration_603439; body: JsonNode): Recallable =
  ## updateAccountAuditConfiguration
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ##   body: JObject (required)
  var body_603452 = newJObject()
  if body != nil:
    body_603452 = body
  result = call_603451.call(nil, nil, nil, nil, body_603452)

var updateAccountAuditConfiguration* = Call_UpdateAccountAuditConfiguration_603439(
    name: "updateAccountAuditConfiguration", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_UpdateAccountAuditConfiguration_603440, base: "/",
    url: url_UpdateAccountAuditConfiguration_603441,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteAccountAuditConfiguration_603425 = ref object of OpenApiRestCall_601389
proc url_DeleteAccountAuditConfiguration_603427(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteAccountAuditConfiguration_603426(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   deleteScheduledAudits: JBool
  ##                        : If true, all scheduled audits are deleted.
  section = newJObject()
  var valid_603428 = query.getOrDefault("deleteScheduledAudits")
  valid_603428 = validateParameter(valid_603428, JBool, required = false, default = nil)
  if valid_603428 != nil:
    section.add "deleteScheduledAudits", valid_603428
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603429 = header.getOrDefault("X-Amz-Signature")
  valid_603429 = validateParameter(valid_603429, JString, required = false,
                                 default = nil)
  if valid_603429 != nil:
    section.add "X-Amz-Signature", valid_603429
  var valid_603430 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603430 = validateParameter(valid_603430, JString, required = false,
                                 default = nil)
  if valid_603430 != nil:
    section.add "X-Amz-Content-Sha256", valid_603430
  var valid_603431 = header.getOrDefault("X-Amz-Date")
  valid_603431 = validateParameter(valid_603431, JString, required = false,
                                 default = nil)
  if valid_603431 != nil:
    section.add "X-Amz-Date", valid_603431
  var valid_603432 = header.getOrDefault("X-Amz-Credential")
  valid_603432 = validateParameter(valid_603432, JString, required = false,
                                 default = nil)
  if valid_603432 != nil:
    section.add "X-Amz-Credential", valid_603432
  var valid_603433 = header.getOrDefault("X-Amz-Security-Token")
  valid_603433 = validateParameter(valid_603433, JString, required = false,
                                 default = nil)
  if valid_603433 != nil:
    section.add "X-Amz-Security-Token", valid_603433
  var valid_603434 = header.getOrDefault("X-Amz-Algorithm")
  valid_603434 = validateParameter(valid_603434, JString, required = false,
                                 default = nil)
  if valid_603434 != nil:
    section.add "X-Amz-Algorithm", valid_603434
  var valid_603435 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603435 = validateParameter(valid_603435, JString, required = false,
                                 default = nil)
  if valid_603435 != nil:
    section.add "X-Amz-SignedHeaders", valid_603435
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603436: Call_DeleteAccountAuditConfiguration_603425;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ## 
  let valid = call_603436.validator(path, query, header, formData, body)
  let scheme = call_603436.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603436.url(scheme.get, call_603436.host, call_603436.base,
                         call_603436.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603436, url, valid)

proc call*(call_603437: Call_DeleteAccountAuditConfiguration_603425;
          deleteScheduledAudits: bool = false): Recallable =
  ## deleteAccountAuditConfiguration
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ##   deleteScheduledAudits: bool
  ##                        : If true, all scheduled audits are deleted.
  var query_603438 = newJObject()
  add(query_603438, "deleteScheduledAudits", newJBool(deleteScheduledAudits))
  result = call_603437.call(nil, query_603438, nil, nil, nil)

var deleteAccountAuditConfiguration* = Call_DeleteAccountAuditConfiguration_603425(
    name: "deleteAccountAuditConfiguration", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_DeleteAccountAuditConfiguration_603426, base: "/",
    url: url_DeleteAccountAuditConfiguration_603427,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateCACertificate_603467 = ref object of OpenApiRestCall_601389
proc url_UpdateCACertificate_603469(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateCACertificate_603468(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Updates a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The CA certificate identifier.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_603470 = path.getOrDefault("caCertificateId")
  valid_603470 = validateParameter(valid_603470, JString, required = true,
                                 default = nil)
  if valid_603470 != nil:
    section.add "caCertificateId", valid_603470
  result.add "path", section
  ## parameters in `query` object:
  ##   newAutoRegistrationStatus: JString
  ##                            : The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
  ##   newStatus: JString
  ##            : <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  section = newJObject()
  var valid_603484 = query.getOrDefault("newAutoRegistrationStatus")
  valid_603484 = validateParameter(valid_603484, JString, required = false,
                                 default = newJString("ENABLE"))
  if valid_603484 != nil:
    section.add "newAutoRegistrationStatus", valid_603484
  var valid_603485 = query.getOrDefault("newStatus")
  valid_603485 = validateParameter(valid_603485, JString, required = false,
                                 default = newJString("ACTIVE"))
  if valid_603485 != nil:
    section.add "newStatus", valid_603485
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603486 = header.getOrDefault("X-Amz-Signature")
  valid_603486 = validateParameter(valid_603486, JString, required = false,
                                 default = nil)
  if valid_603486 != nil:
    section.add "X-Amz-Signature", valid_603486
  var valid_603487 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603487 = validateParameter(valid_603487, JString, required = false,
                                 default = nil)
  if valid_603487 != nil:
    section.add "X-Amz-Content-Sha256", valid_603487
  var valid_603488 = header.getOrDefault("X-Amz-Date")
  valid_603488 = validateParameter(valid_603488, JString, required = false,
                                 default = nil)
  if valid_603488 != nil:
    section.add "X-Amz-Date", valid_603488
  var valid_603489 = header.getOrDefault("X-Amz-Credential")
  valid_603489 = validateParameter(valid_603489, JString, required = false,
                                 default = nil)
  if valid_603489 != nil:
    section.add "X-Amz-Credential", valid_603489
  var valid_603490 = header.getOrDefault("X-Amz-Security-Token")
  valid_603490 = validateParameter(valid_603490, JString, required = false,
                                 default = nil)
  if valid_603490 != nil:
    section.add "X-Amz-Security-Token", valid_603490
  var valid_603491 = header.getOrDefault("X-Amz-Algorithm")
  valid_603491 = validateParameter(valid_603491, JString, required = false,
                                 default = nil)
  if valid_603491 != nil:
    section.add "X-Amz-Algorithm", valid_603491
  var valid_603492 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603492 = validateParameter(valid_603492, JString, required = false,
                                 default = nil)
  if valid_603492 != nil:
    section.add "X-Amz-SignedHeaders", valid_603492
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603494: Call_UpdateCACertificate_603467; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a registered CA certificate.
  ## 
  let valid = call_603494.validator(path, query, header, formData, body)
  let scheme = call_603494.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603494.url(scheme.get, call_603494.host, call_603494.base,
                         call_603494.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603494, url, valid)

proc call*(call_603495: Call_UpdateCACertificate_603467; caCertificateId: string;
          body: JsonNode; newAutoRegistrationStatus: string = "ENABLE";
          newStatus: string = "ACTIVE"): Recallable =
  ## updateCACertificate
  ## Updates a registered CA certificate.
  ##   newAutoRegistrationStatus: string
  ##                            : The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
  ##   caCertificateId: string (required)
  ##                  : The CA certificate identifier.
  ##   newStatus: string
  ##            : <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  ##   body: JObject (required)
  var path_603496 = newJObject()
  var query_603497 = newJObject()
  var body_603498 = newJObject()
  add(query_603497, "newAutoRegistrationStatus",
      newJString(newAutoRegistrationStatus))
  add(path_603496, "caCertificateId", newJString(caCertificateId))
  add(query_603497, "newStatus", newJString(newStatus))
  if body != nil:
    body_603498 = body
  result = call_603495.call(path_603496, query_603497, nil, nil, body_603498)

var updateCACertificate* = Call_UpdateCACertificate_603467(
    name: "updateCACertificate", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_UpdateCACertificate_603468, base: "/",
    url: url_UpdateCACertificate_603469, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeCACertificate_603453 = ref object of OpenApiRestCall_601389
proc url_DescribeCACertificate_603455(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeCACertificate_603454(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The CA certificate identifier.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_603456 = path.getOrDefault("caCertificateId")
  valid_603456 = validateParameter(valid_603456, JString, required = true,
                                 default = nil)
  if valid_603456 != nil:
    section.add "caCertificateId", valid_603456
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603457 = header.getOrDefault("X-Amz-Signature")
  valid_603457 = validateParameter(valid_603457, JString, required = false,
                                 default = nil)
  if valid_603457 != nil:
    section.add "X-Amz-Signature", valid_603457
  var valid_603458 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603458 = validateParameter(valid_603458, JString, required = false,
                                 default = nil)
  if valid_603458 != nil:
    section.add "X-Amz-Content-Sha256", valid_603458
  var valid_603459 = header.getOrDefault("X-Amz-Date")
  valid_603459 = validateParameter(valid_603459, JString, required = false,
                                 default = nil)
  if valid_603459 != nil:
    section.add "X-Amz-Date", valid_603459
  var valid_603460 = header.getOrDefault("X-Amz-Credential")
  valid_603460 = validateParameter(valid_603460, JString, required = false,
                                 default = nil)
  if valid_603460 != nil:
    section.add "X-Amz-Credential", valid_603460
  var valid_603461 = header.getOrDefault("X-Amz-Security-Token")
  valid_603461 = validateParameter(valid_603461, JString, required = false,
                                 default = nil)
  if valid_603461 != nil:
    section.add "X-Amz-Security-Token", valid_603461
  var valid_603462 = header.getOrDefault("X-Amz-Algorithm")
  valid_603462 = validateParameter(valid_603462, JString, required = false,
                                 default = nil)
  if valid_603462 != nil:
    section.add "X-Amz-Algorithm", valid_603462
  var valid_603463 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603463 = validateParameter(valid_603463, JString, required = false,
                                 default = nil)
  if valid_603463 != nil:
    section.add "X-Amz-SignedHeaders", valid_603463
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603464: Call_DescribeCACertificate_603453; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a registered CA certificate.
  ## 
  let valid = call_603464.validator(path, query, header, formData, body)
  let scheme = call_603464.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603464.url(scheme.get, call_603464.host, call_603464.base,
                         call_603464.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603464, url, valid)

proc call*(call_603465: Call_DescribeCACertificate_603453; caCertificateId: string): Recallable =
  ## describeCACertificate
  ## Describes a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The CA certificate identifier.
  var path_603466 = newJObject()
  add(path_603466, "caCertificateId", newJString(caCertificateId))
  result = call_603465.call(path_603466, nil, nil, nil, nil)

var describeCACertificate* = Call_DescribeCACertificate_603453(
    name: "describeCACertificate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_DescribeCACertificate_603454, base: "/",
    url: url_DescribeCACertificate_603455, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteCACertificate_603499 = ref object of OpenApiRestCall_601389
proc url_DeleteCACertificate_603501(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteCACertificate_603500(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Deletes a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_603502 = path.getOrDefault("caCertificateId")
  valid_603502 = validateParameter(valid_603502, JString, required = true,
                                 default = nil)
  if valid_603502 != nil:
    section.add "caCertificateId", valid_603502
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603503 = header.getOrDefault("X-Amz-Signature")
  valid_603503 = validateParameter(valid_603503, JString, required = false,
                                 default = nil)
  if valid_603503 != nil:
    section.add "X-Amz-Signature", valid_603503
  var valid_603504 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603504 = validateParameter(valid_603504, JString, required = false,
                                 default = nil)
  if valid_603504 != nil:
    section.add "X-Amz-Content-Sha256", valid_603504
  var valid_603505 = header.getOrDefault("X-Amz-Date")
  valid_603505 = validateParameter(valid_603505, JString, required = false,
                                 default = nil)
  if valid_603505 != nil:
    section.add "X-Amz-Date", valid_603505
  var valid_603506 = header.getOrDefault("X-Amz-Credential")
  valid_603506 = validateParameter(valid_603506, JString, required = false,
                                 default = nil)
  if valid_603506 != nil:
    section.add "X-Amz-Credential", valid_603506
  var valid_603507 = header.getOrDefault("X-Amz-Security-Token")
  valid_603507 = validateParameter(valid_603507, JString, required = false,
                                 default = nil)
  if valid_603507 != nil:
    section.add "X-Amz-Security-Token", valid_603507
  var valid_603508 = header.getOrDefault("X-Amz-Algorithm")
  valid_603508 = validateParameter(valid_603508, JString, required = false,
                                 default = nil)
  if valid_603508 != nil:
    section.add "X-Amz-Algorithm", valid_603508
  var valid_603509 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603509 = validateParameter(valid_603509, JString, required = false,
                                 default = nil)
  if valid_603509 != nil:
    section.add "X-Amz-SignedHeaders", valid_603509
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603510: Call_DeleteCACertificate_603499; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a registered CA certificate.
  ## 
  let valid = call_603510.validator(path, query, header, formData, body)
  let scheme = call_603510.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603510.url(scheme.get, call_603510.host, call_603510.base,
                         call_603510.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603510, url, valid)

proc call*(call_603511: Call_DeleteCACertificate_603499; caCertificateId: string): Recallable =
  ## deleteCACertificate
  ## Deletes a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
  var path_603512 = newJObject()
  add(path_603512, "caCertificateId", newJString(caCertificateId))
  result = call_603511.call(path_603512, nil, nil, nil, nil)

var deleteCACertificate* = Call_DeleteCACertificate_603499(
    name: "deleteCACertificate", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_DeleteCACertificate_603500, base: "/",
    url: url_DeleteCACertificate_603501, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeCertificate_603513 = ref object of OpenApiRestCall_601389
proc url_DescribeCertificate_603515(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeCertificate_603514(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets information about the specified certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_603516 = path.getOrDefault("certificateId")
  valid_603516 = validateParameter(valid_603516, JString, required = true,
                                 default = nil)
  if valid_603516 != nil:
    section.add "certificateId", valid_603516
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603517 = header.getOrDefault("X-Amz-Signature")
  valid_603517 = validateParameter(valid_603517, JString, required = false,
                                 default = nil)
  if valid_603517 != nil:
    section.add "X-Amz-Signature", valid_603517
  var valid_603518 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603518 = validateParameter(valid_603518, JString, required = false,
                                 default = nil)
  if valid_603518 != nil:
    section.add "X-Amz-Content-Sha256", valid_603518
  var valid_603519 = header.getOrDefault("X-Amz-Date")
  valid_603519 = validateParameter(valid_603519, JString, required = false,
                                 default = nil)
  if valid_603519 != nil:
    section.add "X-Amz-Date", valid_603519
  var valid_603520 = header.getOrDefault("X-Amz-Credential")
  valid_603520 = validateParameter(valid_603520, JString, required = false,
                                 default = nil)
  if valid_603520 != nil:
    section.add "X-Amz-Credential", valid_603520
  var valid_603521 = header.getOrDefault("X-Amz-Security-Token")
  valid_603521 = validateParameter(valid_603521, JString, required = false,
                                 default = nil)
  if valid_603521 != nil:
    section.add "X-Amz-Security-Token", valid_603521
  var valid_603522 = header.getOrDefault("X-Amz-Algorithm")
  valid_603522 = validateParameter(valid_603522, JString, required = false,
                                 default = nil)
  if valid_603522 != nil:
    section.add "X-Amz-Algorithm", valid_603522
  var valid_603523 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603523 = validateParameter(valid_603523, JString, required = false,
                                 default = nil)
  if valid_603523 != nil:
    section.add "X-Amz-SignedHeaders", valid_603523
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603524: Call_DescribeCertificate_603513; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified certificate.
  ## 
  let valid = call_603524.validator(path, query, header, formData, body)
  let scheme = call_603524.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603524.url(scheme.get, call_603524.host, call_603524.base,
                         call_603524.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603524, url, valid)

proc call*(call_603525: Call_DescribeCertificate_603513; certificateId: string): Recallable =
  ## describeCertificate
  ## Gets information about the specified certificate.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_603526 = newJObject()
  add(path_603526, "certificateId", newJString(certificateId))
  result = call_603525.call(path_603526, nil, nil, nil, nil)

var describeCertificate* = Call_DescribeCertificate_603513(
    name: "describeCertificate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates/{certificateId}",
    validator: validate_DescribeCertificate_603514, base: "/",
    url: url_DescribeCertificate_603515, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteCertificate_603527 = ref object of OpenApiRestCall_601389
proc url_DeleteCertificate_603529(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteCertificate_603528(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_603530 = path.getOrDefault("certificateId")
  valid_603530 = validateParameter(valid_603530, JString, required = true,
                                 default = nil)
  if valid_603530 != nil:
    section.add "certificateId", valid_603530
  result.add "path", section
  ## parameters in `query` object:
  ##   forceDelete: JBool
  ##              : Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
  section = newJObject()
  var valid_603531 = query.getOrDefault("forceDelete")
  valid_603531 = validateParameter(valid_603531, JBool, required = false, default = nil)
  if valid_603531 != nil:
    section.add "forceDelete", valid_603531
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603532 = header.getOrDefault("X-Amz-Signature")
  valid_603532 = validateParameter(valid_603532, JString, required = false,
                                 default = nil)
  if valid_603532 != nil:
    section.add "X-Amz-Signature", valid_603532
  var valid_603533 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603533 = validateParameter(valid_603533, JString, required = false,
                                 default = nil)
  if valid_603533 != nil:
    section.add "X-Amz-Content-Sha256", valid_603533
  var valid_603534 = header.getOrDefault("X-Amz-Date")
  valid_603534 = validateParameter(valid_603534, JString, required = false,
                                 default = nil)
  if valid_603534 != nil:
    section.add "X-Amz-Date", valid_603534
  var valid_603535 = header.getOrDefault("X-Amz-Credential")
  valid_603535 = validateParameter(valid_603535, JString, required = false,
                                 default = nil)
  if valid_603535 != nil:
    section.add "X-Amz-Credential", valid_603535
  var valid_603536 = header.getOrDefault("X-Amz-Security-Token")
  valid_603536 = validateParameter(valid_603536, JString, required = false,
                                 default = nil)
  if valid_603536 != nil:
    section.add "X-Amz-Security-Token", valid_603536
  var valid_603537 = header.getOrDefault("X-Amz-Algorithm")
  valid_603537 = validateParameter(valid_603537, JString, required = false,
                                 default = nil)
  if valid_603537 != nil:
    section.add "X-Amz-Algorithm", valid_603537
  var valid_603538 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603538 = validateParameter(valid_603538, JString, required = false,
                                 default = nil)
  if valid_603538 != nil:
    section.add "X-Amz-SignedHeaders", valid_603538
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603539: Call_DeleteCertificate_603527; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ## 
  let valid = call_603539.validator(path, query, header, formData, body)
  let scheme = call_603539.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603539.url(scheme.get, call_603539.host, call_603539.base,
                         call_603539.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603539, url, valid)

proc call*(call_603540: Call_DeleteCertificate_603527; certificateId: string;
          forceDelete: bool = false): Recallable =
  ## deleteCertificate
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ##   forceDelete: bool
  ##              : Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_603541 = newJObject()
  var query_603542 = newJObject()
  add(query_603542, "forceDelete", newJBool(forceDelete))
  add(path_603541, "certificateId", newJString(certificateId))
  result = call_603540.call(path_603541, query_603542, nil, nil, nil)

var deleteCertificate* = Call_DeleteCertificate_603527(name: "deleteCertificate",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/certificates/{certificateId}", validator: validate_DeleteCertificate_603528,
    base: "/", url: url_DeleteCertificate_603529,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteJobExecution_603543 = ref object of OpenApiRestCall_601389
proc url_DeleteJobExecution_603545(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  assert "executionNumber" in path, "`executionNumber` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/executionNumber/"),
               (kind: VariableSegment, value: "executionNumber")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteJobExecution_603544(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deletes a job execution.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   executionNumber: JInt (required)
  ##                  : <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
  ##   jobId: JString (required)
  ##        : The ID of the job whose execution on a particular device will be deleted.
  ##   thingName: JString (required)
  ##            : The name of the thing whose job execution will be deleted.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `executionNumber` field"
  var valid_603546 = path.getOrDefault("executionNumber")
  valid_603546 = validateParameter(valid_603546, JInt, required = true, default = nil)
  if valid_603546 != nil:
    section.add "executionNumber", valid_603546
  var valid_603547 = path.getOrDefault("jobId")
  valid_603547 = validateParameter(valid_603547, JString, required = true,
                                 default = nil)
  if valid_603547 != nil:
    section.add "jobId", valid_603547
  var valid_603548 = path.getOrDefault("thingName")
  valid_603548 = validateParameter(valid_603548, JString, required = true,
                                 default = nil)
  if valid_603548 != nil:
    section.add "thingName", valid_603548
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
  section = newJObject()
  var valid_603549 = query.getOrDefault("force")
  valid_603549 = validateParameter(valid_603549, JBool, required = false, default = nil)
  if valid_603549 != nil:
    section.add "force", valid_603549
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603550 = header.getOrDefault("X-Amz-Signature")
  valid_603550 = validateParameter(valid_603550, JString, required = false,
                                 default = nil)
  if valid_603550 != nil:
    section.add "X-Amz-Signature", valid_603550
  var valid_603551 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603551 = validateParameter(valid_603551, JString, required = false,
                                 default = nil)
  if valid_603551 != nil:
    section.add "X-Amz-Content-Sha256", valid_603551
  var valid_603552 = header.getOrDefault("X-Amz-Date")
  valid_603552 = validateParameter(valid_603552, JString, required = false,
                                 default = nil)
  if valid_603552 != nil:
    section.add "X-Amz-Date", valid_603552
  var valid_603553 = header.getOrDefault("X-Amz-Credential")
  valid_603553 = validateParameter(valid_603553, JString, required = false,
                                 default = nil)
  if valid_603553 != nil:
    section.add "X-Amz-Credential", valid_603553
  var valid_603554 = header.getOrDefault("X-Amz-Security-Token")
  valid_603554 = validateParameter(valid_603554, JString, required = false,
                                 default = nil)
  if valid_603554 != nil:
    section.add "X-Amz-Security-Token", valid_603554
  var valid_603555 = header.getOrDefault("X-Amz-Algorithm")
  valid_603555 = validateParameter(valid_603555, JString, required = false,
                                 default = nil)
  if valid_603555 != nil:
    section.add "X-Amz-Algorithm", valid_603555
  var valid_603556 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603556 = validateParameter(valid_603556, JString, required = false,
                                 default = nil)
  if valid_603556 != nil:
    section.add "X-Amz-SignedHeaders", valid_603556
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603557: Call_DeleteJobExecution_603543; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a job execution.
  ## 
  let valid = call_603557.validator(path, query, header, formData, body)
  let scheme = call_603557.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603557.url(scheme.get, call_603557.host, call_603557.base,
                         call_603557.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603557, url, valid)

proc call*(call_603558: Call_DeleteJobExecution_603543; executionNumber: int;
          jobId: string; thingName: string; force: bool = false): Recallable =
  ## deleteJobExecution
  ## Deletes a job execution.
  ##   executionNumber: int (required)
  ##                  : <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
  ##   jobId: string (required)
  ##        : The ID of the job whose execution on a particular device will be deleted.
  ##   thingName: string (required)
  ##            : The name of the thing whose job execution will be deleted.
  ##   force: bool
  ##        : <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
  var path_603559 = newJObject()
  var query_603560 = newJObject()
  add(path_603559, "executionNumber", newJInt(executionNumber))
  add(path_603559, "jobId", newJString(jobId))
  add(path_603559, "thingName", newJString(thingName))
  add(query_603560, "force", newJBool(force))
  result = call_603558.call(path_603559, query_603560, nil, nil, nil)

var deleteJobExecution* = Call_DeleteJobExecution_603543(
    name: "deleteJobExecution", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}",
    validator: validate_DeleteJobExecution_603544, base: "/",
    url: url_DeleteJobExecution_603545, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPolicyVersion_603561 = ref object of OpenApiRestCall_601389
proc url_GetPolicyVersion_603563(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetPolicyVersion_603562(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets information about the specified policy version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_603564 = path.getOrDefault("policyName")
  valid_603564 = validateParameter(valid_603564, JString, required = true,
                                 default = nil)
  if valid_603564 != nil:
    section.add "policyName", valid_603564
  var valid_603565 = path.getOrDefault("policyVersionId")
  valid_603565 = validateParameter(valid_603565, JString, required = true,
                                 default = nil)
  if valid_603565 != nil:
    section.add "policyVersionId", valid_603565
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603566 = header.getOrDefault("X-Amz-Signature")
  valid_603566 = validateParameter(valid_603566, JString, required = false,
                                 default = nil)
  if valid_603566 != nil:
    section.add "X-Amz-Signature", valid_603566
  var valid_603567 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603567 = validateParameter(valid_603567, JString, required = false,
                                 default = nil)
  if valid_603567 != nil:
    section.add "X-Amz-Content-Sha256", valid_603567
  var valid_603568 = header.getOrDefault("X-Amz-Date")
  valid_603568 = validateParameter(valid_603568, JString, required = false,
                                 default = nil)
  if valid_603568 != nil:
    section.add "X-Amz-Date", valid_603568
  var valid_603569 = header.getOrDefault("X-Amz-Credential")
  valid_603569 = validateParameter(valid_603569, JString, required = false,
                                 default = nil)
  if valid_603569 != nil:
    section.add "X-Amz-Credential", valid_603569
  var valid_603570 = header.getOrDefault("X-Amz-Security-Token")
  valid_603570 = validateParameter(valid_603570, JString, required = false,
                                 default = nil)
  if valid_603570 != nil:
    section.add "X-Amz-Security-Token", valid_603570
  var valid_603571 = header.getOrDefault("X-Amz-Algorithm")
  valid_603571 = validateParameter(valid_603571, JString, required = false,
                                 default = nil)
  if valid_603571 != nil:
    section.add "X-Amz-Algorithm", valid_603571
  var valid_603572 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603572 = validateParameter(valid_603572, JString, required = false,
                                 default = nil)
  if valid_603572 != nil:
    section.add "X-Amz-SignedHeaders", valid_603572
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603573: Call_GetPolicyVersion_603561; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified policy version.
  ## 
  let valid = call_603573.validator(path, query, header, formData, body)
  let scheme = call_603573.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603573.url(scheme.get, call_603573.host, call_603573.base,
                         call_603573.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603573, url, valid)

proc call*(call_603574: Call_GetPolicyVersion_603561; policyName: string;
          policyVersionId: string): Recallable =
  ## getPolicyVersion
  ## Gets information about the specified policy version.
  ##   policyName: string (required)
  ##             : The name of the policy.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_603575 = newJObject()
  add(path_603575, "policyName", newJString(policyName))
  add(path_603575, "policyVersionId", newJString(policyVersionId))
  result = call_603574.call(path_603575, nil, nil, nil, nil)

var getPolicyVersion* = Call_GetPolicyVersion_603561(name: "getPolicyVersion",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_GetPolicyVersion_603562, base: "/",
    url: url_GetPolicyVersion_603563, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetDefaultPolicyVersion_603591 = ref object of OpenApiRestCall_601389
proc url_SetDefaultPolicyVersion_603593(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_SetDefaultPolicyVersion_603592(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_603594 = path.getOrDefault("policyName")
  valid_603594 = validateParameter(valid_603594, JString, required = true,
                                 default = nil)
  if valid_603594 != nil:
    section.add "policyName", valid_603594
  var valid_603595 = path.getOrDefault("policyVersionId")
  valid_603595 = validateParameter(valid_603595, JString, required = true,
                                 default = nil)
  if valid_603595 != nil:
    section.add "policyVersionId", valid_603595
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603596 = header.getOrDefault("X-Amz-Signature")
  valid_603596 = validateParameter(valid_603596, JString, required = false,
                                 default = nil)
  if valid_603596 != nil:
    section.add "X-Amz-Signature", valid_603596
  var valid_603597 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603597 = validateParameter(valid_603597, JString, required = false,
                                 default = nil)
  if valid_603597 != nil:
    section.add "X-Amz-Content-Sha256", valid_603597
  var valid_603598 = header.getOrDefault("X-Amz-Date")
  valid_603598 = validateParameter(valid_603598, JString, required = false,
                                 default = nil)
  if valid_603598 != nil:
    section.add "X-Amz-Date", valid_603598
  var valid_603599 = header.getOrDefault("X-Amz-Credential")
  valid_603599 = validateParameter(valid_603599, JString, required = false,
                                 default = nil)
  if valid_603599 != nil:
    section.add "X-Amz-Credential", valid_603599
  var valid_603600 = header.getOrDefault("X-Amz-Security-Token")
  valid_603600 = validateParameter(valid_603600, JString, required = false,
                                 default = nil)
  if valid_603600 != nil:
    section.add "X-Amz-Security-Token", valid_603600
  var valid_603601 = header.getOrDefault("X-Amz-Algorithm")
  valid_603601 = validateParameter(valid_603601, JString, required = false,
                                 default = nil)
  if valid_603601 != nil:
    section.add "X-Amz-Algorithm", valid_603601
  var valid_603602 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603602 = validateParameter(valid_603602, JString, required = false,
                                 default = nil)
  if valid_603602 != nil:
    section.add "X-Amz-SignedHeaders", valid_603602
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603603: Call_SetDefaultPolicyVersion_603591; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ## 
  let valid = call_603603.validator(path, query, header, formData, body)
  let scheme = call_603603.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603603.url(scheme.get, call_603603.host, call_603603.base,
                         call_603603.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603603, url, valid)

proc call*(call_603604: Call_SetDefaultPolicyVersion_603591; policyName: string;
          policyVersionId: string): Recallable =
  ## setDefaultPolicyVersion
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ##   policyName: string (required)
  ##             : The policy name.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_603605 = newJObject()
  add(path_603605, "policyName", newJString(policyName))
  add(path_603605, "policyVersionId", newJString(policyVersionId))
  result = call_603604.call(path_603605, nil, nil, nil, nil)

var setDefaultPolicyVersion* = Call_SetDefaultPolicyVersion_603591(
    name: "setDefaultPolicyVersion", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_SetDefaultPolicyVersion_603592, base: "/",
    url: url_SetDefaultPolicyVersion_603593, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeletePolicyVersion_603576 = ref object of OpenApiRestCall_601389
proc url_DeletePolicyVersion_603578(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeletePolicyVersion_603577(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_603579 = path.getOrDefault("policyName")
  valid_603579 = validateParameter(valid_603579, JString, required = true,
                                 default = nil)
  if valid_603579 != nil:
    section.add "policyName", valid_603579
  var valid_603580 = path.getOrDefault("policyVersionId")
  valid_603580 = validateParameter(valid_603580, JString, required = true,
                                 default = nil)
  if valid_603580 != nil:
    section.add "policyVersionId", valid_603580
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603581 = header.getOrDefault("X-Amz-Signature")
  valid_603581 = validateParameter(valid_603581, JString, required = false,
                                 default = nil)
  if valid_603581 != nil:
    section.add "X-Amz-Signature", valid_603581
  var valid_603582 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603582 = validateParameter(valid_603582, JString, required = false,
                                 default = nil)
  if valid_603582 != nil:
    section.add "X-Amz-Content-Sha256", valid_603582
  var valid_603583 = header.getOrDefault("X-Amz-Date")
  valid_603583 = validateParameter(valid_603583, JString, required = false,
                                 default = nil)
  if valid_603583 != nil:
    section.add "X-Amz-Date", valid_603583
  var valid_603584 = header.getOrDefault("X-Amz-Credential")
  valid_603584 = validateParameter(valid_603584, JString, required = false,
                                 default = nil)
  if valid_603584 != nil:
    section.add "X-Amz-Credential", valid_603584
  var valid_603585 = header.getOrDefault("X-Amz-Security-Token")
  valid_603585 = validateParameter(valid_603585, JString, required = false,
                                 default = nil)
  if valid_603585 != nil:
    section.add "X-Amz-Security-Token", valid_603585
  var valid_603586 = header.getOrDefault("X-Amz-Algorithm")
  valid_603586 = validateParameter(valid_603586, JString, required = false,
                                 default = nil)
  if valid_603586 != nil:
    section.add "X-Amz-Algorithm", valid_603586
  var valid_603587 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603587 = validateParameter(valid_603587, JString, required = false,
                                 default = nil)
  if valid_603587 != nil:
    section.add "X-Amz-SignedHeaders", valid_603587
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603588: Call_DeletePolicyVersion_603576; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ## 
  let valid = call_603588.validator(path, query, header, formData, body)
  let scheme = call_603588.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603588.url(scheme.get, call_603588.host, call_603588.base,
                         call_603588.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603588, url, valid)

proc call*(call_603589: Call_DeletePolicyVersion_603576; policyName: string;
          policyVersionId: string): Recallable =
  ## deletePolicyVersion
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ##   policyName: string (required)
  ##             : The name of the policy.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_603590 = newJObject()
  add(path_603590, "policyName", newJString(policyName))
  add(path_603590, "policyVersionId", newJString(policyVersionId))
  result = call_603589.call(path_603590, nil, nil, nil, nil)

var deletePolicyVersion* = Call_DeletePolicyVersion_603576(
    name: "deletePolicyVersion", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_DeletePolicyVersion_603577, base: "/",
    url: url_DeletePolicyVersion_603578, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeProvisioningTemplate_603606 = ref object of OpenApiRestCall_601389
proc url_DescribeProvisioningTemplate_603608(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeProvisioningTemplate_603607(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_603609 = path.getOrDefault("templateName")
  valid_603609 = validateParameter(valid_603609, JString, required = true,
                                 default = nil)
  if valid_603609 != nil:
    section.add "templateName", valid_603609
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603610 = header.getOrDefault("X-Amz-Signature")
  valid_603610 = validateParameter(valid_603610, JString, required = false,
                                 default = nil)
  if valid_603610 != nil:
    section.add "X-Amz-Signature", valid_603610
  var valid_603611 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603611 = validateParameter(valid_603611, JString, required = false,
                                 default = nil)
  if valid_603611 != nil:
    section.add "X-Amz-Content-Sha256", valid_603611
  var valid_603612 = header.getOrDefault("X-Amz-Date")
  valid_603612 = validateParameter(valid_603612, JString, required = false,
                                 default = nil)
  if valid_603612 != nil:
    section.add "X-Amz-Date", valid_603612
  var valid_603613 = header.getOrDefault("X-Amz-Credential")
  valid_603613 = validateParameter(valid_603613, JString, required = false,
                                 default = nil)
  if valid_603613 != nil:
    section.add "X-Amz-Credential", valid_603613
  var valid_603614 = header.getOrDefault("X-Amz-Security-Token")
  valid_603614 = validateParameter(valid_603614, JString, required = false,
                                 default = nil)
  if valid_603614 != nil:
    section.add "X-Amz-Security-Token", valid_603614
  var valid_603615 = header.getOrDefault("X-Amz-Algorithm")
  valid_603615 = validateParameter(valid_603615, JString, required = false,
                                 default = nil)
  if valid_603615 != nil:
    section.add "X-Amz-Algorithm", valid_603615
  var valid_603616 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603616 = validateParameter(valid_603616, JString, required = false,
                                 default = nil)
  if valid_603616 != nil:
    section.add "X-Amz-SignedHeaders", valid_603616
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603617: Call_DescribeProvisioningTemplate_603606; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about a fleet provisioning template.
  ## 
  let valid = call_603617.validator(path, query, header, formData, body)
  let scheme = call_603617.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603617.url(scheme.get, call_603617.host, call_603617.base,
                         call_603617.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603617, url, valid)

proc call*(call_603618: Call_DescribeProvisioningTemplate_603606;
          templateName: string): Recallable =
  ## describeProvisioningTemplate
  ## Returns information about a fleet provisioning template.
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template.
  var path_603619 = newJObject()
  add(path_603619, "templateName", newJString(templateName))
  result = call_603618.call(path_603619, nil, nil, nil, nil)

var describeProvisioningTemplate* = Call_DescribeProvisioningTemplate_603606(
    name: "describeProvisioningTemplate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/provisioning-templates/{templateName}",
    validator: validate_DescribeProvisioningTemplate_603607, base: "/",
    url: url_DescribeProvisioningTemplate_603608,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateProvisioningTemplate_603634 = ref object of OpenApiRestCall_601389
proc url_UpdateProvisioningTemplate_603636(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateProvisioningTemplate_603635(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_603637 = path.getOrDefault("templateName")
  valid_603637 = validateParameter(valid_603637, JString, required = true,
                                 default = nil)
  if valid_603637 != nil:
    section.add "templateName", valid_603637
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603638 = header.getOrDefault("X-Amz-Signature")
  valid_603638 = validateParameter(valid_603638, JString, required = false,
                                 default = nil)
  if valid_603638 != nil:
    section.add "X-Amz-Signature", valid_603638
  var valid_603639 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603639 = validateParameter(valid_603639, JString, required = false,
                                 default = nil)
  if valid_603639 != nil:
    section.add "X-Amz-Content-Sha256", valid_603639
  var valid_603640 = header.getOrDefault("X-Amz-Date")
  valid_603640 = validateParameter(valid_603640, JString, required = false,
                                 default = nil)
  if valid_603640 != nil:
    section.add "X-Amz-Date", valid_603640
  var valid_603641 = header.getOrDefault("X-Amz-Credential")
  valid_603641 = validateParameter(valid_603641, JString, required = false,
                                 default = nil)
  if valid_603641 != nil:
    section.add "X-Amz-Credential", valid_603641
  var valid_603642 = header.getOrDefault("X-Amz-Security-Token")
  valid_603642 = validateParameter(valid_603642, JString, required = false,
                                 default = nil)
  if valid_603642 != nil:
    section.add "X-Amz-Security-Token", valid_603642
  var valid_603643 = header.getOrDefault("X-Amz-Algorithm")
  valid_603643 = validateParameter(valid_603643, JString, required = false,
                                 default = nil)
  if valid_603643 != nil:
    section.add "X-Amz-Algorithm", valid_603643
  var valid_603644 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603644 = validateParameter(valid_603644, JString, required = false,
                                 default = nil)
  if valid_603644 != nil:
    section.add "X-Amz-SignedHeaders", valid_603644
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603646: Call_UpdateProvisioningTemplate_603634; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a fleet provisioning template.
  ## 
  let valid = call_603646.validator(path, query, header, formData, body)
  let scheme = call_603646.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603646.url(scheme.get, call_603646.host, call_603646.base,
                         call_603646.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603646, url, valid)

proc call*(call_603647: Call_UpdateProvisioningTemplate_603634; body: JsonNode;
          templateName: string): Recallable =
  ## updateProvisioningTemplate
  ## Updates a fleet provisioning template.
  ##   body: JObject (required)
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template.
  var path_603648 = newJObject()
  var body_603649 = newJObject()
  if body != nil:
    body_603649 = body
  add(path_603648, "templateName", newJString(templateName))
  result = call_603647.call(path_603648, nil, nil, nil, body_603649)

var updateProvisioningTemplate* = Call_UpdateProvisioningTemplate_603634(
    name: "updateProvisioningTemplate", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/provisioning-templates/{templateName}",
    validator: validate_UpdateProvisioningTemplate_603635, base: "/",
    url: url_UpdateProvisioningTemplate_603636,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteProvisioningTemplate_603620 = ref object of OpenApiRestCall_601389
proc url_DeleteProvisioningTemplate_603622(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteProvisioningTemplate_603621(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provision template to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_603623 = path.getOrDefault("templateName")
  valid_603623 = validateParameter(valid_603623, JString, required = true,
                                 default = nil)
  if valid_603623 != nil:
    section.add "templateName", valid_603623
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603624 = header.getOrDefault("X-Amz-Signature")
  valid_603624 = validateParameter(valid_603624, JString, required = false,
                                 default = nil)
  if valid_603624 != nil:
    section.add "X-Amz-Signature", valid_603624
  var valid_603625 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603625 = validateParameter(valid_603625, JString, required = false,
                                 default = nil)
  if valid_603625 != nil:
    section.add "X-Amz-Content-Sha256", valid_603625
  var valid_603626 = header.getOrDefault("X-Amz-Date")
  valid_603626 = validateParameter(valid_603626, JString, required = false,
                                 default = nil)
  if valid_603626 != nil:
    section.add "X-Amz-Date", valid_603626
  var valid_603627 = header.getOrDefault("X-Amz-Credential")
  valid_603627 = validateParameter(valid_603627, JString, required = false,
                                 default = nil)
  if valid_603627 != nil:
    section.add "X-Amz-Credential", valid_603627
  var valid_603628 = header.getOrDefault("X-Amz-Security-Token")
  valid_603628 = validateParameter(valid_603628, JString, required = false,
                                 default = nil)
  if valid_603628 != nil:
    section.add "X-Amz-Security-Token", valid_603628
  var valid_603629 = header.getOrDefault("X-Amz-Algorithm")
  valid_603629 = validateParameter(valid_603629, JString, required = false,
                                 default = nil)
  if valid_603629 != nil:
    section.add "X-Amz-Algorithm", valid_603629
  var valid_603630 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603630 = validateParameter(valid_603630, JString, required = false,
                                 default = nil)
  if valid_603630 != nil:
    section.add "X-Amz-SignedHeaders", valid_603630
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603631: Call_DeleteProvisioningTemplate_603620; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a fleet provisioning template.
  ## 
  let valid = call_603631.validator(path, query, header, formData, body)
  let scheme = call_603631.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603631.url(scheme.get, call_603631.host, call_603631.base,
                         call_603631.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603631, url, valid)

proc call*(call_603632: Call_DeleteProvisioningTemplate_603620;
          templateName: string): Recallable =
  ## deleteProvisioningTemplate
  ## Deletes a fleet provisioning template.
  ##   templateName: string (required)
  ##               : The name of the fleet provision template to delete.
  var path_603633 = newJObject()
  add(path_603633, "templateName", newJString(templateName))
  result = call_603632.call(path_603633, nil, nil, nil, nil)

var deleteProvisioningTemplate* = Call_DeleteProvisioningTemplate_603620(
    name: "deleteProvisioningTemplate", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/provisioning-templates/{templateName}",
    validator: validate_DeleteProvisioningTemplate_603621, base: "/",
    url: url_DeleteProvisioningTemplate_603622,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeProvisioningTemplateVersion_603650 = ref object of OpenApiRestCall_601389
proc url_DescribeProvisioningTemplateVersion_603652(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  assert "versionId" in path, "`versionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/versions/"),
               (kind: VariableSegment, value: "versionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeProvisioningTemplateVersion_603651(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about a fleet provisioning template version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The template name.
  ##   versionId: JInt (required)
  ##            : The fleet provisioning template version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_603653 = path.getOrDefault("templateName")
  valid_603653 = validateParameter(valid_603653, JString, required = true,
                                 default = nil)
  if valid_603653 != nil:
    section.add "templateName", valid_603653
  var valid_603654 = path.getOrDefault("versionId")
  valid_603654 = validateParameter(valid_603654, JInt, required = true, default = nil)
  if valid_603654 != nil:
    section.add "versionId", valid_603654
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603655 = header.getOrDefault("X-Amz-Signature")
  valid_603655 = validateParameter(valid_603655, JString, required = false,
                                 default = nil)
  if valid_603655 != nil:
    section.add "X-Amz-Signature", valid_603655
  var valid_603656 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603656 = validateParameter(valid_603656, JString, required = false,
                                 default = nil)
  if valid_603656 != nil:
    section.add "X-Amz-Content-Sha256", valid_603656
  var valid_603657 = header.getOrDefault("X-Amz-Date")
  valid_603657 = validateParameter(valid_603657, JString, required = false,
                                 default = nil)
  if valid_603657 != nil:
    section.add "X-Amz-Date", valid_603657
  var valid_603658 = header.getOrDefault("X-Amz-Credential")
  valid_603658 = validateParameter(valid_603658, JString, required = false,
                                 default = nil)
  if valid_603658 != nil:
    section.add "X-Amz-Credential", valid_603658
  var valid_603659 = header.getOrDefault("X-Amz-Security-Token")
  valid_603659 = validateParameter(valid_603659, JString, required = false,
                                 default = nil)
  if valid_603659 != nil:
    section.add "X-Amz-Security-Token", valid_603659
  var valid_603660 = header.getOrDefault("X-Amz-Algorithm")
  valid_603660 = validateParameter(valid_603660, JString, required = false,
                                 default = nil)
  if valid_603660 != nil:
    section.add "X-Amz-Algorithm", valid_603660
  var valid_603661 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603661 = validateParameter(valid_603661, JString, required = false,
                                 default = nil)
  if valid_603661 != nil:
    section.add "X-Amz-SignedHeaders", valid_603661
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603662: Call_DescribeProvisioningTemplateVersion_603650;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns information about a fleet provisioning template version.
  ## 
  let valid = call_603662.validator(path, query, header, formData, body)
  let scheme = call_603662.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603662.url(scheme.get, call_603662.host, call_603662.base,
                         call_603662.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603662, url, valid)

proc call*(call_603663: Call_DescribeProvisioningTemplateVersion_603650;
          templateName: string; versionId: int): Recallable =
  ## describeProvisioningTemplateVersion
  ## Returns information about a fleet provisioning template version.
  ##   templateName: string (required)
  ##               : The template name.
  ##   versionId: int (required)
  ##            : The fleet provisioning template version ID.
  var path_603664 = newJObject()
  add(path_603664, "templateName", newJString(templateName))
  add(path_603664, "versionId", newJInt(versionId))
  result = call_603663.call(path_603664, nil, nil, nil, nil)

var describeProvisioningTemplateVersion* = Call_DescribeProvisioningTemplateVersion_603650(
    name: "describeProvisioningTemplateVersion", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/versions/{versionId}",
    validator: validate_DescribeProvisioningTemplateVersion_603651, base: "/",
    url: url_DescribeProvisioningTemplateVersion_603652,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteProvisioningTemplateVersion_603665 = ref object of OpenApiRestCall_601389
proc url_DeleteProvisioningTemplateVersion_603667(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  assert "versionId" in path, "`versionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/versions/"),
               (kind: VariableSegment, value: "versionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteProvisioningTemplateVersion_603666(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a fleet provisioning template version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template version to delete.
  ##   versionId: JInt (required)
  ##            : The fleet provisioning template version ID to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_603668 = path.getOrDefault("templateName")
  valid_603668 = validateParameter(valid_603668, JString, required = true,
                                 default = nil)
  if valid_603668 != nil:
    section.add "templateName", valid_603668
  var valid_603669 = path.getOrDefault("versionId")
  valid_603669 = validateParameter(valid_603669, JInt, required = true, default = nil)
  if valid_603669 != nil:
    section.add "versionId", valid_603669
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603670 = header.getOrDefault("X-Amz-Signature")
  valid_603670 = validateParameter(valid_603670, JString, required = false,
                                 default = nil)
  if valid_603670 != nil:
    section.add "X-Amz-Signature", valid_603670
  var valid_603671 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603671 = validateParameter(valid_603671, JString, required = false,
                                 default = nil)
  if valid_603671 != nil:
    section.add "X-Amz-Content-Sha256", valid_603671
  var valid_603672 = header.getOrDefault("X-Amz-Date")
  valid_603672 = validateParameter(valid_603672, JString, required = false,
                                 default = nil)
  if valid_603672 != nil:
    section.add "X-Amz-Date", valid_603672
  var valid_603673 = header.getOrDefault("X-Amz-Credential")
  valid_603673 = validateParameter(valid_603673, JString, required = false,
                                 default = nil)
  if valid_603673 != nil:
    section.add "X-Amz-Credential", valid_603673
  var valid_603674 = header.getOrDefault("X-Amz-Security-Token")
  valid_603674 = validateParameter(valid_603674, JString, required = false,
                                 default = nil)
  if valid_603674 != nil:
    section.add "X-Amz-Security-Token", valid_603674
  var valid_603675 = header.getOrDefault("X-Amz-Algorithm")
  valid_603675 = validateParameter(valid_603675, JString, required = false,
                                 default = nil)
  if valid_603675 != nil:
    section.add "X-Amz-Algorithm", valid_603675
  var valid_603676 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603676 = validateParameter(valid_603676, JString, required = false,
                                 default = nil)
  if valid_603676 != nil:
    section.add "X-Amz-SignedHeaders", valid_603676
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603677: Call_DeleteProvisioningTemplateVersion_603665;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes a fleet provisioning template version.
  ## 
  let valid = call_603677.validator(path, query, header, formData, body)
  let scheme = call_603677.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603677.url(scheme.get, call_603677.host, call_603677.base,
                         call_603677.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603677, url, valid)

proc call*(call_603678: Call_DeleteProvisioningTemplateVersion_603665;
          templateName: string; versionId: int): Recallable =
  ## deleteProvisioningTemplateVersion
  ## Deletes a fleet provisioning template version.
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template version to delete.
  ##   versionId: int (required)
  ##            : The fleet provisioning template version ID to delete.
  var path_603679 = newJObject()
  add(path_603679, "templateName", newJString(templateName))
  add(path_603679, "versionId", newJInt(versionId))
  result = call_603678.call(path_603679, nil, nil, nil, nil)

var deleteProvisioningTemplateVersion* = Call_DeleteProvisioningTemplateVersion_603665(
    name: "deleteProvisioningTemplateVersion", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/versions/{versionId}",
    validator: validate_DeleteProvisioningTemplateVersion_603666, base: "/",
    url: url_DeleteProvisioningTemplateVersion_603667,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRegistrationCode_603680 = ref object of OpenApiRestCall_601389
proc url_GetRegistrationCode_603682(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRegistrationCode_603681(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603683 = header.getOrDefault("X-Amz-Signature")
  valid_603683 = validateParameter(valid_603683, JString, required = false,
                                 default = nil)
  if valid_603683 != nil:
    section.add "X-Amz-Signature", valid_603683
  var valid_603684 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603684 = validateParameter(valid_603684, JString, required = false,
                                 default = nil)
  if valid_603684 != nil:
    section.add "X-Amz-Content-Sha256", valid_603684
  var valid_603685 = header.getOrDefault("X-Amz-Date")
  valid_603685 = validateParameter(valid_603685, JString, required = false,
                                 default = nil)
  if valid_603685 != nil:
    section.add "X-Amz-Date", valid_603685
  var valid_603686 = header.getOrDefault("X-Amz-Credential")
  valid_603686 = validateParameter(valid_603686, JString, required = false,
                                 default = nil)
  if valid_603686 != nil:
    section.add "X-Amz-Credential", valid_603686
  var valid_603687 = header.getOrDefault("X-Amz-Security-Token")
  valid_603687 = validateParameter(valid_603687, JString, required = false,
                                 default = nil)
  if valid_603687 != nil:
    section.add "X-Amz-Security-Token", valid_603687
  var valid_603688 = header.getOrDefault("X-Amz-Algorithm")
  valid_603688 = validateParameter(valid_603688, JString, required = false,
                                 default = nil)
  if valid_603688 != nil:
    section.add "X-Amz-Algorithm", valid_603688
  var valid_603689 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603689 = validateParameter(valid_603689, JString, required = false,
                                 default = nil)
  if valid_603689 != nil:
    section.add "X-Amz-SignedHeaders", valid_603689
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603690: Call_GetRegistrationCode_603680; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  ## 
  let valid = call_603690.validator(path, query, header, formData, body)
  let scheme = call_603690.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603690.url(scheme.get, call_603690.host, call_603690.base,
                         call_603690.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603690, url, valid)

proc call*(call_603691: Call_GetRegistrationCode_603680): Recallable =
  ## getRegistrationCode
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  result = call_603691.call(nil, nil, nil, nil, nil)

var getRegistrationCode* = Call_GetRegistrationCode_603680(
    name: "getRegistrationCode", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/registrationcode",
    validator: validate_GetRegistrationCode_603681, base: "/",
    url: url_GetRegistrationCode_603682, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRegistrationCode_603692 = ref object of OpenApiRestCall_601389
proc url_DeleteRegistrationCode_603694(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteRegistrationCode_603693(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a CA certificate registration code.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603695 = header.getOrDefault("X-Amz-Signature")
  valid_603695 = validateParameter(valid_603695, JString, required = false,
                                 default = nil)
  if valid_603695 != nil:
    section.add "X-Amz-Signature", valid_603695
  var valid_603696 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603696 = validateParameter(valid_603696, JString, required = false,
                                 default = nil)
  if valid_603696 != nil:
    section.add "X-Amz-Content-Sha256", valid_603696
  var valid_603697 = header.getOrDefault("X-Amz-Date")
  valid_603697 = validateParameter(valid_603697, JString, required = false,
                                 default = nil)
  if valid_603697 != nil:
    section.add "X-Amz-Date", valid_603697
  var valid_603698 = header.getOrDefault("X-Amz-Credential")
  valid_603698 = validateParameter(valid_603698, JString, required = false,
                                 default = nil)
  if valid_603698 != nil:
    section.add "X-Amz-Credential", valid_603698
  var valid_603699 = header.getOrDefault("X-Amz-Security-Token")
  valid_603699 = validateParameter(valid_603699, JString, required = false,
                                 default = nil)
  if valid_603699 != nil:
    section.add "X-Amz-Security-Token", valid_603699
  var valid_603700 = header.getOrDefault("X-Amz-Algorithm")
  valid_603700 = validateParameter(valid_603700, JString, required = false,
                                 default = nil)
  if valid_603700 != nil:
    section.add "X-Amz-Algorithm", valid_603700
  var valid_603701 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603701 = validateParameter(valid_603701, JString, required = false,
                                 default = nil)
  if valid_603701 != nil:
    section.add "X-Amz-SignedHeaders", valid_603701
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603702: Call_DeleteRegistrationCode_603692; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a CA certificate registration code.
  ## 
  let valid = call_603702.validator(path, query, header, formData, body)
  let scheme = call_603702.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603702.url(scheme.get, call_603702.host, call_603702.base,
                         call_603702.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603702, url, valid)

proc call*(call_603703: Call_DeleteRegistrationCode_603692): Recallable =
  ## deleteRegistrationCode
  ## Deletes a CA certificate registration code.
  result = call_603703.call(nil, nil, nil, nil, nil)

var deleteRegistrationCode* = Call_DeleteRegistrationCode_603692(
    name: "deleteRegistrationCode", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/registrationcode",
    validator: validate_DeleteRegistrationCode_603693, base: "/",
    url: url_DeleteRegistrationCode_603694, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetTopicRuleDestination_603704 = ref object of OpenApiRestCall_601389
proc url_GetTopicRuleDestination_603706(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "arn" in path, "`arn` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/destinations/"),
               (kind: VariableSegment, value: "arn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTopicRuleDestination_603705(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a topic rule destination.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   arn: JString (required)
  ##      : The ARN of the topic rule destination.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `arn` field"
  var valid_603707 = path.getOrDefault("arn")
  valid_603707 = validateParameter(valid_603707, JString, required = true,
                                 default = nil)
  if valid_603707 != nil:
    section.add "arn", valid_603707
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603708 = header.getOrDefault("X-Amz-Signature")
  valid_603708 = validateParameter(valid_603708, JString, required = false,
                                 default = nil)
  if valid_603708 != nil:
    section.add "X-Amz-Signature", valid_603708
  var valid_603709 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603709 = validateParameter(valid_603709, JString, required = false,
                                 default = nil)
  if valid_603709 != nil:
    section.add "X-Amz-Content-Sha256", valid_603709
  var valid_603710 = header.getOrDefault("X-Amz-Date")
  valid_603710 = validateParameter(valid_603710, JString, required = false,
                                 default = nil)
  if valid_603710 != nil:
    section.add "X-Amz-Date", valid_603710
  var valid_603711 = header.getOrDefault("X-Amz-Credential")
  valid_603711 = validateParameter(valid_603711, JString, required = false,
                                 default = nil)
  if valid_603711 != nil:
    section.add "X-Amz-Credential", valid_603711
  var valid_603712 = header.getOrDefault("X-Amz-Security-Token")
  valid_603712 = validateParameter(valid_603712, JString, required = false,
                                 default = nil)
  if valid_603712 != nil:
    section.add "X-Amz-Security-Token", valid_603712
  var valid_603713 = header.getOrDefault("X-Amz-Algorithm")
  valid_603713 = validateParameter(valid_603713, JString, required = false,
                                 default = nil)
  if valid_603713 != nil:
    section.add "X-Amz-Algorithm", valid_603713
  var valid_603714 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603714 = validateParameter(valid_603714, JString, required = false,
                                 default = nil)
  if valid_603714 != nil:
    section.add "X-Amz-SignedHeaders", valid_603714
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603715: Call_GetTopicRuleDestination_603704; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a topic rule destination.
  ## 
  let valid = call_603715.validator(path, query, header, formData, body)
  let scheme = call_603715.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603715.url(scheme.get, call_603715.host, call_603715.base,
                         call_603715.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603715, url, valid)

proc call*(call_603716: Call_GetTopicRuleDestination_603704; arn: string): Recallable =
  ## getTopicRuleDestination
  ## Gets information about a topic rule destination.
  ##   arn: string (required)
  ##      : The ARN of the topic rule destination.
  var path_603717 = newJObject()
  add(path_603717, "arn", newJString(arn))
  result = call_603716.call(path_603717, nil, nil, nil, nil)

var getTopicRuleDestination* = Call_GetTopicRuleDestination_603704(
    name: "getTopicRuleDestination", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/destinations/{arn}",
    validator: validate_GetTopicRuleDestination_603705, base: "/",
    url: url_GetTopicRuleDestination_603706, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteTopicRuleDestination_603718 = ref object of OpenApiRestCall_601389
proc url_DeleteTopicRuleDestination_603720(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "arn" in path, "`arn` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/destinations/"),
               (kind: VariableSegment, value: "arn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTopicRuleDestination_603719(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a topic rule destination.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   arn: JString (required)
  ##      : The ARN of the topic rule destination to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `arn` field"
  var valid_603721 = path.getOrDefault("arn")
  valid_603721 = validateParameter(valid_603721, JString, required = true,
                                 default = nil)
  if valid_603721 != nil:
    section.add "arn", valid_603721
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603722 = header.getOrDefault("X-Amz-Signature")
  valid_603722 = validateParameter(valid_603722, JString, required = false,
                                 default = nil)
  if valid_603722 != nil:
    section.add "X-Amz-Signature", valid_603722
  var valid_603723 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603723 = validateParameter(valid_603723, JString, required = false,
                                 default = nil)
  if valid_603723 != nil:
    section.add "X-Amz-Content-Sha256", valid_603723
  var valid_603724 = header.getOrDefault("X-Amz-Date")
  valid_603724 = validateParameter(valid_603724, JString, required = false,
                                 default = nil)
  if valid_603724 != nil:
    section.add "X-Amz-Date", valid_603724
  var valid_603725 = header.getOrDefault("X-Amz-Credential")
  valid_603725 = validateParameter(valid_603725, JString, required = false,
                                 default = nil)
  if valid_603725 != nil:
    section.add "X-Amz-Credential", valid_603725
  var valid_603726 = header.getOrDefault("X-Amz-Security-Token")
  valid_603726 = validateParameter(valid_603726, JString, required = false,
                                 default = nil)
  if valid_603726 != nil:
    section.add "X-Amz-Security-Token", valid_603726
  var valid_603727 = header.getOrDefault("X-Amz-Algorithm")
  valid_603727 = validateParameter(valid_603727, JString, required = false,
                                 default = nil)
  if valid_603727 != nil:
    section.add "X-Amz-Algorithm", valid_603727
  var valid_603728 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603728 = validateParameter(valid_603728, JString, required = false,
                                 default = nil)
  if valid_603728 != nil:
    section.add "X-Amz-SignedHeaders", valid_603728
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603729: Call_DeleteTopicRuleDestination_603718; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a topic rule destination.
  ## 
  let valid = call_603729.validator(path, query, header, formData, body)
  let scheme = call_603729.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603729.url(scheme.get, call_603729.host, call_603729.base,
                         call_603729.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603729, url, valid)

proc call*(call_603730: Call_DeleteTopicRuleDestination_603718; arn: string): Recallable =
  ## deleteTopicRuleDestination
  ## Deletes a topic rule destination.
  ##   arn: string (required)
  ##      : The ARN of the topic rule destination to delete.
  var path_603731 = newJObject()
  add(path_603731, "arn", newJString(arn))
  result = call_603730.call(path_603731, nil, nil, nil, nil)

var deleteTopicRuleDestination* = Call_DeleteTopicRuleDestination_603718(
    name: "deleteTopicRuleDestination", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/destinations/{arn}",
    validator: validate_DeleteTopicRuleDestination_603719, base: "/",
    url: url_DeleteTopicRuleDestination_603720,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteV2LoggingLevel_603732 = ref object of OpenApiRestCall_601389
proc url_DeleteV2LoggingLevel_603734(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteV2LoggingLevel_603733(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a logging level.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   targetName: JString (required)
  ##             : The name of the resource for which you are configuring logging.
  ##   targetType: JString (required)
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `targetName` field"
  var valid_603735 = query.getOrDefault("targetName")
  valid_603735 = validateParameter(valid_603735, JString, required = true,
                                 default = nil)
  if valid_603735 != nil:
    section.add "targetName", valid_603735
  var valid_603736 = query.getOrDefault("targetType")
  valid_603736 = validateParameter(valid_603736, JString, required = true,
                                 default = newJString("DEFAULT"))
  if valid_603736 != nil:
    section.add "targetType", valid_603736
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603737 = header.getOrDefault("X-Amz-Signature")
  valid_603737 = validateParameter(valid_603737, JString, required = false,
                                 default = nil)
  if valid_603737 != nil:
    section.add "X-Amz-Signature", valid_603737
  var valid_603738 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603738 = validateParameter(valid_603738, JString, required = false,
                                 default = nil)
  if valid_603738 != nil:
    section.add "X-Amz-Content-Sha256", valid_603738
  var valid_603739 = header.getOrDefault("X-Amz-Date")
  valid_603739 = validateParameter(valid_603739, JString, required = false,
                                 default = nil)
  if valid_603739 != nil:
    section.add "X-Amz-Date", valid_603739
  var valid_603740 = header.getOrDefault("X-Amz-Credential")
  valid_603740 = validateParameter(valid_603740, JString, required = false,
                                 default = nil)
  if valid_603740 != nil:
    section.add "X-Amz-Credential", valid_603740
  var valid_603741 = header.getOrDefault("X-Amz-Security-Token")
  valid_603741 = validateParameter(valid_603741, JString, required = false,
                                 default = nil)
  if valid_603741 != nil:
    section.add "X-Amz-Security-Token", valid_603741
  var valid_603742 = header.getOrDefault("X-Amz-Algorithm")
  valid_603742 = validateParameter(valid_603742, JString, required = false,
                                 default = nil)
  if valid_603742 != nil:
    section.add "X-Amz-Algorithm", valid_603742
  var valid_603743 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603743 = validateParameter(valid_603743, JString, required = false,
                                 default = nil)
  if valid_603743 != nil:
    section.add "X-Amz-SignedHeaders", valid_603743
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603744: Call_DeleteV2LoggingLevel_603732; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a logging level.
  ## 
  let valid = call_603744.validator(path, query, header, formData, body)
  let scheme = call_603744.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603744.url(scheme.get, call_603744.host, call_603744.base,
                         call_603744.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603744, url, valid)

proc call*(call_603745: Call_DeleteV2LoggingLevel_603732; targetName: string;
          targetType: string = "DEFAULT"): Recallable =
  ## deleteV2LoggingLevel
  ## Deletes a logging level.
  ##   targetName: string (required)
  ##             : The name of the resource for which you are configuring logging.
  ##   targetType: string (required)
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  var query_603746 = newJObject()
  add(query_603746, "targetName", newJString(targetName))
  add(query_603746, "targetType", newJString(targetType))
  result = call_603745.call(nil, query_603746, nil, nil, nil)

var deleteV2LoggingLevel* = Call_DeleteV2LoggingLevel_603732(
    name: "deleteV2LoggingLevel", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/v2LoggingLevel#targetType&targetName",
    validator: validate_DeleteV2LoggingLevel_603733, base: "/",
    url: url_DeleteV2LoggingLevel_603734, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeprecateThingType_603747 = ref object of OpenApiRestCall_601389
proc url_DeprecateThingType_603749(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName"),
               (kind: ConstantSegment, value: "/deprecate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeprecateThingType_603748(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type to deprecate.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_603750 = path.getOrDefault("thingTypeName")
  valid_603750 = validateParameter(valid_603750, JString, required = true,
                                 default = nil)
  if valid_603750 != nil:
    section.add "thingTypeName", valid_603750
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603751 = header.getOrDefault("X-Amz-Signature")
  valid_603751 = validateParameter(valid_603751, JString, required = false,
                                 default = nil)
  if valid_603751 != nil:
    section.add "X-Amz-Signature", valid_603751
  var valid_603752 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603752 = validateParameter(valid_603752, JString, required = false,
                                 default = nil)
  if valid_603752 != nil:
    section.add "X-Amz-Content-Sha256", valid_603752
  var valid_603753 = header.getOrDefault("X-Amz-Date")
  valid_603753 = validateParameter(valid_603753, JString, required = false,
                                 default = nil)
  if valid_603753 != nil:
    section.add "X-Amz-Date", valid_603753
  var valid_603754 = header.getOrDefault("X-Amz-Credential")
  valid_603754 = validateParameter(valid_603754, JString, required = false,
                                 default = nil)
  if valid_603754 != nil:
    section.add "X-Amz-Credential", valid_603754
  var valid_603755 = header.getOrDefault("X-Amz-Security-Token")
  valid_603755 = validateParameter(valid_603755, JString, required = false,
                                 default = nil)
  if valid_603755 != nil:
    section.add "X-Amz-Security-Token", valid_603755
  var valid_603756 = header.getOrDefault("X-Amz-Algorithm")
  valid_603756 = validateParameter(valid_603756, JString, required = false,
                                 default = nil)
  if valid_603756 != nil:
    section.add "X-Amz-Algorithm", valid_603756
  var valid_603757 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603757 = validateParameter(valid_603757, JString, required = false,
                                 default = nil)
  if valid_603757 != nil:
    section.add "X-Amz-SignedHeaders", valid_603757
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603759: Call_DeprecateThingType_603747; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ## 
  let valid = call_603759.validator(path, query, header, formData, body)
  let scheme = call_603759.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603759.url(scheme.get, call_603759.host, call_603759.base,
                         call_603759.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603759, url, valid)

proc call*(call_603760: Call_DeprecateThingType_603747; thingTypeName: string;
          body: JsonNode): Recallable =
  ## deprecateThingType
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type to deprecate.
  ##   body: JObject (required)
  var path_603761 = newJObject()
  var body_603762 = newJObject()
  add(path_603761, "thingTypeName", newJString(thingTypeName))
  if body != nil:
    body_603762 = body
  result = call_603760.call(path_603761, nil, nil, nil, body_603762)

var deprecateThingType* = Call_DeprecateThingType_603747(
    name: "deprecateThingType", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/thing-types/{thingTypeName}/deprecate",
    validator: validate_DeprecateThingType_603748, base: "/",
    url: url_DeprecateThingType_603749, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditFinding_603763 = ref object of OpenApiRestCall_601389
proc url_DescribeAuditFinding_603765(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "findingId" in path, "`findingId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/findings/"),
               (kind: VariableSegment, value: "findingId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuditFinding_603764(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   findingId: JString (required)
  ##            : A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `findingId` field"
  var valid_603766 = path.getOrDefault("findingId")
  valid_603766 = validateParameter(valid_603766, JString, required = true,
                                 default = nil)
  if valid_603766 != nil:
    section.add "findingId", valid_603766
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603767 = header.getOrDefault("X-Amz-Signature")
  valid_603767 = validateParameter(valid_603767, JString, required = false,
                                 default = nil)
  if valid_603767 != nil:
    section.add "X-Amz-Signature", valid_603767
  var valid_603768 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603768 = validateParameter(valid_603768, JString, required = false,
                                 default = nil)
  if valid_603768 != nil:
    section.add "X-Amz-Content-Sha256", valid_603768
  var valid_603769 = header.getOrDefault("X-Amz-Date")
  valid_603769 = validateParameter(valid_603769, JString, required = false,
                                 default = nil)
  if valid_603769 != nil:
    section.add "X-Amz-Date", valid_603769
  var valid_603770 = header.getOrDefault("X-Amz-Credential")
  valid_603770 = validateParameter(valid_603770, JString, required = false,
                                 default = nil)
  if valid_603770 != nil:
    section.add "X-Amz-Credential", valid_603770
  var valid_603771 = header.getOrDefault("X-Amz-Security-Token")
  valid_603771 = validateParameter(valid_603771, JString, required = false,
                                 default = nil)
  if valid_603771 != nil:
    section.add "X-Amz-Security-Token", valid_603771
  var valid_603772 = header.getOrDefault("X-Amz-Algorithm")
  valid_603772 = validateParameter(valid_603772, JString, required = false,
                                 default = nil)
  if valid_603772 != nil:
    section.add "X-Amz-Algorithm", valid_603772
  var valid_603773 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603773 = validateParameter(valid_603773, JString, required = false,
                                 default = nil)
  if valid_603773 != nil:
    section.add "X-Amz-SignedHeaders", valid_603773
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603774: Call_DescribeAuditFinding_603763; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ## 
  let valid = call_603774.validator(path, query, header, formData, body)
  let scheme = call_603774.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603774.url(scheme.get, call_603774.host, call_603774.base,
                         call_603774.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603774, url, valid)

proc call*(call_603775: Call_DescribeAuditFinding_603763; findingId: string): Recallable =
  ## describeAuditFinding
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ##   findingId: string (required)
  ##            : A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
  var path_603776 = newJObject()
  add(path_603776, "findingId", newJString(findingId))
  result = call_603775.call(path_603776, nil, nil, nil, nil)

var describeAuditFinding* = Call_DescribeAuditFinding_603763(
    name: "describeAuditFinding", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/findings/{findingId}",
    validator: validate_DescribeAuditFinding_603764, base: "/",
    url: url_DescribeAuditFinding_603765, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartAuditMitigationActionsTask_603791 = ref object of OpenApiRestCall_601389
proc url_StartAuditMitigationActionsTask_603793(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_StartAuditMitigationActionsTask_603792(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_603794 = path.getOrDefault("taskId")
  valid_603794 = validateParameter(valid_603794, JString, required = true,
                                 default = nil)
  if valid_603794 != nil:
    section.add "taskId", valid_603794
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603795 = header.getOrDefault("X-Amz-Signature")
  valid_603795 = validateParameter(valid_603795, JString, required = false,
                                 default = nil)
  if valid_603795 != nil:
    section.add "X-Amz-Signature", valid_603795
  var valid_603796 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603796 = validateParameter(valid_603796, JString, required = false,
                                 default = nil)
  if valid_603796 != nil:
    section.add "X-Amz-Content-Sha256", valid_603796
  var valid_603797 = header.getOrDefault("X-Amz-Date")
  valid_603797 = validateParameter(valid_603797, JString, required = false,
                                 default = nil)
  if valid_603797 != nil:
    section.add "X-Amz-Date", valid_603797
  var valid_603798 = header.getOrDefault("X-Amz-Credential")
  valid_603798 = validateParameter(valid_603798, JString, required = false,
                                 default = nil)
  if valid_603798 != nil:
    section.add "X-Amz-Credential", valid_603798
  var valid_603799 = header.getOrDefault("X-Amz-Security-Token")
  valid_603799 = validateParameter(valid_603799, JString, required = false,
                                 default = nil)
  if valid_603799 != nil:
    section.add "X-Amz-Security-Token", valid_603799
  var valid_603800 = header.getOrDefault("X-Amz-Algorithm")
  valid_603800 = validateParameter(valid_603800, JString, required = false,
                                 default = nil)
  if valid_603800 != nil:
    section.add "X-Amz-Algorithm", valid_603800
  var valid_603801 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603801 = validateParameter(valid_603801, JString, required = false,
                                 default = nil)
  if valid_603801 != nil:
    section.add "X-Amz-SignedHeaders", valid_603801
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603803: Call_StartAuditMitigationActionsTask_603791;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ## 
  let valid = call_603803.validator(path, query, header, formData, body)
  let scheme = call_603803.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603803.url(scheme.get, call_603803.host, call_603803.base,
                         call_603803.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603803, url, valid)

proc call*(call_603804: Call_StartAuditMitigationActionsTask_603791;
          body: JsonNode; taskId: string): Recallable =
  ## startAuditMitigationActionsTask
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ##   body: JObject (required)
  ##   taskId: string (required)
  ##         : A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
  var path_603805 = newJObject()
  var body_603806 = newJObject()
  if body != nil:
    body_603806 = body
  add(path_603805, "taskId", newJString(taskId))
  result = call_603804.call(path_603805, nil, nil, nil, body_603806)

var startAuditMitigationActionsTask* = Call_StartAuditMitigationActionsTask_603791(
    name: "startAuditMitigationActionsTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/audit/mitigationactions/tasks/{taskId}",
    validator: validate_StartAuditMitigationActionsTask_603792, base: "/",
    url: url_StartAuditMitigationActionsTask_603793,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditMitigationActionsTask_603777 = ref object of OpenApiRestCall_601389
proc url_DescribeAuditMitigationActionsTask_603779(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuditMitigationActionsTask_603778(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The unique identifier for the audit mitigation task.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_603780 = path.getOrDefault("taskId")
  valid_603780 = validateParameter(valid_603780, JString, required = true,
                                 default = nil)
  if valid_603780 != nil:
    section.add "taskId", valid_603780
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603781 = header.getOrDefault("X-Amz-Signature")
  valid_603781 = validateParameter(valid_603781, JString, required = false,
                                 default = nil)
  if valid_603781 != nil:
    section.add "X-Amz-Signature", valid_603781
  var valid_603782 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603782 = validateParameter(valid_603782, JString, required = false,
                                 default = nil)
  if valid_603782 != nil:
    section.add "X-Amz-Content-Sha256", valid_603782
  var valid_603783 = header.getOrDefault("X-Amz-Date")
  valid_603783 = validateParameter(valid_603783, JString, required = false,
                                 default = nil)
  if valid_603783 != nil:
    section.add "X-Amz-Date", valid_603783
  var valid_603784 = header.getOrDefault("X-Amz-Credential")
  valid_603784 = validateParameter(valid_603784, JString, required = false,
                                 default = nil)
  if valid_603784 != nil:
    section.add "X-Amz-Credential", valid_603784
  var valid_603785 = header.getOrDefault("X-Amz-Security-Token")
  valid_603785 = validateParameter(valid_603785, JString, required = false,
                                 default = nil)
  if valid_603785 != nil:
    section.add "X-Amz-Security-Token", valid_603785
  var valid_603786 = header.getOrDefault("X-Amz-Algorithm")
  valid_603786 = validateParameter(valid_603786, JString, required = false,
                                 default = nil)
  if valid_603786 != nil:
    section.add "X-Amz-Algorithm", valid_603786
  var valid_603787 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603787 = validateParameter(valid_603787, JString, required = false,
                                 default = nil)
  if valid_603787 != nil:
    section.add "X-Amz-SignedHeaders", valid_603787
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603788: Call_DescribeAuditMitigationActionsTask_603777;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ## 
  let valid = call_603788.validator(path, query, header, formData, body)
  let scheme = call_603788.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603788.url(scheme.get, call_603788.host, call_603788.base,
                         call_603788.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603788, url, valid)

proc call*(call_603789: Call_DescribeAuditMitigationActionsTask_603777;
          taskId: string): Recallable =
  ## describeAuditMitigationActionsTask
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ##   taskId: string (required)
  ##         : The unique identifier for the audit mitigation task.
  var path_603790 = newJObject()
  add(path_603790, "taskId", newJString(taskId))
  result = call_603789.call(path_603790, nil, nil, nil, nil)

var describeAuditMitigationActionsTask* = Call_DescribeAuditMitigationActionsTask_603777(
    name: "describeAuditMitigationActionsTask", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/mitigationactions/tasks/{taskId}",
    validator: validate_DescribeAuditMitigationActionsTask_603778, base: "/",
    url: url_DescribeAuditMitigationActionsTask_603779,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditTask_603807 = ref object of OpenApiRestCall_601389
proc url_DescribeAuditTask_603809(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuditTask_603808(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Gets information about a Device Defender audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The ID of the audit whose information you want to get.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_603810 = path.getOrDefault("taskId")
  valid_603810 = validateParameter(valid_603810, JString, required = true,
                                 default = nil)
  if valid_603810 != nil:
    section.add "taskId", valid_603810
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603811 = header.getOrDefault("X-Amz-Signature")
  valid_603811 = validateParameter(valid_603811, JString, required = false,
                                 default = nil)
  if valid_603811 != nil:
    section.add "X-Amz-Signature", valid_603811
  var valid_603812 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603812 = validateParameter(valid_603812, JString, required = false,
                                 default = nil)
  if valid_603812 != nil:
    section.add "X-Amz-Content-Sha256", valid_603812
  var valid_603813 = header.getOrDefault("X-Amz-Date")
  valid_603813 = validateParameter(valid_603813, JString, required = false,
                                 default = nil)
  if valid_603813 != nil:
    section.add "X-Amz-Date", valid_603813
  var valid_603814 = header.getOrDefault("X-Amz-Credential")
  valid_603814 = validateParameter(valid_603814, JString, required = false,
                                 default = nil)
  if valid_603814 != nil:
    section.add "X-Amz-Credential", valid_603814
  var valid_603815 = header.getOrDefault("X-Amz-Security-Token")
  valid_603815 = validateParameter(valid_603815, JString, required = false,
                                 default = nil)
  if valid_603815 != nil:
    section.add "X-Amz-Security-Token", valid_603815
  var valid_603816 = header.getOrDefault("X-Amz-Algorithm")
  valid_603816 = validateParameter(valid_603816, JString, required = false,
                                 default = nil)
  if valid_603816 != nil:
    section.add "X-Amz-Algorithm", valid_603816
  var valid_603817 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603817 = validateParameter(valid_603817, JString, required = false,
                                 default = nil)
  if valid_603817 != nil:
    section.add "X-Amz-SignedHeaders", valid_603817
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603818: Call_DescribeAuditTask_603807; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a Device Defender audit.
  ## 
  let valid = call_603818.validator(path, query, header, formData, body)
  let scheme = call_603818.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603818.url(scheme.get, call_603818.host, call_603818.base,
                         call_603818.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603818, url, valid)

proc call*(call_603819: Call_DescribeAuditTask_603807; taskId: string): Recallable =
  ## describeAuditTask
  ## Gets information about a Device Defender audit.
  ##   taskId: string (required)
  ##         : The ID of the audit whose information you want to get.
  var path_603820 = newJObject()
  add(path_603820, "taskId", newJString(taskId))
  result = call_603819.call(path_603820, nil, nil, nil, nil)

var describeAuditTask* = Call_DescribeAuditTask_603807(name: "describeAuditTask",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/audit/tasks/{taskId}", validator: validate_DescribeAuditTask_603808,
    base: "/", url: url_DescribeAuditTask_603809,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeEndpoint_603821 = ref object of OpenApiRestCall_601389
proc url_DescribeEndpoint_603823(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeEndpoint_603822(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Returns a unique endpoint specific to the AWS account making the call.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endpointType: JString
  ##               : <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
  section = newJObject()
  var valid_603824 = query.getOrDefault("endpointType")
  valid_603824 = validateParameter(valid_603824, JString, required = false,
                                 default = nil)
  if valid_603824 != nil:
    section.add "endpointType", valid_603824
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603825 = header.getOrDefault("X-Amz-Signature")
  valid_603825 = validateParameter(valid_603825, JString, required = false,
                                 default = nil)
  if valid_603825 != nil:
    section.add "X-Amz-Signature", valid_603825
  var valid_603826 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603826 = validateParameter(valid_603826, JString, required = false,
                                 default = nil)
  if valid_603826 != nil:
    section.add "X-Amz-Content-Sha256", valid_603826
  var valid_603827 = header.getOrDefault("X-Amz-Date")
  valid_603827 = validateParameter(valid_603827, JString, required = false,
                                 default = nil)
  if valid_603827 != nil:
    section.add "X-Amz-Date", valid_603827
  var valid_603828 = header.getOrDefault("X-Amz-Credential")
  valid_603828 = validateParameter(valid_603828, JString, required = false,
                                 default = nil)
  if valid_603828 != nil:
    section.add "X-Amz-Credential", valid_603828
  var valid_603829 = header.getOrDefault("X-Amz-Security-Token")
  valid_603829 = validateParameter(valid_603829, JString, required = false,
                                 default = nil)
  if valid_603829 != nil:
    section.add "X-Amz-Security-Token", valid_603829
  var valid_603830 = header.getOrDefault("X-Amz-Algorithm")
  valid_603830 = validateParameter(valid_603830, JString, required = false,
                                 default = nil)
  if valid_603830 != nil:
    section.add "X-Amz-Algorithm", valid_603830
  var valid_603831 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603831 = validateParameter(valid_603831, JString, required = false,
                                 default = nil)
  if valid_603831 != nil:
    section.add "X-Amz-SignedHeaders", valid_603831
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603832: Call_DescribeEndpoint_603821; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a unique endpoint specific to the AWS account making the call.
  ## 
  let valid = call_603832.validator(path, query, header, formData, body)
  let scheme = call_603832.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603832.url(scheme.get, call_603832.host, call_603832.base,
                         call_603832.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603832, url, valid)

proc call*(call_603833: Call_DescribeEndpoint_603821; endpointType: string = ""): Recallable =
  ## describeEndpoint
  ## Returns a unique endpoint specific to the AWS account making the call.
  ##   endpointType: string
  ##               : <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
  var query_603834 = newJObject()
  add(query_603834, "endpointType", newJString(endpointType))
  result = call_603833.call(nil, query_603834, nil, nil, nil)

var describeEndpoint* = Call_DescribeEndpoint_603821(name: "describeEndpoint",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/endpoint",
    validator: validate_DescribeEndpoint_603822, base: "/",
    url: url_DescribeEndpoint_603823, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeEventConfigurations_603835 = ref object of OpenApiRestCall_601389
proc url_DescribeEventConfigurations_603837(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeEventConfigurations_603836(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes event configurations.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603838 = header.getOrDefault("X-Amz-Signature")
  valid_603838 = validateParameter(valid_603838, JString, required = false,
                                 default = nil)
  if valid_603838 != nil:
    section.add "X-Amz-Signature", valid_603838
  var valid_603839 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603839 = validateParameter(valid_603839, JString, required = false,
                                 default = nil)
  if valid_603839 != nil:
    section.add "X-Amz-Content-Sha256", valid_603839
  var valid_603840 = header.getOrDefault("X-Amz-Date")
  valid_603840 = validateParameter(valid_603840, JString, required = false,
                                 default = nil)
  if valid_603840 != nil:
    section.add "X-Amz-Date", valid_603840
  var valid_603841 = header.getOrDefault("X-Amz-Credential")
  valid_603841 = validateParameter(valid_603841, JString, required = false,
                                 default = nil)
  if valid_603841 != nil:
    section.add "X-Amz-Credential", valid_603841
  var valid_603842 = header.getOrDefault("X-Amz-Security-Token")
  valid_603842 = validateParameter(valid_603842, JString, required = false,
                                 default = nil)
  if valid_603842 != nil:
    section.add "X-Amz-Security-Token", valid_603842
  var valid_603843 = header.getOrDefault("X-Amz-Algorithm")
  valid_603843 = validateParameter(valid_603843, JString, required = false,
                                 default = nil)
  if valid_603843 != nil:
    section.add "X-Amz-Algorithm", valid_603843
  var valid_603844 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603844 = validateParameter(valid_603844, JString, required = false,
                                 default = nil)
  if valid_603844 != nil:
    section.add "X-Amz-SignedHeaders", valid_603844
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603845: Call_DescribeEventConfigurations_603835; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes event configurations.
  ## 
  let valid = call_603845.validator(path, query, header, formData, body)
  let scheme = call_603845.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603845.url(scheme.get, call_603845.host, call_603845.base,
                         call_603845.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603845, url, valid)

proc call*(call_603846: Call_DescribeEventConfigurations_603835): Recallable =
  ## describeEventConfigurations
  ## Describes event configurations.
  result = call_603846.call(nil, nil, nil, nil, nil)

var describeEventConfigurations* = Call_DescribeEventConfigurations_603835(
    name: "describeEventConfigurations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/event-configurations",
    validator: validate_DescribeEventConfigurations_603836, base: "/",
    url: url_DescribeEventConfigurations_603837,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateEventConfigurations_603847 = ref object of OpenApiRestCall_601389
proc url_UpdateEventConfigurations_603849(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateEventConfigurations_603848(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the event configurations.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603850 = header.getOrDefault("X-Amz-Signature")
  valid_603850 = validateParameter(valid_603850, JString, required = false,
                                 default = nil)
  if valid_603850 != nil:
    section.add "X-Amz-Signature", valid_603850
  var valid_603851 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603851 = validateParameter(valid_603851, JString, required = false,
                                 default = nil)
  if valid_603851 != nil:
    section.add "X-Amz-Content-Sha256", valid_603851
  var valid_603852 = header.getOrDefault("X-Amz-Date")
  valid_603852 = validateParameter(valid_603852, JString, required = false,
                                 default = nil)
  if valid_603852 != nil:
    section.add "X-Amz-Date", valid_603852
  var valid_603853 = header.getOrDefault("X-Amz-Credential")
  valid_603853 = validateParameter(valid_603853, JString, required = false,
                                 default = nil)
  if valid_603853 != nil:
    section.add "X-Amz-Credential", valid_603853
  var valid_603854 = header.getOrDefault("X-Amz-Security-Token")
  valid_603854 = validateParameter(valid_603854, JString, required = false,
                                 default = nil)
  if valid_603854 != nil:
    section.add "X-Amz-Security-Token", valid_603854
  var valid_603855 = header.getOrDefault("X-Amz-Algorithm")
  valid_603855 = validateParameter(valid_603855, JString, required = false,
                                 default = nil)
  if valid_603855 != nil:
    section.add "X-Amz-Algorithm", valid_603855
  var valid_603856 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603856 = validateParameter(valid_603856, JString, required = false,
                                 default = nil)
  if valid_603856 != nil:
    section.add "X-Amz-SignedHeaders", valid_603856
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603858: Call_UpdateEventConfigurations_603847; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the event configurations.
  ## 
  let valid = call_603858.validator(path, query, header, formData, body)
  let scheme = call_603858.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603858.url(scheme.get, call_603858.host, call_603858.base,
                         call_603858.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603858, url, valid)

proc call*(call_603859: Call_UpdateEventConfigurations_603847; body: JsonNode): Recallable =
  ## updateEventConfigurations
  ## Updates the event configurations.
  ##   body: JObject (required)
  var body_603860 = newJObject()
  if body != nil:
    body_603860 = body
  result = call_603859.call(nil, nil, nil, nil, body_603860)

var updateEventConfigurations* = Call_UpdateEventConfigurations_603847(
    name: "updateEventConfigurations", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/event-configurations",
    validator: validate_UpdateEventConfigurations_603848, base: "/",
    url: url_UpdateEventConfigurations_603849,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeIndex_603861 = ref object of OpenApiRestCall_601389
proc url_DescribeIndex_603863(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "indexName" in path, "`indexName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/indices/"),
               (kind: VariableSegment, value: "indexName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeIndex_603862(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a search index.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   indexName: JString (required)
  ##            : The index name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `indexName` field"
  var valid_603864 = path.getOrDefault("indexName")
  valid_603864 = validateParameter(valid_603864, JString, required = true,
                                 default = nil)
  if valid_603864 != nil:
    section.add "indexName", valid_603864
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603865 = header.getOrDefault("X-Amz-Signature")
  valid_603865 = validateParameter(valid_603865, JString, required = false,
                                 default = nil)
  if valid_603865 != nil:
    section.add "X-Amz-Signature", valid_603865
  var valid_603866 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603866 = validateParameter(valid_603866, JString, required = false,
                                 default = nil)
  if valid_603866 != nil:
    section.add "X-Amz-Content-Sha256", valid_603866
  var valid_603867 = header.getOrDefault("X-Amz-Date")
  valid_603867 = validateParameter(valid_603867, JString, required = false,
                                 default = nil)
  if valid_603867 != nil:
    section.add "X-Amz-Date", valid_603867
  var valid_603868 = header.getOrDefault("X-Amz-Credential")
  valid_603868 = validateParameter(valid_603868, JString, required = false,
                                 default = nil)
  if valid_603868 != nil:
    section.add "X-Amz-Credential", valid_603868
  var valid_603869 = header.getOrDefault("X-Amz-Security-Token")
  valid_603869 = validateParameter(valid_603869, JString, required = false,
                                 default = nil)
  if valid_603869 != nil:
    section.add "X-Amz-Security-Token", valid_603869
  var valid_603870 = header.getOrDefault("X-Amz-Algorithm")
  valid_603870 = validateParameter(valid_603870, JString, required = false,
                                 default = nil)
  if valid_603870 != nil:
    section.add "X-Amz-Algorithm", valid_603870
  var valid_603871 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603871 = validateParameter(valid_603871, JString, required = false,
                                 default = nil)
  if valid_603871 != nil:
    section.add "X-Amz-SignedHeaders", valid_603871
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603872: Call_DescribeIndex_603861; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a search index.
  ## 
  let valid = call_603872.validator(path, query, header, formData, body)
  let scheme = call_603872.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603872.url(scheme.get, call_603872.host, call_603872.base,
                         call_603872.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603872, url, valid)

proc call*(call_603873: Call_DescribeIndex_603861; indexName: string): Recallable =
  ## describeIndex
  ## Describes a search index.
  ##   indexName: string (required)
  ##            : The index name.
  var path_603874 = newJObject()
  add(path_603874, "indexName", newJString(indexName))
  result = call_603873.call(path_603874, nil, nil, nil, nil)

var describeIndex* = Call_DescribeIndex_603861(name: "describeIndex",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/indices/{indexName}", validator: validate_DescribeIndex_603862,
    base: "/", url: url_DescribeIndex_603863, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeJobExecution_603875 = ref object of OpenApiRestCall_601389
proc url_DescribeJobExecution_603877(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeJobExecution_603876(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a job execution.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   thingName: JString (required)
  ##            : The name of the thing on which the job execution is running.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_603878 = path.getOrDefault("jobId")
  valid_603878 = validateParameter(valid_603878, JString, required = true,
                                 default = nil)
  if valid_603878 != nil:
    section.add "jobId", valid_603878
  var valid_603879 = path.getOrDefault("thingName")
  valid_603879 = validateParameter(valid_603879, JString, required = true,
                                 default = nil)
  if valid_603879 != nil:
    section.add "thingName", valid_603879
  result.add "path", section
  ## parameters in `query` object:
  ##   executionNumber: JInt
  ##                  : A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
  section = newJObject()
  var valid_603880 = query.getOrDefault("executionNumber")
  valid_603880 = validateParameter(valid_603880, JInt, required = false, default = nil)
  if valid_603880 != nil:
    section.add "executionNumber", valid_603880
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603881 = header.getOrDefault("X-Amz-Signature")
  valid_603881 = validateParameter(valid_603881, JString, required = false,
                                 default = nil)
  if valid_603881 != nil:
    section.add "X-Amz-Signature", valid_603881
  var valid_603882 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603882 = validateParameter(valid_603882, JString, required = false,
                                 default = nil)
  if valid_603882 != nil:
    section.add "X-Amz-Content-Sha256", valid_603882
  var valid_603883 = header.getOrDefault("X-Amz-Date")
  valid_603883 = validateParameter(valid_603883, JString, required = false,
                                 default = nil)
  if valid_603883 != nil:
    section.add "X-Amz-Date", valid_603883
  var valid_603884 = header.getOrDefault("X-Amz-Credential")
  valid_603884 = validateParameter(valid_603884, JString, required = false,
                                 default = nil)
  if valid_603884 != nil:
    section.add "X-Amz-Credential", valid_603884
  var valid_603885 = header.getOrDefault("X-Amz-Security-Token")
  valid_603885 = validateParameter(valid_603885, JString, required = false,
                                 default = nil)
  if valid_603885 != nil:
    section.add "X-Amz-Security-Token", valid_603885
  var valid_603886 = header.getOrDefault("X-Amz-Algorithm")
  valid_603886 = validateParameter(valid_603886, JString, required = false,
                                 default = nil)
  if valid_603886 != nil:
    section.add "X-Amz-Algorithm", valid_603886
  var valid_603887 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603887 = validateParameter(valid_603887, JString, required = false,
                                 default = nil)
  if valid_603887 != nil:
    section.add "X-Amz-SignedHeaders", valid_603887
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603888: Call_DescribeJobExecution_603875; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a job execution.
  ## 
  let valid = call_603888.validator(path, query, header, formData, body)
  let scheme = call_603888.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603888.url(scheme.get, call_603888.host, call_603888.base,
                         call_603888.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603888, url, valid)

proc call*(call_603889: Call_DescribeJobExecution_603875; jobId: string;
          thingName: string; executionNumber: int = 0): Recallable =
  ## describeJobExecution
  ## Describes a job execution.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   executionNumber: int
  ##                  : A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
  ##   thingName: string (required)
  ##            : The name of the thing on which the job execution is running.
  var path_603890 = newJObject()
  var query_603891 = newJObject()
  add(path_603890, "jobId", newJString(jobId))
  add(query_603891, "executionNumber", newJInt(executionNumber))
  add(path_603890, "thingName", newJString(thingName))
  result = call_603889.call(path_603890, query_603891, nil, nil, nil)

var describeJobExecution* = Call_DescribeJobExecution_603875(
    name: "describeJobExecution", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs/{jobId}",
    validator: validate_DescribeJobExecution_603876, base: "/",
    url: url_DescribeJobExecution_603877, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingRegistrationTask_603892 = ref object of OpenApiRestCall_601389
proc url_DescribeThingRegistrationTask_603894(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThingRegistrationTask_603893(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The task ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_603895 = path.getOrDefault("taskId")
  valid_603895 = validateParameter(valid_603895, JString, required = true,
                                 default = nil)
  if valid_603895 != nil:
    section.add "taskId", valid_603895
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603896 = header.getOrDefault("X-Amz-Signature")
  valid_603896 = validateParameter(valid_603896, JString, required = false,
                                 default = nil)
  if valid_603896 != nil:
    section.add "X-Amz-Signature", valid_603896
  var valid_603897 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603897 = validateParameter(valid_603897, JString, required = false,
                                 default = nil)
  if valid_603897 != nil:
    section.add "X-Amz-Content-Sha256", valid_603897
  var valid_603898 = header.getOrDefault("X-Amz-Date")
  valid_603898 = validateParameter(valid_603898, JString, required = false,
                                 default = nil)
  if valid_603898 != nil:
    section.add "X-Amz-Date", valid_603898
  var valid_603899 = header.getOrDefault("X-Amz-Credential")
  valid_603899 = validateParameter(valid_603899, JString, required = false,
                                 default = nil)
  if valid_603899 != nil:
    section.add "X-Amz-Credential", valid_603899
  var valid_603900 = header.getOrDefault("X-Amz-Security-Token")
  valid_603900 = validateParameter(valid_603900, JString, required = false,
                                 default = nil)
  if valid_603900 != nil:
    section.add "X-Amz-Security-Token", valid_603900
  var valid_603901 = header.getOrDefault("X-Amz-Algorithm")
  valid_603901 = validateParameter(valid_603901, JString, required = false,
                                 default = nil)
  if valid_603901 != nil:
    section.add "X-Amz-Algorithm", valid_603901
  var valid_603902 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603902 = validateParameter(valid_603902, JString, required = false,
                                 default = nil)
  if valid_603902 != nil:
    section.add "X-Amz-SignedHeaders", valid_603902
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603903: Call_DescribeThingRegistrationTask_603892; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a bulk thing provisioning task.
  ## 
  let valid = call_603903.validator(path, query, header, formData, body)
  let scheme = call_603903.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603903.url(scheme.get, call_603903.host, call_603903.base,
                         call_603903.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603903, url, valid)

proc call*(call_603904: Call_DescribeThingRegistrationTask_603892; taskId: string): Recallable =
  ## describeThingRegistrationTask
  ## Describes a bulk thing provisioning task.
  ##   taskId: string (required)
  ##         : The task ID.
  var path_603905 = newJObject()
  add(path_603905, "taskId", newJString(taskId))
  result = call_603904.call(path_603905, nil, nil, nil, nil)

var describeThingRegistrationTask* = Call_DescribeThingRegistrationTask_603892(
    name: "describeThingRegistrationTask", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks/{taskId}",
    validator: validate_DescribeThingRegistrationTask_603893, base: "/",
    url: url_DescribeThingRegistrationTask_603894,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DisableTopicRule_603906 = ref object of OpenApiRestCall_601389
proc url_DisableTopicRule_603908(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName"),
               (kind: ConstantSegment, value: "/disable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DisableTopicRule_603907(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Disables the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule to disable.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_603909 = path.getOrDefault("ruleName")
  valid_603909 = validateParameter(valid_603909, JString, required = true,
                                 default = nil)
  if valid_603909 != nil:
    section.add "ruleName", valid_603909
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603910 = header.getOrDefault("X-Amz-Signature")
  valid_603910 = validateParameter(valid_603910, JString, required = false,
                                 default = nil)
  if valid_603910 != nil:
    section.add "X-Amz-Signature", valid_603910
  var valid_603911 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603911 = validateParameter(valid_603911, JString, required = false,
                                 default = nil)
  if valid_603911 != nil:
    section.add "X-Amz-Content-Sha256", valid_603911
  var valid_603912 = header.getOrDefault("X-Amz-Date")
  valid_603912 = validateParameter(valid_603912, JString, required = false,
                                 default = nil)
  if valid_603912 != nil:
    section.add "X-Amz-Date", valid_603912
  var valid_603913 = header.getOrDefault("X-Amz-Credential")
  valid_603913 = validateParameter(valid_603913, JString, required = false,
                                 default = nil)
  if valid_603913 != nil:
    section.add "X-Amz-Credential", valid_603913
  var valid_603914 = header.getOrDefault("X-Amz-Security-Token")
  valid_603914 = validateParameter(valid_603914, JString, required = false,
                                 default = nil)
  if valid_603914 != nil:
    section.add "X-Amz-Security-Token", valid_603914
  var valid_603915 = header.getOrDefault("X-Amz-Algorithm")
  valid_603915 = validateParameter(valid_603915, JString, required = false,
                                 default = nil)
  if valid_603915 != nil:
    section.add "X-Amz-Algorithm", valid_603915
  var valid_603916 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603916 = validateParameter(valid_603916, JString, required = false,
                                 default = nil)
  if valid_603916 != nil:
    section.add "X-Amz-SignedHeaders", valid_603916
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603917: Call_DisableTopicRule_603906; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Disables the rule.
  ## 
  let valid = call_603917.validator(path, query, header, formData, body)
  let scheme = call_603917.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603917.url(scheme.get, call_603917.host, call_603917.base,
                         call_603917.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603917, url, valid)

proc call*(call_603918: Call_DisableTopicRule_603906; ruleName: string): Recallable =
  ## disableTopicRule
  ## Disables the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule to disable.
  var path_603919 = newJObject()
  add(path_603919, "ruleName", newJString(ruleName))
  result = call_603918.call(path_603919, nil, nil, nil, nil)

var disableTopicRule* = Call_DisableTopicRule_603906(name: "disableTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}/disable", validator: validate_DisableTopicRule_603907,
    base: "/", url: url_DisableTopicRule_603908,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_EnableTopicRule_603920 = ref object of OpenApiRestCall_601389
proc url_EnableTopicRule_603922(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName"),
               (kind: ConstantSegment, value: "/enable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_EnableTopicRule_603921(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Enables the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the topic rule to enable.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_603923 = path.getOrDefault("ruleName")
  valid_603923 = validateParameter(valid_603923, JString, required = true,
                                 default = nil)
  if valid_603923 != nil:
    section.add "ruleName", valid_603923
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603924 = header.getOrDefault("X-Amz-Signature")
  valid_603924 = validateParameter(valid_603924, JString, required = false,
                                 default = nil)
  if valid_603924 != nil:
    section.add "X-Amz-Signature", valid_603924
  var valid_603925 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603925 = validateParameter(valid_603925, JString, required = false,
                                 default = nil)
  if valid_603925 != nil:
    section.add "X-Amz-Content-Sha256", valid_603925
  var valid_603926 = header.getOrDefault("X-Amz-Date")
  valid_603926 = validateParameter(valid_603926, JString, required = false,
                                 default = nil)
  if valid_603926 != nil:
    section.add "X-Amz-Date", valid_603926
  var valid_603927 = header.getOrDefault("X-Amz-Credential")
  valid_603927 = validateParameter(valid_603927, JString, required = false,
                                 default = nil)
  if valid_603927 != nil:
    section.add "X-Amz-Credential", valid_603927
  var valid_603928 = header.getOrDefault("X-Amz-Security-Token")
  valid_603928 = validateParameter(valid_603928, JString, required = false,
                                 default = nil)
  if valid_603928 != nil:
    section.add "X-Amz-Security-Token", valid_603928
  var valid_603929 = header.getOrDefault("X-Amz-Algorithm")
  valid_603929 = validateParameter(valid_603929, JString, required = false,
                                 default = nil)
  if valid_603929 != nil:
    section.add "X-Amz-Algorithm", valid_603929
  var valid_603930 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603930 = validateParameter(valid_603930, JString, required = false,
                                 default = nil)
  if valid_603930 != nil:
    section.add "X-Amz-SignedHeaders", valid_603930
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603931: Call_EnableTopicRule_603920; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the rule.
  ## 
  let valid = call_603931.validator(path, query, header, formData, body)
  let scheme = call_603931.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603931.url(scheme.get, call_603931.host, call_603931.base,
                         call_603931.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603931, url, valid)

proc call*(call_603932: Call_EnableTopicRule_603920; ruleName: string): Recallable =
  ## enableTopicRule
  ## Enables the rule.
  ##   ruleName: string (required)
  ##           : The name of the topic rule to enable.
  var path_603933 = newJObject()
  add(path_603933, "ruleName", newJString(ruleName))
  result = call_603932.call(path_603933, nil, nil, nil, nil)

var enableTopicRule* = Call_EnableTopicRule_603920(name: "enableTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}/enable", validator: validate_EnableTopicRule_603921,
    base: "/", url: url_EnableTopicRule_603922, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCardinality_603934 = ref object of OpenApiRestCall_601389
proc url_GetCardinality_603936(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCardinality_603935(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Returns the approximate count of unique values that match the query.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603937 = header.getOrDefault("X-Amz-Signature")
  valid_603937 = validateParameter(valid_603937, JString, required = false,
                                 default = nil)
  if valid_603937 != nil:
    section.add "X-Amz-Signature", valid_603937
  var valid_603938 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603938 = validateParameter(valid_603938, JString, required = false,
                                 default = nil)
  if valid_603938 != nil:
    section.add "X-Amz-Content-Sha256", valid_603938
  var valid_603939 = header.getOrDefault("X-Amz-Date")
  valid_603939 = validateParameter(valid_603939, JString, required = false,
                                 default = nil)
  if valid_603939 != nil:
    section.add "X-Amz-Date", valid_603939
  var valid_603940 = header.getOrDefault("X-Amz-Credential")
  valid_603940 = validateParameter(valid_603940, JString, required = false,
                                 default = nil)
  if valid_603940 != nil:
    section.add "X-Amz-Credential", valid_603940
  var valid_603941 = header.getOrDefault("X-Amz-Security-Token")
  valid_603941 = validateParameter(valid_603941, JString, required = false,
                                 default = nil)
  if valid_603941 != nil:
    section.add "X-Amz-Security-Token", valid_603941
  var valid_603942 = header.getOrDefault("X-Amz-Algorithm")
  valid_603942 = validateParameter(valid_603942, JString, required = false,
                                 default = nil)
  if valid_603942 != nil:
    section.add "X-Amz-Algorithm", valid_603942
  var valid_603943 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603943 = validateParameter(valid_603943, JString, required = false,
                                 default = nil)
  if valid_603943 != nil:
    section.add "X-Amz-SignedHeaders", valid_603943
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603945: Call_GetCardinality_603934; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the approximate count of unique values that match the query.
  ## 
  let valid = call_603945.validator(path, query, header, formData, body)
  let scheme = call_603945.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603945.url(scheme.get, call_603945.host, call_603945.base,
                         call_603945.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603945, url, valid)

proc call*(call_603946: Call_GetCardinality_603934; body: JsonNode): Recallable =
  ## getCardinality
  ## Returns the approximate count of unique values that match the query.
  ##   body: JObject (required)
  var body_603947 = newJObject()
  if body != nil:
    body_603947 = body
  result = call_603946.call(nil, nil, nil, nil, body_603947)

var getCardinality* = Call_GetCardinality_603934(name: "getCardinality",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/cardinality", validator: validate_GetCardinality_603935,
    base: "/", url: url_GetCardinality_603936, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEffectivePolicies_603948 = ref object of OpenApiRestCall_601389
proc url_GetEffectivePolicies_603950(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEffectivePolicies_603949(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingName: JString
  ##            : The thing name.
  section = newJObject()
  var valid_603951 = query.getOrDefault("thingName")
  valid_603951 = validateParameter(valid_603951, JString, required = false,
                                 default = nil)
  if valid_603951 != nil:
    section.add "thingName", valid_603951
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603952 = header.getOrDefault("X-Amz-Signature")
  valid_603952 = validateParameter(valid_603952, JString, required = false,
                                 default = nil)
  if valid_603952 != nil:
    section.add "X-Amz-Signature", valid_603952
  var valid_603953 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603953 = validateParameter(valid_603953, JString, required = false,
                                 default = nil)
  if valid_603953 != nil:
    section.add "X-Amz-Content-Sha256", valid_603953
  var valid_603954 = header.getOrDefault("X-Amz-Date")
  valid_603954 = validateParameter(valid_603954, JString, required = false,
                                 default = nil)
  if valid_603954 != nil:
    section.add "X-Amz-Date", valid_603954
  var valid_603955 = header.getOrDefault("X-Amz-Credential")
  valid_603955 = validateParameter(valid_603955, JString, required = false,
                                 default = nil)
  if valid_603955 != nil:
    section.add "X-Amz-Credential", valid_603955
  var valid_603956 = header.getOrDefault("X-Amz-Security-Token")
  valid_603956 = validateParameter(valid_603956, JString, required = false,
                                 default = nil)
  if valid_603956 != nil:
    section.add "X-Amz-Security-Token", valid_603956
  var valid_603957 = header.getOrDefault("X-Amz-Algorithm")
  valid_603957 = validateParameter(valid_603957, JString, required = false,
                                 default = nil)
  if valid_603957 != nil:
    section.add "X-Amz-Algorithm", valid_603957
  var valid_603958 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603958 = validateParameter(valid_603958, JString, required = false,
                                 default = nil)
  if valid_603958 != nil:
    section.add "X-Amz-SignedHeaders", valid_603958
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603960: Call_GetEffectivePolicies_603948; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ## 
  let valid = call_603960.validator(path, query, header, formData, body)
  let scheme = call_603960.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603960.url(scheme.get, call_603960.host, call_603960.base,
                         call_603960.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603960, url, valid)

proc call*(call_603961: Call_GetEffectivePolicies_603948; body: JsonNode;
          thingName: string = ""): Recallable =
  ## getEffectivePolicies
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ##   thingName: string
  ##            : The thing name.
  ##   body: JObject (required)
  var query_603962 = newJObject()
  var body_603963 = newJObject()
  add(query_603962, "thingName", newJString(thingName))
  if body != nil:
    body_603963 = body
  result = call_603961.call(nil, query_603962, nil, nil, body_603963)

var getEffectivePolicies* = Call_GetEffectivePolicies_603948(
    name: "getEffectivePolicies", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/effective-policies",
    validator: validate_GetEffectivePolicies_603949, base: "/",
    url: url_GetEffectivePolicies_603950, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateIndexingConfiguration_603976 = ref object of OpenApiRestCall_601389
proc url_UpdateIndexingConfiguration_603978(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateIndexingConfiguration_603977(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the search configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603979 = header.getOrDefault("X-Amz-Signature")
  valid_603979 = validateParameter(valid_603979, JString, required = false,
                                 default = nil)
  if valid_603979 != nil:
    section.add "X-Amz-Signature", valid_603979
  var valid_603980 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603980 = validateParameter(valid_603980, JString, required = false,
                                 default = nil)
  if valid_603980 != nil:
    section.add "X-Amz-Content-Sha256", valid_603980
  var valid_603981 = header.getOrDefault("X-Amz-Date")
  valid_603981 = validateParameter(valid_603981, JString, required = false,
                                 default = nil)
  if valid_603981 != nil:
    section.add "X-Amz-Date", valid_603981
  var valid_603982 = header.getOrDefault("X-Amz-Credential")
  valid_603982 = validateParameter(valid_603982, JString, required = false,
                                 default = nil)
  if valid_603982 != nil:
    section.add "X-Amz-Credential", valid_603982
  var valid_603983 = header.getOrDefault("X-Amz-Security-Token")
  valid_603983 = validateParameter(valid_603983, JString, required = false,
                                 default = nil)
  if valid_603983 != nil:
    section.add "X-Amz-Security-Token", valid_603983
  var valid_603984 = header.getOrDefault("X-Amz-Algorithm")
  valid_603984 = validateParameter(valid_603984, JString, required = false,
                                 default = nil)
  if valid_603984 != nil:
    section.add "X-Amz-Algorithm", valid_603984
  var valid_603985 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603985 = validateParameter(valid_603985, JString, required = false,
                                 default = nil)
  if valid_603985 != nil:
    section.add "X-Amz-SignedHeaders", valid_603985
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603987: Call_UpdateIndexingConfiguration_603976; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the search configuration.
  ## 
  let valid = call_603987.validator(path, query, header, formData, body)
  let scheme = call_603987.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603987.url(scheme.get, call_603987.host, call_603987.base,
                         call_603987.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603987, url, valid)

proc call*(call_603988: Call_UpdateIndexingConfiguration_603976; body: JsonNode): Recallable =
  ## updateIndexingConfiguration
  ## Updates the search configuration.
  ##   body: JObject (required)
  var body_603989 = newJObject()
  if body != nil:
    body_603989 = body
  result = call_603988.call(nil, nil, nil, nil, body_603989)

var updateIndexingConfiguration* = Call_UpdateIndexingConfiguration_603976(
    name: "updateIndexingConfiguration", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/indexing/config",
    validator: validate_UpdateIndexingConfiguration_603977, base: "/",
    url: url_UpdateIndexingConfiguration_603978,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetIndexingConfiguration_603964 = ref object of OpenApiRestCall_601389
proc url_GetIndexingConfiguration_603966(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetIndexingConfiguration_603965(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the indexing configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603967 = header.getOrDefault("X-Amz-Signature")
  valid_603967 = validateParameter(valid_603967, JString, required = false,
                                 default = nil)
  if valid_603967 != nil:
    section.add "X-Amz-Signature", valid_603967
  var valid_603968 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603968 = validateParameter(valid_603968, JString, required = false,
                                 default = nil)
  if valid_603968 != nil:
    section.add "X-Amz-Content-Sha256", valid_603968
  var valid_603969 = header.getOrDefault("X-Amz-Date")
  valid_603969 = validateParameter(valid_603969, JString, required = false,
                                 default = nil)
  if valid_603969 != nil:
    section.add "X-Amz-Date", valid_603969
  var valid_603970 = header.getOrDefault("X-Amz-Credential")
  valid_603970 = validateParameter(valid_603970, JString, required = false,
                                 default = nil)
  if valid_603970 != nil:
    section.add "X-Amz-Credential", valid_603970
  var valid_603971 = header.getOrDefault("X-Amz-Security-Token")
  valid_603971 = validateParameter(valid_603971, JString, required = false,
                                 default = nil)
  if valid_603971 != nil:
    section.add "X-Amz-Security-Token", valid_603971
  var valid_603972 = header.getOrDefault("X-Amz-Algorithm")
  valid_603972 = validateParameter(valid_603972, JString, required = false,
                                 default = nil)
  if valid_603972 != nil:
    section.add "X-Amz-Algorithm", valid_603972
  var valid_603973 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603973 = validateParameter(valid_603973, JString, required = false,
                                 default = nil)
  if valid_603973 != nil:
    section.add "X-Amz-SignedHeaders", valid_603973
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603974: Call_GetIndexingConfiguration_603964; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the indexing configuration.
  ## 
  let valid = call_603974.validator(path, query, header, formData, body)
  let scheme = call_603974.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603974.url(scheme.get, call_603974.host, call_603974.base,
                         call_603974.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603974, url, valid)

proc call*(call_603975: Call_GetIndexingConfiguration_603964): Recallable =
  ## getIndexingConfiguration
  ## Gets the indexing configuration.
  result = call_603975.call(nil, nil, nil, nil, nil)

var getIndexingConfiguration* = Call_GetIndexingConfiguration_603964(
    name: "getIndexingConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/indexing/config",
    validator: validate_GetIndexingConfiguration_603965, base: "/",
    url: url_GetIndexingConfiguration_603966, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetJobDocument_603990 = ref object of OpenApiRestCall_601389
proc url_GetJobDocument_603992(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/job-document")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetJobDocument_603991(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets a job document.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_603993 = path.getOrDefault("jobId")
  valid_603993 = validateParameter(valid_603993, JString, required = true,
                                 default = nil)
  if valid_603993 != nil:
    section.add "jobId", valid_603993
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603994 = header.getOrDefault("X-Amz-Signature")
  valid_603994 = validateParameter(valid_603994, JString, required = false,
                                 default = nil)
  if valid_603994 != nil:
    section.add "X-Amz-Signature", valid_603994
  var valid_603995 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603995 = validateParameter(valid_603995, JString, required = false,
                                 default = nil)
  if valid_603995 != nil:
    section.add "X-Amz-Content-Sha256", valid_603995
  var valid_603996 = header.getOrDefault("X-Amz-Date")
  valid_603996 = validateParameter(valid_603996, JString, required = false,
                                 default = nil)
  if valid_603996 != nil:
    section.add "X-Amz-Date", valid_603996
  var valid_603997 = header.getOrDefault("X-Amz-Credential")
  valid_603997 = validateParameter(valid_603997, JString, required = false,
                                 default = nil)
  if valid_603997 != nil:
    section.add "X-Amz-Credential", valid_603997
  var valid_603998 = header.getOrDefault("X-Amz-Security-Token")
  valid_603998 = validateParameter(valid_603998, JString, required = false,
                                 default = nil)
  if valid_603998 != nil:
    section.add "X-Amz-Security-Token", valid_603998
  var valid_603999 = header.getOrDefault("X-Amz-Algorithm")
  valid_603999 = validateParameter(valid_603999, JString, required = false,
                                 default = nil)
  if valid_603999 != nil:
    section.add "X-Amz-Algorithm", valid_603999
  var valid_604000 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604000 = validateParameter(valid_604000, JString, required = false,
                                 default = nil)
  if valid_604000 != nil:
    section.add "X-Amz-SignedHeaders", valid_604000
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604001: Call_GetJobDocument_603990; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a job document.
  ## 
  let valid = call_604001.validator(path, query, header, formData, body)
  let scheme = call_604001.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604001.url(scheme.get, call_604001.host, call_604001.base,
                         call_604001.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604001, url, valid)

proc call*(call_604002: Call_GetJobDocument_603990; jobId: string): Recallable =
  ## getJobDocument
  ## Gets a job document.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  var path_604003 = newJObject()
  add(path_604003, "jobId", newJString(jobId))
  result = call_604002.call(path_604003, nil, nil, nil, nil)

var getJobDocument* = Call_GetJobDocument_603990(name: "getJobDocument",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/jobs/{jobId}/job-document", validator: validate_GetJobDocument_603991,
    base: "/", url: url_GetJobDocument_603992, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetLoggingOptions_604016 = ref object of OpenApiRestCall_601389
proc url_SetLoggingOptions_604018(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetLoggingOptions_604017(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604019 = header.getOrDefault("X-Amz-Signature")
  valid_604019 = validateParameter(valid_604019, JString, required = false,
                                 default = nil)
  if valid_604019 != nil:
    section.add "X-Amz-Signature", valid_604019
  var valid_604020 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604020 = validateParameter(valid_604020, JString, required = false,
                                 default = nil)
  if valid_604020 != nil:
    section.add "X-Amz-Content-Sha256", valid_604020
  var valid_604021 = header.getOrDefault("X-Amz-Date")
  valid_604021 = validateParameter(valid_604021, JString, required = false,
                                 default = nil)
  if valid_604021 != nil:
    section.add "X-Amz-Date", valid_604021
  var valid_604022 = header.getOrDefault("X-Amz-Credential")
  valid_604022 = validateParameter(valid_604022, JString, required = false,
                                 default = nil)
  if valid_604022 != nil:
    section.add "X-Amz-Credential", valid_604022
  var valid_604023 = header.getOrDefault("X-Amz-Security-Token")
  valid_604023 = validateParameter(valid_604023, JString, required = false,
                                 default = nil)
  if valid_604023 != nil:
    section.add "X-Amz-Security-Token", valid_604023
  var valid_604024 = header.getOrDefault("X-Amz-Algorithm")
  valid_604024 = validateParameter(valid_604024, JString, required = false,
                                 default = nil)
  if valid_604024 != nil:
    section.add "X-Amz-Algorithm", valid_604024
  var valid_604025 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604025 = validateParameter(valid_604025, JString, required = false,
                                 default = nil)
  if valid_604025 != nil:
    section.add "X-Amz-SignedHeaders", valid_604025
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604027: Call_SetLoggingOptions_604016; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ## 
  let valid = call_604027.validator(path, query, header, formData, body)
  let scheme = call_604027.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604027.url(scheme.get, call_604027.host, call_604027.base,
                         call_604027.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604027, url, valid)

proc call*(call_604028: Call_SetLoggingOptions_604016; body: JsonNode): Recallable =
  ## setLoggingOptions
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ##   body: JObject (required)
  var body_604029 = newJObject()
  if body != nil:
    body_604029 = body
  result = call_604028.call(nil, nil, nil, nil, body_604029)

var setLoggingOptions* = Call_SetLoggingOptions_604016(name: "setLoggingOptions",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/loggingOptions",
    validator: validate_SetLoggingOptions_604017, base: "/",
    url: url_SetLoggingOptions_604018, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetLoggingOptions_604004 = ref object of OpenApiRestCall_601389
proc url_GetLoggingOptions_604006(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetLoggingOptions_604005(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604007 = header.getOrDefault("X-Amz-Signature")
  valid_604007 = validateParameter(valid_604007, JString, required = false,
                                 default = nil)
  if valid_604007 != nil:
    section.add "X-Amz-Signature", valid_604007
  var valid_604008 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604008 = validateParameter(valid_604008, JString, required = false,
                                 default = nil)
  if valid_604008 != nil:
    section.add "X-Amz-Content-Sha256", valid_604008
  var valid_604009 = header.getOrDefault("X-Amz-Date")
  valid_604009 = validateParameter(valid_604009, JString, required = false,
                                 default = nil)
  if valid_604009 != nil:
    section.add "X-Amz-Date", valid_604009
  var valid_604010 = header.getOrDefault("X-Amz-Credential")
  valid_604010 = validateParameter(valid_604010, JString, required = false,
                                 default = nil)
  if valid_604010 != nil:
    section.add "X-Amz-Credential", valid_604010
  var valid_604011 = header.getOrDefault("X-Amz-Security-Token")
  valid_604011 = validateParameter(valid_604011, JString, required = false,
                                 default = nil)
  if valid_604011 != nil:
    section.add "X-Amz-Security-Token", valid_604011
  var valid_604012 = header.getOrDefault("X-Amz-Algorithm")
  valid_604012 = validateParameter(valid_604012, JString, required = false,
                                 default = nil)
  if valid_604012 != nil:
    section.add "X-Amz-Algorithm", valid_604012
  var valid_604013 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604013 = validateParameter(valid_604013, JString, required = false,
                                 default = nil)
  if valid_604013 != nil:
    section.add "X-Amz-SignedHeaders", valid_604013
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604014: Call_GetLoggingOptions_604004; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  ## 
  let valid = call_604014.validator(path, query, header, formData, body)
  let scheme = call_604014.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604014.url(scheme.get, call_604014.host, call_604014.base,
                         call_604014.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604014, url, valid)

proc call*(call_604015: Call_GetLoggingOptions_604004): Recallable =
  ## getLoggingOptions
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  result = call_604015.call(nil, nil, nil, nil, nil)

var getLoggingOptions* = Call_GetLoggingOptions_604004(name: "getLoggingOptions",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/loggingOptions",
    validator: validate_GetLoggingOptions_604005, base: "/",
    url: url_GetLoggingOptions_604006, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPercentiles_604030 = ref object of OpenApiRestCall_601389
proc url_GetPercentiles_604032(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetPercentiles_604031(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Groups the aggregated values that match the query into percentile groupings. The default percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own when you call <code>GetPercentiles</code>. This function returns a value for each percentile group specified (or the default percentile groupings). The percentile group "1" contains the aggregated field value that occurs in approximately one percent of the values that match the query. The percentile group "5" contains the aggregated field value that occurs in approximately five percent of the values that match the query, and so on. The result is an approximation, the more values that match the query, the more accurate the percentile values.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604033 = header.getOrDefault("X-Amz-Signature")
  valid_604033 = validateParameter(valid_604033, JString, required = false,
                                 default = nil)
  if valid_604033 != nil:
    section.add "X-Amz-Signature", valid_604033
  var valid_604034 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604034 = validateParameter(valid_604034, JString, required = false,
                                 default = nil)
  if valid_604034 != nil:
    section.add "X-Amz-Content-Sha256", valid_604034
  var valid_604035 = header.getOrDefault("X-Amz-Date")
  valid_604035 = validateParameter(valid_604035, JString, required = false,
                                 default = nil)
  if valid_604035 != nil:
    section.add "X-Amz-Date", valid_604035
  var valid_604036 = header.getOrDefault("X-Amz-Credential")
  valid_604036 = validateParameter(valid_604036, JString, required = false,
                                 default = nil)
  if valid_604036 != nil:
    section.add "X-Amz-Credential", valid_604036
  var valid_604037 = header.getOrDefault("X-Amz-Security-Token")
  valid_604037 = validateParameter(valid_604037, JString, required = false,
                                 default = nil)
  if valid_604037 != nil:
    section.add "X-Amz-Security-Token", valid_604037
  var valid_604038 = header.getOrDefault("X-Amz-Algorithm")
  valid_604038 = validateParameter(valid_604038, JString, required = false,
                                 default = nil)
  if valid_604038 != nil:
    section.add "X-Amz-Algorithm", valid_604038
  var valid_604039 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604039 = validateParameter(valid_604039, JString, required = false,
                                 default = nil)
  if valid_604039 != nil:
    section.add "X-Amz-SignedHeaders", valid_604039
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604041: Call_GetPercentiles_604030; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Groups the aggregated values that match the query into percentile groupings. The default percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own when you call <code>GetPercentiles</code>. This function returns a value for each percentile group specified (or the default percentile groupings). The percentile group "1" contains the aggregated field value that occurs in approximately one percent of the values that match the query. The percentile group "5" contains the aggregated field value that occurs in approximately five percent of the values that match the query, and so on. The result is an approximation, the more values that match the query, the more accurate the percentile values.
  ## 
  let valid = call_604041.validator(path, query, header, formData, body)
  let scheme = call_604041.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604041.url(scheme.get, call_604041.host, call_604041.base,
                         call_604041.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604041, url, valid)

proc call*(call_604042: Call_GetPercentiles_604030; body: JsonNode): Recallable =
  ## getPercentiles
  ## Groups the aggregated values that match the query into percentile groupings. The default percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own when you call <code>GetPercentiles</code>. This function returns a value for each percentile group specified (or the default percentile groupings). The percentile group "1" contains the aggregated field value that occurs in approximately one percent of the values that match the query. The percentile group "5" contains the aggregated field value that occurs in approximately five percent of the values that match the query, and so on. The result is an approximation, the more values that match the query, the more accurate the percentile values.
  ##   body: JObject (required)
  var body_604043 = newJObject()
  if body != nil:
    body_604043 = body
  result = call_604042.call(nil, nil, nil, nil, body_604043)

var getPercentiles* = Call_GetPercentiles_604030(name: "getPercentiles",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/percentiles", validator: validate_GetPercentiles_604031,
    base: "/", url: url_GetPercentiles_604032, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetStatistics_604044 = ref object of OpenApiRestCall_601389
proc url_GetStatistics_604046(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetStatistics_604045(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the count, average, sum, minimum, maximum, sum of squares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type <code>String</code>, only the count statistic is returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604047 = header.getOrDefault("X-Amz-Signature")
  valid_604047 = validateParameter(valid_604047, JString, required = false,
                                 default = nil)
  if valid_604047 != nil:
    section.add "X-Amz-Signature", valid_604047
  var valid_604048 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604048 = validateParameter(valid_604048, JString, required = false,
                                 default = nil)
  if valid_604048 != nil:
    section.add "X-Amz-Content-Sha256", valid_604048
  var valid_604049 = header.getOrDefault("X-Amz-Date")
  valid_604049 = validateParameter(valid_604049, JString, required = false,
                                 default = nil)
  if valid_604049 != nil:
    section.add "X-Amz-Date", valid_604049
  var valid_604050 = header.getOrDefault("X-Amz-Credential")
  valid_604050 = validateParameter(valid_604050, JString, required = false,
                                 default = nil)
  if valid_604050 != nil:
    section.add "X-Amz-Credential", valid_604050
  var valid_604051 = header.getOrDefault("X-Amz-Security-Token")
  valid_604051 = validateParameter(valid_604051, JString, required = false,
                                 default = nil)
  if valid_604051 != nil:
    section.add "X-Amz-Security-Token", valid_604051
  var valid_604052 = header.getOrDefault("X-Amz-Algorithm")
  valid_604052 = validateParameter(valid_604052, JString, required = false,
                                 default = nil)
  if valid_604052 != nil:
    section.add "X-Amz-Algorithm", valid_604052
  var valid_604053 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604053 = validateParameter(valid_604053, JString, required = false,
                                 default = nil)
  if valid_604053 != nil:
    section.add "X-Amz-SignedHeaders", valid_604053
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604055: Call_GetStatistics_604044; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the count, average, sum, minimum, maximum, sum of squares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type <code>String</code>, only the count statistic is returned.
  ## 
  let valid = call_604055.validator(path, query, header, formData, body)
  let scheme = call_604055.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604055.url(scheme.get, call_604055.host, call_604055.base,
                         call_604055.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604055, url, valid)

proc call*(call_604056: Call_GetStatistics_604044; body: JsonNode): Recallable =
  ## getStatistics
  ## Returns the count, average, sum, minimum, maximum, sum of squares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type <code>String</code>, only the count statistic is returned.
  ##   body: JObject (required)
  var body_604057 = newJObject()
  if body != nil:
    body_604057 = body
  result = call_604056.call(nil, nil, nil, nil, body_604057)

var getStatistics* = Call_GetStatistics_604044(name: "getStatistics",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/statistics", validator: validate_GetStatistics_604045,
    base: "/", url: url_GetStatistics_604046, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetV2LoggingOptions_604070 = ref object of OpenApiRestCall_601389
proc url_SetV2LoggingOptions_604072(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetV2LoggingOptions_604071(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Sets the logging options for the V2 logging service.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604073 = header.getOrDefault("X-Amz-Signature")
  valid_604073 = validateParameter(valid_604073, JString, required = false,
                                 default = nil)
  if valid_604073 != nil:
    section.add "X-Amz-Signature", valid_604073
  var valid_604074 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604074 = validateParameter(valid_604074, JString, required = false,
                                 default = nil)
  if valid_604074 != nil:
    section.add "X-Amz-Content-Sha256", valid_604074
  var valid_604075 = header.getOrDefault("X-Amz-Date")
  valid_604075 = validateParameter(valid_604075, JString, required = false,
                                 default = nil)
  if valid_604075 != nil:
    section.add "X-Amz-Date", valid_604075
  var valid_604076 = header.getOrDefault("X-Amz-Credential")
  valid_604076 = validateParameter(valid_604076, JString, required = false,
                                 default = nil)
  if valid_604076 != nil:
    section.add "X-Amz-Credential", valid_604076
  var valid_604077 = header.getOrDefault("X-Amz-Security-Token")
  valid_604077 = validateParameter(valid_604077, JString, required = false,
                                 default = nil)
  if valid_604077 != nil:
    section.add "X-Amz-Security-Token", valid_604077
  var valid_604078 = header.getOrDefault("X-Amz-Algorithm")
  valid_604078 = validateParameter(valid_604078, JString, required = false,
                                 default = nil)
  if valid_604078 != nil:
    section.add "X-Amz-Algorithm", valid_604078
  var valid_604079 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604079 = validateParameter(valid_604079, JString, required = false,
                                 default = nil)
  if valid_604079 != nil:
    section.add "X-Amz-SignedHeaders", valid_604079
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604081: Call_SetV2LoggingOptions_604070; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the logging options for the V2 logging service.
  ## 
  let valid = call_604081.validator(path, query, header, formData, body)
  let scheme = call_604081.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604081.url(scheme.get, call_604081.host, call_604081.base,
                         call_604081.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604081, url, valid)

proc call*(call_604082: Call_SetV2LoggingOptions_604070; body: JsonNode): Recallable =
  ## setV2LoggingOptions
  ## Sets the logging options for the V2 logging service.
  ##   body: JObject (required)
  var body_604083 = newJObject()
  if body != nil:
    body_604083 = body
  result = call_604082.call(nil, nil, nil, nil, body_604083)

var setV2LoggingOptions* = Call_SetV2LoggingOptions_604070(
    name: "setV2LoggingOptions", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/v2LoggingOptions",
    validator: validate_SetV2LoggingOptions_604071, base: "/",
    url: url_SetV2LoggingOptions_604072, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetV2LoggingOptions_604058 = ref object of OpenApiRestCall_601389
proc url_GetV2LoggingOptions_604060(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV2LoggingOptions_604059(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets the fine grained logging options.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604061 = header.getOrDefault("X-Amz-Signature")
  valid_604061 = validateParameter(valid_604061, JString, required = false,
                                 default = nil)
  if valid_604061 != nil:
    section.add "X-Amz-Signature", valid_604061
  var valid_604062 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604062 = validateParameter(valid_604062, JString, required = false,
                                 default = nil)
  if valid_604062 != nil:
    section.add "X-Amz-Content-Sha256", valid_604062
  var valid_604063 = header.getOrDefault("X-Amz-Date")
  valid_604063 = validateParameter(valid_604063, JString, required = false,
                                 default = nil)
  if valid_604063 != nil:
    section.add "X-Amz-Date", valid_604063
  var valid_604064 = header.getOrDefault("X-Amz-Credential")
  valid_604064 = validateParameter(valid_604064, JString, required = false,
                                 default = nil)
  if valid_604064 != nil:
    section.add "X-Amz-Credential", valid_604064
  var valid_604065 = header.getOrDefault("X-Amz-Security-Token")
  valid_604065 = validateParameter(valid_604065, JString, required = false,
                                 default = nil)
  if valid_604065 != nil:
    section.add "X-Amz-Security-Token", valid_604065
  var valid_604066 = header.getOrDefault("X-Amz-Algorithm")
  valid_604066 = validateParameter(valid_604066, JString, required = false,
                                 default = nil)
  if valid_604066 != nil:
    section.add "X-Amz-Algorithm", valid_604066
  var valid_604067 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604067 = validateParameter(valid_604067, JString, required = false,
                                 default = nil)
  if valid_604067 != nil:
    section.add "X-Amz-SignedHeaders", valid_604067
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604068: Call_GetV2LoggingOptions_604058; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the fine grained logging options.
  ## 
  let valid = call_604068.validator(path, query, header, formData, body)
  let scheme = call_604068.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604068.url(scheme.get, call_604068.host, call_604068.base,
                         call_604068.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604068, url, valid)

proc call*(call_604069: Call_GetV2LoggingOptions_604058): Recallable =
  ## getV2LoggingOptions
  ## Gets the fine grained logging options.
  result = call_604069.call(nil, nil, nil, nil, nil)

var getV2LoggingOptions* = Call_GetV2LoggingOptions_604058(
    name: "getV2LoggingOptions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/v2LoggingOptions",
    validator: validate_GetV2LoggingOptions_604059, base: "/",
    url: url_GetV2LoggingOptions_604060, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListActiveViolations_604084 = ref object of OpenApiRestCall_601389
proc url_ListActiveViolations_604086(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListActiveViolations_604085(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the active violations for a given Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   securityProfileName: JString
  ##                      : The name of the Device Defender security profile for which violations are listed.
  ##   thingName: JString
  ##            : The name of the thing whose active violations are listed.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_604087 = query.getOrDefault("nextToken")
  valid_604087 = validateParameter(valid_604087, JString, required = false,
                                 default = nil)
  if valid_604087 != nil:
    section.add "nextToken", valid_604087
  var valid_604088 = query.getOrDefault("securityProfileName")
  valid_604088 = validateParameter(valid_604088, JString, required = false,
                                 default = nil)
  if valid_604088 != nil:
    section.add "securityProfileName", valid_604088
  var valid_604089 = query.getOrDefault("thingName")
  valid_604089 = validateParameter(valid_604089, JString, required = false,
                                 default = nil)
  if valid_604089 != nil:
    section.add "thingName", valid_604089
  var valid_604090 = query.getOrDefault("maxResults")
  valid_604090 = validateParameter(valid_604090, JInt, required = false, default = nil)
  if valid_604090 != nil:
    section.add "maxResults", valid_604090
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604091 = header.getOrDefault("X-Amz-Signature")
  valid_604091 = validateParameter(valid_604091, JString, required = false,
                                 default = nil)
  if valid_604091 != nil:
    section.add "X-Amz-Signature", valid_604091
  var valid_604092 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604092 = validateParameter(valid_604092, JString, required = false,
                                 default = nil)
  if valid_604092 != nil:
    section.add "X-Amz-Content-Sha256", valid_604092
  var valid_604093 = header.getOrDefault("X-Amz-Date")
  valid_604093 = validateParameter(valid_604093, JString, required = false,
                                 default = nil)
  if valid_604093 != nil:
    section.add "X-Amz-Date", valid_604093
  var valid_604094 = header.getOrDefault("X-Amz-Credential")
  valid_604094 = validateParameter(valid_604094, JString, required = false,
                                 default = nil)
  if valid_604094 != nil:
    section.add "X-Amz-Credential", valid_604094
  var valid_604095 = header.getOrDefault("X-Amz-Security-Token")
  valid_604095 = validateParameter(valid_604095, JString, required = false,
                                 default = nil)
  if valid_604095 != nil:
    section.add "X-Amz-Security-Token", valid_604095
  var valid_604096 = header.getOrDefault("X-Amz-Algorithm")
  valid_604096 = validateParameter(valid_604096, JString, required = false,
                                 default = nil)
  if valid_604096 != nil:
    section.add "X-Amz-Algorithm", valid_604096
  var valid_604097 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604097 = validateParameter(valid_604097, JString, required = false,
                                 default = nil)
  if valid_604097 != nil:
    section.add "X-Amz-SignedHeaders", valid_604097
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604098: Call_ListActiveViolations_604084; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the active violations for a given Device Defender security profile.
  ## 
  let valid = call_604098.validator(path, query, header, formData, body)
  let scheme = call_604098.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604098.url(scheme.get, call_604098.host, call_604098.base,
                         call_604098.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604098, url, valid)

proc call*(call_604099: Call_ListActiveViolations_604084; nextToken: string = "";
          securityProfileName: string = ""; thingName: string = ""; maxResults: int = 0): Recallable =
  ## listActiveViolations
  ## Lists the active violations for a given Device Defender security profile.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string
  ##                      : The name of the Device Defender security profile for which violations are listed.
  ##   thingName: string
  ##            : The name of the thing whose active violations are listed.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_604100 = newJObject()
  add(query_604100, "nextToken", newJString(nextToken))
  add(query_604100, "securityProfileName", newJString(securityProfileName))
  add(query_604100, "thingName", newJString(thingName))
  add(query_604100, "maxResults", newJInt(maxResults))
  result = call_604099.call(nil, query_604100, nil, nil, nil)

var listActiveViolations* = Call_ListActiveViolations_604084(
    name: "listActiveViolations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/active-violations",
    validator: validate_ListActiveViolations_604085, base: "/",
    url: url_ListActiveViolations_604086, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAttachedPolicies_604101 = ref object of OpenApiRestCall_601389
proc url_ListAttachedPolicies_604103(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "target" in path, "`target` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/attached-policies/"),
               (kind: VariableSegment, value: "target")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListAttachedPolicies_604102(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the policies attached to the specified thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   target: JString (required)
  ##         : The group or principal for which the policies will be listed.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `target` field"
  var valid_604104 = path.getOrDefault("target")
  valid_604104 = validateParameter(valid_604104, JString, required = true,
                                 default = nil)
  if valid_604104 != nil:
    section.add "target", valid_604104
  result.add "path", section
  ## parameters in `query` object:
  ##   pageSize: JInt
  ##           : The maximum number of results to be returned per request.
  ##   recursive: JBool
  ##            : When true, recursively list attached policies.
  ##   marker: JString
  ##         : The token to retrieve the next set of results.
  section = newJObject()
  var valid_604105 = query.getOrDefault("pageSize")
  valid_604105 = validateParameter(valid_604105, JInt, required = false, default = nil)
  if valid_604105 != nil:
    section.add "pageSize", valid_604105
  var valid_604106 = query.getOrDefault("recursive")
  valid_604106 = validateParameter(valid_604106, JBool, required = false, default = nil)
  if valid_604106 != nil:
    section.add "recursive", valid_604106
  var valid_604107 = query.getOrDefault("marker")
  valid_604107 = validateParameter(valid_604107, JString, required = false,
                                 default = nil)
  if valid_604107 != nil:
    section.add "marker", valid_604107
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604108 = header.getOrDefault("X-Amz-Signature")
  valid_604108 = validateParameter(valid_604108, JString, required = false,
                                 default = nil)
  if valid_604108 != nil:
    section.add "X-Amz-Signature", valid_604108
  var valid_604109 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604109 = validateParameter(valid_604109, JString, required = false,
                                 default = nil)
  if valid_604109 != nil:
    section.add "X-Amz-Content-Sha256", valid_604109
  var valid_604110 = header.getOrDefault("X-Amz-Date")
  valid_604110 = validateParameter(valid_604110, JString, required = false,
                                 default = nil)
  if valid_604110 != nil:
    section.add "X-Amz-Date", valid_604110
  var valid_604111 = header.getOrDefault("X-Amz-Credential")
  valid_604111 = validateParameter(valid_604111, JString, required = false,
                                 default = nil)
  if valid_604111 != nil:
    section.add "X-Amz-Credential", valid_604111
  var valid_604112 = header.getOrDefault("X-Amz-Security-Token")
  valid_604112 = validateParameter(valid_604112, JString, required = false,
                                 default = nil)
  if valid_604112 != nil:
    section.add "X-Amz-Security-Token", valid_604112
  var valid_604113 = header.getOrDefault("X-Amz-Algorithm")
  valid_604113 = validateParameter(valid_604113, JString, required = false,
                                 default = nil)
  if valid_604113 != nil:
    section.add "X-Amz-Algorithm", valid_604113
  var valid_604114 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604114 = validateParameter(valid_604114, JString, required = false,
                                 default = nil)
  if valid_604114 != nil:
    section.add "X-Amz-SignedHeaders", valid_604114
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604115: Call_ListAttachedPolicies_604101; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the policies attached to the specified thing group.
  ## 
  let valid = call_604115.validator(path, query, header, formData, body)
  let scheme = call_604115.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604115.url(scheme.get, call_604115.host, call_604115.base,
                         call_604115.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604115, url, valid)

proc call*(call_604116: Call_ListAttachedPolicies_604101; target: string;
          pageSize: int = 0; recursive: bool = false; marker: string = ""): Recallable =
  ## listAttachedPolicies
  ## Lists the policies attached to the specified thing group.
  ##   pageSize: int
  ##           : The maximum number of results to be returned per request.
  ##   recursive: bool
  ##            : When true, recursively list attached policies.
  ##   target: string (required)
  ##         : The group or principal for which the policies will be listed.
  ##   marker: string
  ##         : The token to retrieve the next set of results.
  var path_604117 = newJObject()
  var query_604118 = newJObject()
  add(query_604118, "pageSize", newJInt(pageSize))
  add(query_604118, "recursive", newJBool(recursive))
  add(path_604117, "target", newJString(target))
  add(query_604118, "marker", newJString(marker))
  result = call_604116.call(path_604117, query_604118, nil, nil, nil)

var listAttachedPolicies* = Call_ListAttachedPolicies_604101(
    name: "listAttachedPolicies", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/attached-policies/{target}",
    validator: validate_ListAttachedPolicies_604102, base: "/",
    url: url_ListAttachedPolicies_604103, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditFindings_604119 = ref object of OpenApiRestCall_601389
proc url_ListAuditFindings_604121(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditFindings_604120(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604122 = header.getOrDefault("X-Amz-Signature")
  valid_604122 = validateParameter(valid_604122, JString, required = false,
                                 default = nil)
  if valid_604122 != nil:
    section.add "X-Amz-Signature", valid_604122
  var valid_604123 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604123 = validateParameter(valid_604123, JString, required = false,
                                 default = nil)
  if valid_604123 != nil:
    section.add "X-Amz-Content-Sha256", valid_604123
  var valid_604124 = header.getOrDefault("X-Amz-Date")
  valid_604124 = validateParameter(valid_604124, JString, required = false,
                                 default = nil)
  if valid_604124 != nil:
    section.add "X-Amz-Date", valid_604124
  var valid_604125 = header.getOrDefault("X-Amz-Credential")
  valid_604125 = validateParameter(valid_604125, JString, required = false,
                                 default = nil)
  if valid_604125 != nil:
    section.add "X-Amz-Credential", valid_604125
  var valid_604126 = header.getOrDefault("X-Amz-Security-Token")
  valid_604126 = validateParameter(valid_604126, JString, required = false,
                                 default = nil)
  if valid_604126 != nil:
    section.add "X-Amz-Security-Token", valid_604126
  var valid_604127 = header.getOrDefault("X-Amz-Algorithm")
  valid_604127 = validateParameter(valid_604127, JString, required = false,
                                 default = nil)
  if valid_604127 != nil:
    section.add "X-Amz-Algorithm", valid_604127
  var valid_604128 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604128 = validateParameter(valid_604128, JString, required = false,
                                 default = nil)
  if valid_604128 != nil:
    section.add "X-Amz-SignedHeaders", valid_604128
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604130: Call_ListAuditFindings_604119; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ## 
  let valid = call_604130.validator(path, query, header, formData, body)
  let scheme = call_604130.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604130.url(scheme.get, call_604130.host, call_604130.base,
                         call_604130.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604130, url, valid)

proc call*(call_604131: Call_ListAuditFindings_604119; body: JsonNode): Recallable =
  ## listAuditFindings
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ##   body: JObject (required)
  var body_604132 = newJObject()
  if body != nil:
    body_604132 = body
  result = call_604131.call(nil, nil, nil, nil, body_604132)

var listAuditFindings* = Call_ListAuditFindings_604119(name: "listAuditFindings",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/audit/findings",
    validator: validate_ListAuditFindings_604120, base: "/",
    url: url_ListAuditFindings_604121, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditMitigationActionsExecutions_604133 = ref object of OpenApiRestCall_601389
proc url_ListAuditMitigationActionsExecutions_604135(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditMitigationActionsExecutions_604134(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the status of audit mitigation action tasks that were executed.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   actionStatus: JString
  ##               : Specify this filter to limit results to those with a specific status.
  ##   taskId: JString (required)
  ##         : Specify this filter to limit results to actions for a specific audit mitigation actions task.
  ##   findingId: JString (required)
  ##            : Specify this filter to limit results to those that were applied to a specific audit finding.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  var valid_604136 = query.getOrDefault("nextToken")
  valid_604136 = validateParameter(valid_604136, JString, required = false,
                                 default = nil)
  if valid_604136 != nil:
    section.add "nextToken", valid_604136
  var valid_604137 = query.getOrDefault("actionStatus")
  valid_604137 = validateParameter(valid_604137, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_604137 != nil:
    section.add "actionStatus", valid_604137
  assert query != nil, "query argument is necessary due to required `taskId` field"
  var valid_604138 = query.getOrDefault("taskId")
  valid_604138 = validateParameter(valid_604138, JString, required = true,
                                 default = nil)
  if valid_604138 != nil:
    section.add "taskId", valid_604138
  var valid_604139 = query.getOrDefault("findingId")
  valid_604139 = validateParameter(valid_604139, JString, required = true,
                                 default = nil)
  if valid_604139 != nil:
    section.add "findingId", valid_604139
  var valid_604140 = query.getOrDefault("maxResults")
  valid_604140 = validateParameter(valid_604140, JInt, required = false, default = nil)
  if valid_604140 != nil:
    section.add "maxResults", valid_604140
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604141 = header.getOrDefault("X-Amz-Signature")
  valid_604141 = validateParameter(valid_604141, JString, required = false,
                                 default = nil)
  if valid_604141 != nil:
    section.add "X-Amz-Signature", valid_604141
  var valid_604142 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604142 = validateParameter(valid_604142, JString, required = false,
                                 default = nil)
  if valid_604142 != nil:
    section.add "X-Amz-Content-Sha256", valid_604142
  var valid_604143 = header.getOrDefault("X-Amz-Date")
  valid_604143 = validateParameter(valid_604143, JString, required = false,
                                 default = nil)
  if valid_604143 != nil:
    section.add "X-Amz-Date", valid_604143
  var valid_604144 = header.getOrDefault("X-Amz-Credential")
  valid_604144 = validateParameter(valid_604144, JString, required = false,
                                 default = nil)
  if valid_604144 != nil:
    section.add "X-Amz-Credential", valid_604144
  var valid_604145 = header.getOrDefault("X-Amz-Security-Token")
  valid_604145 = validateParameter(valid_604145, JString, required = false,
                                 default = nil)
  if valid_604145 != nil:
    section.add "X-Amz-Security-Token", valid_604145
  var valid_604146 = header.getOrDefault("X-Amz-Algorithm")
  valid_604146 = validateParameter(valid_604146, JString, required = false,
                                 default = nil)
  if valid_604146 != nil:
    section.add "X-Amz-Algorithm", valid_604146
  var valid_604147 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604147 = validateParameter(valid_604147, JString, required = false,
                                 default = nil)
  if valid_604147 != nil:
    section.add "X-Amz-SignedHeaders", valid_604147
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604148: Call_ListAuditMitigationActionsExecutions_604133;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the status of audit mitigation action tasks that were executed.
  ## 
  let valid = call_604148.validator(path, query, header, formData, body)
  let scheme = call_604148.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604148.url(scheme.get, call_604148.host, call_604148.base,
                         call_604148.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604148, url, valid)

proc call*(call_604149: Call_ListAuditMitigationActionsExecutions_604133;
          taskId: string; findingId: string; nextToken: string = "";
          actionStatus: string = "IN_PROGRESS"; maxResults: int = 0): Recallable =
  ## listAuditMitigationActionsExecutions
  ## Gets the status of audit mitigation action tasks that were executed.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   actionStatus: string
  ##               : Specify this filter to limit results to those with a specific status.
  ##   taskId: string (required)
  ##         : Specify this filter to limit results to actions for a specific audit mitigation actions task.
  ##   findingId: string (required)
  ##            : Specify this filter to limit results to those that were applied to a specific audit finding.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_604150 = newJObject()
  add(query_604150, "nextToken", newJString(nextToken))
  add(query_604150, "actionStatus", newJString(actionStatus))
  add(query_604150, "taskId", newJString(taskId))
  add(query_604150, "findingId", newJString(findingId))
  add(query_604150, "maxResults", newJInt(maxResults))
  result = call_604149.call(nil, query_604150, nil, nil, nil)

var listAuditMitigationActionsExecutions* = Call_ListAuditMitigationActionsExecutions_604133(
    name: "listAuditMitigationActionsExecutions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/executions#taskId&findingId",
    validator: validate_ListAuditMitigationActionsExecutions_604134, base: "/",
    url: url_ListAuditMitigationActionsExecutions_604135,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditMitigationActionsTasks_604151 = ref object of OpenApiRestCall_601389
proc url_ListAuditMitigationActionsTasks_604153(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditMitigationActionsTasks_604152(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endTime: JString (required)
  ##          : Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : Specify this filter to limit results to tasks that began on or after a specific date and time.
  ##   findingId: JString
  ##            : Specify this filter to limit results to tasks that were applied to a specific audit finding.
  ##   taskStatus: JString
  ##             : Specify this filter to limit results to tasks that are in a specific state.
  ##   auditTaskId: JString
  ##              : Specify this filter to limit results to tasks that were applied to results for a specific audit.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_604154 = query.getOrDefault("endTime")
  valid_604154 = validateParameter(valid_604154, JString, required = true,
                                 default = nil)
  if valid_604154 != nil:
    section.add "endTime", valid_604154
  var valid_604155 = query.getOrDefault("nextToken")
  valid_604155 = validateParameter(valid_604155, JString, required = false,
                                 default = nil)
  if valid_604155 != nil:
    section.add "nextToken", valid_604155
  var valid_604156 = query.getOrDefault("startTime")
  valid_604156 = validateParameter(valid_604156, JString, required = true,
                                 default = nil)
  if valid_604156 != nil:
    section.add "startTime", valid_604156
  var valid_604157 = query.getOrDefault("findingId")
  valid_604157 = validateParameter(valid_604157, JString, required = false,
                                 default = nil)
  if valid_604157 != nil:
    section.add "findingId", valid_604157
  var valid_604158 = query.getOrDefault("taskStatus")
  valid_604158 = validateParameter(valid_604158, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_604158 != nil:
    section.add "taskStatus", valid_604158
  var valid_604159 = query.getOrDefault("auditTaskId")
  valid_604159 = validateParameter(valid_604159, JString, required = false,
                                 default = nil)
  if valid_604159 != nil:
    section.add "auditTaskId", valid_604159
  var valid_604160 = query.getOrDefault("maxResults")
  valid_604160 = validateParameter(valid_604160, JInt, required = false, default = nil)
  if valid_604160 != nil:
    section.add "maxResults", valid_604160
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604161 = header.getOrDefault("X-Amz-Signature")
  valid_604161 = validateParameter(valid_604161, JString, required = false,
                                 default = nil)
  if valid_604161 != nil:
    section.add "X-Amz-Signature", valid_604161
  var valid_604162 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604162 = validateParameter(valid_604162, JString, required = false,
                                 default = nil)
  if valid_604162 != nil:
    section.add "X-Amz-Content-Sha256", valid_604162
  var valid_604163 = header.getOrDefault("X-Amz-Date")
  valid_604163 = validateParameter(valid_604163, JString, required = false,
                                 default = nil)
  if valid_604163 != nil:
    section.add "X-Amz-Date", valid_604163
  var valid_604164 = header.getOrDefault("X-Amz-Credential")
  valid_604164 = validateParameter(valid_604164, JString, required = false,
                                 default = nil)
  if valid_604164 != nil:
    section.add "X-Amz-Credential", valid_604164
  var valid_604165 = header.getOrDefault("X-Amz-Security-Token")
  valid_604165 = validateParameter(valid_604165, JString, required = false,
                                 default = nil)
  if valid_604165 != nil:
    section.add "X-Amz-Security-Token", valid_604165
  var valid_604166 = header.getOrDefault("X-Amz-Algorithm")
  valid_604166 = validateParameter(valid_604166, JString, required = false,
                                 default = nil)
  if valid_604166 != nil:
    section.add "X-Amz-Algorithm", valid_604166
  var valid_604167 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604167 = validateParameter(valid_604167, JString, required = false,
                                 default = nil)
  if valid_604167 != nil:
    section.add "X-Amz-SignedHeaders", valid_604167
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604168: Call_ListAuditMitigationActionsTasks_604151;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ## 
  let valid = call_604168.validator(path, query, header, formData, body)
  let scheme = call_604168.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604168.url(scheme.get, call_604168.host, call_604168.base,
                         call_604168.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604168, url, valid)

proc call*(call_604169: Call_ListAuditMitigationActionsTasks_604151;
          endTime: string; startTime: string; nextToken: string = "";
          findingId: string = ""; taskStatus: string = "IN_PROGRESS";
          auditTaskId: string = ""; maxResults: int = 0): Recallable =
  ## listAuditMitigationActionsTasks
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ##   endTime: string (required)
  ##          : Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : Specify this filter to limit results to tasks that began on or after a specific date and time.
  ##   findingId: string
  ##            : Specify this filter to limit results to tasks that were applied to a specific audit finding.
  ##   taskStatus: string
  ##             : Specify this filter to limit results to tasks that are in a specific state.
  ##   auditTaskId: string
  ##              : Specify this filter to limit results to tasks that were applied to results for a specific audit.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_604170 = newJObject()
  add(query_604170, "endTime", newJString(endTime))
  add(query_604170, "nextToken", newJString(nextToken))
  add(query_604170, "startTime", newJString(startTime))
  add(query_604170, "findingId", newJString(findingId))
  add(query_604170, "taskStatus", newJString(taskStatus))
  add(query_604170, "auditTaskId", newJString(auditTaskId))
  add(query_604170, "maxResults", newJInt(maxResults))
  result = call_604169.call(nil, query_604170, nil, nil, nil)

var listAuditMitigationActionsTasks* = Call_ListAuditMitigationActionsTasks_604151(
    name: "listAuditMitigationActionsTasks", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/tasks#startTime&endTime",
    validator: validate_ListAuditMitigationActionsTasks_604152, base: "/",
    url: url_ListAuditMitigationActionsTasks_604153,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditTasks_604171 = ref object of OpenApiRestCall_601389
proc url_ListAuditTasks_604173(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditTasks_604172(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the Device Defender audits that have been performed during a given time period.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endTime: JString (required)
  ##          : The end of the time period.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
  ##   taskStatus: JString
  ##             : A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
  ##   taskType: JString
  ##           : A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_604174 = query.getOrDefault("endTime")
  valid_604174 = validateParameter(valid_604174, JString, required = true,
                                 default = nil)
  if valid_604174 != nil:
    section.add "endTime", valid_604174
  var valid_604175 = query.getOrDefault("nextToken")
  valid_604175 = validateParameter(valid_604175, JString, required = false,
                                 default = nil)
  if valid_604175 != nil:
    section.add "nextToken", valid_604175
  var valid_604176 = query.getOrDefault("startTime")
  valid_604176 = validateParameter(valid_604176, JString, required = true,
                                 default = nil)
  if valid_604176 != nil:
    section.add "startTime", valid_604176
  var valid_604177 = query.getOrDefault("taskStatus")
  valid_604177 = validateParameter(valid_604177, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_604177 != nil:
    section.add "taskStatus", valid_604177
  var valid_604178 = query.getOrDefault("taskType")
  valid_604178 = validateParameter(valid_604178, JString, required = false,
                                 default = newJString("ON_DEMAND_AUDIT_TASK"))
  if valid_604178 != nil:
    section.add "taskType", valid_604178
  var valid_604179 = query.getOrDefault("maxResults")
  valid_604179 = validateParameter(valid_604179, JInt, required = false, default = nil)
  if valid_604179 != nil:
    section.add "maxResults", valid_604179
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604180 = header.getOrDefault("X-Amz-Signature")
  valid_604180 = validateParameter(valid_604180, JString, required = false,
                                 default = nil)
  if valid_604180 != nil:
    section.add "X-Amz-Signature", valid_604180
  var valid_604181 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604181 = validateParameter(valid_604181, JString, required = false,
                                 default = nil)
  if valid_604181 != nil:
    section.add "X-Amz-Content-Sha256", valid_604181
  var valid_604182 = header.getOrDefault("X-Amz-Date")
  valid_604182 = validateParameter(valid_604182, JString, required = false,
                                 default = nil)
  if valid_604182 != nil:
    section.add "X-Amz-Date", valid_604182
  var valid_604183 = header.getOrDefault("X-Amz-Credential")
  valid_604183 = validateParameter(valid_604183, JString, required = false,
                                 default = nil)
  if valid_604183 != nil:
    section.add "X-Amz-Credential", valid_604183
  var valid_604184 = header.getOrDefault("X-Amz-Security-Token")
  valid_604184 = validateParameter(valid_604184, JString, required = false,
                                 default = nil)
  if valid_604184 != nil:
    section.add "X-Amz-Security-Token", valid_604184
  var valid_604185 = header.getOrDefault("X-Amz-Algorithm")
  valid_604185 = validateParameter(valid_604185, JString, required = false,
                                 default = nil)
  if valid_604185 != nil:
    section.add "X-Amz-Algorithm", valid_604185
  var valid_604186 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604186 = validateParameter(valid_604186, JString, required = false,
                                 default = nil)
  if valid_604186 != nil:
    section.add "X-Amz-SignedHeaders", valid_604186
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604187: Call_ListAuditTasks_604171; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender audits that have been performed during a given time period.
  ## 
  let valid = call_604187.validator(path, query, header, formData, body)
  let scheme = call_604187.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604187.url(scheme.get, call_604187.host, call_604187.base,
                         call_604187.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604187, url, valid)

proc call*(call_604188: Call_ListAuditTasks_604171; endTime: string;
          startTime: string; nextToken: string = "";
          taskStatus: string = "IN_PROGRESS";
          taskType: string = "ON_DEMAND_AUDIT_TASK"; maxResults: int = 0): Recallable =
  ## listAuditTasks
  ## Lists the Device Defender audits that have been performed during a given time period.
  ##   endTime: string (required)
  ##          : The end of the time period.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
  ##   taskStatus: string
  ##             : A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
  ##   taskType: string
  ##           : A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_604189 = newJObject()
  add(query_604189, "endTime", newJString(endTime))
  add(query_604189, "nextToken", newJString(nextToken))
  add(query_604189, "startTime", newJString(startTime))
  add(query_604189, "taskStatus", newJString(taskStatus))
  add(query_604189, "taskType", newJString(taskType))
  add(query_604189, "maxResults", newJInt(maxResults))
  result = call_604188.call(nil, query_604189, nil, nil, nil)

var listAuditTasks* = Call_ListAuditTasks_604171(name: "listAuditTasks",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/audit/tasks#startTime&endTime", validator: validate_ListAuditTasks_604172,
    base: "/", url: url_ListAuditTasks_604173, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuthorizers_604190 = ref object of OpenApiRestCall_601389
proc url_ListAuthorizers_604192(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuthorizers_604191(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Lists the authorizers registered in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Return the list of authorizers in ascending alphabetical order.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   status: JString
  ##         : The status of the list authorizers request.
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  section = newJObject()
  var valid_604193 = query.getOrDefault("isAscendingOrder")
  valid_604193 = validateParameter(valid_604193, JBool, required = false, default = nil)
  if valid_604193 != nil:
    section.add "isAscendingOrder", valid_604193
  var valid_604194 = query.getOrDefault("pageSize")
  valid_604194 = validateParameter(valid_604194, JInt, required = false, default = nil)
  if valid_604194 != nil:
    section.add "pageSize", valid_604194
  var valid_604195 = query.getOrDefault("status")
  valid_604195 = validateParameter(valid_604195, JString, required = false,
                                 default = newJString("ACTIVE"))
  if valid_604195 != nil:
    section.add "status", valid_604195
  var valid_604196 = query.getOrDefault("marker")
  valid_604196 = validateParameter(valid_604196, JString, required = false,
                                 default = nil)
  if valid_604196 != nil:
    section.add "marker", valid_604196
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604197 = header.getOrDefault("X-Amz-Signature")
  valid_604197 = validateParameter(valid_604197, JString, required = false,
                                 default = nil)
  if valid_604197 != nil:
    section.add "X-Amz-Signature", valid_604197
  var valid_604198 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604198 = validateParameter(valid_604198, JString, required = false,
                                 default = nil)
  if valid_604198 != nil:
    section.add "X-Amz-Content-Sha256", valid_604198
  var valid_604199 = header.getOrDefault("X-Amz-Date")
  valid_604199 = validateParameter(valid_604199, JString, required = false,
                                 default = nil)
  if valid_604199 != nil:
    section.add "X-Amz-Date", valid_604199
  var valid_604200 = header.getOrDefault("X-Amz-Credential")
  valid_604200 = validateParameter(valid_604200, JString, required = false,
                                 default = nil)
  if valid_604200 != nil:
    section.add "X-Amz-Credential", valid_604200
  var valid_604201 = header.getOrDefault("X-Amz-Security-Token")
  valid_604201 = validateParameter(valid_604201, JString, required = false,
                                 default = nil)
  if valid_604201 != nil:
    section.add "X-Amz-Security-Token", valid_604201
  var valid_604202 = header.getOrDefault("X-Amz-Algorithm")
  valid_604202 = validateParameter(valid_604202, JString, required = false,
                                 default = nil)
  if valid_604202 != nil:
    section.add "X-Amz-Algorithm", valid_604202
  var valid_604203 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604203 = validateParameter(valid_604203, JString, required = false,
                                 default = nil)
  if valid_604203 != nil:
    section.add "X-Amz-SignedHeaders", valid_604203
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604204: Call_ListAuthorizers_604190; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the authorizers registered in your account.
  ## 
  let valid = call_604204.validator(path, query, header, formData, body)
  let scheme = call_604204.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604204.url(scheme.get, call_604204.host, call_604204.base,
                         call_604204.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604204, url, valid)

proc call*(call_604205: Call_ListAuthorizers_604190;
          isAscendingOrder: bool = false; pageSize: int = 0; status: string = "ACTIVE";
          marker: string = ""): Recallable =
  ## listAuthorizers
  ## Lists the authorizers registered in your account.
  ##   isAscendingOrder: bool
  ##                   : Return the list of authorizers in ascending alphabetical order.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   status: string
  ##         : The status of the list authorizers request.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  var query_604206 = newJObject()
  add(query_604206, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_604206, "pageSize", newJInt(pageSize))
  add(query_604206, "status", newJString(status))
  add(query_604206, "marker", newJString(marker))
  result = call_604205.call(nil, query_604206, nil, nil, nil)

var listAuthorizers* = Call_ListAuthorizers_604190(name: "listAuthorizers",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/authorizers/",
    validator: validate_ListAuthorizers_604191, base: "/", url: url_ListAuthorizers_604192,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListBillingGroups_604207 = ref object of OpenApiRestCall_601389
proc url_ListBillingGroups_604209(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListBillingGroups_604208(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Lists the billing groups you have created.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   namePrefixFilter: JString
  ##                   : Limit the results to billing groups whose names have the given prefix.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_604210 = query.getOrDefault("nextToken")
  valid_604210 = validateParameter(valid_604210, JString, required = false,
                                 default = nil)
  if valid_604210 != nil:
    section.add "nextToken", valid_604210
  var valid_604211 = query.getOrDefault("namePrefixFilter")
  valid_604211 = validateParameter(valid_604211, JString, required = false,
                                 default = nil)
  if valid_604211 != nil:
    section.add "namePrefixFilter", valid_604211
  var valid_604212 = query.getOrDefault("maxResults")
  valid_604212 = validateParameter(valid_604212, JInt, required = false, default = nil)
  if valid_604212 != nil:
    section.add "maxResults", valid_604212
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604213 = header.getOrDefault("X-Amz-Signature")
  valid_604213 = validateParameter(valid_604213, JString, required = false,
                                 default = nil)
  if valid_604213 != nil:
    section.add "X-Amz-Signature", valid_604213
  var valid_604214 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604214 = validateParameter(valid_604214, JString, required = false,
                                 default = nil)
  if valid_604214 != nil:
    section.add "X-Amz-Content-Sha256", valid_604214
  var valid_604215 = header.getOrDefault("X-Amz-Date")
  valid_604215 = validateParameter(valid_604215, JString, required = false,
                                 default = nil)
  if valid_604215 != nil:
    section.add "X-Amz-Date", valid_604215
  var valid_604216 = header.getOrDefault("X-Amz-Credential")
  valid_604216 = validateParameter(valid_604216, JString, required = false,
                                 default = nil)
  if valid_604216 != nil:
    section.add "X-Amz-Credential", valid_604216
  var valid_604217 = header.getOrDefault("X-Amz-Security-Token")
  valid_604217 = validateParameter(valid_604217, JString, required = false,
                                 default = nil)
  if valid_604217 != nil:
    section.add "X-Amz-Security-Token", valid_604217
  var valid_604218 = header.getOrDefault("X-Amz-Algorithm")
  valid_604218 = validateParameter(valid_604218, JString, required = false,
                                 default = nil)
  if valid_604218 != nil:
    section.add "X-Amz-Algorithm", valid_604218
  var valid_604219 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604219 = validateParameter(valid_604219, JString, required = false,
                                 default = nil)
  if valid_604219 != nil:
    section.add "X-Amz-SignedHeaders", valid_604219
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604220: Call_ListBillingGroups_604207; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the billing groups you have created.
  ## 
  let valid = call_604220.validator(path, query, header, formData, body)
  let scheme = call_604220.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604220.url(scheme.get, call_604220.host, call_604220.base,
                         call_604220.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604220, url, valid)

proc call*(call_604221: Call_ListBillingGroups_604207; nextToken: string = "";
          namePrefixFilter: string = ""; maxResults: int = 0): Recallable =
  ## listBillingGroups
  ## Lists the billing groups you have created.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   namePrefixFilter: string
  ##                   : Limit the results to billing groups whose names have the given prefix.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var query_604222 = newJObject()
  add(query_604222, "nextToken", newJString(nextToken))
  add(query_604222, "namePrefixFilter", newJString(namePrefixFilter))
  add(query_604222, "maxResults", newJInt(maxResults))
  result = call_604221.call(nil, query_604222, nil, nil, nil)

var listBillingGroups* = Call_ListBillingGroups_604207(name: "listBillingGroups",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/billing-groups",
    validator: validate_ListBillingGroups_604208, base: "/",
    url: url_ListBillingGroups_604209, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCACertificates_604223 = ref object of OpenApiRestCall_601389
proc url_ListCACertificates_604225(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListCACertificates_604224(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Determines the order of the results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_604226 = query.getOrDefault("isAscendingOrder")
  valid_604226 = validateParameter(valid_604226, JBool, required = false, default = nil)
  if valid_604226 != nil:
    section.add "isAscendingOrder", valid_604226
  var valid_604227 = query.getOrDefault("pageSize")
  valid_604227 = validateParameter(valid_604227, JInt, required = false, default = nil)
  if valid_604227 != nil:
    section.add "pageSize", valid_604227
  var valid_604228 = query.getOrDefault("marker")
  valid_604228 = validateParameter(valid_604228, JString, required = false,
                                 default = nil)
  if valid_604228 != nil:
    section.add "marker", valid_604228
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604229 = header.getOrDefault("X-Amz-Signature")
  valid_604229 = validateParameter(valid_604229, JString, required = false,
                                 default = nil)
  if valid_604229 != nil:
    section.add "X-Amz-Signature", valid_604229
  var valid_604230 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604230 = validateParameter(valid_604230, JString, required = false,
                                 default = nil)
  if valid_604230 != nil:
    section.add "X-Amz-Content-Sha256", valid_604230
  var valid_604231 = header.getOrDefault("X-Amz-Date")
  valid_604231 = validateParameter(valid_604231, JString, required = false,
                                 default = nil)
  if valid_604231 != nil:
    section.add "X-Amz-Date", valid_604231
  var valid_604232 = header.getOrDefault("X-Amz-Credential")
  valid_604232 = validateParameter(valid_604232, JString, required = false,
                                 default = nil)
  if valid_604232 != nil:
    section.add "X-Amz-Credential", valid_604232
  var valid_604233 = header.getOrDefault("X-Amz-Security-Token")
  valid_604233 = validateParameter(valid_604233, JString, required = false,
                                 default = nil)
  if valid_604233 != nil:
    section.add "X-Amz-Security-Token", valid_604233
  var valid_604234 = header.getOrDefault("X-Amz-Algorithm")
  valid_604234 = validateParameter(valid_604234, JString, required = false,
                                 default = nil)
  if valid_604234 != nil:
    section.add "X-Amz-Algorithm", valid_604234
  var valid_604235 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604235 = validateParameter(valid_604235, JString, required = false,
                                 default = nil)
  if valid_604235 != nil:
    section.add "X-Amz-SignedHeaders", valid_604235
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604236: Call_ListCACertificates_604223; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  let valid = call_604236.validator(path, query, header, formData, body)
  let scheme = call_604236.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604236.url(scheme.get, call_604236.host, call_604236.base,
                         call_604236.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604236, url, valid)

proc call*(call_604237: Call_ListCACertificates_604223;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listCACertificates
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ##   isAscendingOrder: bool
  ##                   : Determines the order of the results.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_604238 = newJObject()
  add(query_604238, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_604238, "pageSize", newJInt(pageSize))
  add(query_604238, "marker", newJString(marker))
  result = call_604237.call(nil, query_604238, nil, nil, nil)

var listCACertificates* = Call_ListCACertificates_604223(
    name: "listCACertificates", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/cacertificates", validator: validate_ListCACertificates_604224,
    base: "/", url: url_ListCACertificates_604225,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCertificatesByCA_604239 = ref object of OpenApiRestCall_601389
proc url_ListCertificatesByCA_604241(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates-by-ca/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListCertificatesByCA_604240(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List the device certificates signed by the specified CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_604242 = path.getOrDefault("caCertificateId")
  valid_604242 = validateParameter(valid_604242, JString, required = true,
                                 default = nil)
  if valid_604242 != nil:
    section.add "caCertificateId", valid_604242
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_604243 = query.getOrDefault("isAscendingOrder")
  valid_604243 = validateParameter(valid_604243, JBool, required = false, default = nil)
  if valid_604243 != nil:
    section.add "isAscendingOrder", valid_604243
  var valid_604244 = query.getOrDefault("pageSize")
  valid_604244 = validateParameter(valid_604244, JInt, required = false, default = nil)
  if valid_604244 != nil:
    section.add "pageSize", valid_604244
  var valid_604245 = query.getOrDefault("marker")
  valid_604245 = validateParameter(valid_604245, JString, required = false,
                                 default = nil)
  if valid_604245 != nil:
    section.add "marker", valid_604245
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604246 = header.getOrDefault("X-Amz-Signature")
  valid_604246 = validateParameter(valid_604246, JString, required = false,
                                 default = nil)
  if valid_604246 != nil:
    section.add "X-Amz-Signature", valid_604246
  var valid_604247 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604247 = validateParameter(valid_604247, JString, required = false,
                                 default = nil)
  if valid_604247 != nil:
    section.add "X-Amz-Content-Sha256", valid_604247
  var valid_604248 = header.getOrDefault("X-Amz-Date")
  valid_604248 = validateParameter(valid_604248, JString, required = false,
                                 default = nil)
  if valid_604248 != nil:
    section.add "X-Amz-Date", valid_604248
  var valid_604249 = header.getOrDefault("X-Amz-Credential")
  valid_604249 = validateParameter(valid_604249, JString, required = false,
                                 default = nil)
  if valid_604249 != nil:
    section.add "X-Amz-Credential", valid_604249
  var valid_604250 = header.getOrDefault("X-Amz-Security-Token")
  valid_604250 = validateParameter(valid_604250, JString, required = false,
                                 default = nil)
  if valid_604250 != nil:
    section.add "X-Amz-Security-Token", valid_604250
  var valid_604251 = header.getOrDefault("X-Amz-Algorithm")
  valid_604251 = validateParameter(valid_604251, JString, required = false,
                                 default = nil)
  if valid_604251 != nil:
    section.add "X-Amz-Algorithm", valid_604251
  var valid_604252 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604252 = validateParameter(valid_604252, JString, required = false,
                                 default = nil)
  if valid_604252 != nil:
    section.add "X-Amz-SignedHeaders", valid_604252
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604253: Call_ListCertificatesByCA_604239; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the device certificates signed by the specified CA certificate.
  ## 
  let valid = call_604253.validator(path, query, header, formData, body)
  let scheme = call_604253.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604253.url(scheme.get, call_604253.host, call_604253.base,
                         call_604253.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604253, url, valid)

proc call*(call_604254: Call_ListCertificatesByCA_604239; caCertificateId: string;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listCertificatesByCA
  ## List the device certificates signed by the specified CA certificate.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: int
  ##           : The result page size.
  ##   caCertificateId: string (required)
  ##                  : The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
  ##   marker: string
  ##         : The marker for the next set of results.
  var path_604255 = newJObject()
  var query_604256 = newJObject()
  add(query_604256, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_604256, "pageSize", newJInt(pageSize))
  add(path_604255, "caCertificateId", newJString(caCertificateId))
  add(query_604256, "marker", newJString(marker))
  result = call_604254.call(path_604255, query_604256, nil, nil, nil)

var listCertificatesByCA* = Call_ListCertificatesByCA_604239(
    name: "listCertificatesByCA", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates-by-ca/{caCertificateId}",
    validator: validate_ListCertificatesByCA_604240, base: "/",
    url: url_ListCertificatesByCA_604241, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListDomainConfigurations_604257 = ref object of OpenApiRestCall_601389
proc url_ListDomainConfigurations_604259(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListDomainConfigurations_604258(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   pageSize: JInt
  ##           : The result page size.
  ##   serviceType: JString
  ##              : The type of service delivered by the endpoint.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_604260 = query.getOrDefault("pageSize")
  valid_604260 = validateParameter(valid_604260, JInt, required = false, default = nil)
  if valid_604260 != nil:
    section.add "pageSize", valid_604260
  var valid_604261 = query.getOrDefault("serviceType")
  valid_604261 = validateParameter(valid_604261, JString, required = false,
                                 default = newJString("DATA"))
  if valid_604261 != nil:
    section.add "serviceType", valid_604261
  var valid_604262 = query.getOrDefault("marker")
  valid_604262 = validateParameter(valid_604262, JString, required = false,
                                 default = nil)
  if valid_604262 != nil:
    section.add "marker", valid_604262
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604263 = header.getOrDefault("X-Amz-Signature")
  valid_604263 = validateParameter(valid_604263, JString, required = false,
                                 default = nil)
  if valid_604263 != nil:
    section.add "X-Amz-Signature", valid_604263
  var valid_604264 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604264 = validateParameter(valid_604264, JString, required = false,
                                 default = nil)
  if valid_604264 != nil:
    section.add "X-Amz-Content-Sha256", valid_604264
  var valid_604265 = header.getOrDefault("X-Amz-Date")
  valid_604265 = validateParameter(valid_604265, JString, required = false,
                                 default = nil)
  if valid_604265 != nil:
    section.add "X-Amz-Date", valid_604265
  var valid_604266 = header.getOrDefault("X-Amz-Credential")
  valid_604266 = validateParameter(valid_604266, JString, required = false,
                                 default = nil)
  if valid_604266 != nil:
    section.add "X-Amz-Credential", valid_604266
  var valid_604267 = header.getOrDefault("X-Amz-Security-Token")
  valid_604267 = validateParameter(valid_604267, JString, required = false,
                                 default = nil)
  if valid_604267 != nil:
    section.add "X-Amz-Security-Token", valid_604267
  var valid_604268 = header.getOrDefault("X-Amz-Algorithm")
  valid_604268 = validateParameter(valid_604268, JString, required = false,
                                 default = nil)
  if valid_604268 != nil:
    section.add "X-Amz-Algorithm", valid_604268
  var valid_604269 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604269 = validateParameter(valid_604269, JString, required = false,
                                 default = nil)
  if valid_604269 != nil:
    section.add "X-Amz-SignedHeaders", valid_604269
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604270: Call_ListDomainConfigurations_604257; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_604270.validator(path, query, header, formData, body)
  let scheme = call_604270.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604270.url(scheme.get, call_604270.host, call_604270.base,
                         call_604270.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604270, url, valid)

proc call*(call_604271: Call_ListDomainConfigurations_604257; pageSize: int = 0;
          serviceType: string = "DATA"; marker: string = ""): Recallable =
  ## listDomainConfigurations
  ## <p>Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   pageSize: int
  ##           : The result page size.
  ##   serviceType: string
  ##              : The type of service delivered by the endpoint.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_604272 = newJObject()
  add(query_604272, "pageSize", newJInt(pageSize))
  add(query_604272, "serviceType", newJString(serviceType))
  add(query_604272, "marker", newJString(marker))
  result = call_604271.call(nil, query_604272, nil, nil, nil)

var listDomainConfigurations* = Call_ListDomainConfigurations_604257(
    name: "listDomainConfigurations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/domainConfigurations",
    validator: validate_ListDomainConfigurations_604258, base: "/",
    url: url_ListDomainConfigurations_604259, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListIndices_604273 = ref object of OpenApiRestCall_601389
proc url_ListIndices_604275(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListIndices_604274(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the search indices.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token used to get the next set of results, or <code>null</code> if there are no additional results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_604276 = query.getOrDefault("nextToken")
  valid_604276 = validateParameter(valid_604276, JString, required = false,
                                 default = nil)
  if valid_604276 != nil:
    section.add "nextToken", valid_604276
  var valid_604277 = query.getOrDefault("maxResults")
  valid_604277 = validateParameter(valid_604277, JInt, required = false, default = nil)
  if valid_604277 != nil:
    section.add "maxResults", valid_604277
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604278 = header.getOrDefault("X-Amz-Signature")
  valid_604278 = validateParameter(valid_604278, JString, required = false,
                                 default = nil)
  if valid_604278 != nil:
    section.add "X-Amz-Signature", valid_604278
  var valid_604279 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604279 = validateParameter(valid_604279, JString, required = false,
                                 default = nil)
  if valid_604279 != nil:
    section.add "X-Amz-Content-Sha256", valid_604279
  var valid_604280 = header.getOrDefault("X-Amz-Date")
  valid_604280 = validateParameter(valid_604280, JString, required = false,
                                 default = nil)
  if valid_604280 != nil:
    section.add "X-Amz-Date", valid_604280
  var valid_604281 = header.getOrDefault("X-Amz-Credential")
  valid_604281 = validateParameter(valid_604281, JString, required = false,
                                 default = nil)
  if valid_604281 != nil:
    section.add "X-Amz-Credential", valid_604281
  var valid_604282 = header.getOrDefault("X-Amz-Security-Token")
  valid_604282 = validateParameter(valid_604282, JString, required = false,
                                 default = nil)
  if valid_604282 != nil:
    section.add "X-Amz-Security-Token", valid_604282
  var valid_604283 = header.getOrDefault("X-Amz-Algorithm")
  valid_604283 = validateParameter(valid_604283, JString, required = false,
                                 default = nil)
  if valid_604283 != nil:
    section.add "X-Amz-Algorithm", valid_604283
  var valid_604284 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604284 = validateParameter(valid_604284, JString, required = false,
                                 default = nil)
  if valid_604284 != nil:
    section.add "X-Amz-SignedHeaders", valid_604284
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604285: Call_ListIndices_604273; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the search indices.
  ## 
  let valid = call_604285.validator(path, query, header, formData, body)
  let scheme = call_604285.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604285.url(scheme.get, call_604285.host, call_604285.base,
                         call_604285.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604285, url, valid)

proc call*(call_604286: Call_ListIndices_604273; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listIndices
  ## Lists the search indices.
  ##   nextToken: string
  ##            : The token used to get the next set of results, or <code>null</code> if there are no additional results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_604287 = newJObject()
  add(query_604287, "nextToken", newJString(nextToken))
  add(query_604287, "maxResults", newJInt(maxResults))
  result = call_604286.call(nil, query_604287, nil, nil, nil)

var listIndices* = Call_ListIndices_604273(name: "listIndices",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/indices",
                                        validator: validate_ListIndices_604274,
                                        base: "/", url: url_ListIndices_604275,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobExecutionsForJob_604288 = ref object of OpenApiRestCall_601389
proc url_ListJobExecutionsForJob_604290(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListJobExecutionsForJob_604289(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the job executions for a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_604291 = path.getOrDefault("jobId")
  valid_604291 = validateParameter(valid_604291, JString, required = true,
                                 default = nil)
  if valid_604291 != nil:
    section.add "jobId", valid_604291
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : The status of the job.
  ##   maxResults: JInt
  ##             : The maximum number of results to be returned per request.
  section = newJObject()
  var valid_604292 = query.getOrDefault("nextToken")
  valid_604292 = validateParameter(valid_604292, JString, required = false,
                                 default = nil)
  if valid_604292 != nil:
    section.add "nextToken", valid_604292
  var valid_604293 = query.getOrDefault("status")
  valid_604293 = validateParameter(valid_604293, JString, required = false,
                                 default = newJString("QUEUED"))
  if valid_604293 != nil:
    section.add "status", valid_604293
  var valid_604294 = query.getOrDefault("maxResults")
  valid_604294 = validateParameter(valid_604294, JInt, required = false, default = nil)
  if valid_604294 != nil:
    section.add "maxResults", valid_604294
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604295 = header.getOrDefault("X-Amz-Signature")
  valid_604295 = validateParameter(valid_604295, JString, required = false,
                                 default = nil)
  if valid_604295 != nil:
    section.add "X-Amz-Signature", valid_604295
  var valid_604296 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604296 = validateParameter(valid_604296, JString, required = false,
                                 default = nil)
  if valid_604296 != nil:
    section.add "X-Amz-Content-Sha256", valid_604296
  var valid_604297 = header.getOrDefault("X-Amz-Date")
  valid_604297 = validateParameter(valid_604297, JString, required = false,
                                 default = nil)
  if valid_604297 != nil:
    section.add "X-Amz-Date", valid_604297
  var valid_604298 = header.getOrDefault("X-Amz-Credential")
  valid_604298 = validateParameter(valid_604298, JString, required = false,
                                 default = nil)
  if valid_604298 != nil:
    section.add "X-Amz-Credential", valid_604298
  var valid_604299 = header.getOrDefault("X-Amz-Security-Token")
  valid_604299 = validateParameter(valid_604299, JString, required = false,
                                 default = nil)
  if valid_604299 != nil:
    section.add "X-Amz-Security-Token", valid_604299
  var valid_604300 = header.getOrDefault("X-Amz-Algorithm")
  valid_604300 = validateParameter(valid_604300, JString, required = false,
                                 default = nil)
  if valid_604300 != nil:
    section.add "X-Amz-Algorithm", valid_604300
  var valid_604301 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604301 = validateParameter(valid_604301, JString, required = false,
                                 default = nil)
  if valid_604301 != nil:
    section.add "X-Amz-SignedHeaders", valid_604301
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604302: Call_ListJobExecutionsForJob_604288; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the job executions for a job.
  ## 
  let valid = call_604302.validator(path, query, header, formData, body)
  let scheme = call_604302.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604302.url(scheme.get, call_604302.host, call_604302.base,
                         call_604302.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604302, url, valid)

proc call*(call_604303: Call_ListJobExecutionsForJob_604288; jobId: string;
          nextToken: string = ""; status: string = "QUEUED"; maxResults: int = 0): Recallable =
  ## listJobExecutionsForJob
  ## Lists the job executions for a job.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   status: string
  ##         : The status of the job.
  ##   maxResults: int
  ##             : The maximum number of results to be returned per request.
  var path_604304 = newJObject()
  var query_604305 = newJObject()
  add(query_604305, "nextToken", newJString(nextToken))
  add(path_604304, "jobId", newJString(jobId))
  add(query_604305, "status", newJString(status))
  add(query_604305, "maxResults", newJInt(maxResults))
  result = call_604303.call(path_604304, query_604305, nil, nil, nil)

var listJobExecutionsForJob* = Call_ListJobExecutionsForJob_604288(
    name: "listJobExecutionsForJob", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/jobs/{jobId}/things",
    validator: validate_ListJobExecutionsForJob_604289, base: "/",
    url: url_ListJobExecutionsForJob_604290, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobExecutionsForThing_604306 = ref object of OpenApiRestCall_601389
proc url_ListJobExecutionsForThing_604308(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListJobExecutionsForThing_604307(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the job executions for the specified thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The thing name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_604309 = path.getOrDefault("thingName")
  valid_604309 = validateParameter(valid_604309, JString, required = true,
                                 default = nil)
  if valid_604309 != nil:
    section.add "thingName", valid_604309
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: JInt
  ##             : The maximum number of results to be returned per request.
  section = newJObject()
  var valid_604310 = query.getOrDefault("nextToken")
  valid_604310 = validateParameter(valid_604310, JString, required = false,
                                 default = nil)
  if valid_604310 != nil:
    section.add "nextToken", valid_604310
  var valid_604311 = query.getOrDefault("status")
  valid_604311 = validateParameter(valid_604311, JString, required = false,
                                 default = newJString("QUEUED"))
  if valid_604311 != nil:
    section.add "status", valid_604311
  var valid_604312 = query.getOrDefault("maxResults")
  valid_604312 = validateParameter(valid_604312, JInt, required = false, default = nil)
  if valid_604312 != nil:
    section.add "maxResults", valid_604312
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604313 = header.getOrDefault("X-Amz-Signature")
  valid_604313 = validateParameter(valid_604313, JString, required = false,
                                 default = nil)
  if valid_604313 != nil:
    section.add "X-Amz-Signature", valid_604313
  var valid_604314 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604314 = validateParameter(valid_604314, JString, required = false,
                                 default = nil)
  if valid_604314 != nil:
    section.add "X-Amz-Content-Sha256", valid_604314
  var valid_604315 = header.getOrDefault("X-Amz-Date")
  valid_604315 = validateParameter(valid_604315, JString, required = false,
                                 default = nil)
  if valid_604315 != nil:
    section.add "X-Amz-Date", valid_604315
  var valid_604316 = header.getOrDefault("X-Amz-Credential")
  valid_604316 = validateParameter(valid_604316, JString, required = false,
                                 default = nil)
  if valid_604316 != nil:
    section.add "X-Amz-Credential", valid_604316
  var valid_604317 = header.getOrDefault("X-Amz-Security-Token")
  valid_604317 = validateParameter(valid_604317, JString, required = false,
                                 default = nil)
  if valid_604317 != nil:
    section.add "X-Amz-Security-Token", valid_604317
  var valid_604318 = header.getOrDefault("X-Amz-Algorithm")
  valid_604318 = validateParameter(valid_604318, JString, required = false,
                                 default = nil)
  if valid_604318 != nil:
    section.add "X-Amz-Algorithm", valid_604318
  var valid_604319 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604319 = validateParameter(valid_604319, JString, required = false,
                                 default = nil)
  if valid_604319 != nil:
    section.add "X-Amz-SignedHeaders", valid_604319
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604320: Call_ListJobExecutionsForThing_604306; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the job executions for the specified thing.
  ## 
  let valid = call_604320.validator(path, query, header, formData, body)
  let scheme = call_604320.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604320.url(scheme.get, call_604320.host, call_604320.base,
                         call_604320.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604320, url, valid)

proc call*(call_604321: Call_ListJobExecutionsForThing_604306; thingName: string;
          nextToken: string = ""; status: string = "QUEUED"; maxResults: int = 0): Recallable =
  ## listJobExecutionsForThing
  ## Lists the job executions for the specified thing.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingName: string (required)
  ##            : The thing name.
  ##   status: string
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: int
  ##             : The maximum number of results to be returned per request.
  var path_604322 = newJObject()
  var query_604323 = newJObject()
  add(query_604323, "nextToken", newJString(nextToken))
  add(path_604322, "thingName", newJString(thingName))
  add(query_604323, "status", newJString(status))
  add(query_604323, "maxResults", newJInt(maxResults))
  result = call_604321.call(path_604322, query_604323, nil, nil, nil)

var listJobExecutionsForThing* = Call_ListJobExecutionsForThing_604306(
    name: "listJobExecutionsForThing", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs",
    validator: validate_ListJobExecutionsForThing_604307, base: "/",
    url: url_ListJobExecutionsForThing_604308,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobs_604324 = ref object of OpenApiRestCall_601389
proc url_ListJobs_604326(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListJobs_604325(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists jobs.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: JString
  ##                 : A filter that limits the returned jobs to those for the specified group.
  ##   targetSelection: JString
  ##                  : Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. 
  ##   thingGroupId: JString
  ##               : A filter that limits the returned jobs to those for the specified group.
  ##   status: JString
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_604327 = query.getOrDefault("nextToken")
  valid_604327 = validateParameter(valid_604327, JString, required = false,
                                 default = nil)
  if valid_604327 != nil:
    section.add "nextToken", valid_604327
  var valid_604328 = query.getOrDefault("thingGroupName")
  valid_604328 = validateParameter(valid_604328, JString, required = false,
                                 default = nil)
  if valid_604328 != nil:
    section.add "thingGroupName", valid_604328
  var valid_604329 = query.getOrDefault("targetSelection")
  valid_604329 = validateParameter(valid_604329, JString, required = false,
                                 default = newJString("CONTINUOUS"))
  if valid_604329 != nil:
    section.add "targetSelection", valid_604329
  var valid_604330 = query.getOrDefault("thingGroupId")
  valid_604330 = validateParameter(valid_604330, JString, required = false,
                                 default = nil)
  if valid_604330 != nil:
    section.add "thingGroupId", valid_604330
  var valid_604331 = query.getOrDefault("status")
  valid_604331 = validateParameter(valid_604331, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_604331 != nil:
    section.add "status", valid_604331
  var valid_604332 = query.getOrDefault("maxResults")
  valid_604332 = validateParameter(valid_604332, JInt, required = false, default = nil)
  if valid_604332 != nil:
    section.add "maxResults", valid_604332
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604333 = header.getOrDefault("X-Amz-Signature")
  valid_604333 = validateParameter(valid_604333, JString, required = false,
                                 default = nil)
  if valid_604333 != nil:
    section.add "X-Amz-Signature", valid_604333
  var valid_604334 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604334 = validateParameter(valid_604334, JString, required = false,
                                 default = nil)
  if valid_604334 != nil:
    section.add "X-Amz-Content-Sha256", valid_604334
  var valid_604335 = header.getOrDefault("X-Amz-Date")
  valid_604335 = validateParameter(valid_604335, JString, required = false,
                                 default = nil)
  if valid_604335 != nil:
    section.add "X-Amz-Date", valid_604335
  var valid_604336 = header.getOrDefault("X-Amz-Credential")
  valid_604336 = validateParameter(valid_604336, JString, required = false,
                                 default = nil)
  if valid_604336 != nil:
    section.add "X-Amz-Credential", valid_604336
  var valid_604337 = header.getOrDefault("X-Amz-Security-Token")
  valid_604337 = validateParameter(valid_604337, JString, required = false,
                                 default = nil)
  if valid_604337 != nil:
    section.add "X-Amz-Security-Token", valid_604337
  var valid_604338 = header.getOrDefault("X-Amz-Algorithm")
  valid_604338 = validateParameter(valid_604338, JString, required = false,
                                 default = nil)
  if valid_604338 != nil:
    section.add "X-Amz-Algorithm", valid_604338
  var valid_604339 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604339 = validateParameter(valid_604339, JString, required = false,
                                 default = nil)
  if valid_604339 != nil:
    section.add "X-Amz-SignedHeaders", valid_604339
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604340: Call_ListJobs_604324; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists jobs.
  ## 
  let valid = call_604340.validator(path, query, header, formData, body)
  let scheme = call_604340.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604340.url(scheme.get, call_604340.host, call_604340.base,
                         call_604340.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604340, url, valid)

proc call*(call_604341: Call_ListJobs_604324; nextToken: string = "";
          thingGroupName: string = ""; targetSelection: string = "CONTINUOUS";
          thingGroupId: string = ""; status: string = "IN_PROGRESS"; maxResults: int = 0): Recallable =
  ## listJobs
  ## Lists jobs.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: string
  ##                 : A filter that limits the returned jobs to those for the specified group.
  ##   targetSelection: string
  ##                  : Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. 
  ##   thingGroupId: string
  ##               : A filter that limits the returned jobs to those for the specified group.
  ##   status: string
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var query_604342 = newJObject()
  add(query_604342, "nextToken", newJString(nextToken))
  add(query_604342, "thingGroupName", newJString(thingGroupName))
  add(query_604342, "targetSelection", newJString(targetSelection))
  add(query_604342, "thingGroupId", newJString(thingGroupId))
  add(query_604342, "status", newJString(status))
  add(query_604342, "maxResults", newJInt(maxResults))
  result = call_604341.call(nil, query_604342, nil, nil, nil)

var listJobs* = Call_ListJobs_604324(name: "listJobs", meth: HttpMethod.HttpGet,
                                  host: "iot.amazonaws.com", route: "/jobs",
                                  validator: validate_ListJobs_604325, base: "/",
                                  url: url_ListJobs_604326,
                                  schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListMitigationActions_604343 = ref object of OpenApiRestCall_601389
proc url_ListMitigationActions_604345(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListMitigationActions_604344(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   actionType: JString
  ##             : Specify a value to limit the result to mitigation actions with a specific action type.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  var valid_604346 = query.getOrDefault("nextToken")
  valid_604346 = validateParameter(valid_604346, JString, required = false,
                                 default = nil)
  if valid_604346 != nil:
    section.add "nextToken", valid_604346
  var valid_604347 = query.getOrDefault("actionType")
  valid_604347 = validateParameter(valid_604347, JString, required = false, default = newJString(
      "UPDATE_DEVICE_CERTIFICATE"))
  if valid_604347 != nil:
    section.add "actionType", valid_604347
  var valid_604348 = query.getOrDefault("maxResults")
  valid_604348 = validateParameter(valid_604348, JInt, required = false, default = nil)
  if valid_604348 != nil:
    section.add "maxResults", valid_604348
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604349 = header.getOrDefault("X-Amz-Signature")
  valid_604349 = validateParameter(valid_604349, JString, required = false,
                                 default = nil)
  if valid_604349 != nil:
    section.add "X-Amz-Signature", valid_604349
  var valid_604350 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604350 = validateParameter(valid_604350, JString, required = false,
                                 default = nil)
  if valid_604350 != nil:
    section.add "X-Amz-Content-Sha256", valid_604350
  var valid_604351 = header.getOrDefault("X-Amz-Date")
  valid_604351 = validateParameter(valid_604351, JString, required = false,
                                 default = nil)
  if valid_604351 != nil:
    section.add "X-Amz-Date", valid_604351
  var valid_604352 = header.getOrDefault("X-Amz-Credential")
  valid_604352 = validateParameter(valid_604352, JString, required = false,
                                 default = nil)
  if valid_604352 != nil:
    section.add "X-Amz-Credential", valid_604352
  var valid_604353 = header.getOrDefault("X-Amz-Security-Token")
  valid_604353 = validateParameter(valid_604353, JString, required = false,
                                 default = nil)
  if valid_604353 != nil:
    section.add "X-Amz-Security-Token", valid_604353
  var valid_604354 = header.getOrDefault("X-Amz-Algorithm")
  valid_604354 = validateParameter(valid_604354, JString, required = false,
                                 default = nil)
  if valid_604354 != nil:
    section.add "X-Amz-Algorithm", valid_604354
  var valid_604355 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604355 = validateParameter(valid_604355, JString, required = false,
                                 default = nil)
  if valid_604355 != nil:
    section.add "X-Amz-SignedHeaders", valid_604355
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604356: Call_ListMitigationActions_604343; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ## 
  let valid = call_604356.validator(path, query, header, formData, body)
  let scheme = call_604356.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604356.url(scheme.get, call_604356.host, call_604356.base,
                         call_604356.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604356, url, valid)

proc call*(call_604357: Call_ListMitigationActions_604343; nextToken: string = "";
          actionType: string = "UPDATE_DEVICE_CERTIFICATE"; maxResults: int = 0): Recallable =
  ## listMitigationActions
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   actionType: string
  ##             : Specify a value to limit the result to mitigation actions with a specific action type.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_604358 = newJObject()
  add(query_604358, "nextToken", newJString(nextToken))
  add(query_604358, "actionType", newJString(actionType))
  add(query_604358, "maxResults", newJInt(maxResults))
  result = call_604357.call(nil, query_604358, nil, nil, nil)

var listMitigationActions* = Call_ListMitigationActions_604343(
    name: "listMitigationActions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions",
    validator: validate_ListMitigationActions_604344, base: "/",
    url: url_ListMitigationActions_604345, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListOTAUpdates_604359 = ref object of OpenApiRestCall_601389
proc url_ListOTAUpdates_604361(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListOTAUpdates_604360(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists OTA updates.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token used to retrieve the next set of results.
  ##   otaUpdateStatus: JString
  ##                  : The OTA update job status.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_604362 = query.getOrDefault("nextToken")
  valid_604362 = validateParameter(valid_604362, JString, required = false,
                                 default = nil)
  if valid_604362 != nil:
    section.add "nextToken", valid_604362
  var valid_604363 = query.getOrDefault("otaUpdateStatus")
  valid_604363 = validateParameter(valid_604363, JString, required = false,
                                 default = newJString("CREATE_PENDING"))
  if valid_604363 != nil:
    section.add "otaUpdateStatus", valid_604363
  var valid_604364 = query.getOrDefault("maxResults")
  valid_604364 = validateParameter(valid_604364, JInt, required = false, default = nil)
  if valid_604364 != nil:
    section.add "maxResults", valid_604364
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604365 = header.getOrDefault("X-Amz-Signature")
  valid_604365 = validateParameter(valid_604365, JString, required = false,
                                 default = nil)
  if valid_604365 != nil:
    section.add "X-Amz-Signature", valid_604365
  var valid_604366 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604366 = validateParameter(valid_604366, JString, required = false,
                                 default = nil)
  if valid_604366 != nil:
    section.add "X-Amz-Content-Sha256", valid_604366
  var valid_604367 = header.getOrDefault("X-Amz-Date")
  valid_604367 = validateParameter(valid_604367, JString, required = false,
                                 default = nil)
  if valid_604367 != nil:
    section.add "X-Amz-Date", valid_604367
  var valid_604368 = header.getOrDefault("X-Amz-Credential")
  valid_604368 = validateParameter(valid_604368, JString, required = false,
                                 default = nil)
  if valid_604368 != nil:
    section.add "X-Amz-Credential", valid_604368
  var valid_604369 = header.getOrDefault("X-Amz-Security-Token")
  valid_604369 = validateParameter(valid_604369, JString, required = false,
                                 default = nil)
  if valid_604369 != nil:
    section.add "X-Amz-Security-Token", valid_604369
  var valid_604370 = header.getOrDefault("X-Amz-Algorithm")
  valid_604370 = validateParameter(valid_604370, JString, required = false,
                                 default = nil)
  if valid_604370 != nil:
    section.add "X-Amz-Algorithm", valid_604370
  var valid_604371 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604371 = validateParameter(valid_604371, JString, required = false,
                                 default = nil)
  if valid_604371 != nil:
    section.add "X-Amz-SignedHeaders", valid_604371
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604372: Call_ListOTAUpdates_604359; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists OTA updates.
  ## 
  let valid = call_604372.validator(path, query, header, formData, body)
  let scheme = call_604372.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604372.url(scheme.get, call_604372.host, call_604372.base,
                         call_604372.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604372, url, valid)

proc call*(call_604373: Call_ListOTAUpdates_604359; nextToken: string = "";
          otaUpdateStatus: string = "CREATE_PENDING"; maxResults: int = 0): Recallable =
  ## listOTAUpdates
  ## Lists OTA updates.
  ##   nextToken: string
  ##            : A token used to retrieve the next set of results.
  ##   otaUpdateStatus: string
  ##                  : The OTA update job status.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_604374 = newJObject()
  add(query_604374, "nextToken", newJString(nextToken))
  add(query_604374, "otaUpdateStatus", newJString(otaUpdateStatus))
  add(query_604374, "maxResults", newJInt(maxResults))
  result = call_604373.call(nil, query_604374, nil, nil, nil)

var listOTAUpdates* = Call_ListOTAUpdates_604359(name: "listOTAUpdates",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/otaUpdates",
    validator: validate_ListOTAUpdates_604360, base: "/", url: url_ListOTAUpdates_604361,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListOutgoingCertificates_604375 = ref object of OpenApiRestCall_601389
proc url_ListOutgoingCertificates_604377(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListOutgoingCertificates_604376(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists certificates that are being transferred but not yet accepted.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_604378 = query.getOrDefault("isAscendingOrder")
  valid_604378 = validateParameter(valid_604378, JBool, required = false, default = nil)
  if valid_604378 != nil:
    section.add "isAscendingOrder", valid_604378
  var valid_604379 = query.getOrDefault("pageSize")
  valid_604379 = validateParameter(valid_604379, JInt, required = false, default = nil)
  if valid_604379 != nil:
    section.add "pageSize", valid_604379
  var valid_604380 = query.getOrDefault("marker")
  valid_604380 = validateParameter(valid_604380, JString, required = false,
                                 default = nil)
  if valid_604380 != nil:
    section.add "marker", valid_604380
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604381 = header.getOrDefault("X-Amz-Signature")
  valid_604381 = validateParameter(valid_604381, JString, required = false,
                                 default = nil)
  if valid_604381 != nil:
    section.add "X-Amz-Signature", valid_604381
  var valid_604382 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604382 = validateParameter(valid_604382, JString, required = false,
                                 default = nil)
  if valid_604382 != nil:
    section.add "X-Amz-Content-Sha256", valid_604382
  var valid_604383 = header.getOrDefault("X-Amz-Date")
  valid_604383 = validateParameter(valid_604383, JString, required = false,
                                 default = nil)
  if valid_604383 != nil:
    section.add "X-Amz-Date", valid_604383
  var valid_604384 = header.getOrDefault("X-Amz-Credential")
  valid_604384 = validateParameter(valid_604384, JString, required = false,
                                 default = nil)
  if valid_604384 != nil:
    section.add "X-Amz-Credential", valid_604384
  var valid_604385 = header.getOrDefault("X-Amz-Security-Token")
  valid_604385 = validateParameter(valid_604385, JString, required = false,
                                 default = nil)
  if valid_604385 != nil:
    section.add "X-Amz-Security-Token", valid_604385
  var valid_604386 = header.getOrDefault("X-Amz-Algorithm")
  valid_604386 = validateParameter(valid_604386, JString, required = false,
                                 default = nil)
  if valid_604386 != nil:
    section.add "X-Amz-Algorithm", valid_604386
  var valid_604387 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604387 = validateParameter(valid_604387, JString, required = false,
                                 default = nil)
  if valid_604387 != nil:
    section.add "X-Amz-SignedHeaders", valid_604387
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604388: Call_ListOutgoingCertificates_604375; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists certificates that are being transferred but not yet accepted.
  ## 
  let valid = call_604388.validator(path, query, header, formData, body)
  let scheme = call_604388.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604388.url(scheme.get, call_604388.host, call_604388.base,
                         call_604388.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604388, url, valid)

proc call*(call_604389: Call_ListOutgoingCertificates_604375;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listOutgoingCertificates
  ## Lists certificates that are being transferred but not yet accepted.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_604390 = newJObject()
  add(query_604390, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_604390, "pageSize", newJInt(pageSize))
  add(query_604390, "marker", newJString(marker))
  result = call_604389.call(nil, query_604390, nil, nil, nil)

var listOutgoingCertificates* = Call_ListOutgoingCertificates_604375(
    name: "listOutgoingCertificates", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates-out-going",
    validator: validate_ListOutgoingCertificates_604376, base: "/",
    url: url_ListOutgoingCertificates_604377, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicies_604391 = ref object of OpenApiRestCall_601389
proc url_ListPolicies_604393(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPolicies_604392(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists your policies.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_604394 = query.getOrDefault("isAscendingOrder")
  valid_604394 = validateParameter(valid_604394, JBool, required = false, default = nil)
  if valid_604394 != nil:
    section.add "isAscendingOrder", valid_604394
  var valid_604395 = query.getOrDefault("pageSize")
  valid_604395 = validateParameter(valid_604395, JInt, required = false, default = nil)
  if valid_604395 != nil:
    section.add "pageSize", valid_604395
  var valid_604396 = query.getOrDefault("marker")
  valid_604396 = validateParameter(valid_604396, JString, required = false,
                                 default = nil)
  if valid_604396 != nil:
    section.add "marker", valid_604396
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604397 = header.getOrDefault("X-Amz-Signature")
  valid_604397 = validateParameter(valid_604397, JString, required = false,
                                 default = nil)
  if valid_604397 != nil:
    section.add "X-Amz-Signature", valid_604397
  var valid_604398 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604398 = validateParameter(valid_604398, JString, required = false,
                                 default = nil)
  if valid_604398 != nil:
    section.add "X-Amz-Content-Sha256", valid_604398
  var valid_604399 = header.getOrDefault("X-Amz-Date")
  valid_604399 = validateParameter(valid_604399, JString, required = false,
                                 default = nil)
  if valid_604399 != nil:
    section.add "X-Amz-Date", valid_604399
  var valid_604400 = header.getOrDefault("X-Amz-Credential")
  valid_604400 = validateParameter(valid_604400, JString, required = false,
                                 default = nil)
  if valid_604400 != nil:
    section.add "X-Amz-Credential", valid_604400
  var valid_604401 = header.getOrDefault("X-Amz-Security-Token")
  valid_604401 = validateParameter(valid_604401, JString, required = false,
                                 default = nil)
  if valid_604401 != nil:
    section.add "X-Amz-Security-Token", valid_604401
  var valid_604402 = header.getOrDefault("X-Amz-Algorithm")
  valid_604402 = validateParameter(valid_604402, JString, required = false,
                                 default = nil)
  if valid_604402 != nil:
    section.add "X-Amz-Algorithm", valid_604402
  var valid_604403 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604403 = validateParameter(valid_604403, JString, required = false,
                                 default = nil)
  if valid_604403 != nil:
    section.add "X-Amz-SignedHeaders", valid_604403
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604404: Call_ListPolicies_604391; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists your policies.
  ## 
  let valid = call_604404.validator(path, query, header, formData, body)
  let scheme = call_604404.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604404.url(scheme.get, call_604404.host, call_604404.base,
                         call_604404.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604404, url, valid)

proc call*(call_604405: Call_ListPolicies_604391; isAscendingOrder: bool = false;
          pageSize: int = 0; marker: string = ""): Recallable =
  ## listPolicies
  ## Lists your policies.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_604406 = newJObject()
  add(query_604406, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_604406, "pageSize", newJInt(pageSize))
  add(query_604406, "marker", newJString(marker))
  result = call_604405.call(nil, query_604406, nil, nil, nil)

var listPolicies* = Call_ListPolicies_604391(name: "listPolicies",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/policies",
    validator: validate_ListPolicies_604392, base: "/", url: url_ListPolicies_604393,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicyPrincipals_604407 = ref object of OpenApiRestCall_601389
proc url_ListPolicyPrincipals_604409(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPolicyPrincipals_604408(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_604410 = query.getOrDefault("isAscendingOrder")
  valid_604410 = validateParameter(valid_604410, JBool, required = false, default = nil)
  if valid_604410 != nil:
    section.add "isAscendingOrder", valid_604410
  var valid_604411 = query.getOrDefault("pageSize")
  valid_604411 = validateParameter(valid_604411, JInt, required = false, default = nil)
  if valid_604411 != nil:
    section.add "pageSize", valid_604411
  var valid_604412 = query.getOrDefault("marker")
  valid_604412 = validateParameter(valid_604412, JString, required = false,
                                 default = nil)
  if valid_604412 != nil:
    section.add "marker", valid_604412
  result.add "query", section
  ## parameters in `header` object:
  ##   x-amzn-iot-policy: JString (required)
  ##                    : The policy name.
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-policy` field"
  var valid_604413 = header.getOrDefault("x-amzn-iot-policy")
  valid_604413 = validateParameter(valid_604413, JString, required = true,
                                 default = nil)
  if valid_604413 != nil:
    section.add "x-amzn-iot-policy", valid_604413
  var valid_604414 = header.getOrDefault("X-Amz-Signature")
  valid_604414 = validateParameter(valid_604414, JString, required = false,
                                 default = nil)
  if valid_604414 != nil:
    section.add "X-Amz-Signature", valid_604414
  var valid_604415 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604415 = validateParameter(valid_604415, JString, required = false,
                                 default = nil)
  if valid_604415 != nil:
    section.add "X-Amz-Content-Sha256", valid_604415
  var valid_604416 = header.getOrDefault("X-Amz-Date")
  valid_604416 = validateParameter(valid_604416, JString, required = false,
                                 default = nil)
  if valid_604416 != nil:
    section.add "X-Amz-Date", valid_604416
  var valid_604417 = header.getOrDefault("X-Amz-Credential")
  valid_604417 = validateParameter(valid_604417, JString, required = false,
                                 default = nil)
  if valid_604417 != nil:
    section.add "X-Amz-Credential", valid_604417
  var valid_604418 = header.getOrDefault("X-Amz-Security-Token")
  valid_604418 = validateParameter(valid_604418, JString, required = false,
                                 default = nil)
  if valid_604418 != nil:
    section.add "X-Amz-Security-Token", valid_604418
  var valid_604419 = header.getOrDefault("X-Amz-Algorithm")
  valid_604419 = validateParameter(valid_604419, JString, required = false,
                                 default = nil)
  if valid_604419 != nil:
    section.add "X-Amz-Algorithm", valid_604419
  var valid_604420 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604420 = validateParameter(valid_604420, JString, required = false,
                                 default = nil)
  if valid_604420 != nil:
    section.add "X-Amz-SignedHeaders", valid_604420
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604421: Call_ListPolicyPrincipals_604407; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ## 
  let valid = call_604421.validator(path, query, header, formData, body)
  let scheme = call_604421.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604421.url(scheme.get, call_604421.host, call_604421.base,
                         call_604421.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604421, url, valid)

proc call*(call_604422: Call_ListPolicyPrincipals_604407;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listPolicyPrincipals
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_604423 = newJObject()
  add(query_604423, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_604423, "pageSize", newJInt(pageSize))
  add(query_604423, "marker", newJString(marker))
  result = call_604422.call(nil, query_604423, nil, nil, nil)

var listPolicyPrincipals* = Call_ListPolicyPrincipals_604407(
    name: "listPolicyPrincipals", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/policy-principals#x-amzn-iot-policy",
    validator: validate_ListPolicyPrincipals_604408, base: "/",
    url: url_ListPolicyPrincipals_604409, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPrincipalPolicies_604424 = ref object of OpenApiRestCall_601389
proc url_ListPrincipalPolicies_604426(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPrincipalPolicies_604425(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, results are returned in ascending creation order.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_604427 = query.getOrDefault("isAscendingOrder")
  valid_604427 = validateParameter(valid_604427, JBool, required = false, default = nil)
  if valid_604427 != nil:
    section.add "isAscendingOrder", valid_604427
  var valid_604428 = query.getOrDefault("pageSize")
  valid_604428 = validateParameter(valid_604428, JInt, required = false, default = nil)
  if valid_604428 != nil:
    section.add "pageSize", valid_604428
  var valid_604429 = query.getOrDefault("marker")
  valid_604429 = validateParameter(valid_604429, JString, required = false,
                                 default = nil)
  if valid_604429 != nil:
    section.add "marker", valid_604429
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : The principal.
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604430 = header.getOrDefault("X-Amz-Signature")
  valid_604430 = validateParameter(valid_604430, JString, required = false,
                                 default = nil)
  if valid_604430 != nil:
    section.add "X-Amz-Signature", valid_604430
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_604431 = header.getOrDefault("x-amzn-iot-principal")
  valid_604431 = validateParameter(valid_604431, JString, required = true,
                                 default = nil)
  if valid_604431 != nil:
    section.add "x-amzn-iot-principal", valid_604431
  var valid_604432 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604432 = validateParameter(valid_604432, JString, required = false,
                                 default = nil)
  if valid_604432 != nil:
    section.add "X-Amz-Content-Sha256", valid_604432
  var valid_604433 = header.getOrDefault("X-Amz-Date")
  valid_604433 = validateParameter(valid_604433, JString, required = false,
                                 default = nil)
  if valid_604433 != nil:
    section.add "X-Amz-Date", valid_604433
  var valid_604434 = header.getOrDefault("X-Amz-Credential")
  valid_604434 = validateParameter(valid_604434, JString, required = false,
                                 default = nil)
  if valid_604434 != nil:
    section.add "X-Amz-Credential", valid_604434
  var valid_604435 = header.getOrDefault("X-Amz-Security-Token")
  valid_604435 = validateParameter(valid_604435, JString, required = false,
                                 default = nil)
  if valid_604435 != nil:
    section.add "X-Amz-Security-Token", valid_604435
  var valid_604436 = header.getOrDefault("X-Amz-Algorithm")
  valid_604436 = validateParameter(valid_604436, JString, required = false,
                                 default = nil)
  if valid_604436 != nil:
    section.add "X-Amz-Algorithm", valid_604436
  var valid_604437 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604437 = validateParameter(valid_604437, JString, required = false,
                                 default = nil)
  if valid_604437 != nil:
    section.add "X-Amz-SignedHeaders", valid_604437
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604438: Call_ListPrincipalPolicies_604424; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ## 
  let valid = call_604438.validator(path, query, header, formData, body)
  let scheme = call_604438.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604438.url(scheme.get, call_604438.host, call_604438.base,
                         call_604438.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604438, url, valid)

proc call*(call_604439: Call_ListPrincipalPolicies_604424;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listPrincipalPolicies
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, results are returned in ascending creation order.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_604440 = newJObject()
  add(query_604440, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_604440, "pageSize", newJInt(pageSize))
  add(query_604440, "marker", newJString(marker))
  result = call_604439.call(nil, query_604440, nil, nil, nil)

var listPrincipalPolicies* = Call_ListPrincipalPolicies_604424(
    name: "listPrincipalPolicies", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/principal-policies#x-amzn-iot-principal",
    validator: validate_ListPrincipalPolicies_604425, base: "/",
    url: url_ListPrincipalPolicies_604426, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPrincipalThings_604441 = ref object of OpenApiRestCall_601389
proc url_ListPrincipalThings_604443(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPrincipalThings_604442(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  section = newJObject()
  var valid_604444 = query.getOrDefault("nextToken")
  valid_604444 = validateParameter(valid_604444, JString, required = false,
                                 default = nil)
  if valid_604444 != nil:
    section.add "nextToken", valid_604444
  var valid_604445 = query.getOrDefault("maxResults")
  valid_604445 = validateParameter(valid_604445, JInt, required = false, default = nil)
  if valid_604445 != nil:
    section.add "maxResults", valid_604445
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : The principal.
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604446 = header.getOrDefault("X-Amz-Signature")
  valid_604446 = validateParameter(valid_604446, JString, required = false,
                                 default = nil)
  if valid_604446 != nil:
    section.add "X-Amz-Signature", valid_604446
  var valid_604447 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604447 = validateParameter(valid_604447, JString, required = false,
                                 default = nil)
  if valid_604447 != nil:
    section.add "X-Amz-Content-Sha256", valid_604447
  var valid_604448 = header.getOrDefault("X-Amz-Date")
  valid_604448 = validateParameter(valid_604448, JString, required = false,
                                 default = nil)
  if valid_604448 != nil:
    section.add "X-Amz-Date", valid_604448
  var valid_604449 = header.getOrDefault("X-Amz-Credential")
  valid_604449 = validateParameter(valid_604449, JString, required = false,
                                 default = nil)
  if valid_604449 != nil:
    section.add "X-Amz-Credential", valid_604449
  var valid_604450 = header.getOrDefault("X-Amz-Security-Token")
  valid_604450 = validateParameter(valid_604450, JString, required = false,
                                 default = nil)
  if valid_604450 != nil:
    section.add "X-Amz-Security-Token", valid_604450
  var valid_604451 = header.getOrDefault("X-Amz-Algorithm")
  valid_604451 = validateParameter(valid_604451, JString, required = false,
                                 default = nil)
  if valid_604451 != nil:
    section.add "X-Amz-Algorithm", valid_604451
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_604452 = header.getOrDefault("x-amzn-principal")
  valid_604452 = validateParameter(valid_604452, JString, required = true,
                                 default = nil)
  if valid_604452 != nil:
    section.add "x-amzn-principal", valid_604452
  var valid_604453 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604453 = validateParameter(valid_604453, JString, required = false,
                                 default = nil)
  if valid_604453 != nil:
    section.add "X-Amz-SignedHeaders", valid_604453
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604454: Call_ListPrincipalThings_604441; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ## 
  let valid = call_604454.validator(path, query, header, formData, body)
  let scheme = call_604454.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604454.url(scheme.get, call_604454.host, call_604454.base,
                         call_604454.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604454, url, valid)

proc call*(call_604455: Call_ListPrincipalThings_604441; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listPrincipalThings
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  var query_604456 = newJObject()
  add(query_604456, "nextToken", newJString(nextToken))
  add(query_604456, "maxResults", newJInt(maxResults))
  result = call_604455.call(nil, query_604456, nil, nil, nil)

var listPrincipalThings* = Call_ListPrincipalThings_604441(
    name: "listPrincipalThings", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/principals/things#x-amzn-principal",
    validator: validate_ListPrincipalThings_604442, base: "/",
    url: url_ListPrincipalThings_604443, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListRoleAliases_604457 = ref object of OpenApiRestCall_601389
proc url_ListRoleAliases_604459(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListRoleAliases_604458(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Lists the role aliases registered in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Return the list of role aliases in ascending alphabetical order.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  section = newJObject()
  var valid_604460 = query.getOrDefault("isAscendingOrder")
  valid_604460 = validateParameter(valid_604460, JBool, required = false, default = nil)
  if valid_604460 != nil:
    section.add "isAscendingOrder", valid_604460
  var valid_604461 = query.getOrDefault("pageSize")
  valid_604461 = validateParameter(valid_604461, JInt, required = false, default = nil)
  if valid_604461 != nil:
    section.add "pageSize", valid_604461
  var valid_604462 = query.getOrDefault("marker")
  valid_604462 = validateParameter(valid_604462, JString, required = false,
                                 default = nil)
  if valid_604462 != nil:
    section.add "marker", valid_604462
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604463 = header.getOrDefault("X-Amz-Signature")
  valid_604463 = validateParameter(valid_604463, JString, required = false,
                                 default = nil)
  if valid_604463 != nil:
    section.add "X-Amz-Signature", valid_604463
  var valid_604464 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604464 = validateParameter(valid_604464, JString, required = false,
                                 default = nil)
  if valid_604464 != nil:
    section.add "X-Amz-Content-Sha256", valid_604464
  var valid_604465 = header.getOrDefault("X-Amz-Date")
  valid_604465 = validateParameter(valid_604465, JString, required = false,
                                 default = nil)
  if valid_604465 != nil:
    section.add "X-Amz-Date", valid_604465
  var valid_604466 = header.getOrDefault("X-Amz-Credential")
  valid_604466 = validateParameter(valid_604466, JString, required = false,
                                 default = nil)
  if valid_604466 != nil:
    section.add "X-Amz-Credential", valid_604466
  var valid_604467 = header.getOrDefault("X-Amz-Security-Token")
  valid_604467 = validateParameter(valid_604467, JString, required = false,
                                 default = nil)
  if valid_604467 != nil:
    section.add "X-Amz-Security-Token", valid_604467
  var valid_604468 = header.getOrDefault("X-Amz-Algorithm")
  valid_604468 = validateParameter(valid_604468, JString, required = false,
                                 default = nil)
  if valid_604468 != nil:
    section.add "X-Amz-Algorithm", valid_604468
  var valid_604469 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604469 = validateParameter(valid_604469, JString, required = false,
                                 default = nil)
  if valid_604469 != nil:
    section.add "X-Amz-SignedHeaders", valid_604469
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604470: Call_ListRoleAliases_604457; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the role aliases registered in your account.
  ## 
  let valid = call_604470.validator(path, query, header, formData, body)
  let scheme = call_604470.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604470.url(scheme.get, call_604470.host, call_604470.base,
                         call_604470.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604470, url, valid)

proc call*(call_604471: Call_ListRoleAliases_604457;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listRoleAliases
  ## Lists the role aliases registered in your account.
  ##   isAscendingOrder: bool
  ##                   : Return the list of role aliases in ascending alphabetical order.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  var query_604472 = newJObject()
  add(query_604472, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_604472, "pageSize", newJInt(pageSize))
  add(query_604472, "marker", newJString(marker))
  result = call_604471.call(nil, query_604472, nil, nil, nil)

var listRoleAliases* = Call_ListRoleAliases_604457(name: "listRoleAliases",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/role-aliases",
    validator: validate_ListRoleAliases_604458, base: "/", url: url_ListRoleAliases_604459,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListScheduledAudits_604473 = ref object of OpenApiRestCall_601389
proc url_ListScheduledAudits_604475(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListScheduledAudits_604474(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists all of your scheduled audits.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  var valid_604476 = query.getOrDefault("nextToken")
  valid_604476 = validateParameter(valid_604476, JString, required = false,
                                 default = nil)
  if valid_604476 != nil:
    section.add "nextToken", valid_604476
  var valid_604477 = query.getOrDefault("maxResults")
  valid_604477 = validateParameter(valid_604477, JInt, required = false, default = nil)
  if valid_604477 != nil:
    section.add "maxResults", valid_604477
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604478 = header.getOrDefault("X-Amz-Signature")
  valid_604478 = validateParameter(valid_604478, JString, required = false,
                                 default = nil)
  if valid_604478 != nil:
    section.add "X-Amz-Signature", valid_604478
  var valid_604479 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604479 = validateParameter(valid_604479, JString, required = false,
                                 default = nil)
  if valid_604479 != nil:
    section.add "X-Amz-Content-Sha256", valid_604479
  var valid_604480 = header.getOrDefault("X-Amz-Date")
  valid_604480 = validateParameter(valid_604480, JString, required = false,
                                 default = nil)
  if valid_604480 != nil:
    section.add "X-Amz-Date", valid_604480
  var valid_604481 = header.getOrDefault("X-Amz-Credential")
  valid_604481 = validateParameter(valid_604481, JString, required = false,
                                 default = nil)
  if valid_604481 != nil:
    section.add "X-Amz-Credential", valid_604481
  var valid_604482 = header.getOrDefault("X-Amz-Security-Token")
  valid_604482 = validateParameter(valid_604482, JString, required = false,
                                 default = nil)
  if valid_604482 != nil:
    section.add "X-Amz-Security-Token", valid_604482
  var valid_604483 = header.getOrDefault("X-Amz-Algorithm")
  valid_604483 = validateParameter(valid_604483, JString, required = false,
                                 default = nil)
  if valid_604483 != nil:
    section.add "X-Amz-Algorithm", valid_604483
  var valid_604484 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604484 = validateParameter(valid_604484, JString, required = false,
                                 default = nil)
  if valid_604484 != nil:
    section.add "X-Amz-SignedHeaders", valid_604484
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604485: Call_ListScheduledAudits_604473; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all of your scheduled audits.
  ## 
  let valid = call_604485.validator(path, query, header, formData, body)
  let scheme = call_604485.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604485.url(scheme.get, call_604485.host, call_604485.base,
                         call_604485.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604485, url, valid)

proc call*(call_604486: Call_ListScheduledAudits_604473; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listScheduledAudits
  ## Lists all of your scheduled audits.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_604487 = newJObject()
  add(query_604487, "nextToken", newJString(nextToken))
  add(query_604487, "maxResults", newJInt(maxResults))
  result = call_604486.call(nil, query_604487, nil, nil, nil)

var listScheduledAudits* = Call_ListScheduledAudits_604473(
    name: "listScheduledAudits", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/scheduledaudits",
    validator: validate_ListScheduledAudits_604474, base: "/",
    url: url_ListScheduledAudits_604475, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListSecurityProfiles_604488 = ref object of OpenApiRestCall_601389
proc url_ListSecurityProfiles_604490(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListSecurityProfiles_604489(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_604491 = query.getOrDefault("nextToken")
  valid_604491 = validateParameter(valid_604491, JString, required = false,
                                 default = nil)
  if valid_604491 != nil:
    section.add "nextToken", valid_604491
  var valid_604492 = query.getOrDefault("maxResults")
  valid_604492 = validateParameter(valid_604492, JInt, required = false, default = nil)
  if valid_604492 != nil:
    section.add "maxResults", valid_604492
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604493 = header.getOrDefault("X-Amz-Signature")
  valid_604493 = validateParameter(valid_604493, JString, required = false,
                                 default = nil)
  if valid_604493 != nil:
    section.add "X-Amz-Signature", valid_604493
  var valid_604494 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604494 = validateParameter(valid_604494, JString, required = false,
                                 default = nil)
  if valid_604494 != nil:
    section.add "X-Amz-Content-Sha256", valid_604494
  var valid_604495 = header.getOrDefault("X-Amz-Date")
  valid_604495 = validateParameter(valid_604495, JString, required = false,
                                 default = nil)
  if valid_604495 != nil:
    section.add "X-Amz-Date", valid_604495
  var valid_604496 = header.getOrDefault("X-Amz-Credential")
  valid_604496 = validateParameter(valid_604496, JString, required = false,
                                 default = nil)
  if valid_604496 != nil:
    section.add "X-Amz-Credential", valid_604496
  var valid_604497 = header.getOrDefault("X-Amz-Security-Token")
  valid_604497 = validateParameter(valid_604497, JString, required = false,
                                 default = nil)
  if valid_604497 != nil:
    section.add "X-Amz-Security-Token", valid_604497
  var valid_604498 = header.getOrDefault("X-Amz-Algorithm")
  valid_604498 = validateParameter(valid_604498, JString, required = false,
                                 default = nil)
  if valid_604498 != nil:
    section.add "X-Amz-Algorithm", valid_604498
  var valid_604499 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604499 = validateParameter(valid_604499, JString, required = false,
                                 default = nil)
  if valid_604499 != nil:
    section.add "X-Amz-SignedHeaders", valid_604499
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604500: Call_ListSecurityProfiles_604488; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ## 
  let valid = call_604500.validator(path, query, header, formData, body)
  let scheme = call_604500.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604500.url(scheme.get, call_604500.host, call_604500.base,
                         call_604500.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604500, url, valid)

proc call*(call_604501: Call_ListSecurityProfiles_604488; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listSecurityProfiles
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_604502 = newJObject()
  add(query_604502, "nextToken", newJString(nextToken))
  add(query_604502, "maxResults", newJInt(maxResults))
  result = call_604501.call(nil, query_604502, nil, nil, nil)

var listSecurityProfiles* = Call_ListSecurityProfiles_604488(
    name: "listSecurityProfiles", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/security-profiles",
    validator: validate_ListSecurityProfiles_604489, base: "/",
    url: url_ListSecurityProfiles_604490, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListSecurityProfilesForTarget_604503 = ref object of OpenApiRestCall_601389
proc url_ListSecurityProfilesForTarget_604505(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListSecurityProfilesForTarget_604504(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   recursive: JBool
  ##            : If true, return child groups too.
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the target (thing group) whose attached security profiles you want to get.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_604506 = query.getOrDefault("nextToken")
  valid_604506 = validateParameter(valid_604506, JString, required = false,
                                 default = nil)
  if valid_604506 != nil:
    section.add "nextToken", valid_604506
  var valid_604507 = query.getOrDefault("recursive")
  valid_604507 = validateParameter(valid_604507, JBool, required = false, default = nil)
  if valid_604507 != nil:
    section.add "recursive", valid_604507
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_604508 = query.getOrDefault("securityProfileTargetArn")
  valid_604508 = validateParameter(valid_604508, JString, required = true,
                                 default = nil)
  if valid_604508 != nil:
    section.add "securityProfileTargetArn", valid_604508
  var valid_604509 = query.getOrDefault("maxResults")
  valid_604509 = validateParameter(valid_604509, JInt, required = false, default = nil)
  if valid_604509 != nil:
    section.add "maxResults", valid_604509
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604510 = header.getOrDefault("X-Amz-Signature")
  valid_604510 = validateParameter(valid_604510, JString, required = false,
                                 default = nil)
  if valid_604510 != nil:
    section.add "X-Amz-Signature", valid_604510
  var valid_604511 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604511 = validateParameter(valid_604511, JString, required = false,
                                 default = nil)
  if valid_604511 != nil:
    section.add "X-Amz-Content-Sha256", valid_604511
  var valid_604512 = header.getOrDefault("X-Amz-Date")
  valid_604512 = validateParameter(valid_604512, JString, required = false,
                                 default = nil)
  if valid_604512 != nil:
    section.add "X-Amz-Date", valid_604512
  var valid_604513 = header.getOrDefault("X-Amz-Credential")
  valid_604513 = validateParameter(valid_604513, JString, required = false,
                                 default = nil)
  if valid_604513 != nil:
    section.add "X-Amz-Credential", valid_604513
  var valid_604514 = header.getOrDefault("X-Amz-Security-Token")
  valid_604514 = validateParameter(valid_604514, JString, required = false,
                                 default = nil)
  if valid_604514 != nil:
    section.add "X-Amz-Security-Token", valid_604514
  var valid_604515 = header.getOrDefault("X-Amz-Algorithm")
  valid_604515 = validateParameter(valid_604515, JString, required = false,
                                 default = nil)
  if valid_604515 != nil:
    section.add "X-Amz-Algorithm", valid_604515
  var valid_604516 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604516 = validateParameter(valid_604516, JString, required = false,
                                 default = nil)
  if valid_604516 != nil:
    section.add "X-Amz-SignedHeaders", valid_604516
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604517: Call_ListSecurityProfilesForTarget_604503; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ## 
  let valid = call_604517.validator(path, query, header, formData, body)
  let scheme = call_604517.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604517.url(scheme.get, call_604517.host, call_604517.base,
                         call_604517.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604517, url, valid)

proc call*(call_604518: Call_ListSecurityProfilesForTarget_604503;
          securityProfileTargetArn: string; nextToken: string = "";
          recursive: bool = false; maxResults: int = 0): Recallable =
  ## listSecurityProfilesForTarget
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   recursive: bool
  ##            : If true, return child groups too.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the target (thing group) whose attached security profiles you want to get.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_604519 = newJObject()
  add(query_604519, "nextToken", newJString(nextToken))
  add(query_604519, "recursive", newJBool(recursive))
  add(query_604519, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(query_604519, "maxResults", newJInt(maxResults))
  result = call_604518.call(nil, query_604519, nil, nil, nil)

var listSecurityProfilesForTarget* = Call_ListSecurityProfilesForTarget_604503(
    name: "listSecurityProfilesForTarget", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/security-profiles-for-target#securityProfileTargetArn",
    validator: validate_ListSecurityProfilesForTarget_604504, base: "/",
    url: url_ListSecurityProfilesForTarget_604505,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListStreams_604520 = ref object of OpenApiRestCall_601389
proc url_ListStreams_604522(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListStreams_604521(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all of the streams in your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token used to get the next set of results.
  ##   isAscendingOrder: JBool
  ##                   : Set to true to return the list of streams in ascending order.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at a time.
  section = newJObject()
  var valid_604523 = query.getOrDefault("nextToken")
  valid_604523 = validateParameter(valid_604523, JString, required = false,
                                 default = nil)
  if valid_604523 != nil:
    section.add "nextToken", valid_604523
  var valid_604524 = query.getOrDefault("isAscendingOrder")
  valid_604524 = validateParameter(valid_604524, JBool, required = false, default = nil)
  if valid_604524 != nil:
    section.add "isAscendingOrder", valid_604524
  var valid_604525 = query.getOrDefault("maxResults")
  valid_604525 = validateParameter(valid_604525, JInt, required = false, default = nil)
  if valid_604525 != nil:
    section.add "maxResults", valid_604525
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604526 = header.getOrDefault("X-Amz-Signature")
  valid_604526 = validateParameter(valid_604526, JString, required = false,
                                 default = nil)
  if valid_604526 != nil:
    section.add "X-Amz-Signature", valid_604526
  var valid_604527 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604527 = validateParameter(valid_604527, JString, required = false,
                                 default = nil)
  if valid_604527 != nil:
    section.add "X-Amz-Content-Sha256", valid_604527
  var valid_604528 = header.getOrDefault("X-Amz-Date")
  valid_604528 = validateParameter(valid_604528, JString, required = false,
                                 default = nil)
  if valid_604528 != nil:
    section.add "X-Amz-Date", valid_604528
  var valid_604529 = header.getOrDefault("X-Amz-Credential")
  valid_604529 = validateParameter(valid_604529, JString, required = false,
                                 default = nil)
  if valid_604529 != nil:
    section.add "X-Amz-Credential", valid_604529
  var valid_604530 = header.getOrDefault("X-Amz-Security-Token")
  valid_604530 = validateParameter(valid_604530, JString, required = false,
                                 default = nil)
  if valid_604530 != nil:
    section.add "X-Amz-Security-Token", valid_604530
  var valid_604531 = header.getOrDefault("X-Amz-Algorithm")
  valid_604531 = validateParameter(valid_604531, JString, required = false,
                                 default = nil)
  if valid_604531 != nil:
    section.add "X-Amz-Algorithm", valid_604531
  var valid_604532 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604532 = validateParameter(valid_604532, JString, required = false,
                                 default = nil)
  if valid_604532 != nil:
    section.add "X-Amz-SignedHeaders", valid_604532
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604533: Call_ListStreams_604520; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all of the streams in your AWS account.
  ## 
  let valid = call_604533.validator(path, query, header, formData, body)
  let scheme = call_604533.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604533.url(scheme.get, call_604533.host, call_604533.base,
                         call_604533.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604533, url, valid)

proc call*(call_604534: Call_ListStreams_604520; nextToken: string = "";
          isAscendingOrder: bool = false; maxResults: int = 0): Recallable =
  ## listStreams
  ## Lists all of the streams in your AWS account.
  ##   nextToken: string
  ##            : A token used to get the next set of results.
  ##   isAscendingOrder: bool
  ##                   : Set to true to return the list of streams in ascending order.
  ##   maxResults: int
  ##             : The maximum number of results to return at a time.
  var query_604535 = newJObject()
  add(query_604535, "nextToken", newJString(nextToken))
  add(query_604535, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_604535, "maxResults", newJInt(maxResults))
  result = call_604534.call(nil, query_604535, nil, nil, nil)

var listStreams* = Call_ListStreams_604520(name: "listStreams",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/streams",
                                        validator: validate_ListStreams_604521,
                                        base: "/", url: url_ListStreams_604522,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTagsForResource_604536 = ref object of OpenApiRestCall_601389
proc url_ListTagsForResource_604538(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListTagsForResource_604537(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the tags (metadata) you have assigned to the resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   resourceArn: JString (required)
  ##              : The ARN of the resource.
  section = newJObject()
  var valid_604539 = query.getOrDefault("nextToken")
  valid_604539 = validateParameter(valid_604539, JString, required = false,
                                 default = nil)
  if valid_604539 != nil:
    section.add "nextToken", valid_604539
  assert query != nil,
        "query argument is necessary due to required `resourceArn` field"
  var valid_604540 = query.getOrDefault("resourceArn")
  valid_604540 = validateParameter(valid_604540, JString, required = true,
                                 default = nil)
  if valid_604540 != nil:
    section.add "resourceArn", valid_604540
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604541 = header.getOrDefault("X-Amz-Signature")
  valid_604541 = validateParameter(valid_604541, JString, required = false,
                                 default = nil)
  if valid_604541 != nil:
    section.add "X-Amz-Signature", valid_604541
  var valid_604542 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604542 = validateParameter(valid_604542, JString, required = false,
                                 default = nil)
  if valid_604542 != nil:
    section.add "X-Amz-Content-Sha256", valid_604542
  var valid_604543 = header.getOrDefault("X-Amz-Date")
  valid_604543 = validateParameter(valid_604543, JString, required = false,
                                 default = nil)
  if valid_604543 != nil:
    section.add "X-Amz-Date", valid_604543
  var valid_604544 = header.getOrDefault("X-Amz-Credential")
  valid_604544 = validateParameter(valid_604544, JString, required = false,
                                 default = nil)
  if valid_604544 != nil:
    section.add "X-Amz-Credential", valid_604544
  var valid_604545 = header.getOrDefault("X-Amz-Security-Token")
  valid_604545 = validateParameter(valid_604545, JString, required = false,
                                 default = nil)
  if valid_604545 != nil:
    section.add "X-Amz-Security-Token", valid_604545
  var valid_604546 = header.getOrDefault("X-Amz-Algorithm")
  valid_604546 = validateParameter(valid_604546, JString, required = false,
                                 default = nil)
  if valid_604546 != nil:
    section.add "X-Amz-Algorithm", valid_604546
  var valid_604547 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604547 = validateParameter(valid_604547, JString, required = false,
                                 default = nil)
  if valid_604547 != nil:
    section.add "X-Amz-SignedHeaders", valid_604547
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604548: Call_ListTagsForResource_604536; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the tags (metadata) you have assigned to the resource.
  ## 
  let valid = call_604548.validator(path, query, header, formData, body)
  let scheme = call_604548.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604548.url(scheme.get, call_604548.host, call_604548.base,
                         call_604548.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604548, url, valid)

proc call*(call_604549: Call_ListTagsForResource_604536; resourceArn: string;
          nextToken: string = ""): Recallable =
  ## listTagsForResource
  ## Lists the tags (metadata) you have assigned to the resource.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   resourceArn: string (required)
  ##              : The ARN of the resource.
  var query_604550 = newJObject()
  add(query_604550, "nextToken", newJString(nextToken))
  add(query_604550, "resourceArn", newJString(resourceArn))
  result = call_604549.call(nil, query_604550, nil, nil, nil)

var listTagsForResource* = Call_ListTagsForResource_604536(
    name: "listTagsForResource", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/tags#resourceArn",
    validator: validate_ListTagsForResource_604537, base: "/",
    url: url_ListTagsForResource_604538, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTargetsForPolicy_604551 = ref object of OpenApiRestCall_601389
proc url_ListTargetsForPolicy_604553(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policy-targets/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListTargetsForPolicy_604552(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List targets for the specified policy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_604554 = path.getOrDefault("policyName")
  valid_604554 = validateParameter(valid_604554, JString, required = true,
                                 default = nil)
  if valid_604554 != nil:
    section.add "policyName", valid_604554
  result.add "path", section
  ## parameters in `query` object:
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  section = newJObject()
  var valid_604555 = query.getOrDefault("pageSize")
  valid_604555 = validateParameter(valid_604555, JInt, required = false, default = nil)
  if valid_604555 != nil:
    section.add "pageSize", valid_604555
  var valid_604556 = query.getOrDefault("marker")
  valid_604556 = validateParameter(valid_604556, JString, required = false,
                                 default = nil)
  if valid_604556 != nil:
    section.add "marker", valid_604556
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604557 = header.getOrDefault("X-Amz-Signature")
  valid_604557 = validateParameter(valid_604557, JString, required = false,
                                 default = nil)
  if valid_604557 != nil:
    section.add "X-Amz-Signature", valid_604557
  var valid_604558 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604558 = validateParameter(valid_604558, JString, required = false,
                                 default = nil)
  if valid_604558 != nil:
    section.add "X-Amz-Content-Sha256", valid_604558
  var valid_604559 = header.getOrDefault("X-Amz-Date")
  valid_604559 = validateParameter(valid_604559, JString, required = false,
                                 default = nil)
  if valid_604559 != nil:
    section.add "X-Amz-Date", valid_604559
  var valid_604560 = header.getOrDefault("X-Amz-Credential")
  valid_604560 = validateParameter(valid_604560, JString, required = false,
                                 default = nil)
  if valid_604560 != nil:
    section.add "X-Amz-Credential", valid_604560
  var valid_604561 = header.getOrDefault("X-Amz-Security-Token")
  valid_604561 = validateParameter(valid_604561, JString, required = false,
                                 default = nil)
  if valid_604561 != nil:
    section.add "X-Amz-Security-Token", valid_604561
  var valid_604562 = header.getOrDefault("X-Amz-Algorithm")
  valid_604562 = validateParameter(valid_604562, JString, required = false,
                                 default = nil)
  if valid_604562 != nil:
    section.add "X-Amz-Algorithm", valid_604562
  var valid_604563 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604563 = validateParameter(valid_604563, JString, required = false,
                                 default = nil)
  if valid_604563 != nil:
    section.add "X-Amz-SignedHeaders", valid_604563
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604564: Call_ListTargetsForPolicy_604551; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List targets for the specified policy.
  ## 
  let valid = call_604564.validator(path, query, header, formData, body)
  let scheme = call_604564.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604564.url(scheme.get, call_604564.host, call_604564.base,
                         call_604564.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604564, url, valid)

proc call*(call_604565: Call_ListTargetsForPolicy_604551; policyName: string;
          pageSize: int = 0; marker: string = ""): Recallable =
  ## listTargetsForPolicy
  ## List targets for the specified policy.
  ##   policyName: string (required)
  ##             : The policy name.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  var path_604566 = newJObject()
  var query_604567 = newJObject()
  add(path_604566, "policyName", newJString(policyName))
  add(query_604567, "pageSize", newJInt(pageSize))
  add(query_604567, "marker", newJString(marker))
  result = call_604565.call(path_604566, query_604567, nil, nil, nil)

var listTargetsForPolicy* = Call_ListTargetsForPolicy_604551(
    name: "listTargetsForPolicy", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/policy-targets/{policyName}",
    validator: validate_ListTargetsForPolicy_604552, base: "/",
    url: url_ListTargetsForPolicy_604553, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTargetsForSecurityProfile_604568 = ref object of OpenApiRestCall_601389
proc url_ListTargetsForSecurityProfile_604570(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"),
               (kind: ConstantSegment, value: "/targets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListTargetsForSecurityProfile_604569(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_604571 = path.getOrDefault("securityProfileName")
  valid_604571 = validateParameter(valid_604571, JString, required = true,
                                 default = nil)
  if valid_604571 != nil:
    section.add "securityProfileName", valid_604571
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_604572 = query.getOrDefault("nextToken")
  valid_604572 = validateParameter(valid_604572, JString, required = false,
                                 default = nil)
  if valid_604572 != nil:
    section.add "nextToken", valid_604572
  var valid_604573 = query.getOrDefault("maxResults")
  valid_604573 = validateParameter(valid_604573, JInt, required = false, default = nil)
  if valid_604573 != nil:
    section.add "maxResults", valid_604573
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604574 = header.getOrDefault("X-Amz-Signature")
  valid_604574 = validateParameter(valid_604574, JString, required = false,
                                 default = nil)
  if valid_604574 != nil:
    section.add "X-Amz-Signature", valid_604574
  var valid_604575 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604575 = validateParameter(valid_604575, JString, required = false,
                                 default = nil)
  if valid_604575 != nil:
    section.add "X-Amz-Content-Sha256", valid_604575
  var valid_604576 = header.getOrDefault("X-Amz-Date")
  valid_604576 = validateParameter(valid_604576, JString, required = false,
                                 default = nil)
  if valid_604576 != nil:
    section.add "X-Amz-Date", valid_604576
  var valid_604577 = header.getOrDefault("X-Amz-Credential")
  valid_604577 = validateParameter(valid_604577, JString, required = false,
                                 default = nil)
  if valid_604577 != nil:
    section.add "X-Amz-Credential", valid_604577
  var valid_604578 = header.getOrDefault("X-Amz-Security-Token")
  valid_604578 = validateParameter(valid_604578, JString, required = false,
                                 default = nil)
  if valid_604578 != nil:
    section.add "X-Amz-Security-Token", valid_604578
  var valid_604579 = header.getOrDefault("X-Amz-Algorithm")
  valid_604579 = validateParameter(valid_604579, JString, required = false,
                                 default = nil)
  if valid_604579 != nil:
    section.add "X-Amz-Algorithm", valid_604579
  var valid_604580 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604580 = validateParameter(valid_604580, JString, required = false,
                                 default = nil)
  if valid_604580 != nil:
    section.add "X-Amz-SignedHeaders", valid_604580
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604581: Call_ListTargetsForSecurityProfile_604568; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ## 
  let valid = call_604581.validator(path, query, header, formData, body)
  let scheme = call_604581.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604581.url(scheme.get, call_604581.host, call_604581.base,
                         call_604581.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604581, url, valid)

proc call*(call_604582: Call_ListTargetsForSecurityProfile_604568;
          securityProfileName: string; nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listTargetsForSecurityProfile
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string (required)
  ##                      : The security profile.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_604583 = newJObject()
  var query_604584 = newJObject()
  add(query_604584, "nextToken", newJString(nextToken))
  add(path_604583, "securityProfileName", newJString(securityProfileName))
  add(query_604584, "maxResults", newJInt(maxResults))
  result = call_604582.call(path_604583, query_604584, nil, nil, nil)

var listTargetsForSecurityProfile* = Call_ListTargetsForSecurityProfile_604568(
    name: "listTargetsForSecurityProfile", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/security-profiles/{securityProfileName}/targets",
    validator: validate_ListTargetsForSecurityProfile_604569, base: "/",
    url: url_ListTargetsForSecurityProfile_604570,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingGroups_604585 = ref object of OpenApiRestCall_601389
proc url_ListThingGroups_604587(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThingGroups_604586(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List the thing groups in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   recursive: JBool
  ##            : If true, return child groups as well.
  ##   parentGroup: JString
  ##              : A filter that limits the results to those with the specified parent group.
  ##   namePrefixFilter: JString
  ##                   : A filter that limits the results to those with the specified name prefix.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_604588 = query.getOrDefault("nextToken")
  valid_604588 = validateParameter(valid_604588, JString, required = false,
                                 default = nil)
  if valid_604588 != nil:
    section.add "nextToken", valid_604588
  var valid_604589 = query.getOrDefault("recursive")
  valid_604589 = validateParameter(valid_604589, JBool, required = false, default = nil)
  if valid_604589 != nil:
    section.add "recursive", valid_604589
  var valid_604590 = query.getOrDefault("parentGroup")
  valid_604590 = validateParameter(valid_604590, JString, required = false,
                                 default = nil)
  if valid_604590 != nil:
    section.add "parentGroup", valid_604590
  var valid_604591 = query.getOrDefault("namePrefixFilter")
  valid_604591 = validateParameter(valid_604591, JString, required = false,
                                 default = nil)
  if valid_604591 != nil:
    section.add "namePrefixFilter", valid_604591
  var valid_604592 = query.getOrDefault("maxResults")
  valid_604592 = validateParameter(valid_604592, JInt, required = false, default = nil)
  if valid_604592 != nil:
    section.add "maxResults", valid_604592
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604593 = header.getOrDefault("X-Amz-Signature")
  valid_604593 = validateParameter(valid_604593, JString, required = false,
                                 default = nil)
  if valid_604593 != nil:
    section.add "X-Amz-Signature", valid_604593
  var valid_604594 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604594 = validateParameter(valid_604594, JString, required = false,
                                 default = nil)
  if valid_604594 != nil:
    section.add "X-Amz-Content-Sha256", valid_604594
  var valid_604595 = header.getOrDefault("X-Amz-Date")
  valid_604595 = validateParameter(valid_604595, JString, required = false,
                                 default = nil)
  if valid_604595 != nil:
    section.add "X-Amz-Date", valid_604595
  var valid_604596 = header.getOrDefault("X-Amz-Credential")
  valid_604596 = validateParameter(valid_604596, JString, required = false,
                                 default = nil)
  if valid_604596 != nil:
    section.add "X-Amz-Credential", valid_604596
  var valid_604597 = header.getOrDefault("X-Amz-Security-Token")
  valid_604597 = validateParameter(valid_604597, JString, required = false,
                                 default = nil)
  if valid_604597 != nil:
    section.add "X-Amz-Security-Token", valid_604597
  var valid_604598 = header.getOrDefault("X-Amz-Algorithm")
  valid_604598 = validateParameter(valid_604598, JString, required = false,
                                 default = nil)
  if valid_604598 != nil:
    section.add "X-Amz-Algorithm", valid_604598
  var valid_604599 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604599 = validateParameter(valid_604599, JString, required = false,
                                 default = nil)
  if valid_604599 != nil:
    section.add "X-Amz-SignedHeaders", valid_604599
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604600: Call_ListThingGroups_604585; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the thing groups in your account.
  ## 
  let valid = call_604600.validator(path, query, header, formData, body)
  let scheme = call_604600.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604600.url(scheme.get, call_604600.host, call_604600.base,
                         call_604600.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604600, url, valid)

proc call*(call_604601: Call_ListThingGroups_604585; nextToken: string = "";
          recursive: bool = false; parentGroup: string = "";
          namePrefixFilter: string = ""; maxResults: int = 0): Recallable =
  ## listThingGroups
  ## List the thing groups in your account.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   recursive: bool
  ##            : If true, return child groups as well.
  ##   parentGroup: string
  ##              : A filter that limits the results to those with the specified parent group.
  ##   namePrefixFilter: string
  ##                   : A filter that limits the results to those with the specified name prefix.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_604602 = newJObject()
  add(query_604602, "nextToken", newJString(nextToken))
  add(query_604602, "recursive", newJBool(recursive))
  add(query_604602, "parentGroup", newJString(parentGroup))
  add(query_604602, "namePrefixFilter", newJString(namePrefixFilter))
  add(query_604602, "maxResults", newJInt(maxResults))
  result = call_604601.call(nil, query_604602, nil, nil, nil)

var listThingGroups* = Call_ListThingGroups_604585(name: "listThingGroups",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/thing-groups",
    validator: validate_ListThingGroups_604586, base: "/", url: url_ListThingGroups_604587,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingGroupsForThing_604603 = ref object of OpenApiRestCall_601389
proc url_ListThingGroupsForThing_604605(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/thing-groups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingGroupsForThing_604604(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List the thing groups to which the specified thing belongs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The thing name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_604606 = path.getOrDefault("thingName")
  valid_604606 = validateParameter(valid_604606, JString, required = true,
                                 default = nil)
  if valid_604606 != nil:
    section.add "thingName", valid_604606
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_604607 = query.getOrDefault("nextToken")
  valid_604607 = validateParameter(valid_604607, JString, required = false,
                                 default = nil)
  if valid_604607 != nil:
    section.add "nextToken", valid_604607
  var valid_604608 = query.getOrDefault("maxResults")
  valid_604608 = validateParameter(valid_604608, JInt, required = false, default = nil)
  if valid_604608 != nil:
    section.add "maxResults", valid_604608
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604609 = header.getOrDefault("X-Amz-Signature")
  valid_604609 = validateParameter(valid_604609, JString, required = false,
                                 default = nil)
  if valid_604609 != nil:
    section.add "X-Amz-Signature", valid_604609
  var valid_604610 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604610 = validateParameter(valid_604610, JString, required = false,
                                 default = nil)
  if valid_604610 != nil:
    section.add "X-Amz-Content-Sha256", valid_604610
  var valid_604611 = header.getOrDefault("X-Amz-Date")
  valid_604611 = validateParameter(valid_604611, JString, required = false,
                                 default = nil)
  if valid_604611 != nil:
    section.add "X-Amz-Date", valid_604611
  var valid_604612 = header.getOrDefault("X-Amz-Credential")
  valid_604612 = validateParameter(valid_604612, JString, required = false,
                                 default = nil)
  if valid_604612 != nil:
    section.add "X-Amz-Credential", valid_604612
  var valid_604613 = header.getOrDefault("X-Amz-Security-Token")
  valid_604613 = validateParameter(valid_604613, JString, required = false,
                                 default = nil)
  if valid_604613 != nil:
    section.add "X-Amz-Security-Token", valid_604613
  var valid_604614 = header.getOrDefault("X-Amz-Algorithm")
  valid_604614 = validateParameter(valid_604614, JString, required = false,
                                 default = nil)
  if valid_604614 != nil:
    section.add "X-Amz-Algorithm", valid_604614
  var valid_604615 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604615 = validateParameter(valid_604615, JString, required = false,
                                 default = nil)
  if valid_604615 != nil:
    section.add "X-Amz-SignedHeaders", valid_604615
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604616: Call_ListThingGroupsForThing_604603; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the thing groups to which the specified thing belongs.
  ## 
  let valid = call_604616.validator(path, query, header, formData, body)
  let scheme = call_604616.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604616.url(scheme.get, call_604616.host, call_604616.base,
                         call_604616.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604616, url, valid)

proc call*(call_604617: Call_ListThingGroupsForThing_604603; thingName: string;
          nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listThingGroupsForThing
  ## List the thing groups to which the specified thing belongs.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingName: string (required)
  ##            : The thing name.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_604618 = newJObject()
  var query_604619 = newJObject()
  add(query_604619, "nextToken", newJString(nextToken))
  add(path_604618, "thingName", newJString(thingName))
  add(query_604619, "maxResults", newJInt(maxResults))
  result = call_604617.call(path_604618, query_604619, nil, nil, nil)

var listThingGroupsForThing* = Call_ListThingGroupsForThing_604603(
    name: "listThingGroupsForThing", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/thing-groups",
    validator: validate_ListThingGroupsForThing_604604, base: "/",
    url: url_ListThingGroupsForThing_604605, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingPrincipals_604620 = ref object of OpenApiRestCall_601389
proc url_ListThingPrincipals_604622(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingPrincipals_604621(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_604623 = path.getOrDefault("thingName")
  valid_604623 = validateParameter(valid_604623, JString, required = true,
                                 default = nil)
  if valid_604623 != nil:
    section.add "thingName", valid_604623
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604624 = header.getOrDefault("X-Amz-Signature")
  valid_604624 = validateParameter(valid_604624, JString, required = false,
                                 default = nil)
  if valid_604624 != nil:
    section.add "X-Amz-Signature", valid_604624
  var valid_604625 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604625 = validateParameter(valid_604625, JString, required = false,
                                 default = nil)
  if valid_604625 != nil:
    section.add "X-Amz-Content-Sha256", valid_604625
  var valid_604626 = header.getOrDefault("X-Amz-Date")
  valid_604626 = validateParameter(valid_604626, JString, required = false,
                                 default = nil)
  if valid_604626 != nil:
    section.add "X-Amz-Date", valid_604626
  var valid_604627 = header.getOrDefault("X-Amz-Credential")
  valid_604627 = validateParameter(valid_604627, JString, required = false,
                                 default = nil)
  if valid_604627 != nil:
    section.add "X-Amz-Credential", valid_604627
  var valid_604628 = header.getOrDefault("X-Amz-Security-Token")
  valid_604628 = validateParameter(valid_604628, JString, required = false,
                                 default = nil)
  if valid_604628 != nil:
    section.add "X-Amz-Security-Token", valid_604628
  var valid_604629 = header.getOrDefault("X-Amz-Algorithm")
  valid_604629 = validateParameter(valid_604629, JString, required = false,
                                 default = nil)
  if valid_604629 != nil:
    section.add "X-Amz-Algorithm", valid_604629
  var valid_604630 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604630 = validateParameter(valid_604630, JString, required = false,
                                 default = nil)
  if valid_604630 != nil:
    section.add "X-Amz-SignedHeaders", valid_604630
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604631: Call_ListThingPrincipals_604620; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  let valid = call_604631.validator(path, query, header, formData, body)
  let scheme = call_604631.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604631.url(scheme.get, call_604631.host, call_604631.base,
                         call_604631.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604631, url, valid)

proc call*(call_604632: Call_ListThingPrincipals_604620; thingName: string): Recallable =
  ## listThingPrincipals
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_604633 = newJObject()
  add(path_604633, "thingName", newJString(thingName))
  result = call_604632.call(path_604633, nil, nil, nil, nil)

var listThingPrincipals* = Call_ListThingPrincipals_604620(
    name: "listThingPrincipals", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/principals",
    validator: validate_ListThingPrincipals_604621, base: "/",
    url: url_ListThingPrincipals_604622, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingRegistrationTaskReports_604634 = ref object of OpenApiRestCall_601389
proc url_ListThingRegistrationTaskReports_604636(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/reports#reportType")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingRegistrationTaskReports_604635(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Information about the thing registration tasks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The id of the task.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_604637 = path.getOrDefault("taskId")
  valid_604637 = validateParameter(valid_604637, JString, required = true,
                                 default = nil)
  if valid_604637 != nil:
    section.add "taskId", valid_604637
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   reportType: JString (required)
  ##             : The type of task report.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_604638 = query.getOrDefault("nextToken")
  valid_604638 = validateParameter(valid_604638, JString, required = false,
                                 default = nil)
  if valid_604638 != nil:
    section.add "nextToken", valid_604638
  assert query != nil,
        "query argument is necessary due to required `reportType` field"
  var valid_604639 = query.getOrDefault("reportType")
  valid_604639 = validateParameter(valid_604639, JString, required = true,
                                 default = newJString("ERRORS"))
  if valid_604639 != nil:
    section.add "reportType", valid_604639
  var valid_604640 = query.getOrDefault("maxResults")
  valid_604640 = validateParameter(valid_604640, JInt, required = false, default = nil)
  if valid_604640 != nil:
    section.add "maxResults", valid_604640
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604641 = header.getOrDefault("X-Amz-Signature")
  valid_604641 = validateParameter(valid_604641, JString, required = false,
                                 default = nil)
  if valid_604641 != nil:
    section.add "X-Amz-Signature", valid_604641
  var valid_604642 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604642 = validateParameter(valid_604642, JString, required = false,
                                 default = nil)
  if valid_604642 != nil:
    section.add "X-Amz-Content-Sha256", valid_604642
  var valid_604643 = header.getOrDefault("X-Amz-Date")
  valid_604643 = validateParameter(valid_604643, JString, required = false,
                                 default = nil)
  if valid_604643 != nil:
    section.add "X-Amz-Date", valid_604643
  var valid_604644 = header.getOrDefault("X-Amz-Credential")
  valid_604644 = validateParameter(valid_604644, JString, required = false,
                                 default = nil)
  if valid_604644 != nil:
    section.add "X-Amz-Credential", valid_604644
  var valid_604645 = header.getOrDefault("X-Amz-Security-Token")
  valid_604645 = validateParameter(valid_604645, JString, required = false,
                                 default = nil)
  if valid_604645 != nil:
    section.add "X-Amz-Security-Token", valid_604645
  var valid_604646 = header.getOrDefault("X-Amz-Algorithm")
  valid_604646 = validateParameter(valid_604646, JString, required = false,
                                 default = nil)
  if valid_604646 != nil:
    section.add "X-Amz-Algorithm", valid_604646
  var valid_604647 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604647 = validateParameter(valid_604647, JString, required = false,
                                 default = nil)
  if valid_604647 != nil:
    section.add "X-Amz-SignedHeaders", valid_604647
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604648: Call_ListThingRegistrationTaskReports_604634;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Information about the thing registration tasks.
  ## 
  let valid = call_604648.validator(path, query, header, formData, body)
  let scheme = call_604648.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604648.url(scheme.get, call_604648.host, call_604648.base,
                         call_604648.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604648, url, valid)

proc call*(call_604649: Call_ListThingRegistrationTaskReports_604634;
          taskId: string; nextToken: string = ""; reportType: string = "ERRORS";
          maxResults: int = 0): Recallable =
  ## listThingRegistrationTaskReports
  ## Information about the thing registration tasks.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   taskId: string (required)
  ##         : The id of the task.
  ##   reportType: string (required)
  ##             : The type of task report.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var path_604650 = newJObject()
  var query_604651 = newJObject()
  add(query_604651, "nextToken", newJString(nextToken))
  add(path_604650, "taskId", newJString(taskId))
  add(query_604651, "reportType", newJString(reportType))
  add(query_604651, "maxResults", newJInt(maxResults))
  result = call_604649.call(path_604650, query_604651, nil, nil, nil)

var listThingRegistrationTaskReports* = Call_ListThingRegistrationTaskReports_604634(
    name: "listThingRegistrationTaskReports", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/thing-registration-tasks/{taskId}/reports#reportType",
    validator: validate_ListThingRegistrationTaskReports_604635, base: "/",
    url: url_ListThingRegistrationTaskReports_604636,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartThingRegistrationTask_604668 = ref object of OpenApiRestCall_601389
proc url_StartThingRegistrationTask_604670(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_StartThingRegistrationTask_604669(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604671 = header.getOrDefault("X-Amz-Signature")
  valid_604671 = validateParameter(valid_604671, JString, required = false,
                                 default = nil)
  if valid_604671 != nil:
    section.add "X-Amz-Signature", valid_604671
  var valid_604672 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604672 = validateParameter(valid_604672, JString, required = false,
                                 default = nil)
  if valid_604672 != nil:
    section.add "X-Amz-Content-Sha256", valid_604672
  var valid_604673 = header.getOrDefault("X-Amz-Date")
  valid_604673 = validateParameter(valid_604673, JString, required = false,
                                 default = nil)
  if valid_604673 != nil:
    section.add "X-Amz-Date", valid_604673
  var valid_604674 = header.getOrDefault("X-Amz-Credential")
  valid_604674 = validateParameter(valid_604674, JString, required = false,
                                 default = nil)
  if valid_604674 != nil:
    section.add "X-Amz-Credential", valid_604674
  var valid_604675 = header.getOrDefault("X-Amz-Security-Token")
  valid_604675 = validateParameter(valid_604675, JString, required = false,
                                 default = nil)
  if valid_604675 != nil:
    section.add "X-Amz-Security-Token", valid_604675
  var valid_604676 = header.getOrDefault("X-Amz-Algorithm")
  valid_604676 = validateParameter(valid_604676, JString, required = false,
                                 default = nil)
  if valid_604676 != nil:
    section.add "X-Amz-Algorithm", valid_604676
  var valid_604677 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604677 = validateParameter(valid_604677, JString, required = false,
                                 default = nil)
  if valid_604677 != nil:
    section.add "X-Amz-SignedHeaders", valid_604677
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604679: Call_StartThingRegistrationTask_604668; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a bulk thing provisioning task.
  ## 
  let valid = call_604679.validator(path, query, header, formData, body)
  let scheme = call_604679.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604679.url(scheme.get, call_604679.host, call_604679.base,
                         call_604679.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604679, url, valid)

proc call*(call_604680: Call_StartThingRegistrationTask_604668; body: JsonNode): Recallable =
  ## startThingRegistrationTask
  ## Creates a bulk thing provisioning task.
  ##   body: JObject (required)
  var body_604681 = newJObject()
  if body != nil:
    body_604681 = body
  result = call_604680.call(nil, nil, nil, nil, body_604681)

var startThingRegistrationTask* = Call_StartThingRegistrationTask_604668(
    name: "startThingRegistrationTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks",
    validator: validate_StartThingRegistrationTask_604669, base: "/",
    url: url_StartThingRegistrationTask_604670,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingRegistrationTasks_604652 = ref object of OpenApiRestCall_601389
proc url_ListThingRegistrationTasks_604654(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThingRegistrationTasks_604653(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List bulk thing provisioning tasks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : The status of the bulk thing provisioning task.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_604655 = query.getOrDefault("nextToken")
  valid_604655 = validateParameter(valid_604655, JString, required = false,
                                 default = nil)
  if valid_604655 != nil:
    section.add "nextToken", valid_604655
  var valid_604656 = query.getOrDefault("status")
  valid_604656 = validateParameter(valid_604656, JString, required = false,
                                 default = newJString("InProgress"))
  if valid_604656 != nil:
    section.add "status", valid_604656
  var valid_604657 = query.getOrDefault("maxResults")
  valid_604657 = validateParameter(valid_604657, JInt, required = false, default = nil)
  if valid_604657 != nil:
    section.add "maxResults", valid_604657
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604658 = header.getOrDefault("X-Amz-Signature")
  valid_604658 = validateParameter(valid_604658, JString, required = false,
                                 default = nil)
  if valid_604658 != nil:
    section.add "X-Amz-Signature", valid_604658
  var valid_604659 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604659 = validateParameter(valid_604659, JString, required = false,
                                 default = nil)
  if valid_604659 != nil:
    section.add "X-Amz-Content-Sha256", valid_604659
  var valid_604660 = header.getOrDefault("X-Amz-Date")
  valid_604660 = validateParameter(valid_604660, JString, required = false,
                                 default = nil)
  if valid_604660 != nil:
    section.add "X-Amz-Date", valid_604660
  var valid_604661 = header.getOrDefault("X-Amz-Credential")
  valid_604661 = validateParameter(valid_604661, JString, required = false,
                                 default = nil)
  if valid_604661 != nil:
    section.add "X-Amz-Credential", valid_604661
  var valid_604662 = header.getOrDefault("X-Amz-Security-Token")
  valid_604662 = validateParameter(valid_604662, JString, required = false,
                                 default = nil)
  if valid_604662 != nil:
    section.add "X-Amz-Security-Token", valid_604662
  var valid_604663 = header.getOrDefault("X-Amz-Algorithm")
  valid_604663 = validateParameter(valid_604663, JString, required = false,
                                 default = nil)
  if valid_604663 != nil:
    section.add "X-Amz-Algorithm", valid_604663
  var valid_604664 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604664 = validateParameter(valid_604664, JString, required = false,
                                 default = nil)
  if valid_604664 != nil:
    section.add "X-Amz-SignedHeaders", valid_604664
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604665: Call_ListThingRegistrationTasks_604652; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List bulk thing provisioning tasks.
  ## 
  let valid = call_604665.validator(path, query, header, formData, body)
  let scheme = call_604665.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604665.url(scheme.get, call_604665.host, call_604665.base,
                         call_604665.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604665, url, valid)

proc call*(call_604666: Call_ListThingRegistrationTasks_604652;
          nextToken: string = ""; status: string = "InProgress"; maxResults: int = 0): Recallable =
  ## listThingRegistrationTasks
  ## List bulk thing provisioning tasks.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : The status of the bulk thing provisioning task.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_604667 = newJObject()
  add(query_604667, "nextToken", newJString(nextToken))
  add(query_604667, "status", newJString(status))
  add(query_604667, "maxResults", newJInt(maxResults))
  result = call_604666.call(nil, query_604667, nil, nil, nil)

var listThingRegistrationTasks* = Call_ListThingRegistrationTasks_604652(
    name: "listThingRegistrationTasks", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks",
    validator: validate_ListThingRegistrationTasks_604653, base: "/",
    url: url_ListThingRegistrationTasks_604654,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingTypes_604682 = ref object of OpenApiRestCall_601389
proc url_ListThingTypes_604684(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThingTypes_604683(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the existing thing types.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   thingTypeName: JString
  ##                : The name of the thing type.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  section = newJObject()
  var valid_604685 = query.getOrDefault("nextToken")
  valid_604685 = validateParameter(valid_604685, JString, required = false,
                                 default = nil)
  if valid_604685 != nil:
    section.add "nextToken", valid_604685
  var valid_604686 = query.getOrDefault("thingTypeName")
  valid_604686 = validateParameter(valid_604686, JString, required = false,
                                 default = nil)
  if valid_604686 != nil:
    section.add "thingTypeName", valid_604686
  var valid_604687 = query.getOrDefault("maxResults")
  valid_604687 = validateParameter(valid_604687, JInt, required = false, default = nil)
  if valid_604687 != nil:
    section.add "maxResults", valid_604687
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604688 = header.getOrDefault("X-Amz-Signature")
  valid_604688 = validateParameter(valid_604688, JString, required = false,
                                 default = nil)
  if valid_604688 != nil:
    section.add "X-Amz-Signature", valid_604688
  var valid_604689 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604689 = validateParameter(valid_604689, JString, required = false,
                                 default = nil)
  if valid_604689 != nil:
    section.add "X-Amz-Content-Sha256", valid_604689
  var valid_604690 = header.getOrDefault("X-Amz-Date")
  valid_604690 = validateParameter(valid_604690, JString, required = false,
                                 default = nil)
  if valid_604690 != nil:
    section.add "X-Amz-Date", valid_604690
  var valid_604691 = header.getOrDefault("X-Amz-Credential")
  valid_604691 = validateParameter(valid_604691, JString, required = false,
                                 default = nil)
  if valid_604691 != nil:
    section.add "X-Amz-Credential", valid_604691
  var valid_604692 = header.getOrDefault("X-Amz-Security-Token")
  valid_604692 = validateParameter(valid_604692, JString, required = false,
                                 default = nil)
  if valid_604692 != nil:
    section.add "X-Amz-Security-Token", valid_604692
  var valid_604693 = header.getOrDefault("X-Amz-Algorithm")
  valid_604693 = validateParameter(valid_604693, JString, required = false,
                                 default = nil)
  if valid_604693 != nil:
    section.add "X-Amz-Algorithm", valid_604693
  var valid_604694 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604694 = validateParameter(valid_604694, JString, required = false,
                                 default = nil)
  if valid_604694 != nil:
    section.add "X-Amz-SignedHeaders", valid_604694
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604695: Call_ListThingTypes_604682; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the existing thing types.
  ## 
  let valid = call_604695.validator(path, query, header, formData, body)
  let scheme = call_604695.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604695.url(scheme.get, call_604695.host, call_604695.base,
                         call_604695.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604695, url, valid)

proc call*(call_604696: Call_ListThingTypes_604682; nextToken: string = "";
          thingTypeName: string = ""; maxResults: int = 0): Recallable =
  ## listThingTypes
  ## Lists the existing thing types.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingTypeName: string
  ##                : The name of the thing type.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  var query_604697 = newJObject()
  add(query_604697, "nextToken", newJString(nextToken))
  add(query_604697, "thingTypeName", newJString(thingTypeName))
  add(query_604697, "maxResults", newJInt(maxResults))
  result = call_604696.call(nil, query_604697, nil, nil, nil)

var listThingTypes* = Call_ListThingTypes_604682(name: "listThingTypes",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/thing-types",
    validator: validate_ListThingTypes_604683, base: "/", url: url_ListThingTypes_604684,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterThing_604716 = ref object of OpenApiRestCall_601389
proc url_RegisterThing_604718(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RegisterThing_604717(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604719 = header.getOrDefault("X-Amz-Signature")
  valid_604719 = validateParameter(valid_604719, JString, required = false,
                                 default = nil)
  if valid_604719 != nil:
    section.add "X-Amz-Signature", valid_604719
  var valid_604720 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604720 = validateParameter(valid_604720, JString, required = false,
                                 default = nil)
  if valid_604720 != nil:
    section.add "X-Amz-Content-Sha256", valid_604720
  var valid_604721 = header.getOrDefault("X-Amz-Date")
  valid_604721 = validateParameter(valid_604721, JString, required = false,
                                 default = nil)
  if valid_604721 != nil:
    section.add "X-Amz-Date", valid_604721
  var valid_604722 = header.getOrDefault("X-Amz-Credential")
  valid_604722 = validateParameter(valid_604722, JString, required = false,
                                 default = nil)
  if valid_604722 != nil:
    section.add "X-Amz-Credential", valid_604722
  var valid_604723 = header.getOrDefault("X-Amz-Security-Token")
  valid_604723 = validateParameter(valid_604723, JString, required = false,
                                 default = nil)
  if valid_604723 != nil:
    section.add "X-Amz-Security-Token", valid_604723
  var valid_604724 = header.getOrDefault("X-Amz-Algorithm")
  valid_604724 = validateParameter(valid_604724, JString, required = false,
                                 default = nil)
  if valid_604724 != nil:
    section.add "X-Amz-Algorithm", valid_604724
  var valid_604725 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604725 = validateParameter(valid_604725, JString, required = false,
                                 default = nil)
  if valid_604725 != nil:
    section.add "X-Amz-SignedHeaders", valid_604725
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604727: Call_RegisterThing_604716; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.
  ## 
  let valid = call_604727.validator(path, query, header, formData, body)
  let scheme = call_604727.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604727.url(scheme.get, call_604727.host, call_604727.base,
                         call_604727.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604727, url, valid)

proc call*(call_604728: Call_RegisterThing_604716; body: JsonNode): Recallable =
  ## registerThing
  ## Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.
  ##   body: JObject (required)
  var body_604729 = newJObject()
  if body != nil:
    body_604729 = body
  result = call_604728.call(nil, nil, nil, nil, body_604729)

var registerThing* = Call_RegisterThing_604716(name: "registerThing",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/things",
    validator: validate_RegisterThing_604717, base: "/", url: url_RegisterThing_604718,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThings_604698 = ref object of OpenApiRestCall_601389
proc url_ListThings_604700(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThings_604699(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   attributeName: JString
  ##                : The attribute name used to search for things.
  ##   thingTypeName: JString
  ##                : The name of the thing type used to search for things.
  ##   attributeValue: JString
  ##                 : The attribute value used to search for things.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  section = newJObject()
  var valid_604701 = query.getOrDefault("nextToken")
  valid_604701 = validateParameter(valid_604701, JString, required = false,
                                 default = nil)
  if valid_604701 != nil:
    section.add "nextToken", valid_604701
  var valid_604702 = query.getOrDefault("attributeName")
  valid_604702 = validateParameter(valid_604702, JString, required = false,
                                 default = nil)
  if valid_604702 != nil:
    section.add "attributeName", valid_604702
  var valid_604703 = query.getOrDefault("thingTypeName")
  valid_604703 = validateParameter(valid_604703, JString, required = false,
                                 default = nil)
  if valid_604703 != nil:
    section.add "thingTypeName", valid_604703
  var valid_604704 = query.getOrDefault("attributeValue")
  valid_604704 = validateParameter(valid_604704, JString, required = false,
                                 default = nil)
  if valid_604704 != nil:
    section.add "attributeValue", valid_604704
  var valid_604705 = query.getOrDefault("maxResults")
  valid_604705 = validateParameter(valid_604705, JInt, required = false, default = nil)
  if valid_604705 != nil:
    section.add "maxResults", valid_604705
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604706 = header.getOrDefault("X-Amz-Signature")
  valid_604706 = validateParameter(valid_604706, JString, required = false,
                                 default = nil)
  if valid_604706 != nil:
    section.add "X-Amz-Signature", valid_604706
  var valid_604707 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604707 = validateParameter(valid_604707, JString, required = false,
                                 default = nil)
  if valid_604707 != nil:
    section.add "X-Amz-Content-Sha256", valid_604707
  var valid_604708 = header.getOrDefault("X-Amz-Date")
  valid_604708 = validateParameter(valid_604708, JString, required = false,
                                 default = nil)
  if valid_604708 != nil:
    section.add "X-Amz-Date", valid_604708
  var valid_604709 = header.getOrDefault("X-Amz-Credential")
  valid_604709 = validateParameter(valid_604709, JString, required = false,
                                 default = nil)
  if valid_604709 != nil:
    section.add "X-Amz-Credential", valid_604709
  var valid_604710 = header.getOrDefault("X-Amz-Security-Token")
  valid_604710 = validateParameter(valid_604710, JString, required = false,
                                 default = nil)
  if valid_604710 != nil:
    section.add "X-Amz-Security-Token", valid_604710
  var valid_604711 = header.getOrDefault("X-Amz-Algorithm")
  valid_604711 = validateParameter(valid_604711, JString, required = false,
                                 default = nil)
  if valid_604711 != nil:
    section.add "X-Amz-Algorithm", valid_604711
  var valid_604712 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604712 = validateParameter(valid_604712, JString, required = false,
                                 default = nil)
  if valid_604712 != nil:
    section.add "X-Amz-SignedHeaders", valid_604712
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604713: Call_ListThings_604698; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ## 
  let valid = call_604713.validator(path, query, header, formData, body)
  let scheme = call_604713.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604713.url(scheme.get, call_604713.host, call_604713.base,
                         call_604713.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604713, url, valid)

proc call*(call_604714: Call_ListThings_604698; nextToken: string = "";
          attributeName: string = ""; thingTypeName: string = "";
          attributeValue: string = ""; maxResults: int = 0): Recallable =
  ## listThings
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   attributeName: string
  ##                : The attribute name used to search for things.
  ##   thingTypeName: string
  ##                : The name of the thing type used to search for things.
  ##   attributeValue: string
  ##                 : The attribute value used to search for things.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  var query_604715 = newJObject()
  add(query_604715, "nextToken", newJString(nextToken))
  add(query_604715, "attributeName", newJString(attributeName))
  add(query_604715, "thingTypeName", newJString(thingTypeName))
  add(query_604715, "attributeValue", newJString(attributeValue))
  add(query_604715, "maxResults", newJInt(maxResults))
  result = call_604714.call(nil, query_604715, nil, nil, nil)

var listThings* = Call_ListThings_604698(name: "listThings",
                                      meth: HttpMethod.HttpGet,
                                      host: "iot.amazonaws.com", route: "/things",
                                      validator: validate_ListThings_604699,
                                      base: "/", url: url_ListThings_604700,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingsInBillingGroup_604730 = ref object of OpenApiRestCall_601389
proc url_ListThingsInBillingGroup_604732(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingsInBillingGroup_604731(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the things you have added to the given billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_604733 = path.getOrDefault("billingGroupName")
  valid_604733 = validateParameter(valid_604733, JString, required = true,
                                 default = nil)
  if valid_604733 != nil:
    section.add "billingGroupName", valid_604733
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_604734 = query.getOrDefault("nextToken")
  valid_604734 = validateParameter(valid_604734, JString, required = false,
                                 default = nil)
  if valid_604734 != nil:
    section.add "nextToken", valid_604734
  var valid_604735 = query.getOrDefault("maxResults")
  valid_604735 = validateParameter(valid_604735, JInt, required = false, default = nil)
  if valid_604735 != nil:
    section.add "maxResults", valid_604735
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604736 = header.getOrDefault("X-Amz-Signature")
  valid_604736 = validateParameter(valid_604736, JString, required = false,
                                 default = nil)
  if valid_604736 != nil:
    section.add "X-Amz-Signature", valid_604736
  var valid_604737 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604737 = validateParameter(valid_604737, JString, required = false,
                                 default = nil)
  if valid_604737 != nil:
    section.add "X-Amz-Content-Sha256", valid_604737
  var valid_604738 = header.getOrDefault("X-Amz-Date")
  valid_604738 = validateParameter(valid_604738, JString, required = false,
                                 default = nil)
  if valid_604738 != nil:
    section.add "X-Amz-Date", valid_604738
  var valid_604739 = header.getOrDefault("X-Amz-Credential")
  valid_604739 = validateParameter(valid_604739, JString, required = false,
                                 default = nil)
  if valid_604739 != nil:
    section.add "X-Amz-Credential", valid_604739
  var valid_604740 = header.getOrDefault("X-Amz-Security-Token")
  valid_604740 = validateParameter(valid_604740, JString, required = false,
                                 default = nil)
  if valid_604740 != nil:
    section.add "X-Amz-Security-Token", valid_604740
  var valid_604741 = header.getOrDefault("X-Amz-Algorithm")
  valid_604741 = validateParameter(valid_604741, JString, required = false,
                                 default = nil)
  if valid_604741 != nil:
    section.add "X-Amz-Algorithm", valid_604741
  var valid_604742 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604742 = validateParameter(valid_604742, JString, required = false,
                                 default = nil)
  if valid_604742 != nil:
    section.add "X-Amz-SignedHeaders", valid_604742
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604743: Call_ListThingsInBillingGroup_604730; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things you have added to the given billing group.
  ## 
  let valid = call_604743.validator(path, query, header, formData, body)
  let scheme = call_604743.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604743.url(scheme.get, call_604743.host, call_604743.base,
                         call_604743.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604743, url, valid)

proc call*(call_604744: Call_ListThingsInBillingGroup_604730;
          billingGroupName: string; nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listThingsInBillingGroup
  ## Lists the things you have added to the given billing group.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var path_604745 = newJObject()
  var query_604746 = newJObject()
  add(query_604746, "nextToken", newJString(nextToken))
  add(path_604745, "billingGroupName", newJString(billingGroupName))
  add(query_604746, "maxResults", newJInt(maxResults))
  result = call_604744.call(path_604745, query_604746, nil, nil, nil)

var listThingsInBillingGroup* = Call_ListThingsInBillingGroup_604730(
    name: "listThingsInBillingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}/things",
    validator: validate_ListThingsInBillingGroup_604731, base: "/",
    url: url_ListThingsInBillingGroup_604732, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingsInThingGroup_604747 = ref object of OpenApiRestCall_601389
proc url_ListThingsInThingGroup_604749(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingsInThingGroup_604748(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the things in the specified group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_604750 = path.getOrDefault("thingGroupName")
  valid_604750 = validateParameter(valid_604750, JString, required = true,
                                 default = nil)
  if valid_604750 != nil:
    section.add "thingGroupName", valid_604750
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   recursive: JBool
  ##            : When true, list things in this thing group and in all child groups as well.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_604751 = query.getOrDefault("nextToken")
  valid_604751 = validateParameter(valid_604751, JString, required = false,
                                 default = nil)
  if valid_604751 != nil:
    section.add "nextToken", valid_604751
  var valid_604752 = query.getOrDefault("recursive")
  valid_604752 = validateParameter(valid_604752, JBool, required = false, default = nil)
  if valid_604752 != nil:
    section.add "recursive", valid_604752
  var valid_604753 = query.getOrDefault("maxResults")
  valid_604753 = validateParameter(valid_604753, JInt, required = false, default = nil)
  if valid_604753 != nil:
    section.add "maxResults", valid_604753
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604754 = header.getOrDefault("X-Amz-Signature")
  valid_604754 = validateParameter(valid_604754, JString, required = false,
                                 default = nil)
  if valid_604754 != nil:
    section.add "X-Amz-Signature", valid_604754
  var valid_604755 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604755 = validateParameter(valid_604755, JString, required = false,
                                 default = nil)
  if valid_604755 != nil:
    section.add "X-Amz-Content-Sha256", valid_604755
  var valid_604756 = header.getOrDefault("X-Amz-Date")
  valid_604756 = validateParameter(valid_604756, JString, required = false,
                                 default = nil)
  if valid_604756 != nil:
    section.add "X-Amz-Date", valid_604756
  var valid_604757 = header.getOrDefault("X-Amz-Credential")
  valid_604757 = validateParameter(valid_604757, JString, required = false,
                                 default = nil)
  if valid_604757 != nil:
    section.add "X-Amz-Credential", valid_604757
  var valid_604758 = header.getOrDefault("X-Amz-Security-Token")
  valid_604758 = validateParameter(valid_604758, JString, required = false,
                                 default = nil)
  if valid_604758 != nil:
    section.add "X-Amz-Security-Token", valid_604758
  var valid_604759 = header.getOrDefault("X-Amz-Algorithm")
  valid_604759 = validateParameter(valid_604759, JString, required = false,
                                 default = nil)
  if valid_604759 != nil:
    section.add "X-Amz-Algorithm", valid_604759
  var valid_604760 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604760 = validateParameter(valid_604760, JString, required = false,
                                 default = nil)
  if valid_604760 != nil:
    section.add "X-Amz-SignedHeaders", valid_604760
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604761: Call_ListThingsInThingGroup_604747; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things in the specified group.
  ## 
  let valid = call_604761.validator(path, query, header, formData, body)
  let scheme = call_604761.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604761.url(scheme.get, call_604761.host, call_604761.base,
                         call_604761.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604761, url, valid)

proc call*(call_604762: Call_ListThingsInThingGroup_604747; thingGroupName: string;
          nextToken: string = ""; recursive: bool = false; maxResults: int = 0): Recallable =
  ## listThingsInThingGroup
  ## Lists the things in the specified group.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: string (required)
  ##                 : The thing group name.
  ##   recursive: bool
  ##            : When true, list things in this thing group and in all child groups as well.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_604763 = newJObject()
  var query_604764 = newJObject()
  add(query_604764, "nextToken", newJString(nextToken))
  add(path_604763, "thingGroupName", newJString(thingGroupName))
  add(query_604764, "recursive", newJBool(recursive))
  add(query_604764, "maxResults", newJInt(maxResults))
  result = call_604762.call(path_604763, query_604764, nil, nil, nil)

var listThingsInThingGroup* = Call_ListThingsInThingGroup_604747(
    name: "listThingsInThingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-groups/{thingGroupName}/things",
    validator: validate_ListThingsInThingGroup_604748, base: "/",
    url: url_ListThingsInThingGroup_604749, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTopicRules_604765 = ref object of OpenApiRestCall_601389
proc url_ListTopicRules_604767(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListTopicRules_604766(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the rules for the specific topic.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token used to retrieve the next value.
  ##   topic: JString
  ##        : The topic.
  ##   ruleDisabled: JBool
  ##               : Specifies whether the rule is disabled.
  ##   maxResults: JInt
  ##             : The maximum number of results to return.
  section = newJObject()
  var valid_604768 = query.getOrDefault("nextToken")
  valid_604768 = validateParameter(valid_604768, JString, required = false,
                                 default = nil)
  if valid_604768 != nil:
    section.add "nextToken", valid_604768
  var valid_604769 = query.getOrDefault("topic")
  valid_604769 = validateParameter(valid_604769, JString, required = false,
                                 default = nil)
  if valid_604769 != nil:
    section.add "topic", valid_604769
  var valid_604770 = query.getOrDefault("ruleDisabled")
  valid_604770 = validateParameter(valid_604770, JBool, required = false, default = nil)
  if valid_604770 != nil:
    section.add "ruleDisabled", valid_604770
  var valid_604771 = query.getOrDefault("maxResults")
  valid_604771 = validateParameter(valid_604771, JInt, required = false, default = nil)
  if valid_604771 != nil:
    section.add "maxResults", valid_604771
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604772 = header.getOrDefault("X-Amz-Signature")
  valid_604772 = validateParameter(valid_604772, JString, required = false,
                                 default = nil)
  if valid_604772 != nil:
    section.add "X-Amz-Signature", valid_604772
  var valid_604773 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604773 = validateParameter(valid_604773, JString, required = false,
                                 default = nil)
  if valid_604773 != nil:
    section.add "X-Amz-Content-Sha256", valid_604773
  var valid_604774 = header.getOrDefault("X-Amz-Date")
  valid_604774 = validateParameter(valid_604774, JString, required = false,
                                 default = nil)
  if valid_604774 != nil:
    section.add "X-Amz-Date", valid_604774
  var valid_604775 = header.getOrDefault("X-Amz-Credential")
  valid_604775 = validateParameter(valid_604775, JString, required = false,
                                 default = nil)
  if valid_604775 != nil:
    section.add "X-Amz-Credential", valid_604775
  var valid_604776 = header.getOrDefault("X-Amz-Security-Token")
  valid_604776 = validateParameter(valid_604776, JString, required = false,
                                 default = nil)
  if valid_604776 != nil:
    section.add "X-Amz-Security-Token", valid_604776
  var valid_604777 = header.getOrDefault("X-Amz-Algorithm")
  valid_604777 = validateParameter(valid_604777, JString, required = false,
                                 default = nil)
  if valid_604777 != nil:
    section.add "X-Amz-Algorithm", valid_604777
  var valid_604778 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604778 = validateParameter(valid_604778, JString, required = false,
                                 default = nil)
  if valid_604778 != nil:
    section.add "X-Amz-SignedHeaders", valid_604778
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604779: Call_ListTopicRules_604765; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the rules for the specific topic.
  ## 
  let valid = call_604779.validator(path, query, header, formData, body)
  let scheme = call_604779.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604779.url(scheme.get, call_604779.host, call_604779.base,
                         call_604779.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604779, url, valid)

proc call*(call_604780: Call_ListTopicRules_604765; nextToken: string = "";
          topic: string = ""; ruleDisabled: bool = false; maxResults: int = 0): Recallable =
  ## listTopicRules
  ## Lists the rules for the specific topic.
  ##   nextToken: string
  ##            : A token used to retrieve the next value.
  ##   topic: string
  ##        : The topic.
  ##   ruleDisabled: bool
  ##               : Specifies whether the rule is disabled.
  ##   maxResults: int
  ##             : The maximum number of results to return.
  var query_604781 = newJObject()
  add(query_604781, "nextToken", newJString(nextToken))
  add(query_604781, "topic", newJString(topic))
  add(query_604781, "ruleDisabled", newJBool(ruleDisabled))
  add(query_604781, "maxResults", newJInt(maxResults))
  result = call_604780.call(nil, query_604781, nil, nil, nil)

var listTopicRules* = Call_ListTopicRules_604765(name: "listTopicRules",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/rules",
    validator: validate_ListTopicRules_604766, base: "/", url: url_ListTopicRules_604767,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetV2LoggingLevel_604798 = ref object of OpenApiRestCall_601389
proc url_SetV2LoggingLevel_604800(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetV2LoggingLevel_604799(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Sets the logging level.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604801 = header.getOrDefault("X-Amz-Signature")
  valid_604801 = validateParameter(valid_604801, JString, required = false,
                                 default = nil)
  if valid_604801 != nil:
    section.add "X-Amz-Signature", valid_604801
  var valid_604802 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604802 = validateParameter(valid_604802, JString, required = false,
                                 default = nil)
  if valid_604802 != nil:
    section.add "X-Amz-Content-Sha256", valid_604802
  var valid_604803 = header.getOrDefault("X-Amz-Date")
  valid_604803 = validateParameter(valid_604803, JString, required = false,
                                 default = nil)
  if valid_604803 != nil:
    section.add "X-Amz-Date", valid_604803
  var valid_604804 = header.getOrDefault("X-Amz-Credential")
  valid_604804 = validateParameter(valid_604804, JString, required = false,
                                 default = nil)
  if valid_604804 != nil:
    section.add "X-Amz-Credential", valid_604804
  var valid_604805 = header.getOrDefault("X-Amz-Security-Token")
  valid_604805 = validateParameter(valid_604805, JString, required = false,
                                 default = nil)
  if valid_604805 != nil:
    section.add "X-Amz-Security-Token", valid_604805
  var valid_604806 = header.getOrDefault("X-Amz-Algorithm")
  valid_604806 = validateParameter(valid_604806, JString, required = false,
                                 default = nil)
  if valid_604806 != nil:
    section.add "X-Amz-Algorithm", valid_604806
  var valid_604807 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604807 = validateParameter(valid_604807, JString, required = false,
                                 default = nil)
  if valid_604807 != nil:
    section.add "X-Amz-SignedHeaders", valid_604807
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604809: Call_SetV2LoggingLevel_604798; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the logging level.
  ## 
  let valid = call_604809.validator(path, query, header, formData, body)
  let scheme = call_604809.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604809.url(scheme.get, call_604809.host, call_604809.base,
                         call_604809.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604809, url, valid)

proc call*(call_604810: Call_SetV2LoggingLevel_604798; body: JsonNode): Recallable =
  ## setV2LoggingLevel
  ## Sets the logging level.
  ##   body: JObject (required)
  var body_604811 = newJObject()
  if body != nil:
    body_604811 = body
  result = call_604810.call(nil, nil, nil, nil, body_604811)

var setV2LoggingLevel* = Call_SetV2LoggingLevel_604798(name: "setV2LoggingLevel",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/v2LoggingLevel",
    validator: validate_SetV2LoggingLevel_604799, base: "/",
    url: url_SetV2LoggingLevel_604800, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListV2LoggingLevels_604782 = ref object of OpenApiRestCall_601389
proc url_ListV2LoggingLevels_604784(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListV2LoggingLevels_604783(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists logging levels.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token used to get the next set of results, or <b>null</b> if there are no additional results.
  ##   targetType: JString
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_604785 = query.getOrDefault("nextToken")
  valid_604785 = validateParameter(valid_604785, JString, required = false,
                                 default = nil)
  if valid_604785 != nil:
    section.add "nextToken", valid_604785
  var valid_604786 = query.getOrDefault("targetType")
  valid_604786 = validateParameter(valid_604786, JString, required = false,
                                 default = newJString("DEFAULT"))
  if valid_604786 != nil:
    section.add "targetType", valid_604786
  var valid_604787 = query.getOrDefault("maxResults")
  valid_604787 = validateParameter(valid_604787, JInt, required = false, default = nil)
  if valid_604787 != nil:
    section.add "maxResults", valid_604787
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604788 = header.getOrDefault("X-Amz-Signature")
  valid_604788 = validateParameter(valid_604788, JString, required = false,
                                 default = nil)
  if valid_604788 != nil:
    section.add "X-Amz-Signature", valid_604788
  var valid_604789 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604789 = validateParameter(valid_604789, JString, required = false,
                                 default = nil)
  if valid_604789 != nil:
    section.add "X-Amz-Content-Sha256", valid_604789
  var valid_604790 = header.getOrDefault("X-Amz-Date")
  valid_604790 = validateParameter(valid_604790, JString, required = false,
                                 default = nil)
  if valid_604790 != nil:
    section.add "X-Amz-Date", valid_604790
  var valid_604791 = header.getOrDefault("X-Amz-Credential")
  valid_604791 = validateParameter(valid_604791, JString, required = false,
                                 default = nil)
  if valid_604791 != nil:
    section.add "X-Amz-Credential", valid_604791
  var valid_604792 = header.getOrDefault("X-Amz-Security-Token")
  valid_604792 = validateParameter(valid_604792, JString, required = false,
                                 default = nil)
  if valid_604792 != nil:
    section.add "X-Amz-Security-Token", valid_604792
  var valid_604793 = header.getOrDefault("X-Amz-Algorithm")
  valid_604793 = validateParameter(valid_604793, JString, required = false,
                                 default = nil)
  if valid_604793 != nil:
    section.add "X-Amz-Algorithm", valid_604793
  var valid_604794 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604794 = validateParameter(valid_604794, JString, required = false,
                                 default = nil)
  if valid_604794 != nil:
    section.add "X-Amz-SignedHeaders", valid_604794
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604795: Call_ListV2LoggingLevels_604782; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists logging levels.
  ## 
  let valid = call_604795.validator(path, query, header, formData, body)
  let scheme = call_604795.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604795.url(scheme.get, call_604795.host, call_604795.base,
                         call_604795.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604795, url, valid)

proc call*(call_604796: Call_ListV2LoggingLevels_604782; nextToken: string = "";
          targetType: string = "DEFAULT"; maxResults: int = 0): Recallable =
  ## listV2LoggingLevels
  ## Lists logging levels.
  ##   nextToken: string
  ##            : The token used to get the next set of results, or <b>null</b> if there are no additional results.
  ##   targetType: string
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_604797 = newJObject()
  add(query_604797, "nextToken", newJString(nextToken))
  add(query_604797, "targetType", newJString(targetType))
  add(query_604797, "maxResults", newJInt(maxResults))
  result = call_604796.call(nil, query_604797, nil, nil, nil)

var listV2LoggingLevels* = Call_ListV2LoggingLevels_604782(
    name: "listV2LoggingLevels", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/v2LoggingLevel",
    validator: validate_ListV2LoggingLevels_604783, base: "/",
    url: url_ListV2LoggingLevels_604784, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListViolationEvents_604812 = ref object of OpenApiRestCall_601389
proc url_ListViolationEvents_604814(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListViolationEvents_604813(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endTime: JString (required)
  ##          : The end time for the alerts to be listed.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : The start time for the alerts to be listed.
  ##   securityProfileName: JString
  ##                      : A filter to limit results to those alerts generated by the specified security profile.
  ##   thingName: JString
  ##            : A filter to limit results to those alerts caused by the specified thing.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_604815 = query.getOrDefault("endTime")
  valid_604815 = validateParameter(valid_604815, JString, required = true,
                                 default = nil)
  if valid_604815 != nil:
    section.add "endTime", valid_604815
  var valid_604816 = query.getOrDefault("nextToken")
  valid_604816 = validateParameter(valid_604816, JString, required = false,
                                 default = nil)
  if valid_604816 != nil:
    section.add "nextToken", valid_604816
  var valid_604817 = query.getOrDefault("startTime")
  valid_604817 = validateParameter(valid_604817, JString, required = true,
                                 default = nil)
  if valid_604817 != nil:
    section.add "startTime", valid_604817
  var valid_604818 = query.getOrDefault("securityProfileName")
  valid_604818 = validateParameter(valid_604818, JString, required = false,
                                 default = nil)
  if valid_604818 != nil:
    section.add "securityProfileName", valid_604818
  var valid_604819 = query.getOrDefault("thingName")
  valid_604819 = validateParameter(valid_604819, JString, required = false,
                                 default = nil)
  if valid_604819 != nil:
    section.add "thingName", valid_604819
  var valid_604820 = query.getOrDefault("maxResults")
  valid_604820 = validateParameter(valid_604820, JInt, required = false, default = nil)
  if valid_604820 != nil:
    section.add "maxResults", valid_604820
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604821 = header.getOrDefault("X-Amz-Signature")
  valid_604821 = validateParameter(valid_604821, JString, required = false,
                                 default = nil)
  if valid_604821 != nil:
    section.add "X-Amz-Signature", valid_604821
  var valid_604822 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604822 = validateParameter(valid_604822, JString, required = false,
                                 default = nil)
  if valid_604822 != nil:
    section.add "X-Amz-Content-Sha256", valid_604822
  var valid_604823 = header.getOrDefault("X-Amz-Date")
  valid_604823 = validateParameter(valid_604823, JString, required = false,
                                 default = nil)
  if valid_604823 != nil:
    section.add "X-Amz-Date", valid_604823
  var valid_604824 = header.getOrDefault("X-Amz-Credential")
  valid_604824 = validateParameter(valid_604824, JString, required = false,
                                 default = nil)
  if valid_604824 != nil:
    section.add "X-Amz-Credential", valid_604824
  var valid_604825 = header.getOrDefault("X-Amz-Security-Token")
  valid_604825 = validateParameter(valid_604825, JString, required = false,
                                 default = nil)
  if valid_604825 != nil:
    section.add "X-Amz-Security-Token", valid_604825
  var valid_604826 = header.getOrDefault("X-Amz-Algorithm")
  valid_604826 = validateParameter(valid_604826, JString, required = false,
                                 default = nil)
  if valid_604826 != nil:
    section.add "X-Amz-Algorithm", valid_604826
  var valid_604827 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604827 = validateParameter(valid_604827, JString, required = false,
                                 default = nil)
  if valid_604827 != nil:
    section.add "X-Amz-SignedHeaders", valid_604827
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604828: Call_ListViolationEvents_604812; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ## 
  let valid = call_604828.validator(path, query, header, formData, body)
  let scheme = call_604828.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604828.url(scheme.get, call_604828.host, call_604828.base,
                         call_604828.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604828, url, valid)

proc call*(call_604829: Call_ListViolationEvents_604812; endTime: string;
          startTime: string; nextToken: string = ""; securityProfileName: string = "";
          thingName: string = ""; maxResults: int = 0): Recallable =
  ## listViolationEvents
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ##   endTime: string (required)
  ##          : The end time for the alerts to be listed.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : The start time for the alerts to be listed.
  ##   securityProfileName: string
  ##                      : A filter to limit results to those alerts generated by the specified security profile.
  ##   thingName: string
  ##            : A filter to limit results to those alerts caused by the specified thing.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_604830 = newJObject()
  add(query_604830, "endTime", newJString(endTime))
  add(query_604830, "nextToken", newJString(nextToken))
  add(query_604830, "startTime", newJString(startTime))
  add(query_604830, "securityProfileName", newJString(securityProfileName))
  add(query_604830, "thingName", newJString(thingName))
  add(query_604830, "maxResults", newJInt(maxResults))
  result = call_604829.call(nil, query_604830, nil, nil, nil)

var listViolationEvents* = Call_ListViolationEvents_604812(
    name: "listViolationEvents", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/violation-events#startTime&endTime",
    validator: validate_ListViolationEvents_604813, base: "/",
    url: url_ListViolationEvents_604814, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterCACertificate_604831 = ref object of OpenApiRestCall_601389
proc url_RegisterCACertificate_604833(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RegisterCACertificate_604832(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   allowAutoRegistration: JBool
  ##                        : Allows this CA certificate to be used for auto registration of device certificates.
  ##   setAsActive: JBool
  ##              : A boolean value that specifies if the CA certificate is set to active.
  section = newJObject()
  var valid_604834 = query.getOrDefault("allowAutoRegistration")
  valid_604834 = validateParameter(valid_604834, JBool, required = false, default = nil)
  if valid_604834 != nil:
    section.add "allowAutoRegistration", valid_604834
  var valid_604835 = query.getOrDefault("setAsActive")
  valid_604835 = validateParameter(valid_604835, JBool, required = false, default = nil)
  if valid_604835 != nil:
    section.add "setAsActive", valid_604835
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604836 = header.getOrDefault("X-Amz-Signature")
  valid_604836 = validateParameter(valid_604836, JString, required = false,
                                 default = nil)
  if valid_604836 != nil:
    section.add "X-Amz-Signature", valid_604836
  var valid_604837 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604837 = validateParameter(valid_604837, JString, required = false,
                                 default = nil)
  if valid_604837 != nil:
    section.add "X-Amz-Content-Sha256", valid_604837
  var valid_604838 = header.getOrDefault("X-Amz-Date")
  valid_604838 = validateParameter(valid_604838, JString, required = false,
                                 default = nil)
  if valid_604838 != nil:
    section.add "X-Amz-Date", valid_604838
  var valid_604839 = header.getOrDefault("X-Amz-Credential")
  valid_604839 = validateParameter(valid_604839, JString, required = false,
                                 default = nil)
  if valid_604839 != nil:
    section.add "X-Amz-Credential", valid_604839
  var valid_604840 = header.getOrDefault("X-Amz-Security-Token")
  valid_604840 = validateParameter(valid_604840, JString, required = false,
                                 default = nil)
  if valid_604840 != nil:
    section.add "X-Amz-Security-Token", valid_604840
  var valid_604841 = header.getOrDefault("X-Amz-Algorithm")
  valid_604841 = validateParameter(valid_604841, JString, required = false,
                                 default = nil)
  if valid_604841 != nil:
    section.add "X-Amz-Algorithm", valid_604841
  var valid_604842 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604842 = validateParameter(valid_604842, JString, required = false,
                                 default = nil)
  if valid_604842 != nil:
    section.add "X-Amz-SignedHeaders", valid_604842
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604844: Call_RegisterCACertificate_604831; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ## 
  let valid = call_604844.validator(path, query, header, formData, body)
  let scheme = call_604844.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604844.url(scheme.get, call_604844.host, call_604844.base,
                         call_604844.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604844, url, valid)

proc call*(call_604845: Call_RegisterCACertificate_604831; body: JsonNode;
          allowAutoRegistration: bool = false; setAsActive: bool = false): Recallable =
  ## registerCACertificate
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ##   allowAutoRegistration: bool
  ##                        : Allows this CA certificate to be used for auto registration of device certificates.
  ##   setAsActive: bool
  ##              : A boolean value that specifies if the CA certificate is set to active.
  ##   body: JObject (required)
  var query_604846 = newJObject()
  var body_604847 = newJObject()
  add(query_604846, "allowAutoRegistration", newJBool(allowAutoRegistration))
  add(query_604846, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_604847 = body
  result = call_604845.call(nil, query_604846, nil, nil, body_604847)

var registerCACertificate* = Call_RegisterCACertificate_604831(
    name: "registerCACertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/cacertificate",
    validator: validate_RegisterCACertificate_604832, base: "/",
    url: url_RegisterCACertificate_604833, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterCertificate_604848 = ref object of OpenApiRestCall_601389
proc url_RegisterCertificate_604850(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RegisterCertificate_604849(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : A boolean value that specifies if the certificate is set to active.
  section = newJObject()
  var valid_604851 = query.getOrDefault("setAsActive")
  valid_604851 = validateParameter(valid_604851, JBool, required = false, default = nil)
  if valid_604851 != nil:
    section.add "setAsActive", valid_604851
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604852 = header.getOrDefault("X-Amz-Signature")
  valid_604852 = validateParameter(valid_604852, JString, required = false,
                                 default = nil)
  if valid_604852 != nil:
    section.add "X-Amz-Signature", valid_604852
  var valid_604853 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604853 = validateParameter(valid_604853, JString, required = false,
                                 default = nil)
  if valid_604853 != nil:
    section.add "X-Amz-Content-Sha256", valid_604853
  var valid_604854 = header.getOrDefault("X-Amz-Date")
  valid_604854 = validateParameter(valid_604854, JString, required = false,
                                 default = nil)
  if valid_604854 != nil:
    section.add "X-Amz-Date", valid_604854
  var valid_604855 = header.getOrDefault("X-Amz-Credential")
  valid_604855 = validateParameter(valid_604855, JString, required = false,
                                 default = nil)
  if valid_604855 != nil:
    section.add "X-Amz-Credential", valid_604855
  var valid_604856 = header.getOrDefault("X-Amz-Security-Token")
  valid_604856 = validateParameter(valid_604856, JString, required = false,
                                 default = nil)
  if valid_604856 != nil:
    section.add "X-Amz-Security-Token", valid_604856
  var valid_604857 = header.getOrDefault("X-Amz-Algorithm")
  valid_604857 = validateParameter(valid_604857, JString, required = false,
                                 default = nil)
  if valid_604857 != nil:
    section.add "X-Amz-Algorithm", valid_604857
  var valid_604858 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604858 = validateParameter(valid_604858, JString, required = false,
                                 default = nil)
  if valid_604858 != nil:
    section.add "X-Amz-SignedHeaders", valid_604858
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604860: Call_RegisterCertificate_604848; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ## 
  let valid = call_604860.validator(path, query, header, formData, body)
  let scheme = call_604860.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604860.url(scheme.get, call_604860.host, call_604860.base,
                         call_604860.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604860, url, valid)

proc call*(call_604861: Call_RegisterCertificate_604848; body: JsonNode;
          setAsActive: bool = false): Recallable =
  ## registerCertificate
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ##   setAsActive: bool
  ##              : A boolean value that specifies if the certificate is set to active.
  ##   body: JObject (required)
  var query_604862 = newJObject()
  var body_604863 = newJObject()
  add(query_604862, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_604863 = body
  result = call_604861.call(nil, query_604862, nil, nil, body_604863)

var registerCertificate* = Call_RegisterCertificate_604848(
    name: "registerCertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/certificate/register",
    validator: validate_RegisterCertificate_604849, base: "/",
    url: url_RegisterCertificate_604850, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RejectCertificateTransfer_604864 = ref object of OpenApiRestCall_601389
proc url_RejectCertificateTransfer_604866(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/reject-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_RejectCertificateTransfer_604865(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_604867 = path.getOrDefault("certificateId")
  valid_604867 = validateParameter(valid_604867, JString, required = true,
                                 default = nil)
  if valid_604867 != nil:
    section.add "certificateId", valid_604867
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604868 = header.getOrDefault("X-Amz-Signature")
  valid_604868 = validateParameter(valid_604868, JString, required = false,
                                 default = nil)
  if valid_604868 != nil:
    section.add "X-Amz-Signature", valid_604868
  var valid_604869 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604869 = validateParameter(valid_604869, JString, required = false,
                                 default = nil)
  if valid_604869 != nil:
    section.add "X-Amz-Content-Sha256", valid_604869
  var valid_604870 = header.getOrDefault("X-Amz-Date")
  valid_604870 = validateParameter(valid_604870, JString, required = false,
                                 default = nil)
  if valid_604870 != nil:
    section.add "X-Amz-Date", valid_604870
  var valid_604871 = header.getOrDefault("X-Amz-Credential")
  valid_604871 = validateParameter(valid_604871, JString, required = false,
                                 default = nil)
  if valid_604871 != nil:
    section.add "X-Amz-Credential", valid_604871
  var valid_604872 = header.getOrDefault("X-Amz-Security-Token")
  valid_604872 = validateParameter(valid_604872, JString, required = false,
                                 default = nil)
  if valid_604872 != nil:
    section.add "X-Amz-Security-Token", valid_604872
  var valid_604873 = header.getOrDefault("X-Amz-Algorithm")
  valid_604873 = validateParameter(valid_604873, JString, required = false,
                                 default = nil)
  if valid_604873 != nil:
    section.add "X-Amz-Algorithm", valid_604873
  var valid_604874 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604874 = validateParameter(valid_604874, JString, required = false,
                                 default = nil)
  if valid_604874 != nil:
    section.add "X-Amz-SignedHeaders", valid_604874
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604876: Call_RejectCertificateTransfer_604864; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ## 
  let valid = call_604876.validator(path, query, header, formData, body)
  let scheme = call_604876.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604876.url(scheme.get, call_604876.host, call_604876.base,
                         call_604876.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604876, url, valid)

proc call*(call_604877: Call_RejectCertificateTransfer_604864; body: JsonNode;
          certificateId: string): Recallable =
  ## rejectCertificateTransfer
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ##   body: JObject (required)
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_604878 = newJObject()
  var body_604879 = newJObject()
  if body != nil:
    body_604879 = body
  add(path_604878, "certificateId", newJString(certificateId))
  result = call_604877.call(path_604878, nil, nil, nil, body_604879)

var rejectCertificateTransfer* = Call_RejectCertificateTransfer_604864(
    name: "rejectCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/reject-certificate-transfer/{certificateId}",
    validator: validate_RejectCertificateTransfer_604865, base: "/",
    url: url_RejectCertificateTransfer_604866,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveThingFromBillingGroup_604880 = ref object of OpenApiRestCall_601389
proc url_RemoveThingFromBillingGroup_604882(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RemoveThingFromBillingGroup_604881(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes the given thing from the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604883 = header.getOrDefault("X-Amz-Signature")
  valid_604883 = validateParameter(valid_604883, JString, required = false,
                                 default = nil)
  if valid_604883 != nil:
    section.add "X-Amz-Signature", valid_604883
  var valid_604884 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604884 = validateParameter(valid_604884, JString, required = false,
                                 default = nil)
  if valid_604884 != nil:
    section.add "X-Amz-Content-Sha256", valid_604884
  var valid_604885 = header.getOrDefault("X-Amz-Date")
  valid_604885 = validateParameter(valid_604885, JString, required = false,
                                 default = nil)
  if valid_604885 != nil:
    section.add "X-Amz-Date", valid_604885
  var valid_604886 = header.getOrDefault("X-Amz-Credential")
  valid_604886 = validateParameter(valid_604886, JString, required = false,
                                 default = nil)
  if valid_604886 != nil:
    section.add "X-Amz-Credential", valid_604886
  var valid_604887 = header.getOrDefault("X-Amz-Security-Token")
  valid_604887 = validateParameter(valid_604887, JString, required = false,
                                 default = nil)
  if valid_604887 != nil:
    section.add "X-Amz-Security-Token", valid_604887
  var valid_604888 = header.getOrDefault("X-Amz-Algorithm")
  valid_604888 = validateParameter(valid_604888, JString, required = false,
                                 default = nil)
  if valid_604888 != nil:
    section.add "X-Amz-Algorithm", valid_604888
  var valid_604889 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604889 = validateParameter(valid_604889, JString, required = false,
                                 default = nil)
  if valid_604889 != nil:
    section.add "X-Amz-SignedHeaders", valid_604889
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604891: Call_RemoveThingFromBillingGroup_604880; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes the given thing from the billing group.
  ## 
  let valid = call_604891.validator(path, query, header, formData, body)
  let scheme = call_604891.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604891.url(scheme.get, call_604891.host, call_604891.base,
                         call_604891.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604891, url, valid)

proc call*(call_604892: Call_RemoveThingFromBillingGroup_604880; body: JsonNode): Recallable =
  ## removeThingFromBillingGroup
  ## Removes the given thing from the billing group.
  ##   body: JObject (required)
  var body_604893 = newJObject()
  if body != nil:
    body_604893 = body
  result = call_604892.call(nil, nil, nil, nil, body_604893)

var removeThingFromBillingGroup* = Call_RemoveThingFromBillingGroup_604880(
    name: "removeThingFromBillingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/billing-groups/removeThingFromBillingGroup",
    validator: validate_RemoveThingFromBillingGroup_604881, base: "/",
    url: url_RemoveThingFromBillingGroup_604882,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveThingFromThingGroup_604894 = ref object of OpenApiRestCall_601389
proc url_RemoveThingFromThingGroup_604896(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RemoveThingFromThingGroup_604895(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove the specified thing from the specified group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604897 = header.getOrDefault("X-Amz-Signature")
  valid_604897 = validateParameter(valid_604897, JString, required = false,
                                 default = nil)
  if valid_604897 != nil:
    section.add "X-Amz-Signature", valid_604897
  var valid_604898 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604898 = validateParameter(valid_604898, JString, required = false,
                                 default = nil)
  if valid_604898 != nil:
    section.add "X-Amz-Content-Sha256", valid_604898
  var valid_604899 = header.getOrDefault("X-Amz-Date")
  valid_604899 = validateParameter(valid_604899, JString, required = false,
                                 default = nil)
  if valid_604899 != nil:
    section.add "X-Amz-Date", valid_604899
  var valid_604900 = header.getOrDefault("X-Amz-Credential")
  valid_604900 = validateParameter(valid_604900, JString, required = false,
                                 default = nil)
  if valid_604900 != nil:
    section.add "X-Amz-Credential", valid_604900
  var valid_604901 = header.getOrDefault("X-Amz-Security-Token")
  valid_604901 = validateParameter(valid_604901, JString, required = false,
                                 default = nil)
  if valid_604901 != nil:
    section.add "X-Amz-Security-Token", valid_604901
  var valid_604902 = header.getOrDefault("X-Amz-Algorithm")
  valid_604902 = validateParameter(valid_604902, JString, required = false,
                                 default = nil)
  if valid_604902 != nil:
    section.add "X-Amz-Algorithm", valid_604902
  var valid_604903 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604903 = validateParameter(valid_604903, JString, required = false,
                                 default = nil)
  if valid_604903 != nil:
    section.add "X-Amz-SignedHeaders", valid_604903
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604905: Call_RemoveThingFromThingGroup_604894; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Remove the specified thing from the specified group.
  ## 
  let valid = call_604905.validator(path, query, header, formData, body)
  let scheme = call_604905.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604905.url(scheme.get, call_604905.host, call_604905.base,
                         call_604905.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604905, url, valid)

proc call*(call_604906: Call_RemoveThingFromThingGroup_604894; body: JsonNode): Recallable =
  ## removeThingFromThingGroup
  ## Remove the specified thing from the specified group.
  ##   body: JObject (required)
  var body_604907 = newJObject()
  if body != nil:
    body_604907 = body
  result = call_604906.call(nil, nil, nil, nil, body_604907)

var removeThingFromThingGroup* = Call_RemoveThingFromThingGroup_604894(
    name: "removeThingFromThingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/removeThingFromThingGroup",
    validator: validate_RemoveThingFromThingGroup_604895, base: "/",
    url: url_RemoveThingFromThingGroup_604896,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_SearchIndex_604908 = ref object of OpenApiRestCall_601389
proc url_SearchIndex_604910(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SearchIndex_604909(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## The query search index.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604911 = header.getOrDefault("X-Amz-Signature")
  valid_604911 = validateParameter(valid_604911, JString, required = false,
                                 default = nil)
  if valid_604911 != nil:
    section.add "X-Amz-Signature", valid_604911
  var valid_604912 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604912 = validateParameter(valid_604912, JString, required = false,
                                 default = nil)
  if valid_604912 != nil:
    section.add "X-Amz-Content-Sha256", valid_604912
  var valid_604913 = header.getOrDefault("X-Amz-Date")
  valid_604913 = validateParameter(valid_604913, JString, required = false,
                                 default = nil)
  if valid_604913 != nil:
    section.add "X-Amz-Date", valid_604913
  var valid_604914 = header.getOrDefault("X-Amz-Credential")
  valid_604914 = validateParameter(valid_604914, JString, required = false,
                                 default = nil)
  if valid_604914 != nil:
    section.add "X-Amz-Credential", valid_604914
  var valid_604915 = header.getOrDefault("X-Amz-Security-Token")
  valid_604915 = validateParameter(valid_604915, JString, required = false,
                                 default = nil)
  if valid_604915 != nil:
    section.add "X-Amz-Security-Token", valid_604915
  var valid_604916 = header.getOrDefault("X-Amz-Algorithm")
  valid_604916 = validateParameter(valid_604916, JString, required = false,
                                 default = nil)
  if valid_604916 != nil:
    section.add "X-Amz-Algorithm", valid_604916
  var valid_604917 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604917 = validateParameter(valid_604917, JString, required = false,
                                 default = nil)
  if valid_604917 != nil:
    section.add "X-Amz-SignedHeaders", valid_604917
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604919: Call_SearchIndex_604908; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The query search index.
  ## 
  let valid = call_604919.validator(path, query, header, formData, body)
  let scheme = call_604919.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604919.url(scheme.get, call_604919.host, call_604919.base,
                         call_604919.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604919, url, valid)

proc call*(call_604920: Call_SearchIndex_604908; body: JsonNode): Recallable =
  ## searchIndex
  ## The query search index.
  ##   body: JObject (required)
  var body_604921 = newJObject()
  if body != nil:
    body_604921 = body
  result = call_604920.call(nil, nil, nil, nil, body_604921)

var searchIndex* = Call_SearchIndex_604908(name: "searchIndex",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com",
                                        route: "/indices/search",
                                        validator: validate_SearchIndex_604909,
                                        base: "/", url: url_SearchIndex_604910,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartOnDemandAuditTask_604922 = ref object of OpenApiRestCall_601389
proc url_StartOnDemandAuditTask_604924(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_StartOnDemandAuditTask_604923(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts an on-demand Device Defender audit.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604925 = header.getOrDefault("X-Amz-Signature")
  valid_604925 = validateParameter(valid_604925, JString, required = false,
                                 default = nil)
  if valid_604925 != nil:
    section.add "X-Amz-Signature", valid_604925
  var valid_604926 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604926 = validateParameter(valid_604926, JString, required = false,
                                 default = nil)
  if valid_604926 != nil:
    section.add "X-Amz-Content-Sha256", valid_604926
  var valid_604927 = header.getOrDefault("X-Amz-Date")
  valid_604927 = validateParameter(valid_604927, JString, required = false,
                                 default = nil)
  if valid_604927 != nil:
    section.add "X-Amz-Date", valid_604927
  var valid_604928 = header.getOrDefault("X-Amz-Credential")
  valid_604928 = validateParameter(valid_604928, JString, required = false,
                                 default = nil)
  if valid_604928 != nil:
    section.add "X-Amz-Credential", valid_604928
  var valid_604929 = header.getOrDefault("X-Amz-Security-Token")
  valid_604929 = validateParameter(valid_604929, JString, required = false,
                                 default = nil)
  if valid_604929 != nil:
    section.add "X-Amz-Security-Token", valid_604929
  var valid_604930 = header.getOrDefault("X-Amz-Algorithm")
  valid_604930 = validateParameter(valid_604930, JString, required = false,
                                 default = nil)
  if valid_604930 != nil:
    section.add "X-Amz-Algorithm", valid_604930
  var valid_604931 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604931 = validateParameter(valid_604931, JString, required = false,
                                 default = nil)
  if valid_604931 != nil:
    section.add "X-Amz-SignedHeaders", valid_604931
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604933: Call_StartOnDemandAuditTask_604922; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts an on-demand Device Defender audit.
  ## 
  let valid = call_604933.validator(path, query, header, formData, body)
  let scheme = call_604933.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604933.url(scheme.get, call_604933.host, call_604933.base,
                         call_604933.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604933, url, valid)

proc call*(call_604934: Call_StartOnDemandAuditTask_604922; body: JsonNode): Recallable =
  ## startOnDemandAuditTask
  ## Starts an on-demand Device Defender audit.
  ##   body: JObject (required)
  var body_604935 = newJObject()
  if body != nil:
    body_604935 = body
  result = call_604934.call(nil, nil, nil, nil, body_604935)

var startOnDemandAuditTask* = Call_StartOnDemandAuditTask_604922(
    name: "startOnDemandAuditTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/audit/tasks",
    validator: validate_StartOnDemandAuditTask_604923, base: "/",
    url: url_StartOnDemandAuditTask_604924, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StopThingRegistrationTask_604936 = ref object of OpenApiRestCall_601389
proc url_StopThingRegistrationTask_604938(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_StopThingRegistrationTask_604937(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The bulk thing provisioning task ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_604939 = path.getOrDefault("taskId")
  valid_604939 = validateParameter(valid_604939, JString, required = true,
                                 default = nil)
  if valid_604939 != nil:
    section.add "taskId", valid_604939
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604940 = header.getOrDefault("X-Amz-Signature")
  valid_604940 = validateParameter(valid_604940, JString, required = false,
                                 default = nil)
  if valid_604940 != nil:
    section.add "X-Amz-Signature", valid_604940
  var valid_604941 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604941 = validateParameter(valid_604941, JString, required = false,
                                 default = nil)
  if valid_604941 != nil:
    section.add "X-Amz-Content-Sha256", valid_604941
  var valid_604942 = header.getOrDefault("X-Amz-Date")
  valid_604942 = validateParameter(valid_604942, JString, required = false,
                                 default = nil)
  if valid_604942 != nil:
    section.add "X-Amz-Date", valid_604942
  var valid_604943 = header.getOrDefault("X-Amz-Credential")
  valid_604943 = validateParameter(valid_604943, JString, required = false,
                                 default = nil)
  if valid_604943 != nil:
    section.add "X-Amz-Credential", valid_604943
  var valid_604944 = header.getOrDefault("X-Amz-Security-Token")
  valid_604944 = validateParameter(valid_604944, JString, required = false,
                                 default = nil)
  if valid_604944 != nil:
    section.add "X-Amz-Security-Token", valid_604944
  var valid_604945 = header.getOrDefault("X-Amz-Algorithm")
  valid_604945 = validateParameter(valid_604945, JString, required = false,
                                 default = nil)
  if valid_604945 != nil:
    section.add "X-Amz-Algorithm", valid_604945
  var valid_604946 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604946 = validateParameter(valid_604946, JString, required = false,
                                 default = nil)
  if valid_604946 != nil:
    section.add "X-Amz-SignedHeaders", valid_604946
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604947: Call_StopThingRegistrationTask_604936; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a bulk thing provisioning task.
  ## 
  let valid = call_604947.validator(path, query, header, formData, body)
  let scheme = call_604947.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604947.url(scheme.get, call_604947.host, call_604947.base,
                         call_604947.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604947, url, valid)

proc call*(call_604948: Call_StopThingRegistrationTask_604936; taskId: string): Recallable =
  ## stopThingRegistrationTask
  ## Cancels a bulk thing provisioning task.
  ##   taskId: string (required)
  ##         : The bulk thing provisioning task ID.
  var path_604949 = newJObject()
  add(path_604949, "taskId", newJString(taskId))
  result = call_604948.call(path_604949, nil, nil, nil, nil)

var stopThingRegistrationTask* = Call_StopThingRegistrationTask_604936(
    name: "stopThingRegistrationTask", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks/{taskId}/cancel",
    validator: validate_StopThingRegistrationTask_604937, base: "/",
    url: url_StopThingRegistrationTask_604938,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_TagResource_604950 = ref object of OpenApiRestCall_601389
proc url_TagResource_604952(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_TagResource_604951(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604953 = header.getOrDefault("X-Amz-Signature")
  valid_604953 = validateParameter(valid_604953, JString, required = false,
                                 default = nil)
  if valid_604953 != nil:
    section.add "X-Amz-Signature", valid_604953
  var valid_604954 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604954 = validateParameter(valid_604954, JString, required = false,
                                 default = nil)
  if valid_604954 != nil:
    section.add "X-Amz-Content-Sha256", valid_604954
  var valid_604955 = header.getOrDefault("X-Amz-Date")
  valid_604955 = validateParameter(valid_604955, JString, required = false,
                                 default = nil)
  if valid_604955 != nil:
    section.add "X-Amz-Date", valid_604955
  var valid_604956 = header.getOrDefault("X-Amz-Credential")
  valid_604956 = validateParameter(valid_604956, JString, required = false,
                                 default = nil)
  if valid_604956 != nil:
    section.add "X-Amz-Credential", valid_604956
  var valid_604957 = header.getOrDefault("X-Amz-Security-Token")
  valid_604957 = validateParameter(valid_604957, JString, required = false,
                                 default = nil)
  if valid_604957 != nil:
    section.add "X-Amz-Security-Token", valid_604957
  var valid_604958 = header.getOrDefault("X-Amz-Algorithm")
  valid_604958 = validateParameter(valid_604958, JString, required = false,
                                 default = nil)
  if valid_604958 != nil:
    section.add "X-Amz-Algorithm", valid_604958
  var valid_604959 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604959 = validateParameter(valid_604959, JString, required = false,
                                 default = nil)
  if valid_604959 != nil:
    section.add "X-Amz-SignedHeaders", valid_604959
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604961: Call_TagResource_604950; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ## 
  let valid = call_604961.validator(path, query, header, formData, body)
  let scheme = call_604961.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604961.url(scheme.get, call_604961.host, call_604961.base,
                         call_604961.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604961, url, valid)

proc call*(call_604962: Call_TagResource_604950; body: JsonNode): Recallable =
  ## tagResource
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ##   body: JObject (required)
  var body_604963 = newJObject()
  if body != nil:
    body_604963 = body
  result = call_604962.call(nil, nil, nil, nil, body_604963)

var tagResource* = Call_TagResource_604950(name: "tagResource",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com", route: "/tags",
                                        validator: validate_TagResource_604951,
                                        base: "/", url: url_TagResource_604952,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_TestAuthorization_604964 = ref object of OpenApiRestCall_601389
proc url_TestAuthorization_604966(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_TestAuthorization_604965(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   clientId: JString
  ##           : The MQTT client ID.
  section = newJObject()
  var valid_604967 = query.getOrDefault("clientId")
  valid_604967 = validateParameter(valid_604967, JString, required = false,
                                 default = nil)
  if valid_604967 != nil:
    section.add "clientId", valid_604967
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604968 = header.getOrDefault("X-Amz-Signature")
  valid_604968 = validateParameter(valid_604968, JString, required = false,
                                 default = nil)
  if valid_604968 != nil:
    section.add "X-Amz-Signature", valid_604968
  var valid_604969 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604969 = validateParameter(valid_604969, JString, required = false,
                                 default = nil)
  if valid_604969 != nil:
    section.add "X-Amz-Content-Sha256", valid_604969
  var valid_604970 = header.getOrDefault("X-Amz-Date")
  valid_604970 = validateParameter(valid_604970, JString, required = false,
                                 default = nil)
  if valid_604970 != nil:
    section.add "X-Amz-Date", valid_604970
  var valid_604971 = header.getOrDefault("X-Amz-Credential")
  valid_604971 = validateParameter(valid_604971, JString, required = false,
                                 default = nil)
  if valid_604971 != nil:
    section.add "X-Amz-Credential", valid_604971
  var valid_604972 = header.getOrDefault("X-Amz-Security-Token")
  valid_604972 = validateParameter(valid_604972, JString, required = false,
                                 default = nil)
  if valid_604972 != nil:
    section.add "X-Amz-Security-Token", valid_604972
  var valid_604973 = header.getOrDefault("X-Amz-Algorithm")
  valid_604973 = validateParameter(valid_604973, JString, required = false,
                                 default = nil)
  if valid_604973 != nil:
    section.add "X-Amz-Algorithm", valid_604973
  var valid_604974 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604974 = validateParameter(valid_604974, JString, required = false,
                                 default = nil)
  if valid_604974 != nil:
    section.add "X-Amz-SignedHeaders", valid_604974
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604976: Call_TestAuthorization_604964; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  let valid = call_604976.validator(path, query, header, formData, body)
  let scheme = call_604976.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604976.url(scheme.get, call_604976.host, call_604976.base,
                         call_604976.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604976, url, valid)

proc call*(call_604977: Call_TestAuthorization_604964; body: JsonNode;
          clientId: string = ""): Recallable =
  ## testAuthorization
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ##   clientId: string
  ##           : The MQTT client ID.
  ##   body: JObject (required)
  var query_604978 = newJObject()
  var body_604979 = newJObject()
  add(query_604978, "clientId", newJString(clientId))
  if body != nil:
    body_604979 = body
  result = call_604977.call(nil, query_604978, nil, nil, body_604979)

var testAuthorization* = Call_TestAuthorization_604964(name: "testAuthorization",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/test-authorization", validator: validate_TestAuthorization_604965,
    base: "/", url: url_TestAuthorization_604966,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_TestInvokeAuthorizer_604980 = ref object of OpenApiRestCall_601389
proc url_TestInvokeAuthorizer_604982(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName"),
               (kind: ConstantSegment, value: "/test")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_TestInvokeAuthorizer_604981(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The custom authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_604983 = path.getOrDefault("authorizerName")
  valid_604983 = validateParameter(valid_604983, JString, required = true,
                                 default = nil)
  if valid_604983 != nil:
    section.add "authorizerName", valid_604983
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604984 = header.getOrDefault("X-Amz-Signature")
  valid_604984 = validateParameter(valid_604984, JString, required = false,
                                 default = nil)
  if valid_604984 != nil:
    section.add "X-Amz-Signature", valid_604984
  var valid_604985 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604985 = validateParameter(valid_604985, JString, required = false,
                                 default = nil)
  if valid_604985 != nil:
    section.add "X-Amz-Content-Sha256", valid_604985
  var valid_604986 = header.getOrDefault("X-Amz-Date")
  valid_604986 = validateParameter(valid_604986, JString, required = false,
                                 default = nil)
  if valid_604986 != nil:
    section.add "X-Amz-Date", valid_604986
  var valid_604987 = header.getOrDefault("X-Amz-Credential")
  valid_604987 = validateParameter(valid_604987, JString, required = false,
                                 default = nil)
  if valid_604987 != nil:
    section.add "X-Amz-Credential", valid_604987
  var valid_604988 = header.getOrDefault("X-Amz-Security-Token")
  valid_604988 = validateParameter(valid_604988, JString, required = false,
                                 default = nil)
  if valid_604988 != nil:
    section.add "X-Amz-Security-Token", valid_604988
  var valid_604989 = header.getOrDefault("X-Amz-Algorithm")
  valid_604989 = validateParameter(valid_604989, JString, required = false,
                                 default = nil)
  if valid_604989 != nil:
    section.add "X-Amz-Algorithm", valid_604989
  var valid_604990 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604990 = validateParameter(valid_604990, JString, required = false,
                                 default = nil)
  if valid_604990 != nil:
    section.add "X-Amz-SignedHeaders", valid_604990
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604992: Call_TestInvokeAuthorizer_604980; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  let valid = call_604992.validator(path, query, header, formData, body)
  let scheme = call_604992.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604992.url(scheme.get, call_604992.host, call_604992.base,
                         call_604992.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604992, url, valid)

proc call*(call_604993: Call_TestInvokeAuthorizer_604980; authorizerName: string;
          body: JsonNode): Recallable =
  ## testInvokeAuthorizer
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ##   authorizerName: string (required)
  ##                 : The custom authorizer name.
  ##   body: JObject (required)
  var path_604994 = newJObject()
  var body_604995 = newJObject()
  add(path_604994, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_604995 = body
  result = call_604993.call(path_604994, nil, nil, nil, body_604995)

var testInvokeAuthorizer* = Call_TestInvokeAuthorizer_604980(
    name: "testInvokeAuthorizer", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/authorizer/{authorizerName}/test",
    validator: validate_TestInvokeAuthorizer_604981, base: "/",
    url: url_TestInvokeAuthorizer_604982, schemes: {Scheme.Https, Scheme.Http})
type
  Call_TransferCertificate_604996 = ref object of OpenApiRestCall_601389
proc url_TransferCertificate_604998(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/transfer-certificate/"),
               (kind: VariableSegment, value: "certificateId"),
               (kind: ConstantSegment, value: "#targetAwsAccount")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_TransferCertificate_604997(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_604999 = path.getOrDefault("certificateId")
  valid_604999 = validateParameter(valid_604999, JString, required = true,
                                 default = nil)
  if valid_604999 != nil:
    section.add "certificateId", valid_604999
  result.add "path", section
  ## parameters in `query` object:
  ##   targetAwsAccount: JString (required)
  ##                   : The AWS account.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `targetAwsAccount` field"
  var valid_605000 = query.getOrDefault("targetAwsAccount")
  valid_605000 = validateParameter(valid_605000, JString, required = true,
                                 default = nil)
  if valid_605000 != nil:
    section.add "targetAwsAccount", valid_605000
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605001 = header.getOrDefault("X-Amz-Signature")
  valid_605001 = validateParameter(valid_605001, JString, required = false,
                                 default = nil)
  if valid_605001 != nil:
    section.add "X-Amz-Signature", valid_605001
  var valid_605002 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605002 = validateParameter(valid_605002, JString, required = false,
                                 default = nil)
  if valid_605002 != nil:
    section.add "X-Amz-Content-Sha256", valid_605002
  var valid_605003 = header.getOrDefault("X-Amz-Date")
  valid_605003 = validateParameter(valid_605003, JString, required = false,
                                 default = nil)
  if valid_605003 != nil:
    section.add "X-Amz-Date", valid_605003
  var valid_605004 = header.getOrDefault("X-Amz-Credential")
  valid_605004 = validateParameter(valid_605004, JString, required = false,
                                 default = nil)
  if valid_605004 != nil:
    section.add "X-Amz-Credential", valid_605004
  var valid_605005 = header.getOrDefault("X-Amz-Security-Token")
  valid_605005 = validateParameter(valid_605005, JString, required = false,
                                 default = nil)
  if valid_605005 != nil:
    section.add "X-Amz-Security-Token", valid_605005
  var valid_605006 = header.getOrDefault("X-Amz-Algorithm")
  valid_605006 = validateParameter(valid_605006, JString, required = false,
                                 default = nil)
  if valid_605006 != nil:
    section.add "X-Amz-Algorithm", valid_605006
  var valid_605007 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605007 = validateParameter(valid_605007, JString, required = false,
                                 default = nil)
  if valid_605007 != nil:
    section.add "X-Amz-SignedHeaders", valid_605007
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605009: Call_TransferCertificate_604996; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ## 
  let valid = call_605009.validator(path, query, header, formData, body)
  let scheme = call_605009.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605009.url(scheme.get, call_605009.host, call_605009.base,
                         call_605009.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605009, url, valid)

proc call*(call_605010: Call_TransferCertificate_604996; body: JsonNode;
          certificateId: string; targetAwsAccount: string): Recallable =
  ## transferCertificate
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ##   body: JObject (required)
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   targetAwsAccount: string (required)
  ##                   : The AWS account.
  var path_605011 = newJObject()
  var query_605012 = newJObject()
  var body_605013 = newJObject()
  if body != nil:
    body_605013 = body
  add(path_605011, "certificateId", newJString(certificateId))
  add(query_605012, "targetAwsAccount", newJString(targetAwsAccount))
  result = call_605010.call(path_605011, query_605012, nil, nil, body_605013)

var transferCertificate* = Call_TransferCertificate_604996(
    name: "transferCertificate", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/transfer-certificate/{certificateId}#targetAwsAccount",
    validator: validate_TransferCertificate_604997, base: "/",
    url: url_TransferCertificate_604998, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UntagResource_605014 = ref object of OpenApiRestCall_601389
proc url_UntagResource_605016(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UntagResource_605015(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes the given tags (metadata) from the resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605017 = header.getOrDefault("X-Amz-Signature")
  valid_605017 = validateParameter(valid_605017, JString, required = false,
                                 default = nil)
  if valid_605017 != nil:
    section.add "X-Amz-Signature", valid_605017
  var valid_605018 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605018 = validateParameter(valid_605018, JString, required = false,
                                 default = nil)
  if valid_605018 != nil:
    section.add "X-Amz-Content-Sha256", valid_605018
  var valid_605019 = header.getOrDefault("X-Amz-Date")
  valid_605019 = validateParameter(valid_605019, JString, required = false,
                                 default = nil)
  if valid_605019 != nil:
    section.add "X-Amz-Date", valid_605019
  var valid_605020 = header.getOrDefault("X-Amz-Credential")
  valid_605020 = validateParameter(valid_605020, JString, required = false,
                                 default = nil)
  if valid_605020 != nil:
    section.add "X-Amz-Credential", valid_605020
  var valid_605021 = header.getOrDefault("X-Amz-Security-Token")
  valid_605021 = validateParameter(valid_605021, JString, required = false,
                                 default = nil)
  if valid_605021 != nil:
    section.add "X-Amz-Security-Token", valid_605021
  var valid_605022 = header.getOrDefault("X-Amz-Algorithm")
  valid_605022 = validateParameter(valid_605022, JString, required = false,
                                 default = nil)
  if valid_605022 != nil:
    section.add "X-Amz-Algorithm", valid_605022
  var valid_605023 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605023 = validateParameter(valid_605023, JString, required = false,
                                 default = nil)
  if valid_605023 != nil:
    section.add "X-Amz-SignedHeaders", valid_605023
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605025: Call_UntagResource_605014; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes the given tags (metadata) from the resource.
  ## 
  let valid = call_605025.validator(path, query, header, formData, body)
  let scheme = call_605025.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605025.url(scheme.get, call_605025.host, call_605025.base,
                         call_605025.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605025, url, valid)

proc call*(call_605026: Call_UntagResource_605014; body: JsonNode): Recallable =
  ## untagResource
  ## Removes the given tags (metadata) from the resource.
  ##   body: JObject (required)
  var body_605027 = newJObject()
  if body != nil:
    body_605027 = body
  result = call_605026.call(nil, nil, nil, nil, body_605027)

var untagResource* = Call_UntagResource_605014(name: "untagResource",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/untag",
    validator: validate_UntagResource_605015, base: "/", url: url_UntagResource_605016,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateCertificate_605028 = ref object of OpenApiRestCall_601389
proc url_UpdateCertificate_605030(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId"),
               (kind: ConstantSegment, value: "#newStatus")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateCertificate_605029(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_605031 = path.getOrDefault("certificateId")
  valid_605031 = validateParameter(valid_605031, JString, required = true,
                                 default = nil)
  if valid_605031 != nil:
    section.add "certificateId", valid_605031
  result.add "path", section
  ## parameters in `query` object:
  ##   newStatus: JString (required)
  ##            : <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `newStatus` field"
  var valid_605032 = query.getOrDefault("newStatus")
  valid_605032 = validateParameter(valid_605032, JString, required = true,
                                 default = newJString("ACTIVE"))
  if valid_605032 != nil:
    section.add "newStatus", valid_605032
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605033 = header.getOrDefault("X-Amz-Signature")
  valid_605033 = validateParameter(valid_605033, JString, required = false,
                                 default = nil)
  if valid_605033 != nil:
    section.add "X-Amz-Signature", valid_605033
  var valid_605034 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605034 = validateParameter(valid_605034, JString, required = false,
                                 default = nil)
  if valid_605034 != nil:
    section.add "X-Amz-Content-Sha256", valid_605034
  var valid_605035 = header.getOrDefault("X-Amz-Date")
  valid_605035 = validateParameter(valid_605035, JString, required = false,
                                 default = nil)
  if valid_605035 != nil:
    section.add "X-Amz-Date", valid_605035
  var valid_605036 = header.getOrDefault("X-Amz-Credential")
  valid_605036 = validateParameter(valid_605036, JString, required = false,
                                 default = nil)
  if valid_605036 != nil:
    section.add "X-Amz-Credential", valid_605036
  var valid_605037 = header.getOrDefault("X-Amz-Security-Token")
  valid_605037 = validateParameter(valid_605037, JString, required = false,
                                 default = nil)
  if valid_605037 != nil:
    section.add "X-Amz-Security-Token", valid_605037
  var valid_605038 = header.getOrDefault("X-Amz-Algorithm")
  valid_605038 = validateParameter(valid_605038, JString, required = false,
                                 default = nil)
  if valid_605038 != nil:
    section.add "X-Amz-Algorithm", valid_605038
  var valid_605039 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605039 = validateParameter(valid_605039, JString, required = false,
                                 default = nil)
  if valid_605039 != nil:
    section.add "X-Amz-SignedHeaders", valid_605039
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605040: Call_UpdateCertificate_605028; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ## 
  let valid = call_605040.validator(path, query, header, formData, body)
  let scheme = call_605040.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605040.url(scheme.get, call_605040.host, call_605040.base,
                         call_605040.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605040, url, valid)

proc call*(call_605041: Call_UpdateCertificate_605028; certificateId: string;
          newStatus: string = "ACTIVE"): Recallable =
  ## updateCertificate
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ##   newStatus: string (required)
  ##            : <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_605042 = newJObject()
  var query_605043 = newJObject()
  add(query_605043, "newStatus", newJString(newStatus))
  add(path_605042, "certificateId", newJString(certificateId))
  result = call_605041.call(path_605042, query_605043, nil, nil, nil)

var updateCertificate* = Call_UpdateCertificate_605028(name: "updateCertificate",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/certificates/{certificateId}#newStatus",
    validator: validate_UpdateCertificate_605029, base: "/",
    url: url_UpdateCertificate_605030, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThingGroupsForThing_605044 = ref object of OpenApiRestCall_601389
proc url_UpdateThingGroupsForThing_605046(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateThingGroupsForThing_605045(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the groups to which the thing belongs.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605047 = header.getOrDefault("X-Amz-Signature")
  valid_605047 = validateParameter(valid_605047, JString, required = false,
                                 default = nil)
  if valid_605047 != nil:
    section.add "X-Amz-Signature", valid_605047
  var valid_605048 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605048 = validateParameter(valid_605048, JString, required = false,
                                 default = nil)
  if valid_605048 != nil:
    section.add "X-Amz-Content-Sha256", valid_605048
  var valid_605049 = header.getOrDefault("X-Amz-Date")
  valid_605049 = validateParameter(valid_605049, JString, required = false,
                                 default = nil)
  if valid_605049 != nil:
    section.add "X-Amz-Date", valid_605049
  var valid_605050 = header.getOrDefault("X-Amz-Credential")
  valid_605050 = validateParameter(valid_605050, JString, required = false,
                                 default = nil)
  if valid_605050 != nil:
    section.add "X-Amz-Credential", valid_605050
  var valid_605051 = header.getOrDefault("X-Amz-Security-Token")
  valid_605051 = validateParameter(valid_605051, JString, required = false,
                                 default = nil)
  if valid_605051 != nil:
    section.add "X-Amz-Security-Token", valid_605051
  var valid_605052 = header.getOrDefault("X-Amz-Algorithm")
  valid_605052 = validateParameter(valid_605052, JString, required = false,
                                 default = nil)
  if valid_605052 != nil:
    section.add "X-Amz-Algorithm", valid_605052
  var valid_605053 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605053 = validateParameter(valid_605053, JString, required = false,
                                 default = nil)
  if valid_605053 != nil:
    section.add "X-Amz-SignedHeaders", valid_605053
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605055: Call_UpdateThingGroupsForThing_605044; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the groups to which the thing belongs.
  ## 
  let valid = call_605055.validator(path, query, header, formData, body)
  let scheme = call_605055.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605055.url(scheme.get, call_605055.host, call_605055.base,
                         call_605055.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605055, url, valid)

proc call*(call_605056: Call_UpdateThingGroupsForThing_605044; body: JsonNode): Recallable =
  ## updateThingGroupsForThing
  ## Updates the groups to which the thing belongs.
  ##   body: JObject (required)
  var body_605057 = newJObject()
  if body != nil:
    body_605057 = body
  result = call_605056.call(nil, nil, nil, nil, body_605057)

var updateThingGroupsForThing* = Call_UpdateThingGroupsForThing_605044(
    name: "updateThingGroupsForThing", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/updateThingGroupsForThing",
    validator: validate_UpdateThingGroupsForThing_605045, base: "/",
    url: url_UpdateThingGroupsForThing_605046,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ValidateSecurityProfileBehaviors_605058 = ref object of OpenApiRestCall_601389
proc url_ValidateSecurityProfileBehaviors_605060(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ValidateSecurityProfileBehaviors_605059(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validates a Device Defender security profile behaviors specification.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605061 = header.getOrDefault("X-Amz-Signature")
  valid_605061 = validateParameter(valid_605061, JString, required = false,
                                 default = nil)
  if valid_605061 != nil:
    section.add "X-Amz-Signature", valid_605061
  var valid_605062 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605062 = validateParameter(valid_605062, JString, required = false,
                                 default = nil)
  if valid_605062 != nil:
    section.add "X-Amz-Content-Sha256", valid_605062
  var valid_605063 = header.getOrDefault("X-Amz-Date")
  valid_605063 = validateParameter(valid_605063, JString, required = false,
                                 default = nil)
  if valid_605063 != nil:
    section.add "X-Amz-Date", valid_605063
  var valid_605064 = header.getOrDefault("X-Amz-Credential")
  valid_605064 = validateParameter(valid_605064, JString, required = false,
                                 default = nil)
  if valid_605064 != nil:
    section.add "X-Amz-Credential", valid_605064
  var valid_605065 = header.getOrDefault("X-Amz-Security-Token")
  valid_605065 = validateParameter(valid_605065, JString, required = false,
                                 default = nil)
  if valid_605065 != nil:
    section.add "X-Amz-Security-Token", valid_605065
  var valid_605066 = header.getOrDefault("X-Amz-Algorithm")
  valid_605066 = validateParameter(valid_605066, JString, required = false,
                                 default = nil)
  if valid_605066 != nil:
    section.add "X-Amz-Algorithm", valid_605066
  var valid_605067 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605067 = validateParameter(valid_605067, JString, required = false,
                                 default = nil)
  if valid_605067 != nil:
    section.add "X-Amz-SignedHeaders", valid_605067
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605069: Call_ValidateSecurityProfileBehaviors_605058;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Validates a Device Defender security profile behaviors specification.
  ## 
  let valid = call_605069.validator(path, query, header, formData, body)
  let scheme = call_605069.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605069.url(scheme.get, call_605069.host, call_605069.base,
                         call_605069.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605069, url, valid)

proc call*(call_605070: Call_ValidateSecurityProfileBehaviors_605058;
          body: JsonNode): Recallable =
  ## validateSecurityProfileBehaviors
  ## Validates a Device Defender security profile behaviors specification.
  ##   body: JObject (required)
  var body_605071 = newJObject()
  if body != nil:
    body_605071 = body
  result = call_605070.call(nil, nil, nil, nil, body_605071)

var validateSecurityProfileBehaviors* = Call_ValidateSecurityProfileBehaviors_605058(
    name: "validateSecurityProfileBehaviors", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/security-profile-behaviors/validate",
    validator: validate_ValidateSecurityProfileBehaviors_605059, base: "/",
    url: url_ValidateSecurityProfileBehaviors_605060,
    schemes: {Scheme.Https, Scheme.Http})
export
  rest

proc atozSign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", "")
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", "")
    region = os.getEnv("AWS_REGION", "")
  assert secret != "", "need secret key in env"
  assert access != "", "need access key in env"
  assert region != "", "need region in env"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  recall.headers.del "Host"
  recall.url = $url

method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  let headers = massageHeaders(input.getOrDefault("header"))
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
  result.atozSign(input.getOrDefault("query"), SHA256)
