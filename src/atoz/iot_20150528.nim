
import
  json, options, hashes, uri, tables, rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: AWS IoT
## version: 2015-05-28
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>AWS IoT</fullname> <p>AWS IoT provides secure, bi-directional communication between Internet-connected devices (such as sensors, actuators, embedded devices, or smart appliances) and the AWS cloud. You can discover your custom IoT-Data endpoint to communicate with, configure rules for data processing and integration with other services, organize resources associated with each device (Registry), configure logging, and create and manage policies and credentials to authenticate devices.</p> <p>For more information about how AWS IoT works, see the <a href="https://docs.aws.amazon.com/iot/latest/developerguide/aws-iot-how-it-works.html">Developer Guide</a>.</p> <p>For information about how to use the credentials provider for AWS IoT, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorizing-direct-aws.html">Authorizing Direct Calls to AWS Services</a>.</p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/iot/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_593437 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_593437](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_593437): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    if js.kind notin {JString, JInt, JFloat, JNull, JBool}:
      return
    head = $js
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "iot.ap-northeast-1.amazonaws.com", "ap-southeast-1": "iot.ap-southeast-1.amazonaws.com",
                           "us-west-2": "iot.us-west-2.amazonaws.com",
                           "eu-west-2": "iot.eu-west-2.amazonaws.com", "ap-northeast-3": "iot.ap-northeast-3.amazonaws.com",
                           "eu-central-1": "iot.eu-central-1.amazonaws.com",
                           "us-east-2": "iot.us-east-2.amazonaws.com",
                           "us-east-1": "iot.us-east-1.amazonaws.com", "cn-northwest-1": "iot.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "iot.ap-south-1.amazonaws.com",
                           "eu-north-1": "iot.eu-north-1.amazonaws.com", "ap-northeast-2": "iot.ap-northeast-2.amazonaws.com",
                           "us-west-1": "iot.us-west-1.amazonaws.com",
                           "us-gov-east-1": "iot.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "iot.eu-west-3.amazonaws.com",
                           "cn-north-1": "iot.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "iot.sa-east-1.amazonaws.com",
                           "eu-west-1": "iot.eu-west-1.amazonaws.com",
                           "us-gov-west-1": "iot.us-gov-west-1.amazonaws.com", "ap-southeast-2": "iot.ap-southeast-2.amazonaws.com",
                           "ca-central-1": "iot.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "iot.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "iot.ap-southeast-1.amazonaws.com",
      "us-west-2": "iot.us-west-2.amazonaws.com",
      "eu-west-2": "iot.eu-west-2.amazonaws.com",
      "ap-northeast-3": "iot.ap-northeast-3.amazonaws.com",
      "eu-central-1": "iot.eu-central-1.amazonaws.com",
      "us-east-2": "iot.us-east-2.amazonaws.com",
      "us-east-1": "iot.us-east-1.amazonaws.com",
      "cn-northwest-1": "iot.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "iot.ap-south-1.amazonaws.com",
      "eu-north-1": "iot.eu-north-1.amazonaws.com",
      "ap-northeast-2": "iot.ap-northeast-2.amazonaws.com",
      "us-west-1": "iot.us-west-1.amazonaws.com",
      "us-gov-east-1": "iot.us-gov-east-1.amazonaws.com",
      "eu-west-3": "iot.eu-west-3.amazonaws.com",
      "cn-north-1": "iot.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "iot.sa-east-1.amazonaws.com",
      "eu-west-1": "iot.eu-west-1.amazonaws.com",
      "us-gov-west-1": "iot.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "iot.ap-southeast-2.amazonaws.com",
      "ca-central-1": "iot.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "iot"
method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_AcceptCertificateTransfer_593774 = ref object of OpenApiRestCall_593437
proc url_AcceptCertificateTransfer_593776(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/accept-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_AcceptCertificateTransfer_593775(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_593902 = path.getOrDefault("certificateId")
  valid_593902 = validateParameter(valid_593902, JString, required = true,
                                 default = nil)
  if valid_593902 != nil:
    section.add "certificateId", valid_593902
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_593903 = query.getOrDefault("setAsActive")
  valid_593903 = validateParameter(valid_593903, JBool, required = false, default = nil)
  if valid_593903 != nil:
    section.add "setAsActive", valid_593903
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_593904 = header.getOrDefault("X-Amz-Date")
  valid_593904 = validateParameter(valid_593904, JString, required = false,
                                 default = nil)
  if valid_593904 != nil:
    section.add "X-Amz-Date", valid_593904
  var valid_593905 = header.getOrDefault("X-Amz-Security-Token")
  valid_593905 = validateParameter(valid_593905, JString, required = false,
                                 default = nil)
  if valid_593905 != nil:
    section.add "X-Amz-Security-Token", valid_593905
  var valid_593906 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593906 = validateParameter(valid_593906, JString, required = false,
                                 default = nil)
  if valid_593906 != nil:
    section.add "X-Amz-Content-Sha256", valid_593906
  var valid_593907 = header.getOrDefault("X-Amz-Algorithm")
  valid_593907 = validateParameter(valid_593907, JString, required = false,
                                 default = nil)
  if valid_593907 != nil:
    section.add "X-Amz-Algorithm", valid_593907
  var valid_593908 = header.getOrDefault("X-Amz-Signature")
  valid_593908 = validateParameter(valid_593908, JString, required = false,
                                 default = nil)
  if valid_593908 != nil:
    section.add "X-Amz-Signature", valid_593908
  var valid_593909 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593909 = validateParameter(valid_593909, JString, required = false,
                                 default = nil)
  if valid_593909 != nil:
    section.add "X-Amz-SignedHeaders", valid_593909
  var valid_593910 = header.getOrDefault("X-Amz-Credential")
  valid_593910 = validateParameter(valid_593910, JString, required = false,
                                 default = nil)
  if valid_593910 != nil:
    section.add "X-Amz-Credential", valid_593910
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593933: Call_AcceptCertificateTransfer_593774; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ## 
  let valid = call_593933.validator(path, query, header, formData, body)
  let scheme = call_593933.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593933.url(scheme.get, call_593933.host, call_593933.base,
                         call_593933.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593933, url, valid)

proc call*(call_594004: Call_AcceptCertificateTransfer_593774;
          certificateId: string; setAsActive: bool = false): Recallable =
  ## acceptCertificateTransfer
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  var path_594005 = newJObject()
  var query_594007 = newJObject()
  add(path_594005, "certificateId", newJString(certificateId))
  add(query_594007, "setAsActive", newJBool(setAsActive))
  result = call_594004.call(path_594005, query_594007, nil, nil, nil)

var acceptCertificateTransfer* = Call_AcceptCertificateTransfer_593774(
    name: "acceptCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/accept-certificate-transfer/{certificateId}",
    validator: validate_AcceptCertificateTransfer_593775, base: "/",
    url: url_AcceptCertificateTransfer_593776,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_AddThingToBillingGroup_594046 = ref object of OpenApiRestCall_593437
proc url_AddThingToBillingGroup_594048(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_AddThingToBillingGroup_594047(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a thing to a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594049 = header.getOrDefault("X-Amz-Date")
  valid_594049 = validateParameter(valid_594049, JString, required = false,
                                 default = nil)
  if valid_594049 != nil:
    section.add "X-Amz-Date", valid_594049
  var valid_594050 = header.getOrDefault("X-Amz-Security-Token")
  valid_594050 = validateParameter(valid_594050, JString, required = false,
                                 default = nil)
  if valid_594050 != nil:
    section.add "X-Amz-Security-Token", valid_594050
  var valid_594051 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594051 = validateParameter(valid_594051, JString, required = false,
                                 default = nil)
  if valid_594051 != nil:
    section.add "X-Amz-Content-Sha256", valid_594051
  var valid_594052 = header.getOrDefault("X-Amz-Algorithm")
  valid_594052 = validateParameter(valid_594052, JString, required = false,
                                 default = nil)
  if valid_594052 != nil:
    section.add "X-Amz-Algorithm", valid_594052
  var valid_594053 = header.getOrDefault("X-Amz-Signature")
  valid_594053 = validateParameter(valid_594053, JString, required = false,
                                 default = nil)
  if valid_594053 != nil:
    section.add "X-Amz-Signature", valid_594053
  var valid_594054 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594054 = validateParameter(valid_594054, JString, required = false,
                                 default = nil)
  if valid_594054 != nil:
    section.add "X-Amz-SignedHeaders", valid_594054
  var valid_594055 = header.getOrDefault("X-Amz-Credential")
  valid_594055 = validateParameter(valid_594055, JString, required = false,
                                 default = nil)
  if valid_594055 != nil:
    section.add "X-Amz-Credential", valid_594055
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594057: Call_AddThingToBillingGroup_594046; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a thing to a billing group.
  ## 
  let valid = call_594057.validator(path, query, header, formData, body)
  let scheme = call_594057.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594057.url(scheme.get, call_594057.host, call_594057.base,
                         call_594057.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594057, url, valid)

proc call*(call_594058: Call_AddThingToBillingGroup_594046; body: JsonNode): Recallable =
  ## addThingToBillingGroup
  ## Adds a thing to a billing group.
  ##   body: JObject (required)
  var body_594059 = newJObject()
  if body != nil:
    body_594059 = body
  result = call_594058.call(nil, nil, nil, nil, body_594059)

var addThingToBillingGroup* = Call_AddThingToBillingGroup_594046(
    name: "addThingToBillingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/billing-groups/addThingToBillingGroup",
    validator: validate_AddThingToBillingGroup_594047, base: "/",
    url: url_AddThingToBillingGroup_594048, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AddThingToThingGroup_594060 = ref object of OpenApiRestCall_593437
proc url_AddThingToThingGroup_594062(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_AddThingToThingGroup_594061(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a thing to a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594063 = header.getOrDefault("X-Amz-Date")
  valid_594063 = validateParameter(valid_594063, JString, required = false,
                                 default = nil)
  if valid_594063 != nil:
    section.add "X-Amz-Date", valid_594063
  var valid_594064 = header.getOrDefault("X-Amz-Security-Token")
  valid_594064 = validateParameter(valid_594064, JString, required = false,
                                 default = nil)
  if valid_594064 != nil:
    section.add "X-Amz-Security-Token", valid_594064
  var valid_594065 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594065 = validateParameter(valid_594065, JString, required = false,
                                 default = nil)
  if valid_594065 != nil:
    section.add "X-Amz-Content-Sha256", valid_594065
  var valid_594066 = header.getOrDefault("X-Amz-Algorithm")
  valid_594066 = validateParameter(valid_594066, JString, required = false,
                                 default = nil)
  if valid_594066 != nil:
    section.add "X-Amz-Algorithm", valid_594066
  var valid_594067 = header.getOrDefault("X-Amz-Signature")
  valid_594067 = validateParameter(valid_594067, JString, required = false,
                                 default = nil)
  if valid_594067 != nil:
    section.add "X-Amz-Signature", valid_594067
  var valid_594068 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594068 = validateParameter(valid_594068, JString, required = false,
                                 default = nil)
  if valid_594068 != nil:
    section.add "X-Amz-SignedHeaders", valid_594068
  var valid_594069 = header.getOrDefault("X-Amz-Credential")
  valid_594069 = validateParameter(valid_594069, JString, required = false,
                                 default = nil)
  if valid_594069 != nil:
    section.add "X-Amz-Credential", valid_594069
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594071: Call_AddThingToThingGroup_594060; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a thing to a thing group.
  ## 
  let valid = call_594071.validator(path, query, header, formData, body)
  let scheme = call_594071.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594071.url(scheme.get, call_594071.host, call_594071.base,
                         call_594071.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594071, url, valid)

proc call*(call_594072: Call_AddThingToThingGroup_594060; body: JsonNode): Recallable =
  ## addThingToThingGroup
  ## Adds a thing to a thing group.
  ##   body: JObject (required)
  var body_594073 = newJObject()
  if body != nil:
    body_594073 = body
  result = call_594072.call(nil, nil, nil, nil, body_594073)

var addThingToThingGroup* = Call_AddThingToThingGroup_594060(
    name: "addThingToThingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/addThingToThingGroup",
    validator: validate_AddThingToThingGroup_594061, base: "/",
    url: url_AddThingToThingGroup_594062, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AssociateTargetsWithJob_594074 = ref object of OpenApiRestCall_593437
proc url_AssociateTargetsWithJob_594076(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/targets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_AssociateTargetsWithJob_594075(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_594077 = path.getOrDefault("jobId")
  valid_594077 = validateParameter(valid_594077, JString, required = true,
                                 default = nil)
  if valid_594077 != nil:
    section.add "jobId", valid_594077
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594078 = header.getOrDefault("X-Amz-Date")
  valid_594078 = validateParameter(valid_594078, JString, required = false,
                                 default = nil)
  if valid_594078 != nil:
    section.add "X-Amz-Date", valid_594078
  var valid_594079 = header.getOrDefault("X-Amz-Security-Token")
  valid_594079 = validateParameter(valid_594079, JString, required = false,
                                 default = nil)
  if valid_594079 != nil:
    section.add "X-Amz-Security-Token", valid_594079
  var valid_594080 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594080 = validateParameter(valid_594080, JString, required = false,
                                 default = nil)
  if valid_594080 != nil:
    section.add "X-Amz-Content-Sha256", valid_594080
  var valid_594081 = header.getOrDefault("X-Amz-Algorithm")
  valid_594081 = validateParameter(valid_594081, JString, required = false,
                                 default = nil)
  if valid_594081 != nil:
    section.add "X-Amz-Algorithm", valid_594081
  var valid_594082 = header.getOrDefault("X-Amz-Signature")
  valid_594082 = validateParameter(valid_594082, JString, required = false,
                                 default = nil)
  if valid_594082 != nil:
    section.add "X-Amz-Signature", valid_594082
  var valid_594083 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594083 = validateParameter(valid_594083, JString, required = false,
                                 default = nil)
  if valid_594083 != nil:
    section.add "X-Amz-SignedHeaders", valid_594083
  var valid_594084 = header.getOrDefault("X-Amz-Credential")
  valid_594084 = validateParameter(valid_594084, JString, required = false,
                                 default = nil)
  if valid_594084 != nil:
    section.add "X-Amz-Credential", valid_594084
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594086: Call_AssociateTargetsWithJob_594074; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ## 
  let valid = call_594086.validator(path, query, header, formData, body)
  let scheme = call_594086.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594086.url(scheme.get, call_594086.host, call_594086.base,
                         call_594086.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594086, url, valid)

proc call*(call_594087: Call_AssociateTargetsWithJob_594074; jobId: string;
          body: JsonNode): Recallable =
  ## associateTargetsWithJob
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   body: JObject (required)
  var path_594088 = newJObject()
  var body_594089 = newJObject()
  add(path_594088, "jobId", newJString(jobId))
  if body != nil:
    body_594089 = body
  result = call_594087.call(path_594088, nil, nil, nil, body_594089)

var associateTargetsWithJob* = Call_AssociateTargetsWithJob_594074(
    name: "associateTargetsWithJob", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/jobs/{jobId}/targets",
    validator: validate_AssociateTargetsWithJob_594075, base: "/",
    url: url_AssociateTargetsWithJob_594076, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachPolicy_594090 = ref object of OpenApiRestCall_593437
proc url_AttachPolicy_594092(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/target-policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_AttachPolicy_594091(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Attaches a policy to the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to attach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594093 = path.getOrDefault("policyName")
  valid_594093 = validateParameter(valid_594093, JString, required = true,
                                 default = nil)
  if valid_594093 != nil:
    section.add "policyName", valid_594093
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594094 = header.getOrDefault("X-Amz-Date")
  valid_594094 = validateParameter(valid_594094, JString, required = false,
                                 default = nil)
  if valid_594094 != nil:
    section.add "X-Amz-Date", valid_594094
  var valid_594095 = header.getOrDefault("X-Amz-Security-Token")
  valid_594095 = validateParameter(valid_594095, JString, required = false,
                                 default = nil)
  if valid_594095 != nil:
    section.add "X-Amz-Security-Token", valid_594095
  var valid_594096 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594096 = validateParameter(valid_594096, JString, required = false,
                                 default = nil)
  if valid_594096 != nil:
    section.add "X-Amz-Content-Sha256", valid_594096
  var valid_594097 = header.getOrDefault("X-Amz-Algorithm")
  valid_594097 = validateParameter(valid_594097, JString, required = false,
                                 default = nil)
  if valid_594097 != nil:
    section.add "X-Amz-Algorithm", valid_594097
  var valid_594098 = header.getOrDefault("X-Amz-Signature")
  valid_594098 = validateParameter(valid_594098, JString, required = false,
                                 default = nil)
  if valid_594098 != nil:
    section.add "X-Amz-Signature", valid_594098
  var valid_594099 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594099 = validateParameter(valid_594099, JString, required = false,
                                 default = nil)
  if valid_594099 != nil:
    section.add "X-Amz-SignedHeaders", valid_594099
  var valid_594100 = header.getOrDefault("X-Amz-Credential")
  valid_594100 = validateParameter(valid_594100, JString, required = false,
                                 default = nil)
  if valid_594100 != nil:
    section.add "X-Amz-Credential", valid_594100
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594102: Call_AttachPolicy_594090; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Attaches a policy to the specified target.
  ## 
  let valid = call_594102.validator(path, query, header, formData, body)
  let scheme = call_594102.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594102.url(scheme.get, call_594102.host, call_594102.base,
                         call_594102.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594102, url, valid)

proc call*(call_594103: Call_AttachPolicy_594090; policyName: string; body: JsonNode): Recallable =
  ## attachPolicy
  ## Attaches a policy to the specified target.
  ##   policyName: string (required)
  ##             : The name of the policy to attach.
  ##   body: JObject (required)
  var path_594104 = newJObject()
  var body_594105 = newJObject()
  add(path_594104, "policyName", newJString(policyName))
  if body != nil:
    body_594105 = body
  result = call_594103.call(path_594104, nil, nil, nil, body_594105)

var attachPolicy* = Call_AttachPolicy_594090(name: "attachPolicy",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/target-policies/{policyName}", validator: validate_AttachPolicy_594091,
    base: "/", url: url_AttachPolicy_594092, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachPolicy_594106 = ref object of OpenApiRestCall_593437
proc url_DetachPolicy_594108(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/target-policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DetachPolicy_594107(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Detaches a policy from the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy to detach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594109 = path.getOrDefault("policyName")
  valid_594109 = validateParameter(valid_594109, JString, required = true,
                                 default = nil)
  if valid_594109 != nil:
    section.add "policyName", valid_594109
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594110 = header.getOrDefault("X-Amz-Date")
  valid_594110 = validateParameter(valid_594110, JString, required = false,
                                 default = nil)
  if valid_594110 != nil:
    section.add "X-Amz-Date", valid_594110
  var valid_594111 = header.getOrDefault("X-Amz-Security-Token")
  valid_594111 = validateParameter(valid_594111, JString, required = false,
                                 default = nil)
  if valid_594111 != nil:
    section.add "X-Amz-Security-Token", valid_594111
  var valid_594112 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594112 = validateParameter(valid_594112, JString, required = false,
                                 default = nil)
  if valid_594112 != nil:
    section.add "X-Amz-Content-Sha256", valid_594112
  var valid_594113 = header.getOrDefault("X-Amz-Algorithm")
  valid_594113 = validateParameter(valid_594113, JString, required = false,
                                 default = nil)
  if valid_594113 != nil:
    section.add "X-Amz-Algorithm", valid_594113
  var valid_594114 = header.getOrDefault("X-Amz-Signature")
  valid_594114 = validateParameter(valid_594114, JString, required = false,
                                 default = nil)
  if valid_594114 != nil:
    section.add "X-Amz-Signature", valid_594114
  var valid_594115 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594115 = validateParameter(valid_594115, JString, required = false,
                                 default = nil)
  if valid_594115 != nil:
    section.add "X-Amz-SignedHeaders", valid_594115
  var valid_594116 = header.getOrDefault("X-Amz-Credential")
  valid_594116 = validateParameter(valid_594116, JString, required = false,
                                 default = nil)
  if valid_594116 != nil:
    section.add "X-Amz-Credential", valid_594116
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594118: Call_DetachPolicy_594106; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Detaches a policy from the specified target.
  ## 
  let valid = call_594118.validator(path, query, header, formData, body)
  let scheme = call_594118.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594118.url(scheme.get, call_594118.host, call_594118.base,
                         call_594118.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594118, url, valid)

proc call*(call_594119: Call_DetachPolicy_594106; policyName: string; body: JsonNode): Recallable =
  ## detachPolicy
  ## Detaches a policy from the specified target.
  ##   policyName: string (required)
  ##             : The policy to detach.
  ##   body: JObject (required)
  var path_594120 = newJObject()
  var body_594121 = newJObject()
  add(path_594120, "policyName", newJString(policyName))
  if body != nil:
    body_594121 = body
  result = call_594119.call(path_594120, nil, nil, nil, body_594121)

var detachPolicy* = Call_DetachPolicy_594106(name: "detachPolicy",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/target-policies/{policyName}", validator: validate_DetachPolicy_594107,
    base: "/", url: url_DetachPolicy_594108, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachPrincipalPolicy_594122 = ref object of OpenApiRestCall_593437
proc url_AttachPrincipalPolicy_594124(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/principal-policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "#x-amzn-iot-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_AttachPrincipalPolicy_594123(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594125 = path.getOrDefault("policyName")
  valid_594125 = validateParameter(valid_594125, JString, required = true,
                                 default = nil)
  if valid_594125 != nil:
    section.add "policyName", valid_594125
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594126 = header.getOrDefault("X-Amz-Date")
  valid_594126 = validateParameter(valid_594126, JString, required = false,
                                 default = nil)
  if valid_594126 != nil:
    section.add "X-Amz-Date", valid_594126
  var valid_594127 = header.getOrDefault("X-Amz-Security-Token")
  valid_594127 = validateParameter(valid_594127, JString, required = false,
                                 default = nil)
  if valid_594127 != nil:
    section.add "X-Amz-Security-Token", valid_594127
  var valid_594128 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594128 = validateParameter(valid_594128, JString, required = false,
                                 default = nil)
  if valid_594128 != nil:
    section.add "X-Amz-Content-Sha256", valid_594128
  var valid_594129 = header.getOrDefault("X-Amz-Algorithm")
  valid_594129 = validateParameter(valid_594129, JString, required = false,
                                 default = nil)
  if valid_594129 != nil:
    section.add "X-Amz-Algorithm", valid_594129
  var valid_594130 = header.getOrDefault("X-Amz-Signature")
  valid_594130 = validateParameter(valid_594130, JString, required = false,
                                 default = nil)
  if valid_594130 != nil:
    section.add "X-Amz-Signature", valid_594130
  var valid_594131 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594131 = validateParameter(valid_594131, JString, required = false,
                                 default = nil)
  if valid_594131 != nil:
    section.add "X-Amz-SignedHeaders", valid_594131
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_594132 = header.getOrDefault("x-amzn-iot-principal")
  valid_594132 = validateParameter(valid_594132, JString, required = true,
                                 default = nil)
  if valid_594132 != nil:
    section.add "x-amzn-iot-principal", valid_594132
  var valid_594133 = header.getOrDefault("X-Amz-Credential")
  valid_594133 = validateParameter(valid_594133, JString, required = false,
                                 default = nil)
  if valid_594133 != nil:
    section.add "X-Amz-Credential", valid_594133
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594134: Call_AttachPrincipalPolicy_594122; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ## 
  let valid = call_594134.validator(path, query, header, formData, body)
  let scheme = call_594134.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594134.url(scheme.get, call_594134.host, call_594134.base,
                         call_594134.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594134, url, valid)

proc call*(call_594135: Call_AttachPrincipalPolicy_594122; policyName: string): Recallable =
  ## attachPrincipalPolicy
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ##   policyName: string (required)
  ##             : The policy name.
  var path_594136 = newJObject()
  add(path_594136, "policyName", newJString(policyName))
  result = call_594135.call(path_594136, nil, nil, nil, nil)

var attachPrincipalPolicy* = Call_AttachPrincipalPolicy_594122(
    name: "attachPrincipalPolicy", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/principal-policies/{policyName}#x-amzn-iot-principal",
    validator: validate_AttachPrincipalPolicy_594123, base: "/",
    url: url_AttachPrincipalPolicy_594124, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachPrincipalPolicy_594137 = ref object of OpenApiRestCall_593437
proc url_DetachPrincipalPolicy_594139(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/principal-policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "#x-amzn-iot-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DetachPrincipalPolicy_594138(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to detach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594140 = path.getOrDefault("policyName")
  valid_594140 = validateParameter(valid_594140, JString, required = true,
                                 default = nil)
  if valid_594140 != nil:
    section.add "policyName", valid_594140
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : <p>The principal.</p> <p>If the principal is a certificate, specify the certificate ARN. If the principal is an Amazon Cognito identity, specify the identity ID.</p>
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594141 = header.getOrDefault("X-Amz-Date")
  valid_594141 = validateParameter(valid_594141, JString, required = false,
                                 default = nil)
  if valid_594141 != nil:
    section.add "X-Amz-Date", valid_594141
  var valid_594142 = header.getOrDefault("X-Amz-Security-Token")
  valid_594142 = validateParameter(valid_594142, JString, required = false,
                                 default = nil)
  if valid_594142 != nil:
    section.add "X-Amz-Security-Token", valid_594142
  var valid_594143 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594143 = validateParameter(valid_594143, JString, required = false,
                                 default = nil)
  if valid_594143 != nil:
    section.add "X-Amz-Content-Sha256", valid_594143
  var valid_594144 = header.getOrDefault("X-Amz-Algorithm")
  valid_594144 = validateParameter(valid_594144, JString, required = false,
                                 default = nil)
  if valid_594144 != nil:
    section.add "X-Amz-Algorithm", valid_594144
  var valid_594145 = header.getOrDefault("X-Amz-Signature")
  valid_594145 = validateParameter(valid_594145, JString, required = false,
                                 default = nil)
  if valid_594145 != nil:
    section.add "X-Amz-Signature", valid_594145
  var valid_594146 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594146 = validateParameter(valid_594146, JString, required = false,
                                 default = nil)
  if valid_594146 != nil:
    section.add "X-Amz-SignedHeaders", valid_594146
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_594147 = header.getOrDefault("x-amzn-iot-principal")
  valid_594147 = validateParameter(valid_594147, JString, required = true,
                                 default = nil)
  if valid_594147 != nil:
    section.add "x-amzn-iot-principal", valid_594147
  var valid_594148 = header.getOrDefault("X-Amz-Credential")
  valid_594148 = validateParameter(valid_594148, JString, required = false,
                                 default = nil)
  if valid_594148 != nil:
    section.add "X-Amz-Credential", valid_594148
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594149: Call_DetachPrincipalPolicy_594137; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ## 
  let valid = call_594149.validator(path, query, header, formData, body)
  let scheme = call_594149.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594149.url(scheme.get, call_594149.host, call_594149.base,
                         call_594149.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594149, url, valid)

proc call*(call_594150: Call_DetachPrincipalPolicy_594137; policyName: string): Recallable =
  ## detachPrincipalPolicy
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ##   policyName: string (required)
  ##             : The name of the policy to detach.
  var path_594151 = newJObject()
  add(path_594151, "policyName", newJString(policyName))
  result = call_594150.call(path_594151, nil, nil, nil, nil)

var detachPrincipalPolicy* = Call_DetachPrincipalPolicy_594137(
    name: "detachPrincipalPolicy", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/principal-policies/{policyName}#x-amzn-iot-principal",
    validator: validate_DetachPrincipalPolicy_594138, base: "/",
    url: url_DetachPrincipalPolicy_594139, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachSecurityProfile_594152 = ref object of OpenApiRestCall_593437
proc url_AttachSecurityProfile_594154(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"), (
        kind: ConstantSegment, value: "/targets#securityProfileTargetArn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_AttachSecurityProfile_594153(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile that is attached.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_594155 = path.getOrDefault("securityProfileName")
  valid_594155 = validateParameter(valid_594155, JString, required = true,
                                 default = nil)
  if valid_594155 != nil:
    section.add "securityProfileName", valid_594155
  result.add "path", section
  ## parameters in `query` object:
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the target (thing group) to which the security profile is attached.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_594156 = query.getOrDefault("securityProfileTargetArn")
  valid_594156 = validateParameter(valid_594156, JString, required = true,
                                 default = nil)
  if valid_594156 != nil:
    section.add "securityProfileTargetArn", valid_594156
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594157 = header.getOrDefault("X-Amz-Date")
  valid_594157 = validateParameter(valid_594157, JString, required = false,
                                 default = nil)
  if valid_594157 != nil:
    section.add "X-Amz-Date", valid_594157
  var valid_594158 = header.getOrDefault("X-Amz-Security-Token")
  valid_594158 = validateParameter(valid_594158, JString, required = false,
                                 default = nil)
  if valid_594158 != nil:
    section.add "X-Amz-Security-Token", valid_594158
  var valid_594159 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594159 = validateParameter(valid_594159, JString, required = false,
                                 default = nil)
  if valid_594159 != nil:
    section.add "X-Amz-Content-Sha256", valid_594159
  var valid_594160 = header.getOrDefault("X-Amz-Algorithm")
  valid_594160 = validateParameter(valid_594160, JString, required = false,
                                 default = nil)
  if valid_594160 != nil:
    section.add "X-Amz-Algorithm", valid_594160
  var valid_594161 = header.getOrDefault("X-Amz-Signature")
  valid_594161 = validateParameter(valid_594161, JString, required = false,
                                 default = nil)
  if valid_594161 != nil:
    section.add "X-Amz-Signature", valid_594161
  var valid_594162 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594162 = validateParameter(valid_594162, JString, required = false,
                                 default = nil)
  if valid_594162 != nil:
    section.add "X-Amz-SignedHeaders", valid_594162
  var valid_594163 = header.getOrDefault("X-Amz-Credential")
  valid_594163 = validateParameter(valid_594163, JString, required = false,
                                 default = nil)
  if valid_594163 != nil:
    section.add "X-Amz-Credential", valid_594163
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594164: Call_AttachSecurityProfile_594152; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ## 
  let valid = call_594164.validator(path, query, header, formData, body)
  let scheme = call_594164.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594164.url(scheme.get, call_594164.host, call_594164.base,
                         call_594164.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594164, url, valid)

proc call*(call_594165: Call_AttachSecurityProfile_594152;
          securityProfileTargetArn: string; securityProfileName: string): Recallable =
  ## attachSecurityProfile
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the target (thing group) to which the security profile is attached.
  ##   securityProfileName: string (required)
  ##                      : The security profile that is attached.
  var path_594166 = newJObject()
  var query_594167 = newJObject()
  add(query_594167, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(path_594166, "securityProfileName", newJString(securityProfileName))
  result = call_594165.call(path_594166, query_594167, nil, nil, nil)

var attachSecurityProfile* = Call_AttachSecurityProfile_594152(
    name: "attachSecurityProfile", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}/targets#securityProfileTargetArn",
    validator: validate_AttachSecurityProfile_594153, base: "/",
    url: url_AttachSecurityProfile_594154, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachSecurityProfile_594168 = ref object of OpenApiRestCall_593437
proc url_DetachSecurityProfile_594170(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"), (
        kind: ConstantSegment, value: "/targets#securityProfileTargetArn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DetachSecurityProfile_594169(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile that is detached.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_594171 = path.getOrDefault("securityProfileName")
  valid_594171 = validateParameter(valid_594171, JString, required = true,
                                 default = nil)
  if valid_594171 != nil:
    section.add "securityProfileName", valid_594171
  result.add "path", section
  ## parameters in `query` object:
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the thing group from which the security profile is detached.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_594172 = query.getOrDefault("securityProfileTargetArn")
  valid_594172 = validateParameter(valid_594172, JString, required = true,
                                 default = nil)
  if valid_594172 != nil:
    section.add "securityProfileTargetArn", valid_594172
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594173 = header.getOrDefault("X-Amz-Date")
  valid_594173 = validateParameter(valid_594173, JString, required = false,
                                 default = nil)
  if valid_594173 != nil:
    section.add "X-Amz-Date", valid_594173
  var valid_594174 = header.getOrDefault("X-Amz-Security-Token")
  valid_594174 = validateParameter(valid_594174, JString, required = false,
                                 default = nil)
  if valid_594174 != nil:
    section.add "X-Amz-Security-Token", valid_594174
  var valid_594175 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594175 = validateParameter(valid_594175, JString, required = false,
                                 default = nil)
  if valid_594175 != nil:
    section.add "X-Amz-Content-Sha256", valid_594175
  var valid_594176 = header.getOrDefault("X-Amz-Algorithm")
  valid_594176 = validateParameter(valid_594176, JString, required = false,
                                 default = nil)
  if valid_594176 != nil:
    section.add "X-Amz-Algorithm", valid_594176
  var valid_594177 = header.getOrDefault("X-Amz-Signature")
  valid_594177 = validateParameter(valid_594177, JString, required = false,
                                 default = nil)
  if valid_594177 != nil:
    section.add "X-Amz-Signature", valid_594177
  var valid_594178 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594178 = validateParameter(valid_594178, JString, required = false,
                                 default = nil)
  if valid_594178 != nil:
    section.add "X-Amz-SignedHeaders", valid_594178
  var valid_594179 = header.getOrDefault("X-Amz-Credential")
  valid_594179 = validateParameter(valid_594179, JString, required = false,
                                 default = nil)
  if valid_594179 != nil:
    section.add "X-Amz-Credential", valid_594179
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594180: Call_DetachSecurityProfile_594168; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ## 
  let valid = call_594180.validator(path, query, header, formData, body)
  let scheme = call_594180.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594180.url(scheme.get, call_594180.host, call_594180.base,
                         call_594180.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594180, url, valid)

proc call*(call_594181: Call_DetachSecurityProfile_594168;
          securityProfileTargetArn: string; securityProfileName: string): Recallable =
  ## detachSecurityProfile
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the thing group from which the security profile is detached.
  ##   securityProfileName: string (required)
  ##                      : The security profile that is detached.
  var path_594182 = newJObject()
  var query_594183 = newJObject()
  add(query_594183, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(path_594182, "securityProfileName", newJString(securityProfileName))
  result = call_594181.call(path_594182, query_594183, nil, nil, nil)

var detachSecurityProfile* = Call_DetachSecurityProfile_594168(
    name: "detachSecurityProfile", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}/targets#securityProfileTargetArn",
    validator: validate_DetachSecurityProfile_594169, base: "/",
    url: url_DetachSecurityProfile_594170, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachThingPrincipal_594184 = ref object of OpenApiRestCall_593437
proc url_AttachThingPrincipal_594186(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals#x-amzn-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_AttachThingPrincipal_594185(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_594187 = path.getOrDefault("thingName")
  valid_594187 = validateParameter(valid_594187, JString, required = true,
                                 default = nil)
  if valid_594187 != nil:
    section.add "thingName", valid_594187
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : The principal, such as a certificate or other credential.
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594188 = header.getOrDefault("X-Amz-Date")
  valid_594188 = validateParameter(valid_594188, JString, required = false,
                                 default = nil)
  if valid_594188 != nil:
    section.add "X-Amz-Date", valid_594188
  var valid_594189 = header.getOrDefault("X-Amz-Security-Token")
  valid_594189 = validateParameter(valid_594189, JString, required = false,
                                 default = nil)
  if valid_594189 != nil:
    section.add "X-Amz-Security-Token", valid_594189
  var valid_594190 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594190 = validateParameter(valid_594190, JString, required = false,
                                 default = nil)
  if valid_594190 != nil:
    section.add "X-Amz-Content-Sha256", valid_594190
  var valid_594191 = header.getOrDefault("X-Amz-Algorithm")
  valid_594191 = validateParameter(valid_594191, JString, required = false,
                                 default = nil)
  if valid_594191 != nil:
    section.add "X-Amz-Algorithm", valid_594191
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_594192 = header.getOrDefault("x-amzn-principal")
  valid_594192 = validateParameter(valid_594192, JString, required = true,
                                 default = nil)
  if valid_594192 != nil:
    section.add "x-amzn-principal", valid_594192
  var valid_594193 = header.getOrDefault("X-Amz-Signature")
  valid_594193 = validateParameter(valid_594193, JString, required = false,
                                 default = nil)
  if valid_594193 != nil:
    section.add "X-Amz-Signature", valid_594193
  var valid_594194 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594194 = validateParameter(valid_594194, JString, required = false,
                                 default = nil)
  if valid_594194 != nil:
    section.add "X-Amz-SignedHeaders", valid_594194
  var valid_594195 = header.getOrDefault("X-Amz-Credential")
  valid_594195 = validateParameter(valid_594195, JString, required = false,
                                 default = nil)
  if valid_594195 != nil:
    section.add "X-Amz-Credential", valid_594195
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594196: Call_AttachThingPrincipal_594184; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  let valid = call_594196.validator(path, query, header, formData, body)
  let scheme = call_594196.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594196.url(scheme.get, call_594196.host, call_594196.base,
                         call_594196.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594196, url, valid)

proc call*(call_594197: Call_AttachThingPrincipal_594184; thingName: string): Recallable =
  ## attachThingPrincipal
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_594198 = newJObject()
  add(path_594198, "thingName", newJString(thingName))
  result = call_594197.call(path_594198, nil, nil, nil, nil)

var attachThingPrincipal* = Call_AttachThingPrincipal_594184(
    name: "attachThingPrincipal", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/things/{thingName}/principals#x-amzn-principal",
    validator: validate_AttachThingPrincipal_594185, base: "/",
    url: url_AttachThingPrincipal_594186, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachThingPrincipal_594199 = ref object of OpenApiRestCall_593437
proc url_DetachThingPrincipal_594201(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals#x-amzn-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DetachThingPrincipal_594200(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_594202 = path.getOrDefault("thingName")
  valid_594202 = validateParameter(valid_594202, JString, required = true,
                                 default = nil)
  if valid_594202 != nil:
    section.add "thingName", valid_594202
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594203 = header.getOrDefault("X-Amz-Date")
  valid_594203 = validateParameter(valid_594203, JString, required = false,
                                 default = nil)
  if valid_594203 != nil:
    section.add "X-Amz-Date", valid_594203
  var valid_594204 = header.getOrDefault("X-Amz-Security-Token")
  valid_594204 = validateParameter(valid_594204, JString, required = false,
                                 default = nil)
  if valid_594204 != nil:
    section.add "X-Amz-Security-Token", valid_594204
  var valid_594205 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594205 = validateParameter(valid_594205, JString, required = false,
                                 default = nil)
  if valid_594205 != nil:
    section.add "X-Amz-Content-Sha256", valid_594205
  var valid_594206 = header.getOrDefault("X-Amz-Algorithm")
  valid_594206 = validateParameter(valid_594206, JString, required = false,
                                 default = nil)
  if valid_594206 != nil:
    section.add "X-Amz-Algorithm", valid_594206
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_594207 = header.getOrDefault("x-amzn-principal")
  valid_594207 = validateParameter(valid_594207, JString, required = true,
                                 default = nil)
  if valid_594207 != nil:
    section.add "x-amzn-principal", valid_594207
  var valid_594208 = header.getOrDefault("X-Amz-Signature")
  valid_594208 = validateParameter(valid_594208, JString, required = false,
                                 default = nil)
  if valid_594208 != nil:
    section.add "X-Amz-Signature", valid_594208
  var valid_594209 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594209 = validateParameter(valid_594209, JString, required = false,
                                 default = nil)
  if valid_594209 != nil:
    section.add "X-Amz-SignedHeaders", valid_594209
  var valid_594210 = header.getOrDefault("X-Amz-Credential")
  valid_594210 = validateParameter(valid_594210, JString, required = false,
                                 default = nil)
  if valid_594210 != nil:
    section.add "X-Amz-Credential", valid_594210
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594211: Call_DetachThingPrincipal_594199; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ## 
  let valid = call_594211.validator(path, query, header, formData, body)
  let scheme = call_594211.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594211.url(scheme.get, call_594211.host, call_594211.base,
                         call_594211.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594211, url, valid)

proc call*(call_594212: Call_DetachThingPrincipal_594199; thingName: string): Recallable =
  ## detachThingPrincipal
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_594213 = newJObject()
  add(path_594213, "thingName", newJString(thingName))
  result = call_594212.call(path_594213, nil, nil, nil, nil)

var detachThingPrincipal* = Call_DetachThingPrincipal_594199(
    name: "detachThingPrincipal", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/things/{thingName}/principals#x-amzn-principal",
    validator: validate_DetachThingPrincipal_594200, base: "/",
    url: url_DetachThingPrincipal_594201, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelAuditMitigationActionsTask_594214 = ref object of OpenApiRestCall_593437
proc url_CancelAuditMitigationActionsTask_594216(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CancelAuditMitigationActionsTask_594215(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The unique identifier for the task that you want to cancel. 
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_594217 = path.getOrDefault("taskId")
  valid_594217 = validateParameter(valid_594217, JString, required = true,
                                 default = nil)
  if valid_594217 != nil:
    section.add "taskId", valid_594217
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594218 = header.getOrDefault("X-Amz-Date")
  valid_594218 = validateParameter(valid_594218, JString, required = false,
                                 default = nil)
  if valid_594218 != nil:
    section.add "X-Amz-Date", valid_594218
  var valid_594219 = header.getOrDefault("X-Amz-Security-Token")
  valid_594219 = validateParameter(valid_594219, JString, required = false,
                                 default = nil)
  if valid_594219 != nil:
    section.add "X-Amz-Security-Token", valid_594219
  var valid_594220 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594220 = validateParameter(valid_594220, JString, required = false,
                                 default = nil)
  if valid_594220 != nil:
    section.add "X-Amz-Content-Sha256", valid_594220
  var valid_594221 = header.getOrDefault("X-Amz-Algorithm")
  valid_594221 = validateParameter(valid_594221, JString, required = false,
                                 default = nil)
  if valid_594221 != nil:
    section.add "X-Amz-Algorithm", valid_594221
  var valid_594222 = header.getOrDefault("X-Amz-Signature")
  valid_594222 = validateParameter(valid_594222, JString, required = false,
                                 default = nil)
  if valid_594222 != nil:
    section.add "X-Amz-Signature", valid_594222
  var valid_594223 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594223 = validateParameter(valid_594223, JString, required = false,
                                 default = nil)
  if valid_594223 != nil:
    section.add "X-Amz-SignedHeaders", valid_594223
  var valid_594224 = header.getOrDefault("X-Amz-Credential")
  valid_594224 = validateParameter(valid_594224, JString, required = false,
                                 default = nil)
  if valid_594224 != nil:
    section.add "X-Amz-Credential", valid_594224
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594225: Call_CancelAuditMitigationActionsTask_594214;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ## 
  let valid = call_594225.validator(path, query, header, formData, body)
  let scheme = call_594225.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594225.url(scheme.get, call_594225.host, call_594225.base,
                         call_594225.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594225, url, valid)

proc call*(call_594226: Call_CancelAuditMitigationActionsTask_594214;
          taskId: string): Recallable =
  ## cancelAuditMitigationActionsTask
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ##   taskId: string (required)
  ##         : The unique identifier for the task that you want to cancel. 
  var path_594227 = newJObject()
  add(path_594227, "taskId", newJString(taskId))
  result = call_594226.call(path_594227, nil, nil, nil, nil)

var cancelAuditMitigationActionsTask* = Call_CancelAuditMitigationActionsTask_594214(
    name: "cancelAuditMitigationActionsTask", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/tasks/{taskId}/cancel",
    validator: validate_CancelAuditMitigationActionsTask_594215, base: "/",
    url: url_CancelAuditMitigationActionsTask_594216,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelAuditTask_594228 = ref object of OpenApiRestCall_593437
proc url_CancelAuditTask_594230(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CancelAuditTask_594229(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_594231 = path.getOrDefault("taskId")
  valid_594231 = validateParameter(valid_594231, JString, required = true,
                                 default = nil)
  if valid_594231 != nil:
    section.add "taskId", valid_594231
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594232 = header.getOrDefault("X-Amz-Date")
  valid_594232 = validateParameter(valid_594232, JString, required = false,
                                 default = nil)
  if valid_594232 != nil:
    section.add "X-Amz-Date", valid_594232
  var valid_594233 = header.getOrDefault("X-Amz-Security-Token")
  valid_594233 = validateParameter(valid_594233, JString, required = false,
                                 default = nil)
  if valid_594233 != nil:
    section.add "X-Amz-Security-Token", valid_594233
  var valid_594234 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594234 = validateParameter(valid_594234, JString, required = false,
                                 default = nil)
  if valid_594234 != nil:
    section.add "X-Amz-Content-Sha256", valid_594234
  var valid_594235 = header.getOrDefault("X-Amz-Algorithm")
  valid_594235 = validateParameter(valid_594235, JString, required = false,
                                 default = nil)
  if valid_594235 != nil:
    section.add "X-Amz-Algorithm", valid_594235
  var valid_594236 = header.getOrDefault("X-Amz-Signature")
  valid_594236 = validateParameter(valid_594236, JString, required = false,
                                 default = nil)
  if valid_594236 != nil:
    section.add "X-Amz-Signature", valid_594236
  var valid_594237 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594237 = validateParameter(valid_594237, JString, required = false,
                                 default = nil)
  if valid_594237 != nil:
    section.add "X-Amz-SignedHeaders", valid_594237
  var valid_594238 = header.getOrDefault("X-Amz-Credential")
  valid_594238 = validateParameter(valid_594238, JString, required = false,
                                 default = nil)
  if valid_594238 != nil:
    section.add "X-Amz-Credential", valid_594238
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594239: Call_CancelAuditTask_594228; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ## 
  let valid = call_594239.validator(path, query, header, formData, body)
  let scheme = call_594239.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594239.url(scheme.get, call_594239.host, call_594239.base,
                         call_594239.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594239, url, valid)

proc call*(call_594240: Call_CancelAuditTask_594228; taskId: string): Recallable =
  ## cancelAuditTask
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ##   taskId: string (required)
  ##         : The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
  var path_594241 = newJObject()
  add(path_594241, "taskId", newJString(taskId))
  result = call_594240.call(path_594241, nil, nil, nil, nil)

var cancelAuditTask* = Call_CancelAuditTask_594228(name: "cancelAuditTask",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/audit/tasks/{taskId}/cancel", validator: validate_CancelAuditTask_594229,
    base: "/", url: url_CancelAuditTask_594230, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelCertificateTransfer_594242 = ref object of OpenApiRestCall_593437
proc url_CancelCertificateTransfer_594244(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cancel-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CancelCertificateTransfer_594243(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_594245 = path.getOrDefault("certificateId")
  valid_594245 = validateParameter(valid_594245, JString, required = true,
                                 default = nil)
  if valid_594245 != nil:
    section.add "certificateId", valid_594245
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594246 = header.getOrDefault("X-Amz-Date")
  valid_594246 = validateParameter(valid_594246, JString, required = false,
                                 default = nil)
  if valid_594246 != nil:
    section.add "X-Amz-Date", valid_594246
  var valid_594247 = header.getOrDefault("X-Amz-Security-Token")
  valid_594247 = validateParameter(valid_594247, JString, required = false,
                                 default = nil)
  if valid_594247 != nil:
    section.add "X-Amz-Security-Token", valid_594247
  var valid_594248 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594248 = validateParameter(valid_594248, JString, required = false,
                                 default = nil)
  if valid_594248 != nil:
    section.add "X-Amz-Content-Sha256", valid_594248
  var valid_594249 = header.getOrDefault("X-Amz-Algorithm")
  valid_594249 = validateParameter(valid_594249, JString, required = false,
                                 default = nil)
  if valid_594249 != nil:
    section.add "X-Amz-Algorithm", valid_594249
  var valid_594250 = header.getOrDefault("X-Amz-Signature")
  valid_594250 = validateParameter(valid_594250, JString, required = false,
                                 default = nil)
  if valid_594250 != nil:
    section.add "X-Amz-Signature", valid_594250
  var valid_594251 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594251 = validateParameter(valid_594251, JString, required = false,
                                 default = nil)
  if valid_594251 != nil:
    section.add "X-Amz-SignedHeaders", valid_594251
  var valid_594252 = header.getOrDefault("X-Amz-Credential")
  valid_594252 = validateParameter(valid_594252, JString, required = false,
                                 default = nil)
  if valid_594252 != nil:
    section.add "X-Amz-Credential", valid_594252
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594253: Call_CancelCertificateTransfer_594242; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ## 
  let valid = call_594253.validator(path, query, header, formData, body)
  let scheme = call_594253.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594253.url(scheme.get, call_594253.host, call_594253.base,
                         call_594253.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594253, url, valid)

proc call*(call_594254: Call_CancelCertificateTransfer_594242;
          certificateId: string): Recallable =
  ## cancelCertificateTransfer
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_594255 = newJObject()
  add(path_594255, "certificateId", newJString(certificateId))
  result = call_594254.call(path_594255, nil, nil, nil, nil)

var cancelCertificateTransfer* = Call_CancelCertificateTransfer_594242(
    name: "cancelCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/cancel-certificate-transfer/{certificateId}",
    validator: validate_CancelCertificateTransfer_594243, base: "/",
    url: url_CancelCertificateTransfer_594244,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelJob_594256 = ref object of OpenApiRestCall_593437
proc url_CancelJob_594258(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CancelJob_594257(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_594259 = path.getOrDefault("jobId")
  valid_594259 = validateParameter(valid_594259, JString, required = true,
                                 default = nil)
  if valid_594259 != nil:
    section.add "jobId", valid_594259
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
  section = newJObject()
  var valid_594260 = query.getOrDefault("force")
  valid_594260 = validateParameter(valid_594260, JBool, required = false, default = nil)
  if valid_594260 != nil:
    section.add "force", valid_594260
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594261 = header.getOrDefault("X-Amz-Date")
  valid_594261 = validateParameter(valid_594261, JString, required = false,
                                 default = nil)
  if valid_594261 != nil:
    section.add "X-Amz-Date", valid_594261
  var valid_594262 = header.getOrDefault("X-Amz-Security-Token")
  valid_594262 = validateParameter(valid_594262, JString, required = false,
                                 default = nil)
  if valid_594262 != nil:
    section.add "X-Amz-Security-Token", valid_594262
  var valid_594263 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594263 = validateParameter(valid_594263, JString, required = false,
                                 default = nil)
  if valid_594263 != nil:
    section.add "X-Amz-Content-Sha256", valid_594263
  var valid_594264 = header.getOrDefault("X-Amz-Algorithm")
  valid_594264 = validateParameter(valid_594264, JString, required = false,
                                 default = nil)
  if valid_594264 != nil:
    section.add "X-Amz-Algorithm", valid_594264
  var valid_594265 = header.getOrDefault("X-Amz-Signature")
  valid_594265 = validateParameter(valid_594265, JString, required = false,
                                 default = nil)
  if valid_594265 != nil:
    section.add "X-Amz-Signature", valid_594265
  var valid_594266 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594266 = validateParameter(valid_594266, JString, required = false,
                                 default = nil)
  if valid_594266 != nil:
    section.add "X-Amz-SignedHeaders", valid_594266
  var valid_594267 = header.getOrDefault("X-Amz-Credential")
  valid_594267 = validateParameter(valid_594267, JString, required = false,
                                 default = nil)
  if valid_594267 != nil:
    section.add "X-Amz-Credential", valid_594267
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594269: Call_CancelJob_594256; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a job.
  ## 
  let valid = call_594269.validator(path, query, header, formData, body)
  let scheme = call_594269.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594269.url(scheme.get, call_594269.host, call_594269.base,
                         call_594269.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594269, url, valid)

proc call*(call_594270: Call_CancelJob_594256; jobId: string; body: JsonNode;
          force: bool = false): Recallable =
  ## cancelJob
  ## Cancels a job.
  ##   force: bool
  ##        : <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   body: JObject (required)
  var path_594271 = newJObject()
  var query_594272 = newJObject()
  var body_594273 = newJObject()
  add(query_594272, "force", newJBool(force))
  add(path_594271, "jobId", newJString(jobId))
  if body != nil:
    body_594273 = body
  result = call_594270.call(path_594271, query_594272, nil, nil, body_594273)

var cancelJob* = Call_CancelJob_594256(name: "cancelJob", meth: HttpMethod.HttpPut,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}/cancel",
                                    validator: validate_CancelJob_594257,
                                    base: "/", url: url_CancelJob_594258,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelJobExecution_594274 = ref object of OpenApiRestCall_593437
proc url_CancelJobExecution_594276(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CancelJobExecution_594275(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Cancels the execution of a job for a given thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing whose execution of the job will be canceled.
  ##   jobId: JString (required)
  ##        : The ID of the job to be canceled.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_594277 = path.getOrDefault("thingName")
  valid_594277 = validateParameter(valid_594277, JString, required = true,
                                 default = nil)
  if valid_594277 != nil:
    section.add "thingName", valid_594277
  var valid_594278 = path.getOrDefault("jobId")
  valid_594278 = validateParameter(valid_594278, JString, required = true,
                                 default = nil)
  if valid_594278 != nil:
    section.add "jobId", valid_594278
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
  section = newJObject()
  var valid_594279 = query.getOrDefault("force")
  valid_594279 = validateParameter(valid_594279, JBool, required = false, default = nil)
  if valid_594279 != nil:
    section.add "force", valid_594279
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594280 = header.getOrDefault("X-Amz-Date")
  valid_594280 = validateParameter(valid_594280, JString, required = false,
                                 default = nil)
  if valid_594280 != nil:
    section.add "X-Amz-Date", valid_594280
  var valid_594281 = header.getOrDefault("X-Amz-Security-Token")
  valid_594281 = validateParameter(valid_594281, JString, required = false,
                                 default = nil)
  if valid_594281 != nil:
    section.add "X-Amz-Security-Token", valid_594281
  var valid_594282 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594282 = validateParameter(valid_594282, JString, required = false,
                                 default = nil)
  if valid_594282 != nil:
    section.add "X-Amz-Content-Sha256", valid_594282
  var valid_594283 = header.getOrDefault("X-Amz-Algorithm")
  valid_594283 = validateParameter(valid_594283, JString, required = false,
                                 default = nil)
  if valid_594283 != nil:
    section.add "X-Amz-Algorithm", valid_594283
  var valid_594284 = header.getOrDefault("X-Amz-Signature")
  valid_594284 = validateParameter(valid_594284, JString, required = false,
                                 default = nil)
  if valid_594284 != nil:
    section.add "X-Amz-Signature", valid_594284
  var valid_594285 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594285 = validateParameter(valid_594285, JString, required = false,
                                 default = nil)
  if valid_594285 != nil:
    section.add "X-Amz-SignedHeaders", valid_594285
  var valid_594286 = header.getOrDefault("X-Amz-Credential")
  valid_594286 = validateParameter(valid_594286, JString, required = false,
                                 default = nil)
  if valid_594286 != nil:
    section.add "X-Amz-Credential", valid_594286
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594288: Call_CancelJobExecution_594274; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels the execution of a job for a given thing.
  ## 
  let valid = call_594288.validator(path, query, header, formData, body)
  let scheme = call_594288.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594288.url(scheme.get, call_594288.host, call_594288.base,
                         call_594288.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594288, url, valid)

proc call*(call_594289: Call_CancelJobExecution_594274; thingName: string;
          jobId: string; body: JsonNode; force: bool = false): Recallable =
  ## cancelJobExecution
  ## Cancels the execution of a job for a given thing.
  ##   force: bool
  ##        : <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
  ##   thingName: string (required)
  ##            : The name of the thing whose execution of the job will be canceled.
  ##   jobId: string (required)
  ##        : The ID of the job to be canceled.
  ##   body: JObject (required)
  var path_594290 = newJObject()
  var query_594291 = newJObject()
  var body_594292 = newJObject()
  add(query_594291, "force", newJBool(force))
  add(path_594290, "thingName", newJString(thingName))
  add(path_594290, "jobId", newJString(jobId))
  if body != nil:
    body_594292 = body
  result = call_594289.call(path_594290, query_594291, nil, nil, body_594292)

var cancelJobExecution* = Call_CancelJobExecution_594274(
    name: "cancelJobExecution", meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/things/{thingName}/jobs/{jobId}/cancel",
    validator: validate_CancelJobExecution_594275, base: "/",
    url: url_CancelJobExecution_594276, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetDefaultAuthorizer_594305 = ref object of OpenApiRestCall_593437
proc url_SetDefaultAuthorizer_594307(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_SetDefaultAuthorizer_594306(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594308 = header.getOrDefault("X-Amz-Date")
  valid_594308 = validateParameter(valid_594308, JString, required = false,
                                 default = nil)
  if valid_594308 != nil:
    section.add "X-Amz-Date", valid_594308
  var valid_594309 = header.getOrDefault("X-Amz-Security-Token")
  valid_594309 = validateParameter(valid_594309, JString, required = false,
                                 default = nil)
  if valid_594309 != nil:
    section.add "X-Amz-Security-Token", valid_594309
  var valid_594310 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594310 = validateParameter(valid_594310, JString, required = false,
                                 default = nil)
  if valid_594310 != nil:
    section.add "X-Amz-Content-Sha256", valid_594310
  var valid_594311 = header.getOrDefault("X-Amz-Algorithm")
  valid_594311 = validateParameter(valid_594311, JString, required = false,
                                 default = nil)
  if valid_594311 != nil:
    section.add "X-Amz-Algorithm", valid_594311
  var valid_594312 = header.getOrDefault("X-Amz-Signature")
  valid_594312 = validateParameter(valid_594312, JString, required = false,
                                 default = nil)
  if valid_594312 != nil:
    section.add "X-Amz-Signature", valid_594312
  var valid_594313 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594313 = validateParameter(valid_594313, JString, required = false,
                                 default = nil)
  if valid_594313 != nil:
    section.add "X-Amz-SignedHeaders", valid_594313
  var valid_594314 = header.getOrDefault("X-Amz-Credential")
  valid_594314 = validateParameter(valid_594314, JString, required = false,
                                 default = nil)
  if valid_594314 != nil:
    section.add "X-Amz-Credential", valid_594314
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594316: Call_SetDefaultAuthorizer_594305; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ## 
  let valid = call_594316.validator(path, query, header, formData, body)
  let scheme = call_594316.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594316.url(scheme.get, call_594316.host, call_594316.base,
                         call_594316.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594316, url, valid)

proc call*(call_594317: Call_SetDefaultAuthorizer_594305; body: JsonNode): Recallable =
  ## setDefaultAuthorizer
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ##   body: JObject (required)
  var body_594318 = newJObject()
  if body != nil:
    body_594318 = body
  result = call_594317.call(nil, nil, nil, nil, body_594318)

var setDefaultAuthorizer* = Call_SetDefaultAuthorizer_594305(
    name: "setDefaultAuthorizer", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_SetDefaultAuthorizer_594306, base: "/",
    url: url_SetDefaultAuthorizer_594307, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeDefaultAuthorizer_594293 = ref object of OpenApiRestCall_593437
proc url_DescribeDefaultAuthorizer_594295(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DescribeDefaultAuthorizer_594294(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes the default authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594296 = header.getOrDefault("X-Amz-Date")
  valid_594296 = validateParameter(valid_594296, JString, required = false,
                                 default = nil)
  if valid_594296 != nil:
    section.add "X-Amz-Date", valid_594296
  var valid_594297 = header.getOrDefault("X-Amz-Security-Token")
  valid_594297 = validateParameter(valid_594297, JString, required = false,
                                 default = nil)
  if valid_594297 != nil:
    section.add "X-Amz-Security-Token", valid_594297
  var valid_594298 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594298 = validateParameter(valid_594298, JString, required = false,
                                 default = nil)
  if valid_594298 != nil:
    section.add "X-Amz-Content-Sha256", valid_594298
  var valid_594299 = header.getOrDefault("X-Amz-Algorithm")
  valid_594299 = validateParameter(valid_594299, JString, required = false,
                                 default = nil)
  if valid_594299 != nil:
    section.add "X-Amz-Algorithm", valid_594299
  var valid_594300 = header.getOrDefault("X-Amz-Signature")
  valid_594300 = validateParameter(valid_594300, JString, required = false,
                                 default = nil)
  if valid_594300 != nil:
    section.add "X-Amz-Signature", valid_594300
  var valid_594301 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594301 = validateParameter(valid_594301, JString, required = false,
                                 default = nil)
  if valid_594301 != nil:
    section.add "X-Amz-SignedHeaders", valid_594301
  var valid_594302 = header.getOrDefault("X-Amz-Credential")
  valid_594302 = validateParameter(valid_594302, JString, required = false,
                                 default = nil)
  if valid_594302 != nil:
    section.add "X-Amz-Credential", valid_594302
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594303: Call_DescribeDefaultAuthorizer_594293; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes the default authorizer.
  ## 
  let valid = call_594303.validator(path, query, header, formData, body)
  let scheme = call_594303.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594303.url(scheme.get, call_594303.host, call_594303.base,
                         call_594303.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594303, url, valid)

proc call*(call_594304: Call_DescribeDefaultAuthorizer_594293): Recallable =
  ## describeDefaultAuthorizer
  ## Describes the default authorizer.
  result = call_594304.call(nil, nil, nil, nil, nil)

var describeDefaultAuthorizer* = Call_DescribeDefaultAuthorizer_594293(
    name: "describeDefaultAuthorizer", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_DescribeDefaultAuthorizer_594294, base: "/",
    url: url_DescribeDefaultAuthorizer_594295,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ClearDefaultAuthorizer_594319 = ref object of OpenApiRestCall_593437
proc url_ClearDefaultAuthorizer_594321(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ClearDefaultAuthorizer_594320(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Clears the default authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594322 = header.getOrDefault("X-Amz-Date")
  valid_594322 = validateParameter(valid_594322, JString, required = false,
                                 default = nil)
  if valid_594322 != nil:
    section.add "X-Amz-Date", valid_594322
  var valid_594323 = header.getOrDefault("X-Amz-Security-Token")
  valid_594323 = validateParameter(valid_594323, JString, required = false,
                                 default = nil)
  if valid_594323 != nil:
    section.add "X-Amz-Security-Token", valid_594323
  var valid_594324 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594324 = validateParameter(valid_594324, JString, required = false,
                                 default = nil)
  if valid_594324 != nil:
    section.add "X-Amz-Content-Sha256", valid_594324
  var valid_594325 = header.getOrDefault("X-Amz-Algorithm")
  valid_594325 = validateParameter(valid_594325, JString, required = false,
                                 default = nil)
  if valid_594325 != nil:
    section.add "X-Amz-Algorithm", valid_594325
  var valid_594326 = header.getOrDefault("X-Amz-Signature")
  valid_594326 = validateParameter(valid_594326, JString, required = false,
                                 default = nil)
  if valid_594326 != nil:
    section.add "X-Amz-Signature", valid_594326
  var valid_594327 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594327 = validateParameter(valid_594327, JString, required = false,
                                 default = nil)
  if valid_594327 != nil:
    section.add "X-Amz-SignedHeaders", valid_594327
  var valid_594328 = header.getOrDefault("X-Amz-Credential")
  valid_594328 = validateParameter(valid_594328, JString, required = false,
                                 default = nil)
  if valid_594328 != nil:
    section.add "X-Amz-Credential", valid_594328
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594329: Call_ClearDefaultAuthorizer_594319; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Clears the default authorizer.
  ## 
  let valid = call_594329.validator(path, query, header, formData, body)
  let scheme = call_594329.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594329.url(scheme.get, call_594329.host, call_594329.base,
                         call_594329.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594329, url, valid)

proc call*(call_594330: Call_ClearDefaultAuthorizer_594319): Recallable =
  ## clearDefaultAuthorizer
  ## Clears the default authorizer.
  result = call_594330.call(nil, nil, nil, nil, nil)

var clearDefaultAuthorizer* = Call_ClearDefaultAuthorizer_594319(
    name: "clearDefaultAuthorizer", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_ClearDefaultAuthorizer_594320, base: "/",
    url: url_ClearDefaultAuthorizer_594321, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateAuthorizer_594345 = ref object of OpenApiRestCall_593437
proc url_UpdateAuthorizer_594347(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateAuthorizer_594346(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Updates an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_594348 = path.getOrDefault("authorizerName")
  valid_594348 = validateParameter(valid_594348, JString, required = true,
                                 default = nil)
  if valid_594348 != nil:
    section.add "authorizerName", valid_594348
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594349 = header.getOrDefault("X-Amz-Date")
  valid_594349 = validateParameter(valid_594349, JString, required = false,
                                 default = nil)
  if valid_594349 != nil:
    section.add "X-Amz-Date", valid_594349
  var valid_594350 = header.getOrDefault("X-Amz-Security-Token")
  valid_594350 = validateParameter(valid_594350, JString, required = false,
                                 default = nil)
  if valid_594350 != nil:
    section.add "X-Amz-Security-Token", valid_594350
  var valid_594351 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594351 = validateParameter(valid_594351, JString, required = false,
                                 default = nil)
  if valid_594351 != nil:
    section.add "X-Amz-Content-Sha256", valid_594351
  var valid_594352 = header.getOrDefault("X-Amz-Algorithm")
  valid_594352 = validateParameter(valid_594352, JString, required = false,
                                 default = nil)
  if valid_594352 != nil:
    section.add "X-Amz-Algorithm", valid_594352
  var valid_594353 = header.getOrDefault("X-Amz-Signature")
  valid_594353 = validateParameter(valid_594353, JString, required = false,
                                 default = nil)
  if valid_594353 != nil:
    section.add "X-Amz-Signature", valid_594353
  var valid_594354 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594354 = validateParameter(valid_594354, JString, required = false,
                                 default = nil)
  if valid_594354 != nil:
    section.add "X-Amz-SignedHeaders", valid_594354
  var valid_594355 = header.getOrDefault("X-Amz-Credential")
  valid_594355 = validateParameter(valid_594355, JString, required = false,
                                 default = nil)
  if valid_594355 != nil:
    section.add "X-Amz-Credential", valid_594355
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594357: Call_UpdateAuthorizer_594345; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an authorizer.
  ## 
  let valid = call_594357.validator(path, query, header, formData, body)
  let scheme = call_594357.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594357.url(scheme.get, call_594357.host, call_594357.base,
                         call_594357.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594357, url, valid)

proc call*(call_594358: Call_UpdateAuthorizer_594345; authorizerName: string;
          body: JsonNode): Recallable =
  ## updateAuthorizer
  ## Updates an authorizer.
  ##   authorizerName: string (required)
  ##                 : The authorizer name.
  ##   body: JObject (required)
  var path_594359 = newJObject()
  var body_594360 = newJObject()
  add(path_594359, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_594360 = body
  result = call_594358.call(path_594359, nil, nil, nil, body_594360)

var updateAuthorizer* = Call_UpdateAuthorizer_594345(name: "updateAuthorizer",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_UpdateAuthorizer_594346,
    base: "/", url: url_UpdateAuthorizer_594347,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateAuthorizer_594361 = ref object of OpenApiRestCall_593437
proc url_CreateAuthorizer_594363(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateAuthorizer_594362(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Creates an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_594364 = path.getOrDefault("authorizerName")
  valid_594364 = validateParameter(valid_594364, JString, required = true,
                                 default = nil)
  if valid_594364 != nil:
    section.add "authorizerName", valid_594364
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594365 = header.getOrDefault("X-Amz-Date")
  valid_594365 = validateParameter(valid_594365, JString, required = false,
                                 default = nil)
  if valid_594365 != nil:
    section.add "X-Amz-Date", valid_594365
  var valid_594366 = header.getOrDefault("X-Amz-Security-Token")
  valid_594366 = validateParameter(valid_594366, JString, required = false,
                                 default = nil)
  if valid_594366 != nil:
    section.add "X-Amz-Security-Token", valid_594366
  var valid_594367 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594367 = validateParameter(valid_594367, JString, required = false,
                                 default = nil)
  if valid_594367 != nil:
    section.add "X-Amz-Content-Sha256", valid_594367
  var valid_594368 = header.getOrDefault("X-Amz-Algorithm")
  valid_594368 = validateParameter(valid_594368, JString, required = false,
                                 default = nil)
  if valid_594368 != nil:
    section.add "X-Amz-Algorithm", valid_594368
  var valid_594369 = header.getOrDefault("X-Amz-Signature")
  valid_594369 = validateParameter(valid_594369, JString, required = false,
                                 default = nil)
  if valid_594369 != nil:
    section.add "X-Amz-Signature", valid_594369
  var valid_594370 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594370 = validateParameter(valid_594370, JString, required = false,
                                 default = nil)
  if valid_594370 != nil:
    section.add "X-Amz-SignedHeaders", valid_594370
  var valid_594371 = header.getOrDefault("X-Amz-Credential")
  valid_594371 = validateParameter(valid_594371, JString, required = false,
                                 default = nil)
  if valid_594371 != nil:
    section.add "X-Amz-Credential", valid_594371
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594373: Call_CreateAuthorizer_594361; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates an authorizer.
  ## 
  let valid = call_594373.validator(path, query, header, formData, body)
  let scheme = call_594373.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594373.url(scheme.get, call_594373.host, call_594373.base,
                         call_594373.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594373, url, valid)

proc call*(call_594374: Call_CreateAuthorizer_594361; authorizerName: string;
          body: JsonNode): Recallable =
  ## createAuthorizer
  ## Creates an authorizer.
  ##   authorizerName: string (required)
  ##                 : The authorizer name.
  ##   body: JObject (required)
  var path_594375 = newJObject()
  var body_594376 = newJObject()
  add(path_594375, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_594376 = body
  result = call_594374.call(path_594375, nil, nil, nil, body_594376)

var createAuthorizer* = Call_CreateAuthorizer_594361(name: "createAuthorizer",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_CreateAuthorizer_594362,
    base: "/", url: url_CreateAuthorizer_594363,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuthorizer_594331 = ref object of OpenApiRestCall_593437
proc url_DescribeAuthorizer_594333(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeAuthorizer_594332(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Describes an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The name of the authorizer to describe.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_594334 = path.getOrDefault("authorizerName")
  valid_594334 = validateParameter(valid_594334, JString, required = true,
                                 default = nil)
  if valid_594334 != nil:
    section.add "authorizerName", valid_594334
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594335 = header.getOrDefault("X-Amz-Date")
  valid_594335 = validateParameter(valid_594335, JString, required = false,
                                 default = nil)
  if valid_594335 != nil:
    section.add "X-Amz-Date", valid_594335
  var valid_594336 = header.getOrDefault("X-Amz-Security-Token")
  valid_594336 = validateParameter(valid_594336, JString, required = false,
                                 default = nil)
  if valid_594336 != nil:
    section.add "X-Amz-Security-Token", valid_594336
  var valid_594337 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594337 = validateParameter(valid_594337, JString, required = false,
                                 default = nil)
  if valid_594337 != nil:
    section.add "X-Amz-Content-Sha256", valid_594337
  var valid_594338 = header.getOrDefault("X-Amz-Algorithm")
  valid_594338 = validateParameter(valid_594338, JString, required = false,
                                 default = nil)
  if valid_594338 != nil:
    section.add "X-Amz-Algorithm", valid_594338
  var valid_594339 = header.getOrDefault("X-Amz-Signature")
  valid_594339 = validateParameter(valid_594339, JString, required = false,
                                 default = nil)
  if valid_594339 != nil:
    section.add "X-Amz-Signature", valid_594339
  var valid_594340 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594340 = validateParameter(valid_594340, JString, required = false,
                                 default = nil)
  if valid_594340 != nil:
    section.add "X-Amz-SignedHeaders", valid_594340
  var valid_594341 = header.getOrDefault("X-Amz-Credential")
  valid_594341 = validateParameter(valid_594341, JString, required = false,
                                 default = nil)
  if valid_594341 != nil:
    section.add "X-Amz-Credential", valid_594341
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594342: Call_DescribeAuthorizer_594331; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes an authorizer.
  ## 
  let valid = call_594342.validator(path, query, header, formData, body)
  let scheme = call_594342.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594342.url(scheme.get, call_594342.host, call_594342.base,
                         call_594342.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594342, url, valid)

proc call*(call_594343: Call_DescribeAuthorizer_594331; authorizerName: string): Recallable =
  ## describeAuthorizer
  ## Describes an authorizer.
  ##   authorizerName: string (required)
  ##                 : The name of the authorizer to describe.
  var path_594344 = newJObject()
  add(path_594344, "authorizerName", newJString(authorizerName))
  result = call_594343.call(path_594344, nil, nil, nil, nil)

var describeAuthorizer* = Call_DescribeAuthorizer_594331(
    name: "describeAuthorizer", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_DescribeAuthorizer_594332,
    base: "/", url: url_DescribeAuthorizer_594333,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteAuthorizer_594377 = ref object of OpenApiRestCall_593437
proc url_DeleteAuthorizer_594379(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteAuthorizer_594378(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Deletes an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The name of the authorizer to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_594380 = path.getOrDefault("authorizerName")
  valid_594380 = validateParameter(valid_594380, JString, required = true,
                                 default = nil)
  if valid_594380 != nil:
    section.add "authorizerName", valid_594380
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594381 = header.getOrDefault("X-Amz-Date")
  valid_594381 = validateParameter(valid_594381, JString, required = false,
                                 default = nil)
  if valid_594381 != nil:
    section.add "X-Amz-Date", valid_594381
  var valid_594382 = header.getOrDefault("X-Amz-Security-Token")
  valid_594382 = validateParameter(valid_594382, JString, required = false,
                                 default = nil)
  if valid_594382 != nil:
    section.add "X-Amz-Security-Token", valid_594382
  var valid_594383 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594383 = validateParameter(valid_594383, JString, required = false,
                                 default = nil)
  if valid_594383 != nil:
    section.add "X-Amz-Content-Sha256", valid_594383
  var valid_594384 = header.getOrDefault("X-Amz-Algorithm")
  valid_594384 = validateParameter(valid_594384, JString, required = false,
                                 default = nil)
  if valid_594384 != nil:
    section.add "X-Amz-Algorithm", valid_594384
  var valid_594385 = header.getOrDefault("X-Amz-Signature")
  valid_594385 = validateParameter(valid_594385, JString, required = false,
                                 default = nil)
  if valid_594385 != nil:
    section.add "X-Amz-Signature", valid_594385
  var valid_594386 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594386 = validateParameter(valid_594386, JString, required = false,
                                 default = nil)
  if valid_594386 != nil:
    section.add "X-Amz-SignedHeaders", valid_594386
  var valid_594387 = header.getOrDefault("X-Amz-Credential")
  valid_594387 = validateParameter(valid_594387, JString, required = false,
                                 default = nil)
  if valid_594387 != nil:
    section.add "X-Amz-Credential", valid_594387
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594388: Call_DeleteAuthorizer_594377; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an authorizer.
  ## 
  let valid = call_594388.validator(path, query, header, formData, body)
  let scheme = call_594388.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594388.url(scheme.get, call_594388.host, call_594388.base,
                         call_594388.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594388, url, valid)

proc call*(call_594389: Call_DeleteAuthorizer_594377; authorizerName: string): Recallable =
  ## deleteAuthorizer
  ## Deletes an authorizer.
  ##   authorizerName: string (required)
  ##                 : The name of the authorizer to delete.
  var path_594390 = newJObject()
  add(path_594390, "authorizerName", newJString(authorizerName))
  result = call_594389.call(path_594390, nil, nil, nil, nil)

var deleteAuthorizer* = Call_DeleteAuthorizer_594377(name: "deleteAuthorizer",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_DeleteAuthorizer_594378,
    base: "/", url: url_DeleteAuthorizer_594379,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateBillingGroup_594405 = ref object of OpenApiRestCall_593437
proc url_CreateBillingGroup_594407(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateBillingGroup_594406(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Creates a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name you wish to give to the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_594408 = path.getOrDefault("billingGroupName")
  valid_594408 = validateParameter(valid_594408, JString, required = true,
                                 default = nil)
  if valid_594408 != nil:
    section.add "billingGroupName", valid_594408
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594409 = header.getOrDefault("X-Amz-Date")
  valid_594409 = validateParameter(valid_594409, JString, required = false,
                                 default = nil)
  if valid_594409 != nil:
    section.add "X-Amz-Date", valid_594409
  var valid_594410 = header.getOrDefault("X-Amz-Security-Token")
  valid_594410 = validateParameter(valid_594410, JString, required = false,
                                 default = nil)
  if valid_594410 != nil:
    section.add "X-Amz-Security-Token", valid_594410
  var valid_594411 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594411 = validateParameter(valid_594411, JString, required = false,
                                 default = nil)
  if valid_594411 != nil:
    section.add "X-Amz-Content-Sha256", valid_594411
  var valid_594412 = header.getOrDefault("X-Amz-Algorithm")
  valid_594412 = validateParameter(valid_594412, JString, required = false,
                                 default = nil)
  if valid_594412 != nil:
    section.add "X-Amz-Algorithm", valid_594412
  var valid_594413 = header.getOrDefault("X-Amz-Signature")
  valid_594413 = validateParameter(valid_594413, JString, required = false,
                                 default = nil)
  if valid_594413 != nil:
    section.add "X-Amz-Signature", valid_594413
  var valid_594414 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594414 = validateParameter(valid_594414, JString, required = false,
                                 default = nil)
  if valid_594414 != nil:
    section.add "X-Amz-SignedHeaders", valid_594414
  var valid_594415 = header.getOrDefault("X-Amz-Credential")
  valid_594415 = validateParameter(valid_594415, JString, required = false,
                                 default = nil)
  if valid_594415 != nil:
    section.add "X-Amz-Credential", valid_594415
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594417: Call_CreateBillingGroup_594405; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a billing group.
  ## 
  let valid = call_594417.validator(path, query, header, formData, body)
  let scheme = call_594417.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594417.url(scheme.get, call_594417.host, call_594417.base,
                         call_594417.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594417, url, valid)

proc call*(call_594418: Call_CreateBillingGroup_594405; billingGroupName: string;
          body: JsonNode): Recallable =
  ## createBillingGroup
  ## Creates a billing group.
  ##   billingGroupName: string (required)
  ##                   : The name you wish to give to the billing group.
  ##   body: JObject (required)
  var path_594419 = newJObject()
  var body_594420 = newJObject()
  add(path_594419, "billingGroupName", newJString(billingGroupName))
  if body != nil:
    body_594420 = body
  result = call_594418.call(path_594419, nil, nil, nil, body_594420)

var createBillingGroup* = Call_CreateBillingGroup_594405(
    name: "createBillingGroup", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_CreateBillingGroup_594406, base: "/",
    url: url_CreateBillingGroup_594407, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeBillingGroup_594391 = ref object of OpenApiRestCall_593437
proc url_DescribeBillingGroup_594393(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeBillingGroup_594392(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_594394 = path.getOrDefault("billingGroupName")
  valid_594394 = validateParameter(valid_594394, JString, required = true,
                                 default = nil)
  if valid_594394 != nil:
    section.add "billingGroupName", valid_594394
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594395 = header.getOrDefault("X-Amz-Date")
  valid_594395 = validateParameter(valid_594395, JString, required = false,
                                 default = nil)
  if valid_594395 != nil:
    section.add "X-Amz-Date", valid_594395
  var valid_594396 = header.getOrDefault("X-Amz-Security-Token")
  valid_594396 = validateParameter(valid_594396, JString, required = false,
                                 default = nil)
  if valid_594396 != nil:
    section.add "X-Amz-Security-Token", valid_594396
  var valid_594397 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594397 = validateParameter(valid_594397, JString, required = false,
                                 default = nil)
  if valid_594397 != nil:
    section.add "X-Amz-Content-Sha256", valid_594397
  var valid_594398 = header.getOrDefault("X-Amz-Algorithm")
  valid_594398 = validateParameter(valid_594398, JString, required = false,
                                 default = nil)
  if valid_594398 != nil:
    section.add "X-Amz-Algorithm", valid_594398
  var valid_594399 = header.getOrDefault("X-Amz-Signature")
  valid_594399 = validateParameter(valid_594399, JString, required = false,
                                 default = nil)
  if valid_594399 != nil:
    section.add "X-Amz-Signature", valid_594399
  var valid_594400 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594400 = validateParameter(valid_594400, JString, required = false,
                                 default = nil)
  if valid_594400 != nil:
    section.add "X-Amz-SignedHeaders", valid_594400
  var valid_594401 = header.getOrDefault("X-Amz-Credential")
  valid_594401 = validateParameter(valid_594401, JString, required = false,
                                 default = nil)
  if valid_594401 != nil:
    section.add "X-Amz-Credential", valid_594401
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594402: Call_DescribeBillingGroup_594391; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about a billing group.
  ## 
  let valid = call_594402.validator(path, query, header, formData, body)
  let scheme = call_594402.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594402.url(scheme.get, call_594402.host, call_594402.base,
                         call_594402.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594402, url, valid)

proc call*(call_594403: Call_DescribeBillingGroup_594391; billingGroupName: string): Recallable =
  ## describeBillingGroup
  ## Returns information about a billing group.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_594404 = newJObject()
  add(path_594404, "billingGroupName", newJString(billingGroupName))
  result = call_594403.call(path_594404, nil, nil, nil, nil)

var describeBillingGroup* = Call_DescribeBillingGroup_594391(
    name: "describeBillingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_DescribeBillingGroup_594392, base: "/",
    url: url_DescribeBillingGroup_594393, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateBillingGroup_594437 = ref object of OpenApiRestCall_593437
proc url_UpdateBillingGroup_594439(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateBillingGroup_594438(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Updates information about the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_594440 = path.getOrDefault("billingGroupName")
  valid_594440 = validateParameter(valid_594440, JString, required = true,
                                 default = nil)
  if valid_594440 != nil:
    section.add "billingGroupName", valid_594440
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594441 = header.getOrDefault("X-Amz-Date")
  valid_594441 = validateParameter(valid_594441, JString, required = false,
                                 default = nil)
  if valid_594441 != nil:
    section.add "X-Amz-Date", valid_594441
  var valid_594442 = header.getOrDefault("X-Amz-Security-Token")
  valid_594442 = validateParameter(valid_594442, JString, required = false,
                                 default = nil)
  if valid_594442 != nil:
    section.add "X-Amz-Security-Token", valid_594442
  var valid_594443 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594443 = validateParameter(valid_594443, JString, required = false,
                                 default = nil)
  if valid_594443 != nil:
    section.add "X-Amz-Content-Sha256", valid_594443
  var valid_594444 = header.getOrDefault("X-Amz-Algorithm")
  valid_594444 = validateParameter(valid_594444, JString, required = false,
                                 default = nil)
  if valid_594444 != nil:
    section.add "X-Amz-Algorithm", valid_594444
  var valid_594445 = header.getOrDefault("X-Amz-Signature")
  valid_594445 = validateParameter(valid_594445, JString, required = false,
                                 default = nil)
  if valid_594445 != nil:
    section.add "X-Amz-Signature", valid_594445
  var valid_594446 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594446 = validateParameter(valid_594446, JString, required = false,
                                 default = nil)
  if valid_594446 != nil:
    section.add "X-Amz-SignedHeaders", valid_594446
  var valid_594447 = header.getOrDefault("X-Amz-Credential")
  valid_594447 = validateParameter(valid_594447, JString, required = false,
                                 default = nil)
  if valid_594447 != nil:
    section.add "X-Amz-Credential", valid_594447
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594449: Call_UpdateBillingGroup_594437; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates information about the billing group.
  ## 
  let valid = call_594449.validator(path, query, header, formData, body)
  let scheme = call_594449.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594449.url(scheme.get, call_594449.host, call_594449.base,
                         call_594449.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594449, url, valid)

proc call*(call_594450: Call_UpdateBillingGroup_594437; billingGroupName: string;
          body: JsonNode): Recallable =
  ## updateBillingGroup
  ## Updates information about the billing group.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  ##   body: JObject (required)
  var path_594451 = newJObject()
  var body_594452 = newJObject()
  add(path_594451, "billingGroupName", newJString(billingGroupName))
  if body != nil:
    body_594452 = body
  result = call_594450.call(path_594451, nil, nil, nil, body_594452)

var updateBillingGroup* = Call_UpdateBillingGroup_594437(
    name: "updateBillingGroup", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_UpdateBillingGroup_594438, base: "/",
    url: url_UpdateBillingGroup_594439, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteBillingGroup_594421 = ref object of OpenApiRestCall_593437
proc url_DeleteBillingGroup_594423(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteBillingGroup_594422(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deletes the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_594424 = path.getOrDefault("billingGroupName")
  valid_594424 = validateParameter(valid_594424, JString, required = true,
                                 default = nil)
  if valid_594424 != nil:
    section.add "billingGroupName", valid_594424
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.
  section = newJObject()
  var valid_594425 = query.getOrDefault("expectedVersion")
  valid_594425 = validateParameter(valid_594425, JInt, required = false, default = nil)
  if valid_594425 != nil:
    section.add "expectedVersion", valid_594425
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594426 = header.getOrDefault("X-Amz-Date")
  valid_594426 = validateParameter(valid_594426, JString, required = false,
                                 default = nil)
  if valid_594426 != nil:
    section.add "X-Amz-Date", valid_594426
  var valid_594427 = header.getOrDefault("X-Amz-Security-Token")
  valid_594427 = validateParameter(valid_594427, JString, required = false,
                                 default = nil)
  if valid_594427 != nil:
    section.add "X-Amz-Security-Token", valid_594427
  var valid_594428 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594428 = validateParameter(valid_594428, JString, required = false,
                                 default = nil)
  if valid_594428 != nil:
    section.add "X-Amz-Content-Sha256", valid_594428
  var valid_594429 = header.getOrDefault("X-Amz-Algorithm")
  valid_594429 = validateParameter(valid_594429, JString, required = false,
                                 default = nil)
  if valid_594429 != nil:
    section.add "X-Amz-Algorithm", valid_594429
  var valid_594430 = header.getOrDefault("X-Amz-Signature")
  valid_594430 = validateParameter(valid_594430, JString, required = false,
                                 default = nil)
  if valid_594430 != nil:
    section.add "X-Amz-Signature", valid_594430
  var valid_594431 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594431 = validateParameter(valid_594431, JString, required = false,
                                 default = nil)
  if valid_594431 != nil:
    section.add "X-Amz-SignedHeaders", valid_594431
  var valid_594432 = header.getOrDefault("X-Amz-Credential")
  valid_594432 = validateParameter(valid_594432, JString, required = false,
                                 default = nil)
  if valid_594432 != nil:
    section.add "X-Amz-Credential", valid_594432
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594433: Call_DeleteBillingGroup_594421; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the billing group.
  ## 
  let valid = call_594433.validator(path, query, header, formData, body)
  let scheme = call_594433.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594433.url(scheme.get, call_594433.host, call_594433.base,
                         call_594433.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594433, url, valid)

proc call*(call_594434: Call_DeleteBillingGroup_594421; billingGroupName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteBillingGroup
  ## Deletes the billing group.
  ##   expectedVersion: int
  ##                  : The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_594435 = newJObject()
  var query_594436 = newJObject()
  add(query_594436, "expectedVersion", newJInt(expectedVersion))
  add(path_594435, "billingGroupName", newJString(billingGroupName))
  result = call_594434.call(path_594435, query_594436, nil, nil, nil)

var deleteBillingGroup* = Call_DeleteBillingGroup_594421(
    name: "deleteBillingGroup", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_DeleteBillingGroup_594422, base: "/",
    url: url_DeleteBillingGroup_594423, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateCertificateFromCsr_594469 = ref object of OpenApiRestCall_593437
proc url_CreateCertificateFromCsr_594471(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CreateCertificateFromCsr_594470(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_594472 = query.getOrDefault("setAsActive")
  valid_594472 = validateParameter(valid_594472, JBool, required = false, default = nil)
  if valid_594472 != nil:
    section.add "setAsActive", valid_594472
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594473 = header.getOrDefault("X-Amz-Date")
  valid_594473 = validateParameter(valid_594473, JString, required = false,
                                 default = nil)
  if valid_594473 != nil:
    section.add "X-Amz-Date", valid_594473
  var valid_594474 = header.getOrDefault("X-Amz-Security-Token")
  valid_594474 = validateParameter(valid_594474, JString, required = false,
                                 default = nil)
  if valid_594474 != nil:
    section.add "X-Amz-Security-Token", valid_594474
  var valid_594475 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594475 = validateParameter(valid_594475, JString, required = false,
                                 default = nil)
  if valid_594475 != nil:
    section.add "X-Amz-Content-Sha256", valid_594475
  var valid_594476 = header.getOrDefault("X-Amz-Algorithm")
  valid_594476 = validateParameter(valid_594476, JString, required = false,
                                 default = nil)
  if valid_594476 != nil:
    section.add "X-Amz-Algorithm", valid_594476
  var valid_594477 = header.getOrDefault("X-Amz-Signature")
  valid_594477 = validateParameter(valid_594477, JString, required = false,
                                 default = nil)
  if valid_594477 != nil:
    section.add "X-Amz-Signature", valid_594477
  var valid_594478 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594478 = validateParameter(valid_594478, JString, required = false,
                                 default = nil)
  if valid_594478 != nil:
    section.add "X-Amz-SignedHeaders", valid_594478
  var valid_594479 = header.getOrDefault("X-Amz-Credential")
  valid_594479 = validateParameter(valid_594479, JString, required = false,
                                 default = nil)
  if valid_594479 != nil:
    section.add "X-Amz-Credential", valid_594479
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594481: Call_CreateCertificateFromCsr_594469; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ## 
  let valid = call_594481.validator(path, query, header, formData, body)
  let scheme = call_594481.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594481.url(scheme.get, call_594481.host, call_594481.base,
                         call_594481.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594481, url, valid)

proc call*(call_594482: Call_CreateCertificateFromCsr_594469; body: JsonNode;
          setAsActive: bool = false): Recallable =
  ## createCertificateFromCsr
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  ##   body: JObject (required)
  var query_594483 = newJObject()
  var body_594484 = newJObject()
  add(query_594483, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_594484 = body
  result = call_594482.call(nil, query_594483, nil, nil, body_594484)

var createCertificateFromCsr* = Call_CreateCertificateFromCsr_594469(
    name: "createCertificateFromCsr", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/certificates",
    validator: validate_CreateCertificateFromCsr_594470, base: "/",
    url: url_CreateCertificateFromCsr_594471, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCertificates_594453 = ref object of OpenApiRestCall_593437
proc url_ListCertificates_594455(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListCertificates_594454(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  section = newJObject()
  var valid_594456 = query.getOrDefault("marker")
  valid_594456 = validateParameter(valid_594456, JString, required = false,
                                 default = nil)
  if valid_594456 != nil:
    section.add "marker", valid_594456
  var valid_594457 = query.getOrDefault("pageSize")
  valid_594457 = validateParameter(valid_594457, JInt, required = false, default = nil)
  if valid_594457 != nil:
    section.add "pageSize", valid_594457
  var valid_594458 = query.getOrDefault("isAscendingOrder")
  valid_594458 = validateParameter(valid_594458, JBool, required = false, default = nil)
  if valid_594458 != nil:
    section.add "isAscendingOrder", valid_594458
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594459 = header.getOrDefault("X-Amz-Date")
  valid_594459 = validateParameter(valid_594459, JString, required = false,
                                 default = nil)
  if valid_594459 != nil:
    section.add "X-Amz-Date", valid_594459
  var valid_594460 = header.getOrDefault("X-Amz-Security-Token")
  valid_594460 = validateParameter(valid_594460, JString, required = false,
                                 default = nil)
  if valid_594460 != nil:
    section.add "X-Amz-Security-Token", valid_594460
  var valid_594461 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594461 = validateParameter(valid_594461, JString, required = false,
                                 default = nil)
  if valid_594461 != nil:
    section.add "X-Amz-Content-Sha256", valid_594461
  var valid_594462 = header.getOrDefault("X-Amz-Algorithm")
  valid_594462 = validateParameter(valid_594462, JString, required = false,
                                 default = nil)
  if valid_594462 != nil:
    section.add "X-Amz-Algorithm", valid_594462
  var valid_594463 = header.getOrDefault("X-Amz-Signature")
  valid_594463 = validateParameter(valid_594463, JString, required = false,
                                 default = nil)
  if valid_594463 != nil:
    section.add "X-Amz-Signature", valid_594463
  var valid_594464 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594464 = validateParameter(valid_594464, JString, required = false,
                                 default = nil)
  if valid_594464 != nil:
    section.add "X-Amz-SignedHeaders", valid_594464
  var valid_594465 = header.getOrDefault("X-Amz-Credential")
  valid_594465 = validateParameter(valid_594465, JString, required = false,
                                 default = nil)
  if valid_594465 != nil:
    section.add "X-Amz-Credential", valid_594465
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594466: Call_ListCertificates_594453; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  let valid = call_594466.validator(path, query, header, formData, body)
  let scheme = call_594466.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594466.url(scheme.get, call_594466.host, call_594466.base,
                         call_594466.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594466, url, valid)

proc call*(call_594467: Call_ListCertificates_594453; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listCertificates
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  var query_594468 = newJObject()
  add(query_594468, "marker", newJString(marker))
  add(query_594468, "pageSize", newJInt(pageSize))
  add(query_594468, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_594467.call(nil, query_594468, nil, nil, nil)

var listCertificates* = Call_ListCertificates_594453(name: "listCertificates",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/certificates",
    validator: validate_ListCertificates_594454, base: "/",
    url: url_ListCertificates_594455, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateDynamicThingGroup_594485 = ref object of OpenApiRestCall_593437
proc url_CreateDynamicThingGroup_594487(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateDynamicThingGroup_594486(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The dynamic thing group name to create.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_594488 = path.getOrDefault("thingGroupName")
  valid_594488 = validateParameter(valid_594488, JString, required = true,
                                 default = nil)
  if valid_594488 != nil:
    section.add "thingGroupName", valid_594488
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594489 = header.getOrDefault("X-Amz-Date")
  valid_594489 = validateParameter(valid_594489, JString, required = false,
                                 default = nil)
  if valid_594489 != nil:
    section.add "X-Amz-Date", valid_594489
  var valid_594490 = header.getOrDefault("X-Amz-Security-Token")
  valid_594490 = validateParameter(valid_594490, JString, required = false,
                                 default = nil)
  if valid_594490 != nil:
    section.add "X-Amz-Security-Token", valid_594490
  var valid_594491 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594491 = validateParameter(valid_594491, JString, required = false,
                                 default = nil)
  if valid_594491 != nil:
    section.add "X-Amz-Content-Sha256", valid_594491
  var valid_594492 = header.getOrDefault("X-Amz-Algorithm")
  valid_594492 = validateParameter(valid_594492, JString, required = false,
                                 default = nil)
  if valid_594492 != nil:
    section.add "X-Amz-Algorithm", valid_594492
  var valid_594493 = header.getOrDefault("X-Amz-Signature")
  valid_594493 = validateParameter(valid_594493, JString, required = false,
                                 default = nil)
  if valid_594493 != nil:
    section.add "X-Amz-Signature", valid_594493
  var valid_594494 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594494 = validateParameter(valid_594494, JString, required = false,
                                 default = nil)
  if valid_594494 != nil:
    section.add "X-Amz-SignedHeaders", valid_594494
  var valid_594495 = header.getOrDefault("X-Amz-Credential")
  valid_594495 = validateParameter(valid_594495, JString, required = false,
                                 default = nil)
  if valid_594495 != nil:
    section.add "X-Amz-Credential", valid_594495
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594497: Call_CreateDynamicThingGroup_594485; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a dynamic thing group.
  ## 
  let valid = call_594497.validator(path, query, header, formData, body)
  let scheme = call_594497.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594497.url(scheme.get, call_594497.host, call_594497.base,
                         call_594497.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594497, url, valid)

proc call*(call_594498: Call_CreateDynamicThingGroup_594485; body: JsonNode;
          thingGroupName: string): Recallable =
  ## createDynamicThingGroup
  ## Creates a dynamic thing group.
  ##   body: JObject (required)
  ##   thingGroupName: string (required)
  ##                 : The dynamic thing group name to create.
  var path_594499 = newJObject()
  var body_594500 = newJObject()
  if body != nil:
    body_594500 = body
  add(path_594499, "thingGroupName", newJString(thingGroupName))
  result = call_594498.call(path_594499, nil, nil, nil, body_594500)

var createDynamicThingGroup* = Call_CreateDynamicThingGroup_594485(
    name: "createDynamicThingGroup", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_CreateDynamicThingGroup_594486, base: "/",
    url: url_CreateDynamicThingGroup_594487, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateDynamicThingGroup_594517 = ref object of OpenApiRestCall_593437
proc url_UpdateDynamicThingGroup_594519(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateDynamicThingGroup_594518(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the dynamic thing group to update.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_594520 = path.getOrDefault("thingGroupName")
  valid_594520 = validateParameter(valid_594520, JString, required = true,
                                 default = nil)
  if valid_594520 != nil:
    section.add "thingGroupName", valid_594520
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594521 = header.getOrDefault("X-Amz-Date")
  valid_594521 = validateParameter(valid_594521, JString, required = false,
                                 default = nil)
  if valid_594521 != nil:
    section.add "X-Amz-Date", valid_594521
  var valid_594522 = header.getOrDefault("X-Amz-Security-Token")
  valid_594522 = validateParameter(valid_594522, JString, required = false,
                                 default = nil)
  if valid_594522 != nil:
    section.add "X-Amz-Security-Token", valid_594522
  var valid_594523 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594523 = validateParameter(valid_594523, JString, required = false,
                                 default = nil)
  if valid_594523 != nil:
    section.add "X-Amz-Content-Sha256", valid_594523
  var valid_594524 = header.getOrDefault("X-Amz-Algorithm")
  valid_594524 = validateParameter(valid_594524, JString, required = false,
                                 default = nil)
  if valid_594524 != nil:
    section.add "X-Amz-Algorithm", valid_594524
  var valid_594525 = header.getOrDefault("X-Amz-Signature")
  valid_594525 = validateParameter(valid_594525, JString, required = false,
                                 default = nil)
  if valid_594525 != nil:
    section.add "X-Amz-Signature", valid_594525
  var valid_594526 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594526 = validateParameter(valid_594526, JString, required = false,
                                 default = nil)
  if valid_594526 != nil:
    section.add "X-Amz-SignedHeaders", valid_594526
  var valid_594527 = header.getOrDefault("X-Amz-Credential")
  valid_594527 = validateParameter(valid_594527, JString, required = false,
                                 default = nil)
  if valid_594527 != nil:
    section.add "X-Amz-Credential", valid_594527
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594529: Call_UpdateDynamicThingGroup_594517; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a dynamic thing group.
  ## 
  let valid = call_594529.validator(path, query, header, formData, body)
  let scheme = call_594529.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594529.url(scheme.get, call_594529.host, call_594529.base,
                         call_594529.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594529, url, valid)

proc call*(call_594530: Call_UpdateDynamicThingGroup_594517; body: JsonNode;
          thingGroupName: string): Recallable =
  ## updateDynamicThingGroup
  ## Updates a dynamic thing group.
  ##   body: JObject (required)
  ##   thingGroupName: string (required)
  ##                 : The name of the dynamic thing group to update.
  var path_594531 = newJObject()
  var body_594532 = newJObject()
  if body != nil:
    body_594532 = body
  add(path_594531, "thingGroupName", newJString(thingGroupName))
  result = call_594530.call(path_594531, nil, nil, nil, body_594532)

var updateDynamicThingGroup* = Call_UpdateDynamicThingGroup_594517(
    name: "updateDynamicThingGroup", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_UpdateDynamicThingGroup_594518, base: "/",
    url: url_UpdateDynamicThingGroup_594519, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteDynamicThingGroup_594501 = ref object of OpenApiRestCall_593437
proc url_DeleteDynamicThingGroup_594503(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteDynamicThingGroup_594502(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the dynamic thing group to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_594504 = path.getOrDefault("thingGroupName")
  valid_594504 = validateParameter(valid_594504, JString, required = true,
                                 default = nil)
  if valid_594504 != nil:
    section.add "thingGroupName", valid_594504
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the dynamic thing group to delete.
  section = newJObject()
  var valid_594505 = query.getOrDefault("expectedVersion")
  valid_594505 = validateParameter(valid_594505, JInt, required = false, default = nil)
  if valid_594505 != nil:
    section.add "expectedVersion", valid_594505
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594506 = header.getOrDefault("X-Amz-Date")
  valid_594506 = validateParameter(valid_594506, JString, required = false,
                                 default = nil)
  if valid_594506 != nil:
    section.add "X-Amz-Date", valid_594506
  var valid_594507 = header.getOrDefault("X-Amz-Security-Token")
  valid_594507 = validateParameter(valid_594507, JString, required = false,
                                 default = nil)
  if valid_594507 != nil:
    section.add "X-Amz-Security-Token", valid_594507
  var valid_594508 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594508 = validateParameter(valid_594508, JString, required = false,
                                 default = nil)
  if valid_594508 != nil:
    section.add "X-Amz-Content-Sha256", valid_594508
  var valid_594509 = header.getOrDefault("X-Amz-Algorithm")
  valid_594509 = validateParameter(valid_594509, JString, required = false,
                                 default = nil)
  if valid_594509 != nil:
    section.add "X-Amz-Algorithm", valid_594509
  var valid_594510 = header.getOrDefault("X-Amz-Signature")
  valid_594510 = validateParameter(valid_594510, JString, required = false,
                                 default = nil)
  if valid_594510 != nil:
    section.add "X-Amz-Signature", valid_594510
  var valid_594511 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594511 = validateParameter(valid_594511, JString, required = false,
                                 default = nil)
  if valid_594511 != nil:
    section.add "X-Amz-SignedHeaders", valid_594511
  var valid_594512 = header.getOrDefault("X-Amz-Credential")
  valid_594512 = validateParameter(valid_594512, JString, required = false,
                                 default = nil)
  if valid_594512 != nil:
    section.add "X-Amz-Credential", valid_594512
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594513: Call_DeleteDynamicThingGroup_594501; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a dynamic thing group.
  ## 
  let valid = call_594513.validator(path, query, header, formData, body)
  let scheme = call_594513.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594513.url(scheme.get, call_594513.host, call_594513.base,
                         call_594513.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594513, url, valid)

proc call*(call_594514: Call_DeleteDynamicThingGroup_594501;
          thingGroupName: string; expectedVersion: int = 0): Recallable =
  ## deleteDynamicThingGroup
  ## Deletes a dynamic thing group.
  ##   expectedVersion: int
  ##                  : The expected version of the dynamic thing group to delete.
  ##   thingGroupName: string (required)
  ##                 : The name of the dynamic thing group to delete.
  var path_594515 = newJObject()
  var query_594516 = newJObject()
  add(query_594516, "expectedVersion", newJInt(expectedVersion))
  add(path_594515, "thingGroupName", newJString(thingGroupName))
  result = call_594514.call(path_594515, query_594516, nil, nil, nil)

var deleteDynamicThingGroup* = Call_DeleteDynamicThingGroup_594501(
    name: "deleteDynamicThingGroup", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_DeleteDynamicThingGroup_594502, base: "/",
    url: url_DeleteDynamicThingGroup_594503, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateJob_594547 = ref object of OpenApiRestCall_593437
proc url_CreateJob_594549(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateJob_594548(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_594550 = path.getOrDefault("jobId")
  valid_594550 = validateParameter(valid_594550, JString, required = true,
                                 default = nil)
  if valid_594550 != nil:
    section.add "jobId", valid_594550
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594551 = header.getOrDefault("X-Amz-Date")
  valid_594551 = validateParameter(valid_594551, JString, required = false,
                                 default = nil)
  if valid_594551 != nil:
    section.add "X-Amz-Date", valid_594551
  var valid_594552 = header.getOrDefault("X-Amz-Security-Token")
  valid_594552 = validateParameter(valid_594552, JString, required = false,
                                 default = nil)
  if valid_594552 != nil:
    section.add "X-Amz-Security-Token", valid_594552
  var valid_594553 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594553 = validateParameter(valid_594553, JString, required = false,
                                 default = nil)
  if valid_594553 != nil:
    section.add "X-Amz-Content-Sha256", valid_594553
  var valid_594554 = header.getOrDefault("X-Amz-Algorithm")
  valid_594554 = validateParameter(valid_594554, JString, required = false,
                                 default = nil)
  if valid_594554 != nil:
    section.add "X-Amz-Algorithm", valid_594554
  var valid_594555 = header.getOrDefault("X-Amz-Signature")
  valid_594555 = validateParameter(valid_594555, JString, required = false,
                                 default = nil)
  if valid_594555 != nil:
    section.add "X-Amz-Signature", valid_594555
  var valid_594556 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594556 = validateParameter(valid_594556, JString, required = false,
                                 default = nil)
  if valid_594556 != nil:
    section.add "X-Amz-SignedHeaders", valid_594556
  var valid_594557 = header.getOrDefault("X-Amz-Credential")
  valid_594557 = validateParameter(valid_594557, JString, required = false,
                                 default = nil)
  if valid_594557 != nil:
    section.add "X-Amz-Credential", valid_594557
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594559: Call_CreateJob_594547; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a job.
  ## 
  let valid = call_594559.validator(path, query, header, formData, body)
  let scheme = call_594559.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594559.url(scheme.get, call_594559.host, call_594559.base,
                         call_594559.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594559, url, valid)

proc call*(call_594560: Call_CreateJob_594547; jobId: string; body: JsonNode): Recallable =
  ## createJob
  ## Creates a job.
  ##   jobId: string (required)
  ##        : A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
  ##   body: JObject (required)
  var path_594561 = newJObject()
  var body_594562 = newJObject()
  add(path_594561, "jobId", newJString(jobId))
  if body != nil:
    body_594562 = body
  result = call_594560.call(path_594561, nil, nil, nil, body_594562)

var createJob* = Call_CreateJob_594547(name: "createJob", meth: HttpMethod.HttpPut,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_CreateJob_594548,
                                    base: "/", url: url_CreateJob_594549,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeJob_594533 = ref object of OpenApiRestCall_593437
proc url_DescribeJob_594535(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeJob_594534(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_594536 = path.getOrDefault("jobId")
  valid_594536 = validateParameter(valid_594536, JString, required = true,
                                 default = nil)
  if valid_594536 != nil:
    section.add "jobId", valid_594536
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594537 = header.getOrDefault("X-Amz-Date")
  valid_594537 = validateParameter(valid_594537, JString, required = false,
                                 default = nil)
  if valid_594537 != nil:
    section.add "X-Amz-Date", valid_594537
  var valid_594538 = header.getOrDefault("X-Amz-Security-Token")
  valid_594538 = validateParameter(valid_594538, JString, required = false,
                                 default = nil)
  if valid_594538 != nil:
    section.add "X-Amz-Security-Token", valid_594538
  var valid_594539 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594539 = validateParameter(valid_594539, JString, required = false,
                                 default = nil)
  if valid_594539 != nil:
    section.add "X-Amz-Content-Sha256", valid_594539
  var valid_594540 = header.getOrDefault("X-Amz-Algorithm")
  valid_594540 = validateParameter(valid_594540, JString, required = false,
                                 default = nil)
  if valid_594540 != nil:
    section.add "X-Amz-Algorithm", valid_594540
  var valid_594541 = header.getOrDefault("X-Amz-Signature")
  valid_594541 = validateParameter(valid_594541, JString, required = false,
                                 default = nil)
  if valid_594541 != nil:
    section.add "X-Amz-Signature", valid_594541
  var valid_594542 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594542 = validateParameter(valid_594542, JString, required = false,
                                 default = nil)
  if valid_594542 != nil:
    section.add "X-Amz-SignedHeaders", valid_594542
  var valid_594543 = header.getOrDefault("X-Amz-Credential")
  valid_594543 = validateParameter(valid_594543, JString, required = false,
                                 default = nil)
  if valid_594543 != nil:
    section.add "X-Amz-Credential", valid_594543
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594544: Call_DescribeJob_594533; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a job.
  ## 
  let valid = call_594544.validator(path, query, header, formData, body)
  let scheme = call_594544.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594544.url(scheme.get, call_594544.host, call_594544.base,
                         call_594544.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594544, url, valid)

proc call*(call_594545: Call_DescribeJob_594533; jobId: string): Recallable =
  ## describeJob
  ## Describes a job.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  var path_594546 = newJObject()
  add(path_594546, "jobId", newJString(jobId))
  result = call_594545.call(path_594546, nil, nil, nil, nil)

var describeJob* = Call_DescribeJob_594533(name: "describeJob",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/jobs/{jobId}",
                                        validator: validate_DescribeJob_594534,
                                        base: "/", url: url_DescribeJob_594535,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateJob_594579 = ref object of OpenApiRestCall_593437
proc url_UpdateJob_594581(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateJob_594580(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates supported fields of the specified job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The ID of the job to be updated.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_594582 = path.getOrDefault("jobId")
  valid_594582 = validateParameter(valid_594582, JString, required = true,
                                 default = nil)
  if valid_594582 != nil:
    section.add "jobId", valid_594582
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594583 = header.getOrDefault("X-Amz-Date")
  valid_594583 = validateParameter(valid_594583, JString, required = false,
                                 default = nil)
  if valid_594583 != nil:
    section.add "X-Amz-Date", valid_594583
  var valid_594584 = header.getOrDefault("X-Amz-Security-Token")
  valid_594584 = validateParameter(valid_594584, JString, required = false,
                                 default = nil)
  if valid_594584 != nil:
    section.add "X-Amz-Security-Token", valid_594584
  var valid_594585 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594585 = validateParameter(valid_594585, JString, required = false,
                                 default = nil)
  if valid_594585 != nil:
    section.add "X-Amz-Content-Sha256", valid_594585
  var valid_594586 = header.getOrDefault("X-Amz-Algorithm")
  valid_594586 = validateParameter(valid_594586, JString, required = false,
                                 default = nil)
  if valid_594586 != nil:
    section.add "X-Amz-Algorithm", valid_594586
  var valid_594587 = header.getOrDefault("X-Amz-Signature")
  valid_594587 = validateParameter(valid_594587, JString, required = false,
                                 default = nil)
  if valid_594587 != nil:
    section.add "X-Amz-Signature", valid_594587
  var valid_594588 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594588 = validateParameter(valid_594588, JString, required = false,
                                 default = nil)
  if valid_594588 != nil:
    section.add "X-Amz-SignedHeaders", valid_594588
  var valid_594589 = header.getOrDefault("X-Amz-Credential")
  valid_594589 = validateParameter(valid_594589, JString, required = false,
                                 default = nil)
  if valid_594589 != nil:
    section.add "X-Amz-Credential", valid_594589
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594591: Call_UpdateJob_594579; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates supported fields of the specified job.
  ## 
  let valid = call_594591.validator(path, query, header, formData, body)
  let scheme = call_594591.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594591.url(scheme.get, call_594591.host, call_594591.base,
                         call_594591.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594591, url, valid)

proc call*(call_594592: Call_UpdateJob_594579; jobId: string; body: JsonNode): Recallable =
  ## updateJob
  ## Updates supported fields of the specified job.
  ##   jobId: string (required)
  ##        : The ID of the job to be updated.
  ##   body: JObject (required)
  var path_594593 = newJObject()
  var body_594594 = newJObject()
  add(path_594593, "jobId", newJString(jobId))
  if body != nil:
    body_594594 = body
  result = call_594592.call(path_594593, nil, nil, nil, body_594594)

var updateJob* = Call_UpdateJob_594579(name: "updateJob", meth: HttpMethod.HttpPatch,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_UpdateJob_594580,
                                    base: "/", url: url_UpdateJob_594581,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteJob_594563 = ref object of OpenApiRestCall_593437
proc url_DeleteJob_594565(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteJob_594564(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_594566 = path.getOrDefault("jobId")
  valid_594566 = validateParameter(valid_594566, JString, required = true,
                                 default = nil)
  if valid_594566 != nil:
    section.add "jobId", valid_594566
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
  section = newJObject()
  var valid_594567 = query.getOrDefault("force")
  valid_594567 = validateParameter(valid_594567, JBool, required = false, default = nil)
  if valid_594567 != nil:
    section.add "force", valid_594567
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594568 = header.getOrDefault("X-Amz-Date")
  valid_594568 = validateParameter(valid_594568, JString, required = false,
                                 default = nil)
  if valid_594568 != nil:
    section.add "X-Amz-Date", valid_594568
  var valid_594569 = header.getOrDefault("X-Amz-Security-Token")
  valid_594569 = validateParameter(valid_594569, JString, required = false,
                                 default = nil)
  if valid_594569 != nil:
    section.add "X-Amz-Security-Token", valid_594569
  var valid_594570 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594570 = validateParameter(valid_594570, JString, required = false,
                                 default = nil)
  if valid_594570 != nil:
    section.add "X-Amz-Content-Sha256", valid_594570
  var valid_594571 = header.getOrDefault("X-Amz-Algorithm")
  valid_594571 = validateParameter(valid_594571, JString, required = false,
                                 default = nil)
  if valid_594571 != nil:
    section.add "X-Amz-Algorithm", valid_594571
  var valid_594572 = header.getOrDefault("X-Amz-Signature")
  valid_594572 = validateParameter(valid_594572, JString, required = false,
                                 default = nil)
  if valid_594572 != nil:
    section.add "X-Amz-Signature", valid_594572
  var valid_594573 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594573 = validateParameter(valid_594573, JString, required = false,
                                 default = nil)
  if valid_594573 != nil:
    section.add "X-Amz-SignedHeaders", valid_594573
  var valid_594574 = header.getOrDefault("X-Amz-Credential")
  valid_594574 = validateParameter(valid_594574, JString, required = false,
                                 default = nil)
  if valid_594574 != nil:
    section.add "X-Amz-Credential", valid_594574
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594575: Call_DeleteJob_594563; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ## 
  let valid = call_594575.validator(path, query, header, formData, body)
  let scheme = call_594575.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594575.url(scheme.get, call_594575.host, call_594575.base,
                         call_594575.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594575, url, valid)

proc call*(call_594576: Call_DeleteJob_594563; jobId: string; force: bool = false): Recallable =
  ## deleteJob
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ##   force: bool
  ##        : <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
  ##   jobId: string (required)
  ##        : <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
  var path_594577 = newJObject()
  var query_594578 = newJObject()
  add(query_594578, "force", newJBool(force))
  add(path_594577, "jobId", newJString(jobId))
  result = call_594576.call(path_594577, query_594578, nil, nil, nil)

var deleteJob* = Call_DeleteJob_594563(name: "deleteJob",
                                    meth: HttpMethod.HttpDelete,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_DeleteJob_594564,
                                    base: "/", url: url_DeleteJob_594565,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateKeysAndCertificate_594595 = ref object of OpenApiRestCall_593437
proc url_CreateKeysAndCertificate_594597(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CreateKeysAndCertificate_594596(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_594598 = query.getOrDefault("setAsActive")
  valid_594598 = validateParameter(valid_594598, JBool, required = false, default = nil)
  if valid_594598 != nil:
    section.add "setAsActive", valid_594598
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594599 = header.getOrDefault("X-Amz-Date")
  valid_594599 = validateParameter(valid_594599, JString, required = false,
                                 default = nil)
  if valid_594599 != nil:
    section.add "X-Amz-Date", valid_594599
  var valid_594600 = header.getOrDefault("X-Amz-Security-Token")
  valid_594600 = validateParameter(valid_594600, JString, required = false,
                                 default = nil)
  if valid_594600 != nil:
    section.add "X-Amz-Security-Token", valid_594600
  var valid_594601 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594601 = validateParameter(valid_594601, JString, required = false,
                                 default = nil)
  if valid_594601 != nil:
    section.add "X-Amz-Content-Sha256", valid_594601
  var valid_594602 = header.getOrDefault("X-Amz-Algorithm")
  valid_594602 = validateParameter(valid_594602, JString, required = false,
                                 default = nil)
  if valid_594602 != nil:
    section.add "X-Amz-Algorithm", valid_594602
  var valid_594603 = header.getOrDefault("X-Amz-Signature")
  valid_594603 = validateParameter(valid_594603, JString, required = false,
                                 default = nil)
  if valid_594603 != nil:
    section.add "X-Amz-Signature", valid_594603
  var valid_594604 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594604 = validateParameter(valid_594604, JString, required = false,
                                 default = nil)
  if valid_594604 != nil:
    section.add "X-Amz-SignedHeaders", valid_594604
  var valid_594605 = header.getOrDefault("X-Amz-Credential")
  valid_594605 = validateParameter(valid_594605, JString, required = false,
                                 default = nil)
  if valid_594605 != nil:
    section.add "X-Amz-Credential", valid_594605
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594606: Call_CreateKeysAndCertificate_594595; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ## 
  let valid = call_594606.validator(path, query, header, formData, body)
  let scheme = call_594606.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594606.url(scheme.get, call_594606.host, call_594606.base,
                         call_594606.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594606, url, valid)

proc call*(call_594607: Call_CreateKeysAndCertificate_594595;
          setAsActive: bool = false): Recallable =
  ## createKeysAndCertificate
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  var query_594608 = newJObject()
  add(query_594608, "setAsActive", newJBool(setAsActive))
  result = call_594607.call(nil, query_594608, nil, nil, nil)

var createKeysAndCertificate* = Call_CreateKeysAndCertificate_594595(
    name: "createKeysAndCertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/keys-and-certificate",
    validator: validate_CreateKeysAndCertificate_594596, base: "/",
    url: url_CreateKeysAndCertificate_594597, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateMitigationAction_594623 = ref object of OpenApiRestCall_593437
proc url_CreateMitigationAction_594625(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateMitigationAction_594624(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_594626 = path.getOrDefault("actionName")
  valid_594626 = validateParameter(valid_594626, JString, required = true,
                                 default = nil)
  if valid_594626 != nil:
    section.add "actionName", valid_594626
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594627 = header.getOrDefault("X-Amz-Date")
  valid_594627 = validateParameter(valid_594627, JString, required = false,
                                 default = nil)
  if valid_594627 != nil:
    section.add "X-Amz-Date", valid_594627
  var valid_594628 = header.getOrDefault("X-Amz-Security-Token")
  valid_594628 = validateParameter(valid_594628, JString, required = false,
                                 default = nil)
  if valid_594628 != nil:
    section.add "X-Amz-Security-Token", valid_594628
  var valid_594629 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594629 = validateParameter(valid_594629, JString, required = false,
                                 default = nil)
  if valid_594629 != nil:
    section.add "X-Amz-Content-Sha256", valid_594629
  var valid_594630 = header.getOrDefault("X-Amz-Algorithm")
  valid_594630 = validateParameter(valid_594630, JString, required = false,
                                 default = nil)
  if valid_594630 != nil:
    section.add "X-Amz-Algorithm", valid_594630
  var valid_594631 = header.getOrDefault("X-Amz-Signature")
  valid_594631 = validateParameter(valid_594631, JString, required = false,
                                 default = nil)
  if valid_594631 != nil:
    section.add "X-Amz-Signature", valid_594631
  var valid_594632 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594632 = validateParameter(valid_594632, JString, required = false,
                                 default = nil)
  if valid_594632 != nil:
    section.add "X-Amz-SignedHeaders", valid_594632
  var valid_594633 = header.getOrDefault("X-Amz-Credential")
  valid_594633 = validateParameter(valid_594633, JString, required = false,
                                 default = nil)
  if valid_594633 != nil:
    section.add "X-Amz-Credential", valid_594633
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594635: Call_CreateMitigationAction_594623; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ## 
  let valid = call_594635.validator(path, query, header, formData, body)
  let scheme = call_594635.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594635.url(scheme.get, call_594635.host, call_594635.base,
                         call_594635.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594635, url, valid)

proc call*(call_594636: Call_CreateMitigationAction_594623; actionName: string;
          body: JsonNode): Recallable =
  ## createMitigationAction
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ##   actionName: string (required)
  ##             : A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).
  ##   body: JObject (required)
  var path_594637 = newJObject()
  var body_594638 = newJObject()
  add(path_594637, "actionName", newJString(actionName))
  if body != nil:
    body_594638 = body
  result = call_594636.call(path_594637, nil, nil, nil, body_594638)

var createMitigationAction* = Call_CreateMitigationAction_594623(
    name: "createMitigationAction", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_CreateMitigationAction_594624, base: "/",
    url: url_CreateMitigationAction_594625, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeMitigationAction_594609 = ref object of OpenApiRestCall_593437
proc url_DescribeMitigationAction_594611(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeMitigationAction_594610(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a mitigation action.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The friendly name that uniquely identifies the mitigation action.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_594612 = path.getOrDefault("actionName")
  valid_594612 = validateParameter(valid_594612, JString, required = true,
                                 default = nil)
  if valid_594612 != nil:
    section.add "actionName", valid_594612
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594613 = header.getOrDefault("X-Amz-Date")
  valid_594613 = validateParameter(valid_594613, JString, required = false,
                                 default = nil)
  if valid_594613 != nil:
    section.add "X-Amz-Date", valid_594613
  var valid_594614 = header.getOrDefault("X-Amz-Security-Token")
  valid_594614 = validateParameter(valid_594614, JString, required = false,
                                 default = nil)
  if valid_594614 != nil:
    section.add "X-Amz-Security-Token", valid_594614
  var valid_594615 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594615 = validateParameter(valid_594615, JString, required = false,
                                 default = nil)
  if valid_594615 != nil:
    section.add "X-Amz-Content-Sha256", valid_594615
  var valid_594616 = header.getOrDefault("X-Amz-Algorithm")
  valid_594616 = validateParameter(valid_594616, JString, required = false,
                                 default = nil)
  if valid_594616 != nil:
    section.add "X-Amz-Algorithm", valid_594616
  var valid_594617 = header.getOrDefault("X-Amz-Signature")
  valid_594617 = validateParameter(valid_594617, JString, required = false,
                                 default = nil)
  if valid_594617 != nil:
    section.add "X-Amz-Signature", valid_594617
  var valid_594618 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594618 = validateParameter(valid_594618, JString, required = false,
                                 default = nil)
  if valid_594618 != nil:
    section.add "X-Amz-SignedHeaders", valid_594618
  var valid_594619 = header.getOrDefault("X-Amz-Credential")
  valid_594619 = validateParameter(valid_594619, JString, required = false,
                                 default = nil)
  if valid_594619 != nil:
    section.add "X-Amz-Credential", valid_594619
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594620: Call_DescribeMitigationAction_594609; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a mitigation action.
  ## 
  let valid = call_594620.validator(path, query, header, formData, body)
  let scheme = call_594620.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594620.url(scheme.get, call_594620.host, call_594620.base,
                         call_594620.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594620, url, valid)

proc call*(call_594621: Call_DescribeMitigationAction_594609; actionName: string): Recallable =
  ## describeMitigationAction
  ## Gets information about a mitigation action.
  ##   actionName: string (required)
  ##             : The friendly name that uniquely identifies the mitigation action.
  var path_594622 = newJObject()
  add(path_594622, "actionName", newJString(actionName))
  result = call_594621.call(path_594622, nil, nil, nil, nil)

var describeMitigationAction* = Call_DescribeMitigationAction_594609(
    name: "describeMitigationAction", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_DescribeMitigationAction_594610, base: "/",
    url: url_DescribeMitigationAction_594611, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateMitigationAction_594653 = ref object of OpenApiRestCall_593437
proc url_UpdateMitigationAction_594655(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateMitigationAction_594654(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the definition for the specified mitigation action.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_594656 = path.getOrDefault("actionName")
  valid_594656 = validateParameter(valid_594656, JString, required = true,
                                 default = nil)
  if valid_594656 != nil:
    section.add "actionName", valid_594656
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594657 = header.getOrDefault("X-Amz-Date")
  valid_594657 = validateParameter(valid_594657, JString, required = false,
                                 default = nil)
  if valid_594657 != nil:
    section.add "X-Amz-Date", valid_594657
  var valid_594658 = header.getOrDefault("X-Amz-Security-Token")
  valid_594658 = validateParameter(valid_594658, JString, required = false,
                                 default = nil)
  if valid_594658 != nil:
    section.add "X-Amz-Security-Token", valid_594658
  var valid_594659 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594659 = validateParameter(valid_594659, JString, required = false,
                                 default = nil)
  if valid_594659 != nil:
    section.add "X-Amz-Content-Sha256", valid_594659
  var valid_594660 = header.getOrDefault("X-Amz-Algorithm")
  valid_594660 = validateParameter(valid_594660, JString, required = false,
                                 default = nil)
  if valid_594660 != nil:
    section.add "X-Amz-Algorithm", valid_594660
  var valid_594661 = header.getOrDefault("X-Amz-Signature")
  valid_594661 = validateParameter(valid_594661, JString, required = false,
                                 default = nil)
  if valid_594661 != nil:
    section.add "X-Amz-Signature", valid_594661
  var valid_594662 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594662 = validateParameter(valid_594662, JString, required = false,
                                 default = nil)
  if valid_594662 != nil:
    section.add "X-Amz-SignedHeaders", valid_594662
  var valid_594663 = header.getOrDefault("X-Amz-Credential")
  valid_594663 = validateParameter(valid_594663, JString, required = false,
                                 default = nil)
  if valid_594663 != nil:
    section.add "X-Amz-Credential", valid_594663
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594665: Call_UpdateMitigationAction_594653; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the definition for the specified mitigation action.
  ## 
  let valid = call_594665.validator(path, query, header, formData, body)
  let scheme = call_594665.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594665.url(scheme.get, call_594665.host, call_594665.base,
                         call_594665.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594665, url, valid)

proc call*(call_594666: Call_UpdateMitigationAction_594653; actionName: string;
          body: JsonNode): Recallable =
  ## updateMitigationAction
  ## Updates the definition for the specified mitigation action.
  ##   actionName: string (required)
  ##             : The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.
  ##   body: JObject (required)
  var path_594667 = newJObject()
  var body_594668 = newJObject()
  add(path_594667, "actionName", newJString(actionName))
  if body != nil:
    body_594668 = body
  result = call_594666.call(path_594667, nil, nil, nil, body_594668)

var updateMitigationAction* = Call_UpdateMitigationAction_594653(
    name: "updateMitigationAction", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_UpdateMitigationAction_594654, base: "/",
    url: url_UpdateMitigationAction_594655, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteMitigationAction_594639 = ref object of OpenApiRestCall_593437
proc url_DeleteMitigationAction_594641(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteMitigationAction_594640(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a defined mitigation action from your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The name of the mitigation action that you want to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_594642 = path.getOrDefault("actionName")
  valid_594642 = validateParameter(valid_594642, JString, required = true,
                                 default = nil)
  if valid_594642 != nil:
    section.add "actionName", valid_594642
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594643 = header.getOrDefault("X-Amz-Date")
  valid_594643 = validateParameter(valid_594643, JString, required = false,
                                 default = nil)
  if valid_594643 != nil:
    section.add "X-Amz-Date", valid_594643
  var valid_594644 = header.getOrDefault("X-Amz-Security-Token")
  valid_594644 = validateParameter(valid_594644, JString, required = false,
                                 default = nil)
  if valid_594644 != nil:
    section.add "X-Amz-Security-Token", valid_594644
  var valid_594645 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594645 = validateParameter(valid_594645, JString, required = false,
                                 default = nil)
  if valid_594645 != nil:
    section.add "X-Amz-Content-Sha256", valid_594645
  var valid_594646 = header.getOrDefault("X-Amz-Algorithm")
  valid_594646 = validateParameter(valid_594646, JString, required = false,
                                 default = nil)
  if valid_594646 != nil:
    section.add "X-Amz-Algorithm", valid_594646
  var valid_594647 = header.getOrDefault("X-Amz-Signature")
  valid_594647 = validateParameter(valid_594647, JString, required = false,
                                 default = nil)
  if valid_594647 != nil:
    section.add "X-Amz-Signature", valid_594647
  var valid_594648 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594648 = validateParameter(valid_594648, JString, required = false,
                                 default = nil)
  if valid_594648 != nil:
    section.add "X-Amz-SignedHeaders", valid_594648
  var valid_594649 = header.getOrDefault("X-Amz-Credential")
  valid_594649 = validateParameter(valid_594649, JString, required = false,
                                 default = nil)
  if valid_594649 != nil:
    section.add "X-Amz-Credential", valid_594649
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594650: Call_DeleteMitigationAction_594639; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a defined mitigation action from your AWS account.
  ## 
  let valid = call_594650.validator(path, query, header, formData, body)
  let scheme = call_594650.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594650.url(scheme.get, call_594650.host, call_594650.base,
                         call_594650.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594650, url, valid)

proc call*(call_594651: Call_DeleteMitigationAction_594639; actionName: string): Recallable =
  ## deleteMitigationAction
  ## Deletes a defined mitigation action from your AWS account.
  ##   actionName: string (required)
  ##             : The name of the mitigation action that you want to delete.
  var path_594652 = newJObject()
  add(path_594652, "actionName", newJString(actionName))
  result = call_594651.call(path_594652, nil, nil, nil, nil)

var deleteMitigationAction* = Call_DeleteMitigationAction_594639(
    name: "deleteMitigationAction", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_DeleteMitigationAction_594640, base: "/",
    url: url_DeleteMitigationAction_594641, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateOTAUpdate_594683 = ref object of OpenApiRestCall_593437
proc url_CreateOTAUpdate_594685(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateOTAUpdate_594684(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The ID of the OTA update to be created.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_594686 = path.getOrDefault("otaUpdateId")
  valid_594686 = validateParameter(valid_594686, JString, required = true,
                                 default = nil)
  if valid_594686 != nil:
    section.add "otaUpdateId", valid_594686
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594687 = header.getOrDefault("X-Amz-Date")
  valid_594687 = validateParameter(valid_594687, JString, required = false,
                                 default = nil)
  if valid_594687 != nil:
    section.add "X-Amz-Date", valid_594687
  var valid_594688 = header.getOrDefault("X-Amz-Security-Token")
  valid_594688 = validateParameter(valid_594688, JString, required = false,
                                 default = nil)
  if valid_594688 != nil:
    section.add "X-Amz-Security-Token", valid_594688
  var valid_594689 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594689 = validateParameter(valid_594689, JString, required = false,
                                 default = nil)
  if valid_594689 != nil:
    section.add "X-Amz-Content-Sha256", valid_594689
  var valid_594690 = header.getOrDefault("X-Amz-Algorithm")
  valid_594690 = validateParameter(valid_594690, JString, required = false,
                                 default = nil)
  if valid_594690 != nil:
    section.add "X-Amz-Algorithm", valid_594690
  var valid_594691 = header.getOrDefault("X-Amz-Signature")
  valid_594691 = validateParameter(valid_594691, JString, required = false,
                                 default = nil)
  if valid_594691 != nil:
    section.add "X-Amz-Signature", valid_594691
  var valid_594692 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594692 = validateParameter(valid_594692, JString, required = false,
                                 default = nil)
  if valid_594692 != nil:
    section.add "X-Amz-SignedHeaders", valid_594692
  var valid_594693 = header.getOrDefault("X-Amz-Credential")
  valid_594693 = validateParameter(valid_594693, JString, required = false,
                                 default = nil)
  if valid_594693 != nil:
    section.add "X-Amz-Credential", valid_594693
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594695: Call_CreateOTAUpdate_594683; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ## 
  let valid = call_594695.validator(path, query, header, formData, body)
  let scheme = call_594695.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594695.url(scheme.get, call_594695.host, call_594695.base,
                         call_594695.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594695, url, valid)

proc call*(call_594696: Call_CreateOTAUpdate_594683; otaUpdateId: string;
          body: JsonNode): Recallable =
  ## createOTAUpdate
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ##   otaUpdateId: string (required)
  ##              : The ID of the OTA update to be created.
  ##   body: JObject (required)
  var path_594697 = newJObject()
  var body_594698 = newJObject()
  add(path_594697, "otaUpdateId", newJString(otaUpdateId))
  if body != nil:
    body_594698 = body
  result = call_594696.call(path_594697, nil, nil, nil, body_594698)

var createOTAUpdate* = Call_CreateOTAUpdate_594683(name: "createOTAUpdate",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_CreateOTAUpdate_594684,
    base: "/", url: url_CreateOTAUpdate_594685, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetOTAUpdate_594669 = ref object of OpenApiRestCall_593437
proc url_GetOTAUpdate_594671(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetOTAUpdate_594670(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets an OTA update.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The OTA update ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_594672 = path.getOrDefault("otaUpdateId")
  valid_594672 = validateParameter(valid_594672, JString, required = true,
                                 default = nil)
  if valid_594672 != nil:
    section.add "otaUpdateId", valid_594672
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594673 = header.getOrDefault("X-Amz-Date")
  valid_594673 = validateParameter(valid_594673, JString, required = false,
                                 default = nil)
  if valid_594673 != nil:
    section.add "X-Amz-Date", valid_594673
  var valid_594674 = header.getOrDefault("X-Amz-Security-Token")
  valid_594674 = validateParameter(valid_594674, JString, required = false,
                                 default = nil)
  if valid_594674 != nil:
    section.add "X-Amz-Security-Token", valid_594674
  var valid_594675 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594675 = validateParameter(valid_594675, JString, required = false,
                                 default = nil)
  if valid_594675 != nil:
    section.add "X-Amz-Content-Sha256", valid_594675
  var valid_594676 = header.getOrDefault("X-Amz-Algorithm")
  valid_594676 = validateParameter(valid_594676, JString, required = false,
                                 default = nil)
  if valid_594676 != nil:
    section.add "X-Amz-Algorithm", valid_594676
  var valid_594677 = header.getOrDefault("X-Amz-Signature")
  valid_594677 = validateParameter(valid_594677, JString, required = false,
                                 default = nil)
  if valid_594677 != nil:
    section.add "X-Amz-Signature", valid_594677
  var valid_594678 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594678 = validateParameter(valid_594678, JString, required = false,
                                 default = nil)
  if valid_594678 != nil:
    section.add "X-Amz-SignedHeaders", valid_594678
  var valid_594679 = header.getOrDefault("X-Amz-Credential")
  valid_594679 = validateParameter(valid_594679, JString, required = false,
                                 default = nil)
  if valid_594679 != nil:
    section.add "X-Amz-Credential", valid_594679
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594680: Call_GetOTAUpdate_594669; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets an OTA update.
  ## 
  let valid = call_594680.validator(path, query, header, formData, body)
  let scheme = call_594680.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594680.url(scheme.get, call_594680.host, call_594680.base,
                         call_594680.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594680, url, valid)

proc call*(call_594681: Call_GetOTAUpdate_594669; otaUpdateId: string): Recallable =
  ## getOTAUpdate
  ## Gets an OTA update.
  ##   otaUpdateId: string (required)
  ##              : The OTA update ID.
  var path_594682 = newJObject()
  add(path_594682, "otaUpdateId", newJString(otaUpdateId))
  result = call_594681.call(path_594682, nil, nil, nil, nil)

var getOTAUpdate* = Call_GetOTAUpdate_594669(name: "getOTAUpdate",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_GetOTAUpdate_594670,
    base: "/", url: url_GetOTAUpdate_594671, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteOTAUpdate_594699 = ref object of OpenApiRestCall_593437
proc url_DeleteOTAUpdate_594701(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteOTAUpdate_594700(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Delete an OTA update.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The OTA update ID to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_594702 = path.getOrDefault("otaUpdateId")
  valid_594702 = validateParameter(valid_594702, JString, required = true,
                                 default = nil)
  if valid_594702 != nil:
    section.add "otaUpdateId", valid_594702
  result.add "path", section
  ## parameters in `query` object:
  ##   deleteStream: JBool
  ##               : Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.
  ##   forceDeleteAWSJob: JBool
  ##                    : Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.
  section = newJObject()
  var valid_594703 = query.getOrDefault("deleteStream")
  valid_594703 = validateParameter(valid_594703, JBool, required = false, default = nil)
  if valid_594703 != nil:
    section.add "deleteStream", valid_594703
  var valid_594704 = query.getOrDefault("forceDeleteAWSJob")
  valid_594704 = validateParameter(valid_594704, JBool, required = false, default = nil)
  if valid_594704 != nil:
    section.add "forceDeleteAWSJob", valid_594704
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594705 = header.getOrDefault("X-Amz-Date")
  valid_594705 = validateParameter(valid_594705, JString, required = false,
                                 default = nil)
  if valid_594705 != nil:
    section.add "X-Amz-Date", valid_594705
  var valid_594706 = header.getOrDefault("X-Amz-Security-Token")
  valid_594706 = validateParameter(valid_594706, JString, required = false,
                                 default = nil)
  if valid_594706 != nil:
    section.add "X-Amz-Security-Token", valid_594706
  var valid_594707 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594707 = validateParameter(valid_594707, JString, required = false,
                                 default = nil)
  if valid_594707 != nil:
    section.add "X-Amz-Content-Sha256", valid_594707
  var valid_594708 = header.getOrDefault("X-Amz-Algorithm")
  valid_594708 = validateParameter(valid_594708, JString, required = false,
                                 default = nil)
  if valid_594708 != nil:
    section.add "X-Amz-Algorithm", valid_594708
  var valid_594709 = header.getOrDefault("X-Amz-Signature")
  valid_594709 = validateParameter(valid_594709, JString, required = false,
                                 default = nil)
  if valid_594709 != nil:
    section.add "X-Amz-Signature", valid_594709
  var valid_594710 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594710 = validateParameter(valid_594710, JString, required = false,
                                 default = nil)
  if valid_594710 != nil:
    section.add "X-Amz-SignedHeaders", valid_594710
  var valid_594711 = header.getOrDefault("X-Amz-Credential")
  valid_594711 = validateParameter(valid_594711, JString, required = false,
                                 default = nil)
  if valid_594711 != nil:
    section.add "X-Amz-Credential", valid_594711
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594712: Call_DeleteOTAUpdate_594699; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete an OTA update.
  ## 
  let valid = call_594712.validator(path, query, header, formData, body)
  let scheme = call_594712.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594712.url(scheme.get, call_594712.host, call_594712.base,
                         call_594712.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594712, url, valid)

proc call*(call_594713: Call_DeleteOTAUpdate_594699; otaUpdateId: string;
          deleteStream: bool = false; forceDeleteAWSJob: bool = false): Recallable =
  ## deleteOTAUpdate
  ## Delete an OTA update.
  ##   deleteStream: bool
  ##               : Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.
  ##   otaUpdateId: string (required)
  ##              : The OTA update ID to delete.
  ##   forceDeleteAWSJob: bool
  ##                    : Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.
  var path_594714 = newJObject()
  var query_594715 = newJObject()
  add(query_594715, "deleteStream", newJBool(deleteStream))
  add(path_594714, "otaUpdateId", newJString(otaUpdateId))
  add(query_594715, "forceDeleteAWSJob", newJBool(forceDeleteAWSJob))
  result = call_594713.call(path_594714, query_594715, nil, nil, nil)

var deleteOTAUpdate* = Call_DeleteOTAUpdate_594699(name: "deleteOTAUpdate",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_DeleteOTAUpdate_594700,
    base: "/", url: url_DeleteOTAUpdate_594701, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreatePolicy_594730 = ref object of OpenApiRestCall_593437
proc url_CreatePolicy_594732(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreatePolicy_594731(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594733 = path.getOrDefault("policyName")
  valid_594733 = validateParameter(valid_594733, JString, required = true,
                                 default = nil)
  if valid_594733 != nil:
    section.add "policyName", valid_594733
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594734 = header.getOrDefault("X-Amz-Date")
  valid_594734 = validateParameter(valid_594734, JString, required = false,
                                 default = nil)
  if valid_594734 != nil:
    section.add "X-Amz-Date", valid_594734
  var valid_594735 = header.getOrDefault("X-Amz-Security-Token")
  valid_594735 = validateParameter(valid_594735, JString, required = false,
                                 default = nil)
  if valid_594735 != nil:
    section.add "X-Amz-Security-Token", valid_594735
  var valid_594736 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594736 = validateParameter(valid_594736, JString, required = false,
                                 default = nil)
  if valid_594736 != nil:
    section.add "X-Amz-Content-Sha256", valid_594736
  var valid_594737 = header.getOrDefault("X-Amz-Algorithm")
  valid_594737 = validateParameter(valid_594737, JString, required = false,
                                 default = nil)
  if valid_594737 != nil:
    section.add "X-Amz-Algorithm", valid_594737
  var valid_594738 = header.getOrDefault("X-Amz-Signature")
  valid_594738 = validateParameter(valid_594738, JString, required = false,
                                 default = nil)
  if valid_594738 != nil:
    section.add "X-Amz-Signature", valid_594738
  var valid_594739 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594739 = validateParameter(valid_594739, JString, required = false,
                                 default = nil)
  if valid_594739 != nil:
    section.add "X-Amz-SignedHeaders", valid_594739
  var valid_594740 = header.getOrDefault("X-Amz-Credential")
  valid_594740 = validateParameter(valid_594740, JString, required = false,
                                 default = nil)
  if valid_594740 != nil:
    section.add "X-Amz-Credential", valid_594740
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594742: Call_CreatePolicy_594730; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ## 
  let valid = call_594742.validator(path, query, header, formData, body)
  let scheme = call_594742.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594742.url(scheme.get, call_594742.host, call_594742.base,
                         call_594742.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594742, url, valid)

proc call*(call_594743: Call_CreatePolicy_594730; policyName: string; body: JsonNode): Recallable =
  ## createPolicy
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ##   policyName: string (required)
  ##             : The policy name.
  ##   body: JObject (required)
  var path_594744 = newJObject()
  var body_594745 = newJObject()
  add(path_594744, "policyName", newJString(policyName))
  if body != nil:
    body_594745 = body
  result = call_594743.call(path_594744, nil, nil, nil, body_594745)

var createPolicy* = Call_CreatePolicy_594730(name: "createPolicy",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/policies/{policyName}", validator: validate_CreatePolicy_594731,
    base: "/", url: url_CreatePolicy_594732, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPolicy_594716 = ref object of OpenApiRestCall_593437
proc url_GetPolicy_594718(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPolicy_594717(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the specified policy with the policy document of the default version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594719 = path.getOrDefault("policyName")
  valid_594719 = validateParameter(valid_594719, JString, required = true,
                                 default = nil)
  if valid_594719 != nil:
    section.add "policyName", valid_594719
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594720 = header.getOrDefault("X-Amz-Date")
  valid_594720 = validateParameter(valid_594720, JString, required = false,
                                 default = nil)
  if valid_594720 != nil:
    section.add "X-Amz-Date", valid_594720
  var valid_594721 = header.getOrDefault("X-Amz-Security-Token")
  valid_594721 = validateParameter(valid_594721, JString, required = false,
                                 default = nil)
  if valid_594721 != nil:
    section.add "X-Amz-Security-Token", valid_594721
  var valid_594722 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594722 = validateParameter(valid_594722, JString, required = false,
                                 default = nil)
  if valid_594722 != nil:
    section.add "X-Amz-Content-Sha256", valid_594722
  var valid_594723 = header.getOrDefault("X-Amz-Algorithm")
  valid_594723 = validateParameter(valid_594723, JString, required = false,
                                 default = nil)
  if valid_594723 != nil:
    section.add "X-Amz-Algorithm", valid_594723
  var valid_594724 = header.getOrDefault("X-Amz-Signature")
  valid_594724 = validateParameter(valid_594724, JString, required = false,
                                 default = nil)
  if valid_594724 != nil:
    section.add "X-Amz-Signature", valid_594724
  var valid_594725 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594725 = validateParameter(valid_594725, JString, required = false,
                                 default = nil)
  if valid_594725 != nil:
    section.add "X-Amz-SignedHeaders", valid_594725
  var valid_594726 = header.getOrDefault("X-Amz-Credential")
  valid_594726 = validateParameter(valid_594726, JString, required = false,
                                 default = nil)
  if valid_594726 != nil:
    section.add "X-Amz-Credential", valid_594726
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594727: Call_GetPolicy_594716; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified policy with the policy document of the default version.
  ## 
  let valid = call_594727.validator(path, query, header, formData, body)
  let scheme = call_594727.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594727.url(scheme.get, call_594727.host, call_594727.base,
                         call_594727.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594727, url, valid)

proc call*(call_594728: Call_GetPolicy_594716; policyName: string): Recallable =
  ## getPolicy
  ## Gets information about the specified policy with the policy document of the default version.
  ##   policyName: string (required)
  ##             : The name of the policy.
  var path_594729 = newJObject()
  add(path_594729, "policyName", newJString(policyName))
  result = call_594728.call(path_594729, nil, nil, nil, nil)

var getPolicy* = Call_GetPolicy_594716(name: "getPolicy", meth: HttpMethod.HttpGet,
                                    host: "iot.amazonaws.com",
                                    route: "/policies/{policyName}",
                                    validator: validate_GetPolicy_594717,
                                    base: "/", url: url_GetPolicy_594718,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeletePolicy_594746 = ref object of OpenApiRestCall_593437
proc url_DeletePolicy_594748(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeletePolicy_594747(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594749 = path.getOrDefault("policyName")
  valid_594749 = validateParameter(valid_594749, JString, required = true,
                                 default = nil)
  if valid_594749 != nil:
    section.add "policyName", valid_594749
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594750 = header.getOrDefault("X-Amz-Date")
  valid_594750 = validateParameter(valid_594750, JString, required = false,
                                 default = nil)
  if valid_594750 != nil:
    section.add "X-Amz-Date", valid_594750
  var valid_594751 = header.getOrDefault("X-Amz-Security-Token")
  valid_594751 = validateParameter(valid_594751, JString, required = false,
                                 default = nil)
  if valid_594751 != nil:
    section.add "X-Amz-Security-Token", valid_594751
  var valid_594752 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594752 = validateParameter(valid_594752, JString, required = false,
                                 default = nil)
  if valid_594752 != nil:
    section.add "X-Amz-Content-Sha256", valid_594752
  var valid_594753 = header.getOrDefault("X-Amz-Algorithm")
  valid_594753 = validateParameter(valid_594753, JString, required = false,
                                 default = nil)
  if valid_594753 != nil:
    section.add "X-Amz-Algorithm", valid_594753
  var valid_594754 = header.getOrDefault("X-Amz-Signature")
  valid_594754 = validateParameter(valid_594754, JString, required = false,
                                 default = nil)
  if valid_594754 != nil:
    section.add "X-Amz-Signature", valid_594754
  var valid_594755 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594755 = validateParameter(valid_594755, JString, required = false,
                                 default = nil)
  if valid_594755 != nil:
    section.add "X-Amz-SignedHeaders", valid_594755
  var valid_594756 = header.getOrDefault("X-Amz-Credential")
  valid_594756 = validateParameter(valid_594756, JString, required = false,
                                 default = nil)
  if valid_594756 != nil:
    section.add "X-Amz-Credential", valid_594756
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594757: Call_DeletePolicy_594746; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ## 
  let valid = call_594757.validator(path, query, header, formData, body)
  let scheme = call_594757.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594757.url(scheme.get, call_594757.host, call_594757.base,
                         call_594757.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594757, url, valid)

proc call*(call_594758: Call_DeletePolicy_594746; policyName: string): Recallable =
  ## deletePolicy
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ##   policyName: string (required)
  ##             : The name of the policy to delete.
  var path_594759 = newJObject()
  add(path_594759, "policyName", newJString(policyName))
  result = call_594758.call(path_594759, nil, nil, nil, nil)

var deletePolicy* = Call_DeletePolicy_594746(name: "deletePolicy",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/policies/{policyName}", validator: validate_DeletePolicy_594747,
    base: "/", url: url_DeletePolicy_594748, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreatePolicyVersion_594774 = ref object of OpenApiRestCall_593437
proc url_CreatePolicyVersion_594776(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreatePolicyVersion_594775(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594777 = path.getOrDefault("policyName")
  valid_594777 = validateParameter(valid_594777, JString, required = true,
                                 default = nil)
  if valid_594777 != nil:
    section.add "policyName", valid_594777
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsDefault: JBool
  ##               : Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
  section = newJObject()
  var valid_594778 = query.getOrDefault("setAsDefault")
  valid_594778 = validateParameter(valid_594778, JBool, required = false, default = nil)
  if valid_594778 != nil:
    section.add "setAsDefault", valid_594778
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594779 = header.getOrDefault("X-Amz-Date")
  valid_594779 = validateParameter(valid_594779, JString, required = false,
                                 default = nil)
  if valid_594779 != nil:
    section.add "X-Amz-Date", valid_594779
  var valid_594780 = header.getOrDefault("X-Amz-Security-Token")
  valid_594780 = validateParameter(valid_594780, JString, required = false,
                                 default = nil)
  if valid_594780 != nil:
    section.add "X-Amz-Security-Token", valid_594780
  var valid_594781 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594781 = validateParameter(valid_594781, JString, required = false,
                                 default = nil)
  if valid_594781 != nil:
    section.add "X-Amz-Content-Sha256", valid_594781
  var valid_594782 = header.getOrDefault("X-Amz-Algorithm")
  valid_594782 = validateParameter(valid_594782, JString, required = false,
                                 default = nil)
  if valid_594782 != nil:
    section.add "X-Amz-Algorithm", valid_594782
  var valid_594783 = header.getOrDefault("X-Amz-Signature")
  valid_594783 = validateParameter(valid_594783, JString, required = false,
                                 default = nil)
  if valid_594783 != nil:
    section.add "X-Amz-Signature", valid_594783
  var valid_594784 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594784 = validateParameter(valid_594784, JString, required = false,
                                 default = nil)
  if valid_594784 != nil:
    section.add "X-Amz-SignedHeaders", valid_594784
  var valid_594785 = header.getOrDefault("X-Amz-Credential")
  valid_594785 = validateParameter(valid_594785, JString, required = false,
                                 default = nil)
  if valid_594785 != nil:
    section.add "X-Amz-Credential", valid_594785
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594787: Call_CreatePolicyVersion_594774; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ## 
  let valid = call_594787.validator(path, query, header, formData, body)
  let scheme = call_594787.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594787.url(scheme.get, call_594787.host, call_594787.base,
                         call_594787.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594787, url, valid)

proc call*(call_594788: Call_CreatePolicyVersion_594774; policyName: string;
          body: JsonNode; setAsDefault: bool = false): Recallable =
  ## createPolicyVersion
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ##   setAsDefault: bool
  ##               : Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
  ##   policyName: string (required)
  ##             : The policy name.
  ##   body: JObject (required)
  var path_594789 = newJObject()
  var query_594790 = newJObject()
  var body_594791 = newJObject()
  add(query_594790, "setAsDefault", newJBool(setAsDefault))
  add(path_594789, "policyName", newJString(policyName))
  if body != nil:
    body_594791 = body
  result = call_594788.call(path_594789, query_594790, nil, nil, body_594791)

var createPolicyVersion* = Call_CreatePolicyVersion_594774(
    name: "createPolicyVersion", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/policies/{policyName}/version",
    validator: validate_CreatePolicyVersion_594775, base: "/",
    url: url_CreatePolicyVersion_594776, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicyVersions_594760 = ref object of OpenApiRestCall_593437
proc url_ListPolicyVersions_594762(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListPolicyVersions_594761(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Lists the versions of the specified policy and identifies the default version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594763 = path.getOrDefault("policyName")
  valid_594763 = validateParameter(valid_594763, JString, required = true,
                                 default = nil)
  if valid_594763 != nil:
    section.add "policyName", valid_594763
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594764 = header.getOrDefault("X-Amz-Date")
  valid_594764 = validateParameter(valid_594764, JString, required = false,
                                 default = nil)
  if valid_594764 != nil:
    section.add "X-Amz-Date", valid_594764
  var valid_594765 = header.getOrDefault("X-Amz-Security-Token")
  valid_594765 = validateParameter(valid_594765, JString, required = false,
                                 default = nil)
  if valid_594765 != nil:
    section.add "X-Amz-Security-Token", valid_594765
  var valid_594766 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594766 = validateParameter(valid_594766, JString, required = false,
                                 default = nil)
  if valid_594766 != nil:
    section.add "X-Amz-Content-Sha256", valid_594766
  var valid_594767 = header.getOrDefault("X-Amz-Algorithm")
  valid_594767 = validateParameter(valid_594767, JString, required = false,
                                 default = nil)
  if valid_594767 != nil:
    section.add "X-Amz-Algorithm", valid_594767
  var valid_594768 = header.getOrDefault("X-Amz-Signature")
  valid_594768 = validateParameter(valid_594768, JString, required = false,
                                 default = nil)
  if valid_594768 != nil:
    section.add "X-Amz-Signature", valid_594768
  var valid_594769 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594769 = validateParameter(valid_594769, JString, required = false,
                                 default = nil)
  if valid_594769 != nil:
    section.add "X-Amz-SignedHeaders", valid_594769
  var valid_594770 = header.getOrDefault("X-Amz-Credential")
  valid_594770 = validateParameter(valid_594770, JString, required = false,
                                 default = nil)
  if valid_594770 != nil:
    section.add "X-Amz-Credential", valid_594770
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594771: Call_ListPolicyVersions_594760; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the versions of the specified policy and identifies the default version.
  ## 
  let valid = call_594771.validator(path, query, header, formData, body)
  let scheme = call_594771.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594771.url(scheme.get, call_594771.host, call_594771.base,
                         call_594771.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594771, url, valid)

proc call*(call_594772: Call_ListPolicyVersions_594760; policyName: string): Recallable =
  ## listPolicyVersions
  ## Lists the versions of the specified policy and identifies the default version.
  ##   policyName: string (required)
  ##             : The policy name.
  var path_594773 = newJObject()
  add(path_594773, "policyName", newJString(policyName))
  result = call_594772.call(path_594773, nil, nil, nil, nil)

var listPolicyVersions* = Call_ListPolicyVersions_594760(
    name: "listPolicyVersions", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version",
    validator: validate_ListPolicyVersions_594761, base: "/",
    url: url_ListPolicyVersions_594762, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateRoleAlias_594806 = ref object of OpenApiRestCall_593437
proc url_UpdateRoleAlias_594808(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateRoleAlias_594807(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Updates a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_594809 = path.getOrDefault("roleAlias")
  valid_594809 = validateParameter(valid_594809, JString, required = true,
                                 default = nil)
  if valid_594809 != nil:
    section.add "roleAlias", valid_594809
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594810 = header.getOrDefault("X-Amz-Date")
  valid_594810 = validateParameter(valid_594810, JString, required = false,
                                 default = nil)
  if valid_594810 != nil:
    section.add "X-Amz-Date", valid_594810
  var valid_594811 = header.getOrDefault("X-Amz-Security-Token")
  valid_594811 = validateParameter(valid_594811, JString, required = false,
                                 default = nil)
  if valid_594811 != nil:
    section.add "X-Amz-Security-Token", valid_594811
  var valid_594812 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594812 = validateParameter(valid_594812, JString, required = false,
                                 default = nil)
  if valid_594812 != nil:
    section.add "X-Amz-Content-Sha256", valid_594812
  var valid_594813 = header.getOrDefault("X-Amz-Algorithm")
  valid_594813 = validateParameter(valid_594813, JString, required = false,
                                 default = nil)
  if valid_594813 != nil:
    section.add "X-Amz-Algorithm", valid_594813
  var valid_594814 = header.getOrDefault("X-Amz-Signature")
  valid_594814 = validateParameter(valid_594814, JString, required = false,
                                 default = nil)
  if valid_594814 != nil:
    section.add "X-Amz-Signature", valid_594814
  var valid_594815 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594815 = validateParameter(valid_594815, JString, required = false,
                                 default = nil)
  if valid_594815 != nil:
    section.add "X-Amz-SignedHeaders", valid_594815
  var valid_594816 = header.getOrDefault("X-Amz-Credential")
  valid_594816 = validateParameter(valid_594816, JString, required = false,
                                 default = nil)
  if valid_594816 != nil:
    section.add "X-Amz-Credential", valid_594816
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594818: Call_UpdateRoleAlias_594806; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a role alias.
  ## 
  let valid = call_594818.validator(path, query, header, formData, body)
  let scheme = call_594818.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594818.url(scheme.get, call_594818.host, call_594818.base,
                         call_594818.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594818, url, valid)

proc call*(call_594819: Call_UpdateRoleAlias_594806; body: JsonNode;
          roleAlias: string): Recallable =
  ## updateRoleAlias
  ## Updates a role alias.
  ##   body: JObject (required)
  ##   roleAlias: string (required)
  ##            : The role alias to update.
  var path_594820 = newJObject()
  var body_594821 = newJObject()
  if body != nil:
    body_594821 = body
  add(path_594820, "roleAlias", newJString(roleAlias))
  result = call_594819.call(path_594820, nil, nil, nil, body_594821)

var updateRoleAlias* = Call_UpdateRoleAlias_594806(name: "updateRoleAlias",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_UpdateRoleAlias_594807,
    base: "/", url: url_UpdateRoleAlias_594808, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateRoleAlias_594822 = ref object of OpenApiRestCall_593437
proc url_CreateRoleAlias_594824(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateRoleAlias_594823(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias that points to a role ARN. This allows you to change the role without having to update the device.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_594825 = path.getOrDefault("roleAlias")
  valid_594825 = validateParameter(valid_594825, JString, required = true,
                                 default = nil)
  if valid_594825 != nil:
    section.add "roleAlias", valid_594825
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594826 = header.getOrDefault("X-Amz-Date")
  valid_594826 = validateParameter(valid_594826, JString, required = false,
                                 default = nil)
  if valid_594826 != nil:
    section.add "X-Amz-Date", valid_594826
  var valid_594827 = header.getOrDefault("X-Amz-Security-Token")
  valid_594827 = validateParameter(valid_594827, JString, required = false,
                                 default = nil)
  if valid_594827 != nil:
    section.add "X-Amz-Security-Token", valid_594827
  var valid_594828 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594828 = validateParameter(valid_594828, JString, required = false,
                                 default = nil)
  if valid_594828 != nil:
    section.add "X-Amz-Content-Sha256", valid_594828
  var valid_594829 = header.getOrDefault("X-Amz-Algorithm")
  valid_594829 = validateParameter(valid_594829, JString, required = false,
                                 default = nil)
  if valid_594829 != nil:
    section.add "X-Amz-Algorithm", valid_594829
  var valid_594830 = header.getOrDefault("X-Amz-Signature")
  valid_594830 = validateParameter(valid_594830, JString, required = false,
                                 default = nil)
  if valid_594830 != nil:
    section.add "X-Amz-Signature", valid_594830
  var valid_594831 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594831 = validateParameter(valid_594831, JString, required = false,
                                 default = nil)
  if valid_594831 != nil:
    section.add "X-Amz-SignedHeaders", valid_594831
  var valid_594832 = header.getOrDefault("X-Amz-Credential")
  valid_594832 = validateParameter(valid_594832, JString, required = false,
                                 default = nil)
  if valid_594832 != nil:
    section.add "X-Amz-Credential", valid_594832
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594834: Call_CreateRoleAlias_594822; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a role alias.
  ## 
  let valid = call_594834.validator(path, query, header, formData, body)
  let scheme = call_594834.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594834.url(scheme.get, call_594834.host, call_594834.base,
                         call_594834.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594834, url, valid)

proc call*(call_594835: Call_CreateRoleAlias_594822; body: JsonNode;
          roleAlias: string): Recallable =
  ## createRoleAlias
  ## Creates a role alias.
  ##   body: JObject (required)
  ##   roleAlias: string (required)
  ##            : The role alias that points to a role ARN. This allows you to change the role without having to update the device.
  var path_594836 = newJObject()
  var body_594837 = newJObject()
  if body != nil:
    body_594837 = body
  add(path_594836, "roleAlias", newJString(roleAlias))
  result = call_594835.call(path_594836, nil, nil, nil, body_594837)

var createRoleAlias* = Call_CreateRoleAlias_594822(name: "createRoleAlias",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_CreateRoleAlias_594823,
    base: "/", url: url_CreateRoleAlias_594824, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeRoleAlias_594792 = ref object of OpenApiRestCall_593437
proc url_DescribeRoleAlias_594794(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeRoleAlias_594793(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Describes a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to describe.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_594795 = path.getOrDefault("roleAlias")
  valid_594795 = validateParameter(valid_594795, JString, required = true,
                                 default = nil)
  if valid_594795 != nil:
    section.add "roleAlias", valid_594795
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594796 = header.getOrDefault("X-Amz-Date")
  valid_594796 = validateParameter(valid_594796, JString, required = false,
                                 default = nil)
  if valid_594796 != nil:
    section.add "X-Amz-Date", valid_594796
  var valid_594797 = header.getOrDefault("X-Amz-Security-Token")
  valid_594797 = validateParameter(valid_594797, JString, required = false,
                                 default = nil)
  if valid_594797 != nil:
    section.add "X-Amz-Security-Token", valid_594797
  var valid_594798 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594798 = validateParameter(valid_594798, JString, required = false,
                                 default = nil)
  if valid_594798 != nil:
    section.add "X-Amz-Content-Sha256", valid_594798
  var valid_594799 = header.getOrDefault("X-Amz-Algorithm")
  valid_594799 = validateParameter(valid_594799, JString, required = false,
                                 default = nil)
  if valid_594799 != nil:
    section.add "X-Amz-Algorithm", valid_594799
  var valid_594800 = header.getOrDefault("X-Amz-Signature")
  valid_594800 = validateParameter(valid_594800, JString, required = false,
                                 default = nil)
  if valid_594800 != nil:
    section.add "X-Amz-Signature", valid_594800
  var valid_594801 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594801 = validateParameter(valid_594801, JString, required = false,
                                 default = nil)
  if valid_594801 != nil:
    section.add "X-Amz-SignedHeaders", valid_594801
  var valid_594802 = header.getOrDefault("X-Amz-Credential")
  valid_594802 = validateParameter(valid_594802, JString, required = false,
                                 default = nil)
  if valid_594802 != nil:
    section.add "X-Amz-Credential", valid_594802
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594803: Call_DescribeRoleAlias_594792; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a role alias.
  ## 
  let valid = call_594803.validator(path, query, header, formData, body)
  let scheme = call_594803.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594803.url(scheme.get, call_594803.host, call_594803.base,
                         call_594803.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594803, url, valid)

proc call*(call_594804: Call_DescribeRoleAlias_594792; roleAlias: string): Recallable =
  ## describeRoleAlias
  ## Describes a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias to describe.
  var path_594805 = newJObject()
  add(path_594805, "roleAlias", newJString(roleAlias))
  result = call_594804.call(path_594805, nil, nil, nil, nil)

var describeRoleAlias* = Call_DescribeRoleAlias_594792(name: "describeRoleAlias",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_DescribeRoleAlias_594793,
    base: "/", url: url_DescribeRoleAlias_594794,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRoleAlias_594838 = ref object of OpenApiRestCall_593437
proc url_DeleteRoleAlias_594840(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteRoleAlias_594839(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes a role alias
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_594841 = path.getOrDefault("roleAlias")
  valid_594841 = validateParameter(valid_594841, JString, required = true,
                                 default = nil)
  if valid_594841 != nil:
    section.add "roleAlias", valid_594841
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594842 = header.getOrDefault("X-Amz-Date")
  valid_594842 = validateParameter(valid_594842, JString, required = false,
                                 default = nil)
  if valid_594842 != nil:
    section.add "X-Amz-Date", valid_594842
  var valid_594843 = header.getOrDefault("X-Amz-Security-Token")
  valid_594843 = validateParameter(valid_594843, JString, required = false,
                                 default = nil)
  if valid_594843 != nil:
    section.add "X-Amz-Security-Token", valid_594843
  var valid_594844 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594844 = validateParameter(valid_594844, JString, required = false,
                                 default = nil)
  if valid_594844 != nil:
    section.add "X-Amz-Content-Sha256", valid_594844
  var valid_594845 = header.getOrDefault("X-Amz-Algorithm")
  valid_594845 = validateParameter(valid_594845, JString, required = false,
                                 default = nil)
  if valid_594845 != nil:
    section.add "X-Amz-Algorithm", valid_594845
  var valid_594846 = header.getOrDefault("X-Amz-Signature")
  valid_594846 = validateParameter(valid_594846, JString, required = false,
                                 default = nil)
  if valid_594846 != nil:
    section.add "X-Amz-Signature", valid_594846
  var valid_594847 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594847 = validateParameter(valid_594847, JString, required = false,
                                 default = nil)
  if valid_594847 != nil:
    section.add "X-Amz-SignedHeaders", valid_594847
  var valid_594848 = header.getOrDefault("X-Amz-Credential")
  valid_594848 = validateParameter(valid_594848, JString, required = false,
                                 default = nil)
  if valid_594848 != nil:
    section.add "X-Amz-Credential", valid_594848
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594849: Call_DeleteRoleAlias_594838; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a role alias
  ## 
  let valid = call_594849.validator(path, query, header, formData, body)
  let scheme = call_594849.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594849.url(scheme.get, call_594849.host, call_594849.base,
                         call_594849.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594849, url, valid)

proc call*(call_594850: Call_DeleteRoleAlias_594838; roleAlias: string): Recallable =
  ## deleteRoleAlias
  ## Deletes a role alias
  ##   roleAlias: string (required)
  ##            : The role alias to delete.
  var path_594851 = newJObject()
  add(path_594851, "roleAlias", newJString(roleAlias))
  result = call_594850.call(path_594851, nil, nil, nil, nil)

var deleteRoleAlias* = Call_DeleteRoleAlias_594838(name: "deleteRoleAlias",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_DeleteRoleAlias_594839,
    base: "/", url: url_DeleteRoleAlias_594840, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateScheduledAudit_594866 = ref object of OpenApiRestCall_593437
proc url_CreateScheduledAudit_594868(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateScheduledAudit_594867(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled audit that is run at a specified time interval.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name you want to give to the scheduled audit. (Max. 128 chars)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_594869 = path.getOrDefault("scheduledAuditName")
  valid_594869 = validateParameter(valid_594869, JString, required = true,
                                 default = nil)
  if valid_594869 != nil:
    section.add "scheduledAuditName", valid_594869
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594870 = header.getOrDefault("X-Amz-Date")
  valid_594870 = validateParameter(valid_594870, JString, required = false,
                                 default = nil)
  if valid_594870 != nil:
    section.add "X-Amz-Date", valid_594870
  var valid_594871 = header.getOrDefault("X-Amz-Security-Token")
  valid_594871 = validateParameter(valid_594871, JString, required = false,
                                 default = nil)
  if valid_594871 != nil:
    section.add "X-Amz-Security-Token", valid_594871
  var valid_594872 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594872 = validateParameter(valid_594872, JString, required = false,
                                 default = nil)
  if valid_594872 != nil:
    section.add "X-Amz-Content-Sha256", valid_594872
  var valid_594873 = header.getOrDefault("X-Amz-Algorithm")
  valid_594873 = validateParameter(valid_594873, JString, required = false,
                                 default = nil)
  if valid_594873 != nil:
    section.add "X-Amz-Algorithm", valid_594873
  var valid_594874 = header.getOrDefault("X-Amz-Signature")
  valid_594874 = validateParameter(valid_594874, JString, required = false,
                                 default = nil)
  if valid_594874 != nil:
    section.add "X-Amz-Signature", valid_594874
  var valid_594875 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594875 = validateParameter(valid_594875, JString, required = false,
                                 default = nil)
  if valid_594875 != nil:
    section.add "X-Amz-SignedHeaders", valid_594875
  var valid_594876 = header.getOrDefault("X-Amz-Credential")
  valid_594876 = validateParameter(valid_594876, JString, required = false,
                                 default = nil)
  if valid_594876 != nil:
    section.add "X-Amz-Credential", valid_594876
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594878: Call_CreateScheduledAudit_594866; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled audit that is run at a specified time interval.
  ## 
  let valid = call_594878.validator(path, query, header, formData, body)
  let scheme = call_594878.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594878.url(scheme.get, call_594878.host, call_594878.base,
                         call_594878.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594878, url, valid)

proc call*(call_594879: Call_CreateScheduledAudit_594866;
          scheduledAuditName: string; body: JsonNode): Recallable =
  ## createScheduledAudit
  ## Creates a scheduled audit that is run at a specified time interval.
  ##   scheduledAuditName: string (required)
  ##                     : The name you want to give to the scheduled audit. (Max. 128 chars)
  ##   body: JObject (required)
  var path_594880 = newJObject()
  var body_594881 = newJObject()
  add(path_594880, "scheduledAuditName", newJString(scheduledAuditName))
  if body != nil:
    body_594881 = body
  result = call_594879.call(path_594880, nil, nil, nil, body_594881)

var createScheduledAudit* = Call_CreateScheduledAudit_594866(
    name: "createScheduledAudit", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_CreateScheduledAudit_594867, base: "/",
    url: url_CreateScheduledAudit_594868, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeScheduledAudit_594852 = ref object of OpenApiRestCall_593437
proc url_DescribeScheduledAudit_594854(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeScheduledAudit_594853(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a scheduled audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit whose information you want to get.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_594855 = path.getOrDefault("scheduledAuditName")
  valid_594855 = validateParameter(valid_594855, JString, required = true,
                                 default = nil)
  if valid_594855 != nil:
    section.add "scheduledAuditName", valid_594855
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594856 = header.getOrDefault("X-Amz-Date")
  valid_594856 = validateParameter(valid_594856, JString, required = false,
                                 default = nil)
  if valid_594856 != nil:
    section.add "X-Amz-Date", valid_594856
  var valid_594857 = header.getOrDefault("X-Amz-Security-Token")
  valid_594857 = validateParameter(valid_594857, JString, required = false,
                                 default = nil)
  if valid_594857 != nil:
    section.add "X-Amz-Security-Token", valid_594857
  var valid_594858 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594858 = validateParameter(valid_594858, JString, required = false,
                                 default = nil)
  if valid_594858 != nil:
    section.add "X-Amz-Content-Sha256", valid_594858
  var valid_594859 = header.getOrDefault("X-Amz-Algorithm")
  valid_594859 = validateParameter(valid_594859, JString, required = false,
                                 default = nil)
  if valid_594859 != nil:
    section.add "X-Amz-Algorithm", valid_594859
  var valid_594860 = header.getOrDefault("X-Amz-Signature")
  valid_594860 = validateParameter(valid_594860, JString, required = false,
                                 default = nil)
  if valid_594860 != nil:
    section.add "X-Amz-Signature", valid_594860
  var valid_594861 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594861 = validateParameter(valid_594861, JString, required = false,
                                 default = nil)
  if valid_594861 != nil:
    section.add "X-Amz-SignedHeaders", valid_594861
  var valid_594862 = header.getOrDefault("X-Amz-Credential")
  valid_594862 = validateParameter(valid_594862, JString, required = false,
                                 default = nil)
  if valid_594862 != nil:
    section.add "X-Amz-Credential", valid_594862
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594863: Call_DescribeScheduledAudit_594852; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a scheduled audit.
  ## 
  let valid = call_594863.validator(path, query, header, formData, body)
  let scheme = call_594863.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594863.url(scheme.get, call_594863.host, call_594863.base,
                         call_594863.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594863, url, valid)

proc call*(call_594864: Call_DescribeScheduledAudit_594852;
          scheduledAuditName: string): Recallable =
  ## describeScheduledAudit
  ## Gets information about a scheduled audit.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit whose information you want to get.
  var path_594865 = newJObject()
  add(path_594865, "scheduledAuditName", newJString(scheduledAuditName))
  result = call_594864.call(path_594865, nil, nil, nil, nil)

var describeScheduledAudit* = Call_DescribeScheduledAudit_594852(
    name: "describeScheduledAudit", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_DescribeScheduledAudit_594853, base: "/",
    url: url_DescribeScheduledAudit_594854, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateScheduledAudit_594896 = ref object of OpenApiRestCall_593437
proc url_UpdateScheduledAudit_594898(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateScheduledAudit_594897(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit. (Max. 128 chars)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_594899 = path.getOrDefault("scheduledAuditName")
  valid_594899 = validateParameter(valid_594899, JString, required = true,
                                 default = nil)
  if valid_594899 != nil:
    section.add "scheduledAuditName", valid_594899
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594900 = header.getOrDefault("X-Amz-Date")
  valid_594900 = validateParameter(valid_594900, JString, required = false,
                                 default = nil)
  if valid_594900 != nil:
    section.add "X-Amz-Date", valid_594900
  var valid_594901 = header.getOrDefault("X-Amz-Security-Token")
  valid_594901 = validateParameter(valid_594901, JString, required = false,
                                 default = nil)
  if valid_594901 != nil:
    section.add "X-Amz-Security-Token", valid_594901
  var valid_594902 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594902 = validateParameter(valid_594902, JString, required = false,
                                 default = nil)
  if valid_594902 != nil:
    section.add "X-Amz-Content-Sha256", valid_594902
  var valid_594903 = header.getOrDefault("X-Amz-Algorithm")
  valid_594903 = validateParameter(valid_594903, JString, required = false,
                                 default = nil)
  if valid_594903 != nil:
    section.add "X-Amz-Algorithm", valid_594903
  var valid_594904 = header.getOrDefault("X-Amz-Signature")
  valid_594904 = validateParameter(valid_594904, JString, required = false,
                                 default = nil)
  if valid_594904 != nil:
    section.add "X-Amz-Signature", valid_594904
  var valid_594905 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594905 = validateParameter(valid_594905, JString, required = false,
                                 default = nil)
  if valid_594905 != nil:
    section.add "X-Amz-SignedHeaders", valid_594905
  var valid_594906 = header.getOrDefault("X-Amz-Credential")
  valid_594906 = validateParameter(valid_594906, JString, required = false,
                                 default = nil)
  if valid_594906 != nil:
    section.add "X-Amz-Credential", valid_594906
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594908: Call_UpdateScheduledAudit_594896; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ## 
  let valid = call_594908.validator(path, query, header, formData, body)
  let scheme = call_594908.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594908.url(scheme.get, call_594908.host, call_594908.base,
                         call_594908.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594908, url, valid)

proc call*(call_594909: Call_UpdateScheduledAudit_594896;
          scheduledAuditName: string; body: JsonNode): Recallable =
  ## updateScheduledAudit
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit. (Max. 128 chars)
  ##   body: JObject (required)
  var path_594910 = newJObject()
  var body_594911 = newJObject()
  add(path_594910, "scheduledAuditName", newJString(scheduledAuditName))
  if body != nil:
    body_594911 = body
  result = call_594909.call(path_594910, nil, nil, nil, body_594911)

var updateScheduledAudit* = Call_UpdateScheduledAudit_594896(
    name: "updateScheduledAudit", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_UpdateScheduledAudit_594897, base: "/",
    url: url_UpdateScheduledAudit_594898, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteScheduledAudit_594882 = ref object of OpenApiRestCall_593437
proc url_DeleteScheduledAudit_594884(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteScheduledAudit_594883(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit you want to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_594885 = path.getOrDefault("scheduledAuditName")
  valid_594885 = validateParameter(valid_594885, JString, required = true,
                                 default = nil)
  if valid_594885 != nil:
    section.add "scheduledAuditName", valid_594885
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594886 = header.getOrDefault("X-Amz-Date")
  valid_594886 = validateParameter(valid_594886, JString, required = false,
                                 default = nil)
  if valid_594886 != nil:
    section.add "X-Amz-Date", valid_594886
  var valid_594887 = header.getOrDefault("X-Amz-Security-Token")
  valid_594887 = validateParameter(valid_594887, JString, required = false,
                                 default = nil)
  if valid_594887 != nil:
    section.add "X-Amz-Security-Token", valid_594887
  var valid_594888 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594888 = validateParameter(valid_594888, JString, required = false,
                                 default = nil)
  if valid_594888 != nil:
    section.add "X-Amz-Content-Sha256", valid_594888
  var valid_594889 = header.getOrDefault("X-Amz-Algorithm")
  valid_594889 = validateParameter(valid_594889, JString, required = false,
                                 default = nil)
  if valid_594889 != nil:
    section.add "X-Amz-Algorithm", valid_594889
  var valid_594890 = header.getOrDefault("X-Amz-Signature")
  valid_594890 = validateParameter(valid_594890, JString, required = false,
                                 default = nil)
  if valid_594890 != nil:
    section.add "X-Amz-Signature", valid_594890
  var valid_594891 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594891 = validateParameter(valid_594891, JString, required = false,
                                 default = nil)
  if valid_594891 != nil:
    section.add "X-Amz-SignedHeaders", valid_594891
  var valid_594892 = header.getOrDefault("X-Amz-Credential")
  valid_594892 = validateParameter(valid_594892, JString, required = false,
                                 default = nil)
  if valid_594892 != nil:
    section.add "X-Amz-Credential", valid_594892
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594893: Call_DeleteScheduledAudit_594882; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled audit.
  ## 
  let valid = call_594893.validator(path, query, header, formData, body)
  let scheme = call_594893.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594893.url(scheme.get, call_594893.host, call_594893.base,
                         call_594893.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594893, url, valid)

proc call*(call_594894: Call_DeleteScheduledAudit_594882;
          scheduledAuditName: string): Recallable =
  ## deleteScheduledAudit
  ## Deletes a scheduled audit.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit you want to delete.
  var path_594895 = newJObject()
  add(path_594895, "scheduledAuditName", newJString(scheduledAuditName))
  result = call_594894.call(path_594895, nil, nil, nil, nil)

var deleteScheduledAudit* = Call_DeleteScheduledAudit_594882(
    name: "deleteScheduledAudit", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_DeleteScheduledAudit_594883, base: "/",
    url: url_DeleteScheduledAudit_594884, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateSecurityProfile_594926 = ref object of OpenApiRestCall_593437
proc url_CreateSecurityProfile_594928(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateSecurityProfile_594927(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name you are giving to the security profile.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_594929 = path.getOrDefault("securityProfileName")
  valid_594929 = validateParameter(valid_594929, JString, required = true,
                                 default = nil)
  if valid_594929 != nil:
    section.add "securityProfileName", valid_594929
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594930 = header.getOrDefault("X-Amz-Date")
  valid_594930 = validateParameter(valid_594930, JString, required = false,
                                 default = nil)
  if valid_594930 != nil:
    section.add "X-Amz-Date", valid_594930
  var valid_594931 = header.getOrDefault("X-Amz-Security-Token")
  valid_594931 = validateParameter(valid_594931, JString, required = false,
                                 default = nil)
  if valid_594931 != nil:
    section.add "X-Amz-Security-Token", valid_594931
  var valid_594932 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594932 = validateParameter(valid_594932, JString, required = false,
                                 default = nil)
  if valid_594932 != nil:
    section.add "X-Amz-Content-Sha256", valid_594932
  var valid_594933 = header.getOrDefault("X-Amz-Algorithm")
  valid_594933 = validateParameter(valid_594933, JString, required = false,
                                 default = nil)
  if valid_594933 != nil:
    section.add "X-Amz-Algorithm", valid_594933
  var valid_594934 = header.getOrDefault("X-Amz-Signature")
  valid_594934 = validateParameter(valid_594934, JString, required = false,
                                 default = nil)
  if valid_594934 != nil:
    section.add "X-Amz-Signature", valid_594934
  var valid_594935 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594935 = validateParameter(valid_594935, JString, required = false,
                                 default = nil)
  if valid_594935 != nil:
    section.add "X-Amz-SignedHeaders", valid_594935
  var valid_594936 = header.getOrDefault("X-Amz-Credential")
  valid_594936 = validateParameter(valid_594936, JString, required = false,
                                 default = nil)
  if valid_594936 != nil:
    section.add "X-Amz-Credential", valid_594936
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594938: Call_CreateSecurityProfile_594926; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Device Defender security profile.
  ## 
  let valid = call_594938.validator(path, query, header, formData, body)
  let scheme = call_594938.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594938.url(scheme.get, call_594938.host, call_594938.base,
                         call_594938.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594938, url, valid)

proc call*(call_594939: Call_CreateSecurityProfile_594926; body: JsonNode;
          securityProfileName: string): Recallable =
  ## createSecurityProfile
  ## Creates a Device Defender security profile.
  ##   body: JObject (required)
  ##   securityProfileName: string (required)
  ##                      : The name you are giving to the security profile.
  var path_594940 = newJObject()
  var body_594941 = newJObject()
  if body != nil:
    body_594941 = body
  add(path_594940, "securityProfileName", newJString(securityProfileName))
  result = call_594939.call(path_594940, nil, nil, nil, body_594941)

var createSecurityProfile* = Call_CreateSecurityProfile_594926(
    name: "createSecurityProfile", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_CreateSecurityProfile_594927, base: "/",
    url: url_CreateSecurityProfile_594928, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeSecurityProfile_594912 = ref object of OpenApiRestCall_593437
proc url_DescribeSecurityProfile_594914(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeSecurityProfile_594913(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile whose information you want to get.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_594915 = path.getOrDefault("securityProfileName")
  valid_594915 = validateParameter(valid_594915, JString, required = true,
                                 default = nil)
  if valid_594915 != nil:
    section.add "securityProfileName", valid_594915
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594916 = header.getOrDefault("X-Amz-Date")
  valid_594916 = validateParameter(valid_594916, JString, required = false,
                                 default = nil)
  if valid_594916 != nil:
    section.add "X-Amz-Date", valid_594916
  var valid_594917 = header.getOrDefault("X-Amz-Security-Token")
  valid_594917 = validateParameter(valid_594917, JString, required = false,
                                 default = nil)
  if valid_594917 != nil:
    section.add "X-Amz-Security-Token", valid_594917
  var valid_594918 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594918 = validateParameter(valid_594918, JString, required = false,
                                 default = nil)
  if valid_594918 != nil:
    section.add "X-Amz-Content-Sha256", valid_594918
  var valid_594919 = header.getOrDefault("X-Amz-Algorithm")
  valid_594919 = validateParameter(valid_594919, JString, required = false,
                                 default = nil)
  if valid_594919 != nil:
    section.add "X-Amz-Algorithm", valid_594919
  var valid_594920 = header.getOrDefault("X-Amz-Signature")
  valid_594920 = validateParameter(valid_594920, JString, required = false,
                                 default = nil)
  if valid_594920 != nil:
    section.add "X-Amz-Signature", valid_594920
  var valid_594921 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594921 = validateParameter(valid_594921, JString, required = false,
                                 default = nil)
  if valid_594921 != nil:
    section.add "X-Amz-SignedHeaders", valid_594921
  var valid_594922 = header.getOrDefault("X-Amz-Credential")
  valid_594922 = validateParameter(valid_594922, JString, required = false,
                                 default = nil)
  if valid_594922 != nil:
    section.add "X-Amz-Credential", valid_594922
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594923: Call_DescribeSecurityProfile_594912; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a Device Defender security profile.
  ## 
  let valid = call_594923.validator(path, query, header, formData, body)
  let scheme = call_594923.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594923.url(scheme.get, call_594923.host, call_594923.base,
                         call_594923.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594923, url, valid)

proc call*(call_594924: Call_DescribeSecurityProfile_594912;
          securityProfileName: string): Recallable =
  ## describeSecurityProfile
  ## Gets information about a Device Defender security profile.
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile whose information you want to get.
  var path_594925 = newJObject()
  add(path_594925, "securityProfileName", newJString(securityProfileName))
  result = call_594924.call(path_594925, nil, nil, nil, nil)

var describeSecurityProfile* = Call_DescribeSecurityProfile_594912(
    name: "describeSecurityProfile", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_DescribeSecurityProfile_594913, base: "/",
    url: url_DescribeSecurityProfile_594914, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateSecurityProfile_594958 = ref object of OpenApiRestCall_593437
proc url_UpdateSecurityProfile_594960(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateSecurityProfile_594959(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile you want to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_594961 = path.getOrDefault("securityProfileName")
  valid_594961 = validateParameter(valid_594961, JString, required = true,
                                 default = nil)
  if valid_594961 != nil:
    section.add "securityProfileName", valid_594961
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  section = newJObject()
  var valid_594962 = query.getOrDefault("expectedVersion")
  valid_594962 = validateParameter(valid_594962, JInt, required = false, default = nil)
  if valid_594962 != nil:
    section.add "expectedVersion", valid_594962
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594963 = header.getOrDefault("X-Amz-Date")
  valid_594963 = validateParameter(valid_594963, JString, required = false,
                                 default = nil)
  if valid_594963 != nil:
    section.add "X-Amz-Date", valid_594963
  var valid_594964 = header.getOrDefault("X-Amz-Security-Token")
  valid_594964 = validateParameter(valid_594964, JString, required = false,
                                 default = nil)
  if valid_594964 != nil:
    section.add "X-Amz-Security-Token", valid_594964
  var valid_594965 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594965 = validateParameter(valid_594965, JString, required = false,
                                 default = nil)
  if valid_594965 != nil:
    section.add "X-Amz-Content-Sha256", valid_594965
  var valid_594966 = header.getOrDefault("X-Amz-Algorithm")
  valid_594966 = validateParameter(valid_594966, JString, required = false,
                                 default = nil)
  if valid_594966 != nil:
    section.add "X-Amz-Algorithm", valid_594966
  var valid_594967 = header.getOrDefault("X-Amz-Signature")
  valid_594967 = validateParameter(valid_594967, JString, required = false,
                                 default = nil)
  if valid_594967 != nil:
    section.add "X-Amz-Signature", valid_594967
  var valid_594968 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594968 = validateParameter(valid_594968, JString, required = false,
                                 default = nil)
  if valid_594968 != nil:
    section.add "X-Amz-SignedHeaders", valid_594968
  var valid_594969 = header.getOrDefault("X-Amz-Credential")
  valid_594969 = validateParameter(valid_594969, JString, required = false,
                                 default = nil)
  if valid_594969 != nil:
    section.add "X-Amz-Credential", valid_594969
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594971: Call_UpdateSecurityProfile_594958; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a Device Defender security profile.
  ## 
  let valid = call_594971.validator(path, query, header, formData, body)
  let scheme = call_594971.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594971.url(scheme.get, call_594971.host, call_594971.base,
                         call_594971.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594971, url, valid)

proc call*(call_594972: Call_UpdateSecurityProfile_594958; body: JsonNode;
          securityProfileName: string; expectedVersion: int = 0): Recallable =
  ## updateSecurityProfile
  ## Updates a Device Defender security profile.
  ##   expectedVersion: int
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  ##   body: JObject (required)
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile you want to update.
  var path_594973 = newJObject()
  var query_594974 = newJObject()
  var body_594975 = newJObject()
  add(query_594974, "expectedVersion", newJInt(expectedVersion))
  if body != nil:
    body_594975 = body
  add(path_594973, "securityProfileName", newJString(securityProfileName))
  result = call_594972.call(path_594973, query_594974, nil, nil, body_594975)

var updateSecurityProfile* = Call_UpdateSecurityProfile_594958(
    name: "updateSecurityProfile", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_UpdateSecurityProfile_594959, base: "/",
    url: url_UpdateSecurityProfile_594960, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteSecurityProfile_594942 = ref object of OpenApiRestCall_593437
proc url_DeleteSecurityProfile_594944(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteSecurityProfile_594943(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile to be deleted.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_594945 = path.getOrDefault("securityProfileName")
  valid_594945 = validateParameter(valid_594945, JString, required = true,
                                 default = nil)
  if valid_594945 != nil:
    section.add "securityProfileName", valid_594945
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  section = newJObject()
  var valid_594946 = query.getOrDefault("expectedVersion")
  valid_594946 = validateParameter(valid_594946, JInt, required = false, default = nil)
  if valid_594946 != nil:
    section.add "expectedVersion", valid_594946
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594947 = header.getOrDefault("X-Amz-Date")
  valid_594947 = validateParameter(valid_594947, JString, required = false,
                                 default = nil)
  if valid_594947 != nil:
    section.add "X-Amz-Date", valid_594947
  var valid_594948 = header.getOrDefault("X-Amz-Security-Token")
  valid_594948 = validateParameter(valid_594948, JString, required = false,
                                 default = nil)
  if valid_594948 != nil:
    section.add "X-Amz-Security-Token", valid_594948
  var valid_594949 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594949 = validateParameter(valid_594949, JString, required = false,
                                 default = nil)
  if valid_594949 != nil:
    section.add "X-Amz-Content-Sha256", valid_594949
  var valid_594950 = header.getOrDefault("X-Amz-Algorithm")
  valid_594950 = validateParameter(valid_594950, JString, required = false,
                                 default = nil)
  if valid_594950 != nil:
    section.add "X-Amz-Algorithm", valid_594950
  var valid_594951 = header.getOrDefault("X-Amz-Signature")
  valid_594951 = validateParameter(valid_594951, JString, required = false,
                                 default = nil)
  if valid_594951 != nil:
    section.add "X-Amz-Signature", valid_594951
  var valid_594952 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594952 = validateParameter(valid_594952, JString, required = false,
                                 default = nil)
  if valid_594952 != nil:
    section.add "X-Amz-SignedHeaders", valid_594952
  var valid_594953 = header.getOrDefault("X-Amz-Credential")
  valid_594953 = validateParameter(valid_594953, JString, required = false,
                                 default = nil)
  if valid_594953 != nil:
    section.add "X-Amz-Credential", valid_594953
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594954: Call_DeleteSecurityProfile_594942; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a Device Defender security profile.
  ## 
  let valid = call_594954.validator(path, query, header, formData, body)
  let scheme = call_594954.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594954.url(scheme.get, call_594954.host, call_594954.base,
                         call_594954.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594954, url, valid)

proc call*(call_594955: Call_DeleteSecurityProfile_594942;
          securityProfileName: string; expectedVersion: int = 0): Recallable =
  ## deleteSecurityProfile
  ## Deletes a Device Defender security profile.
  ##   expectedVersion: int
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile to be deleted.
  var path_594956 = newJObject()
  var query_594957 = newJObject()
  add(query_594957, "expectedVersion", newJInt(expectedVersion))
  add(path_594956, "securityProfileName", newJString(securityProfileName))
  result = call_594955.call(path_594956, query_594957, nil, nil, nil)

var deleteSecurityProfile* = Call_DeleteSecurityProfile_594942(
    name: "deleteSecurityProfile", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_DeleteSecurityProfile_594943, base: "/",
    url: url_DeleteSecurityProfile_594944, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateStream_594990 = ref object of OpenApiRestCall_593437
proc url_UpdateStream_594992(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateStream_594991(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing stream. The stream version will be incremented by one.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_594993 = path.getOrDefault("streamId")
  valid_594993 = validateParameter(valid_594993, JString, required = true,
                                 default = nil)
  if valid_594993 != nil:
    section.add "streamId", valid_594993
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594994 = header.getOrDefault("X-Amz-Date")
  valid_594994 = validateParameter(valid_594994, JString, required = false,
                                 default = nil)
  if valid_594994 != nil:
    section.add "X-Amz-Date", valid_594994
  var valid_594995 = header.getOrDefault("X-Amz-Security-Token")
  valid_594995 = validateParameter(valid_594995, JString, required = false,
                                 default = nil)
  if valid_594995 != nil:
    section.add "X-Amz-Security-Token", valid_594995
  var valid_594996 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594996 = validateParameter(valid_594996, JString, required = false,
                                 default = nil)
  if valid_594996 != nil:
    section.add "X-Amz-Content-Sha256", valid_594996
  var valid_594997 = header.getOrDefault("X-Amz-Algorithm")
  valid_594997 = validateParameter(valid_594997, JString, required = false,
                                 default = nil)
  if valid_594997 != nil:
    section.add "X-Amz-Algorithm", valid_594997
  var valid_594998 = header.getOrDefault("X-Amz-Signature")
  valid_594998 = validateParameter(valid_594998, JString, required = false,
                                 default = nil)
  if valid_594998 != nil:
    section.add "X-Amz-Signature", valid_594998
  var valid_594999 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594999 = validateParameter(valid_594999, JString, required = false,
                                 default = nil)
  if valid_594999 != nil:
    section.add "X-Amz-SignedHeaders", valid_594999
  var valid_595000 = header.getOrDefault("X-Amz-Credential")
  valid_595000 = validateParameter(valid_595000, JString, required = false,
                                 default = nil)
  if valid_595000 != nil:
    section.add "X-Amz-Credential", valid_595000
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595002: Call_UpdateStream_594990; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing stream. The stream version will be incremented by one.
  ## 
  let valid = call_595002.validator(path, query, header, formData, body)
  let scheme = call_595002.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595002.url(scheme.get, call_595002.host, call_595002.base,
                         call_595002.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595002, url, valid)

proc call*(call_595003: Call_UpdateStream_594990; body: JsonNode; streamId: string): Recallable =
  ## updateStream
  ## Updates an existing stream. The stream version will be incremented by one.
  ##   body: JObject (required)
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_595004 = newJObject()
  var body_595005 = newJObject()
  if body != nil:
    body_595005 = body
  add(path_595004, "streamId", newJString(streamId))
  result = call_595003.call(path_595004, nil, nil, nil, body_595005)

var updateStream* = Call_UpdateStream_594990(name: "updateStream",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_UpdateStream_594991,
    base: "/", url: url_UpdateStream_594992, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateStream_595006 = ref object of OpenApiRestCall_593437
proc url_CreateStream_595008(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateStream_595007(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream. The total size of a file associated with the stream cannot exceed more than 2 MB. The stream will be created with version 0. If a stream is created with the same streamID as a stream that existed and was deleted within last 90 days, we will resurrect that old stream by incrementing the version by 1.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_595009 = path.getOrDefault("streamId")
  valid_595009 = validateParameter(valid_595009, JString, required = true,
                                 default = nil)
  if valid_595009 != nil:
    section.add "streamId", valid_595009
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595010 = header.getOrDefault("X-Amz-Date")
  valid_595010 = validateParameter(valid_595010, JString, required = false,
                                 default = nil)
  if valid_595010 != nil:
    section.add "X-Amz-Date", valid_595010
  var valid_595011 = header.getOrDefault("X-Amz-Security-Token")
  valid_595011 = validateParameter(valid_595011, JString, required = false,
                                 default = nil)
  if valid_595011 != nil:
    section.add "X-Amz-Security-Token", valid_595011
  var valid_595012 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595012 = validateParameter(valid_595012, JString, required = false,
                                 default = nil)
  if valid_595012 != nil:
    section.add "X-Amz-Content-Sha256", valid_595012
  var valid_595013 = header.getOrDefault("X-Amz-Algorithm")
  valid_595013 = validateParameter(valid_595013, JString, required = false,
                                 default = nil)
  if valid_595013 != nil:
    section.add "X-Amz-Algorithm", valid_595013
  var valid_595014 = header.getOrDefault("X-Amz-Signature")
  valid_595014 = validateParameter(valid_595014, JString, required = false,
                                 default = nil)
  if valid_595014 != nil:
    section.add "X-Amz-Signature", valid_595014
  var valid_595015 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595015 = validateParameter(valid_595015, JString, required = false,
                                 default = nil)
  if valid_595015 != nil:
    section.add "X-Amz-SignedHeaders", valid_595015
  var valid_595016 = header.getOrDefault("X-Amz-Credential")
  valid_595016 = validateParameter(valid_595016, JString, required = false,
                                 default = nil)
  if valid_595016 != nil:
    section.add "X-Amz-Credential", valid_595016
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595018: Call_CreateStream_595006; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream. The total size of a file associated with the stream cannot exceed more than 2 MB. The stream will be created with version 0. If a stream is created with the same streamID as a stream that existed and was deleted within last 90 days, we will resurrect that old stream by incrementing the version by 1.
  ## 
  let valid = call_595018.validator(path, query, header, formData, body)
  let scheme = call_595018.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595018.url(scheme.get, call_595018.host, call_595018.base,
                         call_595018.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595018, url, valid)

proc call*(call_595019: Call_CreateStream_595006; body: JsonNode; streamId: string): Recallable =
  ## createStream
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream. The total size of a file associated with the stream cannot exceed more than 2 MB. The stream will be created with version 0. If a stream is created with the same streamID as a stream that existed and was deleted within last 90 days, we will resurrect that old stream by incrementing the version by 1.
  ##   body: JObject (required)
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_595020 = newJObject()
  var body_595021 = newJObject()
  if body != nil:
    body_595021 = body
  add(path_595020, "streamId", newJString(streamId))
  result = call_595019.call(path_595020, nil, nil, nil, body_595021)

var createStream* = Call_CreateStream_595006(name: "createStream",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_CreateStream_595007,
    base: "/", url: url_CreateStream_595008, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeStream_594976 = ref object of OpenApiRestCall_593437
proc url_DescribeStream_594978(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeStream_594977(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets information about a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_594979 = path.getOrDefault("streamId")
  valid_594979 = validateParameter(valid_594979, JString, required = true,
                                 default = nil)
  if valid_594979 != nil:
    section.add "streamId", valid_594979
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594980 = header.getOrDefault("X-Amz-Date")
  valid_594980 = validateParameter(valid_594980, JString, required = false,
                                 default = nil)
  if valid_594980 != nil:
    section.add "X-Amz-Date", valid_594980
  var valid_594981 = header.getOrDefault("X-Amz-Security-Token")
  valid_594981 = validateParameter(valid_594981, JString, required = false,
                                 default = nil)
  if valid_594981 != nil:
    section.add "X-Amz-Security-Token", valid_594981
  var valid_594982 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594982 = validateParameter(valid_594982, JString, required = false,
                                 default = nil)
  if valid_594982 != nil:
    section.add "X-Amz-Content-Sha256", valid_594982
  var valid_594983 = header.getOrDefault("X-Amz-Algorithm")
  valid_594983 = validateParameter(valid_594983, JString, required = false,
                                 default = nil)
  if valid_594983 != nil:
    section.add "X-Amz-Algorithm", valid_594983
  var valid_594984 = header.getOrDefault("X-Amz-Signature")
  valid_594984 = validateParameter(valid_594984, JString, required = false,
                                 default = nil)
  if valid_594984 != nil:
    section.add "X-Amz-Signature", valid_594984
  var valid_594985 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594985 = validateParameter(valid_594985, JString, required = false,
                                 default = nil)
  if valid_594985 != nil:
    section.add "X-Amz-SignedHeaders", valid_594985
  var valid_594986 = header.getOrDefault("X-Amz-Credential")
  valid_594986 = validateParameter(valid_594986, JString, required = false,
                                 default = nil)
  if valid_594986 != nil:
    section.add "X-Amz-Credential", valid_594986
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594987: Call_DescribeStream_594976; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a stream.
  ## 
  let valid = call_594987.validator(path, query, header, formData, body)
  let scheme = call_594987.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594987.url(scheme.get, call_594987.host, call_594987.base,
                         call_594987.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594987, url, valid)

proc call*(call_594988: Call_DescribeStream_594976; streamId: string): Recallable =
  ## describeStream
  ## Gets information about a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_594989 = newJObject()
  add(path_594989, "streamId", newJString(streamId))
  result = call_594988.call(path_594989, nil, nil, nil, nil)

var describeStream* = Call_DescribeStream_594976(name: "describeStream",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_DescribeStream_594977,
    base: "/", url: url_DescribeStream_594978, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteStream_595022 = ref object of OpenApiRestCall_593437
proc url_DeleteStream_595024(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteStream_595023(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_595025 = path.getOrDefault("streamId")
  valid_595025 = validateParameter(valid_595025, JString, required = true,
                                 default = nil)
  if valid_595025 != nil:
    section.add "streamId", valid_595025
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595026 = header.getOrDefault("X-Amz-Date")
  valid_595026 = validateParameter(valid_595026, JString, required = false,
                                 default = nil)
  if valid_595026 != nil:
    section.add "X-Amz-Date", valid_595026
  var valid_595027 = header.getOrDefault("X-Amz-Security-Token")
  valid_595027 = validateParameter(valid_595027, JString, required = false,
                                 default = nil)
  if valid_595027 != nil:
    section.add "X-Amz-Security-Token", valid_595027
  var valid_595028 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595028 = validateParameter(valid_595028, JString, required = false,
                                 default = nil)
  if valid_595028 != nil:
    section.add "X-Amz-Content-Sha256", valid_595028
  var valid_595029 = header.getOrDefault("X-Amz-Algorithm")
  valid_595029 = validateParameter(valid_595029, JString, required = false,
                                 default = nil)
  if valid_595029 != nil:
    section.add "X-Amz-Algorithm", valid_595029
  var valid_595030 = header.getOrDefault("X-Amz-Signature")
  valid_595030 = validateParameter(valid_595030, JString, required = false,
                                 default = nil)
  if valid_595030 != nil:
    section.add "X-Amz-Signature", valid_595030
  var valid_595031 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595031 = validateParameter(valid_595031, JString, required = false,
                                 default = nil)
  if valid_595031 != nil:
    section.add "X-Amz-SignedHeaders", valid_595031
  var valid_595032 = header.getOrDefault("X-Amz-Credential")
  valid_595032 = validateParameter(valid_595032, JString, required = false,
                                 default = nil)
  if valid_595032 != nil:
    section.add "X-Amz-Credential", valid_595032
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595033: Call_DeleteStream_595022; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a stream.
  ## 
  let valid = call_595033.validator(path, query, header, formData, body)
  let scheme = call_595033.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595033.url(scheme.get, call_595033.host, call_595033.base,
                         call_595033.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595033, url, valid)

proc call*(call_595034: Call_DeleteStream_595022; streamId: string): Recallable =
  ## deleteStream
  ## Deletes a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_595035 = newJObject()
  add(path_595035, "streamId", newJString(streamId))
  result = call_595034.call(path_595035, nil, nil, nil, nil)

var deleteStream* = Call_DeleteStream_595022(name: "deleteStream",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_DeleteStream_595023,
    base: "/", url: url_DeleteStream_595024, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThing_595050 = ref object of OpenApiRestCall_593437
proc url_CreateThing_595052(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateThing_595051(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to create.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_595053 = path.getOrDefault("thingName")
  valid_595053 = validateParameter(valid_595053, JString, required = true,
                                 default = nil)
  if valid_595053 != nil:
    section.add "thingName", valid_595053
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595054 = header.getOrDefault("X-Amz-Date")
  valid_595054 = validateParameter(valid_595054, JString, required = false,
                                 default = nil)
  if valid_595054 != nil:
    section.add "X-Amz-Date", valid_595054
  var valid_595055 = header.getOrDefault("X-Amz-Security-Token")
  valid_595055 = validateParameter(valid_595055, JString, required = false,
                                 default = nil)
  if valid_595055 != nil:
    section.add "X-Amz-Security-Token", valid_595055
  var valid_595056 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595056 = validateParameter(valid_595056, JString, required = false,
                                 default = nil)
  if valid_595056 != nil:
    section.add "X-Amz-Content-Sha256", valid_595056
  var valid_595057 = header.getOrDefault("X-Amz-Algorithm")
  valid_595057 = validateParameter(valid_595057, JString, required = false,
                                 default = nil)
  if valid_595057 != nil:
    section.add "X-Amz-Algorithm", valid_595057
  var valid_595058 = header.getOrDefault("X-Amz-Signature")
  valid_595058 = validateParameter(valid_595058, JString, required = false,
                                 default = nil)
  if valid_595058 != nil:
    section.add "X-Amz-Signature", valid_595058
  var valid_595059 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595059 = validateParameter(valid_595059, JString, required = false,
                                 default = nil)
  if valid_595059 != nil:
    section.add "X-Amz-SignedHeaders", valid_595059
  var valid_595060 = header.getOrDefault("X-Amz-Credential")
  valid_595060 = validateParameter(valid_595060, JString, required = false,
                                 default = nil)
  if valid_595060 != nil:
    section.add "X-Amz-Credential", valid_595060
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595062: Call_CreateThing_595050; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  let valid = call_595062.validator(path, query, header, formData, body)
  let scheme = call_595062.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595062.url(scheme.get, call_595062.host, call_595062.base,
                         call_595062.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595062, url, valid)

proc call*(call_595063: Call_CreateThing_595050; thingName: string; body: JsonNode): Recallable =
  ## createThing
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing to create.
  ##   body: JObject (required)
  var path_595064 = newJObject()
  var body_595065 = newJObject()
  add(path_595064, "thingName", newJString(thingName))
  if body != nil:
    body_595065 = body
  result = call_595063.call(path_595064, nil, nil, nil, body_595065)

var createThing* = Call_CreateThing_595050(name: "createThing",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_CreateThing_595051,
                                        base: "/", url: url_CreateThing_595052,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThing_595036 = ref object of OpenApiRestCall_593437
proc url_DescribeThing_595038(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeThing_595037(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the specified thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_595039 = path.getOrDefault("thingName")
  valid_595039 = validateParameter(valid_595039, JString, required = true,
                                 default = nil)
  if valid_595039 != nil:
    section.add "thingName", valid_595039
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595040 = header.getOrDefault("X-Amz-Date")
  valid_595040 = validateParameter(valid_595040, JString, required = false,
                                 default = nil)
  if valid_595040 != nil:
    section.add "X-Amz-Date", valid_595040
  var valid_595041 = header.getOrDefault("X-Amz-Security-Token")
  valid_595041 = validateParameter(valid_595041, JString, required = false,
                                 default = nil)
  if valid_595041 != nil:
    section.add "X-Amz-Security-Token", valid_595041
  var valid_595042 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595042 = validateParameter(valid_595042, JString, required = false,
                                 default = nil)
  if valid_595042 != nil:
    section.add "X-Amz-Content-Sha256", valid_595042
  var valid_595043 = header.getOrDefault("X-Amz-Algorithm")
  valid_595043 = validateParameter(valid_595043, JString, required = false,
                                 default = nil)
  if valid_595043 != nil:
    section.add "X-Amz-Algorithm", valid_595043
  var valid_595044 = header.getOrDefault("X-Amz-Signature")
  valid_595044 = validateParameter(valid_595044, JString, required = false,
                                 default = nil)
  if valid_595044 != nil:
    section.add "X-Amz-Signature", valid_595044
  var valid_595045 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595045 = validateParameter(valid_595045, JString, required = false,
                                 default = nil)
  if valid_595045 != nil:
    section.add "X-Amz-SignedHeaders", valid_595045
  var valid_595046 = header.getOrDefault("X-Amz-Credential")
  valid_595046 = validateParameter(valid_595046, JString, required = false,
                                 default = nil)
  if valid_595046 != nil:
    section.add "X-Amz-Credential", valid_595046
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595047: Call_DescribeThing_595036; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified thing.
  ## 
  let valid = call_595047.validator(path, query, header, formData, body)
  let scheme = call_595047.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595047.url(scheme.get, call_595047.host, call_595047.base,
                         call_595047.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595047, url, valid)

proc call*(call_595048: Call_DescribeThing_595036; thingName: string): Recallable =
  ## describeThing
  ## Gets information about the specified thing.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_595049 = newJObject()
  add(path_595049, "thingName", newJString(thingName))
  result = call_595048.call(path_595049, nil, nil, nil, nil)

var describeThing* = Call_DescribeThing_595036(name: "describeThing",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/things/{thingName}", validator: validate_DescribeThing_595037,
    base: "/", url: url_DescribeThing_595038, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThing_595082 = ref object of OpenApiRestCall_593437
proc url_UpdateThing_595084(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateThing_595083(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the data for a thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_595085 = path.getOrDefault("thingName")
  valid_595085 = validateParameter(valid_595085, JString, required = true,
                                 default = nil)
  if valid_595085 != nil:
    section.add "thingName", valid_595085
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595086 = header.getOrDefault("X-Amz-Date")
  valid_595086 = validateParameter(valid_595086, JString, required = false,
                                 default = nil)
  if valid_595086 != nil:
    section.add "X-Amz-Date", valid_595086
  var valid_595087 = header.getOrDefault("X-Amz-Security-Token")
  valid_595087 = validateParameter(valid_595087, JString, required = false,
                                 default = nil)
  if valid_595087 != nil:
    section.add "X-Amz-Security-Token", valid_595087
  var valid_595088 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595088 = validateParameter(valid_595088, JString, required = false,
                                 default = nil)
  if valid_595088 != nil:
    section.add "X-Amz-Content-Sha256", valid_595088
  var valid_595089 = header.getOrDefault("X-Amz-Algorithm")
  valid_595089 = validateParameter(valid_595089, JString, required = false,
                                 default = nil)
  if valid_595089 != nil:
    section.add "X-Amz-Algorithm", valid_595089
  var valid_595090 = header.getOrDefault("X-Amz-Signature")
  valid_595090 = validateParameter(valid_595090, JString, required = false,
                                 default = nil)
  if valid_595090 != nil:
    section.add "X-Amz-Signature", valid_595090
  var valid_595091 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595091 = validateParameter(valid_595091, JString, required = false,
                                 default = nil)
  if valid_595091 != nil:
    section.add "X-Amz-SignedHeaders", valid_595091
  var valid_595092 = header.getOrDefault("X-Amz-Credential")
  valid_595092 = validateParameter(valid_595092, JString, required = false,
                                 default = nil)
  if valid_595092 != nil:
    section.add "X-Amz-Credential", valid_595092
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595094: Call_UpdateThing_595082; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the data for a thing.
  ## 
  let valid = call_595094.validator(path, query, header, formData, body)
  let scheme = call_595094.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595094.url(scheme.get, call_595094.host, call_595094.base,
                         call_595094.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595094, url, valid)

proc call*(call_595095: Call_UpdateThing_595082; thingName: string; body: JsonNode): Recallable =
  ## updateThing
  ## Updates the data for a thing.
  ##   thingName: string (required)
  ##            : The name of the thing to update.
  ##   body: JObject (required)
  var path_595096 = newJObject()
  var body_595097 = newJObject()
  add(path_595096, "thingName", newJString(thingName))
  if body != nil:
    body_595097 = body
  result = call_595095.call(path_595096, nil, nil, nil, body_595097)

var updateThing* = Call_UpdateThing_595082(name: "updateThing",
                                        meth: HttpMethod.HttpPatch,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_UpdateThing_595083,
                                        base: "/", url: url_UpdateThing_595084,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThing_595066 = ref object of OpenApiRestCall_593437
proc url_DeleteThing_595068(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteThing_595067(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_595069 = path.getOrDefault("thingName")
  valid_595069 = validateParameter(valid_595069, JString, required = true,
                                 default = nil)
  if valid_595069 != nil:
    section.add "thingName", valid_595069
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.
  section = newJObject()
  var valid_595070 = query.getOrDefault("expectedVersion")
  valid_595070 = validateParameter(valid_595070, JInt, required = false, default = nil)
  if valid_595070 != nil:
    section.add "expectedVersion", valid_595070
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595071 = header.getOrDefault("X-Amz-Date")
  valid_595071 = validateParameter(valid_595071, JString, required = false,
                                 default = nil)
  if valid_595071 != nil:
    section.add "X-Amz-Date", valid_595071
  var valid_595072 = header.getOrDefault("X-Amz-Security-Token")
  valid_595072 = validateParameter(valid_595072, JString, required = false,
                                 default = nil)
  if valid_595072 != nil:
    section.add "X-Amz-Security-Token", valid_595072
  var valid_595073 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595073 = validateParameter(valid_595073, JString, required = false,
                                 default = nil)
  if valid_595073 != nil:
    section.add "X-Amz-Content-Sha256", valid_595073
  var valid_595074 = header.getOrDefault("X-Amz-Algorithm")
  valid_595074 = validateParameter(valid_595074, JString, required = false,
                                 default = nil)
  if valid_595074 != nil:
    section.add "X-Amz-Algorithm", valid_595074
  var valid_595075 = header.getOrDefault("X-Amz-Signature")
  valid_595075 = validateParameter(valid_595075, JString, required = false,
                                 default = nil)
  if valid_595075 != nil:
    section.add "X-Amz-Signature", valid_595075
  var valid_595076 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595076 = validateParameter(valid_595076, JString, required = false,
                                 default = nil)
  if valid_595076 != nil:
    section.add "X-Amz-SignedHeaders", valid_595076
  var valid_595077 = header.getOrDefault("X-Amz-Credential")
  valid_595077 = validateParameter(valid_595077, JString, required = false,
                                 default = nil)
  if valid_595077 != nil:
    section.add "X-Amz-Credential", valid_595077
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595078: Call_DeleteThing_595066; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ## 
  let valid = call_595078.validator(path, query, header, formData, body)
  let scheme = call_595078.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595078.url(scheme.get, call_595078.host, call_595078.base,
                         call_595078.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595078, url, valid)

proc call*(call_595079: Call_DeleteThing_595066; thingName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteThing
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ##   expectedVersion: int
  ##                  : The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.
  ##   thingName: string (required)
  ##            : The name of the thing to delete.
  var path_595080 = newJObject()
  var query_595081 = newJObject()
  add(query_595081, "expectedVersion", newJInt(expectedVersion))
  add(path_595080, "thingName", newJString(thingName))
  result = call_595079.call(path_595080, query_595081, nil, nil, nil)

var deleteThing* = Call_DeleteThing_595066(name: "deleteThing",
                                        meth: HttpMethod.HttpDelete,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_DeleteThing_595067,
                                        base: "/", url: url_DeleteThing_595068,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThingGroup_595112 = ref object of OpenApiRestCall_593437
proc url_CreateThingGroup_595114(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateThingGroup_595113(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group name to create.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_595115 = path.getOrDefault("thingGroupName")
  valid_595115 = validateParameter(valid_595115, JString, required = true,
                                 default = nil)
  if valid_595115 != nil:
    section.add "thingGroupName", valid_595115
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595116 = header.getOrDefault("X-Amz-Date")
  valid_595116 = validateParameter(valid_595116, JString, required = false,
                                 default = nil)
  if valid_595116 != nil:
    section.add "X-Amz-Date", valid_595116
  var valid_595117 = header.getOrDefault("X-Amz-Security-Token")
  valid_595117 = validateParameter(valid_595117, JString, required = false,
                                 default = nil)
  if valid_595117 != nil:
    section.add "X-Amz-Security-Token", valid_595117
  var valid_595118 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595118 = validateParameter(valid_595118, JString, required = false,
                                 default = nil)
  if valid_595118 != nil:
    section.add "X-Amz-Content-Sha256", valid_595118
  var valid_595119 = header.getOrDefault("X-Amz-Algorithm")
  valid_595119 = validateParameter(valid_595119, JString, required = false,
                                 default = nil)
  if valid_595119 != nil:
    section.add "X-Amz-Algorithm", valid_595119
  var valid_595120 = header.getOrDefault("X-Amz-Signature")
  valid_595120 = validateParameter(valid_595120, JString, required = false,
                                 default = nil)
  if valid_595120 != nil:
    section.add "X-Amz-Signature", valid_595120
  var valid_595121 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595121 = validateParameter(valid_595121, JString, required = false,
                                 default = nil)
  if valid_595121 != nil:
    section.add "X-Amz-SignedHeaders", valid_595121
  var valid_595122 = header.getOrDefault("X-Amz-Credential")
  valid_595122 = validateParameter(valid_595122, JString, required = false,
                                 default = nil)
  if valid_595122 != nil:
    section.add "X-Amz-Credential", valid_595122
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595124: Call_CreateThingGroup_595112; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  let valid = call_595124.validator(path, query, header, formData, body)
  let scheme = call_595124.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595124.url(scheme.get, call_595124.host, call_595124.base,
                         call_595124.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595124, url, valid)

proc call*(call_595125: Call_CreateThingGroup_595112; body: JsonNode;
          thingGroupName: string): Recallable =
  ## createThingGroup
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ##   body: JObject (required)
  ##   thingGroupName: string (required)
  ##                 : The thing group name to create.
  var path_595126 = newJObject()
  var body_595127 = newJObject()
  if body != nil:
    body_595127 = body
  add(path_595126, "thingGroupName", newJString(thingGroupName))
  result = call_595125.call(path_595126, nil, nil, nil, body_595127)

var createThingGroup* = Call_CreateThingGroup_595112(name: "createThingGroup",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_CreateThingGroup_595113,
    base: "/", url: url_CreateThingGroup_595114,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingGroup_595098 = ref object of OpenApiRestCall_593437
proc url_DescribeThingGroup_595100(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeThingGroup_595099(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Describe a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the thing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_595101 = path.getOrDefault("thingGroupName")
  valid_595101 = validateParameter(valid_595101, JString, required = true,
                                 default = nil)
  if valid_595101 != nil:
    section.add "thingGroupName", valid_595101
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595102 = header.getOrDefault("X-Amz-Date")
  valid_595102 = validateParameter(valid_595102, JString, required = false,
                                 default = nil)
  if valid_595102 != nil:
    section.add "X-Amz-Date", valid_595102
  var valid_595103 = header.getOrDefault("X-Amz-Security-Token")
  valid_595103 = validateParameter(valid_595103, JString, required = false,
                                 default = nil)
  if valid_595103 != nil:
    section.add "X-Amz-Security-Token", valid_595103
  var valid_595104 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595104 = validateParameter(valid_595104, JString, required = false,
                                 default = nil)
  if valid_595104 != nil:
    section.add "X-Amz-Content-Sha256", valid_595104
  var valid_595105 = header.getOrDefault("X-Amz-Algorithm")
  valid_595105 = validateParameter(valid_595105, JString, required = false,
                                 default = nil)
  if valid_595105 != nil:
    section.add "X-Amz-Algorithm", valid_595105
  var valid_595106 = header.getOrDefault("X-Amz-Signature")
  valid_595106 = validateParameter(valid_595106, JString, required = false,
                                 default = nil)
  if valid_595106 != nil:
    section.add "X-Amz-Signature", valid_595106
  var valid_595107 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595107 = validateParameter(valid_595107, JString, required = false,
                                 default = nil)
  if valid_595107 != nil:
    section.add "X-Amz-SignedHeaders", valid_595107
  var valid_595108 = header.getOrDefault("X-Amz-Credential")
  valid_595108 = validateParameter(valid_595108, JString, required = false,
                                 default = nil)
  if valid_595108 != nil:
    section.add "X-Amz-Credential", valid_595108
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595109: Call_DescribeThingGroup_595098; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describe a thing group.
  ## 
  let valid = call_595109.validator(path, query, header, formData, body)
  let scheme = call_595109.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595109.url(scheme.get, call_595109.host, call_595109.base,
                         call_595109.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595109, url, valid)

proc call*(call_595110: Call_DescribeThingGroup_595098; thingGroupName: string): Recallable =
  ## describeThingGroup
  ## Describe a thing group.
  ##   thingGroupName: string (required)
  ##                 : The name of the thing group.
  var path_595111 = newJObject()
  add(path_595111, "thingGroupName", newJString(thingGroupName))
  result = call_595110.call(path_595111, nil, nil, nil, nil)

var describeThingGroup* = Call_DescribeThingGroup_595098(
    name: "describeThingGroup", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}",
    validator: validate_DescribeThingGroup_595099, base: "/",
    url: url_DescribeThingGroup_595100, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThingGroup_595144 = ref object of OpenApiRestCall_593437
proc url_UpdateThingGroup_595146(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateThingGroup_595145(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Update a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group to update.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_595147 = path.getOrDefault("thingGroupName")
  valid_595147 = validateParameter(valid_595147, JString, required = true,
                                 default = nil)
  if valid_595147 != nil:
    section.add "thingGroupName", valid_595147
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595148 = header.getOrDefault("X-Amz-Date")
  valid_595148 = validateParameter(valid_595148, JString, required = false,
                                 default = nil)
  if valid_595148 != nil:
    section.add "X-Amz-Date", valid_595148
  var valid_595149 = header.getOrDefault("X-Amz-Security-Token")
  valid_595149 = validateParameter(valid_595149, JString, required = false,
                                 default = nil)
  if valid_595149 != nil:
    section.add "X-Amz-Security-Token", valid_595149
  var valid_595150 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595150 = validateParameter(valid_595150, JString, required = false,
                                 default = nil)
  if valid_595150 != nil:
    section.add "X-Amz-Content-Sha256", valid_595150
  var valid_595151 = header.getOrDefault("X-Amz-Algorithm")
  valid_595151 = validateParameter(valid_595151, JString, required = false,
                                 default = nil)
  if valid_595151 != nil:
    section.add "X-Amz-Algorithm", valid_595151
  var valid_595152 = header.getOrDefault("X-Amz-Signature")
  valid_595152 = validateParameter(valid_595152, JString, required = false,
                                 default = nil)
  if valid_595152 != nil:
    section.add "X-Amz-Signature", valid_595152
  var valid_595153 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595153 = validateParameter(valid_595153, JString, required = false,
                                 default = nil)
  if valid_595153 != nil:
    section.add "X-Amz-SignedHeaders", valid_595153
  var valid_595154 = header.getOrDefault("X-Amz-Credential")
  valid_595154 = validateParameter(valid_595154, JString, required = false,
                                 default = nil)
  if valid_595154 != nil:
    section.add "X-Amz-Credential", valid_595154
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595156: Call_UpdateThingGroup_595144; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update a thing group.
  ## 
  let valid = call_595156.validator(path, query, header, formData, body)
  let scheme = call_595156.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595156.url(scheme.get, call_595156.host, call_595156.base,
                         call_595156.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595156, url, valid)

proc call*(call_595157: Call_UpdateThingGroup_595144; body: JsonNode;
          thingGroupName: string): Recallable =
  ## updateThingGroup
  ## Update a thing group.
  ##   body: JObject (required)
  ##   thingGroupName: string (required)
  ##                 : The thing group to update.
  var path_595158 = newJObject()
  var body_595159 = newJObject()
  if body != nil:
    body_595159 = body
  add(path_595158, "thingGroupName", newJString(thingGroupName))
  result = call_595157.call(path_595158, nil, nil, nil, body_595159)

var updateThingGroup* = Call_UpdateThingGroup_595144(name: "updateThingGroup",
    meth: HttpMethod.HttpPatch, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_UpdateThingGroup_595145,
    base: "/", url: url_UpdateThingGroup_595146,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThingGroup_595128 = ref object of OpenApiRestCall_593437
proc url_DeleteThingGroup_595130(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteThingGroup_595129(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Deletes a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the thing group to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_595131 = path.getOrDefault("thingGroupName")
  valid_595131 = validateParameter(valid_595131, JString, required = true,
                                 default = nil)
  if valid_595131 != nil:
    section.add "thingGroupName", valid_595131
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the thing group to delete.
  section = newJObject()
  var valid_595132 = query.getOrDefault("expectedVersion")
  valid_595132 = validateParameter(valid_595132, JInt, required = false, default = nil)
  if valid_595132 != nil:
    section.add "expectedVersion", valid_595132
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595133 = header.getOrDefault("X-Amz-Date")
  valid_595133 = validateParameter(valid_595133, JString, required = false,
                                 default = nil)
  if valid_595133 != nil:
    section.add "X-Amz-Date", valid_595133
  var valid_595134 = header.getOrDefault("X-Amz-Security-Token")
  valid_595134 = validateParameter(valid_595134, JString, required = false,
                                 default = nil)
  if valid_595134 != nil:
    section.add "X-Amz-Security-Token", valid_595134
  var valid_595135 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595135 = validateParameter(valid_595135, JString, required = false,
                                 default = nil)
  if valid_595135 != nil:
    section.add "X-Amz-Content-Sha256", valid_595135
  var valid_595136 = header.getOrDefault("X-Amz-Algorithm")
  valid_595136 = validateParameter(valid_595136, JString, required = false,
                                 default = nil)
  if valid_595136 != nil:
    section.add "X-Amz-Algorithm", valid_595136
  var valid_595137 = header.getOrDefault("X-Amz-Signature")
  valid_595137 = validateParameter(valid_595137, JString, required = false,
                                 default = nil)
  if valid_595137 != nil:
    section.add "X-Amz-Signature", valid_595137
  var valid_595138 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595138 = validateParameter(valid_595138, JString, required = false,
                                 default = nil)
  if valid_595138 != nil:
    section.add "X-Amz-SignedHeaders", valid_595138
  var valid_595139 = header.getOrDefault("X-Amz-Credential")
  valid_595139 = validateParameter(valid_595139, JString, required = false,
                                 default = nil)
  if valid_595139 != nil:
    section.add "X-Amz-Credential", valid_595139
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595140: Call_DeleteThingGroup_595128; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a thing group.
  ## 
  let valid = call_595140.validator(path, query, header, formData, body)
  let scheme = call_595140.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595140.url(scheme.get, call_595140.host, call_595140.base,
                         call_595140.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595140, url, valid)

proc call*(call_595141: Call_DeleteThingGroup_595128; thingGroupName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteThingGroup
  ## Deletes a thing group.
  ##   expectedVersion: int
  ##                  : The expected version of the thing group to delete.
  ##   thingGroupName: string (required)
  ##                 : The name of the thing group to delete.
  var path_595142 = newJObject()
  var query_595143 = newJObject()
  add(query_595143, "expectedVersion", newJInt(expectedVersion))
  add(path_595142, "thingGroupName", newJString(thingGroupName))
  result = call_595141.call(path_595142, query_595143, nil, nil, nil)

var deleteThingGroup* = Call_DeleteThingGroup_595128(name: "deleteThingGroup",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_DeleteThingGroup_595129,
    base: "/", url: url_DeleteThingGroup_595130,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThingType_595174 = ref object of OpenApiRestCall_593437
proc url_CreateThingType_595176(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateThingType_595175(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a new thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_595177 = path.getOrDefault("thingTypeName")
  valid_595177 = validateParameter(valid_595177, JString, required = true,
                                 default = nil)
  if valid_595177 != nil:
    section.add "thingTypeName", valid_595177
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595178 = header.getOrDefault("X-Amz-Date")
  valid_595178 = validateParameter(valid_595178, JString, required = false,
                                 default = nil)
  if valid_595178 != nil:
    section.add "X-Amz-Date", valid_595178
  var valid_595179 = header.getOrDefault("X-Amz-Security-Token")
  valid_595179 = validateParameter(valid_595179, JString, required = false,
                                 default = nil)
  if valid_595179 != nil:
    section.add "X-Amz-Security-Token", valid_595179
  var valid_595180 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595180 = validateParameter(valid_595180, JString, required = false,
                                 default = nil)
  if valid_595180 != nil:
    section.add "X-Amz-Content-Sha256", valid_595180
  var valid_595181 = header.getOrDefault("X-Amz-Algorithm")
  valid_595181 = validateParameter(valid_595181, JString, required = false,
                                 default = nil)
  if valid_595181 != nil:
    section.add "X-Amz-Algorithm", valid_595181
  var valid_595182 = header.getOrDefault("X-Amz-Signature")
  valid_595182 = validateParameter(valid_595182, JString, required = false,
                                 default = nil)
  if valid_595182 != nil:
    section.add "X-Amz-Signature", valid_595182
  var valid_595183 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595183 = validateParameter(valid_595183, JString, required = false,
                                 default = nil)
  if valid_595183 != nil:
    section.add "X-Amz-SignedHeaders", valid_595183
  var valid_595184 = header.getOrDefault("X-Amz-Credential")
  valid_595184 = validateParameter(valid_595184, JString, required = false,
                                 default = nil)
  if valid_595184 != nil:
    section.add "X-Amz-Credential", valid_595184
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595186: Call_CreateThingType_595174; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new thing type.
  ## 
  let valid = call_595186.validator(path, query, header, formData, body)
  let scheme = call_595186.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595186.url(scheme.get, call_595186.host, call_595186.base,
                         call_595186.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595186, url, valid)

proc call*(call_595187: Call_CreateThingType_595174; body: JsonNode;
          thingTypeName: string): Recallable =
  ## createThingType
  ## Creates a new thing type.
  ##   body: JObject (required)
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_595188 = newJObject()
  var body_595189 = newJObject()
  if body != nil:
    body_595189 = body
  add(path_595188, "thingTypeName", newJString(thingTypeName))
  result = call_595187.call(path_595188, nil, nil, nil, body_595189)

var createThingType* = Call_CreateThingType_595174(name: "createThingType",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_CreateThingType_595175,
    base: "/", url: url_CreateThingType_595176, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingType_595160 = ref object of OpenApiRestCall_593437
proc url_DescribeThingType_595162(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeThingType_595161(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Gets information about the specified thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_595163 = path.getOrDefault("thingTypeName")
  valid_595163 = validateParameter(valid_595163, JString, required = true,
                                 default = nil)
  if valid_595163 != nil:
    section.add "thingTypeName", valid_595163
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595164 = header.getOrDefault("X-Amz-Date")
  valid_595164 = validateParameter(valid_595164, JString, required = false,
                                 default = nil)
  if valid_595164 != nil:
    section.add "X-Amz-Date", valid_595164
  var valid_595165 = header.getOrDefault("X-Amz-Security-Token")
  valid_595165 = validateParameter(valid_595165, JString, required = false,
                                 default = nil)
  if valid_595165 != nil:
    section.add "X-Amz-Security-Token", valid_595165
  var valid_595166 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595166 = validateParameter(valid_595166, JString, required = false,
                                 default = nil)
  if valid_595166 != nil:
    section.add "X-Amz-Content-Sha256", valid_595166
  var valid_595167 = header.getOrDefault("X-Amz-Algorithm")
  valid_595167 = validateParameter(valid_595167, JString, required = false,
                                 default = nil)
  if valid_595167 != nil:
    section.add "X-Amz-Algorithm", valid_595167
  var valid_595168 = header.getOrDefault("X-Amz-Signature")
  valid_595168 = validateParameter(valid_595168, JString, required = false,
                                 default = nil)
  if valid_595168 != nil:
    section.add "X-Amz-Signature", valid_595168
  var valid_595169 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595169 = validateParameter(valid_595169, JString, required = false,
                                 default = nil)
  if valid_595169 != nil:
    section.add "X-Amz-SignedHeaders", valid_595169
  var valid_595170 = header.getOrDefault("X-Amz-Credential")
  valid_595170 = validateParameter(valid_595170, JString, required = false,
                                 default = nil)
  if valid_595170 != nil:
    section.add "X-Amz-Credential", valid_595170
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595171: Call_DescribeThingType_595160; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified thing type.
  ## 
  let valid = call_595171.validator(path, query, header, formData, body)
  let scheme = call_595171.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595171.url(scheme.get, call_595171.host, call_595171.base,
                         call_595171.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595171, url, valid)

proc call*(call_595172: Call_DescribeThingType_595160; thingTypeName: string): Recallable =
  ## describeThingType
  ## Gets information about the specified thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_595173 = newJObject()
  add(path_595173, "thingTypeName", newJString(thingTypeName))
  result = call_595172.call(path_595173, nil, nil, nil, nil)

var describeThingType* = Call_DescribeThingType_595160(name: "describeThingType",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_DescribeThingType_595161,
    base: "/", url: url_DescribeThingType_595162,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThingType_595190 = ref object of OpenApiRestCall_593437
proc url_DeleteThingType_595192(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteThingType_595191(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_595193 = path.getOrDefault("thingTypeName")
  valid_595193 = validateParameter(valid_595193, JString, required = true,
                                 default = nil)
  if valid_595193 != nil:
    section.add "thingTypeName", valid_595193
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595194 = header.getOrDefault("X-Amz-Date")
  valid_595194 = validateParameter(valid_595194, JString, required = false,
                                 default = nil)
  if valid_595194 != nil:
    section.add "X-Amz-Date", valid_595194
  var valid_595195 = header.getOrDefault("X-Amz-Security-Token")
  valid_595195 = validateParameter(valid_595195, JString, required = false,
                                 default = nil)
  if valid_595195 != nil:
    section.add "X-Amz-Security-Token", valid_595195
  var valid_595196 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595196 = validateParameter(valid_595196, JString, required = false,
                                 default = nil)
  if valid_595196 != nil:
    section.add "X-Amz-Content-Sha256", valid_595196
  var valid_595197 = header.getOrDefault("X-Amz-Algorithm")
  valid_595197 = validateParameter(valid_595197, JString, required = false,
                                 default = nil)
  if valid_595197 != nil:
    section.add "X-Amz-Algorithm", valid_595197
  var valid_595198 = header.getOrDefault("X-Amz-Signature")
  valid_595198 = validateParameter(valid_595198, JString, required = false,
                                 default = nil)
  if valid_595198 != nil:
    section.add "X-Amz-Signature", valid_595198
  var valid_595199 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595199 = validateParameter(valid_595199, JString, required = false,
                                 default = nil)
  if valid_595199 != nil:
    section.add "X-Amz-SignedHeaders", valid_595199
  var valid_595200 = header.getOrDefault("X-Amz-Credential")
  valid_595200 = validateParameter(valid_595200, JString, required = false,
                                 default = nil)
  if valid_595200 != nil:
    section.add "X-Amz-Credential", valid_595200
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595201: Call_DeleteThingType_595190; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ## 
  let valid = call_595201.validator(path, query, header, formData, body)
  let scheme = call_595201.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595201.url(scheme.get, call_595201.host, call_595201.base,
                         call_595201.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595201, url, valid)

proc call*(call_595202: Call_DeleteThingType_595190; thingTypeName: string): Recallable =
  ## deleteThingType
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_595203 = newJObject()
  add(path_595203, "thingTypeName", newJString(thingTypeName))
  result = call_595202.call(path_595203, nil, nil, nil, nil)

var deleteThingType* = Call_DeleteThingType_595190(name: "deleteThingType",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_DeleteThingType_595191,
    base: "/", url: url_DeleteThingType_595192, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateTopicRule_595218 = ref object of OpenApiRestCall_593437
proc url_CreateTopicRule_595220(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateTopicRule_595219(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_595221 = path.getOrDefault("ruleName")
  valid_595221 = validateParameter(valid_595221, JString, required = true,
                                 default = nil)
  if valid_595221 != nil:
    section.add "ruleName", valid_595221
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   x-amz-tagging: JString
  ##                : <p>Metadata which can be used to manage the topic rule.</p> <note> <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p> <p>For the CLI command-line parameter use format: --tags "key1=value1&amp;key2=value2..."</p> <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p> </note>
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595222 = header.getOrDefault("X-Amz-Date")
  valid_595222 = validateParameter(valid_595222, JString, required = false,
                                 default = nil)
  if valid_595222 != nil:
    section.add "X-Amz-Date", valid_595222
  var valid_595223 = header.getOrDefault("X-Amz-Security-Token")
  valid_595223 = validateParameter(valid_595223, JString, required = false,
                                 default = nil)
  if valid_595223 != nil:
    section.add "X-Amz-Security-Token", valid_595223
  var valid_595224 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595224 = validateParameter(valid_595224, JString, required = false,
                                 default = nil)
  if valid_595224 != nil:
    section.add "X-Amz-Content-Sha256", valid_595224
  var valid_595225 = header.getOrDefault("X-Amz-Algorithm")
  valid_595225 = validateParameter(valid_595225, JString, required = false,
                                 default = nil)
  if valid_595225 != nil:
    section.add "X-Amz-Algorithm", valid_595225
  var valid_595226 = header.getOrDefault("X-Amz-Signature")
  valid_595226 = validateParameter(valid_595226, JString, required = false,
                                 default = nil)
  if valid_595226 != nil:
    section.add "X-Amz-Signature", valid_595226
  var valid_595227 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595227 = validateParameter(valid_595227, JString, required = false,
                                 default = nil)
  if valid_595227 != nil:
    section.add "X-Amz-SignedHeaders", valid_595227
  var valid_595228 = header.getOrDefault("x-amz-tagging")
  valid_595228 = validateParameter(valid_595228, JString, required = false,
                                 default = nil)
  if valid_595228 != nil:
    section.add "x-amz-tagging", valid_595228
  var valid_595229 = header.getOrDefault("X-Amz-Credential")
  valid_595229 = validateParameter(valid_595229, JString, required = false,
                                 default = nil)
  if valid_595229 != nil:
    section.add "X-Amz-Credential", valid_595229
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595231: Call_CreateTopicRule_595218; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  let valid = call_595231.validator(path, query, header, formData, body)
  let scheme = call_595231.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595231.url(scheme.get, call_595231.host, call_595231.base,
                         call_595231.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595231, url, valid)

proc call*(call_595232: Call_CreateTopicRule_595218; ruleName: string; body: JsonNode): Recallable =
  ## createTopicRule
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  ##   body: JObject (required)
  var path_595233 = newJObject()
  var body_595234 = newJObject()
  add(path_595233, "ruleName", newJString(ruleName))
  if body != nil:
    body_595234 = body
  result = call_595232.call(path_595233, nil, nil, nil, body_595234)

var createTopicRule* = Call_CreateTopicRule_595218(name: "createTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_CreateTopicRule_595219,
    base: "/", url: url_CreateTopicRule_595220, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetTopicRule_595204 = ref object of OpenApiRestCall_593437
proc url_GetTopicRule_595206(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetTopicRule_595205(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_595207 = path.getOrDefault("ruleName")
  valid_595207 = validateParameter(valid_595207, JString, required = true,
                                 default = nil)
  if valid_595207 != nil:
    section.add "ruleName", valid_595207
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595208 = header.getOrDefault("X-Amz-Date")
  valid_595208 = validateParameter(valid_595208, JString, required = false,
                                 default = nil)
  if valid_595208 != nil:
    section.add "X-Amz-Date", valid_595208
  var valid_595209 = header.getOrDefault("X-Amz-Security-Token")
  valid_595209 = validateParameter(valid_595209, JString, required = false,
                                 default = nil)
  if valid_595209 != nil:
    section.add "X-Amz-Security-Token", valid_595209
  var valid_595210 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595210 = validateParameter(valid_595210, JString, required = false,
                                 default = nil)
  if valid_595210 != nil:
    section.add "X-Amz-Content-Sha256", valid_595210
  var valid_595211 = header.getOrDefault("X-Amz-Algorithm")
  valid_595211 = validateParameter(valid_595211, JString, required = false,
                                 default = nil)
  if valid_595211 != nil:
    section.add "X-Amz-Algorithm", valid_595211
  var valid_595212 = header.getOrDefault("X-Amz-Signature")
  valid_595212 = validateParameter(valid_595212, JString, required = false,
                                 default = nil)
  if valid_595212 != nil:
    section.add "X-Amz-Signature", valid_595212
  var valid_595213 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595213 = validateParameter(valid_595213, JString, required = false,
                                 default = nil)
  if valid_595213 != nil:
    section.add "X-Amz-SignedHeaders", valid_595213
  var valid_595214 = header.getOrDefault("X-Amz-Credential")
  valid_595214 = validateParameter(valid_595214, JString, required = false,
                                 default = nil)
  if valid_595214 != nil:
    section.add "X-Amz-Credential", valid_595214
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595215: Call_GetTopicRule_595204; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the rule.
  ## 
  let valid = call_595215.validator(path, query, header, formData, body)
  let scheme = call_595215.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595215.url(scheme.get, call_595215.host, call_595215.base,
                         call_595215.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595215, url, valid)

proc call*(call_595216: Call_GetTopicRule_595204; ruleName: string): Recallable =
  ## getTopicRule
  ## Gets information about the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  var path_595217 = newJObject()
  add(path_595217, "ruleName", newJString(ruleName))
  result = call_595216.call(path_595217, nil, nil, nil, nil)

var getTopicRule* = Call_GetTopicRule_595204(name: "getTopicRule",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/rules/{ruleName}",
    validator: validate_GetTopicRule_595205, base: "/", url: url_GetTopicRule_595206,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReplaceTopicRule_595249 = ref object of OpenApiRestCall_593437
proc url_ReplaceTopicRule_595251(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReplaceTopicRule_595250(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_595252 = path.getOrDefault("ruleName")
  valid_595252 = validateParameter(valid_595252, JString, required = true,
                                 default = nil)
  if valid_595252 != nil:
    section.add "ruleName", valid_595252
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595253 = header.getOrDefault("X-Amz-Date")
  valid_595253 = validateParameter(valid_595253, JString, required = false,
                                 default = nil)
  if valid_595253 != nil:
    section.add "X-Amz-Date", valid_595253
  var valid_595254 = header.getOrDefault("X-Amz-Security-Token")
  valid_595254 = validateParameter(valid_595254, JString, required = false,
                                 default = nil)
  if valid_595254 != nil:
    section.add "X-Amz-Security-Token", valid_595254
  var valid_595255 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595255 = validateParameter(valid_595255, JString, required = false,
                                 default = nil)
  if valid_595255 != nil:
    section.add "X-Amz-Content-Sha256", valid_595255
  var valid_595256 = header.getOrDefault("X-Amz-Algorithm")
  valid_595256 = validateParameter(valid_595256, JString, required = false,
                                 default = nil)
  if valid_595256 != nil:
    section.add "X-Amz-Algorithm", valid_595256
  var valid_595257 = header.getOrDefault("X-Amz-Signature")
  valid_595257 = validateParameter(valid_595257, JString, required = false,
                                 default = nil)
  if valid_595257 != nil:
    section.add "X-Amz-Signature", valid_595257
  var valid_595258 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595258 = validateParameter(valid_595258, JString, required = false,
                                 default = nil)
  if valid_595258 != nil:
    section.add "X-Amz-SignedHeaders", valid_595258
  var valid_595259 = header.getOrDefault("X-Amz-Credential")
  valid_595259 = validateParameter(valid_595259, JString, required = false,
                                 default = nil)
  if valid_595259 != nil:
    section.add "X-Amz-Credential", valid_595259
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595261: Call_ReplaceTopicRule_595249; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  let valid = call_595261.validator(path, query, header, formData, body)
  let scheme = call_595261.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595261.url(scheme.get, call_595261.host, call_595261.base,
                         call_595261.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595261, url, valid)

proc call*(call_595262: Call_ReplaceTopicRule_595249; ruleName: string;
          body: JsonNode): Recallable =
  ## replaceTopicRule
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  ##   body: JObject (required)
  var path_595263 = newJObject()
  var body_595264 = newJObject()
  add(path_595263, "ruleName", newJString(ruleName))
  if body != nil:
    body_595264 = body
  result = call_595262.call(path_595263, nil, nil, nil, body_595264)

var replaceTopicRule* = Call_ReplaceTopicRule_595249(name: "replaceTopicRule",
    meth: HttpMethod.HttpPatch, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_ReplaceTopicRule_595250,
    base: "/", url: url_ReplaceTopicRule_595251,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteTopicRule_595235 = ref object of OpenApiRestCall_593437
proc url_DeleteTopicRule_595237(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteTopicRule_595236(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_595238 = path.getOrDefault("ruleName")
  valid_595238 = validateParameter(valid_595238, JString, required = true,
                                 default = nil)
  if valid_595238 != nil:
    section.add "ruleName", valid_595238
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595239 = header.getOrDefault("X-Amz-Date")
  valid_595239 = validateParameter(valid_595239, JString, required = false,
                                 default = nil)
  if valid_595239 != nil:
    section.add "X-Amz-Date", valid_595239
  var valid_595240 = header.getOrDefault("X-Amz-Security-Token")
  valid_595240 = validateParameter(valid_595240, JString, required = false,
                                 default = nil)
  if valid_595240 != nil:
    section.add "X-Amz-Security-Token", valid_595240
  var valid_595241 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595241 = validateParameter(valid_595241, JString, required = false,
                                 default = nil)
  if valid_595241 != nil:
    section.add "X-Amz-Content-Sha256", valid_595241
  var valid_595242 = header.getOrDefault("X-Amz-Algorithm")
  valid_595242 = validateParameter(valid_595242, JString, required = false,
                                 default = nil)
  if valid_595242 != nil:
    section.add "X-Amz-Algorithm", valid_595242
  var valid_595243 = header.getOrDefault("X-Amz-Signature")
  valid_595243 = validateParameter(valid_595243, JString, required = false,
                                 default = nil)
  if valid_595243 != nil:
    section.add "X-Amz-Signature", valid_595243
  var valid_595244 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595244 = validateParameter(valid_595244, JString, required = false,
                                 default = nil)
  if valid_595244 != nil:
    section.add "X-Amz-SignedHeaders", valid_595244
  var valid_595245 = header.getOrDefault("X-Amz-Credential")
  valid_595245 = validateParameter(valid_595245, JString, required = false,
                                 default = nil)
  if valid_595245 != nil:
    section.add "X-Amz-Credential", valid_595245
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595246: Call_DeleteTopicRule_595235; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the rule.
  ## 
  let valid = call_595246.validator(path, query, header, formData, body)
  let scheme = call_595246.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595246.url(scheme.get, call_595246.host, call_595246.base,
                         call_595246.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595246, url, valid)

proc call*(call_595247: Call_DeleteTopicRule_595235; ruleName: string): Recallable =
  ## deleteTopicRule
  ## Deletes the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  var path_595248 = newJObject()
  add(path_595248, "ruleName", newJString(ruleName))
  result = call_595247.call(path_595248, nil, nil, nil, nil)

var deleteTopicRule* = Call_DeleteTopicRule_595235(name: "deleteTopicRule",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_DeleteTopicRule_595236,
    base: "/", url: url_DeleteTopicRule_595237, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAccountAuditConfiguration_595265 = ref object of OpenApiRestCall_593437
proc url_DescribeAccountAuditConfiguration_595267(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DescribeAccountAuditConfiguration_595266(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595268 = header.getOrDefault("X-Amz-Date")
  valid_595268 = validateParameter(valid_595268, JString, required = false,
                                 default = nil)
  if valid_595268 != nil:
    section.add "X-Amz-Date", valid_595268
  var valid_595269 = header.getOrDefault("X-Amz-Security-Token")
  valid_595269 = validateParameter(valid_595269, JString, required = false,
                                 default = nil)
  if valid_595269 != nil:
    section.add "X-Amz-Security-Token", valid_595269
  var valid_595270 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595270 = validateParameter(valid_595270, JString, required = false,
                                 default = nil)
  if valid_595270 != nil:
    section.add "X-Amz-Content-Sha256", valid_595270
  var valid_595271 = header.getOrDefault("X-Amz-Algorithm")
  valid_595271 = validateParameter(valid_595271, JString, required = false,
                                 default = nil)
  if valid_595271 != nil:
    section.add "X-Amz-Algorithm", valid_595271
  var valid_595272 = header.getOrDefault("X-Amz-Signature")
  valid_595272 = validateParameter(valid_595272, JString, required = false,
                                 default = nil)
  if valid_595272 != nil:
    section.add "X-Amz-Signature", valid_595272
  var valid_595273 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595273 = validateParameter(valid_595273, JString, required = false,
                                 default = nil)
  if valid_595273 != nil:
    section.add "X-Amz-SignedHeaders", valid_595273
  var valid_595274 = header.getOrDefault("X-Amz-Credential")
  valid_595274 = validateParameter(valid_595274, JString, required = false,
                                 default = nil)
  if valid_595274 != nil:
    section.add "X-Amz-Credential", valid_595274
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595275: Call_DescribeAccountAuditConfiguration_595265;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  let valid = call_595275.validator(path, query, header, formData, body)
  let scheme = call_595275.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595275.url(scheme.get, call_595275.host, call_595275.base,
                         call_595275.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595275, url, valid)

proc call*(call_595276: Call_DescribeAccountAuditConfiguration_595265): Recallable =
  ## describeAccountAuditConfiguration
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  result = call_595276.call(nil, nil, nil, nil, nil)

var describeAccountAuditConfiguration* = Call_DescribeAccountAuditConfiguration_595265(
    name: "describeAccountAuditConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_DescribeAccountAuditConfiguration_595266, base: "/",
    url: url_DescribeAccountAuditConfiguration_595267,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateAccountAuditConfiguration_595291 = ref object of OpenApiRestCall_593437
proc url_UpdateAccountAuditConfiguration_595293(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateAccountAuditConfiguration_595292(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595294 = header.getOrDefault("X-Amz-Date")
  valid_595294 = validateParameter(valid_595294, JString, required = false,
                                 default = nil)
  if valid_595294 != nil:
    section.add "X-Amz-Date", valid_595294
  var valid_595295 = header.getOrDefault("X-Amz-Security-Token")
  valid_595295 = validateParameter(valid_595295, JString, required = false,
                                 default = nil)
  if valid_595295 != nil:
    section.add "X-Amz-Security-Token", valid_595295
  var valid_595296 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595296 = validateParameter(valid_595296, JString, required = false,
                                 default = nil)
  if valid_595296 != nil:
    section.add "X-Amz-Content-Sha256", valid_595296
  var valid_595297 = header.getOrDefault("X-Amz-Algorithm")
  valid_595297 = validateParameter(valid_595297, JString, required = false,
                                 default = nil)
  if valid_595297 != nil:
    section.add "X-Amz-Algorithm", valid_595297
  var valid_595298 = header.getOrDefault("X-Amz-Signature")
  valid_595298 = validateParameter(valid_595298, JString, required = false,
                                 default = nil)
  if valid_595298 != nil:
    section.add "X-Amz-Signature", valid_595298
  var valid_595299 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595299 = validateParameter(valid_595299, JString, required = false,
                                 default = nil)
  if valid_595299 != nil:
    section.add "X-Amz-SignedHeaders", valid_595299
  var valid_595300 = header.getOrDefault("X-Amz-Credential")
  valid_595300 = validateParameter(valid_595300, JString, required = false,
                                 default = nil)
  if valid_595300 != nil:
    section.add "X-Amz-Credential", valid_595300
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595302: Call_UpdateAccountAuditConfiguration_595291;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  let valid = call_595302.validator(path, query, header, formData, body)
  let scheme = call_595302.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595302.url(scheme.get, call_595302.host, call_595302.base,
                         call_595302.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595302, url, valid)

proc call*(call_595303: Call_UpdateAccountAuditConfiguration_595291; body: JsonNode): Recallable =
  ## updateAccountAuditConfiguration
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ##   body: JObject (required)
  var body_595304 = newJObject()
  if body != nil:
    body_595304 = body
  result = call_595303.call(nil, nil, nil, nil, body_595304)

var updateAccountAuditConfiguration* = Call_UpdateAccountAuditConfiguration_595291(
    name: "updateAccountAuditConfiguration", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_UpdateAccountAuditConfiguration_595292, base: "/",
    url: url_UpdateAccountAuditConfiguration_595293,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteAccountAuditConfiguration_595277 = ref object of OpenApiRestCall_593437
proc url_DeleteAccountAuditConfiguration_595279(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DeleteAccountAuditConfiguration_595278(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   deleteScheduledAudits: JBool
  ##                        : If true, all scheduled audits are deleted.
  section = newJObject()
  var valid_595280 = query.getOrDefault("deleteScheduledAudits")
  valid_595280 = validateParameter(valid_595280, JBool, required = false, default = nil)
  if valid_595280 != nil:
    section.add "deleteScheduledAudits", valid_595280
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595281 = header.getOrDefault("X-Amz-Date")
  valid_595281 = validateParameter(valid_595281, JString, required = false,
                                 default = nil)
  if valid_595281 != nil:
    section.add "X-Amz-Date", valid_595281
  var valid_595282 = header.getOrDefault("X-Amz-Security-Token")
  valid_595282 = validateParameter(valid_595282, JString, required = false,
                                 default = nil)
  if valid_595282 != nil:
    section.add "X-Amz-Security-Token", valid_595282
  var valid_595283 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595283 = validateParameter(valid_595283, JString, required = false,
                                 default = nil)
  if valid_595283 != nil:
    section.add "X-Amz-Content-Sha256", valid_595283
  var valid_595284 = header.getOrDefault("X-Amz-Algorithm")
  valid_595284 = validateParameter(valid_595284, JString, required = false,
                                 default = nil)
  if valid_595284 != nil:
    section.add "X-Amz-Algorithm", valid_595284
  var valid_595285 = header.getOrDefault("X-Amz-Signature")
  valid_595285 = validateParameter(valid_595285, JString, required = false,
                                 default = nil)
  if valid_595285 != nil:
    section.add "X-Amz-Signature", valid_595285
  var valid_595286 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595286 = validateParameter(valid_595286, JString, required = false,
                                 default = nil)
  if valid_595286 != nil:
    section.add "X-Amz-SignedHeaders", valid_595286
  var valid_595287 = header.getOrDefault("X-Amz-Credential")
  valid_595287 = validateParameter(valid_595287, JString, required = false,
                                 default = nil)
  if valid_595287 != nil:
    section.add "X-Amz-Credential", valid_595287
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595288: Call_DeleteAccountAuditConfiguration_595277;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ## 
  let valid = call_595288.validator(path, query, header, formData, body)
  let scheme = call_595288.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595288.url(scheme.get, call_595288.host, call_595288.base,
                         call_595288.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595288, url, valid)

proc call*(call_595289: Call_DeleteAccountAuditConfiguration_595277;
          deleteScheduledAudits: bool = false): Recallable =
  ## deleteAccountAuditConfiguration
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ##   deleteScheduledAudits: bool
  ##                        : If true, all scheduled audits are deleted.
  var query_595290 = newJObject()
  add(query_595290, "deleteScheduledAudits", newJBool(deleteScheduledAudits))
  result = call_595289.call(nil, query_595290, nil, nil, nil)

var deleteAccountAuditConfiguration* = Call_DeleteAccountAuditConfiguration_595277(
    name: "deleteAccountAuditConfiguration", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_DeleteAccountAuditConfiguration_595278, base: "/",
    url: url_DeleteAccountAuditConfiguration_595279,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateCACertificate_595319 = ref object of OpenApiRestCall_593437
proc url_UpdateCACertificate_595321(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateCACertificate_595320(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Updates a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The CA certificate identifier.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_595322 = path.getOrDefault("caCertificateId")
  valid_595322 = validateParameter(valid_595322, JString, required = true,
                                 default = nil)
  if valid_595322 != nil:
    section.add "caCertificateId", valid_595322
  result.add "path", section
  ## parameters in `query` object:
  ##   newStatus: JString
  ##            : <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  ##   newAutoRegistrationStatus: JString
  ##                            : The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
  section = newJObject()
  var valid_595336 = query.getOrDefault("newStatus")
  valid_595336 = validateParameter(valid_595336, JString, required = false,
                                 default = newJString("ACTIVE"))
  if valid_595336 != nil:
    section.add "newStatus", valid_595336
  var valid_595337 = query.getOrDefault("newAutoRegistrationStatus")
  valid_595337 = validateParameter(valid_595337, JString, required = false,
                                 default = newJString("ENABLE"))
  if valid_595337 != nil:
    section.add "newAutoRegistrationStatus", valid_595337
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595338 = header.getOrDefault("X-Amz-Date")
  valid_595338 = validateParameter(valid_595338, JString, required = false,
                                 default = nil)
  if valid_595338 != nil:
    section.add "X-Amz-Date", valid_595338
  var valid_595339 = header.getOrDefault("X-Amz-Security-Token")
  valid_595339 = validateParameter(valid_595339, JString, required = false,
                                 default = nil)
  if valid_595339 != nil:
    section.add "X-Amz-Security-Token", valid_595339
  var valid_595340 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595340 = validateParameter(valid_595340, JString, required = false,
                                 default = nil)
  if valid_595340 != nil:
    section.add "X-Amz-Content-Sha256", valid_595340
  var valid_595341 = header.getOrDefault("X-Amz-Algorithm")
  valid_595341 = validateParameter(valid_595341, JString, required = false,
                                 default = nil)
  if valid_595341 != nil:
    section.add "X-Amz-Algorithm", valid_595341
  var valid_595342 = header.getOrDefault("X-Amz-Signature")
  valid_595342 = validateParameter(valid_595342, JString, required = false,
                                 default = nil)
  if valid_595342 != nil:
    section.add "X-Amz-Signature", valid_595342
  var valid_595343 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595343 = validateParameter(valid_595343, JString, required = false,
                                 default = nil)
  if valid_595343 != nil:
    section.add "X-Amz-SignedHeaders", valid_595343
  var valid_595344 = header.getOrDefault("X-Amz-Credential")
  valid_595344 = validateParameter(valid_595344, JString, required = false,
                                 default = nil)
  if valid_595344 != nil:
    section.add "X-Amz-Credential", valid_595344
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595346: Call_UpdateCACertificate_595319; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a registered CA certificate.
  ## 
  let valid = call_595346.validator(path, query, header, formData, body)
  let scheme = call_595346.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595346.url(scheme.get, call_595346.host, call_595346.base,
                         call_595346.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595346, url, valid)

proc call*(call_595347: Call_UpdateCACertificate_595319; caCertificateId: string;
          body: JsonNode; newStatus: string = "ACTIVE";
          newAutoRegistrationStatus: string = "ENABLE"): Recallable =
  ## updateCACertificate
  ## Updates a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The CA certificate identifier.
  ##   body: JObject (required)
  ##   newStatus: string
  ##            : <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  ##   newAutoRegistrationStatus: string
  ##                            : The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
  var path_595348 = newJObject()
  var query_595349 = newJObject()
  var body_595350 = newJObject()
  add(path_595348, "caCertificateId", newJString(caCertificateId))
  if body != nil:
    body_595350 = body
  add(query_595349, "newStatus", newJString(newStatus))
  add(query_595349, "newAutoRegistrationStatus",
      newJString(newAutoRegistrationStatus))
  result = call_595347.call(path_595348, query_595349, nil, nil, body_595350)

var updateCACertificate* = Call_UpdateCACertificate_595319(
    name: "updateCACertificate", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_UpdateCACertificate_595320, base: "/",
    url: url_UpdateCACertificate_595321, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeCACertificate_595305 = ref object of OpenApiRestCall_593437
proc url_DescribeCACertificate_595307(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeCACertificate_595306(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The CA certificate identifier.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_595308 = path.getOrDefault("caCertificateId")
  valid_595308 = validateParameter(valid_595308, JString, required = true,
                                 default = nil)
  if valid_595308 != nil:
    section.add "caCertificateId", valid_595308
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595309 = header.getOrDefault("X-Amz-Date")
  valid_595309 = validateParameter(valid_595309, JString, required = false,
                                 default = nil)
  if valid_595309 != nil:
    section.add "X-Amz-Date", valid_595309
  var valid_595310 = header.getOrDefault("X-Amz-Security-Token")
  valid_595310 = validateParameter(valid_595310, JString, required = false,
                                 default = nil)
  if valid_595310 != nil:
    section.add "X-Amz-Security-Token", valid_595310
  var valid_595311 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595311 = validateParameter(valid_595311, JString, required = false,
                                 default = nil)
  if valid_595311 != nil:
    section.add "X-Amz-Content-Sha256", valid_595311
  var valid_595312 = header.getOrDefault("X-Amz-Algorithm")
  valid_595312 = validateParameter(valid_595312, JString, required = false,
                                 default = nil)
  if valid_595312 != nil:
    section.add "X-Amz-Algorithm", valid_595312
  var valid_595313 = header.getOrDefault("X-Amz-Signature")
  valid_595313 = validateParameter(valid_595313, JString, required = false,
                                 default = nil)
  if valid_595313 != nil:
    section.add "X-Amz-Signature", valid_595313
  var valid_595314 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595314 = validateParameter(valid_595314, JString, required = false,
                                 default = nil)
  if valid_595314 != nil:
    section.add "X-Amz-SignedHeaders", valid_595314
  var valid_595315 = header.getOrDefault("X-Amz-Credential")
  valid_595315 = validateParameter(valid_595315, JString, required = false,
                                 default = nil)
  if valid_595315 != nil:
    section.add "X-Amz-Credential", valid_595315
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595316: Call_DescribeCACertificate_595305; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a registered CA certificate.
  ## 
  let valid = call_595316.validator(path, query, header, formData, body)
  let scheme = call_595316.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595316.url(scheme.get, call_595316.host, call_595316.base,
                         call_595316.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595316, url, valid)

proc call*(call_595317: Call_DescribeCACertificate_595305; caCertificateId: string): Recallable =
  ## describeCACertificate
  ## Describes a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The CA certificate identifier.
  var path_595318 = newJObject()
  add(path_595318, "caCertificateId", newJString(caCertificateId))
  result = call_595317.call(path_595318, nil, nil, nil, nil)

var describeCACertificate* = Call_DescribeCACertificate_595305(
    name: "describeCACertificate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_DescribeCACertificate_595306, base: "/",
    url: url_DescribeCACertificate_595307, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteCACertificate_595351 = ref object of OpenApiRestCall_593437
proc url_DeleteCACertificate_595353(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteCACertificate_595352(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Deletes a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_595354 = path.getOrDefault("caCertificateId")
  valid_595354 = validateParameter(valid_595354, JString, required = true,
                                 default = nil)
  if valid_595354 != nil:
    section.add "caCertificateId", valid_595354
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595355 = header.getOrDefault("X-Amz-Date")
  valid_595355 = validateParameter(valid_595355, JString, required = false,
                                 default = nil)
  if valid_595355 != nil:
    section.add "X-Amz-Date", valid_595355
  var valid_595356 = header.getOrDefault("X-Amz-Security-Token")
  valid_595356 = validateParameter(valid_595356, JString, required = false,
                                 default = nil)
  if valid_595356 != nil:
    section.add "X-Amz-Security-Token", valid_595356
  var valid_595357 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595357 = validateParameter(valid_595357, JString, required = false,
                                 default = nil)
  if valid_595357 != nil:
    section.add "X-Amz-Content-Sha256", valid_595357
  var valid_595358 = header.getOrDefault("X-Amz-Algorithm")
  valid_595358 = validateParameter(valid_595358, JString, required = false,
                                 default = nil)
  if valid_595358 != nil:
    section.add "X-Amz-Algorithm", valid_595358
  var valid_595359 = header.getOrDefault("X-Amz-Signature")
  valid_595359 = validateParameter(valid_595359, JString, required = false,
                                 default = nil)
  if valid_595359 != nil:
    section.add "X-Amz-Signature", valid_595359
  var valid_595360 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595360 = validateParameter(valid_595360, JString, required = false,
                                 default = nil)
  if valid_595360 != nil:
    section.add "X-Amz-SignedHeaders", valid_595360
  var valid_595361 = header.getOrDefault("X-Amz-Credential")
  valid_595361 = validateParameter(valid_595361, JString, required = false,
                                 default = nil)
  if valid_595361 != nil:
    section.add "X-Amz-Credential", valid_595361
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595362: Call_DeleteCACertificate_595351; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a registered CA certificate.
  ## 
  let valid = call_595362.validator(path, query, header, formData, body)
  let scheme = call_595362.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595362.url(scheme.get, call_595362.host, call_595362.base,
                         call_595362.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595362, url, valid)

proc call*(call_595363: Call_DeleteCACertificate_595351; caCertificateId: string): Recallable =
  ## deleteCACertificate
  ## Deletes a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
  var path_595364 = newJObject()
  add(path_595364, "caCertificateId", newJString(caCertificateId))
  result = call_595363.call(path_595364, nil, nil, nil, nil)

var deleteCACertificate* = Call_DeleteCACertificate_595351(
    name: "deleteCACertificate", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_DeleteCACertificate_595352, base: "/",
    url: url_DeleteCACertificate_595353, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeCertificate_595365 = ref object of OpenApiRestCall_593437
proc url_DescribeCertificate_595367(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeCertificate_595366(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets information about the specified certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_595368 = path.getOrDefault("certificateId")
  valid_595368 = validateParameter(valid_595368, JString, required = true,
                                 default = nil)
  if valid_595368 != nil:
    section.add "certificateId", valid_595368
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595369 = header.getOrDefault("X-Amz-Date")
  valid_595369 = validateParameter(valid_595369, JString, required = false,
                                 default = nil)
  if valid_595369 != nil:
    section.add "X-Amz-Date", valid_595369
  var valid_595370 = header.getOrDefault("X-Amz-Security-Token")
  valid_595370 = validateParameter(valid_595370, JString, required = false,
                                 default = nil)
  if valid_595370 != nil:
    section.add "X-Amz-Security-Token", valid_595370
  var valid_595371 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595371 = validateParameter(valid_595371, JString, required = false,
                                 default = nil)
  if valid_595371 != nil:
    section.add "X-Amz-Content-Sha256", valid_595371
  var valid_595372 = header.getOrDefault("X-Amz-Algorithm")
  valid_595372 = validateParameter(valid_595372, JString, required = false,
                                 default = nil)
  if valid_595372 != nil:
    section.add "X-Amz-Algorithm", valid_595372
  var valid_595373 = header.getOrDefault("X-Amz-Signature")
  valid_595373 = validateParameter(valid_595373, JString, required = false,
                                 default = nil)
  if valid_595373 != nil:
    section.add "X-Amz-Signature", valid_595373
  var valid_595374 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595374 = validateParameter(valid_595374, JString, required = false,
                                 default = nil)
  if valid_595374 != nil:
    section.add "X-Amz-SignedHeaders", valid_595374
  var valid_595375 = header.getOrDefault("X-Amz-Credential")
  valid_595375 = validateParameter(valid_595375, JString, required = false,
                                 default = nil)
  if valid_595375 != nil:
    section.add "X-Amz-Credential", valid_595375
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595376: Call_DescribeCertificate_595365; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified certificate.
  ## 
  let valid = call_595376.validator(path, query, header, formData, body)
  let scheme = call_595376.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595376.url(scheme.get, call_595376.host, call_595376.base,
                         call_595376.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595376, url, valid)

proc call*(call_595377: Call_DescribeCertificate_595365; certificateId: string): Recallable =
  ## describeCertificate
  ## Gets information about the specified certificate.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_595378 = newJObject()
  add(path_595378, "certificateId", newJString(certificateId))
  result = call_595377.call(path_595378, nil, nil, nil, nil)

var describeCertificate* = Call_DescribeCertificate_595365(
    name: "describeCertificate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates/{certificateId}",
    validator: validate_DescribeCertificate_595366, base: "/",
    url: url_DescribeCertificate_595367, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteCertificate_595379 = ref object of OpenApiRestCall_593437
proc url_DeleteCertificate_595381(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteCertificate_595380(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_595382 = path.getOrDefault("certificateId")
  valid_595382 = validateParameter(valid_595382, JString, required = true,
                                 default = nil)
  if valid_595382 != nil:
    section.add "certificateId", valid_595382
  result.add "path", section
  ## parameters in `query` object:
  ##   forceDelete: JBool
  ##              : Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
  section = newJObject()
  var valid_595383 = query.getOrDefault("forceDelete")
  valid_595383 = validateParameter(valid_595383, JBool, required = false, default = nil)
  if valid_595383 != nil:
    section.add "forceDelete", valid_595383
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595384 = header.getOrDefault("X-Amz-Date")
  valid_595384 = validateParameter(valid_595384, JString, required = false,
                                 default = nil)
  if valid_595384 != nil:
    section.add "X-Amz-Date", valid_595384
  var valid_595385 = header.getOrDefault("X-Amz-Security-Token")
  valid_595385 = validateParameter(valid_595385, JString, required = false,
                                 default = nil)
  if valid_595385 != nil:
    section.add "X-Amz-Security-Token", valid_595385
  var valid_595386 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595386 = validateParameter(valid_595386, JString, required = false,
                                 default = nil)
  if valid_595386 != nil:
    section.add "X-Amz-Content-Sha256", valid_595386
  var valid_595387 = header.getOrDefault("X-Amz-Algorithm")
  valid_595387 = validateParameter(valid_595387, JString, required = false,
                                 default = nil)
  if valid_595387 != nil:
    section.add "X-Amz-Algorithm", valid_595387
  var valid_595388 = header.getOrDefault("X-Amz-Signature")
  valid_595388 = validateParameter(valid_595388, JString, required = false,
                                 default = nil)
  if valid_595388 != nil:
    section.add "X-Amz-Signature", valid_595388
  var valid_595389 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595389 = validateParameter(valid_595389, JString, required = false,
                                 default = nil)
  if valid_595389 != nil:
    section.add "X-Amz-SignedHeaders", valid_595389
  var valid_595390 = header.getOrDefault("X-Amz-Credential")
  valid_595390 = validateParameter(valid_595390, JString, required = false,
                                 default = nil)
  if valid_595390 != nil:
    section.add "X-Amz-Credential", valid_595390
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595391: Call_DeleteCertificate_595379; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ## 
  let valid = call_595391.validator(path, query, header, formData, body)
  let scheme = call_595391.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595391.url(scheme.get, call_595391.host, call_595391.base,
                         call_595391.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595391, url, valid)

proc call*(call_595392: Call_DeleteCertificate_595379; certificateId: string;
          forceDelete: bool = false): Recallable =
  ## deleteCertificate
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ##   forceDelete: bool
  ##              : Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_595393 = newJObject()
  var query_595394 = newJObject()
  add(query_595394, "forceDelete", newJBool(forceDelete))
  add(path_595393, "certificateId", newJString(certificateId))
  result = call_595392.call(path_595393, query_595394, nil, nil, nil)

var deleteCertificate* = Call_DeleteCertificate_595379(name: "deleteCertificate",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/certificates/{certificateId}", validator: validate_DeleteCertificate_595380,
    base: "/", url: url_DeleteCertificate_595381,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteJobExecution_595395 = ref object of OpenApiRestCall_593437
proc url_DeleteJobExecution_595397(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  assert "executionNumber" in path, "`executionNumber` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/executionNumber/"),
               (kind: VariableSegment, value: "executionNumber")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteJobExecution_595396(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deletes a job execution.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing whose job execution will be deleted.
  ##   jobId: JString (required)
  ##        : The ID of the job whose execution on a particular device will be deleted.
  ##   executionNumber: JInt (required)
  ##                  : <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_595398 = path.getOrDefault("thingName")
  valid_595398 = validateParameter(valid_595398, JString, required = true,
                                 default = nil)
  if valid_595398 != nil:
    section.add "thingName", valid_595398
  var valid_595399 = path.getOrDefault("jobId")
  valid_595399 = validateParameter(valid_595399, JString, required = true,
                                 default = nil)
  if valid_595399 != nil:
    section.add "jobId", valid_595399
  var valid_595400 = path.getOrDefault("executionNumber")
  valid_595400 = validateParameter(valid_595400, JInt, required = true, default = nil)
  if valid_595400 != nil:
    section.add "executionNumber", valid_595400
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
  section = newJObject()
  var valid_595401 = query.getOrDefault("force")
  valid_595401 = validateParameter(valid_595401, JBool, required = false, default = nil)
  if valid_595401 != nil:
    section.add "force", valid_595401
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595402 = header.getOrDefault("X-Amz-Date")
  valid_595402 = validateParameter(valid_595402, JString, required = false,
                                 default = nil)
  if valid_595402 != nil:
    section.add "X-Amz-Date", valid_595402
  var valid_595403 = header.getOrDefault("X-Amz-Security-Token")
  valid_595403 = validateParameter(valid_595403, JString, required = false,
                                 default = nil)
  if valid_595403 != nil:
    section.add "X-Amz-Security-Token", valid_595403
  var valid_595404 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595404 = validateParameter(valid_595404, JString, required = false,
                                 default = nil)
  if valid_595404 != nil:
    section.add "X-Amz-Content-Sha256", valid_595404
  var valid_595405 = header.getOrDefault("X-Amz-Algorithm")
  valid_595405 = validateParameter(valid_595405, JString, required = false,
                                 default = nil)
  if valid_595405 != nil:
    section.add "X-Amz-Algorithm", valid_595405
  var valid_595406 = header.getOrDefault("X-Amz-Signature")
  valid_595406 = validateParameter(valid_595406, JString, required = false,
                                 default = nil)
  if valid_595406 != nil:
    section.add "X-Amz-Signature", valid_595406
  var valid_595407 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595407 = validateParameter(valid_595407, JString, required = false,
                                 default = nil)
  if valid_595407 != nil:
    section.add "X-Amz-SignedHeaders", valid_595407
  var valid_595408 = header.getOrDefault("X-Amz-Credential")
  valid_595408 = validateParameter(valid_595408, JString, required = false,
                                 default = nil)
  if valid_595408 != nil:
    section.add "X-Amz-Credential", valid_595408
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595409: Call_DeleteJobExecution_595395; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a job execution.
  ## 
  let valid = call_595409.validator(path, query, header, formData, body)
  let scheme = call_595409.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595409.url(scheme.get, call_595409.host, call_595409.base,
                         call_595409.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595409, url, valid)

proc call*(call_595410: Call_DeleteJobExecution_595395; thingName: string;
          jobId: string; executionNumber: int; force: bool = false): Recallable =
  ## deleteJobExecution
  ## Deletes a job execution.
  ##   force: bool
  ##        : <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing whose job execution will be deleted.
  ##   jobId: string (required)
  ##        : The ID of the job whose execution on a particular device will be deleted.
  ##   executionNumber: int (required)
  ##                  : <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
  var path_595411 = newJObject()
  var query_595412 = newJObject()
  add(query_595412, "force", newJBool(force))
  add(path_595411, "thingName", newJString(thingName))
  add(path_595411, "jobId", newJString(jobId))
  add(path_595411, "executionNumber", newJInt(executionNumber))
  result = call_595410.call(path_595411, query_595412, nil, nil, nil)

var deleteJobExecution* = Call_DeleteJobExecution_595395(
    name: "deleteJobExecution", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}",
    validator: validate_DeleteJobExecution_595396, base: "/",
    url: url_DeleteJobExecution_595397, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPolicyVersion_595413 = ref object of OpenApiRestCall_593437
proc url_GetPolicyVersion_595415(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPolicyVersion_595414(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets information about the specified policy version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_595416 = path.getOrDefault("policyName")
  valid_595416 = validateParameter(valid_595416, JString, required = true,
                                 default = nil)
  if valid_595416 != nil:
    section.add "policyName", valid_595416
  var valid_595417 = path.getOrDefault("policyVersionId")
  valid_595417 = validateParameter(valid_595417, JString, required = true,
                                 default = nil)
  if valid_595417 != nil:
    section.add "policyVersionId", valid_595417
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595418 = header.getOrDefault("X-Amz-Date")
  valid_595418 = validateParameter(valid_595418, JString, required = false,
                                 default = nil)
  if valid_595418 != nil:
    section.add "X-Amz-Date", valid_595418
  var valid_595419 = header.getOrDefault("X-Amz-Security-Token")
  valid_595419 = validateParameter(valid_595419, JString, required = false,
                                 default = nil)
  if valid_595419 != nil:
    section.add "X-Amz-Security-Token", valid_595419
  var valid_595420 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595420 = validateParameter(valid_595420, JString, required = false,
                                 default = nil)
  if valid_595420 != nil:
    section.add "X-Amz-Content-Sha256", valid_595420
  var valid_595421 = header.getOrDefault("X-Amz-Algorithm")
  valid_595421 = validateParameter(valid_595421, JString, required = false,
                                 default = nil)
  if valid_595421 != nil:
    section.add "X-Amz-Algorithm", valid_595421
  var valid_595422 = header.getOrDefault("X-Amz-Signature")
  valid_595422 = validateParameter(valid_595422, JString, required = false,
                                 default = nil)
  if valid_595422 != nil:
    section.add "X-Amz-Signature", valid_595422
  var valid_595423 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595423 = validateParameter(valid_595423, JString, required = false,
                                 default = nil)
  if valid_595423 != nil:
    section.add "X-Amz-SignedHeaders", valid_595423
  var valid_595424 = header.getOrDefault("X-Amz-Credential")
  valid_595424 = validateParameter(valid_595424, JString, required = false,
                                 default = nil)
  if valid_595424 != nil:
    section.add "X-Amz-Credential", valid_595424
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595425: Call_GetPolicyVersion_595413; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified policy version.
  ## 
  let valid = call_595425.validator(path, query, header, formData, body)
  let scheme = call_595425.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595425.url(scheme.get, call_595425.host, call_595425.base,
                         call_595425.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595425, url, valid)

proc call*(call_595426: Call_GetPolicyVersion_595413; policyName: string;
          policyVersionId: string): Recallable =
  ## getPolicyVersion
  ## Gets information about the specified policy version.
  ##   policyName: string (required)
  ##             : The name of the policy.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_595427 = newJObject()
  add(path_595427, "policyName", newJString(policyName))
  add(path_595427, "policyVersionId", newJString(policyVersionId))
  result = call_595426.call(path_595427, nil, nil, nil, nil)

var getPolicyVersion* = Call_GetPolicyVersion_595413(name: "getPolicyVersion",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_GetPolicyVersion_595414, base: "/",
    url: url_GetPolicyVersion_595415, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetDefaultPolicyVersion_595443 = ref object of OpenApiRestCall_593437
proc url_SetDefaultPolicyVersion_595445(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_SetDefaultPolicyVersion_595444(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_595446 = path.getOrDefault("policyName")
  valid_595446 = validateParameter(valid_595446, JString, required = true,
                                 default = nil)
  if valid_595446 != nil:
    section.add "policyName", valid_595446
  var valid_595447 = path.getOrDefault("policyVersionId")
  valid_595447 = validateParameter(valid_595447, JString, required = true,
                                 default = nil)
  if valid_595447 != nil:
    section.add "policyVersionId", valid_595447
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595448 = header.getOrDefault("X-Amz-Date")
  valid_595448 = validateParameter(valid_595448, JString, required = false,
                                 default = nil)
  if valid_595448 != nil:
    section.add "X-Amz-Date", valid_595448
  var valid_595449 = header.getOrDefault("X-Amz-Security-Token")
  valid_595449 = validateParameter(valid_595449, JString, required = false,
                                 default = nil)
  if valid_595449 != nil:
    section.add "X-Amz-Security-Token", valid_595449
  var valid_595450 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595450 = validateParameter(valid_595450, JString, required = false,
                                 default = nil)
  if valid_595450 != nil:
    section.add "X-Amz-Content-Sha256", valid_595450
  var valid_595451 = header.getOrDefault("X-Amz-Algorithm")
  valid_595451 = validateParameter(valid_595451, JString, required = false,
                                 default = nil)
  if valid_595451 != nil:
    section.add "X-Amz-Algorithm", valid_595451
  var valid_595452 = header.getOrDefault("X-Amz-Signature")
  valid_595452 = validateParameter(valid_595452, JString, required = false,
                                 default = nil)
  if valid_595452 != nil:
    section.add "X-Amz-Signature", valid_595452
  var valid_595453 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595453 = validateParameter(valid_595453, JString, required = false,
                                 default = nil)
  if valid_595453 != nil:
    section.add "X-Amz-SignedHeaders", valid_595453
  var valid_595454 = header.getOrDefault("X-Amz-Credential")
  valid_595454 = validateParameter(valid_595454, JString, required = false,
                                 default = nil)
  if valid_595454 != nil:
    section.add "X-Amz-Credential", valid_595454
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595455: Call_SetDefaultPolicyVersion_595443; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ## 
  let valid = call_595455.validator(path, query, header, formData, body)
  let scheme = call_595455.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595455.url(scheme.get, call_595455.host, call_595455.base,
                         call_595455.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595455, url, valid)

proc call*(call_595456: Call_SetDefaultPolicyVersion_595443; policyName: string;
          policyVersionId: string): Recallable =
  ## setDefaultPolicyVersion
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ##   policyName: string (required)
  ##             : The policy name.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_595457 = newJObject()
  add(path_595457, "policyName", newJString(policyName))
  add(path_595457, "policyVersionId", newJString(policyVersionId))
  result = call_595456.call(path_595457, nil, nil, nil, nil)

var setDefaultPolicyVersion* = Call_SetDefaultPolicyVersion_595443(
    name: "setDefaultPolicyVersion", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_SetDefaultPolicyVersion_595444, base: "/",
    url: url_SetDefaultPolicyVersion_595445, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeletePolicyVersion_595428 = ref object of OpenApiRestCall_593437
proc url_DeletePolicyVersion_595430(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeletePolicyVersion_595429(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_595431 = path.getOrDefault("policyName")
  valid_595431 = validateParameter(valid_595431, JString, required = true,
                                 default = nil)
  if valid_595431 != nil:
    section.add "policyName", valid_595431
  var valid_595432 = path.getOrDefault("policyVersionId")
  valid_595432 = validateParameter(valid_595432, JString, required = true,
                                 default = nil)
  if valid_595432 != nil:
    section.add "policyVersionId", valid_595432
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595433 = header.getOrDefault("X-Amz-Date")
  valid_595433 = validateParameter(valid_595433, JString, required = false,
                                 default = nil)
  if valid_595433 != nil:
    section.add "X-Amz-Date", valid_595433
  var valid_595434 = header.getOrDefault("X-Amz-Security-Token")
  valid_595434 = validateParameter(valid_595434, JString, required = false,
                                 default = nil)
  if valid_595434 != nil:
    section.add "X-Amz-Security-Token", valid_595434
  var valid_595435 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595435 = validateParameter(valid_595435, JString, required = false,
                                 default = nil)
  if valid_595435 != nil:
    section.add "X-Amz-Content-Sha256", valid_595435
  var valid_595436 = header.getOrDefault("X-Amz-Algorithm")
  valid_595436 = validateParameter(valid_595436, JString, required = false,
                                 default = nil)
  if valid_595436 != nil:
    section.add "X-Amz-Algorithm", valid_595436
  var valid_595437 = header.getOrDefault("X-Amz-Signature")
  valid_595437 = validateParameter(valid_595437, JString, required = false,
                                 default = nil)
  if valid_595437 != nil:
    section.add "X-Amz-Signature", valid_595437
  var valid_595438 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595438 = validateParameter(valid_595438, JString, required = false,
                                 default = nil)
  if valid_595438 != nil:
    section.add "X-Amz-SignedHeaders", valid_595438
  var valid_595439 = header.getOrDefault("X-Amz-Credential")
  valid_595439 = validateParameter(valid_595439, JString, required = false,
                                 default = nil)
  if valid_595439 != nil:
    section.add "X-Amz-Credential", valid_595439
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595440: Call_DeletePolicyVersion_595428; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ## 
  let valid = call_595440.validator(path, query, header, formData, body)
  let scheme = call_595440.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595440.url(scheme.get, call_595440.host, call_595440.base,
                         call_595440.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595440, url, valid)

proc call*(call_595441: Call_DeletePolicyVersion_595428; policyName: string;
          policyVersionId: string): Recallable =
  ## deletePolicyVersion
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ##   policyName: string (required)
  ##             : The name of the policy.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_595442 = newJObject()
  add(path_595442, "policyName", newJString(policyName))
  add(path_595442, "policyVersionId", newJString(policyVersionId))
  result = call_595441.call(path_595442, nil, nil, nil, nil)

var deletePolicyVersion* = Call_DeletePolicyVersion_595428(
    name: "deletePolicyVersion", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_DeletePolicyVersion_595429, base: "/",
    url: url_DeletePolicyVersion_595430, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRegistrationCode_595458 = ref object of OpenApiRestCall_593437
proc url_GetRegistrationCode_595460(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRegistrationCode_595459(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595461 = header.getOrDefault("X-Amz-Date")
  valid_595461 = validateParameter(valid_595461, JString, required = false,
                                 default = nil)
  if valid_595461 != nil:
    section.add "X-Amz-Date", valid_595461
  var valid_595462 = header.getOrDefault("X-Amz-Security-Token")
  valid_595462 = validateParameter(valid_595462, JString, required = false,
                                 default = nil)
  if valid_595462 != nil:
    section.add "X-Amz-Security-Token", valid_595462
  var valid_595463 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595463 = validateParameter(valid_595463, JString, required = false,
                                 default = nil)
  if valid_595463 != nil:
    section.add "X-Amz-Content-Sha256", valid_595463
  var valid_595464 = header.getOrDefault("X-Amz-Algorithm")
  valid_595464 = validateParameter(valid_595464, JString, required = false,
                                 default = nil)
  if valid_595464 != nil:
    section.add "X-Amz-Algorithm", valid_595464
  var valid_595465 = header.getOrDefault("X-Amz-Signature")
  valid_595465 = validateParameter(valid_595465, JString, required = false,
                                 default = nil)
  if valid_595465 != nil:
    section.add "X-Amz-Signature", valid_595465
  var valid_595466 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595466 = validateParameter(valid_595466, JString, required = false,
                                 default = nil)
  if valid_595466 != nil:
    section.add "X-Amz-SignedHeaders", valid_595466
  var valid_595467 = header.getOrDefault("X-Amz-Credential")
  valid_595467 = validateParameter(valid_595467, JString, required = false,
                                 default = nil)
  if valid_595467 != nil:
    section.add "X-Amz-Credential", valid_595467
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595468: Call_GetRegistrationCode_595458; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  ## 
  let valid = call_595468.validator(path, query, header, formData, body)
  let scheme = call_595468.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595468.url(scheme.get, call_595468.host, call_595468.base,
                         call_595468.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595468, url, valid)

proc call*(call_595469: Call_GetRegistrationCode_595458): Recallable =
  ## getRegistrationCode
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  result = call_595469.call(nil, nil, nil, nil, nil)

var getRegistrationCode* = Call_GetRegistrationCode_595458(
    name: "getRegistrationCode", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/registrationcode",
    validator: validate_GetRegistrationCode_595459, base: "/",
    url: url_GetRegistrationCode_595460, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRegistrationCode_595470 = ref object of OpenApiRestCall_593437
proc url_DeleteRegistrationCode_595472(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DeleteRegistrationCode_595471(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a CA certificate registration code.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595473 = header.getOrDefault("X-Amz-Date")
  valid_595473 = validateParameter(valid_595473, JString, required = false,
                                 default = nil)
  if valid_595473 != nil:
    section.add "X-Amz-Date", valid_595473
  var valid_595474 = header.getOrDefault("X-Amz-Security-Token")
  valid_595474 = validateParameter(valid_595474, JString, required = false,
                                 default = nil)
  if valid_595474 != nil:
    section.add "X-Amz-Security-Token", valid_595474
  var valid_595475 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595475 = validateParameter(valid_595475, JString, required = false,
                                 default = nil)
  if valid_595475 != nil:
    section.add "X-Amz-Content-Sha256", valid_595475
  var valid_595476 = header.getOrDefault("X-Amz-Algorithm")
  valid_595476 = validateParameter(valid_595476, JString, required = false,
                                 default = nil)
  if valid_595476 != nil:
    section.add "X-Amz-Algorithm", valid_595476
  var valid_595477 = header.getOrDefault("X-Amz-Signature")
  valid_595477 = validateParameter(valid_595477, JString, required = false,
                                 default = nil)
  if valid_595477 != nil:
    section.add "X-Amz-Signature", valid_595477
  var valid_595478 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595478 = validateParameter(valid_595478, JString, required = false,
                                 default = nil)
  if valid_595478 != nil:
    section.add "X-Amz-SignedHeaders", valid_595478
  var valid_595479 = header.getOrDefault("X-Amz-Credential")
  valid_595479 = validateParameter(valid_595479, JString, required = false,
                                 default = nil)
  if valid_595479 != nil:
    section.add "X-Amz-Credential", valid_595479
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595480: Call_DeleteRegistrationCode_595470; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a CA certificate registration code.
  ## 
  let valid = call_595480.validator(path, query, header, formData, body)
  let scheme = call_595480.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595480.url(scheme.get, call_595480.host, call_595480.base,
                         call_595480.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595480, url, valid)

proc call*(call_595481: Call_DeleteRegistrationCode_595470): Recallable =
  ## deleteRegistrationCode
  ## Deletes a CA certificate registration code.
  result = call_595481.call(nil, nil, nil, nil, nil)

var deleteRegistrationCode* = Call_DeleteRegistrationCode_595470(
    name: "deleteRegistrationCode", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/registrationcode",
    validator: validate_DeleteRegistrationCode_595471, base: "/",
    url: url_DeleteRegistrationCode_595472, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteV2LoggingLevel_595482 = ref object of OpenApiRestCall_593437
proc url_DeleteV2LoggingLevel_595484(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DeleteV2LoggingLevel_595483(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a logging level.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   targetType: JString (required)
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   targetName: JString (required)
  ##             : The name of the resource for which you are configuring logging.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `targetType` field"
  var valid_595485 = query.getOrDefault("targetType")
  valid_595485 = validateParameter(valid_595485, JString, required = true,
                                 default = newJString("DEFAULT"))
  if valid_595485 != nil:
    section.add "targetType", valid_595485
  var valid_595486 = query.getOrDefault("targetName")
  valid_595486 = validateParameter(valid_595486, JString, required = true,
                                 default = nil)
  if valid_595486 != nil:
    section.add "targetName", valid_595486
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595487 = header.getOrDefault("X-Amz-Date")
  valid_595487 = validateParameter(valid_595487, JString, required = false,
                                 default = nil)
  if valid_595487 != nil:
    section.add "X-Amz-Date", valid_595487
  var valid_595488 = header.getOrDefault("X-Amz-Security-Token")
  valid_595488 = validateParameter(valid_595488, JString, required = false,
                                 default = nil)
  if valid_595488 != nil:
    section.add "X-Amz-Security-Token", valid_595488
  var valid_595489 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595489 = validateParameter(valid_595489, JString, required = false,
                                 default = nil)
  if valid_595489 != nil:
    section.add "X-Amz-Content-Sha256", valid_595489
  var valid_595490 = header.getOrDefault("X-Amz-Algorithm")
  valid_595490 = validateParameter(valid_595490, JString, required = false,
                                 default = nil)
  if valid_595490 != nil:
    section.add "X-Amz-Algorithm", valid_595490
  var valid_595491 = header.getOrDefault("X-Amz-Signature")
  valid_595491 = validateParameter(valid_595491, JString, required = false,
                                 default = nil)
  if valid_595491 != nil:
    section.add "X-Amz-Signature", valid_595491
  var valid_595492 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595492 = validateParameter(valid_595492, JString, required = false,
                                 default = nil)
  if valid_595492 != nil:
    section.add "X-Amz-SignedHeaders", valid_595492
  var valid_595493 = header.getOrDefault("X-Amz-Credential")
  valid_595493 = validateParameter(valid_595493, JString, required = false,
                                 default = nil)
  if valid_595493 != nil:
    section.add "X-Amz-Credential", valid_595493
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595494: Call_DeleteV2LoggingLevel_595482; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a logging level.
  ## 
  let valid = call_595494.validator(path, query, header, formData, body)
  let scheme = call_595494.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595494.url(scheme.get, call_595494.host, call_595494.base,
                         call_595494.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595494, url, valid)

proc call*(call_595495: Call_DeleteV2LoggingLevel_595482; targetName: string;
          targetType: string = "DEFAULT"): Recallable =
  ## deleteV2LoggingLevel
  ## Deletes a logging level.
  ##   targetType: string (required)
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   targetName: string (required)
  ##             : The name of the resource for which you are configuring logging.
  var query_595496 = newJObject()
  add(query_595496, "targetType", newJString(targetType))
  add(query_595496, "targetName", newJString(targetName))
  result = call_595495.call(nil, query_595496, nil, nil, nil)

var deleteV2LoggingLevel* = Call_DeleteV2LoggingLevel_595482(
    name: "deleteV2LoggingLevel", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/v2LoggingLevel#targetType&targetName",
    validator: validate_DeleteV2LoggingLevel_595483, base: "/",
    url: url_DeleteV2LoggingLevel_595484, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeprecateThingType_595497 = ref object of OpenApiRestCall_593437
proc url_DeprecateThingType_595499(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName"),
               (kind: ConstantSegment, value: "/deprecate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeprecateThingType_595498(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type to deprecate.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_595500 = path.getOrDefault("thingTypeName")
  valid_595500 = validateParameter(valid_595500, JString, required = true,
                                 default = nil)
  if valid_595500 != nil:
    section.add "thingTypeName", valid_595500
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595501 = header.getOrDefault("X-Amz-Date")
  valid_595501 = validateParameter(valid_595501, JString, required = false,
                                 default = nil)
  if valid_595501 != nil:
    section.add "X-Amz-Date", valid_595501
  var valid_595502 = header.getOrDefault("X-Amz-Security-Token")
  valid_595502 = validateParameter(valid_595502, JString, required = false,
                                 default = nil)
  if valid_595502 != nil:
    section.add "X-Amz-Security-Token", valid_595502
  var valid_595503 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595503 = validateParameter(valid_595503, JString, required = false,
                                 default = nil)
  if valid_595503 != nil:
    section.add "X-Amz-Content-Sha256", valid_595503
  var valid_595504 = header.getOrDefault("X-Amz-Algorithm")
  valid_595504 = validateParameter(valid_595504, JString, required = false,
                                 default = nil)
  if valid_595504 != nil:
    section.add "X-Amz-Algorithm", valid_595504
  var valid_595505 = header.getOrDefault("X-Amz-Signature")
  valid_595505 = validateParameter(valid_595505, JString, required = false,
                                 default = nil)
  if valid_595505 != nil:
    section.add "X-Amz-Signature", valid_595505
  var valid_595506 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595506 = validateParameter(valid_595506, JString, required = false,
                                 default = nil)
  if valid_595506 != nil:
    section.add "X-Amz-SignedHeaders", valid_595506
  var valid_595507 = header.getOrDefault("X-Amz-Credential")
  valid_595507 = validateParameter(valid_595507, JString, required = false,
                                 default = nil)
  if valid_595507 != nil:
    section.add "X-Amz-Credential", valid_595507
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595509: Call_DeprecateThingType_595497; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ## 
  let valid = call_595509.validator(path, query, header, formData, body)
  let scheme = call_595509.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595509.url(scheme.get, call_595509.host, call_595509.base,
                         call_595509.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595509, url, valid)

proc call*(call_595510: Call_DeprecateThingType_595497; body: JsonNode;
          thingTypeName: string): Recallable =
  ## deprecateThingType
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ##   body: JObject (required)
  ##   thingTypeName: string (required)
  ##                : The name of the thing type to deprecate.
  var path_595511 = newJObject()
  var body_595512 = newJObject()
  if body != nil:
    body_595512 = body
  add(path_595511, "thingTypeName", newJString(thingTypeName))
  result = call_595510.call(path_595511, nil, nil, nil, body_595512)

var deprecateThingType* = Call_DeprecateThingType_595497(
    name: "deprecateThingType", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/thing-types/{thingTypeName}/deprecate",
    validator: validate_DeprecateThingType_595498, base: "/",
    url: url_DeprecateThingType_595499, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditFinding_595513 = ref object of OpenApiRestCall_593437
proc url_DescribeAuditFinding_595515(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "findingId" in path, "`findingId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/findings/"),
               (kind: VariableSegment, value: "findingId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeAuditFinding_595514(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   findingId: JString (required)
  ##            : A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `findingId` field"
  var valid_595516 = path.getOrDefault("findingId")
  valid_595516 = validateParameter(valid_595516, JString, required = true,
                                 default = nil)
  if valid_595516 != nil:
    section.add "findingId", valid_595516
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595517 = header.getOrDefault("X-Amz-Date")
  valid_595517 = validateParameter(valid_595517, JString, required = false,
                                 default = nil)
  if valid_595517 != nil:
    section.add "X-Amz-Date", valid_595517
  var valid_595518 = header.getOrDefault("X-Amz-Security-Token")
  valid_595518 = validateParameter(valid_595518, JString, required = false,
                                 default = nil)
  if valid_595518 != nil:
    section.add "X-Amz-Security-Token", valid_595518
  var valid_595519 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595519 = validateParameter(valid_595519, JString, required = false,
                                 default = nil)
  if valid_595519 != nil:
    section.add "X-Amz-Content-Sha256", valid_595519
  var valid_595520 = header.getOrDefault("X-Amz-Algorithm")
  valid_595520 = validateParameter(valid_595520, JString, required = false,
                                 default = nil)
  if valid_595520 != nil:
    section.add "X-Amz-Algorithm", valid_595520
  var valid_595521 = header.getOrDefault("X-Amz-Signature")
  valid_595521 = validateParameter(valid_595521, JString, required = false,
                                 default = nil)
  if valid_595521 != nil:
    section.add "X-Amz-Signature", valid_595521
  var valid_595522 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595522 = validateParameter(valid_595522, JString, required = false,
                                 default = nil)
  if valid_595522 != nil:
    section.add "X-Amz-SignedHeaders", valid_595522
  var valid_595523 = header.getOrDefault("X-Amz-Credential")
  valid_595523 = validateParameter(valid_595523, JString, required = false,
                                 default = nil)
  if valid_595523 != nil:
    section.add "X-Amz-Credential", valid_595523
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595524: Call_DescribeAuditFinding_595513; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ## 
  let valid = call_595524.validator(path, query, header, formData, body)
  let scheme = call_595524.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595524.url(scheme.get, call_595524.host, call_595524.base,
                         call_595524.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595524, url, valid)

proc call*(call_595525: Call_DescribeAuditFinding_595513; findingId: string): Recallable =
  ## describeAuditFinding
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ##   findingId: string (required)
  ##            : A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
  var path_595526 = newJObject()
  add(path_595526, "findingId", newJString(findingId))
  result = call_595525.call(path_595526, nil, nil, nil, nil)

var describeAuditFinding* = Call_DescribeAuditFinding_595513(
    name: "describeAuditFinding", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/findings/{findingId}",
    validator: validate_DescribeAuditFinding_595514, base: "/",
    url: url_DescribeAuditFinding_595515, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartAuditMitigationActionsTask_595541 = ref object of OpenApiRestCall_593437
proc url_StartAuditMitigationActionsTask_595543(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartAuditMitigationActionsTask_595542(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_595544 = path.getOrDefault("taskId")
  valid_595544 = validateParameter(valid_595544, JString, required = true,
                                 default = nil)
  if valid_595544 != nil:
    section.add "taskId", valid_595544
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595545 = header.getOrDefault("X-Amz-Date")
  valid_595545 = validateParameter(valid_595545, JString, required = false,
                                 default = nil)
  if valid_595545 != nil:
    section.add "X-Amz-Date", valid_595545
  var valid_595546 = header.getOrDefault("X-Amz-Security-Token")
  valid_595546 = validateParameter(valid_595546, JString, required = false,
                                 default = nil)
  if valid_595546 != nil:
    section.add "X-Amz-Security-Token", valid_595546
  var valid_595547 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595547 = validateParameter(valid_595547, JString, required = false,
                                 default = nil)
  if valid_595547 != nil:
    section.add "X-Amz-Content-Sha256", valid_595547
  var valid_595548 = header.getOrDefault("X-Amz-Algorithm")
  valid_595548 = validateParameter(valid_595548, JString, required = false,
                                 default = nil)
  if valid_595548 != nil:
    section.add "X-Amz-Algorithm", valid_595548
  var valid_595549 = header.getOrDefault("X-Amz-Signature")
  valid_595549 = validateParameter(valid_595549, JString, required = false,
                                 default = nil)
  if valid_595549 != nil:
    section.add "X-Amz-Signature", valid_595549
  var valid_595550 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595550 = validateParameter(valid_595550, JString, required = false,
                                 default = nil)
  if valid_595550 != nil:
    section.add "X-Amz-SignedHeaders", valid_595550
  var valid_595551 = header.getOrDefault("X-Amz-Credential")
  valid_595551 = validateParameter(valid_595551, JString, required = false,
                                 default = nil)
  if valid_595551 != nil:
    section.add "X-Amz-Credential", valid_595551
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595553: Call_StartAuditMitigationActionsTask_595541;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ## 
  let valid = call_595553.validator(path, query, header, formData, body)
  let scheme = call_595553.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595553.url(scheme.get, call_595553.host, call_595553.base,
                         call_595553.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595553, url, valid)

proc call*(call_595554: Call_StartAuditMitigationActionsTask_595541;
          body: JsonNode; taskId: string): Recallable =
  ## startAuditMitigationActionsTask
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ##   body: JObject (required)
  ##   taskId: string (required)
  ##         : A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
  var path_595555 = newJObject()
  var body_595556 = newJObject()
  if body != nil:
    body_595556 = body
  add(path_595555, "taskId", newJString(taskId))
  result = call_595554.call(path_595555, nil, nil, nil, body_595556)

var startAuditMitigationActionsTask* = Call_StartAuditMitigationActionsTask_595541(
    name: "startAuditMitigationActionsTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/audit/mitigationactions/tasks/{taskId}",
    validator: validate_StartAuditMitigationActionsTask_595542, base: "/",
    url: url_StartAuditMitigationActionsTask_595543,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditMitigationActionsTask_595527 = ref object of OpenApiRestCall_593437
proc url_DescribeAuditMitigationActionsTask_595529(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeAuditMitigationActionsTask_595528(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The unique identifier for the audit mitigation task.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_595530 = path.getOrDefault("taskId")
  valid_595530 = validateParameter(valid_595530, JString, required = true,
                                 default = nil)
  if valid_595530 != nil:
    section.add "taskId", valid_595530
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595531 = header.getOrDefault("X-Amz-Date")
  valid_595531 = validateParameter(valid_595531, JString, required = false,
                                 default = nil)
  if valid_595531 != nil:
    section.add "X-Amz-Date", valid_595531
  var valid_595532 = header.getOrDefault("X-Amz-Security-Token")
  valid_595532 = validateParameter(valid_595532, JString, required = false,
                                 default = nil)
  if valid_595532 != nil:
    section.add "X-Amz-Security-Token", valid_595532
  var valid_595533 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595533 = validateParameter(valid_595533, JString, required = false,
                                 default = nil)
  if valid_595533 != nil:
    section.add "X-Amz-Content-Sha256", valid_595533
  var valid_595534 = header.getOrDefault("X-Amz-Algorithm")
  valid_595534 = validateParameter(valid_595534, JString, required = false,
                                 default = nil)
  if valid_595534 != nil:
    section.add "X-Amz-Algorithm", valid_595534
  var valid_595535 = header.getOrDefault("X-Amz-Signature")
  valid_595535 = validateParameter(valid_595535, JString, required = false,
                                 default = nil)
  if valid_595535 != nil:
    section.add "X-Amz-Signature", valid_595535
  var valid_595536 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595536 = validateParameter(valid_595536, JString, required = false,
                                 default = nil)
  if valid_595536 != nil:
    section.add "X-Amz-SignedHeaders", valid_595536
  var valid_595537 = header.getOrDefault("X-Amz-Credential")
  valid_595537 = validateParameter(valid_595537, JString, required = false,
                                 default = nil)
  if valid_595537 != nil:
    section.add "X-Amz-Credential", valid_595537
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595538: Call_DescribeAuditMitigationActionsTask_595527;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ## 
  let valid = call_595538.validator(path, query, header, formData, body)
  let scheme = call_595538.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595538.url(scheme.get, call_595538.host, call_595538.base,
                         call_595538.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595538, url, valid)

proc call*(call_595539: Call_DescribeAuditMitigationActionsTask_595527;
          taskId: string): Recallable =
  ## describeAuditMitigationActionsTask
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ##   taskId: string (required)
  ##         : The unique identifier for the audit mitigation task.
  var path_595540 = newJObject()
  add(path_595540, "taskId", newJString(taskId))
  result = call_595539.call(path_595540, nil, nil, nil, nil)

var describeAuditMitigationActionsTask* = Call_DescribeAuditMitigationActionsTask_595527(
    name: "describeAuditMitigationActionsTask", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/mitigationactions/tasks/{taskId}",
    validator: validate_DescribeAuditMitigationActionsTask_595528, base: "/",
    url: url_DescribeAuditMitigationActionsTask_595529,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditTask_595557 = ref object of OpenApiRestCall_593437
proc url_DescribeAuditTask_595559(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeAuditTask_595558(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Gets information about a Device Defender audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The ID of the audit whose information you want to get.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_595560 = path.getOrDefault("taskId")
  valid_595560 = validateParameter(valid_595560, JString, required = true,
                                 default = nil)
  if valid_595560 != nil:
    section.add "taskId", valid_595560
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595561 = header.getOrDefault("X-Amz-Date")
  valid_595561 = validateParameter(valid_595561, JString, required = false,
                                 default = nil)
  if valid_595561 != nil:
    section.add "X-Amz-Date", valid_595561
  var valid_595562 = header.getOrDefault("X-Amz-Security-Token")
  valid_595562 = validateParameter(valid_595562, JString, required = false,
                                 default = nil)
  if valid_595562 != nil:
    section.add "X-Amz-Security-Token", valid_595562
  var valid_595563 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595563 = validateParameter(valid_595563, JString, required = false,
                                 default = nil)
  if valid_595563 != nil:
    section.add "X-Amz-Content-Sha256", valid_595563
  var valid_595564 = header.getOrDefault("X-Amz-Algorithm")
  valid_595564 = validateParameter(valid_595564, JString, required = false,
                                 default = nil)
  if valid_595564 != nil:
    section.add "X-Amz-Algorithm", valid_595564
  var valid_595565 = header.getOrDefault("X-Amz-Signature")
  valid_595565 = validateParameter(valid_595565, JString, required = false,
                                 default = nil)
  if valid_595565 != nil:
    section.add "X-Amz-Signature", valid_595565
  var valid_595566 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595566 = validateParameter(valid_595566, JString, required = false,
                                 default = nil)
  if valid_595566 != nil:
    section.add "X-Amz-SignedHeaders", valid_595566
  var valid_595567 = header.getOrDefault("X-Amz-Credential")
  valid_595567 = validateParameter(valid_595567, JString, required = false,
                                 default = nil)
  if valid_595567 != nil:
    section.add "X-Amz-Credential", valid_595567
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595568: Call_DescribeAuditTask_595557; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a Device Defender audit.
  ## 
  let valid = call_595568.validator(path, query, header, formData, body)
  let scheme = call_595568.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595568.url(scheme.get, call_595568.host, call_595568.base,
                         call_595568.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595568, url, valid)

proc call*(call_595569: Call_DescribeAuditTask_595557; taskId: string): Recallable =
  ## describeAuditTask
  ## Gets information about a Device Defender audit.
  ##   taskId: string (required)
  ##         : The ID of the audit whose information you want to get.
  var path_595570 = newJObject()
  add(path_595570, "taskId", newJString(taskId))
  result = call_595569.call(path_595570, nil, nil, nil, nil)

var describeAuditTask* = Call_DescribeAuditTask_595557(name: "describeAuditTask",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/audit/tasks/{taskId}", validator: validate_DescribeAuditTask_595558,
    base: "/", url: url_DescribeAuditTask_595559,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeEndpoint_595571 = ref object of OpenApiRestCall_593437
proc url_DescribeEndpoint_595573(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DescribeEndpoint_595572(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Returns a unique endpoint specific to the AWS account making the call.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endpointType: JString
  ##               : <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
  section = newJObject()
  var valid_595574 = query.getOrDefault("endpointType")
  valid_595574 = validateParameter(valid_595574, JString, required = false,
                                 default = nil)
  if valid_595574 != nil:
    section.add "endpointType", valid_595574
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595575 = header.getOrDefault("X-Amz-Date")
  valid_595575 = validateParameter(valid_595575, JString, required = false,
                                 default = nil)
  if valid_595575 != nil:
    section.add "X-Amz-Date", valid_595575
  var valid_595576 = header.getOrDefault("X-Amz-Security-Token")
  valid_595576 = validateParameter(valid_595576, JString, required = false,
                                 default = nil)
  if valid_595576 != nil:
    section.add "X-Amz-Security-Token", valid_595576
  var valid_595577 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595577 = validateParameter(valid_595577, JString, required = false,
                                 default = nil)
  if valid_595577 != nil:
    section.add "X-Amz-Content-Sha256", valid_595577
  var valid_595578 = header.getOrDefault("X-Amz-Algorithm")
  valid_595578 = validateParameter(valid_595578, JString, required = false,
                                 default = nil)
  if valid_595578 != nil:
    section.add "X-Amz-Algorithm", valid_595578
  var valid_595579 = header.getOrDefault("X-Amz-Signature")
  valid_595579 = validateParameter(valid_595579, JString, required = false,
                                 default = nil)
  if valid_595579 != nil:
    section.add "X-Amz-Signature", valid_595579
  var valid_595580 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595580 = validateParameter(valid_595580, JString, required = false,
                                 default = nil)
  if valid_595580 != nil:
    section.add "X-Amz-SignedHeaders", valid_595580
  var valid_595581 = header.getOrDefault("X-Amz-Credential")
  valid_595581 = validateParameter(valid_595581, JString, required = false,
                                 default = nil)
  if valid_595581 != nil:
    section.add "X-Amz-Credential", valid_595581
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595582: Call_DescribeEndpoint_595571; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a unique endpoint specific to the AWS account making the call.
  ## 
  let valid = call_595582.validator(path, query, header, formData, body)
  let scheme = call_595582.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595582.url(scheme.get, call_595582.host, call_595582.base,
                         call_595582.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595582, url, valid)

proc call*(call_595583: Call_DescribeEndpoint_595571; endpointType: string = ""): Recallable =
  ## describeEndpoint
  ## Returns a unique endpoint specific to the AWS account making the call.
  ##   endpointType: string
  ##               : <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
  var query_595584 = newJObject()
  add(query_595584, "endpointType", newJString(endpointType))
  result = call_595583.call(nil, query_595584, nil, nil, nil)

var describeEndpoint* = Call_DescribeEndpoint_595571(name: "describeEndpoint",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/endpoint",
    validator: validate_DescribeEndpoint_595572, base: "/",
    url: url_DescribeEndpoint_595573, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeEventConfigurations_595585 = ref object of OpenApiRestCall_593437
proc url_DescribeEventConfigurations_595587(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DescribeEventConfigurations_595586(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes event configurations.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595588 = header.getOrDefault("X-Amz-Date")
  valid_595588 = validateParameter(valid_595588, JString, required = false,
                                 default = nil)
  if valid_595588 != nil:
    section.add "X-Amz-Date", valid_595588
  var valid_595589 = header.getOrDefault("X-Amz-Security-Token")
  valid_595589 = validateParameter(valid_595589, JString, required = false,
                                 default = nil)
  if valid_595589 != nil:
    section.add "X-Amz-Security-Token", valid_595589
  var valid_595590 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595590 = validateParameter(valid_595590, JString, required = false,
                                 default = nil)
  if valid_595590 != nil:
    section.add "X-Amz-Content-Sha256", valid_595590
  var valid_595591 = header.getOrDefault("X-Amz-Algorithm")
  valid_595591 = validateParameter(valid_595591, JString, required = false,
                                 default = nil)
  if valid_595591 != nil:
    section.add "X-Amz-Algorithm", valid_595591
  var valid_595592 = header.getOrDefault("X-Amz-Signature")
  valid_595592 = validateParameter(valid_595592, JString, required = false,
                                 default = nil)
  if valid_595592 != nil:
    section.add "X-Amz-Signature", valid_595592
  var valid_595593 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595593 = validateParameter(valid_595593, JString, required = false,
                                 default = nil)
  if valid_595593 != nil:
    section.add "X-Amz-SignedHeaders", valid_595593
  var valid_595594 = header.getOrDefault("X-Amz-Credential")
  valid_595594 = validateParameter(valid_595594, JString, required = false,
                                 default = nil)
  if valid_595594 != nil:
    section.add "X-Amz-Credential", valid_595594
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595595: Call_DescribeEventConfigurations_595585; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes event configurations.
  ## 
  let valid = call_595595.validator(path, query, header, formData, body)
  let scheme = call_595595.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595595.url(scheme.get, call_595595.host, call_595595.base,
                         call_595595.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595595, url, valid)

proc call*(call_595596: Call_DescribeEventConfigurations_595585): Recallable =
  ## describeEventConfigurations
  ## Describes event configurations.
  result = call_595596.call(nil, nil, nil, nil, nil)

var describeEventConfigurations* = Call_DescribeEventConfigurations_595585(
    name: "describeEventConfigurations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/event-configurations",
    validator: validate_DescribeEventConfigurations_595586, base: "/",
    url: url_DescribeEventConfigurations_595587,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateEventConfigurations_595597 = ref object of OpenApiRestCall_593437
proc url_UpdateEventConfigurations_595599(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateEventConfigurations_595598(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the event configurations.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595600 = header.getOrDefault("X-Amz-Date")
  valid_595600 = validateParameter(valid_595600, JString, required = false,
                                 default = nil)
  if valid_595600 != nil:
    section.add "X-Amz-Date", valid_595600
  var valid_595601 = header.getOrDefault("X-Amz-Security-Token")
  valid_595601 = validateParameter(valid_595601, JString, required = false,
                                 default = nil)
  if valid_595601 != nil:
    section.add "X-Amz-Security-Token", valid_595601
  var valid_595602 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595602 = validateParameter(valid_595602, JString, required = false,
                                 default = nil)
  if valid_595602 != nil:
    section.add "X-Amz-Content-Sha256", valid_595602
  var valid_595603 = header.getOrDefault("X-Amz-Algorithm")
  valid_595603 = validateParameter(valid_595603, JString, required = false,
                                 default = nil)
  if valid_595603 != nil:
    section.add "X-Amz-Algorithm", valid_595603
  var valid_595604 = header.getOrDefault("X-Amz-Signature")
  valid_595604 = validateParameter(valid_595604, JString, required = false,
                                 default = nil)
  if valid_595604 != nil:
    section.add "X-Amz-Signature", valid_595604
  var valid_595605 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595605 = validateParameter(valid_595605, JString, required = false,
                                 default = nil)
  if valid_595605 != nil:
    section.add "X-Amz-SignedHeaders", valid_595605
  var valid_595606 = header.getOrDefault("X-Amz-Credential")
  valid_595606 = validateParameter(valid_595606, JString, required = false,
                                 default = nil)
  if valid_595606 != nil:
    section.add "X-Amz-Credential", valid_595606
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595608: Call_UpdateEventConfigurations_595597; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the event configurations.
  ## 
  let valid = call_595608.validator(path, query, header, formData, body)
  let scheme = call_595608.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595608.url(scheme.get, call_595608.host, call_595608.base,
                         call_595608.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595608, url, valid)

proc call*(call_595609: Call_UpdateEventConfigurations_595597; body: JsonNode): Recallable =
  ## updateEventConfigurations
  ## Updates the event configurations.
  ##   body: JObject (required)
  var body_595610 = newJObject()
  if body != nil:
    body_595610 = body
  result = call_595609.call(nil, nil, nil, nil, body_595610)

var updateEventConfigurations* = Call_UpdateEventConfigurations_595597(
    name: "updateEventConfigurations", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/event-configurations",
    validator: validate_UpdateEventConfigurations_595598, base: "/",
    url: url_UpdateEventConfigurations_595599,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeIndex_595611 = ref object of OpenApiRestCall_593437
proc url_DescribeIndex_595613(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "indexName" in path, "`indexName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/indices/"),
               (kind: VariableSegment, value: "indexName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeIndex_595612(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a search index.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   indexName: JString (required)
  ##            : The index name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `indexName` field"
  var valid_595614 = path.getOrDefault("indexName")
  valid_595614 = validateParameter(valid_595614, JString, required = true,
                                 default = nil)
  if valid_595614 != nil:
    section.add "indexName", valid_595614
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595615 = header.getOrDefault("X-Amz-Date")
  valid_595615 = validateParameter(valid_595615, JString, required = false,
                                 default = nil)
  if valid_595615 != nil:
    section.add "X-Amz-Date", valid_595615
  var valid_595616 = header.getOrDefault("X-Amz-Security-Token")
  valid_595616 = validateParameter(valid_595616, JString, required = false,
                                 default = nil)
  if valid_595616 != nil:
    section.add "X-Amz-Security-Token", valid_595616
  var valid_595617 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595617 = validateParameter(valid_595617, JString, required = false,
                                 default = nil)
  if valid_595617 != nil:
    section.add "X-Amz-Content-Sha256", valid_595617
  var valid_595618 = header.getOrDefault("X-Amz-Algorithm")
  valid_595618 = validateParameter(valid_595618, JString, required = false,
                                 default = nil)
  if valid_595618 != nil:
    section.add "X-Amz-Algorithm", valid_595618
  var valid_595619 = header.getOrDefault("X-Amz-Signature")
  valid_595619 = validateParameter(valid_595619, JString, required = false,
                                 default = nil)
  if valid_595619 != nil:
    section.add "X-Amz-Signature", valid_595619
  var valid_595620 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595620 = validateParameter(valid_595620, JString, required = false,
                                 default = nil)
  if valid_595620 != nil:
    section.add "X-Amz-SignedHeaders", valid_595620
  var valid_595621 = header.getOrDefault("X-Amz-Credential")
  valid_595621 = validateParameter(valid_595621, JString, required = false,
                                 default = nil)
  if valid_595621 != nil:
    section.add "X-Amz-Credential", valid_595621
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595622: Call_DescribeIndex_595611; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a search index.
  ## 
  let valid = call_595622.validator(path, query, header, formData, body)
  let scheme = call_595622.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595622.url(scheme.get, call_595622.host, call_595622.base,
                         call_595622.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595622, url, valid)

proc call*(call_595623: Call_DescribeIndex_595611; indexName: string): Recallable =
  ## describeIndex
  ## Describes a search index.
  ##   indexName: string (required)
  ##            : The index name.
  var path_595624 = newJObject()
  add(path_595624, "indexName", newJString(indexName))
  result = call_595623.call(path_595624, nil, nil, nil, nil)

var describeIndex* = Call_DescribeIndex_595611(name: "describeIndex",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/indices/{indexName}", validator: validate_DescribeIndex_595612,
    base: "/", url: url_DescribeIndex_595613, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeJobExecution_595625 = ref object of OpenApiRestCall_593437
proc url_DescribeJobExecution_595627(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeJobExecution_595626(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a job execution.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing on which the job execution is running.
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_595628 = path.getOrDefault("thingName")
  valid_595628 = validateParameter(valid_595628, JString, required = true,
                                 default = nil)
  if valid_595628 != nil:
    section.add "thingName", valid_595628
  var valid_595629 = path.getOrDefault("jobId")
  valid_595629 = validateParameter(valid_595629, JString, required = true,
                                 default = nil)
  if valid_595629 != nil:
    section.add "jobId", valid_595629
  result.add "path", section
  ## parameters in `query` object:
  ##   executionNumber: JInt
  ##                  : A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
  section = newJObject()
  var valid_595630 = query.getOrDefault("executionNumber")
  valid_595630 = validateParameter(valid_595630, JInt, required = false, default = nil)
  if valid_595630 != nil:
    section.add "executionNumber", valid_595630
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595631 = header.getOrDefault("X-Amz-Date")
  valid_595631 = validateParameter(valid_595631, JString, required = false,
                                 default = nil)
  if valid_595631 != nil:
    section.add "X-Amz-Date", valid_595631
  var valid_595632 = header.getOrDefault("X-Amz-Security-Token")
  valid_595632 = validateParameter(valid_595632, JString, required = false,
                                 default = nil)
  if valid_595632 != nil:
    section.add "X-Amz-Security-Token", valid_595632
  var valid_595633 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595633 = validateParameter(valid_595633, JString, required = false,
                                 default = nil)
  if valid_595633 != nil:
    section.add "X-Amz-Content-Sha256", valid_595633
  var valid_595634 = header.getOrDefault("X-Amz-Algorithm")
  valid_595634 = validateParameter(valid_595634, JString, required = false,
                                 default = nil)
  if valid_595634 != nil:
    section.add "X-Amz-Algorithm", valid_595634
  var valid_595635 = header.getOrDefault("X-Amz-Signature")
  valid_595635 = validateParameter(valid_595635, JString, required = false,
                                 default = nil)
  if valid_595635 != nil:
    section.add "X-Amz-Signature", valid_595635
  var valid_595636 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595636 = validateParameter(valid_595636, JString, required = false,
                                 default = nil)
  if valid_595636 != nil:
    section.add "X-Amz-SignedHeaders", valid_595636
  var valid_595637 = header.getOrDefault("X-Amz-Credential")
  valid_595637 = validateParameter(valid_595637, JString, required = false,
                                 default = nil)
  if valid_595637 != nil:
    section.add "X-Amz-Credential", valid_595637
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595638: Call_DescribeJobExecution_595625; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a job execution.
  ## 
  let valid = call_595638.validator(path, query, header, formData, body)
  let scheme = call_595638.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595638.url(scheme.get, call_595638.host, call_595638.base,
                         call_595638.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595638, url, valid)

proc call*(call_595639: Call_DescribeJobExecution_595625; thingName: string;
          jobId: string; executionNumber: int = 0): Recallable =
  ## describeJobExecution
  ## Describes a job execution.
  ##   thingName: string (required)
  ##            : The name of the thing on which the job execution is running.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   executionNumber: int
  ##                  : A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
  var path_595640 = newJObject()
  var query_595641 = newJObject()
  add(path_595640, "thingName", newJString(thingName))
  add(path_595640, "jobId", newJString(jobId))
  add(query_595641, "executionNumber", newJInt(executionNumber))
  result = call_595639.call(path_595640, query_595641, nil, nil, nil)

var describeJobExecution* = Call_DescribeJobExecution_595625(
    name: "describeJobExecution", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs/{jobId}",
    validator: validate_DescribeJobExecution_595626, base: "/",
    url: url_DescribeJobExecution_595627, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingRegistrationTask_595642 = ref object of OpenApiRestCall_593437
proc url_DescribeThingRegistrationTask_595644(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeThingRegistrationTask_595643(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The task ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_595645 = path.getOrDefault("taskId")
  valid_595645 = validateParameter(valid_595645, JString, required = true,
                                 default = nil)
  if valid_595645 != nil:
    section.add "taskId", valid_595645
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595646 = header.getOrDefault("X-Amz-Date")
  valid_595646 = validateParameter(valid_595646, JString, required = false,
                                 default = nil)
  if valid_595646 != nil:
    section.add "X-Amz-Date", valid_595646
  var valid_595647 = header.getOrDefault("X-Amz-Security-Token")
  valid_595647 = validateParameter(valid_595647, JString, required = false,
                                 default = nil)
  if valid_595647 != nil:
    section.add "X-Amz-Security-Token", valid_595647
  var valid_595648 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595648 = validateParameter(valid_595648, JString, required = false,
                                 default = nil)
  if valid_595648 != nil:
    section.add "X-Amz-Content-Sha256", valid_595648
  var valid_595649 = header.getOrDefault("X-Amz-Algorithm")
  valid_595649 = validateParameter(valid_595649, JString, required = false,
                                 default = nil)
  if valid_595649 != nil:
    section.add "X-Amz-Algorithm", valid_595649
  var valid_595650 = header.getOrDefault("X-Amz-Signature")
  valid_595650 = validateParameter(valid_595650, JString, required = false,
                                 default = nil)
  if valid_595650 != nil:
    section.add "X-Amz-Signature", valid_595650
  var valid_595651 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595651 = validateParameter(valid_595651, JString, required = false,
                                 default = nil)
  if valid_595651 != nil:
    section.add "X-Amz-SignedHeaders", valid_595651
  var valid_595652 = header.getOrDefault("X-Amz-Credential")
  valid_595652 = validateParameter(valid_595652, JString, required = false,
                                 default = nil)
  if valid_595652 != nil:
    section.add "X-Amz-Credential", valid_595652
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595653: Call_DescribeThingRegistrationTask_595642; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a bulk thing provisioning task.
  ## 
  let valid = call_595653.validator(path, query, header, formData, body)
  let scheme = call_595653.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595653.url(scheme.get, call_595653.host, call_595653.base,
                         call_595653.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595653, url, valid)

proc call*(call_595654: Call_DescribeThingRegistrationTask_595642; taskId: string): Recallable =
  ## describeThingRegistrationTask
  ## Describes a bulk thing provisioning task.
  ##   taskId: string (required)
  ##         : The task ID.
  var path_595655 = newJObject()
  add(path_595655, "taskId", newJString(taskId))
  result = call_595654.call(path_595655, nil, nil, nil, nil)

var describeThingRegistrationTask* = Call_DescribeThingRegistrationTask_595642(
    name: "describeThingRegistrationTask", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks/{taskId}",
    validator: validate_DescribeThingRegistrationTask_595643, base: "/",
    url: url_DescribeThingRegistrationTask_595644,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DisableTopicRule_595656 = ref object of OpenApiRestCall_593437
proc url_DisableTopicRule_595658(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName"),
               (kind: ConstantSegment, value: "/disable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DisableTopicRule_595657(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Disables the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule to disable.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_595659 = path.getOrDefault("ruleName")
  valid_595659 = validateParameter(valid_595659, JString, required = true,
                                 default = nil)
  if valid_595659 != nil:
    section.add "ruleName", valid_595659
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595660 = header.getOrDefault("X-Amz-Date")
  valid_595660 = validateParameter(valid_595660, JString, required = false,
                                 default = nil)
  if valid_595660 != nil:
    section.add "X-Amz-Date", valid_595660
  var valid_595661 = header.getOrDefault("X-Amz-Security-Token")
  valid_595661 = validateParameter(valid_595661, JString, required = false,
                                 default = nil)
  if valid_595661 != nil:
    section.add "X-Amz-Security-Token", valid_595661
  var valid_595662 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595662 = validateParameter(valid_595662, JString, required = false,
                                 default = nil)
  if valid_595662 != nil:
    section.add "X-Amz-Content-Sha256", valid_595662
  var valid_595663 = header.getOrDefault("X-Amz-Algorithm")
  valid_595663 = validateParameter(valid_595663, JString, required = false,
                                 default = nil)
  if valid_595663 != nil:
    section.add "X-Amz-Algorithm", valid_595663
  var valid_595664 = header.getOrDefault("X-Amz-Signature")
  valid_595664 = validateParameter(valid_595664, JString, required = false,
                                 default = nil)
  if valid_595664 != nil:
    section.add "X-Amz-Signature", valid_595664
  var valid_595665 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595665 = validateParameter(valid_595665, JString, required = false,
                                 default = nil)
  if valid_595665 != nil:
    section.add "X-Amz-SignedHeaders", valid_595665
  var valid_595666 = header.getOrDefault("X-Amz-Credential")
  valid_595666 = validateParameter(valid_595666, JString, required = false,
                                 default = nil)
  if valid_595666 != nil:
    section.add "X-Amz-Credential", valid_595666
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595667: Call_DisableTopicRule_595656; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Disables the rule.
  ## 
  let valid = call_595667.validator(path, query, header, formData, body)
  let scheme = call_595667.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595667.url(scheme.get, call_595667.host, call_595667.base,
                         call_595667.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595667, url, valid)

proc call*(call_595668: Call_DisableTopicRule_595656; ruleName: string): Recallable =
  ## disableTopicRule
  ## Disables the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule to disable.
  var path_595669 = newJObject()
  add(path_595669, "ruleName", newJString(ruleName))
  result = call_595668.call(path_595669, nil, nil, nil, nil)

var disableTopicRule* = Call_DisableTopicRule_595656(name: "disableTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}/disable", validator: validate_DisableTopicRule_595657,
    base: "/", url: url_DisableTopicRule_595658,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_EnableTopicRule_595670 = ref object of OpenApiRestCall_593437
proc url_EnableTopicRule_595672(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName"),
               (kind: ConstantSegment, value: "/enable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_EnableTopicRule_595671(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Enables the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the topic rule to enable.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_595673 = path.getOrDefault("ruleName")
  valid_595673 = validateParameter(valid_595673, JString, required = true,
                                 default = nil)
  if valid_595673 != nil:
    section.add "ruleName", valid_595673
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595674 = header.getOrDefault("X-Amz-Date")
  valid_595674 = validateParameter(valid_595674, JString, required = false,
                                 default = nil)
  if valid_595674 != nil:
    section.add "X-Amz-Date", valid_595674
  var valid_595675 = header.getOrDefault("X-Amz-Security-Token")
  valid_595675 = validateParameter(valid_595675, JString, required = false,
                                 default = nil)
  if valid_595675 != nil:
    section.add "X-Amz-Security-Token", valid_595675
  var valid_595676 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595676 = validateParameter(valid_595676, JString, required = false,
                                 default = nil)
  if valid_595676 != nil:
    section.add "X-Amz-Content-Sha256", valid_595676
  var valid_595677 = header.getOrDefault("X-Amz-Algorithm")
  valid_595677 = validateParameter(valid_595677, JString, required = false,
                                 default = nil)
  if valid_595677 != nil:
    section.add "X-Amz-Algorithm", valid_595677
  var valid_595678 = header.getOrDefault("X-Amz-Signature")
  valid_595678 = validateParameter(valid_595678, JString, required = false,
                                 default = nil)
  if valid_595678 != nil:
    section.add "X-Amz-Signature", valid_595678
  var valid_595679 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595679 = validateParameter(valid_595679, JString, required = false,
                                 default = nil)
  if valid_595679 != nil:
    section.add "X-Amz-SignedHeaders", valid_595679
  var valid_595680 = header.getOrDefault("X-Amz-Credential")
  valid_595680 = validateParameter(valid_595680, JString, required = false,
                                 default = nil)
  if valid_595680 != nil:
    section.add "X-Amz-Credential", valid_595680
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595681: Call_EnableTopicRule_595670; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the rule.
  ## 
  let valid = call_595681.validator(path, query, header, formData, body)
  let scheme = call_595681.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595681.url(scheme.get, call_595681.host, call_595681.base,
                         call_595681.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595681, url, valid)

proc call*(call_595682: Call_EnableTopicRule_595670; ruleName: string): Recallable =
  ## enableTopicRule
  ## Enables the rule.
  ##   ruleName: string (required)
  ##           : The name of the topic rule to enable.
  var path_595683 = newJObject()
  add(path_595683, "ruleName", newJString(ruleName))
  result = call_595682.call(path_595683, nil, nil, nil, nil)

var enableTopicRule* = Call_EnableTopicRule_595670(name: "enableTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}/enable", validator: validate_EnableTopicRule_595671,
    base: "/", url: url_EnableTopicRule_595672, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEffectivePolicies_595684 = ref object of OpenApiRestCall_593437
proc url_GetEffectivePolicies_595686(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetEffectivePolicies_595685(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingName: JString
  ##            : The thing name.
  section = newJObject()
  var valid_595687 = query.getOrDefault("thingName")
  valid_595687 = validateParameter(valid_595687, JString, required = false,
                                 default = nil)
  if valid_595687 != nil:
    section.add "thingName", valid_595687
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595688 = header.getOrDefault("X-Amz-Date")
  valid_595688 = validateParameter(valid_595688, JString, required = false,
                                 default = nil)
  if valid_595688 != nil:
    section.add "X-Amz-Date", valid_595688
  var valid_595689 = header.getOrDefault("X-Amz-Security-Token")
  valid_595689 = validateParameter(valid_595689, JString, required = false,
                                 default = nil)
  if valid_595689 != nil:
    section.add "X-Amz-Security-Token", valid_595689
  var valid_595690 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595690 = validateParameter(valid_595690, JString, required = false,
                                 default = nil)
  if valid_595690 != nil:
    section.add "X-Amz-Content-Sha256", valid_595690
  var valid_595691 = header.getOrDefault("X-Amz-Algorithm")
  valid_595691 = validateParameter(valid_595691, JString, required = false,
                                 default = nil)
  if valid_595691 != nil:
    section.add "X-Amz-Algorithm", valid_595691
  var valid_595692 = header.getOrDefault("X-Amz-Signature")
  valid_595692 = validateParameter(valid_595692, JString, required = false,
                                 default = nil)
  if valid_595692 != nil:
    section.add "X-Amz-Signature", valid_595692
  var valid_595693 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595693 = validateParameter(valid_595693, JString, required = false,
                                 default = nil)
  if valid_595693 != nil:
    section.add "X-Amz-SignedHeaders", valid_595693
  var valid_595694 = header.getOrDefault("X-Amz-Credential")
  valid_595694 = validateParameter(valid_595694, JString, required = false,
                                 default = nil)
  if valid_595694 != nil:
    section.add "X-Amz-Credential", valid_595694
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595696: Call_GetEffectivePolicies_595684; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ## 
  let valid = call_595696.validator(path, query, header, formData, body)
  let scheme = call_595696.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595696.url(scheme.get, call_595696.host, call_595696.base,
                         call_595696.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595696, url, valid)

proc call*(call_595697: Call_GetEffectivePolicies_595684; body: JsonNode;
          thingName: string = ""): Recallable =
  ## getEffectivePolicies
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ##   thingName: string
  ##            : The thing name.
  ##   body: JObject (required)
  var query_595698 = newJObject()
  var body_595699 = newJObject()
  add(query_595698, "thingName", newJString(thingName))
  if body != nil:
    body_595699 = body
  result = call_595697.call(nil, query_595698, nil, nil, body_595699)

var getEffectivePolicies* = Call_GetEffectivePolicies_595684(
    name: "getEffectivePolicies", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/effective-policies",
    validator: validate_GetEffectivePolicies_595685, base: "/",
    url: url_GetEffectivePolicies_595686, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateIndexingConfiguration_595712 = ref object of OpenApiRestCall_593437
proc url_UpdateIndexingConfiguration_595714(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateIndexingConfiguration_595713(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the search configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595715 = header.getOrDefault("X-Amz-Date")
  valid_595715 = validateParameter(valid_595715, JString, required = false,
                                 default = nil)
  if valid_595715 != nil:
    section.add "X-Amz-Date", valid_595715
  var valid_595716 = header.getOrDefault("X-Amz-Security-Token")
  valid_595716 = validateParameter(valid_595716, JString, required = false,
                                 default = nil)
  if valid_595716 != nil:
    section.add "X-Amz-Security-Token", valid_595716
  var valid_595717 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595717 = validateParameter(valid_595717, JString, required = false,
                                 default = nil)
  if valid_595717 != nil:
    section.add "X-Amz-Content-Sha256", valid_595717
  var valid_595718 = header.getOrDefault("X-Amz-Algorithm")
  valid_595718 = validateParameter(valid_595718, JString, required = false,
                                 default = nil)
  if valid_595718 != nil:
    section.add "X-Amz-Algorithm", valid_595718
  var valid_595719 = header.getOrDefault("X-Amz-Signature")
  valid_595719 = validateParameter(valid_595719, JString, required = false,
                                 default = nil)
  if valid_595719 != nil:
    section.add "X-Amz-Signature", valid_595719
  var valid_595720 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595720 = validateParameter(valid_595720, JString, required = false,
                                 default = nil)
  if valid_595720 != nil:
    section.add "X-Amz-SignedHeaders", valid_595720
  var valid_595721 = header.getOrDefault("X-Amz-Credential")
  valid_595721 = validateParameter(valid_595721, JString, required = false,
                                 default = nil)
  if valid_595721 != nil:
    section.add "X-Amz-Credential", valid_595721
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595723: Call_UpdateIndexingConfiguration_595712; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the search configuration.
  ## 
  let valid = call_595723.validator(path, query, header, formData, body)
  let scheme = call_595723.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595723.url(scheme.get, call_595723.host, call_595723.base,
                         call_595723.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595723, url, valid)

proc call*(call_595724: Call_UpdateIndexingConfiguration_595712; body: JsonNode): Recallable =
  ## updateIndexingConfiguration
  ## Updates the search configuration.
  ##   body: JObject (required)
  var body_595725 = newJObject()
  if body != nil:
    body_595725 = body
  result = call_595724.call(nil, nil, nil, nil, body_595725)

var updateIndexingConfiguration* = Call_UpdateIndexingConfiguration_595712(
    name: "updateIndexingConfiguration", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/indexing/config",
    validator: validate_UpdateIndexingConfiguration_595713, base: "/",
    url: url_UpdateIndexingConfiguration_595714,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetIndexingConfiguration_595700 = ref object of OpenApiRestCall_593437
proc url_GetIndexingConfiguration_595702(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetIndexingConfiguration_595701(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the search configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595703 = header.getOrDefault("X-Amz-Date")
  valid_595703 = validateParameter(valid_595703, JString, required = false,
                                 default = nil)
  if valid_595703 != nil:
    section.add "X-Amz-Date", valid_595703
  var valid_595704 = header.getOrDefault("X-Amz-Security-Token")
  valid_595704 = validateParameter(valid_595704, JString, required = false,
                                 default = nil)
  if valid_595704 != nil:
    section.add "X-Amz-Security-Token", valid_595704
  var valid_595705 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595705 = validateParameter(valid_595705, JString, required = false,
                                 default = nil)
  if valid_595705 != nil:
    section.add "X-Amz-Content-Sha256", valid_595705
  var valid_595706 = header.getOrDefault("X-Amz-Algorithm")
  valid_595706 = validateParameter(valid_595706, JString, required = false,
                                 default = nil)
  if valid_595706 != nil:
    section.add "X-Amz-Algorithm", valid_595706
  var valid_595707 = header.getOrDefault("X-Amz-Signature")
  valid_595707 = validateParameter(valid_595707, JString, required = false,
                                 default = nil)
  if valid_595707 != nil:
    section.add "X-Amz-Signature", valid_595707
  var valid_595708 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595708 = validateParameter(valid_595708, JString, required = false,
                                 default = nil)
  if valid_595708 != nil:
    section.add "X-Amz-SignedHeaders", valid_595708
  var valid_595709 = header.getOrDefault("X-Amz-Credential")
  valid_595709 = validateParameter(valid_595709, JString, required = false,
                                 default = nil)
  if valid_595709 != nil:
    section.add "X-Amz-Credential", valid_595709
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595710: Call_GetIndexingConfiguration_595700; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the search configuration.
  ## 
  let valid = call_595710.validator(path, query, header, formData, body)
  let scheme = call_595710.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595710.url(scheme.get, call_595710.host, call_595710.base,
                         call_595710.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595710, url, valid)

proc call*(call_595711: Call_GetIndexingConfiguration_595700): Recallable =
  ## getIndexingConfiguration
  ## Gets the search configuration.
  result = call_595711.call(nil, nil, nil, nil, nil)

var getIndexingConfiguration* = Call_GetIndexingConfiguration_595700(
    name: "getIndexingConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/indexing/config",
    validator: validate_GetIndexingConfiguration_595701, base: "/",
    url: url_GetIndexingConfiguration_595702, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetJobDocument_595726 = ref object of OpenApiRestCall_593437
proc url_GetJobDocument_595728(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/job-document")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetJobDocument_595727(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets a job document.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_595729 = path.getOrDefault("jobId")
  valid_595729 = validateParameter(valid_595729, JString, required = true,
                                 default = nil)
  if valid_595729 != nil:
    section.add "jobId", valid_595729
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595730 = header.getOrDefault("X-Amz-Date")
  valid_595730 = validateParameter(valid_595730, JString, required = false,
                                 default = nil)
  if valid_595730 != nil:
    section.add "X-Amz-Date", valid_595730
  var valid_595731 = header.getOrDefault("X-Amz-Security-Token")
  valid_595731 = validateParameter(valid_595731, JString, required = false,
                                 default = nil)
  if valid_595731 != nil:
    section.add "X-Amz-Security-Token", valid_595731
  var valid_595732 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595732 = validateParameter(valid_595732, JString, required = false,
                                 default = nil)
  if valid_595732 != nil:
    section.add "X-Amz-Content-Sha256", valid_595732
  var valid_595733 = header.getOrDefault("X-Amz-Algorithm")
  valid_595733 = validateParameter(valid_595733, JString, required = false,
                                 default = nil)
  if valid_595733 != nil:
    section.add "X-Amz-Algorithm", valid_595733
  var valid_595734 = header.getOrDefault("X-Amz-Signature")
  valid_595734 = validateParameter(valid_595734, JString, required = false,
                                 default = nil)
  if valid_595734 != nil:
    section.add "X-Amz-Signature", valid_595734
  var valid_595735 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595735 = validateParameter(valid_595735, JString, required = false,
                                 default = nil)
  if valid_595735 != nil:
    section.add "X-Amz-SignedHeaders", valid_595735
  var valid_595736 = header.getOrDefault("X-Amz-Credential")
  valid_595736 = validateParameter(valid_595736, JString, required = false,
                                 default = nil)
  if valid_595736 != nil:
    section.add "X-Amz-Credential", valid_595736
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595737: Call_GetJobDocument_595726; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a job document.
  ## 
  let valid = call_595737.validator(path, query, header, formData, body)
  let scheme = call_595737.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595737.url(scheme.get, call_595737.host, call_595737.base,
                         call_595737.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595737, url, valid)

proc call*(call_595738: Call_GetJobDocument_595726; jobId: string): Recallable =
  ## getJobDocument
  ## Gets a job document.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  var path_595739 = newJObject()
  add(path_595739, "jobId", newJString(jobId))
  result = call_595738.call(path_595739, nil, nil, nil, nil)

var getJobDocument* = Call_GetJobDocument_595726(name: "getJobDocument",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/jobs/{jobId}/job-document", validator: validate_GetJobDocument_595727,
    base: "/", url: url_GetJobDocument_595728, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetLoggingOptions_595752 = ref object of OpenApiRestCall_593437
proc url_SetLoggingOptions_595754(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_SetLoggingOptions_595753(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595755 = header.getOrDefault("X-Amz-Date")
  valid_595755 = validateParameter(valid_595755, JString, required = false,
                                 default = nil)
  if valid_595755 != nil:
    section.add "X-Amz-Date", valid_595755
  var valid_595756 = header.getOrDefault("X-Amz-Security-Token")
  valid_595756 = validateParameter(valid_595756, JString, required = false,
                                 default = nil)
  if valid_595756 != nil:
    section.add "X-Amz-Security-Token", valid_595756
  var valid_595757 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595757 = validateParameter(valid_595757, JString, required = false,
                                 default = nil)
  if valid_595757 != nil:
    section.add "X-Amz-Content-Sha256", valid_595757
  var valid_595758 = header.getOrDefault("X-Amz-Algorithm")
  valid_595758 = validateParameter(valid_595758, JString, required = false,
                                 default = nil)
  if valid_595758 != nil:
    section.add "X-Amz-Algorithm", valid_595758
  var valid_595759 = header.getOrDefault("X-Amz-Signature")
  valid_595759 = validateParameter(valid_595759, JString, required = false,
                                 default = nil)
  if valid_595759 != nil:
    section.add "X-Amz-Signature", valid_595759
  var valid_595760 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595760 = validateParameter(valid_595760, JString, required = false,
                                 default = nil)
  if valid_595760 != nil:
    section.add "X-Amz-SignedHeaders", valid_595760
  var valid_595761 = header.getOrDefault("X-Amz-Credential")
  valid_595761 = validateParameter(valid_595761, JString, required = false,
                                 default = nil)
  if valid_595761 != nil:
    section.add "X-Amz-Credential", valid_595761
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595763: Call_SetLoggingOptions_595752; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ## 
  let valid = call_595763.validator(path, query, header, formData, body)
  let scheme = call_595763.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595763.url(scheme.get, call_595763.host, call_595763.base,
                         call_595763.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595763, url, valid)

proc call*(call_595764: Call_SetLoggingOptions_595752; body: JsonNode): Recallable =
  ## setLoggingOptions
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ##   body: JObject (required)
  var body_595765 = newJObject()
  if body != nil:
    body_595765 = body
  result = call_595764.call(nil, nil, nil, nil, body_595765)

var setLoggingOptions* = Call_SetLoggingOptions_595752(name: "setLoggingOptions",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/loggingOptions",
    validator: validate_SetLoggingOptions_595753, base: "/",
    url: url_SetLoggingOptions_595754, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetLoggingOptions_595740 = ref object of OpenApiRestCall_593437
proc url_GetLoggingOptions_595742(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetLoggingOptions_595741(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595743 = header.getOrDefault("X-Amz-Date")
  valid_595743 = validateParameter(valid_595743, JString, required = false,
                                 default = nil)
  if valid_595743 != nil:
    section.add "X-Amz-Date", valid_595743
  var valid_595744 = header.getOrDefault("X-Amz-Security-Token")
  valid_595744 = validateParameter(valid_595744, JString, required = false,
                                 default = nil)
  if valid_595744 != nil:
    section.add "X-Amz-Security-Token", valid_595744
  var valid_595745 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595745 = validateParameter(valid_595745, JString, required = false,
                                 default = nil)
  if valid_595745 != nil:
    section.add "X-Amz-Content-Sha256", valid_595745
  var valid_595746 = header.getOrDefault("X-Amz-Algorithm")
  valid_595746 = validateParameter(valid_595746, JString, required = false,
                                 default = nil)
  if valid_595746 != nil:
    section.add "X-Amz-Algorithm", valid_595746
  var valid_595747 = header.getOrDefault("X-Amz-Signature")
  valid_595747 = validateParameter(valid_595747, JString, required = false,
                                 default = nil)
  if valid_595747 != nil:
    section.add "X-Amz-Signature", valid_595747
  var valid_595748 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595748 = validateParameter(valid_595748, JString, required = false,
                                 default = nil)
  if valid_595748 != nil:
    section.add "X-Amz-SignedHeaders", valid_595748
  var valid_595749 = header.getOrDefault("X-Amz-Credential")
  valid_595749 = validateParameter(valid_595749, JString, required = false,
                                 default = nil)
  if valid_595749 != nil:
    section.add "X-Amz-Credential", valid_595749
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595750: Call_GetLoggingOptions_595740; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  ## 
  let valid = call_595750.validator(path, query, header, formData, body)
  let scheme = call_595750.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595750.url(scheme.get, call_595750.host, call_595750.base,
                         call_595750.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595750, url, valid)

proc call*(call_595751: Call_GetLoggingOptions_595740): Recallable =
  ## getLoggingOptions
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  result = call_595751.call(nil, nil, nil, nil, nil)

var getLoggingOptions* = Call_GetLoggingOptions_595740(name: "getLoggingOptions",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/loggingOptions",
    validator: validate_GetLoggingOptions_595741, base: "/",
    url: url_GetLoggingOptions_595742, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetStatistics_595766 = ref object of OpenApiRestCall_593437
proc url_GetStatistics_595768(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetStatistics_595767(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets statistics about things that match the specified query.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595769 = header.getOrDefault("X-Amz-Date")
  valid_595769 = validateParameter(valid_595769, JString, required = false,
                                 default = nil)
  if valid_595769 != nil:
    section.add "X-Amz-Date", valid_595769
  var valid_595770 = header.getOrDefault("X-Amz-Security-Token")
  valid_595770 = validateParameter(valid_595770, JString, required = false,
                                 default = nil)
  if valid_595770 != nil:
    section.add "X-Amz-Security-Token", valid_595770
  var valid_595771 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595771 = validateParameter(valid_595771, JString, required = false,
                                 default = nil)
  if valid_595771 != nil:
    section.add "X-Amz-Content-Sha256", valid_595771
  var valid_595772 = header.getOrDefault("X-Amz-Algorithm")
  valid_595772 = validateParameter(valid_595772, JString, required = false,
                                 default = nil)
  if valid_595772 != nil:
    section.add "X-Amz-Algorithm", valid_595772
  var valid_595773 = header.getOrDefault("X-Amz-Signature")
  valid_595773 = validateParameter(valid_595773, JString, required = false,
                                 default = nil)
  if valid_595773 != nil:
    section.add "X-Amz-Signature", valid_595773
  var valid_595774 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595774 = validateParameter(valid_595774, JString, required = false,
                                 default = nil)
  if valid_595774 != nil:
    section.add "X-Amz-SignedHeaders", valid_595774
  var valid_595775 = header.getOrDefault("X-Amz-Credential")
  valid_595775 = validateParameter(valid_595775, JString, required = false,
                                 default = nil)
  if valid_595775 != nil:
    section.add "X-Amz-Credential", valid_595775
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595777: Call_GetStatistics_595766; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets statistics about things that match the specified query.
  ## 
  let valid = call_595777.validator(path, query, header, formData, body)
  let scheme = call_595777.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595777.url(scheme.get, call_595777.host, call_595777.base,
                         call_595777.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595777, url, valid)

proc call*(call_595778: Call_GetStatistics_595766; body: JsonNode): Recallable =
  ## getStatistics
  ## Gets statistics about things that match the specified query.
  ##   body: JObject (required)
  var body_595779 = newJObject()
  if body != nil:
    body_595779 = body
  result = call_595778.call(nil, nil, nil, nil, body_595779)

var getStatistics* = Call_GetStatistics_595766(name: "getStatistics",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/statistics", validator: validate_GetStatistics_595767,
    base: "/", url: url_GetStatistics_595768, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetV2LoggingOptions_595792 = ref object of OpenApiRestCall_593437
proc url_SetV2LoggingOptions_595794(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_SetV2LoggingOptions_595793(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Sets the logging options for the V2 logging service.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595795 = header.getOrDefault("X-Amz-Date")
  valid_595795 = validateParameter(valid_595795, JString, required = false,
                                 default = nil)
  if valid_595795 != nil:
    section.add "X-Amz-Date", valid_595795
  var valid_595796 = header.getOrDefault("X-Amz-Security-Token")
  valid_595796 = validateParameter(valid_595796, JString, required = false,
                                 default = nil)
  if valid_595796 != nil:
    section.add "X-Amz-Security-Token", valid_595796
  var valid_595797 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595797 = validateParameter(valid_595797, JString, required = false,
                                 default = nil)
  if valid_595797 != nil:
    section.add "X-Amz-Content-Sha256", valid_595797
  var valid_595798 = header.getOrDefault("X-Amz-Algorithm")
  valid_595798 = validateParameter(valid_595798, JString, required = false,
                                 default = nil)
  if valid_595798 != nil:
    section.add "X-Amz-Algorithm", valid_595798
  var valid_595799 = header.getOrDefault("X-Amz-Signature")
  valid_595799 = validateParameter(valid_595799, JString, required = false,
                                 default = nil)
  if valid_595799 != nil:
    section.add "X-Amz-Signature", valid_595799
  var valid_595800 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595800 = validateParameter(valid_595800, JString, required = false,
                                 default = nil)
  if valid_595800 != nil:
    section.add "X-Amz-SignedHeaders", valid_595800
  var valid_595801 = header.getOrDefault("X-Amz-Credential")
  valid_595801 = validateParameter(valid_595801, JString, required = false,
                                 default = nil)
  if valid_595801 != nil:
    section.add "X-Amz-Credential", valid_595801
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595803: Call_SetV2LoggingOptions_595792; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the logging options for the V2 logging service.
  ## 
  let valid = call_595803.validator(path, query, header, formData, body)
  let scheme = call_595803.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595803.url(scheme.get, call_595803.host, call_595803.base,
                         call_595803.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595803, url, valid)

proc call*(call_595804: Call_SetV2LoggingOptions_595792; body: JsonNode): Recallable =
  ## setV2LoggingOptions
  ## Sets the logging options for the V2 logging service.
  ##   body: JObject (required)
  var body_595805 = newJObject()
  if body != nil:
    body_595805 = body
  result = call_595804.call(nil, nil, nil, nil, body_595805)

var setV2LoggingOptions* = Call_SetV2LoggingOptions_595792(
    name: "setV2LoggingOptions", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/v2LoggingOptions",
    validator: validate_SetV2LoggingOptions_595793, base: "/",
    url: url_SetV2LoggingOptions_595794, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetV2LoggingOptions_595780 = ref object of OpenApiRestCall_593437
proc url_GetV2LoggingOptions_595782(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetV2LoggingOptions_595781(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets the fine grained logging options.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595783 = header.getOrDefault("X-Amz-Date")
  valid_595783 = validateParameter(valid_595783, JString, required = false,
                                 default = nil)
  if valid_595783 != nil:
    section.add "X-Amz-Date", valid_595783
  var valid_595784 = header.getOrDefault("X-Amz-Security-Token")
  valid_595784 = validateParameter(valid_595784, JString, required = false,
                                 default = nil)
  if valid_595784 != nil:
    section.add "X-Amz-Security-Token", valid_595784
  var valid_595785 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595785 = validateParameter(valid_595785, JString, required = false,
                                 default = nil)
  if valid_595785 != nil:
    section.add "X-Amz-Content-Sha256", valid_595785
  var valid_595786 = header.getOrDefault("X-Amz-Algorithm")
  valid_595786 = validateParameter(valid_595786, JString, required = false,
                                 default = nil)
  if valid_595786 != nil:
    section.add "X-Amz-Algorithm", valid_595786
  var valid_595787 = header.getOrDefault("X-Amz-Signature")
  valid_595787 = validateParameter(valid_595787, JString, required = false,
                                 default = nil)
  if valid_595787 != nil:
    section.add "X-Amz-Signature", valid_595787
  var valid_595788 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595788 = validateParameter(valid_595788, JString, required = false,
                                 default = nil)
  if valid_595788 != nil:
    section.add "X-Amz-SignedHeaders", valid_595788
  var valid_595789 = header.getOrDefault("X-Amz-Credential")
  valid_595789 = validateParameter(valid_595789, JString, required = false,
                                 default = nil)
  if valid_595789 != nil:
    section.add "X-Amz-Credential", valid_595789
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595790: Call_GetV2LoggingOptions_595780; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the fine grained logging options.
  ## 
  let valid = call_595790.validator(path, query, header, formData, body)
  let scheme = call_595790.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595790.url(scheme.get, call_595790.host, call_595790.base,
                         call_595790.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595790, url, valid)

proc call*(call_595791: Call_GetV2LoggingOptions_595780): Recallable =
  ## getV2LoggingOptions
  ## Gets the fine grained logging options.
  result = call_595791.call(nil, nil, nil, nil, nil)

var getV2LoggingOptions* = Call_GetV2LoggingOptions_595780(
    name: "getV2LoggingOptions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/v2LoggingOptions",
    validator: validate_GetV2LoggingOptions_595781, base: "/",
    url: url_GetV2LoggingOptions_595782, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListActiveViolations_595806 = ref object of OpenApiRestCall_593437
proc url_ListActiveViolations_595808(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListActiveViolations_595807(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the active violations for a given Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingName: JString
  ##            : The name of the thing whose active violations are listed.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   securityProfileName: JString
  ##                      : The name of the Device Defender security profile for which violations are listed.
  section = newJObject()
  var valid_595809 = query.getOrDefault("thingName")
  valid_595809 = validateParameter(valid_595809, JString, required = false,
                                 default = nil)
  if valid_595809 != nil:
    section.add "thingName", valid_595809
  var valid_595810 = query.getOrDefault("maxResults")
  valid_595810 = validateParameter(valid_595810, JInt, required = false, default = nil)
  if valid_595810 != nil:
    section.add "maxResults", valid_595810
  var valid_595811 = query.getOrDefault("nextToken")
  valid_595811 = validateParameter(valid_595811, JString, required = false,
                                 default = nil)
  if valid_595811 != nil:
    section.add "nextToken", valid_595811
  var valid_595812 = query.getOrDefault("securityProfileName")
  valid_595812 = validateParameter(valid_595812, JString, required = false,
                                 default = nil)
  if valid_595812 != nil:
    section.add "securityProfileName", valid_595812
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595813 = header.getOrDefault("X-Amz-Date")
  valid_595813 = validateParameter(valid_595813, JString, required = false,
                                 default = nil)
  if valid_595813 != nil:
    section.add "X-Amz-Date", valid_595813
  var valid_595814 = header.getOrDefault("X-Amz-Security-Token")
  valid_595814 = validateParameter(valid_595814, JString, required = false,
                                 default = nil)
  if valid_595814 != nil:
    section.add "X-Amz-Security-Token", valid_595814
  var valid_595815 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595815 = validateParameter(valid_595815, JString, required = false,
                                 default = nil)
  if valid_595815 != nil:
    section.add "X-Amz-Content-Sha256", valid_595815
  var valid_595816 = header.getOrDefault("X-Amz-Algorithm")
  valid_595816 = validateParameter(valid_595816, JString, required = false,
                                 default = nil)
  if valid_595816 != nil:
    section.add "X-Amz-Algorithm", valid_595816
  var valid_595817 = header.getOrDefault("X-Amz-Signature")
  valid_595817 = validateParameter(valid_595817, JString, required = false,
                                 default = nil)
  if valid_595817 != nil:
    section.add "X-Amz-Signature", valid_595817
  var valid_595818 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595818 = validateParameter(valid_595818, JString, required = false,
                                 default = nil)
  if valid_595818 != nil:
    section.add "X-Amz-SignedHeaders", valid_595818
  var valid_595819 = header.getOrDefault("X-Amz-Credential")
  valid_595819 = validateParameter(valid_595819, JString, required = false,
                                 default = nil)
  if valid_595819 != nil:
    section.add "X-Amz-Credential", valid_595819
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595820: Call_ListActiveViolations_595806; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the active violations for a given Device Defender security profile.
  ## 
  let valid = call_595820.validator(path, query, header, formData, body)
  let scheme = call_595820.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595820.url(scheme.get, call_595820.host, call_595820.base,
                         call_595820.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595820, url, valid)

proc call*(call_595821: Call_ListActiveViolations_595806; thingName: string = "";
          maxResults: int = 0; nextToken: string = ""; securityProfileName: string = ""): Recallable =
  ## listActiveViolations
  ## Lists the active violations for a given Device Defender security profile.
  ##   thingName: string
  ##            : The name of the thing whose active violations are listed.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string
  ##                      : The name of the Device Defender security profile for which violations are listed.
  var query_595822 = newJObject()
  add(query_595822, "thingName", newJString(thingName))
  add(query_595822, "maxResults", newJInt(maxResults))
  add(query_595822, "nextToken", newJString(nextToken))
  add(query_595822, "securityProfileName", newJString(securityProfileName))
  result = call_595821.call(nil, query_595822, nil, nil, nil)

var listActiveViolations* = Call_ListActiveViolations_595806(
    name: "listActiveViolations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/active-violations",
    validator: validate_ListActiveViolations_595807, base: "/",
    url: url_ListActiveViolations_595808, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAttachedPolicies_595823 = ref object of OpenApiRestCall_593437
proc url_ListAttachedPolicies_595825(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "target" in path, "`target` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/attached-policies/"),
               (kind: VariableSegment, value: "target")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListAttachedPolicies_595824(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the policies attached to the specified thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   target: JString (required)
  ##         : The group or principal for which the policies will be listed.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `target` field"
  var valid_595826 = path.getOrDefault("target")
  valid_595826 = validateParameter(valid_595826, JString, required = true,
                                 default = nil)
  if valid_595826 != nil:
    section.add "target", valid_595826
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The token to retrieve the next set of results.
  ##   pageSize: JInt
  ##           : The maximum number of results to be returned per request.
  ##   recursive: JBool
  ##            : When true, recursively list attached policies.
  section = newJObject()
  var valid_595827 = query.getOrDefault("marker")
  valid_595827 = validateParameter(valid_595827, JString, required = false,
                                 default = nil)
  if valid_595827 != nil:
    section.add "marker", valid_595827
  var valid_595828 = query.getOrDefault("pageSize")
  valid_595828 = validateParameter(valid_595828, JInt, required = false, default = nil)
  if valid_595828 != nil:
    section.add "pageSize", valid_595828
  var valid_595829 = query.getOrDefault("recursive")
  valid_595829 = validateParameter(valid_595829, JBool, required = false, default = nil)
  if valid_595829 != nil:
    section.add "recursive", valid_595829
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595830 = header.getOrDefault("X-Amz-Date")
  valid_595830 = validateParameter(valid_595830, JString, required = false,
                                 default = nil)
  if valid_595830 != nil:
    section.add "X-Amz-Date", valid_595830
  var valid_595831 = header.getOrDefault("X-Amz-Security-Token")
  valid_595831 = validateParameter(valid_595831, JString, required = false,
                                 default = nil)
  if valid_595831 != nil:
    section.add "X-Amz-Security-Token", valid_595831
  var valid_595832 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595832 = validateParameter(valid_595832, JString, required = false,
                                 default = nil)
  if valid_595832 != nil:
    section.add "X-Amz-Content-Sha256", valid_595832
  var valid_595833 = header.getOrDefault("X-Amz-Algorithm")
  valid_595833 = validateParameter(valid_595833, JString, required = false,
                                 default = nil)
  if valid_595833 != nil:
    section.add "X-Amz-Algorithm", valid_595833
  var valid_595834 = header.getOrDefault("X-Amz-Signature")
  valid_595834 = validateParameter(valid_595834, JString, required = false,
                                 default = nil)
  if valid_595834 != nil:
    section.add "X-Amz-Signature", valid_595834
  var valid_595835 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595835 = validateParameter(valid_595835, JString, required = false,
                                 default = nil)
  if valid_595835 != nil:
    section.add "X-Amz-SignedHeaders", valid_595835
  var valid_595836 = header.getOrDefault("X-Amz-Credential")
  valid_595836 = validateParameter(valid_595836, JString, required = false,
                                 default = nil)
  if valid_595836 != nil:
    section.add "X-Amz-Credential", valid_595836
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595837: Call_ListAttachedPolicies_595823; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the policies attached to the specified thing group.
  ## 
  let valid = call_595837.validator(path, query, header, formData, body)
  let scheme = call_595837.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595837.url(scheme.get, call_595837.host, call_595837.base,
                         call_595837.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595837, url, valid)

proc call*(call_595838: Call_ListAttachedPolicies_595823; target: string;
          marker: string = ""; pageSize: int = 0; recursive: bool = false): Recallable =
  ## listAttachedPolicies
  ## Lists the policies attached to the specified thing group.
  ##   marker: string
  ##         : The token to retrieve the next set of results.
  ##   pageSize: int
  ##           : The maximum number of results to be returned per request.
  ##   recursive: bool
  ##            : When true, recursively list attached policies.
  ##   target: string (required)
  ##         : The group or principal for which the policies will be listed.
  var path_595839 = newJObject()
  var query_595840 = newJObject()
  add(query_595840, "marker", newJString(marker))
  add(query_595840, "pageSize", newJInt(pageSize))
  add(query_595840, "recursive", newJBool(recursive))
  add(path_595839, "target", newJString(target))
  result = call_595838.call(path_595839, query_595840, nil, nil, nil)

var listAttachedPolicies* = Call_ListAttachedPolicies_595823(
    name: "listAttachedPolicies", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/attached-policies/{target}",
    validator: validate_ListAttachedPolicies_595824, base: "/",
    url: url_ListAttachedPolicies_595825, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditFindings_595841 = ref object of OpenApiRestCall_593437
proc url_ListAuditFindings_595843(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListAuditFindings_595842(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595844 = header.getOrDefault("X-Amz-Date")
  valid_595844 = validateParameter(valid_595844, JString, required = false,
                                 default = nil)
  if valid_595844 != nil:
    section.add "X-Amz-Date", valid_595844
  var valid_595845 = header.getOrDefault("X-Amz-Security-Token")
  valid_595845 = validateParameter(valid_595845, JString, required = false,
                                 default = nil)
  if valid_595845 != nil:
    section.add "X-Amz-Security-Token", valid_595845
  var valid_595846 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595846 = validateParameter(valid_595846, JString, required = false,
                                 default = nil)
  if valid_595846 != nil:
    section.add "X-Amz-Content-Sha256", valid_595846
  var valid_595847 = header.getOrDefault("X-Amz-Algorithm")
  valid_595847 = validateParameter(valid_595847, JString, required = false,
                                 default = nil)
  if valid_595847 != nil:
    section.add "X-Amz-Algorithm", valid_595847
  var valid_595848 = header.getOrDefault("X-Amz-Signature")
  valid_595848 = validateParameter(valid_595848, JString, required = false,
                                 default = nil)
  if valid_595848 != nil:
    section.add "X-Amz-Signature", valid_595848
  var valid_595849 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595849 = validateParameter(valid_595849, JString, required = false,
                                 default = nil)
  if valid_595849 != nil:
    section.add "X-Amz-SignedHeaders", valid_595849
  var valid_595850 = header.getOrDefault("X-Amz-Credential")
  valid_595850 = validateParameter(valid_595850, JString, required = false,
                                 default = nil)
  if valid_595850 != nil:
    section.add "X-Amz-Credential", valid_595850
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595852: Call_ListAuditFindings_595841; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ## 
  let valid = call_595852.validator(path, query, header, formData, body)
  let scheme = call_595852.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595852.url(scheme.get, call_595852.host, call_595852.base,
                         call_595852.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595852, url, valid)

proc call*(call_595853: Call_ListAuditFindings_595841; body: JsonNode): Recallable =
  ## listAuditFindings
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ##   body: JObject (required)
  var body_595854 = newJObject()
  if body != nil:
    body_595854 = body
  result = call_595853.call(nil, nil, nil, nil, body_595854)

var listAuditFindings* = Call_ListAuditFindings_595841(name: "listAuditFindings",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/audit/findings",
    validator: validate_ListAuditFindings_595842, base: "/",
    url: url_ListAuditFindings_595843, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditMitigationActionsExecutions_595855 = ref object of OpenApiRestCall_593437
proc url_ListAuditMitigationActionsExecutions_595857(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListAuditMitigationActionsExecutions_595856(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the status of audit mitigation action tasks that were executed.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   findingId: JString (required)
  ##            : Specify this filter to limit results to those that were applied to a specific audit finding.
  ##   taskId: JString (required)
  ##         : Specify this filter to limit results to actions for a specific audit mitigation actions task.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   actionStatus: JString
  ##               : Specify this filter to limit results to those with a specific status.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `findingId` field"
  var valid_595858 = query.getOrDefault("findingId")
  valid_595858 = validateParameter(valid_595858, JString, required = true,
                                 default = nil)
  if valid_595858 != nil:
    section.add "findingId", valid_595858
  var valid_595859 = query.getOrDefault("taskId")
  valid_595859 = validateParameter(valid_595859, JString, required = true,
                                 default = nil)
  if valid_595859 != nil:
    section.add "taskId", valid_595859
  var valid_595860 = query.getOrDefault("maxResults")
  valid_595860 = validateParameter(valid_595860, JInt, required = false, default = nil)
  if valid_595860 != nil:
    section.add "maxResults", valid_595860
  var valid_595861 = query.getOrDefault("nextToken")
  valid_595861 = validateParameter(valid_595861, JString, required = false,
                                 default = nil)
  if valid_595861 != nil:
    section.add "nextToken", valid_595861
  var valid_595862 = query.getOrDefault("actionStatus")
  valid_595862 = validateParameter(valid_595862, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_595862 != nil:
    section.add "actionStatus", valid_595862
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595863 = header.getOrDefault("X-Amz-Date")
  valid_595863 = validateParameter(valid_595863, JString, required = false,
                                 default = nil)
  if valid_595863 != nil:
    section.add "X-Amz-Date", valid_595863
  var valid_595864 = header.getOrDefault("X-Amz-Security-Token")
  valid_595864 = validateParameter(valid_595864, JString, required = false,
                                 default = nil)
  if valid_595864 != nil:
    section.add "X-Amz-Security-Token", valid_595864
  var valid_595865 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595865 = validateParameter(valid_595865, JString, required = false,
                                 default = nil)
  if valid_595865 != nil:
    section.add "X-Amz-Content-Sha256", valid_595865
  var valid_595866 = header.getOrDefault("X-Amz-Algorithm")
  valid_595866 = validateParameter(valid_595866, JString, required = false,
                                 default = nil)
  if valid_595866 != nil:
    section.add "X-Amz-Algorithm", valid_595866
  var valid_595867 = header.getOrDefault("X-Amz-Signature")
  valid_595867 = validateParameter(valid_595867, JString, required = false,
                                 default = nil)
  if valid_595867 != nil:
    section.add "X-Amz-Signature", valid_595867
  var valid_595868 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595868 = validateParameter(valid_595868, JString, required = false,
                                 default = nil)
  if valid_595868 != nil:
    section.add "X-Amz-SignedHeaders", valid_595868
  var valid_595869 = header.getOrDefault("X-Amz-Credential")
  valid_595869 = validateParameter(valid_595869, JString, required = false,
                                 default = nil)
  if valid_595869 != nil:
    section.add "X-Amz-Credential", valid_595869
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595870: Call_ListAuditMitigationActionsExecutions_595855;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the status of audit mitigation action tasks that were executed.
  ## 
  let valid = call_595870.validator(path, query, header, formData, body)
  let scheme = call_595870.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595870.url(scheme.get, call_595870.host, call_595870.base,
                         call_595870.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595870, url, valid)

proc call*(call_595871: Call_ListAuditMitigationActionsExecutions_595855;
          findingId: string; taskId: string; maxResults: int = 0;
          nextToken: string = ""; actionStatus: string = "IN_PROGRESS"): Recallable =
  ## listAuditMitigationActionsExecutions
  ## Gets the status of audit mitigation action tasks that were executed.
  ##   findingId: string (required)
  ##            : Specify this filter to limit results to those that were applied to a specific audit finding.
  ##   taskId: string (required)
  ##         : Specify this filter to limit results to actions for a specific audit mitigation actions task.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   actionStatus: string
  ##               : Specify this filter to limit results to those with a specific status.
  var query_595872 = newJObject()
  add(query_595872, "findingId", newJString(findingId))
  add(query_595872, "taskId", newJString(taskId))
  add(query_595872, "maxResults", newJInt(maxResults))
  add(query_595872, "nextToken", newJString(nextToken))
  add(query_595872, "actionStatus", newJString(actionStatus))
  result = call_595871.call(nil, query_595872, nil, nil, nil)

var listAuditMitigationActionsExecutions* = Call_ListAuditMitigationActionsExecutions_595855(
    name: "listAuditMitigationActionsExecutions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/executions#taskId&findingId",
    validator: validate_ListAuditMitigationActionsExecutions_595856, base: "/",
    url: url_ListAuditMitigationActionsExecutions_595857,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditMitigationActionsTasks_595873 = ref object of OpenApiRestCall_593437
proc url_ListAuditMitigationActionsTasks_595875(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListAuditMitigationActionsTasks_595874(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   findingId: JString
  ##            : Specify this filter to limit results to tasks that were applied to a specific audit finding.
  ##   taskStatus: JString
  ##             : Specify this filter to limit results to tasks that are in a specific state.
  ##   auditTaskId: JString
  ##              : Specify this filter to limit results to tasks that were applied to results for a specific audit.
  ##   endTime: JString (required)
  ##          : Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : Specify this filter to limit results to tasks that began on or after a specific date and time.
  section = newJObject()
  var valid_595876 = query.getOrDefault("findingId")
  valid_595876 = validateParameter(valid_595876, JString, required = false,
                                 default = nil)
  if valid_595876 != nil:
    section.add "findingId", valid_595876
  var valid_595877 = query.getOrDefault("taskStatus")
  valid_595877 = validateParameter(valid_595877, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_595877 != nil:
    section.add "taskStatus", valid_595877
  var valid_595878 = query.getOrDefault("auditTaskId")
  valid_595878 = validateParameter(valid_595878, JString, required = false,
                                 default = nil)
  if valid_595878 != nil:
    section.add "auditTaskId", valid_595878
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_595879 = query.getOrDefault("endTime")
  valid_595879 = validateParameter(valid_595879, JString, required = true,
                                 default = nil)
  if valid_595879 != nil:
    section.add "endTime", valid_595879
  var valid_595880 = query.getOrDefault("maxResults")
  valid_595880 = validateParameter(valid_595880, JInt, required = false, default = nil)
  if valid_595880 != nil:
    section.add "maxResults", valid_595880
  var valid_595881 = query.getOrDefault("nextToken")
  valid_595881 = validateParameter(valid_595881, JString, required = false,
                                 default = nil)
  if valid_595881 != nil:
    section.add "nextToken", valid_595881
  var valid_595882 = query.getOrDefault("startTime")
  valid_595882 = validateParameter(valid_595882, JString, required = true,
                                 default = nil)
  if valid_595882 != nil:
    section.add "startTime", valid_595882
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595883 = header.getOrDefault("X-Amz-Date")
  valid_595883 = validateParameter(valid_595883, JString, required = false,
                                 default = nil)
  if valid_595883 != nil:
    section.add "X-Amz-Date", valid_595883
  var valid_595884 = header.getOrDefault("X-Amz-Security-Token")
  valid_595884 = validateParameter(valid_595884, JString, required = false,
                                 default = nil)
  if valid_595884 != nil:
    section.add "X-Amz-Security-Token", valid_595884
  var valid_595885 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595885 = validateParameter(valid_595885, JString, required = false,
                                 default = nil)
  if valid_595885 != nil:
    section.add "X-Amz-Content-Sha256", valid_595885
  var valid_595886 = header.getOrDefault("X-Amz-Algorithm")
  valid_595886 = validateParameter(valid_595886, JString, required = false,
                                 default = nil)
  if valid_595886 != nil:
    section.add "X-Amz-Algorithm", valid_595886
  var valid_595887 = header.getOrDefault("X-Amz-Signature")
  valid_595887 = validateParameter(valid_595887, JString, required = false,
                                 default = nil)
  if valid_595887 != nil:
    section.add "X-Amz-Signature", valid_595887
  var valid_595888 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595888 = validateParameter(valid_595888, JString, required = false,
                                 default = nil)
  if valid_595888 != nil:
    section.add "X-Amz-SignedHeaders", valid_595888
  var valid_595889 = header.getOrDefault("X-Amz-Credential")
  valid_595889 = validateParameter(valid_595889, JString, required = false,
                                 default = nil)
  if valid_595889 != nil:
    section.add "X-Amz-Credential", valid_595889
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595890: Call_ListAuditMitigationActionsTasks_595873;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ## 
  let valid = call_595890.validator(path, query, header, formData, body)
  let scheme = call_595890.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595890.url(scheme.get, call_595890.host, call_595890.base,
                         call_595890.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595890, url, valid)

proc call*(call_595891: Call_ListAuditMitigationActionsTasks_595873;
          endTime: string; startTime: string; findingId: string = "";
          taskStatus: string = "IN_PROGRESS"; auditTaskId: string = "";
          maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listAuditMitigationActionsTasks
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ##   findingId: string
  ##            : Specify this filter to limit results to tasks that were applied to a specific audit finding.
  ##   taskStatus: string
  ##             : Specify this filter to limit results to tasks that are in a specific state.
  ##   auditTaskId: string
  ##              : Specify this filter to limit results to tasks that were applied to results for a specific audit.
  ##   endTime: string (required)
  ##          : Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : Specify this filter to limit results to tasks that began on or after a specific date and time.
  var query_595892 = newJObject()
  add(query_595892, "findingId", newJString(findingId))
  add(query_595892, "taskStatus", newJString(taskStatus))
  add(query_595892, "auditTaskId", newJString(auditTaskId))
  add(query_595892, "endTime", newJString(endTime))
  add(query_595892, "maxResults", newJInt(maxResults))
  add(query_595892, "nextToken", newJString(nextToken))
  add(query_595892, "startTime", newJString(startTime))
  result = call_595891.call(nil, query_595892, nil, nil, nil)

var listAuditMitigationActionsTasks* = Call_ListAuditMitigationActionsTasks_595873(
    name: "listAuditMitigationActionsTasks", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/tasks#startTime&endTime",
    validator: validate_ListAuditMitigationActionsTasks_595874, base: "/",
    url: url_ListAuditMitigationActionsTasks_595875,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditTasks_595893 = ref object of OpenApiRestCall_593437
proc url_ListAuditTasks_595895(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListAuditTasks_595894(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the Device Defender audits that have been performed during a given time period.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   taskType: JString
  ##           : A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
  ##   taskStatus: JString
  ##             : A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
  ##   endTime: JString (required)
  ##          : The end of the time period.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
  section = newJObject()
  var valid_595896 = query.getOrDefault("taskType")
  valid_595896 = validateParameter(valid_595896, JString, required = false,
                                 default = newJString("ON_DEMAND_AUDIT_TASK"))
  if valid_595896 != nil:
    section.add "taskType", valid_595896
  var valid_595897 = query.getOrDefault("taskStatus")
  valid_595897 = validateParameter(valid_595897, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_595897 != nil:
    section.add "taskStatus", valid_595897
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_595898 = query.getOrDefault("endTime")
  valid_595898 = validateParameter(valid_595898, JString, required = true,
                                 default = nil)
  if valid_595898 != nil:
    section.add "endTime", valid_595898
  var valid_595899 = query.getOrDefault("maxResults")
  valid_595899 = validateParameter(valid_595899, JInt, required = false, default = nil)
  if valid_595899 != nil:
    section.add "maxResults", valid_595899
  var valid_595900 = query.getOrDefault("nextToken")
  valid_595900 = validateParameter(valid_595900, JString, required = false,
                                 default = nil)
  if valid_595900 != nil:
    section.add "nextToken", valid_595900
  var valid_595901 = query.getOrDefault("startTime")
  valid_595901 = validateParameter(valid_595901, JString, required = true,
                                 default = nil)
  if valid_595901 != nil:
    section.add "startTime", valid_595901
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595902 = header.getOrDefault("X-Amz-Date")
  valid_595902 = validateParameter(valid_595902, JString, required = false,
                                 default = nil)
  if valid_595902 != nil:
    section.add "X-Amz-Date", valid_595902
  var valid_595903 = header.getOrDefault("X-Amz-Security-Token")
  valid_595903 = validateParameter(valid_595903, JString, required = false,
                                 default = nil)
  if valid_595903 != nil:
    section.add "X-Amz-Security-Token", valid_595903
  var valid_595904 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595904 = validateParameter(valid_595904, JString, required = false,
                                 default = nil)
  if valid_595904 != nil:
    section.add "X-Amz-Content-Sha256", valid_595904
  var valid_595905 = header.getOrDefault("X-Amz-Algorithm")
  valid_595905 = validateParameter(valid_595905, JString, required = false,
                                 default = nil)
  if valid_595905 != nil:
    section.add "X-Amz-Algorithm", valid_595905
  var valid_595906 = header.getOrDefault("X-Amz-Signature")
  valid_595906 = validateParameter(valid_595906, JString, required = false,
                                 default = nil)
  if valid_595906 != nil:
    section.add "X-Amz-Signature", valid_595906
  var valid_595907 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595907 = validateParameter(valid_595907, JString, required = false,
                                 default = nil)
  if valid_595907 != nil:
    section.add "X-Amz-SignedHeaders", valid_595907
  var valid_595908 = header.getOrDefault("X-Amz-Credential")
  valid_595908 = validateParameter(valid_595908, JString, required = false,
                                 default = nil)
  if valid_595908 != nil:
    section.add "X-Amz-Credential", valid_595908
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595909: Call_ListAuditTasks_595893; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender audits that have been performed during a given time period.
  ## 
  let valid = call_595909.validator(path, query, header, formData, body)
  let scheme = call_595909.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595909.url(scheme.get, call_595909.host, call_595909.base,
                         call_595909.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595909, url, valid)

proc call*(call_595910: Call_ListAuditTasks_595893; endTime: string;
          startTime: string; taskType: string = "ON_DEMAND_AUDIT_TASK";
          taskStatus: string = "IN_PROGRESS"; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listAuditTasks
  ## Lists the Device Defender audits that have been performed during a given time period.
  ##   taskType: string
  ##           : A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
  ##   taskStatus: string
  ##             : A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
  ##   endTime: string (required)
  ##          : The end of the time period.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
  var query_595911 = newJObject()
  add(query_595911, "taskType", newJString(taskType))
  add(query_595911, "taskStatus", newJString(taskStatus))
  add(query_595911, "endTime", newJString(endTime))
  add(query_595911, "maxResults", newJInt(maxResults))
  add(query_595911, "nextToken", newJString(nextToken))
  add(query_595911, "startTime", newJString(startTime))
  result = call_595910.call(nil, query_595911, nil, nil, nil)

var listAuditTasks* = Call_ListAuditTasks_595893(name: "listAuditTasks",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/audit/tasks#startTime&endTime", validator: validate_ListAuditTasks_595894,
    base: "/", url: url_ListAuditTasks_595895, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuthorizers_595912 = ref object of OpenApiRestCall_593437
proc url_ListAuthorizers_595914(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListAuthorizers_595913(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Lists the authorizers registered in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   status: JString
  ##         : The status of the list authorizers request.
  ##   isAscendingOrder: JBool
  ##                   : Return the list of authorizers in ascending alphabetical order.
  section = newJObject()
  var valid_595915 = query.getOrDefault("marker")
  valid_595915 = validateParameter(valid_595915, JString, required = false,
                                 default = nil)
  if valid_595915 != nil:
    section.add "marker", valid_595915
  var valid_595916 = query.getOrDefault("pageSize")
  valid_595916 = validateParameter(valid_595916, JInt, required = false, default = nil)
  if valid_595916 != nil:
    section.add "pageSize", valid_595916
  var valid_595917 = query.getOrDefault("status")
  valid_595917 = validateParameter(valid_595917, JString, required = false,
                                 default = newJString("ACTIVE"))
  if valid_595917 != nil:
    section.add "status", valid_595917
  var valid_595918 = query.getOrDefault("isAscendingOrder")
  valid_595918 = validateParameter(valid_595918, JBool, required = false, default = nil)
  if valid_595918 != nil:
    section.add "isAscendingOrder", valid_595918
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595919 = header.getOrDefault("X-Amz-Date")
  valid_595919 = validateParameter(valid_595919, JString, required = false,
                                 default = nil)
  if valid_595919 != nil:
    section.add "X-Amz-Date", valid_595919
  var valid_595920 = header.getOrDefault("X-Amz-Security-Token")
  valid_595920 = validateParameter(valid_595920, JString, required = false,
                                 default = nil)
  if valid_595920 != nil:
    section.add "X-Amz-Security-Token", valid_595920
  var valid_595921 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595921 = validateParameter(valid_595921, JString, required = false,
                                 default = nil)
  if valid_595921 != nil:
    section.add "X-Amz-Content-Sha256", valid_595921
  var valid_595922 = header.getOrDefault("X-Amz-Algorithm")
  valid_595922 = validateParameter(valid_595922, JString, required = false,
                                 default = nil)
  if valid_595922 != nil:
    section.add "X-Amz-Algorithm", valid_595922
  var valid_595923 = header.getOrDefault("X-Amz-Signature")
  valid_595923 = validateParameter(valid_595923, JString, required = false,
                                 default = nil)
  if valid_595923 != nil:
    section.add "X-Amz-Signature", valid_595923
  var valid_595924 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595924 = validateParameter(valid_595924, JString, required = false,
                                 default = nil)
  if valid_595924 != nil:
    section.add "X-Amz-SignedHeaders", valid_595924
  var valid_595925 = header.getOrDefault("X-Amz-Credential")
  valid_595925 = validateParameter(valid_595925, JString, required = false,
                                 default = nil)
  if valid_595925 != nil:
    section.add "X-Amz-Credential", valid_595925
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595926: Call_ListAuthorizers_595912; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the authorizers registered in your account.
  ## 
  let valid = call_595926.validator(path, query, header, formData, body)
  let scheme = call_595926.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595926.url(scheme.get, call_595926.host, call_595926.base,
                         call_595926.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595926, url, valid)

proc call*(call_595927: Call_ListAuthorizers_595912; marker: string = "";
          pageSize: int = 0; status: string = "ACTIVE"; isAscendingOrder: bool = false): Recallable =
  ## listAuthorizers
  ## Lists the authorizers registered in your account.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   status: string
  ##         : The status of the list authorizers request.
  ##   isAscendingOrder: bool
  ##                   : Return the list of authorizers in ascending alphabetical order.
  var query_595928 = newJObject()
  add(query_595928, "marker", newJString(marker))
  add(query_595928, "pageSize", newJInt(pageSize))
  add(query_595928, "status", newJString(status))
  add(query_595928, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_595927.call(nil, query_595928, nil, nil, nil)

var listAuthorizers* = Call_ListAuthorizers_595912(name: "listAuthorizers",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/authorizers/",
    validator: validate_ListAuthorizers_595913, base: "/", url: url_ListAuthorizers_595914,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListBillingGroups_595929 = ref object of OpenApiRestCall_593437
proc url_ListBillingGroups_595931(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListBillingGroups_595930(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Lists the billing groups you have created.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   namePrefixFilter: JString
  ##                   : Limit the results to billing groups whose names have the given prefix.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  var valid_595932 = query.getOrDefault("namePrefixFilter")
  valid_595932 = validateParameter(valid_595932, JString, required = false,
                                 default = nil)
  if valid_595932 != nil:
    section.add "namePrefixFilter", valid_595932
  var valid_595933 = query.getOrDefault("maxResults")
  valid_595933 = validateParameter(valid_595933, JInt, required = false, default = nil)
  if valid_595933 != nil:
    section.add "maxResults", valid_595933
  var valid_595934 = query.getOrDefault("nextToken")
  valid_595934 = validateParameter(valid_595934, JString, required = false,
                                 default = nil)
  if valid_595934 != nil:
    section.add "nextToken", valid_595934
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595935 = header.getOrDefault("X-Amz-Date")
  valid_595935 = validateParameter(valid_595935, JString, required = false,
                                 default = nil)
  if valid_595935 != nil:
    section.add "X-Amz-Date", valid_595935
  var valid_595936 = header.getOrDefault("X-Amz-Security-Token")
  valid_595936 = validateParameter(valid_595936, JString, required = false,
                                 default = nil)
  if valid_595936 != nil:
    section.add "X-Amz-Security-Token", valid_595936
  var valid_595937 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595937 = validateParameter(valid_595937, JString, required = false,
                                 default = nil)
  if valid_595937 != nil:
    section.add "X-Amz-Content-Sha256", valid_595937
  var valid_595938 = header.getOrDefault("X-Amz-Algorithm")
  valid_595938 = validateParameter(valid_595938, JString, required = false,
                                 default = nil)
  if valid_595938 != nil:
    section.add "X-Amz-Algorithm", valid_595938
  var valid_595939 = header.getOrDefault("X-Amz-Signature")
  valid_595939 = validateParameter(valid_595939, JString, required = false,
                                 default = nil)
  if valid_595939 != nil:
    section.add "X-Amz-Signature", valid_595939
  var valid_595940 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595940 = validateParameter(valid_595940, JString, required = false,
                                 default = nil)
  if valid_595940 != nil:
    section.add "X-Amz-SignedHeaders", valid_595940
  var valid_595941 = header.getOrDefault("X-Amz-Credential")
  valid_595941 = validateParameter(valid_595941, JString, required = false,
                                 default = nil)
  if valid_595941 != nil:
    section.add "X-Amz-Credential", valid_595941
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595942: Call_ListBillingGroups_595929; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the billing groups you have created.
  ## 
  let valid = call_595942.validator(path, query, header, formData, body)
  let scheme = call_595942.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595942.url(scheme.get, call_595942.host, call_595942.base,
                         call_595942.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595942, url, valid)

proc call*(call_595943: Call_ListBillingGroups_595929;
          namePrefixFilter: string = ""; maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listBillingGroups
  ## Lists the billing groups you have created.
  ##   namePrefixFilter: string
  ##                   : Limit the results to billing groups whose names have the given prefix.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var query_595944 = newJObject()
  add(query_595944, "namePrefixFilter", newJString(namePrefixFilter))
  add(query_595944, "maxResults", newJInt(maxResults))
  add(query_595944, "nextToken", newJString(nextToken))
  result = call_595943.call(nil, query_595944, nil, nil, nil)

var listBillingGroups* = Call_ListBillingGroups_595929(name: "listBillingGroups",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/billing-groups",
    validator: validate_ListBillingGroups_595930, base: "/",
    url: url_ListBillingGroups_595931, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCACertificates_595945 = ref object of OpenApiRestCall_593437
proc url_ListCACertificates_595947(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListCACertificates_595946(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Determines the order of the results.
  section = newJObject()
  var valid_595948 = query.getOrDefault("marker")
  valid_595948 = validateParameter(valid_595948, JString, required = false,
                                 default = nil)
  if valid_595948 != nil:
    section.add "marker", valid_595948
  var valid_595949 = query.getOrDefault("pageSize")
  valid_595949 = validateParameter(valid_595949, JInt, required = false, default = nil)
  if valid_595949 != nil:
    section.add "pageSize", valid_595949
  var valid_595950 = query.getOrDefault("isAscendingOrder")
  valid_595950 = validateParameter(valid_595950, JBool, required = false, default = nil)
  if valid_595950 != nil:
    section.add "isAscendingOrder", valid_595950
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595951 = header.getOrDefault("X-Amz-Date")
  valid_595951 = validateParameter(valid_595951, JString, required = false,
                                 default = nil)
  if valid_595951 != nil:
    section.add "X-Amz-Date", valid_595951
  var valid_595952 = header.getOrDefault("X-Amz-Security-Token")
  valid_595952 = validateParameter(valid_595952, JString, required = false,
                                 default = nil)
  if valid_595952 != nil:
    section.add "X-Amz-Security-Token", valid_595952
  var valid_595953 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595953 = validateParameter(valid_595953, JString, required = false,
                                 default = nil)
  if valid_595953 != nil:
    section.add "X-Amz-Content-Sha256", valid_595953
  var valid_595954 = header.getOrDefault("X-Amz-Algorithm")
  valid_595954 = validateParameter(valid_595954, JString, required = false,
                                 default = nil)
  if valid_595954 != nil:
    section.add "X-Amz-Algorithm", valid_595954
  var valid_595955 = header.getOrDefault("X-Amz-Signature")
  valid_595955 = validateParameter(valid_595955, JString, required = false,
                                 default = nil)
  if valid_595955 != nil:
    section.add "X-Amz-Signature", valid_595955
  var valid_595956 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595956 = validateParameter(valid_595956, JString, required = false,
                                 default = nil)
  if valid_595956 != nil:
    section.add "X-Amz-SignedHeaders", valid_595956
  var valid_595957 = header.getOrDefault("X-Amz-Credential")
  valid_595957 = validateParameter(valid_595957, JString, required = false,
                                 default = nil)
  if valid_595957 != nil:
    section.add "X-Amz-Credential", valid_595957
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595958: Call_ListCACertificates_595945; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  let valid = call_595958.validator(path, query, header, formData, body)
  let scheme = call_595958.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595958.url(scheme.get, call_595958.host, call_595958.base,
                         call_595958.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595958, url, valid)

proc call*(call_595959: Call_ListCACertificates_595945; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listCACertificates
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Determines the order of the results.
  var query_595960 = newJObject()
  add(query_595960, "marker", newJString(marker))
  add(query_595960, "pageSize", newJInt(pageSize))
  add(query_595960, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_595959.call(nil, query_595960, nil, nil, nil)

var listCACertificates* = Call_ListCACertificates_595945(
    name: "listCACertificates", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/cacertificates", validator: validate_ListCACertificates_595946,
    base: "/", url: url_ListCACertificates_595947,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCertificatesByCA_595961 = ref object of OpenApiRestCall_593437
proc url_ListCertificatesByCA_595963(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates-by-ca/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListCertificatesByCA_595962(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List the device certificates signed by the specified CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_595964 = path.getOrDefault("caCertificateId")
  valid_595964 = validateParameter(valid_595964, JString, required = true,
                                 default = nil)
  if valid_595964 != nil:
    section.add "caCertificateId", valid_595964
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  section = newJObject()
  var valid_595965 = query.getOrDefault("marker")
  valid_595965 = validateParameter(valid_595965, JString, required = false,
                                 default = nil)
  if valid_595965 != nil:
    section.add "marker", valid_595965
  var valid_595966 = query.getOrDefault("pageSize")
  valid_595966 = validateParameter(valid_595966, JInt, required = false, default = nil)
  if valid_595966 != nil:
    section.add "pageSize", valid_595966
  var valid_595967 = query.getOrDefault("isAscendingOrder")
  valid_595967 = validateParameter(valid_595967, JBool, required = false, default = nil)
  if valid_595967 != nil:
    section.add "isAscendingOrder", valid_595967
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595968 = header.getOrDefault("X-Amz-Date")
  valid_595968 = validateParameter(valid_595968, JString, required = false,
                                 default = nil)
  if valid_595968 != nil:
    section.add "X-Amz-Date", valid_595968
  var valid_595969 = header.getOrDefault("X-Amz-Security-Token")
  valid_595969 = validateParameter(valid_595969, JString, required = false,
                                 default = nil)
  if valid_595969 != nil:
    section.add "X-Amz-Security-Token", valid_595969
  var valid_595970 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595970 = validateParameter(valid_595970, JString, required = false,
                                 default = nil)
  if valid_595970 != nil:
    section.add "X-Amz-Content-Sha256", valid_595970
  var valid_595971 = header.getOrDefault("X-Amz-Algorithm")
  valid_595971 = validateParameter(valid_595971, JString, required = false,
                                 default = nil)
  if valid_595971 != nil:
    section.add "X-Amz-Algorithm", valid_595971
  var valid_595972 = header.getOrDefault("X-Amz-Signature")
  valid_595972 = validateParameter(valid_595972, JString, required = false,
                                 default = nil)
  if valid_595972 != nil:
    section.add "X-Amz-Signature", valid_595972
  var valid_595973 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595973 = validateParameter(valid_595973, JString, required = false,
                                 default = nil)
  if valid_595973 != nil:
    section.add "X-Amz-SignedHeaders", valid_595973
  var valid_595974 = header.getOrDefault("X-Amz-Credential")
  valid_595974 = validateParameter(valid_595974, JString, required = false,
                                 default = nil)
  if valid_595974 != nil:
    section.add "X-Amz-Credential", valid_595974
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595975: Call_ListCertificatesByCA_595961; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the device certificates signed by the specified CA certificate.
  ## 
  let valid = call_595975.validator(path, query, header, formData, body)
  let scheme = call_595975.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595975.url(scheme.get, call_595975.host, call_595975.base,
                         call_595975.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595975, url, valid)

proc call*(call_595976: Call_ListCertificatesByCA_595961; caCertificateId: string;
          marker: string = ""; pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listCertificatesByCA
  ## List the device certificates signed by the specified CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  var path_595977 = newJObject()
  var query_595978 = newJObject()
  add(path_595977, "caCertificateId", newJString(caCertificateId))
  add(query_595978, "marker", newJString(marker))
  add(query_595978, "pageSize", newJInt(pageSize))
  add(query_595978, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_595976.call(path_595977, query_595978, nil, nil, nil)

var listCertificatesByCA* = Call_ListCertificatesByCA_595961(
    name: "listCertificatesByCA", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates-by-ca/{caCertificateId}",
    validator: validate_ListCertificatesByCA_595962, base: "/",
    url: url_ListCertificatesByCA_595963, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListIndices_595979 = ref object of OpenApiRestCall_593437
proc url_ListIndices_595981(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListIndices_595980(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the search indices.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token used to get the next set of results, or null if there are no additional results.
  section = newJObject()
  var valid_595982 = query.getOrDefault("maxResults")
  valid_595982 = validateParameter(valid_595982, JInt, required = false, default = nil)
  if valid_595982 != nil:
    section.add "maxResults", valid_595982
  var valid_595983 = query.getOrDefault("nextToken")
  valid_595983 = validateParameter(valid_595983, JString, required = false,
                                 default = nil)
  if valid_595983 != nil:
    section.add "nextToken", valid_595983
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595984 = header.getOrDefault("X-Amz-Date")
  valid_595984 = validateParameter(valid_595984, JString, required = false,
                                 default = nil)
  if valid_595984 != nil:
    section.add "X-Amz-Date", valid_595984
  var valid_595985 = header.getOrDefault("X-Amz-Security-Token")
  valid_595985 = validateParameter(valid_595985, JString, required = false,
                                 default = nil)
  if valid_595985 != nil:
    section.add "X-Amz-Security-Token", valid_595985
  var valid_595986 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595986 = validateParameter(valid_595986, JString, required = false,
                                 default = nil)
  if valid_595986 != nil:
    section.add "X-Amz-Content-Sha256", valid_595986
  var valid_595987 = header.getOrDefault("X-Amz-Algorithm")
  valid_595987 = validateParameter(valid_595987, JString, required = false,
                                 default = nil)
  if valid_595987 != nil:
    section.add "X-Amz-Algorithm", valid_595987
  var valid_595988 = header.getOrDefault("X-Amz-Signature")
  valid_595988 = validateParameter(valid_595988, JString, required = false,
                                 default = nil)
  if valid_595988 != nil:
    section.add "X-Amz-Signature", valid_595988
  var valid_595989 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595989 = validateParameter(valid_595989, JString, required = false,
                                 default = nil)
  if valid_595989 != nil:
    section.add "X-Amz-SignedHeaders", valid_595989
  var valid_595990 = header.getOrDefault("X-Amz-Credential")
  valid_595990 = validateParameter(valid_595990, JString, required = false,
                                 default = nil)
  if valid_595990 != nil:
    section.add "X-Amz-Credential", valid_595990
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595991: Call_ListIndices_595979; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the search indices.
  ## 
  let valid = call_595991.validator(path, query, header, formData, body)
  let scheme = call_595991.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595991.url(scheme.get, call_595991.host, call_595991.base,
                         call_595991.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595991, url, valid)

proc call*(call_595992: Call_ListIndices_595979; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listIndices
  ## Lists the search indices.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token used to get the next set of results, or null if there are no additional results.
  var query_595993 = newJObject()
  add(query_595993, "maxResults", newJInt(maxResults))
  add(query_595993, "nextToken", newJString(nextToken))
  result = call_595992.call(nil, query_595993, nil, nil, nil)

var listIndices* = Call_ListIndices_595979(name: "listIndices",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/indices",
                                        validator: validate_ListIndices_595980,
                                        base: "/", url: url_ListIndices_595981,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobExecutionsForJob_595994 = ref object of OpenApiRestCall_593437
proc url_ListJobExecutionsForJob_595996(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListJobExecutionsForJob_595995(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the job executions for a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_595997 = path.getOrDefault("jobId")
  valid_595997 = validateParameter(valid_595997, JString, required = true,
                                 default = nil)
  if valid_595997 != nil:
    section.add "jobId", valid_595997
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to be returned per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : The status of the job.
  section = newJObject()
  var valid_595998 = query.getOrDefault("maxResults")
  valid_595998 = validateParameter(valid_595998, JInt, required = false, default = nil)
  if valid_595998 != nil:
    section.add "maxResults", valid_595998
  var valid_595999 = query.getOrDefault("nextToken")
  valid_595999 = validateParameter(valid_595999, JString, required = false,
                                 default = nil)
  if valid_595999 != nil:
    section.add "nextToken", valid_595999
  var valid_596000 = query.getOrDefault("status")
  valid_596000 = validateParameter(valid_596000, JString, required = false,
                                 default = newJString("QUEUED"))
  if valid_596000 != nil:
    section.add "status", valid_596000
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596001 = header.getOrDefault("X-Amz-Date")
  valid_596001 = validateParameter(valid_596001, JString, required = false,
                                 default = nil)
  if valid_596001 != nil:
    section.add "X-Amz-Date", valid_596001
  var valid_596002 = header.getOrDefault("X-Amz-Security-Token")
  valid_596002 = validateParameter(valid_596002, JString, required = false,
                                 default = nil)
  if valid_596002 != nil:
    section.add "X-Amz-Security-Token", valid_596002
  var valid_596003 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596003 = validateParameter(valid_596003, JString, required = false,
                                 default = nil)
  if valid_596003 != nil:
    section.add "X-Amz-Content-Sha256", valid_596003
  var valid_596004 = header.getOrDefault("X-Amz-Algorithm")
  valid_596004 = validateParameter(valid_596004, JString, required = false,
                                 default = nil)
  if valid_596004 != nil:
    section.add "X-Amz-Algorithm", valid_596004
  var valid_596005 = header.getOrDefault("X-Amz-Signature")
  valid_596005 = validateParameter(valid_596005, JString, required = false,
                                 default = nil)
  if valid_596005 != nil:
    section.add "X-Amz-Signature", valid_596005
  var valid_596006 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596006 = validateParameter(valid_596006, JString, required = false,
                                 default = nil)
  if valid_596006 != nil:
    section.add "X-Amz-SignedHeaders", valid_596006
  var valid_596007 = header.getOrDefault("X-Amz-Credential")
  valid_596007 = validateParameter(valid_596007, JString, required = false,
                                 default = nil)
  if valid_596007 != nil:
    section.add "X-Amz-Credential", valid_596007
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596008: Call_ListJobExecutionsForJob_595994; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the job executions for a job.
  ## 
  let valid = call_596008.validator(path, query, header, formData, body)
  let scheme = call_596008.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596008.url(scheme.get, call_596008.host, call_596008.base,
                         call_596008.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596008, url, valid)

proc call*(call_596009: Call_ListJobExecutionsForJob_595994; jobId: string;
          maxResults: int = 0; nextToken: string = ""; status: string = "QUEUED"): Recallable =
  ## listJobExecutionsForJob
  ## Lists the job executions for a job.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   maxResults: int
  ##             : The maximum number of results to be returned per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : The status of the job.
  var path_596010 = newJObject()
  var query_596011 = newJObject()
  add(path_596010, "jobId", newJString(jobId))
  add(query_596011, "maxResults", newJInt(maxResults))
  add(query_596011, "nextToken", newJString(nextToken))
  add(query_596011, "status", newJString(status))
  result = call_596009.call(path_596010, query_596011, nil, nil, nil)

var listJobExecutionsForJob* = Call_ListJobExecutionsForJob_595994(
    name: "listJobExecutionsForJob", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/jobs/{jobId}/things",
    validator: validate_ListJobExecutionsForJob_595995, base: "/",
    url: url_ListJobExecutionsForJob_595996, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobExecutionsForThing_596012 = ref object of OpenApiRestCall_593437
proc url_ListJobExecutionsForThing_596014(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListJobExecutionsForThing_596013(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the job executions for the specified thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The thing name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_596015 = path.getOrDefault("thingName")
  valid_596015 = validateParameter(valid_596015, JString, required = true,
                                 default = nil)
  if valid_596015 != nil:
    section.add "thingName", valid_596015
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to be returned per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : An optional filter that lets you search for jobs that have the specified status.
  section = newJObject()
  var valid_596016 = query.getOrDefault("maxResults")
  valid_596016 = validateParameter(valid_596016, JInt, required = false, default = nil)
  if valid_596016 != nil:
    section.add "maxResults", valid_596016
  var valid_596017 = query.getOrDefault("nextToken")
  valid_596017 = validateParameter(valid_596017, JString, required = false,
                                 default = nil)
  if valid_596017 != nil:
    section.add "nextToken", valid_596017
  var valid_596018 = query.getOrDefault("status")
  valid_596018 = validateParameter(valid_596018, JString, required = false,
                                 default = newJString("QUEUED"))
  if valid_596018 != nil:
    section.add "status", valid_596018
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596019 = header.getOrDefault("X-Amz-Date")
  valid_596019 = validateParameter(valid_596019, JString, required = false,
                                 default = nil)
  if valid_596019 != nil:
    section.add "X-Amz-Date", valid_596019
  var valid_596020 = header.getOrDefault("X-Amz-Security-Token")
  valid_596020 = validateParameter(valid_596020, JString, required = false,
                                 default = nil)
  if valid_596020 != nil:
    section.add "X-Amz-Security-Token", valid_596020
  var valid_596021 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596021 = validateParameter(valid_596021, JString, required = false,
                                 default = nil)
  if valid_596021 != nil:
    section.add "X-Amz-Content-Sha256", valid_596021
  var valid_596022 = header.getOrDefault("X-Amz-Algorithm")
  valid_596022 = validateParameter(valid_596022, JString, required = false,
                                 default = nil)
  if valid_596022 != nil:
    section.add "X-Amz-Algorithm", valid_596022
  var valid_596023 = header.getOrDefault("X-Amz-Signature")
  valid_596023 = validateParameter(valid_596023, JString, required = false,
                                 default = nil)
  if valid_596023 != nil:
    section.add "X-Amz-Signature", valid_596023
  var valid_596024 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596024 = validateParameter(valid_596024, JString, required = false,
                                 default = nil)
  if valid_596024 != nil:
    section.add "X-Amz-SignedHeaders", valid_596024
  var valid_596025 = header.getOrDefault("X-Amz-Credential")
  valid_596025 = validateParameter(valid_596025, JString, required = false,
                                 default = nil)
  if valid_596025 != nil:
    section.add "X-Amz-Credential", valid_596025
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596026: Call_ListJobExecutionsForThing_596012; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the job executions for the specified thing.
  ## 
  let valid = call_596026.validator(path, query, header, formData, body)
  let scheme = call_596026.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596026.url(scheme.get, call_596026.host, call_596026.base,
                         call_596026.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596026, url, valid)

proc call*(call_596027: Call_ListJobExecutionsForThing_596012; thingName: string;
          maxResults: int = 0; nextToken: string = ""; status: string = "QUEUED"): Recallable =
  ## listJobExecutionsForThing
  ## Lists the job executions for the specified thing.
  ##   thingName: string (required)
  ##            : The thing name.
  ##   maxResults: int
  ##             : The maximum number of results to be returned per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : An optional filter that lets you search for jobs that have the specified status.
  var path_596028 = newJObject()
  var query_596029 = newJObject()
  add(path_596028, "thingName", newJString(thingName))
  add(query_596029, "maxResults", newJInt(maxResults))
  add(query_596029, "nextToken", newJString(nextToken))
  add(query_596029, "status", newJString(status))
  result = call_596027.call(path_596028, query_596029, nil, nil, nil)

var listJobExecutionsForThing* = Call_ListJobExecutionsForThing_596012(
    name: "listJobExecutionsForThing", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs",
    validator: validate_ListJobExecutionsForThing_596013, base: "/",
    url: url_ListJobExecutionsForThing_596014,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobs_596030 = ref object of OpenApiRestCall_593437
proc url_ListJobs_596032(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListJobs_596031(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists jobs.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingGroupName: JString
  ##                 : A filter that limits the returned jobs to those for the specified group.
  ##   targetSelection: JString
  ##                  : Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. 
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   thingGroupId: JString
  ##               : A filter that limits the returned jobs to those for the specified group.
  section = newJObject()
  var valid_596033 = query.getOrDefault("thingGroupName")
  valid_596033 = validateParameter(valid_596033, JString, required = false,
                                 default = nil)
  if valid_596033 != nil:
    section.add "thingGroupName", valid_596033
  var valid_596034 = query.getOrDefault("targetSelection")
  valid_596034 = validateParameter(valid_596034, JString, required = false,
                                 default = newJString("CONTINUOUS"))
  if valid_596034 != nil:
    section.add "targetSelection", valid_596034
  var valid_596035 = query.getOrDefault("maxResults")
  valid_596035 = validateParameter(valid_596035, JInt, required = false, default = nil)
  if valid_596035 != nil:
    section.add "maxResults", valid_596035
  var valid_596036 = query.getOrDefault("nextToken")
  valid_596036 = validateParameter(valid_596036, JString, required = false,
                                 default = nil)
  if valid_596036 != nil:
    section.add "nextToken", valid_596036
  var valid_596037 = query.getOrDefault("status")
  valid_596037 = validateParameter(valid_596037, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_596037 != nil:
    section.add "status", valid_596037
  var valid_596038 = query.getOrDefault("thingGroupId")
  valid_596038 = validateParameter(valid_596038, JString, required = false,
                                 default = nil)
  if valid_596038 != nil:
    section.add "thingGroupId", valid_596038
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596039 = header.getOrDefault("X-Amz-Date")
  valid_596039 = validateParameter(valid_596039, JString, required = false,
                                 default = nil)
  if valid_596039 != nil:
    section.add "X-Amz-Date", valid_596039
  var valid_596040 = header.getOrDefault("X-Amz-Security-Token")
  valid_596040 = validateParameter(valid_596040, JString, required = false,
                                 default = nil)
  if valid_596040 != nil:
    section.add "X-Amz-Security-Token", valid_596040
  var valid_596041 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596041 = validateParameter(valid_596041, JString, required = false,
                                 default = nil)
  if valid_596041 != nil:
    section.add "X-Amz-Content-Sha256", valid_596041
  var valid_596042 = header.getOrDefault("X-Amz-Algorithm")
  valid_596042 = validateParameter(valid_596042, JString, required = false,
                                 default = nil)
  if valid_596042 != nil:
    section.add "X-Amz-Algorithm", valid_596042
  var valid_596043 = header.getOrDefault("X-Amz-Signature")
  valid_596043 = validateParameter(valid_596043, JString, required = false,
                                 default = nil)
  if valid_596043 != nil:
    section.add "X-Amz-Signature", valid_596043
  var valid_596044 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596044 = validateParameter(valid_596044, JString, required = false,
                                 default = nil)
  if valid_596044 != nil:
    section.add "X-Amz-SignedHeaders", valid_596044
  var valid_596045 = header.getOrDefault("X-Amz-Credential")
  valid_596045 = validateParameter(valid_596045, JString, required = false,
                                 default = nil)
  if valid_596045 != nil:
    section.add "X-Amz-Credential", valid_596045
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596046: Call_ListJobs_596030; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists jobs.
  ## 
  let valid = call_596046.validator(path, query, header, formData, body)
  let scheme = call_596046.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596046.url(scheme.get, call_596046.host, call_596046.base,
                         call_596046.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596046, url, valid)

proc call*(call_596047: Call_ListJobs_596030; thingGroupName: string = "";
          targetSelection: string = "CONTINUOUS"; maxResults: int = 0;
          nextToken: string = ""; status: string = "IN_PROGRESS";
          thingGroupId: string = ""): Recallable =
  ## listJobs
  ## Lists jobs.
  ##   thingGroupName: string
  ##                 : A filter that limits the returned jobs to those for the specified group.
  ##   targetSelection: string
  ##                  : Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. 
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   thingGroupId: string
  ##               : A filter that limits the returned jobs to those for the specified group.
  var query_596048 = newJObject()
  add(query_596048, "thingGroupName", newJString(thingGroupName))
  add(query_596048, "targetSelection", newJString(targetSelection))
  add(query_596048, "maxResults", newJInt(maxResults))
  add(query_596048, "nextToken", newJString(nextToken))
  add(query_596048, "status", newJString(status))
  add(query_596048, "thingGroupId", newJString(thingGroupId))
  result = call_596047.call(nil, query_596048, nil, nil, nil)

var listJobs* = Call_ListJobs_596030(name: "listJobs", meth: HttpMethod.HttpGet,
                                  host: "iot.amazonaws.com", route: "/jobs",
                                  validator: validate_ListJobs_596031, base: "/",
                                  url: url_ListJobs_596032,
                                  schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListMitigationActions_596049 = ref object of OpenApiRestCall_593437
proc url_ListMitigationActions_596051(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListMitigationActions_596050(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   actionType: JString
  ##             : Specify a value to limit the result to mitigation actions with a specific action type.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  section = newJObject()
  var valid_596052 = query.getOrDefault("actionType")
  valid_596052 = validateParameter(valid_596052, JString, required = false, default = newJString(
      "UPDATE_DEVICE_CERTIFICATE"))
  if valid_596052 != nil:
    section.add "actionType", valid_596052
  var valid_596053 = query.getOrDefault("maxResults")
  valid_596053 = validateParameter(valid_596053, JInt, required = false, default = nil)
  if valid_596053 != nil:
    section.add "maxResults", valid_596053
  var valid_596054 = query.getOrDefault("nextToken")
  valid_596054 = validateParameter(valid_596054, JString, required = false,
                                 default = nil)
  if valid_596054 != nil:
    section.add "nextToken", valid_596054
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596055 = header.getOrDefault("X-Amz-Date")
  valid_596055 = validateParameter(valid_596055, JString, required = false,
                                 default = nil)
  if valid_596055 != nil:
    section.add "X-Amz-Date", valid_596055
  var valid_596056 = header.getOrDefault("X-Amz-Security-Token")
  valid_596056 = validateParameter(valid_596056, JString, required = false,
                                 default = nil)
  if valid_596056 != nil:
    section.add "X-Amz-Security-Token", valid_596056
  var valid_596057 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596057 = validateParameter(valid_596057, JString, required = false,
                                 default = nil)
  if valid_596057 != nil:
    section.add "X-Amz-Content-Sha256", valid_596057
  var valid_596058 = header.getOrDefault("X-Amz-Algorithm")
  valid_596058 = validateParameter(valid_596058, JString, required = false,
                                 default = nil)
  if valid_596058 != nil:
    section.add "X-Amz-Algorithm", valid_596058
  var valid_596059 = header.getOrDefault("X-Amz-Signature")
  valid_596059 = validateParameter(valid_596059, JString, required = false,
                                 default = nil)
  if valid_596059 != nil:
    section.add "X-Amz-Signature", valid_596059
  var valid_596060 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596060 = validateParameter(valid_596060, JString, required = false,
                                 default = nil)
  if valid_596060 != nil:
    section.add "X-Amz-SignedHeaders", valid_596060
  var valid_596061 = header.getOrDefault("X-Amz-Credential")
  valid_596061 = validateParameter(valid_596061, JString, required = false,
                                 default = nil)
  if valid_596061 != nil:
    section.add "X-Amz-Credential", valid_596061
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596062: Call_ListMitigationActions_596049; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ## 
  let valid = call_596062.validator(path, query, header, formData, body)
  let scheme = call_596062.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596062.url(scheme.get, call_596062.host, call_596062.base,
                         call_596062.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596062, url, valid)

proc call*(call_596063: Call_ListMitigationActions_596049;
          actionType: string = "UPDATE_DEVICE_CERTIFICATE"; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listMitigationActions
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ##   actionType: string
  ##             : Specify a value to limit the result to mitigation actions with a specific action type.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: string
  ##            : The token for the next set of results.
  var query_596064 = newJObject()
  add(query_596064, "actionType", newJString(actionType))
  add(query_596064, "maxResults", newJInt(maxResults))
  add(query_596064, "nextToken", newJString(nextToken))
  result = call_596063.call(nil, query_596064, nil, nil, nil)

var listMitigationActions* = Call_ListMitigationActions_596049(
    name: "listMitigationActions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions",
    validator: validate_ListMitigationActions_596050, base: "/",
    url: url_ListMitigationActions_596051, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListOTAUpdates_596065 = ref object of OpenApiRestCall_593437
proc url_ListOTAUpdates_596067(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListOTAUpdates_596066(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists OTA updates.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   otaUpdateStatus: JString
  ##                  : The OTA update job status.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : A token used to retrieve the next set of results.
  section = newJObject()
  var valid_596068 = query.getOrDefault("otaUpdateStatus")
  valid_596068 = validateParameter(valid_596068, JString, required = false,
                                 default = newJString("CREATE_PENDING"))
  if valid_596068 != nil:
    section.add "otaUpdateStatus", valid_596068
  var valid_596069 = query.getOrDefault("maxResults")
  valid_596069 = validateParameter(valid_596069, JInt, required = false, default = nil)
  if valid_596069 != nil:
    section.add "maxResults", valid_596069
  var valid_596070 = query.getOrDefault("nextToken")
  valid_596070 = validateParameter(valid_596070, JString, required = false,
                                 default = nil)
  if valid_596070 != nil:
    section.add "nextToken", valid_596070
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596071 = header.getOrDefault("X-Amz-Date")
  valid_596071 = validateParameter(valid_596071, JString, required = false,
                                 default = nil)
  if valid_596071 != nil:
    section.add "X-Amz-Date", valid_596071
  var valid_596072 = header.getOrDefault("X-Amz-Security-Token")
  valid_596072 = validateParameter(valid_596072, JString, required = false,
                                 default = nil)
  if valid_596072 != nil:
    section.add "X-Amz-Security-Token", valid_596072
  var valid_596073 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596073 = validateParameter(valid_596073, JString, required = false,
                                 default = nil)
  if valid_596073 != nil:
    section.add "X-Amz-Content-Sha256", valid_596073
  var valid_596074 = header.getOrDefault("X-Amz-Algorithm")
  valid_596074 = validateParameter(valid_596074, JString, required = false,
                                 default = nil)
  if valid_596074 != nil:
    section.add "X-Amz-Algorithm", valid_596074
  var valid_596075 = header.getOrDefault("X-Amz-Signature")
  valid_596075 = validateParameter(valid_596075, JString, required = false,
                                 default = nil)
  if valid_596075 != nil:
    section.add "X-Amz-Signature", valid_596075
  var valid_596076 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596076 = validateParameter(valid_596076, JString, required = false,
                                 default = nil)
  if valid_596076 != nil:
    section.add "X-Amz-SignedHeaders", valid_596076
  var valid_596077 = header.getOrDefault("X-Amz-Credential")
  valid_596077 = validateParameter(valid_596077, JString, required = false,
                                 default = nil)
  if valid_596077 != nil:
    section.add "X-Amz-Credential", valid_596077
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596078: Call_ListOTAUpdates_596065; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists OTA updates.
  ## 
  let valid = call_596078.validator(path, query, header, formData, body)
  let scheme = call_596078.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596078.url(scheme.get, call_596078.host, call_596078.base,
                         call_596078.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596078, url, valid)

proc call*(call_596079: Call_ListOTAUpdates_596065;
          otaUpdateStatus: string = "CREATE_PENDING"; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listOTAUpdates
  ## Lists OTA updates.
  ##   otaUpdateStatus: string
  ##                  : The OTA update job status.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : A token used to retrieve the next set of results.
  var query_596080 = newJObject()
  add(query_596080, "otaUpdateStatus", newJString(otaUpdateStatus))
  add(query_596080, "maxResults", newJInt(maxResults))
  add(query_596080, "nextToken", newJString(nextToken))
  result = call_596079.call(nil, query_596080, nil, nil, nil)

var listOTAUpdates* = Call_ListOTAUpdates_596065(name: "listOTAUpdates",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/otaUpdates",
    validator: validate_ListOTAUpdates_596066, base: "/", url: url_ListOTAUpdates_596067,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListOutgoingCertificates_596081 = ref object of OpenApiRestCall_593437
proc url_ListOutgoingCertificates_596083(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListOutgoingCertificates_596082(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists certificates that are being transferred but not yet accepted.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  section = newJObject()
  var valid_596084 = query.getOrDefault("marker")
  valid_596084 = validateParameter(valid_596084, JString, required = false,
                                 default = nil)
  if valid_596084 != nil:
    section.add "marker", valid_596084
  var valid_596085 = query.getOrDefault("pageSize")
  valid_596085 = validateParameter(valid_596085, JInt, required = false, default = nil)
  if valid_596085 != nil:
    section.add "pageSize", valid_596085
  var valid_596086 = query.getOrDefault("isAscendingOrder")
  valid_596086 = validateParameter(valid_596086, JBool, required = false, default = nil)
  if valid_596086 != nil:
    section.add "isAscendingOrder", valid_596086
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596087 = header.getOrDefault("X-Amz-Date")
  valid_596087 = validateParameter(valid_596087, JString, required = false,
                                 default = nil)
  if valid_596087 != nil:
    section.add "X-Amz-Date", valid_596087
  var valid_596088 = header.getOrDefault("X-Amz-Security-Token")
  valid_596088 = validateParameter(valid_596088, JString, required = false,
                                 default = nil)
  if valid_596088 != nil:
    section.add "X-Amz-Security-Token", valid_596088
  var valid_596089 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596089 = validateParameter(valid_596089, JString, required = false,
                                 default = nil)
  if valid_596089 != nil:
    section.add "X-Amz-Content-Sha256", valid_596089
  var valid_596090 = header.getOrDefault("X-Amz-Algorithm")
  valid_596090 = validateParameter(valid_596090, JString, required = false,
                                 default = nil)
  if valid_596090 != nil:
    section.add "X-Amz-Algorithm", valid_596090
  var valid_596091 = header.getOrDefault("X-Amz-Signature")
  valid_596091 = validateParameter(valid_596091, JString, required = false,
                                 default = nil)
  if valid_596091 != nil:
    section.add "X-Amz-Signature", valid_596091
  var valid_596092 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596092 = validateParameter(valid_596092, JString, required = false,
                                 default = nil)
  if valid_596092 != nil:
    section.add "X-Amz-SignedHeaders", valid_596092
  var valid_596093 = header.getOrDefault("X-Amz-Credential")
  valid_596093 = validateParameter(valid_596093, JString, required = false,
                                 default = nil)
  if valid_596093 != nil:
    section.add "X-Amz-Credential", valid_596093
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596094: Call_ListOutgoingCertificates_596081; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists certificates that are being transferred but not yet accepted.
  ## 
  let valid = call_596094.validator(path, query, header, formData, body)
  let scheme = call_596094.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596094.url(scheme.get, call_596094.host, call_596094.base,
                         call_596094.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596094, url, valid)

proc call*(call_596095: Call_ListOutgoingCertificates_596081; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listOutgoingCertificates
  ## Lists certificates that are being transferred but not yet accepted.
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  var query_596096 = newJObject()
  add(query_596096, "marker", newJString(marker))
  add(query_596096, "pageSize", newJInt(pageSize))
  add(query_596096, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_596095.call(nil, query_596096, nil, nil, nil)

var listOutgoingCertificates* = Call_ListOutgoingCertificates_596081(
    name: "listOutgoingCertificates", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates-out-going",
    validator: validate_ListOutgoingCertificates_596082, base: "/",
    url: url_ListOutgoingCertificates_596083, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicies_596097 = ref object of OpenApiRestCall_593437
proc url_ListPolicies_596099(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListPolicies_596098(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists your policies.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  section = newJObject()
  var valid_596100 = query.getOrDefault("marker")
  valid_596100 = validateParameter(valid_596100, JString, required = false,
                                 default = nil)
  if valid_596100 != nil:
    section.add "marker", valid_596100
  var valid_596101 = query.getOrDefault("pageSize")
  valid_596101 = validateParameter(valid_596101, JInt, required = false, default = nil)
  if valid_596101 != nil:
    section.add "pageSize", valid_596101
  var valid_596102 = query.getOrDefault("isAscendingOrder")
  valid_596102 = validateParameter(valid_596102, JBool, required = false, default = nil)
  if valid_596102 != nil:
    section.add "isAscendingOrder", valid_596102
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596103 = header.getOrDefault("X-Amz-Date")
  valid_596103 = validateParameter(valid_596103, JString, required = false,
                                 default = nil)
  if valid_596103 != nil:
    section.add "X-Amz-Date", valid_596103
  var valid_596104 = header.getOrDefault("X-Amz-Security-Token")
  valid_596104 = validateParameter(valid_596104, JString, required = false,
                                 default = nil)
  if valid_596104 != nil:
    section.add "X-Amz-Security-Token", valid_596104
  var valid_596105 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596105 = validateParameter(valid_596105, JString, required = false,
                                 default = nil)
  if valid_596105 != nil:
    section.add "X-Amz-Content-Sha256", valid_596105
  var valid_596106 = header.getOrDefault("X-Amz-Algorithm")
  valid_596106 = validateParameter(valid_596106, JString, required = false,
                                 default = nil)
  if valid_596106 != nil:
    section.add "X-Amz-Algorithm", valid_596106
  var valid_596107 = header.getOrDefault("X-Amz-Signature")
  valid_596107 = validateParameter(valid_596107, JString, required = false,
                                 default = nil)
  if valid_596107 != nil:
    section.add "X-Amz-Signature", valid_596107
  var valid_596108 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596108 = validateParameter(valid_596108, JString, required = false,
                                 default = nil)
  if valid_596108 != nil:
    section.add "X-Amz-SignedHeaders", valid_596108
  var valid_596109 = header.getOrDefault("X-Amz-Credential")
  valid_596109 = validateParameter(valid_596109, JString, required = false,
                                 default = nil)
  if valid_596109 != nil:
    section.add "X-Amz-Credential", valid_596109
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596110: Call_ListPolicies_596097; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists your policies.
  ## 
  let valid = call_596110.validator(path, query, header, formData, body)
  let scheme = call_596110.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596110.url(scheme.get, call_596110.host, call_596110.base,
                         call_596110.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596110, url, valid)

proc call*(call_596111: Call_ListPolicies_596097; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listPolicies
  ## Lists your policies.
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  var query_596112 = newJObject()
  add(query_596112, "marker", newJString(marker))
  add(query_596112, "pageSize", newJInt(pageSize))
  add(query_596112, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_596111.call(nil, query_596112, nil, nil, nil)

var listPolicies* = Call_ListPolicies_596097(name: "listPolicies",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/policies",
    validator: validate_ListPolicies_596098, base: "/", url: url_ListPolicies_596099,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicyPrincipals_596113 = ref object of OpenApiRestCall_593437
proc url_ListPolicyPrincipals_596115(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListPolicyPrincipals_596114(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  section = newJObject()
  var valid_596116 = query.getOrDefault("marker")
  valid_596116 = validateParameter(valid_596116, JString, required = false,
                                 default = nil)
  if valid_596116 != nil:
    section.add "marker", valid_596116
  var valid_596117 = query.getOrDefault("pageSize")
  valid_596117 = validateParameter(valid_596117, JInt, required = false, default = nil)
  if valid_596117 != nil:
    section.add "pageSize", valid_596117
  var valid_596118 = query.getOrDefault("isAscendingOrder")
  valid_596118 = validateParameter(valid_596118, JBool, required = false, default = nil)
  if valid_596118 != nil:
    section.add "isAscendingOrder", valid_596118
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   x-amzn-iot-policy: JString (required)
  ##                    : The policy name.
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596119 = header.getOrDefault("X-Amz-Date")
  valid_596119 = validateParameter(valid_596119, JString, required = false,
                                 default = nil)
  if valid_596119 != nil:
    section.add "X-Amz-Date", valid_596119
  var valid_596120 = header.getOrDefault("X-Amz-Security-Token")
  valid_596120 = validateParameter(valid_596120, JString, required = false,
                                 default = nil)
  if valid_596120 != nil:
    section.add "X-Amz-Security-Token", valid_596120
  var valid_596121 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596121 = validateParameter(valid_596121, JString, required = false,
                                 default = nil)
  if valid_596121 != nil:
    section.add "X-Amz-Content-Sha256", valid_596121
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-policy` field"
  var valid_596122 = header.getOrDefault("x-amzn-iot-policy")
  valid_596122 = validateParameter(valid_596122, JString, required = true,
                                 default = nil)
  if valid_596122 != nil:
    section.add "x-amzn-iot-policy", valid_596122
  var valid_596123 = header.getOrDefault("X-Amz-Algorithm")
  valid_596123 = validateParameter(valid_596123, JString, required = false,
                                 default = nil)
  if valid_596123 != nil:
    section.add "X-Amz-Algorithm", valid_596123
  var valid_596124 = header.getOrDefault("X-Amz-Signature")
  valid_596124 = validateParameter(valid_596124, JString, required = false,
                                 default = nil)
  if valid_596124 != nil:
    section.add "X-Amz-Signature", valid_596124
  var valid_596125 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596125 = validateParameter(valid_596125, JString, required = false,
                                 default = nil)
  if valid_596125 != nil:
    section.add "X-Amz-SignedHeaders", valid_596125
  var valid_596126 = header.getOrDefault("X-Amz-Credential")
  valid_596126 = validateParameter(valid_596126, JString, required = false,
                                 default = nil)
  if valid_596126 != nil:
    section.add "X-Amz-Credential", valid_596126
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596127: Call_ListPolicyPrincipals_596113; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ## 
  let valid = call_596127.validator(path, query, header, formData, body)
  let scheme = call_596127.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596127.url(scheme.get, call_596127.host, call_596127.base,
                         call_596127.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596127, url, valid)

proc call*(call_596128: Call_ListPolicyPrincipals_596113; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listPolicyPrincipals
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  var query_596129 = newJObject()
  add(query_596129, "marker", newJString(marker))
  add(query_596129, "pageSize", newJInt(pageSize))
  add(query_596129, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_596128.call(nil, query_596129, nil, nil, nil)

var listPolicyPrincipals* = Call_ListPolicyPrincipals_596113(
    name: "listPolicyPrincipals", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/policy-principals#x-amzn-iot-policy",
    validator: validate_ListPolicyPrincipals_596114, base: "/",
    url: url_ListPolicyPrincipals_596115, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPrincipalPolicies_596130 = ref object of OpenApiRestCall_593437
proc url_ListPrincipalPolicies_596132(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListPrincipalPolicies_596131(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, results are returned in ascending creation order.
  section = newJObject()
  var valid_596133 = query.getOrDefault("marker")
  valid_596133 = validateParameter(valid_596133, JString, required = false,
                                 default = nil)
  if valid_596133 != nil:
    section.add "marker", valid_596133
  var valid_596134 = query.getOrDefault("pageSize")
  valid_596134 = validateParameter(valid_596134, JInt, required = false, default = nil)
  if valid_596134 != nil:
    section.add "pageSize", valid_596134
  var valid_596135 = query.getOrDefault("isAscendingOrder")
  valid_596135 = validateParameter(valid_596135, JBool, required = false, default = nil)
  if valid_596135 != nil:
    section.add "isAscendingOrder", valid_596135
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : The principal.
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596136 = header.getOrDefault("X-Amz-Date")
  valid_596136 = validateParameter(valid_596136, JString, required = false,
                                 default = nil)
  if valid_596136 != nil:
    section.add "X-Amz-Date", valid_596136
  var valid_596137 = header.getOrDefault("X-Amz-Security-Token")
  valid_596137 = validateParameter(valid_596137, JString, required = false,
                                 default = nil)
  if valid_596137 != nil:
    section.add "X-Amz-Security-Token", valid_596137
  var valid_596138 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596138 = validateParameter(valid_596138, JString, required = false,
                                 default = nil)
  if valid_596138 != nil:
    section.add "X-Amz-Content-Sha256", valid_596138
  var valid_596139 = header.getOrDefault("X-Amz-Algorithm")
  valid_596139 = validateParameter(valid_596139, JString, required = false,
                                 default = nil)
  if valid_596139 != nil:
    section.add "X-Amz-Algorithm", valid_596139
  var valid_596140 = header.getOrDefault("X-Amz-Signature")
  valid_596140 = validateParameter(valid_596140, JString, required = false,
                                 default = nil)
  if valid_596140 != nil:
    section.add "X-Amz-Signature", valid_596140
  var valid_596141 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596141 = validateParameter(valid_596141, JString, required = false,
                                 default = nil)
  if valid_596141 != nil:
    section.add "X-Amz-SignedHeaders", valid_596141
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_596142 = header.getOrDefault("x-amzn-iot-principal")
  valid_596142 = validateParameter(valid_596142, JString, required = true,
                                 default = nil)
  if valid_596142 != nil:
    section.add "x-amzn-iot-principal", valid_596142
  var valid_596143 = header.getOrDefault("X-Amz-Credential")
  valid_596143 = validateParameter(valid_596143, JString, required = false,
                                 default = nil)
  if valid_596143 != nil:
    section.add "X-Amz-Credential", valid_596143
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596144: Call_ListPrincipalPolicies_596130; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ## 
  let valid = call_596144.validator(path, query, header, formData, body)
  let scheme = call_596144.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596144.url(scheme.get, call_596144.host, call_596144.base,
                         call_596144.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596144, url, valid)

proc call*(call_596145: Call_ListPrincipalPolicies_596130; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listPrincipalPolicies
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, results are returned in ascending creation order.
  var query_596146 = newJObject()
  add(query_596146, "marker", newJString(marker))
  add(query_596146, "pageSize", newJInt(pageSize))
  add(query_596146, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_596145.call(nil, query_596146, nil, nil, nil)

var listPrincipalPolicies* = Call_ListPrincipalPolicies_596130(
    name: "listPrincipalPolicies", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/principal-policies#x-amzn-iot-principal",
    validator: validate_ListPrincipalPolicies_596131, base: "/",
    url: url_ListPrincipalPolicies_596132, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPrincipalThings_596147 = ref object of OpenApiRestCall_593437
proc url_ListPrincipalThings_596149(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListPrincipalThings_596148(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  var valid_596150 = query.getOrDefault("maxResults")
  valid_596150 = validateParameter(valid_596150, JInt, required = false, default = nil)
  if valid_596150 != nil:
    section.add "maxResults", valid_596150
  var valid_596151 = query.getOrDefault("nextToken")
  valid_596151 = validateParameter(valid_596151, JString, required = false,
                                 default = nil)
  if valid_596151 != nil:
    section.add "nextToken", valid_596151
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : The principal.
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596152 = header.getOrDefault("X-Amz-Date")
  valid_596152 = validateParameter(valid_596152, JString, required = false,
                                 default = nil)
  if valid_596152 != nil:
    section.add "X-Amz-Date", valid_596152
  var valid_596153 = header.getOrDefault("X-Amz-Security-Token")
  valid_596153 = validateParameter(valid_596153, JString, required = false,
                                 default = nil)
  if valid_596153 != nil:
    section.add "X-Amz-Security-Token", valid_596153
  var valid_596154 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596154 = validateParameter(valid_596154, JString, required = false,
                                 default = nil)
  if valid_596154 != nil:
    section.add "X-Amz-Content-Sha256", valid_596154
  var valid_596155 = header.getOrDefault("X-Amz-Algorithm")
  valid_596155 = validateParameter(valid_596155, JString, required = false,
                                 default = nil)
  if valid_596155 != nil:
    section.add "X-Amz-Algorithm", valid_596155
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_596156 = header.getOrDefault("x-amzn-principal")
  valid_596156 = validateParameter(valid_596156, JString, required = true,
                                 default = nil)
  if valid_596156 != nil:
    section.add "x-amzn-principal", valid_596156
  var valid_596157 = header.getOrDefault("X-Amz-Signature")
  valid_596157 = validateParameter(valid_596157, JString, required = false,
                                 default = nil)
  if valid_596157 != nil:
    section.add "X-Amz-Signature", valid_596157
  var valid_596158 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596158 = validateParameter(valid_596158, JString, required = false,
                                 default = nil)
  if valid_596158 != nil:
    section.add "X-Amz-SignedHeaders", valid_596158
  var valid_596159 = header.getOrDefault("X-Amz-Credential")
  valid_596159 = validateParameter(valid_596159, JString, required = false,
                                 default = nil)
  if valid_596159 != nil:
    section.add "X-Amz-Credential", valid_596159
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596160: Call_ListPrincipalThings_596147; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ## 
  let valid = call_596160.validator(path, query, header, formData, body)
  let scheme = call_596160.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596160.url(scheme.get, call_596160.host, call_596160.base,
                         call_596160.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596160, url, valid)

proc call*(call_596161: Call_ListPrincipalThings_596147; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listPrincipalThings
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var query_596162 = newJObject()
  add(query_596162, "maxResults", newJInt(maxResults))
  add(query_596162, "nextToken", newJString(nextToken))
  result = call_596161.call(nil, query_596162, nil, nil, nil)

var listPrincipalThings* = Call_ListPrincipalThings_596147(
    name: "listPrincipalThings", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/principals/things#x-amzn-principal",
    validator: validate_ListPrincipalThings_596148, base: "/",
    url: url_ListPrincipalThings_596149, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListRoleAliases_596163 = ref object of OpenApiRestCall_593437
proc url_ListRoleAliases_596165(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListRoleAliases_596164(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Lists the role aliases registered in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   isAscendingOrder: JBool
  ##                   : Return the list of role aliases in ascending alphabetical order.
  section = newJObject()
  var valid_596166 = query.getOrDefault("marker")
  valid_596166 = validateParameter(valid_596166, JString, required = false,
                                 default = nil)
  if valid_596166 != nil:
    section.add "marker", valid_596166
  var valid_596167 = query.getOrDefault("pageSize")
  valid_596167 = validateParameter(valid_596167, JInt, required = false, default = nil)
  if valid_596167 != nil:
    section.add "pageSize", valid_596167
  var valid_596168 = query.getOrDefault("isAscendingOrder")
  valid_596168 = validateParameter(valid_596168, JBool, required = false, default = nil)
  if valid_596168 != nil:
    section.add "isAscendingOrder", valid_596168
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596169 = header.getOrDefault("X-Amz-Date")
  valid_596169 = validateParameter(valid_596169, JString, required = false,
                                 default = nil)
  if valid_596169 != nil:
    section.add "X-Amz-Date", valid_596169
  var valid_596170 = header.getOrDefault("X-Amz-Security-Token")
  valid_596170 = validateParameter(valid_596170, JString, required = false,
                                 default = nil)
  if valid_596170 != nil:
    section.add "X-Amz-Security-Token", valid_596170
  var valid_596171 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596171 = validateParameter(valid_596171, JString, required = false,
                                 default = nil)
  if valid_596171 != nil:
    section.add "X-Amz-Content-Sha256", valid_596171
  var valid_596172 = header.getOrDefault("X-Amz-Algorithm")
  valid_596172 = validateParameter(valid_596172, JString, required = false,
                                 default = nil)
  if valid_596172 != nil:
    section.add "X-Amz-Algorithm", valid_596172
  var valid_596173 = header.getOrDefault("X-Amz-Signature")
  valid_596173 = validateParameter(valid_596173, JString, required = false,
                                 default = nil)
  if valid_596173 != nil:
    section.add "X-Amz-Signature", valid_596173
  var valid_596174 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596174 = validateParameter(valid_596174, JString, required = false,
                                 default = nil)
  if valid_596174 != nil:
    section.add "X-Amz-SignedHeaders", valid_596174
  var valid_596175 = header.getOrDefault("X-Amz-Credential")
  valid_596175 = validateParameter(valid_596175, JString, required = false,
                                 default = nil)
  if valid_596175 != nil:
    section.add "X-Amz-Credential", valid_596175
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596176: Call_ListRoleAliases_596163; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the role aliases registered in your account.
  ## 
  let valid = call_596176.validator(path, query, header, formData, body)
  let scheme = call_596176.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596176.url(scheme.get, call_596176.host, call_596176.base,
                         call_596176.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596176, url, valid)

proc call*(call_596177: Call_ListRoleAliases_596163; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listRoleAliases
  ## Lists the role aliases registered in your account.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   isAscendingOrder: bool
  ##                   : Return the list of role aliases in ascending alphabetical order.
  var query_596178 = newJObject()
  add(query_596178, "marker", newJString(marker))
  add(query_596178, "pageSize", newJInt(pageSize))
  add(query_596178, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_596177.call(nil, query_596178, nil, nil, nil)

var listRoleAliases* = Call_ListRoleAliases_596163(name: "listRoleAliases",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/role-aliases",
    validator: validate_ListRoleAliases_596164, base: "/", url: url_ListRoleAliases_596165,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListScheduledAudits_596179 = ref object of OpenApiRestCall_593437
proc url_ListScheduledAudits_596181(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListScheduledAudits_596180(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists all of your scheduled audits.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  section = newJObject()
  var valid_596182 = query.getOrDefault("maxResults")
  valid_596182 = validateParameter(valid_596182, JInt, required = false, default = nil)
  if valid_596182 != nil:
    section.add "maxResults", valid_596182
  var valid_596183 = query.getOrDefault("nextToken")
  valid_596183 = validateParameter(valid_596183, JString, required = false,
                                 default = nil)
  if valid_596183 != nil:
    section.add "nextToken", valid_596183
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596184 = header.getOrDefault("X-Amz-Date")
  valid_596184 = validateParameter(valid_596184, JString, required = false,
                                 default = nil)
  if valid_596184 != nil:
    section.add "X-Amz-Date", valid_596184
  var valid_596185 = header.getOrDefault("X-Amz-Security-Token")
  valid_596185 = validateParameter(valid_596185, JString, required = false,
                                 default = nil)
  if valid_596185 != nil:
    section.add "X-Amz-Security-Token", valid_596185
  var valid_596186 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596186 = validateParameter(valid_596186, JString, required = false,
                                 default = nil)
  if valid_596186 != nil:
    section.add "X-Amz-Content-Sha256", valid_596186
  var valid_596187 = header.getOrDefault("X-Amz-Algorithm")
  valid_596187 = validateParameter(valid_596187, JString, required = false,
                                 default = nil)
  if valid_596187 != nil:
    section.add "X-Amz-Algorithm", valid_596187
  var valid_596188 = header.getOrDefault("X-Amz-Signature")
  valid_596188 = validateParameter(valid_596188, JString, required = false,
                                 default = nil)
  if valid_596188 != nil:
    section.add "X-Amz-Signature", valid_596188
  var valid_596189 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596189 = validateParameter(valid_596189, JString, required = false,
                                 default = nil)
  if valid_596189 != nil:
    section.add "X-Amz-SignedHeaders", valid_596189
  var valid_596190 = header.getOrDefault("X-Amz-Credential")
  valid_596190 = validateParameter(valid_596190, JString, required = false,
                                 default = nil)
  if valid_596190 != nil:
    section.add "X-Amz-Credential", valid_596190
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596191: Call_ListScheduledAudits_596179; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all of your scheduled audits.
  ## 
  let valid = call_596191.validator(path, query, header, formData, body)
  let scheme = call_596191.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596191.url(scheme.get, call_596191.host, call_596191.base,
                         call_596191.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596191, url, valid)

proc call*(call_596192: Call_ListScheduledAudits_596179; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listScheduledAudits
  ## Lists all of your scheduled audits.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: string
  ##            : The token for the next set of results.
  var query_596193 = newJObject()
  add(query_596193, "maxResults", newJInt(maxResults))
  add(query_596193, "nextToken", newJString(nextToken))
  result = call_596192.call(nil, query_596193, nil, nil, nil)

var listScheduledAudits* = Call_ListScheduledAudits_596179(
    name: "listScheduledAudits", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/scheduledaudits",
    validator: validate_ListScheduledAudits_596180, base: "/",
    url: url_ListScheduledAudits_596181, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListSecurityProfiles_596194 = ref object of OpenApiRestCall_593437
proc url_ListSecurityProfiles_596196(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListSecurityProfiles_596195(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  section = newJObject()
  var valid_596197 = query.getOrDefault("maxResults")
  valid_596197 = validateParameter(valid_596197, JInt, required = false, default = nil)
  if valid_596197 != nil:
    section.add "maxResults", valid_596197
  var valid_596198 = query.getOrDefault("nextToken")
  valid_596198 = validateParameter(valid_596198, JString, required = false,
                                 default = nil)
  if valid_596198 != nil:
    section.add "nextToken", valid_596198
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596199 = header.getOrDefault("X-Amz-Date")
  valid_596199 = validateParameter(valid_596199, JString, required = false,
                                 default = nil)
  if valid_596199 != nil:
    section.add "X-Amz-Date", valid_596199
  var valid_596200 = header.getOrDefault("X-Amz-Security-Token")
  valid_596200 = validateParameter(valid_596200, JString, required = false,
                                 default = nil)
  if valid_596200 != nil:
    section.add "X-Amz-Security-Token", valid_596200
  var valid_596201 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596201 = validateParameter(valid_596201, JString, required = false,
                                 default = nil)
  if valid_596201 != nil:
    section.add "X-Amz-Content-Sha256", valid_596201
  var valid_596202 = header.getOrDefault("X-Amz-Algorithm")
  valid_596202 = validateParameter(valid_596202, JString, required = false,
                                 default = nil)
  if valid_596202 != nil:
    section.add "X-Amz-Algorithm", valid_596202
  var valid_596203 = header.getOrDefault("X-Amz-Signature")
  valid_596203 = validateParameter(valid_596203, JString, required = false,
                                 default = nil)
  if valid_596203 != nil:
    section.add "X-Amz-Signature", valid_596203
  var valid_596204 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596204 = validateParameter(valid_596204, JString, required = false,
                                 default = nil)
  if valid_596204 != nil:
    section.add "X-Amz-SignedHeaders", valid_596204
  var valid_596205 = header.getOrDefault("X-Amz-Credential")
  valid_596205 = validateParameter(valid_596205, JString, required = false,
                                 default = nil)
  if valid_596205 != nil:
    section.add "X-Amz-Credential", valid_596205
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596206: Call_ListSecurityProfiles_596194; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ## 
  let valid = call_596206.validator(path, query, header, formData, body)
  let scheme = call_596206.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596206.url(scheme.get, call_596206.host, call_596206.base,
                         call_596206.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596206, url, valid)

proc call*(call_596207: Call_ListSecurityProfiles_596194; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listSecurityProfiles
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  var query_596208 = newJObject()
  add(query_596208, "maxResults", newJInt(maxResults))
  add(query_596208, "nextToken", newJString(nextToken))
  result = call_596207.call(nil, query_596208, nil, nil, nil)

var listSecurityProfiles* = Call_ListSecurityProfiles_596194(
    name: "listSecurityProfiles", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/security-profiles",
    validator: validate_ListSecurityProfiles_596195, base: "/",
    url: url_ListSecurityProfiles_596196, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListSecurityProfilesForTarget_596209 = ref object of OpenApiRestCall_593437
proc url_ListSecurityProfilesForTarget_596211(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListSecurityProfilesForTarget_596210(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the target (thing group) whose attached security profiles you want to get.
  ##   recursive: JBool
  ##            : If true, return child groups too.
  section = newJObject()
  var valid_596212 = query.getOrDefault("maxResults")
  valid_596212 = validateParameter(valid_596212, JInt, required = false, default = nil)
  if valid_596212 != nil:
    section.add "maxResults", valid_596212
  var valid_596213 = query.getOrDefault("nextToken")
  valid_596213 = validateParameter(valid_596213, JString, required = false,
                                 default = nil)
  if valid_596213 != nil:
    section.add "nextToken", valid_596213
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_596214 = query.getOrDefault("securityProfileTargetArn")
  valid_596214 = validateParameter(valid_596214, JString, required = true,
                                 default = nil)
  if valid_596214 != nil:
    section.add "securityProfileTargetArn", valid_596214
  var valid_596215 = query.getOrDefault("recursive")
  valid_596215 = validateParameter(valid_596215, JBool, required = false, default = nil)
  if valid_596215 != nil:
    section.add "recursive", valid_596215
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596216 = header.getOrDefault("X-Amz-Date")
  valid_596216 = validateParameter(valid_596216, JString, required = false,
                                 default = nil)
  if valid_596216 != nil:
    section.add "X-Amz-Date", valid_596216
  var valid_596217 = header.getOrDefault("X-Amz-Security-Token")
  valid_596217 = validateParameter(valid_596217, JString, required = false,
                                 default = nil)
  if valid_596217 != nil:
    section.add "X-Amz-Security-Token", valid_596217
  var valid_596218 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596218 = validateParameter(valid_596218, JString, required = false,
                                 default = nil)
  if valid_596218 != nil:
    section.add "X-Amz-Content-Sha256", valid_596218
  var valid_596219 = header.getOrDefault("X-Amz-Algorithm")
  valid_596219 = validateParameter(valid_596219, JString, required = false,
                                 default = nil)
  if valid_596219 != nil:
    section.add "X-Amz-Algorithm", valid_596219
  var valid_596220 = header.getOrDefault("X-Amz-Signature")
  valid_596220 = validateParameter(valid_596220, JString, required = false,
                                 default = nil)
  if valid_596220 != nil:
    section.add "X-Amz-Signature", valid_596220
  var valid_596221 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596221 = validateParameter(valid_596221, JString, required = false,
                                 default = nil)
  if valid_596221 != nil:
    section.add "X-Amz-SignedHeaders", valid_596221
  var valid_596222 = header.getOrDefault("X-Amz-Credential")
  valid_596222 = validateParameter(valid_596222, JString, required = false,
                                 default = nil)
  if valid_596222 != nil:
    section.add "X-Amz-Credential", valid_596222
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596223: Call_ListSecurityProfilesForTarget_596209; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ## 
  let valid = call_596223.validator(path, query, header, formData, body)
  let scheme = call_596223.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596223.url(scheme.get, call_596223.host, call_596223.base,
                         call_596223.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596223, url, valid)

proc call*(call_596224: Call_ListSecurityProfilesForTarget_596209;
          securityProfileTargetArn: string; maxResults: int = 0;
          nextToken: string = ""; recursive: bool = false): Recallable =
  ## listSecurityProfilesForTarget
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the target (thing group) whose attached security profiles you want to get.
  ##   recursive: bool
  ##            : If true, return child groups too.
  var query_596225 = newJObject()
  add(query_596225, "maxResults", newJInt(maxResults))
  add(query_596225, "nextToken", newJString(nextToken))
  add(query_596225, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(query_596225, "recursive", newJBool(recursive))
  result = call_596224.call(nil, query_596225, nil, nil, nil)

var listSecurityProfilesForTarget* = Call_ListSecurityProfilesForTarget_596209(
    name: "listSecurityProfilesForTarget", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/security-profiles-for-target#securityProfileTargetArn",
    validator: validate_ListSecurityProfilesForTarget_596210, base: "/",
    url: url_ListSecurityProfilesForTarget_596211,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListStreams_596226 = ref object of OpenApiRestCall_593437
proc url_ListStreams_596228(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListStreams_596227(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all of the streams in your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at a time.
  ##   nextToken: JString
  ##            : A token used to get the next set of results.
  ##   isAscendingOrder: JBool
  ##                   : Set to true to return the list of streams in ascending order.
  section = newJObject()
  var valid_596229 = query.getOrDefault("maxResults")
  valid_596229 = validateParameter(valid_596229, JInt, required = false, default = nil)
  if valid_596229 != nil:
    section.add "maxResults", valid_596229
  var valid_596230 = query.getOrDefault("nextToken")
  valid_596230 = validateParameter(valid_596230, JString, required = false,
                                 default = nil)
  if valid_596230 != nil:
    section.add "nextToken", valid_596230
  var valid_596231 = query.getOrDefault("isAscendingOrder")
  valid_596231 = validateParameter(valid_596231, JBool, required = false, default = nil)
  if valid_596231 != nil:
    section.add "isAscendingOrder", valid_596231
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596232 = header.getOrDefault("X-Amz-Date")
  valid_596232 = validateParameter(valid_596232, JString, required = false,
                                 default = nil)
  if valid_596232 != nil:
    section.add "X-Amz-Date", valid_596232
  var valid_596233 = header.getOrDefault("X-Amz-Security-Token")
  valid_596233 = validateParameter(valid_596233, JString, required = false,
                                 default = nil)
  if valid_596233 != nil:
    section.add "X-Amz-Security-Token", valid_596233
  var valid_596234 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596234 = validateParameter(valid_596234, JString, required = false,
                                 default = nil)
  if valid_596234 != nil:
    section.add "X-Amz-Content-Sha256", valid_596234
  var valid_596235 = header.getOrDefault("X-Amz-Algorithm")
  valid_596235 = validateParameter(valid_596235, JString, required = false,
                                 default = nil)
  if valid_596235 != nil:
    section.add "X-Amz-Algorithm", valid_596235
  var valid_596236 = header.getOrDefault("X-Amz-Signature")
  valid_596236 = validateParameter(valid_596236, JString, required = false,
                                 default = nil)
  if valid_596236 != nil:
    section.add "X-Amz-Signature", valid_596236
  var valid_596237 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596237 = validateParameter(valid_596237, JString, required = false,
                                 default = nil)
  if valid_596237 != nil:
    section.add "X-Amz-SignedHeaders", valid_596237
  var valid_596238 = header.getOrDefault("X-Amz-Credential")
  valid_596238 = validateParameter(valid_596238, JString, required = false,
                                 default = nil)
  if valid_596238 != nil:
    section.add "X-Amz-Credential", valid_596238
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596239: Call_ListStreams_596226; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all of the streams in your AWS account.
  ## 
  let valid = call_596239.validator(path, query, header, formData, body)
  let scheme = call_596239.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596239.url(scheme.get, call_596239.host, call_596239.base,
                         call_596239.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596239, url, valid)

proc call*(call_596240: Call_ListStreams_596226; maxResults: int = 0;
          nextToken: string = ""; isAscendingOrder: bool = false): Recallable =
  ## listStreams
  ## Lists all of the streams in your AWS account.
  ##   maxResults: int
  ##             : The maximum number of results to return at a time.
  ##   nextToken: string
  ##            : A token used to get the next set of results.
  ##   isAscendingOrder: bool
  ##                   : Set to true to return the list of streams in ascending order.
  var query_596241 = newJObject()
  add(query_596241, "maxResults", newJInt(maxResults))
  add(query_596241, "nextToken", newJString(nextToken))
  add(query_596241, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_596240.call(nil, query_596241, nil, nil, nil)

var listStreams* = Call_ListStreams_596226(name: "listStreams",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/streams",
                                        validator: validate_ListStreams_596227,
                                        base: "/", url: url_ListStreams_596228,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTagsForResource_596242 = ref object of OpenApiRestCall_593437
proc url_ListTagsForResource_596244(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListTagsForResource_596243(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the tags (metadata) you have assigned to the resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   resourceArn: JString (required)
  ##              : The ARN of the resource.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `resourceArn` field"
  var valid_596245 = query.getOrDefault("resourceArn")
  valid_596245 = validateParameter(valid_596245, JString, required = true,
                                 default = nil)
  if valid_596245 != nil:
    section.add "resourceArn", valid_596245
  var valid_596246 = query.getOrDefault("nextToken")
  valid_596246 = validateParameter(valid_596246, JString, required = false,
                                 default = nil)
  if valid_596246 != nil:
    section.add "nextToken", valid_596246
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596247 = header.getOrDefault("X-Amz-Date")
  valid_596247 = validateParameter(valid_596247, JString, required = false,
                                 default = nil)
  if valid_596247 != nil:
    section.add "X-Amz-Date", valid_596247
  var valid_596248 = header.getOrDefault("X-Amz-Security-Token")
  valid_596248 = validateParameter(valid_596248, JString, required = false,
                                 default = nil)
  if valid_596248 != nil:
    section.add "X-Amz-Security-Token", valid_596248
  var valid_596249 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596249 = validateParameter(valid_596249, JString, required = false,
                                 default = nil)
  if valid_596249 != nil:
    section.add "X-Amz-Content-Sha256", valid_596249
  var valid_596250 = header.getOrDefault("X-Amz-Algorithm")
  valid_596250 = validateParameter(valid_596250, JString, required = false,
                                 default = nil)
  if valid_596250 != nil:
    section.add "X-Amz-Algorithm", valid_596250
  var valid_596251 = header.getOrDefault("X-Amz-Signature")
  valid_596251 = validateParameter(valid_596251, JString, required = false,
                                 default = nil)
  if valid_596251 != nil:
    section.add "X-Amz-Signature", valid_596251
  var valid_596252 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596252 = validateParameter(valid_596252, JString, required = false,
                                 default = nil)
  if valid_596252 != nil:
    section.add "X-Amz-SignedHeaders", valid_596252
  var valid_596253 = header.getOrDefault("X-Amz-Credential")
  valid_596253 = validateParameter(valid_596253, JString, required = false,
                                 default = nil)
  if valid_596253 != nil:
    section.add "X-Amz-Credential", valid_596253
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596254: Call_ListTagsForResource_596242; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the tags (metadata) you have assigned to the resource.
  ## 
  let valid = call_596254.validator(path, query, header, formData, body)
  let scheme = call_596254.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596254.url(scheme.get, call_596254.host, call_596254.base,
                         call_596254.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596254, url, valid)

proc call*(call_596255: Call_ListTagsForResource_596242; resourceArn: string;
          nextToken: string = ""): Recallable =
  ## listTagsForResource
  ## Lists the tags (metadata) you have assigned to the resource.
  ##   resourceArn: string (required)
  ##              : The ARN of the resource.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var query_596256 = newJObject()
  add(query_596256, "resourceArn", newJString(resourceArn))
  add(query_596256, "nextToken", newJString(nextToken))
  result = call_596255.call(nil, query_596256, nil, nil, nil)

var listTagsForResource* = Call_ListTagsForResource_596242(
    name: "listTagsForResource", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/tags#resourceArn",
    validator: validate_ListTagsForResource_596243, base: "/",
    url: url_ListTagsForResource_596244, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTargetsForPolicy_596257 = ref object of OpenApiRestCall_593437
proc url_ListTargetsForPolicy_596259(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policy-targets/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListTargetsForPolicy_596258(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List targets for the specified policy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_596260 = path.getOrDefault("policyName")
  valid_596260 = validateParameter(valid_596260, JString, required = true,
                                 default = nil)
  if valid_596260 != nil:
    section.add "policyName", valid_596260
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  section = newJObject()
  var valid_596261 = query.getOrDefault("marker")
  valid_596261 = validateParameter(valid_596261, JString, required = false,
                                 default = nil)
  if valid_596261 != nil:
    section.add "marker", valid_596261
  var valid_596262 = query.getOrDefault("pageSize")
  valid_596262 = validateParameter(valid_596262, JInt, required = false, default = nil)
  if valid_596262 != nil:
    section.add "pageSize", valid_596262
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596263 = header.getOrDefault("X-Amz-Date")
  valid_596263 = validateParameter(valid_596263, JString, required = false,
                                 default = nil)
  if valid_596263 != nil:
    section.add "X-Amz-Date", valid_596263
  var valid_596264 = header.getOrDefault("X-Amz-Security-Token")
  valid_596264 = validateParameter(valid_596264, JString, required = false,
                                 default = nil)
  if valid_596264 != nil:
    section.add "X-Amz-Security-Token", valid_596264
  var valid_596265 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596265 = validateParameter(valid_596265, JString, required = false,
                                 default = nil)
  if valid_596265 != nil:
    section.add "X-Amz-Content-Sha256", valid_596265
  var valid_596266 = header.getOrDefault("X-Amz-Algorithm")
  valid_596266 = validateParameter(valid_596266, JString, required = false,
                                 default = nil)
  if valid_596266 != nil:
    section.add "X-Amz-Algorithm", valid_596266
  var valid_596267 = header.getOrDefault("X-Amz-Signature")
  valid_596267 = validateParameter(valid_596267, JString, required = false,
                                 default = nil)
  if valid_596267 != nil:
    section.add "X-Amz-Signature", valid_596267
  var valid_596268 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596268 = validateParameter(valid_596268, JString, required = false,
                                 default = nil)
  if valid_596268 != nil:
    section.add "X-Amz-SignedHeaders", valid_596268
  var valid_596269 = header.getOrDefault("X-Amz-Credential")
  valid_596269 = validateParameter(valid_596269, JString, required = false,
                                 default = nil)
  if valid_596269 != nil:
    section.add "X-Amz-Credential", valid_596269
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596270: Call_ListTargetsForPolicy_596257; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List targets for the specified policy.
  ## 
  let valid = call_596270.validator(path, query, header, formData, body)
  let scheme = call_596270.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596270.url(scheme.get, call_596270.host, call_596270.base,
                         call_596270.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596270, url, valid)

proc call*(call_596271: Call_ListTargetsForPolicy_596257; policyName: string;
          marker: string = ""; pageSize: int = 0): Recallable =
  ## listTargetsForPolicy
  ## List targets for the specified policy.
  ##   policyName: string (required)
  ##             : The policy name.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  var path_596272 = newJObject()
  var query_596273 = newJObject()
  add(path_596272, "policyName", newJString(policyName))
  add(query_596273, "marker", newJString(marker))
  add(query_596273, "pageSize", newJInt(pageSize))
  result = call_596271.call(path_596272, query_596273, nil, nil, nil)

var listTargetsForPolicy* = Call_ListTargetsForPolicy_596257(
    name: "listTargetsForPolicy", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/policy-targets/{policyName}",
    validator: validate_ListTargetsForPolicy_596258, base: "/",
    url: url_ListTargetsForPolicy_596259, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTargetsForSecurityProfile_596274 = ref object of OpenApiRestCall_593437
proc url_ListTargetsForSecurityProfile_596276(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"),
               (kind: ConstantSegment, value: "/targets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListTargetsForSecurityProfile_596275(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_596277 = path.getOrDefault("securityProfileName")
  valid_596277 = validateParameter(valid_596277, JString, required = true,
                                 default = nil)
  if valid_596277 != nil:
    section.add "securityProfileName", valid_596277
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  section = newJObject()
  var valid_596278 = query.getOrDefault("maxResults")
  valid_596278 = validateParameter(valid_596278, JInt, required = false, default = nil)
  if valid_596278 != nil:
    section.add "maxResults", valid_596278
  var valid_596279 = query.getOrDefault("nextToken")
  valid_596279 = validateParameter(valid_596279, JString, required = false,
                                 default = nil)
  if valid_596279 != nil:
    section.add "nextToken", valid_596279
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596280 = header.getOrDefault("X-Amz-Date")
  valid_596280 = validateParameter(valid_596280, JString, required = false,
                                 default = nil)
  if valid_596280 != nil:
    section.add "X-Amz-Date", valid_596280
  var valid_596281 = header.getOrDefault("X-Amz-Security-Token")
  valid_596281 = validateParameter(valid_596281, JString, required = false,
                                 default = nil)
  if valid_596281 != nil:
    section.add "X-Amz-Security-Token", valid_596281
  var valid_596282 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596282 = validateParameter(valid_596282, JString, required = false,
                                 default = nil)
  if valid_596282 != nil:
    section.add "X-Amz-Content-Sha256", valid_596282
  var valid_596283 = header.getOrDefault("X-Amz-Algorithm")
  valid_596283 = validateParameter(valid_596283, JString, required = false,
                                 default = nil)
  if valid_596283 != nil:
    section.add "X-Amz-Algorithm", valid_596283
  var valid_596284 = header.getOrDefault("X-Amz-Signature")
  valid_596284 = validateParameter(valid_596284, JString, required = false,
                                 default = nil)
  if valid_596284 != nil:
    section.add "X-Amz-Signature", valid_596284
  var valid_596285 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596285 = validateParameter(valid_596285, JString, required = false,
                                 default = nil)
  if valid_596285 != nil:
    section.add "X-Amz-SignedHeaders", valid_596285
  var valid_596286 = header.getOrDefault("X-Amz-Credential")
  valid_596286 = validateParameter(valid_596286, JString, required = false,
                                 default = nil)
  if valid_596286 != nil:
    section.add "X-Amz-Credential", valid_596286
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596287: Call_ListTargetsForSecurityProfile_596274; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ## 
  let valid = call_596287.validator(path, query, header, formData, body)
  let scheme = call_596287.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596287.url(scheme.get, call_596287.host, call_596287.base,
                         call_596287.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596287, url, valid)

proc call*(call_596288: Call_ListTargetsForSecurityProfile_596274;
          securityProfileName: string; maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listTargetsForSecurityProfile
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string (required)
  ##                      : The security profile.
  var path_596289 = newJObject()
  var query_596290 = newJObject()
  add(query_596290, "maxResults", newJInt(maxResults))
  add(query_596290, "nextToken", newJString(nextToken))
  add(path_596289, "securityProfileName", newJString(securityProfileName))
  result = call_596288.call(path_596289, query_596290, nil, nil, nil)

var listTargetsForSecurityProfile* = Call_ListTargetsForSecurityProfile_596274(
    name: "listTargetsForSecurityProfile", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/security-profiles/{securityProfileName}/targets",
    validator: validate_ListTargetsForSecurityProfile_596275, base: "/",
    url: url_ListTargetsForSecurityProfile_596276,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingGroups_596291 = ref object of OpenApiRestCall_593437
proc url_ListThingGroups_596293(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListThingGroups_596292(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List the thing groups in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   namePrefixFilter: JString
  ##                   : A filter that limits the results to those with the specified name prefix.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   recursive: JBool
  ##            : If true, return child groups as well.
  ##   parentGroup: JString
  ##              : A filter that limits the results to those with the specified parent group.
  section = newJObject()
  var valid_596294 = query.getOrDefault("namePrefixFilter")
  valid_596294 = validateParameter(valid_596294, JString, required = false,
                                 default = nil)
  if valid_596294 != nil:
    section.add "namePrefixFilter", valid_596294
  var valid_596295 = query.getOrDefault("maxResults")
  valid_596295 = validateParameter(valid_596295, JInt, required = false, default = nil)
  if valid_596295 != nil:
    section.add "maxResults", valid_596295
  var valid_596296 = query.getOrDefault("nextToken")
  valid_596296 = validateParameter(valid_596296, JString, required = false,
                                 default = nil)
  if valid_596296 != nil:
    section.add "nextToken", valid_596296
  var valid_596297 = query.getOrDefault("recursive")
  valid_596297 = validateParameter(valid_596297, JBool, required = false, default = nil)
  if valid_596297 != nil:
    section.add "recursive", valid_596297
  var valid_596298 = query.getOrDefault("parentGroup")
  valid_596298 = validateParameter(valid_596298, JString, required = false,
                                 default = nil)
  if valid_596298 != nil:
    section.add "parentGroup", valid_596298
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596299 = header.getOrDefault("X-Amz-Date")
  valid_596299 = validateParameter(valid_596299, JString, required = false,
                                 default = nil)
  if valid_596299 != nil:
    section.add "X-Amz-Date", valid_596299
  var valid_596300 = header.getOrDefault("X-Amz-Security-Token")
  valid_596300 = validateParameter(valid_596300, JString, required = false,
                                 default = nil)
  if valid_596300 != nil:
    section.add "X-Amz-Security-Token", valid_596300
  var valid_596301 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596301 = validateParameter(valid_596301, JString, required = false,
                                 default = nil)
  if valid_596301 != nil:
    section.add "X-Amz-Content-Sha256", valid_596301
  var valid_596302 = header.getOrDefault("X-Amz-Algorithm")
  valid_596302 = validateParameter(valid_596302, JString, required = false,
                                 default = nil)
  if valid_596302 != nil:
    section.add "X-Amz-Algorithm", valid_596302
  var valid_596303 = header.getOrDefault("X-Amz-Signature")
  valid_596303 = validateParameter(valid_596303, JString, required = false,
                                 default = nil)
  if valid_596303 != nil:
    section.add "X-Amz-Signature", valid_596303
  var valid_596304 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596304 = validateParameter(valid_596304, JString, required = false,
                                 default = nil)
  if valid_596304 != nil:
    section.add "X-Amz-SignedHeaders", valid_596304
  var valid_596305 = header.getOrDefault("X-Amz-Credential")
  valid_596305 = validateParameter(valid_596305, JString, required = false,
                                 default = nil)
  if valid_596305 != nil:
    section.add "X-Amz-Credential", valid_596305
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596306: Call_ListThingGroups_596291; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the thing groups in your account.
  ## 
  let valid = call_596306.validator(path, query, header, formData, body)
  let scheme = call_596306.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596306.url(scheme.get, call_596306.host, call_596306.base,
                         call_596306.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596306, url, valid)

proc call*(call_596307: Call_ListThingGroups_596291; namePrefixFilter: string = "";
          maxResults: int = 0; nextToken: string = ""; recursive: bool = false;
          parentGroup: string = ""): Recallable =
  ## listThingGroups
  ## List the thing groups in your account.
  ##   namePrefixFilter: string
  ##                   : A filter that limits the results to those with the specified name prefix.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   recursive: bool
  ##            : If true, return child groups as well.
  ##   parentGroup: string
  ##              : A filter that limits the results to those with the specified parent group.
  var query_596308 = newJObject()
  add(query_596308, "namePrefixFilter", newJString(namePrefixFilter))
  add(query_596308, "maxResults", newJInt(maxResults))
  add(query_596308, "nextToken", newJString(nextToken))
  add(query_596308, "recursive", newJBool(recursive))
  add(query_596308, "parentGroup", newJString(parentGroup))
  result = call_596307.call(nil, query_596308, nil, nil, nil)

var listThingGroups* = Call_ListThingGroups_596291(name: "listThingGroups",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/thing-groups",
    validator: validate_ListThingGroups_596292, base: "/", url: url_ListThingGroups_596293,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingGroupsForThing_596309 = ref object of OpenApiRestCall_593437
proc url_ListThingGroupsForThing_596311(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/thing-groups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListThingGroupsForThing_596310(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List the thing groups to which the specified thing belongs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The thing name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_596312 = path.getOrDefault("thingName")
  valid_596312 = validateParameter(valid_596312, JString, required = true,
                                 default = nil)
  if valid_596312 != nil:
    section.add "thingName", valid_596312
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  var valid_596313 = query.getOrDefault("maxResults")
  valid_596313 = validateParameter(valid_596313, JInt, required = false, default = nil)
  if valid_596313 != nil:
    section.add "maxResults", valid_596313
  var valid_596314 = query.getOrDefault("nextToken")
  valid_596314 = validateParameter(valid_596314, JString, required = false,
                                 default = nil)
  if valid_596314 != nil:
    section.add "nextToken", valid_596314
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596315 = header.getOrDefault("X-Amz-Date")
  valid_596315 = validateParameter(valid_596315, JString, required = false,
                                 default = nil)
  if valid_596315 != nil:
    section.add "X-Amz-Date", valid_596315
  var valid_596316 = header.getOrDefault("X-Amz-Security-Token")
  valid_596316 = validateParameter(valid_596316, JString, required = false,
                                 default = nil)
  if valid_596316 != nil:
    section.add "X-Amz-Security-Token", valid_596316
  var valid_596317 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596317 = validateParameter(valid_596317, JString, required = false,
                                 default = nil)
  if valid_596317 != nil:
    section.add "X-Amz-Content-Sha256", valid_596317
  var valid_596318 = header.getOrDefault("X-Amz-Algorithm")
  valid_596318 = validateParameter(valid_596318, JString, required = false,
                                 default = nil)
  if valid_596318 != nil:
    section.add "X-Amz-Algorithm", valid_596318
  var valid_596319 = header.getOrDefault("X-Amz-Signature")
  valid_596319 = validateParameter(valid_596319, JString, required = false,
                                 default = nil)
  if valid_596319 != nil:
    section.add "X-Amz-Signature", valid_596319
  var valid_596320 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596320 = validateParameter(valid_596320, JString, required = false,
                                 default = nil)
  if valid_596320 != nil:
    section.add "X-Amz-SignedHeaders", valid_596320
  var valid_596321 = header.getOrDefault("X-Amz-Credential")
  valid_596321 = validateParameter(valid_596321, JString, required = false,
                                 default = nil)
  if valid_596321 != nil:
    section.add "X-Amz-Credential", valid_596321
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596322: Call_ListThingGroupsForThing_596309; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the thing groups to which the specified thing belongs.
  ## 
  let valid = call_596322.validator(path, query, header, formData, body)
  let scheme = call_596322.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596322.url(scheme.get, call_596322.host, call_596322.base,
                         call_596322.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596322, url, valid)

proc call*(call_596323: Call_ListThingGroupsForThing_596309; thingName: string;
          maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listThingGroupsForThing
  ## List the thing groups to which the specified thing belongs.
  ##   thingName: string (required)
  ##            : The thing name.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var path_596324 = newJObject()
  var query_596325 = newJObject()
  add(path_596324, "thingName", newJString(thingName))
  add(query_596325, "maxResults", newJInt(maxResults))
  add(query_596325, "nextToken", newJString(nextToken))
  result = call_596323.call(path_596324, query_596325, nil, nil, nil)

var listThingGroupsForThing* = Call_ListThingGroupsForThing_596309(
    name: "listThingGroupsForThing", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/thing-groups",
    validator: validate_ListThingGroupsForThing_596310, base: "/",
    url: url_ListThingGroupsForThing_596311, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingPrincipals_596326 = ref object of OpenApiRestCall_593437
proc url_ListThingPrincipals_596328(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListThingPrincipals_596327(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_596329 = path.getOrDefault("thingName")
  valid_596329 = validateParameter(valid_596329, JString, required = true,
                                 default = nil)
  if valid_596329 != nil:
    section.add "thingName", valid_596329
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596330 = header.getOrDefault("X-Amz-Date")
  valid_596330 = validateParameter(valid_596330, JString, required = false,
                                 default = nil)
  if valid_596330 != nil:
    section.add "X-Amz-Date", valid_596330
  var valid_596331 = header.getOrDefault("X-Amz-Security-Token")
  valid_596331 = validateParameter(valid_596331, JString, required = false,
                                 default = nil)
  if valid_596331 != nil:
    section.add "X-Amz-Security-Token", valid_596331
  var valid_596332 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596332 = validateParameter(valid_596332, JString, required = false,
                                 default = nil)
  if valid_596332 != nil:
    section.add "X-Amz-Content-Sha256", valid_596332
  var valid_596333 = header.getOrDefault("X-Amz-Algorithm")
  valid_596333 = validateParameter(valid_596333, JString, required = false,
                                 default = nil)
  if valid_596333 != nil:
    section.add "X-Amz-Algorithm", valid_596333
  var valid_596334 = header.getOrDefault("X-Amz-Signature")
  valid_596334 = validateParameter(valid_596334, JString, required = false,
                                 default = nil)
  if valid_596334 != nil:
    section.add "X-Amz-Signature", valid_596334
  var valid_596335 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596335 = validateParameter(valid_596335, JString, required = false,
                                 default = nil)
  if valid_596335 != nil:
    section.add "X-Amz-SignedHeaders", valid_596335
  var valid_596336 = header.getOrDefault("X-Amz-Credential")
  valid_596336 = validateParameter(valid_596336, JString, required = false,
                                 default = nil)
  if valid_596336 != nil:
    section.add "X-Amz-Credential", valid_596336
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596337: Call_ListThingPrincipals_596326; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  let valid = call_596337.validator(path, query, header, formData, body)
  let scheme = call_596337.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596337.url(scheme.get, call_596337.host, call_596337.base,
                         call_596337.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596337, url, valid)

proc call*(call_596338: Call_ListThingPrincipals_596326; thingName: string): Recallable =
  ## listThingPrincipals
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_596339 = newJObject()
  add(path_596339, "thingName", newJString(thingName))
  result = call_596338.call(path_596339, nil, nil, nil, nil)

var listThingPrincipals* = Call_ListThingPrincipals_596326(
    name: "listThingPrincipals", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/principals",
    validator: validate_ListThingPrincipals_596327, base: "/",
    url: url_ListThingPrincipals_596328, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingRegistrationTaskReports_596340 = ref object of OpenApiRestCall_593437
proc url_ListThingRegistrationTaskReports_596342(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/reports#reportType")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListThingRegistrationTaskReports_596341(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Information about the thing registration tasks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The id of the task.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_596343 = path.getOrDefault("taskId")
  valid_596343 = validateParameter(valid_596343, JString, required = true,
                                 default = nil)
  if valid_596343 != nil:
    section.add "taskId", valid_596343
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   reportType: JString (required)
  ##             : The type of task report.
  section = newJObject()
  var valid_596344 = query.getOrDefault("maxResults")
  valid_596344 = validateParameter(valid_596344, JInt, required = false, default = nil)
  if valid_596344 != nil:
    section.add "maxResults", valid_596344
  var valid_596345 = query.getOrDefault("nextToken")
  valid_596345 = validateParameter(valid_596345, JString, required = false,
                                 default = nil)
  if valid_596345 != nil:
    section.add "nextToken", valid_596345
  assert query != nil,
        "query argument is necessary due to required `reportType` field"
  var valid_596346 = query.getOrDefault("reportType")
  valid_596346 = validateParameter(valid_596346, JString, required = true,
                                 default = newJString("ERRORS"))
  if valid_596346 != nil:
    section.add "reportType", valid_596346
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596347 = header.getOrDefault("X-Amz-Date")
  valid_596347 = validateParameter(valid_596347, JString, required = false,
                                 default = nil)
  if valid_596347 != nil:
    section.add "X-Amz-Date", valid_596347
  var valid_596348 = header.getOrDefault("X-Amz-Security-Token")
  valid_596348 = validateParameter(valid_596348, JString, required = false,
                                 default = nil)
  if valid_596348 != nil:
    section.add "X-Amz-Security-Token", valid_596348
  var valid_596349 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596349 = validateParameter(valid_596349, JString, required = false,
                                 default = nil)
  if valid_596349 != nil:
    section.add "X-Amz-Content-Sha256", valid_596349
  var valid_596350 = header.getOrDefault("X-Amz-Algorithm")
  valid_596350 = validateParameter(valid_596350, JString, required = false,
                                 default = nil)
  if valid_596350 != nil:
    section.add "X-Amz-Algorithm", valid_596350
  var valid_596351 = header.getOrDefault("X-Amz-Signature")
  valid_596351 = validateParameter(valid_596351, JString, required = false,
                                 default = nil)
  if valid_596351 != nil:
    section.add "X-Amz-Signature", valid_596351
  var valid_596352 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596352 = validateParameter(valid_596352, JString, required = false,
                                 default = nil)
  if valid_596352 != nil:
    section.add "X-Amz-SignedHeaders", valid_596352
  var valid_596353 = header.getOrDefault("X-Amz-Credential")
  valid_596353 = validateParameter(valid_596353, JString, required = false,
                                 default = nil)
  if valid_596353 != nil:
    section.add "X-Amz-Credential", valid_596353
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596354: Call_ListThingRegistrationTaskReports_596340;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Information about the thing registration tasks.
  ## 
  let valid = call_596354.validator(path, query, header, formData, body)
  let scheme = call_596354.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596354.url(scheme.get, call_596354.host, call_596354.base,
                         call_596354.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596354, url, valid)

proc call*(call_596355: Call_ListThingRegistrationTaskReports_596340;
          taskId: string; maxResults: int = 0; nextToken: string = "";
          reportType: string = "ERRORS"): Recallable =
  ## listThingRegistrationTaskReports
  ## Information about the thing registration tasks.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   reportType: string (required)
  ##             : The type of task report.
  ##   taskId: string (required)
  ##         : The id of the task.
  var path_596356 = newJObject()
  var query_596357 = newJObject()
  add(query_596357, "maxResults", newJInt(maxResults))
  add(query_596357, "nextToken", newJString(nextToken))
  add(query_596357, "reportType", newJString(reportType))
  add(path_596356, "taskId", newJString(taskId))
  result = call_596355.call(path_596356, query_596357, nil, nil, nil)

var listThingRegistrationTaskReports* = Call_ListThingRegistrationTaskReports_596340(
    name: "listThingRegistrationTaskReports", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/thing-registration-tasks/{taskId}/reports#reportType",
    validator: validate_ListThingRegistrationTaskReports_596341, base: "/",
    url: url_ListThingRegistrationTaskReports_596342,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartThingRegistrationTask_596374 = ref object of OpenApiRestCall_593437
proc url_StartThingRegistrationTask_596376(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_StartThingRegistrationTask_596375(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596377 = header.getOrDefault("X-Amz-Date")
  valid_596377 = validateParameter(valid_596377, JString, required = false,
                                 default = nil)
  if valid_596377 != nil:
    section.add "X-Amz-Date", valid_596377
  var valid_596378 = header.getOrDefault("X-Amz-Security-Token")
  valid_596378 = validateParameter(valid_596378, JString, required = false,
                                 default = nil)
  if valid_596378 != nil:
    section.add "X-Amz-Security-Token", valid_596378
  var valid_596379 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596379 = validateParameter(valid_596379, JString, required = false,
                                 default = nil)
  if valid_596379 != nil:
    section.add "X-Amz-Content-Sha256", valid_596379
  var valid_596380 = header.getOrDefault("X-Amz-Algorithm")
  valid_596380 = validateParameter(valid_596380, JString, required = false,
                                 default = nil)
  if valid_596380 != nil:
    section.add "X-Amz-Algorithm", valid_596380
  var valid_596381 = header.getOrDefault("X-Amz-Signature")
  valid_596381 = validateParameter(valid_596381, JString, required = false,
                                 default = nil)
  if valid_596381 != nil:
    section.add "X-Amz-Signature", valid_596381
  var valid_596382 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596382 = validateParameter(valid_596382, JString, required = false,
                                 default = nil)
  if valid_596382 != nil:
    section.add "X-Amz-SignedHeaders", valid_596382
  var valid_596383 = header.getOrDefault("X-Amz-Credential")
  valid_596383 = validateParameter(valid_596383, JString, required = false,
                                 default = nil)
  if valid_596383 != nil:
    section.add "X-Amz-Credential", valid_596383
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596385: Call_StartThingRegistrationTask_596374; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a bulk thing provisioning task.
  ## 
  let valid = call_596385.validator(path, query, header, formData, body)
  let scheme = call_596385.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596385.url(scheme.get, call_596385.host, call_596385.base,
                         call_596385.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596385, url, valid)

proc call*(call_596386: Call_StartThingRegistrationTask_596374; body: JsonNode): Recallable =
  ## startThingRegistrationTask
  ## Creates a bulk thing provisioning task.
  ##   body: JObject (required)
  var body_596387 = newJObject()
  if body != nil:
    body_596387 = body
  result = call_596386.call(nil, nil, nil, nil, body_596387)

var startThingRegistrationTask* = Call_StartThingRegistrationTask_596374(
    name: "startThingRegistrationTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks",
    validator: validate_StartThingRegistrationTask_596375, base: "/",
    url: url_StartThingRegistrationTask_596376,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingRegistrationTasks_596358 = ref object of OpenApiRestCall_593437
proc url_ListThingRegistrationTasks_596360(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListThingRegistrationTasks_596359(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List bulk thing provisioning tasks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : The status of the bulk thing provisioning task.
  section = newJObject()
  var valid_596361 = query.getOrDefault("maxResults")
  valid_596361 = validateParameter(valid_596361, JInt, required = false, default = nil)
  if valid_596361 != nil:
    section.add "maxResults", valid_596361
  var valid_596362 = query.getOrDefault("nextToken")
  valid_596362 = validateParameter(valid_596362, JString, required = false,
                                 default = nil)
  if valid_596362 != nil:
    section.add "nextToken", valid_596362
  var valid_596363 = query.getOrDefault("status")
  valid_596363 = validateParameter(valid_596363, JString, required = false,
                                 default = newJString("InProgress"))
  if valid_596363 != nil:
    section.add "status", valid_596363
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596364 = header.getOrDefault("X-Amz-Date")
  valid_596364 = validateParameter(valid_596364, JString, required = false,
                                 default = nil)
  if valid_596364 != nil:
    section.add "X-Amz-Date", valid_596364
  var valid_596365 = header.getOrDefault("X-Amz-Security-Token")
  valid_596365 = validateParameter(valid_596365, JString, required = false,
                                 default = nil)
  if valid_596365 != nil:
    section.add "X-Amz-Security-Token", valid_596365
  var valid_596366 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596366 = validateParameter(valid_596366, JString, required = false,
                                 default = nil)
  if valid_596366 != nil:
    section.add "X-Amz-Content-Sha256", valid_596366
  var valid_596367 = header.getOrDefault("X-Amz-Algorithm")
  valid_596367 = validateParameter(valid_596367, JString, required = false,
                                 default = nil)
  if valid_596367 != nil:
    section.add "X-Amz-Algorithm", valid_596367
  var valid_596368 = header.getOrDefault("X-Amz-Signature")
  valid_596368 = validateParameter(valid_596368, JString, required = false,
                                 default = nil)
  if valid_596368 != nil:
    section.add "X-Amz-Signature", valid_596368
  var valid_596369 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596369 = validateParameter(valid_596369, JString, required = false,
                                 default = nil)
  if valid_596369 != nil:
    section.add "X-Amz-SignedHeaders", valid_596369
  var valid_596370 = header.getOrDefault("X-Amz-Credential")
  valid_596370 = validateParameter(valid_596370, JString, required = false,
                                 default = nil)
  if valid_596370 != nil:
    section.add "X-Amz-Credential", valid_596370
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596371: Call_ListThingRegistrationTasks_596358; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List bulk thing provisioning tasks.
  ## 
  let valid = call_596371.validator(path, query, header, formData, body)
  let scheme = call_596371.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596371.url(scheme.get, call_596371.host, call_596371.base,
                         call_596371.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596371, url, valid)

proc call*(call_596372: Call_ListThingRegistrationTasks_596358;
          maxResults: int = 0; nextToken: string = ""; status: string = "InProgress"): Recallable =
  ## listThingRegistrationTasks
  ## List bulk thing provisioning tasks.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : The status of the bulk thing provisioning task.
  var query_596373 = newJObject()
  add(query_596373, "maxResults", newJInt(maxResults))
  add(query_596373, "nextToken", newJString(nextToken))
  add(query_596373, "status", newJString(status))
  result = call_596372.call(nil, query_596373, nil, nil, nil)

var listThingRegistrationTasks* = Call_ListThingRegistrationTasks_596358(
    name: "listThingRegistrationTasks", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks",
    validator: validate_ListThingRegistrationTasks_596359, base: "/",
    url: url_ListThingRegistrationTasks_596360,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingTypes_596388 = ref object of OpenApiRestCall_593437
proc url_ListThingTypes_596390(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListThingTypes_596389(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the existing thing types.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingTypeName: JString
  ##                : The name of the thing type.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  var valid_596391 = query.getOrDefault("thingTypeName")
  valid_596391 = validateParameter(valid_596391, JString, required = false,
                                 default = nil)
  if valid_596391 != nil:
    section.add "thingTypeName", valid_596391
  var valid_596392 = query.getOrDefault("maxResults")
  valid_596392 = validateParameter(valid_596392, JInt, required = false, default = nil)
  if valid_596392 != nil:
    section.add "maxResults", valid_596392
  var valid_596393 = query.getOrDefault("nextToken")
  valid_596393 = validateParameter(valid_596393, JString, required = false,
                                 default = nil)
  if valid_596393 != nil:
    section.add "nextToken", valid_596393
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596394 = header.getOrDefault("X-Amz-Date")
  valid_596394 = validateParameter(valid_596394, JString, required = false,
                                 default = nil)
  if valid_596394 != nil:
    section.add "X-Amz-Date", valid_596394
  var valid_596395 = header.getOrDefault("X-Amz-Security-Token")
  valid_596395 = validateParameter(valid_596395, JString, required = false,
                                 default = nil)
  if valid_596395 != nil:
    section.add "X-Amz-Security-Token", valid_596395
  var valid_596396 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596396 = validateParameter(valid_596396, JString, required = false,
                                 default = nil)
  if valid_596396 != nil:
    section.add "X-Amz-Content-Sha256", valid_596396
  var valid_596397 = header.getOrDefault("X-Amz-Algorithm")
  valid_596397 = validateParameter(valid_596397, JString, required = false,
                                 default = nil)
  if valid_596397 != nil:
    section.add "X-Amz-Algorithm", valid_596397
  var valid_596398 = header.getOrDefault("X-Amz-Signature")
  valid_596398 = validateParameter(valid_596398, JString, required = false,
                                 default = nil)
  if valid_596398 != nil:
    section.add "X-Amz-Signature", valid_596398
  var valid_596399 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596399 = validateParameter(valid_596399, JString, required = false,
                                 default = nil)
  if valid_596399 != nil:
    section.add "X-Amz-SignedHeaders", valid_596399
  var valid_596400 = header.getOrDefault("X-Amz-Credential")
  valid_596400 = validateParameter(valid_596400, JString, required = false,
                                 default = nil)
  if valid_596400 != nil:
    section.add "X-Amz-Credential", valid_596400
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596401: Call_ListThingTypes_596388; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the existing thing types.
  ## 
  let valid = call_596401.validator(path, query, header, formData, body)
  let scheme = call_596401.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596401.url(scheme.get, call_596401.host, call_596401.base,
                         call_596401.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596401, url, valid)

proc call*(call_596402: Call_ListThingTypes_596388; thingTypeName: string = "";
          maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listThingTypes
  ## Lists the existing thing types.
  ##   thingTypeName: string
  ##                : The name of the thing type.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var query_596403 = newJObject()
  add(query_596403, "thingTypeName", newJString(thingTypeName))
  add(query_596403, "maxResults", newJInt(maxResults))
  add(query_596403, "nextToken", newJString(nextToken))
  result = call_596402.call(nil, query_596403, nil, nil, nil)

var listThingTypes* = Call_ListThingTypes_596388(name: "listThingTypes",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/thing-types",
    validator: validate_ListThingTypes_596389, base: "/", url: url_ListThingTypes_596390,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterThing_596422 = ref object of OpenApiRestCall_593437
proc url_RegisterThing_596424(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RegisterThing_596423(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Provisions a thing.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596425 = header.getOrDefault("X-Amz-Date")
  valid_596425 = validateParameter(valid_596425, JString, required = false,
                                 default = nil)
  if valid_596425 != nil:
    section.add "X-Amz-Date", valid_596425
  var valid_596426 = header.getOrDefault("X-Amz-Security-Token")
  valid_596426 = validateParameter(valid_596426, JString, required = false,
                                 default = nil)
  if valid_596426 != nil:
    section.add "X-Amz-Security-Token", valid_596426
  var valid_596427 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596427 = validateParameter(valid_596427, JString, required = false,
                                 default = nil)
  if valid_596427 != nil:
    section.add "X-Amz-Content-Sha256", valid_596427
  var valid_596428 = header.getOrDefault("X-Amz-Algorithm")
  valid_596428 = validateParameter(valid_596428, JString, required = false,
                                 default = nil)
  if valid_596428 != nil:
    section.add "X-Amz-Algorithm", valid_596428
  var valid_596429 = header.getOrDefault("X-Amz-Signature")
  valid_596429 = validateParameter(valid_596429, JString, required = false,
                                 default = nil)
  if valid_596429 != nil:
    section.add "X-Amz-Signature", valid_596429
  var valid_596430 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596430 = validateParameter(valid_596430, JString, required = false,
                                 default = nil)
  if valid_596430 != nil:
    section.add "X-Amz-SignedHeaders", valid_596430
  var valid_596431 = header.getOrDefault("X-Amz-Credential")
  valid_596431 = validateParameter(valid_596431, JString, required = false,
                                 default = nil)
  if valid_596431 != nil:
    section.add "X-Amz-Credential", valid_596431
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596433: Call_RegisterThing_596422; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Provisions a thing.
  ## 
  let valid = call_596433.validator(path, query, header, formData, body)
  let scheme = call_596433.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596433.url(scheme.get, call_596433.host, call_596433.base,
                         call_596433.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596433, url, valid)

proc call*(call_596434: Call_RegisterThing_596422; body: JsonNode): Recallable =
  ## registerThing
  ## Provisions a thing.
  ##   body: JObject (required)
  var body_596435 = newJObject()
  if body != nil:
    body_596435 = body
  result = call_596434.call(nil, nil, nil, nil, body_596435)

var registerThing* = Call_RegisterThing_596422(name: "registerThing",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/things",
    validator: validate_RegisterThing_596423, base: "/", url: url_RegisterThing_596424,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThings_596404 = ref object of OpenApiRestCall_593437
proc url_ListThings_596406(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListThings_596405(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingTypeName: JString
  ##                : The name of the thing type used to search for things.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   attributeValue: JString
  ##                 : The attribute value used to search for things.
  ##   attributeName: JString
  ##                : The attribute name used to search for things.
  section = newJObject()
  var valid_596407 = query.getOrDefault("thingTypeName")
  valid_596407 = validateParameter(valid_596407, JString, required = false,
                                 default = nil)
  if valid_596407 != nil:
    section.add "thingTypeName", valid_596407
  var valid_596408 = query.getOrDefault("maxResults")
  valid_596408 = validateParameter(valid_596408, JInt, required = false, default = nil)
  if valid_596408 != nil:
    section.add "maxResults", valid_596408
  var valid_596409 = query.getOrDefault("nextToken")
  valid_596409 = validateParameter(valid_596409, JString, required = false,
                                 default = nil)
  if valid_596409 != nil:
    section.add "nextToken", valid_596409
  var valid_596410 = query.getOrDefault("attributeValue")
  valid_596410 = validateParameter(valid_596410, JString, required = false,
                                 default = nil)
  if valid_596410 != nil:
    section.add "attributeValue", valid_596410
  var valid_596411 = query.getOrDefault("attributeName")
  valid_596411 = validateParameter(valid_596411, JString, required = false,
                                 default = nil)
  if valid_596411 != nil:
    section.add "attributeName", valid_596411
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596412 = header.getOrDefault("X-Amz-Date")
  valid_596412 = validateParameter(valid_596412, JString, required = false,
                                 default = nil)
  if valid_596412 != nil:
    section.add "X-Amz-Date", valid_596412
  var valid_596413 = header.getOrDefault("X-Amz-Security-Token")
  valid_596413 = validateParameter(valid_596413, JString, required = false,
                                 default = nil)
  if valid_596413 != nil:
    section.add "X-Amz-Security-Token", valid_596413
  var valid_596414 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596414 = validateParameter(valid_596414, JString, required = false,
                                 default = nil)
  if valid_596414 != nil:
    section.add "X-Amz-Content-Sha256", valid_596414
  var valid_596415 = header.getOrDefault("X-Amz-Algorithm")
  valid_596415 = validateParameter(valid_596415, JString, required = false,
                                 default = nil)
  if valid_596415 != nil:
    section.add "X-Amz-Algorithm", valid_596415
  var valid_596416 = header.getOrDefault("X-Amz-Signature")
  valid_596416 = validateParameter(valid_596416, JString, required = false,
                                 default = nil)
  if valid_596416 != nil:
    section.add "X-Amz-Signature", valid_596416
  var valid_596417 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596417 = validateParameter(valid_596417, JString, required = false,
                                 default = nil)
  if valid_596417 != nil:
    section.add "X-Amz-SignedHeaders", valid_596417
  var valid_596418 = header.getOrDefault("X-Amz-Credential")
  valid_596418 = validateParameter(valid_596418, JString, required = false,
                                 default = nil)
  if valid_596418 != nil:
    section.add "X-Amz-Credential", valid_596418
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596419: Call_ListThings_596404; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ## 
  let valid = call_596419.validator(path, query, header, formData, body)
  let scheme = call_596419.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596419.url(scheme.get, call_596419.host, call_596419.base,
                         call_596419.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596419, url, valid)

proc call*(call_596420: Call_ListThings_596404; thingTypeName: string = "";
          maxResults: int = 0; nextToken: string = ""; attributeValue: string = "";
          attributeName: string = ""): Recallable =
  ## listThings
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ##   thingTypeName: string
  ##                : The name of the thing type used to search for things.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   attributeValue: string
  ##                 : The attribute value used to search for things.
  ##   attributeName: string
  ##                : The attribute name used to search for things.
  var query_596421 = newJObject()
  add(query_596421, "thingTypeName", newJString(thingTypeName))
  add(query_596421, "maxResults", newJInt(maxResults))
  add(query_596421, "nextToken", newJString(nextToken))
  add(query_596421, "attributeValue", newJString(attributeValue))
  add(query_596421, "attributeName", newJString(attributeName))
  result = call_596420.call(nil, query_596421, nil, nil, nil)

var listThings* = Call_ListThings_596404(name: "listThings",
                                      meth: HttpMethod.HttpGet,
                                      host: "iot.amazonaws.com", route: "/things",
                                      validator: validate_ListThings_596405,
                                      base: "/", url: url_ListThings_596406,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingsInBillingGroup_596436 = ref object of OpenApiRestCall_593437
proc url_ListThingsInBillingGroup_596438(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListThingsInBillingGroup_596437(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the things you have added to the given billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_596439 = path.getOrDefault("billingGroupName")
  valid_596439 = validateParameter(valid_596439, JString, required = true,
                                 default = nil)
  if valid_596439 != nil:
    section.add "billingGroupName", valid_596439
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  var valid_596440 = query.getOrDefault("maxResults")
  valid_596440 = validateParameter(valid_596440, JInt, required = false, default = nil)
  if valid_596440 != nil:
    section.add "maxResults", valid_596440
  var valid_596441 = query.getOrDefault("nextToken")
  valid_596441 = validateParameter(valid_596441, JString, required = false,
                                 default = nil)
  if valid_596441 != nil:
    section.add "nextToken", valid_596441
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596442 = header.getOrDefault("X-Amz-Date")
  valid_596442 = validateParameter(valid_596442, JString, required = false,
                                 default = nil)
  if valid_596442 != nil:
    section.add "X-Amz-Date", valid_596442
  var valid_596443 = header.getOrDefault("X-Amz-Security-Token")
  valid_596443 = validateParameter(valid_596443, JString, required = false,
                                 default = nil)
  if valid_596443 != nil:
    section.add "X-Amz-Security-Token", valid_596443
  var valid_596444 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596444 = validateParameter(valid_596444, JString, required = false,
                                 default = nil)
  if valid_596444 != nil:
    section.add "X-Amz-Content-Sha256", valid_596444
  var valid_596445 = header.getOrDefault("X-Amz-Algorithm")
  valid_596445 = validateParameter(valid_596445, JString, required = false,
                                 default = nil)
  if valid_596445 != nil:
    section.add "X-Amz-Algorithm", valid_596445
  var valid_596446 = header.getOrDefault("X-Amz-Signature")
  valid_596446 = validateParameter(valid_596446, JString, required = false,
                                 default = nil)
  if valid_596446 != nil:
    section.add "X-Amz-Signature", valid_596446
  var valid_596447 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596447 = validateParameter(valid_596447, JString, required = false,
                                 default = nil)
  if valid_596447 != nil:
    section.add "X-Amz-SignedHeaders", valid_596447
  var valid_596448 = header.getOrDefault("X-Amz-Credential")
  valid_596448 = validateParameter(valid_596448, JString, required = false,
                                 default = nil)
  if valid_596448 != nil:
    section.add "X-Amz-Credential", valid_596448
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596449: Call_ListThingsInBillingGroup_596436; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things you have added to the given billing group.
  ## 
  let valid = call_596449.validator(path, query, header, formData, body)
  let scheme = call_596449.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596449.url(scheme.get, call_596449.host, call_596449.base,
                         call_596449.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596449, url, valid)

proc call*(call_596450: Call_ListThingsInBillingGroup_596436;
          billingGroupName: string; maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listThingsInBillingGroup
  ## Lists the things you have added to the given billing group.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var path_596451 = newJObject()
  var query_596452 = newJObject()
  add(path_596451, "billingGroupName", newJString(billingGroupName))
  add(query_596452, "maxResults", newJInt(maxResults))
  add(query_596452, "nextToken", newJString(nextToken))
  result = call_596450.call(path_596451, query_596452, nil, nil, nil)

var listThingsInBillingGroup* = Call_ListThingsInBillingGroup_596436(
    name: "listThingsInBillingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}/things",
    validator: validate_ListThingsInBillingGroup_596437, base: "/",
    url: url_ListThingsInBillingGroup_596438, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingsInThingGroup_596453 = ref object of OpenApiRestCall_593437
proc url_ListThingsInThingGroup_596455(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListThingsInThingGroup_596454(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the things in the specified group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_596456 = path.getOrDefault("thingGroupName")
  valid_596456 = validateParameter(valid_596456, JString, required = true,
                                 default = nil)
  if valid_596456 != nil:
    section.add "thingGroupName", valid_596456
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   recursive: JBool
  ##            : When true, list things in this thing group and in all child groups as well.
  section = newJObject()
  var valid_596457 = query.getOrDefault("maxResults")
  valid_596457 = validateParameter(valid_596457, JInt, required = false, default = nil)
  if valid_596457 != nil:
    section.add "maxResults", valid_596457
  var valid_596458 = query.getOrDefault("nextToken")
  valid_596458 = validateParameter(valid_596458, JString, required = false,
                                 default = nil)
  if valid_596458 != nil:
    section.add "nextToken", valid_596458
  var valid_596459 = query.getOrDefault("recursive")
  valid_596459 = validateParameter(valid_596459, JBool, required = false, default = nil)
  if valid_596459 != nil:
    section.add "recursive", valid_596459
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596460 = header.getOrDefault("X-Amz-Date")
  valid_596460 = validateParameter(valid_596460, JString, required = false,
                                 default = nil)
  if valid_596460 != nil:
    section.add "X-Amz-Date", valid_596460
  var valid_596461 = header.getOrDefault("X-Amz-Security-Token")
  valid_596461 = validateParameter(valid_596461, JString, required = false,
                                 default = nil)
  if valid_596461 != nil:
    section.add "X-Amz-Security-Token", valid_596461
  var valid_596462 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596462 = validateParameter(valid_596462, JString, required = false,
                                 default = nil)
  if valid_596462 != nil:
    section.add "X-Amz-Content-Sha256", valid_596462
  var valid_596463 = header.getOrDefault("X-Amz-Algorithm")
  valid_596463 = validateParameter(valid_596463, JString, required = false,
                                 default = nil)
  if valid_596463 != nil:
    section.add "X-Amz-Algorithm", valid_596463
  var valid_596464 = header.getOrDefault("X-Amz-Signature")
  valid_596464 = validateParameter(valid_596464, JString, required = false,
                                 default = nil)
  if valid_596464 != nil:
    section.add "X-Amz-Signature", valid_596464
  var valid_596465 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596465 = validateParameter(valid_596465, JString, required = false,
                                 default = nil)
  if valid_596465 != nil:
    section.add "X-Amz-SignedHeaders", valid_596465
  var valid_596466 = header.getOrDefault("X-Amz-Credential")
  valid_596466 = validateParameter(valid_596466, JString, required = false,
                                 default = nil)
  if valid_596466 != nil:
    section.add "X-Amz-Credential", valid_596466
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596467: Call_ListThingsInThingGroup_596453; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things in the specified group.
  ## 
  let valid = call_596467.validator(path, query, header, formData, body)
  let scheme = call_596467.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596467.url(scheme.get, call_596467.host, call_596467.base,
                         call_596467.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596467, url, valid)

proc call*(call_596468: Call_ListThingsInThingGroup_596453; thingGroupName: string;
          maxResults: int = 0; nextToken: string = ""; recursive: bool = false): Recallable =
  ## listThingsInThingGroup
  ## Lists the things in the specified group.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: string (required)
  ##                 : The thing group name.
  ##   recursive: bool
  ##            : When true, list things in this thing group and in all child groups as well.
  var path_596469 = newJObject()
  var query_596470 = newJObject()
  add(query_596470, "maxResults", newJInt(maxResults))
  add(query_596470, "nextToken", newJString(nextToken))
  add(path_596469, "thingGroupName", newJString(thingGroupName))
  add(query_596470, "recursive", newJBool(recursive))
  result = call_596468.call(path_596469, query_596470, nil, nil, nil)

var listThingsInThingGroup* = Call_ListThingsInThingGroup_596453(
    name: "listThingsInThingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-groups/{thingGroupName}/things",
    validator: validate_ListThingsInThingGroup_596454, base: "/",
    url: url_ListThingsInThingGroup_596455, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTopicRules_596471 = ref object of OpenApiRestCall_593437
proc url_ListTopicRules_596473(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListTopicRules_596472(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the rules for the specific topic.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return.
  ##   nextToken: JString
  ##            : A token used to retrieve the next value.
  ##   topic: JString
  ##        : The topic.
  ##   ruleDisabled: JBool
  ##               : Specifies whether the rule is disabled.
  section = newJObject()
  var valid_596474 = query.getOrDefault("maxResults")
  valid_596474 = validateParameter(valid_596474, JInt, required = false, default = nil)
  if valid_596474 != nil:
    section.add "maxResults", valid_596474
  var valid_596475 = query.getOrDefault("nextToken")
  valid_596475 = validateParameter(valid_596475, JString, required = false,
                                 default = nil)
  if valid_596475 != nil:
    section.add "nextToken", valid_596475
  var valid_596476 = query.getOrDefault("topic")
  valid_596476 = validateParameter(valid_596476, JString, required = false,
                                 default = nil)
  if valid_596476 != nil:
    section.add "topic", valid_596476
  var valid_596477 = query.getOrDefault("ruleDisabled")
  valid_596477 = validateParameter(valid_596477, JBool, required = false, default = nil)
  if valid_596477 != nil:
    section.add "ruleDisabled", valid_596477
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596478 = header.getOrDefault("X-Amz-Date")
  valid_596478 = validateParameter(valid_596478, JString, required = false,
                                 default = nil)
  if valid_596478 != nil:
    section.add "X-Amz-Date", valid_596478
  var valid_596479 = header.getOrDefault("X-Amz-Security-Token")
  valid_596479 = validateParameter(valid_596479, JString, required = false,
                                 default = nil)
  if valid_596479 != nil:
    section.add "X-Amz-Security-Token", valid_596479
  var valid_596480 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596480 = validateParameter(valid_596480, JString, required = false,
                                 default = nil)
  if valid_596480 != nil:
    section.add "X-Amz-Content-Sha256", valid_596480
  var valid_596481 = header.getOrDefault("X-Amz-Algorithm")
  valid_596481 = validateParameter(valid_596481, JString, required = false,
                                 default = nil)
  if valid_596481 != nil:
    section.add "X-Amz-Algorithm", valid_596481
  var valid_596482 = header.getOrDefault("X-Amz-Signature")
  valid_596482 = validateParameter(valid_596482, JString, required = false,
                                 default = nil)
  if valid_596482 != nil:
    section.add "X-Amz-Signature", valid_596482
  var valid_596483 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596483 = validateParameter(valid_596483, JString, required = false,
                                 default = nil)
  if valid_596483 != nil:
    section.add "X-Amz-SignedHeaders", valid_596483
  var valid_596484 = header.getOrDefault("X-Amz-Credential")
  valid_596484 = validateParameter(valid_596484, JString, required = false,
                                 default = nil)
  if valid_596484 != nil:
    section.add "X-Amz-Credential", valid_596484
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596485: Call_ListTopicRules_596471; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the rules for the specific topic.
  ## 
  let valid = call_596485.validator(path, query, header, formData, body)
  let scheme = call_596485.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596485.url(scheme.get, call_596485.host, call_596485.base,
                         call_596485.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596485, url, valid)

proc call*(call_596486: Call_ListTopicRules_596471; maxResults: int = 0;
          nextToken: string = ""; topic: string = ""; ruleDisabled: bool = false): Recallable =
  ## listTopicRules
  ## Lists the rules for the specific topic.
  ##   maxResults: int
  ##             : The maximum number of results to return.
  ##   nextToken: string
  ##            : A token used to retrieve the next value.
  ##   topic: string
  ##        : The topic.
  ##   ruleDisabled: bool
  ##               : Specifies whether the rule is disabled.
  var query_596487 = newJObject()
  add(query_596487, "maxResults", newJInt(maxResults))
  add(query_596487, "nextToken", newJString(nextToken))
  add(query_596487, "topic", newJString(topic))
  add(query_596487, "ruleDisabled", newJBool(ruleDisabled))
  result = call_596486.call(nil, query_596487, nil, nil, nil)

var listTopicRules* = Call_ListTopicRules_596471(name: "listTopicRules",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/rules",
    validator: validate_ListTopicRules_596472, base: "/", url: url_ListTopicRules_596473,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetV2LoggingLevel_596504 = ref object of OpenApiRestCall_593437
proc url_SetV2LoggingLevel_596506(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_SetV2LoggingLevel_596505(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Sets the logging level.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596507 = header.getOrDefault("X-Amz-Date")
  valid_596507 = validateParameter(valid_596507, JString, required = false,
                                 default = nil)
  if valid_596507 != nil:
    section.add "X-Amz-Date", valid_596507
  var valid_596508 = header.getOrDefault("X-Amz-Security-Token")
  valid_596508 = validateParameter(valid_596508, JString, required = false,
                                 default = nil)
  if valid_596508 != nil:
    section.add "X-Amz-Security-Token", valid_596508
  var valid_596509 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596509 = validateParameter(valid_596509, JString, required = false,
                                 default = nil)
  if valid_596509 != nil:
    section.add "X-Amz-Content-Sha256", valid_596509
  var valid_596510 = header.getOrDefault("X-Amz-Algorithm")
  valid_596510 = validateParameter(valid_596510, JString, required = false,
                                 default = nil)
  if valid_596510 != nil:
    section.add "X-Amz-Algorithm", valid_596510
  var valid_596511 = header.getOrDefault("X-Amz-Signature")
  valid_596511 = validateParameter(valid_596511, JString, required = false,
                                 default = nil)
  if valid_596511 != nil:
    section.add "X-Amz-Signature", valid_596511
  var valid_596512 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596512 = validateParameter(valid_596512, JString, required = false,
                                 default = nil)
  if valid_596512 != nil:
    section.add "X-Amz-SignedHeaders", valid_596512
  var valid_596513 = header.getOrDefault("X-Amz-Credential")
  valid_596513 = validateParameter(valid_596513, JString, required = false,
                                 default = nil)
  if valid_596513 != nil:
    section.add "X-Amz-Credential", valid_596513
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596515: Call_SetV2LoggingLevel_596504; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the logging level.
  ## 
  let valid = call_596515.validator(path, query, header, formData, body)
  let scheme = call_596515.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596515.url(scheme.get, call_596515.host, call_596515.base,
                         call_596515.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596515, url, valid)

proc call*(call_596516: Call_SetV2LoggingLevel_596504; body: JsonNode): Recallable =
  ## setV2LoggingLevel
  ## Sets the logging level.
  ##   body: JObject (required)
  var body_596517 = newJObject()
  if body != nil:
    body_596517 = body
  result = call_596516.call(nil, nil, nil, nil, body_596517)

var setV2LoggingLevel* = Call_SetV2LoggingLevel_596504(name: "setV2LoggingLevel",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/v2LoggingLevel",
    validator: validate_SetV2LoggingLevel_596505, base: "/",
    url: url_SetV2LoggingLevel_596506, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListV2LoggingLevels_596488 = ref object of OpenApiRestCall_593437
proc url_ListV2LoggingLevels_596490(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListV2LoggingLevels_596489(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists logging levels.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   targetType: JString
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token used to get the next set of results, or <b>null</b> if there are no additional results.
  section = newJObject()
  var valid_596491 = query.getOrDefault("targetType")
  valid_596491 = validateParameter(valid_596491, JString, required = false,
                                 default = newJString("DEFAULT"))
  if valid_596491 != nil:
    section.add "targetType", valid_596491
  var valid_596492 = query.getOrDefault("maxResults")
  valid_596492 = validateParameter(valid_596492, JInt, required = false, default = nil)
  if valid_596492 != nil:
    section.add "maxResults", valid_596492
  var valid_596493 = query.getOrDefault("nextToken")
  valid_596493 = validateParameter(valid_596493, JString, required = false,
                                 default = nil)
  if valid_596493 != nil:
    section.add "nextToken", valid_596493
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596494 = header.getOrDefault("X-Amz-Date")
  valid_596494 = validateParameter(valid_596494, JString, required = false,
                                 default = nil)
  if valid_596494 != nil:
    section.add "X-Amz-Date", valid_596494
  var valid_596495 = header.getOrDefault("X-Amz-Security-Token")
  valid_596495 = validateParameter(valid_596495, JString, required = false,
                                 default = nil)
  if valid_596495 != nil:
    section.add "X-Amz-Security-Token", valid_596495
  var valid_596496 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596496 = validateParameter(valid_596496, JString, required = false,
                                 default = nil)
  if valid_596496 != nil:
    section.add "X-Amz-Content-Sha256", valid_596496
  var valid_596497 = header.getOrDefault("X-Amz-Algorithm")
  valid_596497 = validateParameter(valid_596497, JString, required = false,
                                 default = nil)
  if valid_596497 != nil:
    section.add "X-Amz-Algorithm", valid_596497
  var valid_596498 = header.getOrDefault("X-Amz-Signature")
  valid_596498 = validateParameter(valid_596498, JString, required = false,
                                 default = nil)
  if valid_596498 != nil:
    section.add "X-Amz-Signature", valid_596498
  var valid_596499 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596499 = validateParameter(valid_596499, JString, required = false,
                                 default = nil)
  if valid_596499 != nil:
    section.add "X-Amz-SignedHeaders", valid_596499
  var valid_596500 = header.getOrDefault("X-Amz-Credential")
  valid_596500 = validateParameter(valid_596500, JString, required = false,
                                 default = nil)
  if valid_596500 != nil:
    section.add "X-Amz-Credential", valid_596500
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596501: Call_ListV2LoggingLevels_596488; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists logging levels.
  ## 
  let valid = call_596501.validator(path, query, header, formData, body)
  let scheme = call_596501.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596501.url(scheme.get, call_596501.host, call_596501.base,
                         call_596501.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596501, url, valid)

proc call*(call_596502: Call_ListV2LoggingLevels_596488;
          targetType: string = "DEFAULT"; maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listV2LoggingLevels
  ## Lists logging levels.
  ##   targetType: string
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token used to get the next set of results, or <b>null</b> if there are no additional results.
  var query_596503 = newJObject()
  add(query_596503, "targetType", newJString(targetType))
  add(query_596503, "maxResults", newJInt(maxResults))
  add(query_596503, "nextToken", newJString(nextToken))
  result = call_596502.call(nil, query_596503, nil, nil, nil)

var listV2LoggingLevels* = Call_ListV2LoggingLevels_596488(
    name: "listV2LoggingLevels", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/v2LoggingLevel",
    validator: validate_ListV2LoggingLevels_596489, base: "/",
    url: url_ListV2LoggingLevels_596490, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListViolationEvents_596518 = ref object of OpenApiRestCall_593437
proc url_ListViolationEvents_596520(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListViolationEvents_596519(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingName: JString
  ##            : A filter to limit results to those alerts caused by the specified thing.
  ##   endTime: JString (required)
  ##          : The end time for the alerts to be listed.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   securityProfileName: JString
  ##                      : A filter to limit results to those alerts generated by the specified security profile.
  ##   startTime: JString (required)
  ##            : The start time for the alerts to be listed.
  section = newJObject()
  var valid_596521 = query.getOrDefault("thingName")
  valid_596521 = validateParameter(valid_596521, JString, required = false,
                                 default = nil)
  if valid_596521 != nil:
    section.add "thingName", valid_596521
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_596522 = query.getOrDefault("endTime")
  valid_596522 = validateParameter(valid_596522, JString, required = true,
                                 default = nil)
  if valid_596522 != nil:
    section.add "endTime", valid_596522
  var valid_596523 = query.getOrDefault("maxResults")
  valid_596523 = validateParameter(valid_596523, JInt, required = false, default = nil)
  if valid_596523 != nil:
    section.add "maxResults", valid_596523
  var valid_596524 = query.getOrDefault("nextToken")
  valid_596524 = validateParameter(valid_596524, JString, required = false,
                                 default = nil)
  if valid_596524 != nil:
    section.add "nextToken", valid_596524
  var valid_596525 = query.getOrDefault("securityProfileName")
  valid_596525 = validateParameter(valid_596525, JString, required = false,
                                 default = nil)
  if valid_596525 != nil:
    section.add "securityProfileName", valid_596525
  var valid_596526 = query.getOrDefault("startTime")
  valid_596526 = validateParameter(valid_596526, JString, required = true,
                                 default = nil)
  if valid_596526 != nil:
    section.add "startTime", valid_596526
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596527 = header.getOrDefault("X-Amz-Date")
  valid_596527 = validateParameter(valid_596527, JString, required = false,
                                 default = nil)
  if valid_596527 != nil:
    section.add "X-Amz-Date", valid_596527
  var valid_596528 = header.getOrDefault("X-Amz-Security-Token")
  valid_596528 = validateParameter(valid_596528, JString, required = false,
                                 default = nil)
  if valid_596528 != nil:
    section.add "X-Amz-Security-Token", valid_596528
  var valid_596529 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596529 = validateParameter(valid_596529, JString, required = false,
                                 default = nil)
  if valid_596529 != nil:
    section.add "X-Amz-Content-Sha256", valid_596529
  var valid_596530 = header.getOrDefault("X-Amz-Algorithm")
  valid_596530 = validateParameter(valid_596530, JString, required = false,
                                 default = nil)
  if valid_596530 != nil:
    section.add "X-Amz-Algorithm", valid_596530
  var valid_596531 = header.getOrDefault("X-Amz-Signature")
  valid_596531 = validateParameter(valid_596531, JString, required = false,
                                 default = nil)
  if valid_596531 != nil:
    section.add "X-Amz-Signature", valid_596531
  var valid_596532 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596532 = validateParameter(valid_596532, JString, required = false,
                                 default = nil)
  if valid_596532 != nil:
    section.add "X-Amz-SignedHeaders", valid_596532
  var valid_596533 = header.getOrDefault("X-Amz-Credential")
  valid_596533 = validateParameter(valid_596533, JString, required = false,
                                 default = nil)
  if valid_596533 != nil:
    section.add "X-Amz-Credential", valid_596533
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596534: Call_ListViolationEvents_596518; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ## 
  let valid = call_596534.validator(path, query, header, formData, body)
  let scheme = call_596534.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596534.url(scheme.get, call_596534.host, call_596534.base,
                         call_596534.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596534, url, valid)

proc call*(call_596535: Call_ListViolationEvents_596518; endTime: string;
          startTime: string; thingName: string = ""; maxResults: int = 0;
          nextToken: string = ""; securityProfileName: string = ""): Recallable =
  ## listViolationEvents
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ##   thingName: string
  ##            : A filter to limit results to those alerts caused by the specified thing.
  ##   endTime: string (required)
  ##          : The end time for the alerts to be listed.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string
  ##                      : A filter to limit results to those alerts generated by the specified security profile.
  ##   startTime: string (required)
  ##            : The start time for the alerts to be listed.
  var query_596536 = newJObject()
  add(query_596536, "thingName", newJString(thingName))
  add(query_596536, "endTime", newJString(endTime))
  add(query_596536, "maxResults", newJInt(maxResults))
  add(query_596536, "nextToken", newJString(nextToken))
  add(query_596536, "securityProfileName", newJString(securityProfileName))
  add(query_596536, "startTime", newJString(startTime))
  result = call_596535.call(nil, query_596536, nil, nil, nil)

var listViolationEvents* = Call_ListViolationEvents_596518(
    name: "listViolationEvents", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/violation-events#startTime&endTime",
    validator: validate_ListViolationEvents_596519, base: "/",
    url: url_ListViolationEvents_596520, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterCACertificate_596537 = ref object of OpenApiRestCall_593437
proc url_RegisterCACertificate_596539(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RegisterCACertificate_596538(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : A boolean value that specifies if the CA certificate is set to active.
  ##   allowAutoRegistration: JBool
  ##                        : Allows this CA certificate to be used for auto registration of device certificates.
  section = newJObject()
  var valid_596540 = query.getOrDefault("setAsActive")
  valid_596540 = validateParameter(valid_596540, JBool, required = false, default = nil)
  if valid_596540 != nil:
    section.add "setAsActive", valid_596540
  var valid_596541 = query.getOrDefault("allowAutoRegistration")
  valid_596541 = validateParameter(valid_596541, JBool, required = false, default = nil)
  if valid_596541 != nil:
    section.add "allowAutoRegistration", valid_596541
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596542 = header.getOrDefault("X-Amz-Date")
  valid_596542 = validateParameter(valid_596542, JString, required = false,
                                 default = nil)
  if valid_596542 != nil:
    section.add "X-Amz-Date", valid_596542
  var valid_596543 = header.getOrDefault("X-Amz-Security-Token")
  valid_596543 = validateParameter(valid_596543, JString, required = false,
                                 default = nil)
  if valid_596543 != nil:
    section.add "X-Amz-Security-Token", valid_596543
  var valid_596544 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596544 = validateParameter(valid_596544, JString, required = false,
                                 default = nil)
  if valid_596544 != nil:
    section.add "X-Amz-Content-Sha256", valid_596544
  var valid_596545 = header.getOrDefault("X-Amz-Algorithm")
  valid_596545 = validateParameter(valid_596545, JString, required = false,
                                 default = nil)
  if valid_596545 != nil:
    section.add "X-Amz-Algorithm", valid_596545
  var valid_596546 = header.getOrDefault("X-Amz-Signature")
  valid_596546 = validateParameter(valid_596546, JString, required = false,
                                 default = nil)
  if valid_596546 != nil:
    section.add "X-Amz-Signature", valid_596546
  var valid_596547 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596547 = validateParameter(valid_596547, JString, required = false,
                                 default = nil)
  if valid_596547 != nil:
    section.add "X-Amz-SignedHeaders", valid_596547
  var valid_596548 = header.getOrDefault("X-Amz-Credential")
  valid_596548 = validateParameter(valid_596548, JString, required = false,
                                 default = nil)
  if valid_596548 != nil:
    section.add "X-Amz-Credential", valid_596548
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596550: Call_RegisterCACertificate_596537; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ## 
  let valid = call_596550.validator(path, query, header, formData, body)
  let scheme = call_596550.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596550.url(scheme.get, call_596550.host, call_596550.base,
                         call_596550.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596550, url, valid)

proc call*(call_596551: Call_RegisterCACertificate_596537; body: JsonNode;
          setAsActive: bool = false; allowAutoRegistration: bool = false): Recallable =
  ## registerCACertificate
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ##   setAsActive: bool
  ##              : A boolean value that specifies if the CA certificate is set to active.
  ##   body: JObject (required)
  ##   allowAutoRegistration: bool
  ##                        : Allows this CA certificate to be used for auto registration of device certificates.
  var query_596552 = newJObject()
  var body_596553 = newJObject()
  add(query_596552, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_596553 = body
  add(query_596552, "allowAutoRegistration", newJBool(allowAutoRegistration))
  result = call_596551.call(nil, query_596552, nil, nil, body_596553)

var registerCACertificate* = Call_RegisterCACertificate_596537(
    name: "registerCACertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/cacertificate",
    validator: validate_RegisterCACertificate_596538, base: "/",
    url: url_RegisterCACertificate_596539, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterCertificate_596554 = ref object of OpenApiRestCall_593437
proc url_RegisterCertificate_596556(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RegisterCertificate_596555(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : A boolean value that specifies if the certificate is set to active.
  section = newJObject()
  var valid_596557 = query.getOrDefault("setAsActive")
  valid_596557 = validateParameter(valid_596557, JBool, required = false, default = nil)
  if valid_596557 != nil:
    section.add "setAsActive", valid_596557
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596558 = header.getOrDefault("X-Amz-Date")
  valid_596558 = validateParameter(valid_596558, JString, required = false,
                                 default = nil)
  if valid_596558 != nil:
    section.add "X-Amz-Date", valid_596558
  var valid_596559 = header.getOrDefault("X-Amz-Security-Token")
  valid_596559 = validateParameter(valid_596559, JString, required = false,
                                 default = nil)
  if valid_596559 != nil:
    section.add "X-Amz-Security-Token", valid_596559
  var valid_596560 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596560 = validateParameter(valid_596560, JString, required = false,
                                 default = nil)
  if valid_596560 != nil:
    section.add "X-Amz-Content-Sha256", valid_596560
  var valid_596561 = header.getOrDefault("X-Amz-Algorithm")
  valid_596561 = validateParameter(valid_596561, JString, required = false,
                                 default = nil)
  if valid_596561 != nil:
    section.add "X-Amz-Algorithm", valid_596561
  var valid_596562 = header.getOrDefault("X-Amz-Signature")
  valid_596562 = validateParameter(valid_596562, JString, required = false,
                                 default = nil)
  if valid_596562 != nil:
    section.add "X-Amz-Signature", valid_596562
  var valid_596563 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596563 = validateParameter(valid_596563, JString, required = false,
                                 default = nil)
  if valid_596563 != nil:
    section.add "X-Amz-SignedHeaders", valid_596563
  var valid_596564 = header.getOrDefault("X-Amz-Credential")
  valid_596564 = validateParameter(valid_596564, JString, required = false,
                                 default = nil)
  if valid_596564 != nil:
    section.add "X-Amz-Credential", valid_596564
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596566: Call_RegisterCertificate_596554; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ## 
  let valid = call_596566.validator(path, query, header, formData, body)
  let scheme = call_596566.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596566.url(scheme.get, call_596566.host, call_596566.base,
                         call_596566.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596566, url, valid)

proc call*(call_596567: Call_RegisterCertificate_596554; body: JsonNode;
          setAsActive: bool = false): Recallable =
  ## registerCertificate
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ##   setAsActive: bool
  ##              : A boolean value that specifies if the certificate is set to active.
  ##   body: JObject (required)
  var query_596568 = newJObject()
  var body_596569 = newJObject()
  add(query_596568, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_596569 = body
  result = call_596567.call(nil, query_596568, nil, nil, body_596569)

var registerCertificate* = Call_RegisterCertificate_596554(
    name: "registerCertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/certificate/register",
    validator: validate_RegisterCertificate_596555, base: "/",
    url: url_RegisterCertificate_596556, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RejectCertificateTransfer_596570 = ref object of OpenApiRestCall_593437
proc url_RejectCertificateTransfer_596572(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/reject-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RejectCertificateTransfer_596571(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_596573 = path.getOrDefault("certificateId")
  valid_596573 = validateParameter(valid_596573, JString, required = true,
                                 default = nil)
  if valid_596573 != nil:
    section.add "certificateId", valid_596573
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596574 = header.getOrDefault("X-Amz-Date")
  valid_596574 = validateParameter(valid_596574, JString, required = false,
                                 default = nil)
  if valid_596574 != nil:
    section.add "X-Amz-Date", valid_596574
  var valid_596575 = header.getOrDefault("X-Amz-Security-Token")
  valid_596575 = validateParameter(valid_596575, JString, required = false,
                                 default = nil)
  if valid_596575 != nil:
    section.add "X-Amz-Security-Token", valid_596575
  var valid_596576 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596576 = validateParameter(valid_596576, JString, required = false,
                                 default = nil)
  if valid_596576 != nil:
    section.add "X-Amz-Content-Sha256", valid_596576
  var valid_596577 = header.getOrDefault("X-Amz-Algorithm")
  valid_596577 = validateParameter(valid_596577, JString, required = false,
                                 default = nil)
  if valid_596577 != nil:
    section.add "X-Amz-Algorithm", valid_596577
  var valid_596578 = header.getOrDefault("X-Amz-Signature")
  valid_596578 = validateParameter(valid_596578, JString, required = false,
                                 default = nil)
  if valid_596578 != nil:
    section.add "X-Amz-Signature", valid_596578
  var valid_596579 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596579 = validateParameter(valid_596579, JString, required = false,
                                 default = nil)
  if valid_596579 != nil:
    section.add "X-Amz-SignedHeaders", valid_596579
  var valid_596580 = header.getOrDefault("X-Amz-Credential")
  valid_596580 = validateParameter(valid_596580, JString, required = false,
                                 default = nil)
  if valid_596580 != nil:
    section.add "X-Amz-Credential", valid_596580
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596582: Call_RejectCertificateTransfer_596570; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ## 
  let valid = call_596582.validator(path, query, header, formData, body)
  let scheme = call_596582.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596582.url(scheme.get, call_596582.host, call_596582.base,
                         call_596582.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596582, url, valid)

proc call*(call_596583: Call_RejectCertificateTransfer_596570;
          certificateId: string; body: JsonNode): Recallable =
  ## rejectCertificateTransfer
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   body: JObject (required)
  var path_596584 = newJObject()
  var body_596585 = newJObject()
  add(path_596584, "certificateId", newJString(certificateId))
  if body != nil:
    body_596585 = body
  result = call_596583.call(path_596584, nil, nil, nil, body_596585)

var rejectCertificateTransfer* = Call_RejectCertificateTransfer_596570(
    name: "rejectCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/reject-certificate-transfer/{certificateId}",
    validator: validate_RejectCertificateTransfer_596571, base: "/",
    url: url_RejectCertificateTransfer_596572,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveThingFromBillingGroup_596586 = ref object of OpenApiRestCall_593437
proc url_RemoveThingFromBillingGroup_596588(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RemoveThingFromBillingGroup_596587(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes the given thing from the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596589 = header.getOrDefault("X-Amz-Date")
  valid_596589 = validateParameter(valid_596589, JString, required = false,
                                 default = nil)
  if valid_596589 != nil:
    section.add "X-Amz-Date", valid_596589
  var valid_596590 = header.getOrDefault("X-Amz-Security-Token")
  valid_596590 = validateParameter(valid_596590, JString, required = false,
                                 default = nil)
  if valid_596590 != nil:
    section.add "X-Amz-Security-Token", valid_596590
  var valid_596591 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596591 = validateParameter(valid_596591, JString, required = false,
                                 default = nil)
  if valid_596591 != nil:
    section.add "X-Amz-Content-Sha256", valid_596591
  var valid_596592 = header.getOrDefault("X-Amz-Algorithm")
  valid_596592 = validateParameter(valid_596592, JString, required = false,
                                 default = nil)
  if valid_596592 != nil:
    section.add "X-Amz-Algorithm", valid_596592
  var valid_596593 = header.getOrDefault("X-Amz-Signature")
  valid_596593 = validateParameter(valid_596593, JString, required = false,
                                 default = nil)
  if valid_596593 != nil:
    section.add "X-Amz-Signature", valid_596593
  var valid_596594 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596594 = validateParameter(valid_596594, JString, required = false,
                                 default = nil)
  if valid_596594 != nil:
    section.add "X-Amz-SignedHeaders", valid_596594
  var valid_596595 = header.getOrDefault("X-Amz-Credential")
  valid_596595 = validateParameter(valid_596595, JString, required = false,
                                 default = nil)
  if valid_596595 != nil:
    section.add "X-Amz-Credential", valid_596595
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596597: Call_RemoveThingFromBillingGroup_596586; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes the given thing from the billing group.
  ## 
  let valid = call_596597.validator(path, query, header, formData, body)
  let scheme = call_596597.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596597.url(scheme.get, call_596597.host, call_596597.base,
                         call_596597.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596597, url, valid)

proc call*(call_596598: Call_RemoveThingFromBillingGroup_596586; body: JsonNode): Recallable =
  ## removeThingFromBillingGroup
  ## Removes the given thing from the billing group.
  ##   body: JObject (required)
  var body_596599 = newJObject()
  if body != nil:
    body_596599 = body
  result = call_596598.call(nil, nil, nil, nil, body_596599)

var removeThingFromBillingGroup* = Call_RemoveThingFromBillingGroup_596586(
    name: "removeThingFromBillingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/billing-groups/removeThingFromBillingGroup",
    validator: validate_RemoveThingFromBillingGroup_596587, base: "/",
    url: url_RemoveThingFromBillingGroup_596588,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveThingFromThingGroup_596600 = ref object of OpenApiRestCall_593437
proc url_RemoveThingFromThingGroup_596602(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RemoveThingFromThingGroup_596601(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove the specified thing from the specified group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596603 = header.getOrDefault("X-Amz-Date")
  valid_596603 = validateParameter(valid_596603, JString, required = false,
                                 default = nil)
  if valid_596603 != nil:
    section.add "X-Amz-Date", valid_596603
  var valid_596604 = header.getOrDefault("X-Amz-Security-Token")
  valid_596604 = validateParameter(valid_596604, JString, required = false,
                                 default = nil)
  if valid_596604 != nil:
    section.add "X-Amz-Security-Token", valid_596604
  var valid_596605 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596605 = validateParameter(valid_596605, JString, required = false,
                                 default = nil)
  if valid_596605 != nil:
    section.add "X-Amz-Content-Sha256", valid_596605
  var valid_596606 = header.getOrDefault("X-Amz-Algorithm")
  valid_596606 = validateParameter(valid_596606, JString, required = false,
                                 default = nil)
  if valid_596606 != nil:
    section.add "X-Amz-Algorithm", valid_596606
  var valid_596607 = header.getOrDefault("X-Amz-Signature")
  valid_596607 = validateParameter(valid_596607, JString, required = false,
                                 default = nil)
  if valid_596607 != nil:
    section.add "X-Amz-Signature", valid_596607
  var valid_596608 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596608 = validateParameter(valid_596608, JString, required = false,
                                 default = nil)
  if valid_596608 != nil:
    section.add "X-Amz-SignedHeaders", valid_596608
  var valid_596609 = header.getOrDefault("X-Amz-Credential")
  valid_596609 = validateParameter(valid_596609, JString, required = false,
                                 default = nil)
  if valid_596609 != nil:
    section.add "X-Amz-Credential", valid_596609
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596611: Call_RemoveThingFromThingGroup_596600; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Remove the specified thing from the specified group.
  ## 
  let valid = call_596611.validator(path, query, header, formData, body)
  let scheme = call_596611.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596611.url(scheme.get, call_596611.host, call_596611.base,
                         call_596611.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596611, url, valid)

proc call*(call_596612: Call_RemoveThingFromThingGroup_596600; body: JsonNode): Recallable =
  ## removeThingFromThingGroup
  ## Remove the specified thing from the specified group.
  ##   body: JObject (required)
  var body_596613 = newJObject()
  if body != nil:
    body_596613 = body
  result = call_596612.call(nil, nil, nil, nil, body_596613)

var removeThingFromThingGroup* = Call_RemoveThingFromThingGroup_596600(
    name: "removeThingFromThingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/removeThingFromThingGroup",
    validator: validate_RemoveThingFromThingGroup_596601, base: "/",
    url: url_RemoveThingFromThingGroup_596602,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_SearchIndex_596614 = ref object of OpenApiRestCall_593437
proc url_SearchIndex_596616(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_SearchIndex_596615(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## The query search index.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596617 = header.getOrDefault("X-Amz-Date")
  valid_596617 = validateParameter(valid_596617, JString, required = false,
                                 default = nil)
  if valid_596617 != nil:
    section.add "X-Amz-Date", valid_596617
  var valid_596618 = header.getOrDefault("X-Amz-Security-Token")
  valid_596618 = validateParameter(valid_596618, JString, required = false,
                                 default = nil)
  if valid_596618 != nil:
    section.add "X-Amz-Security-Token", valid_596618
  var valid_596619 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596619 = validateParameter(valid_596619, JString, required = false,
                                 default = nil)
  if valid_596619 != nil:
    section.add "X-Amz-Content-Sha256", valid_596619
  var valid_596620 = header.getOrDefault("X-Amz-Algorithm")
  valid_596620 = validateParameter(valid_596620, JString, required = false,
                                 default = nil)
  if valid_596620 != nil:
    section.add "X-Amz-Algorithm", valid_596620
  var valid_596621 = header.getOrDefault("X-Amz-Signature")
  valid_596621 = validateParameter(valid_596621, JString, required = false,
                                 default = nil)
  if valid_596621 != nil:
    section.add "X-Amz-Signature", valid_596621
  var valid_596622 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596622 = validateParameter(valid_596622, JString, required = false,
                                 default = nil)
  if valid_596622 != nil:
    section.add "X-Amz-SignedHeaders", valid_596622
  var valid_596623 = header.getOrDefault("X-Amz-Credential")
  valid_596623 = validateParameter(valid_596623, JString, required = false,
                                 default = nil)
  if valid_596623 != nil:
    section.add "X-Amz-Credential", valid_596623
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596625: Call_SearchIndex_596614; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The query search index.
  ## 
  let valid = call_596625.validator(path, query, header, formData, body)
  let scheme = call_596625.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596625.url(scheme.get, call_596625.host, call_596625.base,
                         call_596625.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596625, url, valid)

proc call*(call_596626: Call_SearchIndex_596614; body: JsonNode): Recallable =
  ## searchIndex
  ## The query search index.
  ##   body: JObject (required)
  var body_596627 = newJObject()
  if body != nil:
    body_596627 = body
  result = call_596626.call(nil, nil, nil, nil, body_596627)

var searchIndex* = Call_SearchIndex_596614(name: "searchIndex",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com",
                                        route: "/indices/search",
                                        validator: validate_SearchIndex_596615,
                                        base: "/", url: url_SearchIndex_596616,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartOnDemandAuditTask_596628 = ref object of OpenApiRestCall_593437
proc url_StartOnDemandAuditTask_596630(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_StartOnDemandAuditTask_596629(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts an on-demand Device Defender audit.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596631 = header.getOrDefault("X-Amz-Date")
  valid_596631 = validateParameter(valid_596631, JString, required = false,
                                 default = nil)
  if valid_596631 != nil:
    section.add "X-Amz-Date", valid_596631
  var valid_596632 = header.getOrDefault("X-Amz-Security-Token")
  valid_596632 = validateParameter(valid_596632, JString, required = false,
                                 default = nil)
  if valid_596632 != nil:
    section.add "X-Amz-Security-Token", valid_596632
  var valid_596633 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596633 = validateParameter(valid_596633, JString, required = false,
                                 default = nil)
  if valid_596633 != nil:
    section.add "X-Amz-Content-Sha256", valid_596633
  var valid_596634 = header.getOrDefault("X-Amz-Algorithm")
  valid_596634 = validateParameter(valid_596634, JString, required = false,
                                 default = nil)
  if valid_596634 != nil:
    section.add "X-Amz-Algorithm", valid_596634
  var valid_596635 = header.getOrDefault("X-Amz-Signature")
  valid_596635 = validateParameter(valid_596635, JString, required = false,
                                 default = nil)
  if valid_596635 != nil:
    section.add "X-Amz-Signature", valid_596635
  var valid_596636 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596636 = validateParameter(valid_596636, JString, required = false,
                                 default = nil)
  if valid_596636 != nil:
    section.add "X-Amz-SignedHeaders", valid_596636
  var valid_596637 = header.getOrDefault("X-Amz-Credential")
  valid_596637 = validateParameter(valid_596637, JString, required = false,
                                 default = nil)
  if valid_596637 != nil:
    section.add "X-Amz-Credential", valid_596637
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596639: Call_StartOnDemandAuditTask_596628; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts an on-demand Device Defender audit.
  ## 
  let valid = call_596639.validator(path, query, header, formData, body)
  let scheme = call_596639.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596639.url(scheme.get, call_596639.host, call_596639.base,
                         call_596639.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596639, url, valid)

proc call*(call_596640: Call_StartOnDemandAuditTask_596628; body: JsonNode): Recallable =
  ## startOnDemandAuditTask
  ## Starts an on-demand Device Defender audit.
  ##   body: JObject (required)
  var body_596641 = newJObject()
  if body != nil:
    body_596641 = body
  result = call_596640.call(nil, nil, nil, nil, body_596641)

var startOnDemandAuditTask* = Call_StartOnDemandAuditTask_596628(
    name: "startOnDemandAuditTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/audit/tasks",
    validator: validate_StartOnDemandAuditTask_596629, base: "/",
    url: url_StartOnDemandAuditTask_596630, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StopThingRegistrationTask_596642 = ref object of OpenApiRestCall_593437
proc url_StopThingRegistrationTask_596644(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StopThingRegistrationTask_596643(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The bulk thing provisioning task ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_596645 = path.getOrDefault("taskId")
  valid_596645 = validateParameter(valid_596645, JString, required = true,
                                 default = nil)
  if valid_596645 != nil:
    section.add "taskId", valid_596645
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596646 = header.getOrDefault("X-Amz-Date")
  valid_596646 = validateParameter(valid_596646, JString, required = false,
                                 default = nil)
  if valid_596646 != nil:
    section.add "X-Amz-Date", valid_596646
  var valid_596647 = header.getOrDefault("X-Amz-Security-Token")
  valid_596647 = validateParameter(valid_596647, JString, required = false,
                                 default = nil)
  if valid_596647 != nil:
    section.add "X-Amz-Security-Token", valid_596647
  var valid_596648 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596648 = validateParameter(valid_596648, JString, required = false,
                                 default = nil)
  if valid_596648 != nil:
    section.add "X-Amz-Content-Sha256", valid_596648
  var valid_596649 = header.getOrDefault("X-Amz-Algorithm")
  valid_596649 = validateParameter(valid_596649, JString, required = false,
                                 default = nil)
  if valid_596649 != nil:
    section.add "X-Amz-Algorithm", valid_596649
  var valid_596650 = header.getOrDefault("X-Amz-Signature")
  valid_596650 = validateParameter(valid_596650, JString, required = false,
                                 default = nil)
  if valid_596650 != nil:
    section.add "X-Amz-Signature", valid_596650
  var valid_596651 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596651 = validateParameter(valid_596651, JString, required = false,
                                 default = nil)
  if valid_596651 != nil:
    section.add "X-Amz-SignedHeaders", valid_596651
  var valid_596652 = header.getOrDefault("X-Amz-Credential")
  valid_596652 = validateParameter(valid_596652, JString, required = false,
                                 default = nil)
  if valid_596652 != nil:
    section.add "X-Amz-Credential", valid_596652
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596653: Call_StopThingRegistrationTask_596642; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a bulk thing provisioning task.
  ## 
  let valid = call_596653.validator(path, query, header, formData, body)
  let scheme = call_596653.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596653.url(scheme.get, call_596653.host, call_596653.base,
                         call_596653.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596653, url, valid)

proc call*(call_596654: Call_StopThingRegistrationTask_596642; taskId: string): Recallable =
  ## stopThingRegistrationTask
  ## Cancels a bulk thing provisioning task.
  ##   taskId: string (required)
  ##         : The bulk thing provisioning task ID.
  var path_596655 = newJObject()
  add(path_596655, "taskId", newJString(taskId))
  result = call_596654.call(path_596655, nil, nil, nil, nil)

var stopThingRegistrationTask* = Call_StopThingRegistrationTask_596642(
    name: "stopThingRegistrationTask", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks/{taskId}/cancel",
    validator: validate_StopThingRegistrationTask_596643, base: "/",
    url: url_StopThingRegistrationTask_596644,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_TagResource_596656 = ref object of OpenApiRestCall_593437
proc url_TagResource_596658(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_TagResource_596657(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596659 = header.getOrDefault("X-Amz-Date")
  valid_596659 = validateParameter(valid_596659, JString, required = false,
                                 default = nil)
  if valid_596659 != nil:
    section.add "X-Amz-Date", valid_596659
  var valid_596660 = header.getOrDefault("X-Amz-Security-Token")
  valid_596660 = validateParameter(valid_596660, JString, required = false,
                                 default = nil)
  if valid_596660 != nil:
    section.add "X-Amz-Security-Token", valid_596660
  var valid_596661 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596661 = validateParameter(valid_596661, JString, required = false,
                                 default = nil)
  if valid_596661 != nil:
    section.add "X-Amz-Content-Sha256", valid_596661
  var valid_596662 = header.getOrDefault("X-Amz-Algorithm")
  valid_596662 = validateParameter(valid_596662, JString, required = false,
                                 default = nil)
  if valid_596662 != nil:
    section.add "X-Amz-Algorithm", valid_596662
  var valid_596663 = header.getOrDefault("X-Amz-Signature")
  valid_596663 = validateParameter(valid_596663, JString, required = false,
                                 default = nil)
  if valid_596663 != nil:
    section.add "X-Amz-Signature", valid_596663
  var valid_596664 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596664 = validateParameter(valid_596664, JString, required = false,
                                 default = nil)
  if valid_596664 != nil:
    section.add "X-Amz-SignedHeaders", valid_596664
  var valid_596665 = header.getOrDefault("X-Amz-Credential")
  valid_596665 = validateParameter(valid_596665, JString, required = false,
                                 default = nil)
  if valid_596665 != nil:
    section.add "X-Amz-Credential", valid_596665
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596667: Call_TagResource_596656; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ## 
  let valid = call_596667.validator(path, query, header, formData, body)
  let scheme = call_596667.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596667.url(scheme.get, call_596667.host, call_596667.base,
                         call_596667.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596667, url, valid)

proc call*(call_596668: Call_TagResource_596656; body: JsonNode): Recallable =
  ## tagResource
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ##   body: JObject (required)
  var body_596669 = newJObject()
  if body != nil:
    body_596669 = body
  result = call_596668.call(nil, nil, nil, nil, body_596669)

var tagResource* = Call_TagResource_596656(name: "tagResource",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com", route: "/tags",
                                        validator: validate_TagResource_596657,
                                        base: "/", url: url_TagResource_596658,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_TestAuthorization_596670 = ref object of OpenApiRestCall_593437
proc url_TestAuthorization_596672(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_TestAuthorization_596671(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   clientId: JString
  ##           : The MQTT client ID.
  section = newJObject()
  var valid_596673 = query.getOrDefault("clientId")
  valid_596673 = validateParameter(valid_596673, JString, required = false,
                                 default = nil)
  if valid_596673 != nil:
    section.add "clientId", valid_596673
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596674 = header.getOrDefault("X-Amz-Date")
  valid_596674 = validateParameter(valid_596674, JString, required = false,
                                 default = nil)
  if valid_596674 != nil:
    section.add "X-Amz-Date", valid_596674
  var valid_596675 = header.getOrDefault("X-Amz-Security-Token")
  valid_596675 = validateParameter(valid_596675, JString, required = false,
                                 default = nil)
  if valid_596675 != nil:
    section.add "X-Amz-Security-Token", valid_596675
  var valid_596676 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596676 = validateParameter(valid_596676, JString, required = false,
                                 default = nil)
  if valid_596676 != nil:
    section.add "X-Amz-Content-Sha256", valid_596676
  var valid_596677 = header.getOrDefault("X-Amz-Algorithm")
  valid_596677 = validateParameter(valid_596677, JString, required = false,
                                 default = nil)
  if valid_596677 != nil:
    section.add "X-Amz-Algorithm", valid_596677
  var valid_596678 = header.getOrDefault("X-Amz-Signature")
  valid_596678 = validateParameter(valid_596678, JString, required = false,
                                 default = nil)
  if valid_596678 != nil:
    section.add "X-Amz-Signature", valid_596678
  var valid_596679 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596679 = validateParameter(valid_596679, JString, required = false,
                                 default = nil)
  if valid_596679 != nil:
    section.add "X-Amz-SignedHeaders", valid_596679
  var valid_596680 = header.getOrDefault("X-Amz-Credential")
  valid_596680 = validateParameter(valid_596680, JString, required = false,
                                 default = nil)
  if valid_596680 != nil:
    section.add "X-Amz-Credential", valid_596680
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596682: Call_TestAuthorization_596670; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  let valid = call_596682.validator(path, query, header, formData, body)
  let scheme = call_596682.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596682.url(scheme.get, call_596682.host, call_596682.base,
                         call_596682.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596682, url, valid)

proc call*(call_596683: Call_TestAuthorization_596670; body: JsonNode;
          clientId: string = ""): Recallable =
  ## testAuthorization
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ##   clientId: string
  ##           : The MQTT client ID.
  ##   body: JObject (required)
  var query_596684 = newJObject()
  var body_596685 = newJObject()
  add(query_596684, "clientId", newJString(clientId))
  if body != nil:
    body_596685 = body
  result = call_596683.call(nil, query_596684, nil, nil, body_596685)

var testAuthorization* = Call_TestAuthorization_596670(name: "testAuthorization",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/test-authorization", validator: validate_TestAuthorization_596671,
    base: "/", url: url_TestAuthorization_596672,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_TestInvokeAuthorizer_596686 = ref object of OpenApiRestCall_593437
proc url_TestInvokeAuthorizer_596688(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName"),
               (kind: ConstantSegment, value: "/test")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_TestInvokeAuthorizer_596687(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The custom authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_596689 = path.getOrDefault("authorizerName")
  valid_596689 = validateParameter(valid_596689, JString, required = true,
                                 default = nil)
  if valid_596689 != nil:
    section.add "authorizerName", valid_596689
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596690 = header.getOrDefault("X-Amz-Date")
  valid_596690 = validateParameter(valid_596690, JString, required = false,
                                 default = nil)
  if valid_596690 != nil:
    section.add "X-Amz-Date", valid_596690
  var valid_596691 = header.getOrDefault("X-Amz-Security-Token")
  valid_596691 = validateParameter(valid_596691, JString, required = false,
                                 default = nil)
  if valid_596691 != nil:
    section.add "X-Amz-Security-Token", valid_596691
  var valid_596692 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596692 = validateParameter(valid_596692, JString, required = false,
                                 default = nil)
  if valid_596692 != nil:
    section.add "X-Amz-Content-Sha256", valid_596692
  var valid_596693 = header.getOrDefault("X-Amz-Algorithm")
  valid_596693 = validateParameter(valid_596693, JString, required = false,
                                 default = nil)
  if valid_596693 != nil:
    section.add "X-Amz-Algorithm", valid_596693
  var valid_596694 = header.getOrDefault("X-Amz-Signature")
  valid_596694 = validateParameter(valid_596694, JString, required = false,
                                 default = nil)
  if valid_596694 != nil:
    section.add "X-Amz-Signature", valid_596694
  var valid_596695 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596695 = validateParameter(valid_596695, JString, required = false,
                                 default = nil)
  if valid_596695 != nil:
    section.add "X-Amz-SignedHeaders", valid_596695
  var valid_596696 = header.getOrDefault("X-Amz-Credential")
  valid_596696 = validateParameter(valid_596696, JString, required = false,
                                 default = nil)
  if valid_596696 != nil:
    section.add "X-Amz-Credential", valid_596696
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596698: Call_TestInvokeAuthorizer_596686; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  let valid = call_596698.validator(path, query, header, formData, body)
  let scheme = call_596698.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596698.url(scheme.get, call_596698.host, call_596698.base,
                         call_596698.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596698, url, valid)

proc call*(call_596699: Call_TestInvokeAuthorizer_596686; authorizerName: string;
          body: JsonNode): Recallable =
  ## testInvokeAuthorizer
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ##   authorizerName: string (required)
  ##                 : The custom authorizer name.
  ##   body: JObject (required)
  var path_596700 = newJObject()
  var body_596701 = newJObject()
  add(path_596700, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_596701 = body
  result = call_596699.call(path_596700, nil, nil, nil, body_596701)

var testInvokeAuthorizer* = Call_TestInvokeAuthorizer_596686(
    name: "testInvokeAuthorizer", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/authorizer/{authorizerName}/test",
    validator: validate_TestInvokeAuthorizer_596687, base: "/",
    url: url_TestInvokeAuthorizer_596688, schemes: {Scheme.Https, Scheme.Http})
type
  Call_TransferCertificate_596702 = ref object of OpenApiRestCall_593437
proc url_TransferCertificate_596704(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/transfer-certificate/"),
               (kind: VariableSegment, value: "certificateId"),
               (kind: ConstantSegment, value: "#targetAwsAccount")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_TransferCertificate_596703(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_596705 = path.getOrDefault("certificateId")
  valid_596705 = validateParameter(valid_596705, JString, required = true,
                                 default = nil)
  if valid_596705 != nil:
    section.add "certificateId", valid_596705
  result.add "path", section
  ## parameters in `query` object:
  ##   targetAwsAccount: JString (required)
  ##                   : The AWS account.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `targetAwsAccount` field"
  var valid_596706 = query.getOrDefault("targetAwsAccount")
  valid_596706 = validateParameter(valid_596706, JString, required = true,
                                 default = nil)
  if valid_596706 != nil:
    section.add "targetAwsAccount", valid_596706
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596707 = header.getOrDefault("X-Amz-Date")
  valid_596707 = validateParameter(valid_596707, JString, required = false,
                                 default = nil)
  if valid_596707 != nil:
    section.add "X-Amz-Date", valid_596707
  var valid_596708 = header.getOrDefault("X-Amz-Security-Token")
  valid_596708 = validateParameter(valid_596708, JString, required = false,
                                 default = nil)
  if valid_596708 != nil:
    section.add "X-Amz-Security-Token", valid_596708
  var valid_596709 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596709 = validateParameter(valid_596709, JString, required = false,
                                 default = nil)
  if valid_596709 != nil:
    section.add "X-Amz-Content-Sha256", valid_596709
  var valid_596710 = header.getOrDefault("X-Amz-Algorithm")
  valid_596710 = validateParameter(valid_596710, JString, required = false,
                                 default = nil)
  if valid_596710 != nil:
    section.add "X-Amz-Algorithm", valid_596710
  var valid_596711 = header.getOrDefault("X-Amz-Signature")
  valid_596711 = validateParameter(valid_596711, JString, required = false,
                                 default = nil)
  if valid_596711 != nil:
    section.add "X-Amz-Signature", valid_596711
  var valid_596712 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596712 = validateParameter(valid_596712, JString, required = false,
                                 default = nil)
  if valid_596712 != nil:
    section.add "X-Amz-SignedHeaders", valid_596712
  var valid_596713 = header.getOrDefault("X-Amz-Credential")
  valid_596713 = validateParameter(valid_596713, JString, required = false,
                                 default = nil)
  if valid_596713 != nil:
    section.add "X-Amz-Credential", valid_596713
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596715: Call_TransferCertificate_596702; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ## 
  let valid = call_596715.validator(path, query, header, formData, body)
  let scheme = call_596715.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596715.url(scheme.get, call_596715.host, call_596715.base,
                         call_596715.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596715, url, valid)

proc call*(call_596716: Call_TransferCertificate_596702; certificateId: string;
          targetAwsAccount: string; body: JsonNode): Recallable =
  ## transferCertificate
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   targetAwsAccount: string (required)
  ##                   : The AWS account.
  ##   body: JObject (required)
  var path_596717 = newJObject()
  var query_596718 = newJObject()
  var body_596719 = newJObject()
  add(path_596717, "certificateId", newJString(certificateId))
  add(query_596718, "targetAwsAccount", newJString(targetAwsAccount))
  if body != nil:
    body_596719 = body
  result = call_596716.call(path_596717, query_596718, nil, nil, body_596719)

var transferCertificate* = Call_TransferCertificate_596702(
    name: "transferCertificate", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/transfer-certificate/{certificateId}#targetAwsAccount",
    validator: validate_TransferCertificate_596703, base: "/",
    url: url_TransferCertificate_596704, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UntagResource_596720 = ref object of OpenApiRestCall_593437
proc url_UntagResource_596722(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UntagResource_596721(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes the given tags (metadata) from the resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596723 = header.getOrDefault("X-Amz-Date")
  valid_596723 = validateParameter(valid_596723, JString, required = false,
                                 default = nil)
  if valid_596723 != nil:
    section.add "X-Amz-Date", valid_596723
  var valid_596724 = header.getOrDefault("X-Amz-Security-Token")
  valid_596724 = validateParameter(valid_596724, JString, required = false,
                                 default = nil)
  if valid_596724 != nil:
    section.add "X-Amz-Security-Token", valid_596724
  var valid_596725 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596725 = validateParameter(valid_596725, JString, required = false,
                                 default = nil)
  if valid_596725 != nil:
    section.add "X-Amz-Content-Sha256", valid_596725
  var valid_596726 = header.getOrDefault("X-Amz-Algorithm")
  valid_596726 = validateParameter(valid_596726, JString, required = false,
                                 default = nil)
  if valid_596726 != nil:
    section.add "X-Amz-Algorithm", valid_596726
  var valid_596727 = header.getOrDefault("X-Amz-Signature")
  valid_596727 = validateParameter(valid_596727, JString, required = false,
                                 default = nil)
  if valid_596727 != nil:
    section.add "X-Amz-Signature", valid_596727
  var valid_596728 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596728 = validateParameter(valid_596728, JString, required = false,
                                 default = nil)
  if valid_596728 != nil:
    section.add "X-Amz-SignedHeaders", valid_596728
  var valid_596729 = header.getOrDefault("X-Amz-Credential")
  valid_596729 = validateParameter(valid_596729, JString, required = false,
                                 default = nil)
  if valid_596729 != nil:
    section.add "X-Amz-Credential", valid_596729
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596731: Call_UntagResource_596720; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes the given tags (metadata) from the resource.
  ## 
  let valid = call_596731.validator(path, query, header, formData, body)
  let scheme = call_596731.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596731.url(scheme.get, call_596731.host, call_596731.base,
                         call_596731.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596731, url, valid)

proc call*(call_596732: Call_UntagResource_596720; body: JsonNode): Recallable =
  ## untagResource
  ## Removes the given tags (metadata) from the resource.
  ##   body: JObject (required)
  var body_596733 = newJObject()
  if body != nil:
    body_596733 = body
  result = call_596732.call(nil, nil, nil, nil, body_596733)

var untagResource* = Call_UntagResource_596720(name: "untagResource",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/untag",
    validator: validate_UntagResource_596721, base: "/", url: url_UntagResource_596722,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateCertificate_596734 = ref object of OpenApiRestCall_593437
proc url_UpdateCertificate_596736(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId"),
               (kind: ConstantSegment, value: "#newStatus")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateCertificate_596735(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_596737 = path.getOrDefault("certificateId")
  valid_596737 = validateParameter(valid_596737, JString, required = true,
                                 default = nil)
  if valid_596737 != nil:
    section.add "certificateId", valid_596737
  result.add "path", section
  ## parameters in `query` object:
  ##   newStatus: JString (required)
  ##            : <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `newStatus` field"
  var valid_596738 = query.getOrDefault("newStatus")
  valid_596738 = validateParameter(valid_596738, JString, required = true,
                                 default = newJString("ACTIVE"))
  if valid_596738 != nil:
    section.add "newStatus", valid_596738
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596739 = header.getOrDefault("X-Amz-Date")
  valid_596739 = validateParameter(valid_596739, JString, required = false,
                                 default = nil)
  if valid_596739 != nil:
    section.add "X-Amz-Date", valid_596739
  var valid_596740 = header.getOrDefault("X-Amz-Security-Token")
  valid_596740 = validateParameter(valid_596740, JString, required = false,
                                 default = nil)
  if valid_596740 != nil:
    section.add "X-Amz-Security-Token", valid_596740
  var valid_596741 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596741 = validateParameter(valid_596741, JString, required = false,
                                 default = nil)
  if valid_596741 != nil:
    section.add "X-Amz-Content-Sha256", valid_596741
  var valid_596742 = header.getOrDefault("X-Amz-Algorithm")
  valid_596742 = validateParameter(valid_596742, JString, required = false,
                                 default = nil)
  if valid_596742 != nil:
    section.add "X-Amz-Algorithm", valid_596742
  var valid_596743 = header.getOrDefault("X-Amz-Signature")
  valid_596743 = validateParameter(valid_596743, JString, required = false,
                                 default = nil)
  if valid_596743 != nil:
    section.add "X-Amz-Signature", valid_596743
  var valid_596744 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596744 = validateParameter(valid_596744, JString, required = false,
                                 default = nil)
  if valid_596744 != nil:
    section.add "X-Amz-SignedHeaders", valid_596744
  var valid_596745 = header.getOrDefault("X-Amz-Credential")
  valid_596745 = validateParameter(valid_596745, JString, required = false,
                                 default = nil)
  if valid_596745 != nil:
    section.add "X-Amz-Credential", valid_596745
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596746: Call_UpdateCertificate_596734; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ## 
  let valid = call_596746.validator(path, query, header, formData, body)
  let scheme = call_596746.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596746.url(scheme.get, call_596746.host, call_596746.base,
                         call_596746.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596746, url, valid)

proc call*(call_596747: Call_UpdateCertificate_596734; certificateId: string;
          newStatus: string = "ACTIVE"): Recallable =
  ## updateCertificate
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   newStatus: string (required)
  ##            : <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  var path_596748 = newJObject()
  var query_596749 = newJObject()
  add(path_596748, "certificateId", newJString(certificateId))
  add(query_596749, "newStatus", newJString(newStatus))
  result = call_596747.call(path_596748, query_596749, nil, nil, nil)

var updateCertificate* = Call_UpdateCertificate_596734(name: "updateCertificate",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/certificates/{certificateId}#newStatus",
    validator: validate_UpdateCertificate_596735, base: "/",
    url: url_UpdateCertificate_596736, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThingGroupsForThing_596750 = ref object of OpenApiRestCall_593437
proc url_UpdateThingGroupsForThing_596752(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateThingGroupsForThing_596751(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the groups to which the thing belongs.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596753 = header.getOrDefault("X-Amz-Date")
  valid_596753 = validateParameter(valid_596753, JString, required = false,
                                 default = nil)
  if valid_596753 != nil:
    section.add "X-Amz-Date", valid_596753
  var valid_596754 = header.getOrDefault("X-Amz-Security-Token")
  valid_596754 = validateParameter(valid_596754, JString, required = false,
                                 default = nil)
  if valid_596754 != nil:
    section.add "X-Amz-Security-Token", valid_596754
  var valid_596755 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596755 = validateParameter(valid_596755, JString, required = false,
                                 default = nil)
  if valid_596755 != nil:
    section.add "X-Amz-Content-Sha256", valid_596755
  var valid_596756 = header.getOrDefault("X-Amz-Algorithm")
  valid_596756 = validateParameter(valid_596756, JString, required = false,
                                 default = nil)
  if valid_596756 != nil:
    section.add "X-Amz-Algorithm", valid_596756
  var valid_596757 = header.getOrDefault("X-Amz-Signature")
  valid_596757 = validateParameter(valid_596757, JString, required = false,
                                 default = nil)
  if valid_596757 != nil:
    section.add "X-Amz-Signature", valid_596757
  var valid_596758 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596758 = validateParameter(valid_596758, JString, required = false,
                                 default = nil)
  if valid_596758 != nil:
    section.add "X-Amz-SignedHeaders", valid_596758
  var valid_596759 = header.getOrDefault("X-Amz-Credential")
  valid_596759 = validateParameter(valid_596759, JString, required = false,
                                 default = nil)
  if valid_596759 != nil:
    section.add "X-Amz-Credential", valid_596759
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596761: Call_UpdateThingGroupsForThing_596750; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the groups to which the thing belongs.
  ## 
  let valid = call_596761.validator(path, query, header, formData, body)
  let scheme = call_596761.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596761.url(scheme.get, call_596761.host, call_596761.base,
                         call_596761.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596761, url, valid)

proc call*(call_596762: Call_UpdateThingGroupsForThing_596750; body: JsonNode): Recallable =
  ## updateThingGroupsForThing
  ## Updates the groups to which the thing belongs.
  ##   body: JObject (required)
  var body_596763 = newJObject()
  if body != nil:
    body_596763 = body
  result = call_596762.call(nil, nil, nil, nil, body_596763)

var updateThingGroupsForThing* = Call_UpdateThingGroupsForThing_596750(
    name: "updateThingGroupsForThing", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/updateThingGroupsForThing",
    validator: validate_UpdateThingGroupsForThing_596751, base: "/",
    url: url_UpdateThingGroupsForThing_596752,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ValidateSecurityProfileBehaviors_596764 = ref object of OpenApiRestCall_593437
proc url_ValidateSecurityProfileBehaviors_596766(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ValidateSecurityProfileBehaviors_596765(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validates a Device Defender security profile behaviors specification.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596767 = header.getOrDefault("X-Amz-Date")
  valid_596767 = validateParameter(valid_596767, JString, required = false,
                                 default = nil)
  if valid_596767 != nil:
    section.add "X-Amz-Date", valid_596767
  var valid_596768 = header.getOrDefault("X-Amz-Security-Token")
  valid_596768 = validateParameter(valid_596768, JString, required = false,
                                 default = nil)
  if valid_596768 != nil:
    section.add "X-Amz-Security-Token", valid_596768
  var valid_596769 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596769 = validateParameter(valid_596769, JString, required = false,
                                 default = nil)
  if valid_596769 != nil:
    section.add "X-Amz-Content-Sha256", valid_596769
  var valid_596770 = header.getOrDefault("X-Amz-Algorithm")
  valid_596770 = validateParameter(valid_596770, JString, required = false,
                                 default = nil)
  if valid_596770 != nil:
    section.add "X-Amz-Algorithm", valid_596770
  var valid_596771 = header.getOrDefault("X-Amz-Signature")
  valid_596771 = validateParameter(valid_596771, JString, required = false,
                                 default = nil)
  if valid_596771 != nil:
    section.add "X-Amz-Signature", valid_596771
  var valid_596772 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596772 = validateParameter(valid_596772, JString, required = false,
                                 default = nil)
  if valid_596772 != nil:
    section.add "X-Amz-SignedHeaders", valid_596772
  var valid_596773 = header.getOrDefault("X-Amz-Credential")
  valid_596773 = validateParameter(valid_596773, JString, required = false,
                                 default = nil)
  if valid_596773 != nil:
    section.add "X-Amz-Credential", valid_596773
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596775: Call_ValidateSecurityProfileBehaviors_596764;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Validates a Device Defender security profile behaviors specification.
  ## 
  let valid = call_596775.validator(path, query, header, formData, body)
  let scheme = call_596775.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596775.url(scheme.get, call_596775.host, call_596775.base,
                         call_596775.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596775, url, valid)

proc call*(call_596776: Call_ValidateSecurityProfileBehaviors_596764;
          body: JsonNode): Recallable =
  ## validateSecurityProfileBehaviors
  ## Validates a Device Defender security profile behaviors specification.
  ##   body: JObject (required)
  var body_596777 = newJObject()
  if body != nil:
    body_596777 = body
  result = call_596776.call(nil, nil, nil, nil, body_596777)

var validateSecurityProfileBehaviors* = Call_ValidateSecurityProfileBehaviors_596764(
    name: "validateSecurityProfileBehaviors", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/security-profile-behaviors/validate",
    validator: validate_ValidateSecurityProfileBehaviors_596765, base: "/",
    url: url_ValidateSecurityProfileBehaviors_596766,
    schemes: {Scheme.Https, Scheme.Http})
export
  rest

proc sign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", "")
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", "")
    region = os.getEnv("AWS_REGION", "")
  assert secret != "", "need secret key in env"
  assert access != "", "need access key in env"
  assert region != "", "need region in env"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  recall.headers.del "Host"
  recall.url = $url

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  let headers = massageHeaders(input.getOrDefault("header"))
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
  result.sign(input.getOrDefault("query"), SHA256)
