
import
  json, options, hashes, tables, openapi/rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: AWS IoT
## version: 2015-05-28
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>AWS IoT</fullname> <p>AWS IoT provides secure, bi-directional communication between Internet-connected devices (such as sensors, actuators, embedded devices, or smart appliances) and the AWS cloud. You can discover your custom IoT-Data endpoint to communicate with, configure rules for data processing and integration with other services, organize resources associated with each device (Registry), configure logging, and create and manage policies and credentials to authenticate devices.</p> <p>For more information about how AWS IoT works, see the <a href="https://docs.aws.amazon.com/iot/latest/developerguide/aws-iot-how-it-works.html">Developer Guide</a>.</p> <p>For information about how to use the credentials provider for AWS IoT, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorizing-direct-aws.html">Authorizing Direct Calls to AWS Services</a>.</p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/iot/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode): string

  OpenApiRestCall_772597 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_772597](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_772597): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    if js.kind notin {JString, JInt, JFloat, JNull, JBool}:
      return
    head = $js
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get())

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "iot.ap-northeast-1.amazonaws.com", "ap-southeast-1": "iot.ap-southeast-1.amazonaws.com",
                           "us-west-2": "iot.us-west-2.amazonaws.com",
                           "eu-west-2": "iot.eu-west-2.amazonaws.com", "ap-northeast-3": "iot.ap-northeast-3.amazonaws.com",
                           "eu-central-1": "iot.eu-central-1.amazonaws.com",
                           "us-east-2": "iot.us-east-2.amazonaws.com",
                           "us-east-1": "iot.us-east-1.amazonaws.com", "cn-northwest-1": "iot.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "iot.ap-south-1.amazonaws.com",
                           "eu-north-1": "iot.eu-north-1.amazonaws.com", "ap-northeast-2": "iot.ap-northeast-2.amazonaws.com",
                           "us-west-1": "iot.us-west-1.amazonaws.com",
                           "us-gov-east-1": "iot.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "iot.eu-west-3.amazonaws.com",
                           "cn-north-1": "iot.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "iot.sa-east-1.amazonaws.com",
                           "eu-west-1": "iot.eu-west-1.amazonaws.com",
                           "us-gov-west-1": "iot.us-gov-west-1.amazonaws.com", "ap-southeast-2": "iot.ap-southeast-2.amazonaws.com",
                           "ca-central-1": "iot.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "iot.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "iot.ap-southeast-1.amazonaws.com",
      "us-west-2": "iot.us-west-2.amazonaws.com",
      "eu-west-2": "iot.eu-west-2.amazonaws.com",
      "ap-northeast-3": "iot.ap-northeast-3.amazonaws.com",
      "eu-central-1": "iot.eu-central-1.amazonaws.com",
      "us-east-2": "iot.us-east-2.amazonaws.com",
      "us-east-1": "iot.us-east-1.amazonaws.com",
      "cn-northwest-1": "iot.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "iot.ap-south-1.amazonaws.com",
      "eu-north-1": "iot.eu-north-1.amazonaws.com",
      "ap-northeast-2": "iot.ap-northeast-2.amazonaws.com",
      "us-west-1": "iot.us-west-1.amazonaws.com",
      "us-gov-east-1": "iot.us-gov-east-1.amazonaws.com",
      "eu-west-3": "iot.eu-west-3.amazonaws.com",
      "cn-north-1": "iot.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "iot.sa-east-1.amazonaws.com",
      "eu-west-1": "iot.eu-west-1.amazonaws.com",
      "us-gov-west-1": "iot.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "iot.ap-southeast-2.amazonaws.com",
      "ca-central-1": "iot.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "iot"
method hook(call: OpenApiRestCall; url: string; input: JsonNode): Recallable {.base.}
type
  Call_AcceptCertificateTransfer_772933 = ref object of OpenApiRestCall_772597
proc url_AcceptCertificateTransfer_772935(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/accept-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_AcceptCertificateTransfer_772934(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_773061 = path.getOrDefault("certificateId")
  valid_773061 = validateParameter(valid_773061, JString, required = true,
                                 default = nil)
  if valid_773061 != nil:
    section.add "certificateId", valid_773061
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_773062 = query.getOrDefault("setAsActive")
  valid_773062 = validateParameter(valid_773062, JBool, required = false, default = nil)
  if valid_773062 != nil:
    section.add "setAsActive", valid_773062
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773063 = header.getOrDefault("X-Amz-Date")
  valid_773063 = validateParameter(valid_773063, JString, required = false,
                                 default = nil)
  if valid_773063 != nil:
    section.add "X-Amz-Date", valid_773063
  var valid_773064 = header.getOrDefault("X-Amz-Security-Token")
  valid_773064 = validateParameter(valid_773064, JString, required = false,
                                 default = nil)
  if valid_773064 != nil:
    section.add "X-Amz-Security-Token", valid_773064
  var valid_773065 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773065 = validateParameter(valid_773065, JString, required = false,
                                 default = nil)
  if valid_773065 != nil:
    section.add "X-Amz-Content-Sha256", valid_773065
  var valid_773066 = header.getOrDefault("X-Amz-Algorithm")
  valid_773066 = validateParameter(valid_773066, JString, required = false,
                                 default = nil)
  if valid_773066 != nil:
    section.add "X-Amz-Algorithm", valid_773066
  var valid_773067 = header.getOrDefault("X-Amz-Signature")
  valid_773067 = validateParameter(valid_773067, JString, required = false,
                                 default = nil)
  if valid_773067 != nil:
    section.add "X-Amz-Signature", valid_773067
  var valid_773068 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773068 = validateParameter(valid_773068, JString, required = false,
                                 default = nil)
  if valid_773068 != nil:
    section.add "X-Amz-SignedHeaders", valid_773068
  var valid_773069 = header.getOrDefault("X-Amz-Credential")
  valid_773069 = validateParameter(valid_773069, JString, required = false,
                                 default = nil)
  if valid_773069 != nil:
    section.add "X-Amz-Credential", valid_773069
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773092: Call_AcceptCertificateTransfer_772933; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ## 
  let valid = call_773092.validator(path, query, header, formData, body)
  let scheme = call_773092.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773092.url(scheme.get, call_773092.host, call_773092.base,
                         call_773092.route, valid.getOrDefault("path"))
  result = hook(call_773092, url, valid)

proc call*(call_773163: Call_AcceptCertificateTransfer_772933;
          certificateId: string; setAsActive: bool = false): Recallable =
  ## acceptCertificateTransfer
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  var path_773164 = newJObject()
  var query_773166 = newJObject()
  add(path_773164, "certificateId", newJString(certificateId))
  add(query_773166, "setAsActive", newJBool(setAsActive))
  result = call_773163.call(path_773164, query_773166, nil, nil, nil)

var acceptCertificateTransfer* = Call_AcceptCertificateTransfer_772933(
    name: "acceptCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/accept-certificate-transfer/{certificateId}",
    validator: validate_AcceptCertificateTransfer_772934, base: "/",
    url: url_AcceptCertificateTransfer_772935,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_AddThingToBillingGroup_773205 = ref object of OpenApiRestCall_772597
proc url_AddThingToBillingGroup_773207(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_AddThingToBillingGroup_773206(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a thing to a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773208 = header.getOrDefault("X-Amz-Date")
  valid_773208 = validateParameter(valid_773208, JString, required = false,
                                 default = nil)
  if valid_773208 != nil:
    section.add "X-Amz-Date", valid_773208
  var valid_773209 = header.getOrDefault("X-Amz-Security-Token")
  valid_773209 = validateParameter(valid_773209, JString, required = false,
                                 default = nil)
  if valid_773209 != nil:
    section.add "X-Amz-Security-Token", valid_773209
  var valid_773210 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773210 = validateParameter(valid_773210, JString, required = false,
                                 default = nil)
  if valid_773210 != nil:
    section.add "X-Amz-Content-Sha256", valid_773210
  var valid_773211 = header.getOrDefault("X-Amz-Algorithm")
  valid_773211 = validateParameter(valid_773211, JString, required = false,
                                 default = nil)
  if valid_773211 != nil:
    section.add "X-Amz-Algorithm", valid_773211
  var valid_773212 = header.getOrDefault("X-Amz-Signature")
  valid_773212 = validateParameter(valid_773212, JString, required = false,
                                 default = nil)
  if valid_773212 != nil:
    section.add "X-Amz-Signature", valid_773212
  var valid_773213 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773213 = validateParameter(valid_773213, JString, required = false,
                                 default = nil)
  if valid_773213 != nil:
    section.add "X-Amz-SignedHeaders", valid_773213
  var valid_773214 = header.getOrDefault("X-Amz-Credential")
  valid_773214 = validateParameter(valid_773214, JString, required = false,
                                 default = nil)
  if valid_773214 != nil:
    section.add "X-Amz-Credential", valid_773214
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773216: Call_AddThingToBillingGroup_773205; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a thing to a billing group.
  ## 
  let valid = call_773216.validator(path, query, header, formData, body)
  let scheme = call_773216.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773216.url(scheme.get, call_773216.host, call_773216.base,
                         call_773216.route, valid.getOrDefault("path"))
  result = hook(call_773216, url, valid)

proc call*(call_773217: Call_AddThingToBillingGroup_773205; body: JsonNode): Recallable =
  ## addThingToBillingGroup
  ## Adds a thing to a billing group.
  ##   body: JObject (required)
  var body_773218 = newJObject()
  if body != nil:
    body_773218 = body
  result = call_773217.call(nil, nil, nil, nil, body_773218)

var addThingToBillingGroup* = Call_AddThingToBillingGroup_773205(
    name: "addThingToBillingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/billing-groups/addThingToBillingGroup",
    validator: validate_AddThingToBillingGroup_773206, base: "/",
    url: url_AddThingToBillingGroup_773207, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AddThingToThingGroup_773219 = ref object of OpenApiRestCall_772597
proc url_AddThingToThingGroup_773221(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_AddThingToThingGroup_773220(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a thing to a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773222 = header.getOrDefault("X-Amz-Date")
  valid_773222 = validateParameter(valid_773222, JString, required = false,
                                 default = nil)
  if valid_773222 != nil:
    section.add "X-Amz-Date", valid_773222
  var valid_773223 = header.getOrDefault("X-Amz-Security-Token")
  valid_773223 = validateParameter(valid_773223, JString, required = false,
                                 default = nil)
  if valid_773223 != nil:
    section.add "X-Amz-Security-Token", valid_773223
  var valid_773224 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773224 = validateParameter(valid_773224, JString, required = false,
                                 default = nil)
  if valid_773224 != nil:
    section.add "X-Amz-Content-Sha256", valid_773224
  var valid_773225 = header.getOrDefault("X-Amz-Algorithm")
  valid_773225 = validateParameter(valid_773225, JString, required = false,
                                 default = nil)
  if valid_773225 != nil:
    section.add "X-Amz-Algorithm", valid_773225
  var valid_773226 = header.getOrDefault("X-Amz-Signature")
  valid_773226 = validateParameter(valid_773226, JString, required = false,
                                 default = nil)
  if valid_773226 != nil:
    section.add "X-Amz-Signature", valid_773226
  var valid_773227 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773227 = validateParameter(valid_773227, JString, required = false,
                                 default = nil)
  if valid_773227 != nil:
    section.add "X-Amz-SignedHeaders", valid_773227
  var valid_773228 = header.getOrDefault("X-Amz-Credential")
  valid_773228 = validateParameter(valid_773228, JString, required = false,
                                 default = nil)
  if valid_773228 != nil:
    section.add "X-Amz-Credential", valid_773228
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773230: Call_AddThingToThingGroup_773219; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a thing to a thing group.
  ## 
  let valid = call_773230.validator(path, query, header, formData, body)
  let scheme = call_773230.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773230.url(scheme.get, call_773230.host, call_773230.base,
                         call_773230.route, valid.getOrDefault("path"))
  result = hook(call_773230, url, valid)

proc call*(call_773231: Call_AddThingToThingGroup_773219; body: JsonNode): Recallable =
  ## addThingToThingGroup
  ## Adds a thing to a thing group.
  ##   body: JObject (required)
  var body_773232 = newJObject()
  if body != nil:
    body_773232 = body
  result = call_773231.call(nil, nil, nil, nil, body_773232)

var addThingToThingGroup* = Call_AddThingToThingGroup_773219(
    name: "addThingToThingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/addThingToThingGroup",
    validator: validate_AddThingToThingGroup_773220, base: "/",
    url: url_AddThingToThingGroup_773221, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AssociateTargetsWithJob_773233 = ref object of OpenApiRestCall_772597
proc url_AssociateTargetsWithJob_773235(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/targets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_AssociateTargetsWithJob_773234(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_773236 = path.getOrDefault("jobId")
  valid_773236 = validateParameter(valid_773236, JString, required = true,
                                 default = nil)
  if valid_773236 != nil:
    section.add "jobId", valid_773236
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773237 = header.getOrDefault("X-Amz-Date")
  valid_773237 = validateParameter(valid_773237, JString, required = false,
                                 default = nil)
  if valid_773237 != nil:
    section.add "X-Amz-Date", valid_773237
  var valid_773238 = header.getOrDefault("X-Amz-Security-Token")
  valid_773238 = validateParameter(valid_773238, JString, required = false,
                                 default = nil)
  if valid_773238 != nil:
    section.add "X-Amz-Security-Token", valid_773238
  var valid_773239 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773239 = validateParameter(valid_773239, JString, required = false,
                                 default = nil)
  if valid_773239 != nil:
    section.add "X-Amz-Content-Sha256", valid_773239
  var valid_773240 = header.getOrDefault("X-Amz-Algorithm")
  valid_773240 = validateParameter(valid_773240, JString, required = false,
                                 default = nil)
  if valid_773240 != nil:
    section.add "X-Amz-Algorithm", valid_773240
  var valid_773241 = header.getOrDefault("X-Amz-Signature")
  valid_773241 = validateParameter(valid_773241, JString, required = false,
                                 default = nil)
  if valid_773241 != nil:
    section.add "X-Amz-Signature", valid_773241
  var valid_773242 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773242 = validateParameter(valid_773242, JString, required = false,
                                 default = nil)
  if valid_773242 != nil:
    section.add "X-Amz-SignedHeaders", valid_773242
  var valid_773243 = header.getOrDefault("X-Amz-Credential")
  valid_773243 = validateParameter(valid_773243, JString, required = false,
                                 default = nil)
  if valid_773243 != nil:
    section.add "X-Amz-Credential", valid_773243
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773245: Call_AssociateTargetsWithJob_773233; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ## 
  let valid = call_773245.validator(path, query, header, formData, body)
  let scheme = call_773245.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773245.url(scheme.get, call_773245.host, call_773245.base,
                         call_773245.route, valid.getOrDefault("path"))
  result = hook(call_773245, url, valid)

proc call*(call_773246: Call_AssociateTargetsWithJob_773233; jobId: string;
          body: JsonNode): Recallable =
  ## associateTargetsWithJob
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   body: JObject (required)
  var path_773247 = newJObject()
  var body_773248 = newJObject()
  add(path_773247, "jobId", newJString(jobId))
  if body != nil:
    body_773248 = body
  result = call_773246.call(path_773247, nil, nil, nil, body_773248)

var associateTargetsWithJob* = Call_AssociateTargetsWithJob_773233(
    name: "associateTargetsWithJob", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/jobs/{jobId}/targets",
    validator: validate_AssociateTargetsWithJob_773234, base: "/",
    url: url_AssociateTargetsWithJob_773235, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachPolicy_773249 = ref object of OpenApiRestCall_772597
proc url_AttachPolicy_773251(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/target-policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_AttachPolicy_773250(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Attaches a policy to the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to attach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_773252 = path.getOrDefault("policyName")
  valid_773252 = validateParameter(valid_773252, JString, required = true,
                                 default = nil)
  if valid_773252 != nil:
    section.add "policyName", valid_773252
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773253 = header.getOrDefault("X-Amz-Date")
  valid_773253 = validateParameter(valid_773253, JString, required = false,
                                 default = nil)
  if valid_773253 != nil:
    section.add "X-Amz-Date", valid_773253
  var valid_773254 = header.getOrDefault("X-Amz-Security-Token")
  valid_773254 = validateParameter(valid_773254, JString, required = false,
                                 default = nil)
  if valid_773254 != nil:
    section.add "X-Amz-Security-Token", valid_773254
  var valid_773255 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773255 = validateParameter(valid_773255, JString, required = false,
                                 default = nil)
  if valid_773255 != nil:
    section.add "X-Amz-Content-Sha256", valid_773255
  var valid_773256 = header.getOrDefault("X-Amz-Algorithm")
  valid_773256 = validateParameter(valid_773256, JString, required = false,
                                 default = nil)
  if valid_773256 != nil:
    section.add "X-Amz-Algorithm", valid_773256
  var valid_773257 = header.getOrDefault("X-Amz-Signature")
  valid_773257 = validateParameter(valid_773257, JString, required = false,
                                 default = nil)
  if valid_773257 != nil:
    section.add "X-Amz-Signature", valid_773257
  var valid_773258 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773258 = validateParameter(valid_773258, JString, required = false,
                                 default = nil)
  if valid_773258 != nil:
    section.add "X-Amz-SignedHeaders", valid_773258
  var valid_773259 = header.getOrDefault("X-Amz-Credential")
  valid_773259 = validateParameter(valid_773259, JString, required = false,
                                 default = nil)
  if valid_773259 != nil:
    section.add "X-Amz-Credential", valid_773259
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773261: Call_AttachPolicy_773249; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Attaches a policy to the specified target.
  ## 
  let valid = call_773261.validator(path, query, header, formData, body)
  let scheme = call_773261.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773261.url(scheme.get, call_773261.host, call_773261.base,
                         call_773261.route, valid.getOrDefault("path"))
  result = hook(call_773261, url, valid)

proc call*(call_773262: Call_AttachPolicy_773249; policyName: string; body: JsonNode): Recallable =
  ## attachPolicy
  ## Attaches a policy to the specified target.
  ##   policyName: string (required)
  ##             : The name of the policy to attach.
  ##   body: JObject (required)
  var path_773263 = newJObject()
  var body_773264 = newJObject()
  add(path_773263, "policyName", newJString(policyName))
  if body != nil:
    body_773264 = body
  result = call_773262.call(path_773263, nil, nil, nil, body_773264)

var attachPolicy* = Call_AttachPolicy_773249(name: "attachPolicy",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/target-policies/{policyName}", validator: validate_AttachPolicy_773250,
    base: "/", url: url_AttachPolicy_773251, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachPolicy_773265 = ref object of OpenApiRestCall_772597
proc url_DetachPolicy_773267(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/target-policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DetachPolicy_773266(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Detaches a policy from the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy to detach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_773268 = path.getOrDefault("policyName")
  valid_773268 = validateParameter(valid_773268, JString, required = true,
                                 default = nil)
  if valid_773268 != nil:
    section.add "policyName", valid_773268
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773269 = header.getOrDefault("X-Amz-Date")
  valid_773269 = validateParameter(valid_773269, JString, required = false,
                                 default = nil)
  if valid_773269 != nil:
    section.add "X-Amz-Date", valid_773269
  var valid_773270 = header.getOrDefault("X-Amz-Security-Token")
  valid_773270 = validateParameter(valid_773270, JString, required = false,
                                 default = nil)
  if valid_773270 != nil:
    section.add "X-Amz-Security-Token", valid_773270
  var valid_773271 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773271 = validateParameter(valid_773271, JString, required = false,
                                 default = nil)
  if valid_773271 != nil:
    section.add "X-Amz-Content-Sha256", valid_773271
  var valid_773272 = header.getOrDefault("X-Amz-Algorithm")
  valid_773272 = validateParameter(valid_773272, JString, required = false,
                                 default = nil)
  if valid_773272 != nil:
    section.add "X-Amz-Algorithm", valid_773272
  var valid_773273 = header.getOrDefault("X-Amz-Signature")
  valid_773273 = validateParameter(valid_773273, JString, required = false,
                                 default = nil)
  if valid_773273 != nil:
    section.add "X-Amz-Signature", valid_773273
  var valid_773274 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773274 = validateParameter(valid_773274, JString, required = false,
                                 default = nil)
  if valid_773274 != nil:
    section.add "X-Amz-SignedHeaders", valid_773274
  var valid_773275 = header.getOrDefault("X-Amz-Credential")
  valid_773275 = validateParameter(valid_773275, JString, required = false,
                                 default = nil)
  if valid_773275 != nil:
    section.add "X-Amz-Credential", valid_773275
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773277: Call_DetachPolicy_773265; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Detaches a policy from the specified target.
  ## 
  let valid = call_773277.validator(path, query, header, formData, body)
  let scheme = call_773277.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773277.url(scheme.get, call_773277.host, call_773277.base,
                         call_773277.route, valid.getOrDefault("path"))
  result = hook(call_773277, url, valid)

proc call*(call_773278: Call_DetachPolicy_773265; policyName: string; body: JsonNode): Recallable =
  ## detachPolicy
  ## Detaches a policy from the specified target.
  ##   policyName: string (required)
  ##             : The policy to detach.
  ##   body: JObject (required)
  var path_773279 = newJObject()
  var body_773280 = newJObject()
  add(path_773279, "policyName", newJString(policyName))
  if body != nil:
    body_773280 = body
  result = call_773278.call(path_773279, nil, nil, nil, body_773280)

var detachPolicy* = Call_DetachPolicy_773265(name: "detachPolicy",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/target-policies/{policyName}", validator: validate_DetachPolicy_773266,
    base: "/", url: url_DetachPolicy_773267, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachPrincipalPolicy_773281 = ref object of OpenApiRestCall_772597
proc url_AttachPrincipalPolicy_773283(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/principal-policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "#x-amzn-iot-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_AttachPrincipalPolicy_773282(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_773284 = path.getOrDefault("policyName")
  valid_773284 = validateParameter(valid_773284, JString, required = true,
                                 default = nil)
  if valid_773284 != nil:
    section.add "policyName", valid_773284
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773285 = header.getOrDefault("X-Amz-Date")
  valid_773285 = validateParameter(valid_773285, JString, required = false,
                                 default = nil)
  if valid_773285 != nil:
    section.add "X-Amz-Date", valid_773285
  var valid_773286 = header.getOrDefault("X-Amz-Security-Token")
  valid_773286 = validateParameter(valid_773286, JString, required = false,
                                 default = nil)
  if valid_773286 != nil:
    section.add "X-Amz-Security-Token", valid_773286
  var valid_773287 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773287 = validateParameter(valid_773287, JString, required = false,
                                 default = nil)
  if valid_773287 != nil:
    section.add "X-Amz-Content-Sha256", valid_773287
  var valid_773288 = header.getOrDefault("X-Amz-Algorithm")
  valid_773288 = validateParameter(valid_773288, JString, required = false,
                                 default = nil)
  if valid_773288 != nil:
    section.add "X-Amz-Algorithm", valid_773288
  var valid_773289 = header.getOrDefault("X-Amz-Signature")
  valid_773289 = validateParameter(valid_773289, JString, required = false,
                                 default = nil)
  if valid_773289 != nil:
    section.add "X-Amz-Signature", valid_773289
  var valid_773290 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773290 = validateParameter(valid_773290, JString, required = false,
                                 default = nil)
  if valid_773290 != nil:
    section.add "X-Amz-SignedHeaders", valid_773290
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_773291 = header.getOrDefault("x-amzn-iot-principal")
  valid_773291 = validateParameter(valid_773291, JString, required = true,
                                 default = nil)
  if valid_773291 != nil:
    section.add "x-amzn-iot-principal", valid_773291
  var valid_773292 = header.getOrDefault("X-Amz-Credential")
  valid_773292 = validateParameter(valid_773292, JString, required = false,
                                 default = nil)
  if valid_773292 != nil:
    section.add "X-Amz-Credential", valid_773292
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773293: Call_AttachPrincipalPolicy_773281; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ## 
  let valid = call_773293.validator(path, query, header, formData, body)
  let scheme = call_773293.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773293.url(scheme.get, call_773293.host, call_773293.base,
                         call_773293.route, valid.getOrDefault("path"))
  result = hook(call_773293, url, valid)

proc call*(call_773294: Call_AttachPrincipalPolicy_773281; policyName: string): Recallable =
  ## attachPrincipalPolicy
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ##   policyName: string (required)
  ##             : The policy name.
  var path_773295 = newJObject()
  add(path_773295, "policyName", newJString(policyName))
  result = call_773294.call(path_773295, nil, nil, nil, nil)

var attachPrincipalPolicy* = Call_AttachPrincipalPolicy_773281(
    name: "attachPrincipalPolicy", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/principal-policies/{policyName}#x-amzn-iot-principal",
    validator: validate_AttachPrincipalPolicy_773282, base: "/",
    url: url_AttachPrincipalPolicy_773283, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachPrincipalPolicy_773296 = ref object of OpenApiRestCall_772597
proc url_DetachPrincipalPolicy_773298(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/principal-policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "#x-amzn-iot-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DetachPrincipalPolicy_773297(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to detach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_773299 = path.getOrDefault("policyName")
  valid_773299 = validateParameter(valid_773299, JString, required = true,
                                 default = nil)
  if valid_773299 != nil:
    section.add "policyName", valid_773299
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : <p>The principal.</p> <p>If the principal is a certificate, specify the certificate ARN. If the principal is an Amazon Cognito identity, specify the identity ID.</p>
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773300 = header.getOrDefault("X-Amz-Date")
  valid_773300 = validateParameter(valid_773300, JString, required = false,
                                 default = nil)
  if valid_773300 != nil:
    section.add "X-Amz-Date", valid_773300
  var valid_773301 = header.getOrDefault("X-Amz-Security-Token")
  valid_773301 = validateParameter(valid_773301, JString, required = false,
                                 default = nil)
  if valid_773301 != nil:
    section.add "X-Amz-Security-Token", valid_773301
  var valid_773302 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773302 = validateParameter(valid_773302, JString, required = false,
                                 default = nil)
  if valid_773302 != nil:
    section.add "X-Amz-Content-Sha256", valid_773302
  var valid_773303 = header.getOrDefault("X-Amz-Algorithm")
  valid_773303 = validateParameter(valid_773303, JString, required = false,
                                 default = nil)
  if valid_773303 != nil:
    section.add "X-Amz-Algorithm", valid_773303
  var valid_773304 = header.getOrDefault("X-Amz-Signature")
  valid_773304 = validateParameter(valid_773304, JString, required = false,
                                 default = nil)
  if valid_773304 != nil:
    section.add "X-Amz-Signature", valid_773304
  var valid_773305 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773305 = validateParameter(valid_773305, JString, required = false,
                                 default = nil)
  if valid_773305 != nil:
    section.add "X-Amz-SignedHeaders", valid_773305
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_773306 = header.getOrDefault("x-amzn-iot-principal")
  valid_773306 = validateParameter(valid_773306, JString, required = true,
                                 default = nil)
  if valid_773306 != nil:
    section.add "x-amzn-iot-principal", valid_773306
  var valid_773307 = header.getOrDefault("X-Amz-Credential")
  valid_773307 = validateParameter(valid_773307, JString, required = false,
                                 default = nil)
  if valid_773307 != nil:
    section.add "X-Amz-Credential", valid_773307
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773308: Call_DetachPrincipalPolicy_773296; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ## 
  let valid = call_773308.validator(path, query, header, formData, body)
  let scheme = call_773308.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773308.url(scheme.get, call_773308.host, call_773308.base,
                         call_773308.route, valid.getOrDefault("path"))
  result = hook(call_773308, url, valid)

proc call*(call_773309: Call_DetachPrincipalPolicy_773296; policyName: string): Recallable =
  ## detachPrincipalPolicy
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ##   policyName: string (required)
  ##             : The name of the policy to detach.
  var path_773310 = newJObject()
  add(path_773310, "policyName", newJString(policyName))
  result = call_773309.call(path_773310, nil, nil, nil, nil)

var detachPrincipalPolicy* = Call_DetachPrincipalPolicy_773296(
    name: "detachPrincipalPolicy", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/principal-policies/{policyName}#x-amzn-iot-principal",
    validator: validate_DetachPrincipalPolicy_773297, base: "/",
    url: url_DetachPrincipalPolicy_773298, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachSecurityProfile_773311 = ref object of OpenApiRestCall_772597
proc url_AttachSecurityProfile_773313(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"), (
        kind: ConstantSegment, value: "/targets#securityProfileTargetArn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_AttachSecurityProfile_773312(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile that is attached.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_773314 = path.getOrDefault("securityProfileName")
  valid_773314 = validateParameter(valid_773314, JString, required = true,
                                 default = nil)
  if valid_773314 != nil:
    section.add "securityProfileName", valid_773314
  result.add "path", section
  ## parameters in `query` object:
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the target (thing group) to which the security profile is attached.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_773315 = query.getOrDefault("securityProfileTargetArn")
  valid_773315 = validateParameter(valid_773315, JString, required = true,
                                 default = nil)
  if valid_773315 != nil:
    section.add "securityProfileTargetArn", valid_773315
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773316 = header.getOrDefault("X-Amz-Date")
  valid_773316 = validateParameter(valid_773316, JString, required = false,
                                 default = nil)
  if valid_773316 != nil:
    section.add "X-Amz-Date", valid_773316
  var valid_773317 = header.getOrDefault("X-Amz-Security-Token")
  valid_773317 = validateParameter(valid_773317, JString, required = false,
                                 default = nil)
  if valid_773317 != nil:
    section.add "X-Amz-Security-Token", valid_773317
  var valid_773318 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773318 = validateParameter(valid_773318, JString, required = false,
                                 default = nil)
  if valid_773318 != nil:
    section.add "X-Amz-Content-Sha256", valid_773318
  var valid_773319 = header.getOrDefault("X-Amz-Algorithm")
  valid_773319 = validateParameter(valid_773319, JString, required = false,
                                 default = nil)
  if valid_773319 != nil:
    section.add "X-Amz-Algorithm", valid_773319
  var valid_773320 = header.getOrDefault("X-Amz-Signature")
  valid_773320 = validateParameter(valid_773320, JString, required = false,
                                 default = nil)
  if valid_773320 != nil:
    section.add "X-Amz-Signature", valid_773320
  var valid_773321 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773321 = validateParameter(valid_773321, JString, required = false,
                                 default = nil)
  if valid_773321 != nil:
    section.add "X-Amz-SignedHeaders", valid_773321
  var valid_773322 = header.getOrDefault("X-Amz-Credential")
  valid_773322 = validateParameter(valid_773322, JString, required = false,
                                 default = nil)
  if valid_773322 != nil:
    section.add "X-Amz-Credential", valid_773322
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773323: Call_AttachSecurityProfile_773311; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ## 
  let valid = call_773323.validator(path, query, header, formData, body)
  let scheme = call_773323.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773323.url(scheme.get, call_773323.host, call_773323.base,
                         call_773323.route, valid.getOrDefault("path"))
  result = hook(call_773323, url, valid)

proc call*(call_773324: Call_AttachSecurityProfile_773311;
          securityProfileTargetArn: string; securityProfileName: string): Recallable =
  ## attachSecurityProfile
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the target (thing group) to which the security profile is attached.
  ##   securityProfileName: string (required)
  ##                      : The security profile that is attached.
  var path_773325 = newJObject()
  var query_773326 = newJObject()
  add(query_773326, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(path_773325, "securityProfileName", newJString(securityProfileName))
  result = call_773324.call(path_773325, query_773326, nil, nil, nil)

var attachSecurityProfile* = Call_AttachSecurityProfile_773311(
    name: "attachSecurityProfile", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}/targets#securityProfileTargetArn",
    validator: validate_AttachSecurityProfile_773312, base: "/",
    url: url_AttachSecurityProfile_773313, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachSecurityProfile_773327 = ref object of OpenApiRestCall_772597
proc url_DetachSecurityProfile_773329(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"), (
        kind: ConstantSegment, value: "/targets#securityProfileTargetArn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DetachSecurityProfile_773328(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile that is detached.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_773330 = path.getOrDefault("securityProfileName")
  valid_773330 = validateParameter(valid_773330, JString, required = true,
                                 default = nil)
  if valid_773330 != nil:
    section.add "securityProfileName", valid_773330
  result.add "path", section
  ## parameters in `query` object:
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the thing group from which the security profile is detached.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_773331 = query.getOrDefault("securityProfileTargetArn")
  valid_773331 = validateParameter(valid_773331, JString, required = true,
                                 default = nil)
  if valid_773331 != nil:
    section.add "securityProfileTargetArn", valid_773331
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773332 = header.getOrDefault("X-Amz-Date")
  valid_773332 = validateParameter(valid_773332, JString, required = false,
                                 default = nil)
  if valid_773332 != nil:
    section.add "X-Amz-Date", valid_773332
  var valid_773333 = header.getOrDefault("X-Amz-Security-Token")
  valid_773333 = validateParameter(valid_773333, JString, required = false,
                                 default = nil)
  if valid_773333 != nil:
    section.add "X-Amz-Security-Token", valid_773333
  var valid_773334 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773334 = validateParameter(valid_773334, JString, required = false,
                                 default = nil)
  if valid_773334 != nil:
    section.add "X-Amz-Content-Sha256", valid_773334
  var valid_773335 = header.getOrDefault("X-Amz-Algorithm")
  valid_773335 = validateParameter(valid_773335, JString, required = false,
                                 default = nil)
  if valid_773335 != nil:
    section.add "X-Amz-Algorithm", valid_773335
  var valid_773336 = header.getOrDefault("X-Amz-Signature")
  valid_773336 = validateParameter(valid_773336, JString, required = false,
                                 default = nil)
  if valid_773336 != nil:
    section.add "X-Amz-Signature", valid_773336
  var valid_773337 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773337 = validateParameter(valid_773337, JString, required = false,
                                 default = nil)
  if valid_773337 != nil:
    section.add "X-Amz-SignedHeaders", valid_773337
  var valid_773338 = header.getOrDefault("X-Amz-Credential")
  valid_773338 = validateParameter(valid_773338, JString, required = false,
                                 default = nil)
  if valid_773338 != nil:
    section.add "X-Amz-Credential", valid_773338
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773339: Call_DetachSecurityProfile_773327; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ## 
  let valid = call_773339.validator(path, query, header, formData, body)
  let scheme = call_773339.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773339.url(scheme.get, call_773339.host, call_773339.base,
                         call_773339.route, valid.getOrDefault("path"))
  result = hook(call_773339, url, valid)

proc call*(call_773340: Call_DetachSecurityProfile_773327;
          securityProfileTargetArn: string; securityProfileName: string): Recallable =
  ## detachSecurityProfile
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the thing group from which the security profile is detached.
  ##   securityProfileName: string (required)
  ##                      : The security profile that is detached.
  var path_773341 = newJObject()
  var query_773342 = newJObject()
  add(query_773342, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(path_773341, "securityProfileName", newJString(securityProfileName))
  result = call_773340.call(path_773341, query_773342, nil, nil, nil)

var detachSecurityProfile* = Call_DetachSecurityProfile_773327(
    name: "detachSecurityProfile", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}/targets#securityProfileTargetArn",
    validator: validate_DetachSecurityProfile_773328, base: "/",
    url: url_DetachSecurityProfile_773329, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachThingPrincipal_773343 = ref object of OpenApiRestCall_772597
proc url_AttachThingPrincipal_773345(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals#x-amzn-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_AttachThingPrincipal_773344(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_773346 = path.getOrDefault("thingName")
  valid_773346 = validateParameter(valid_773346, JString, required = true,
                                 default = nil)
  if valid_773346 != nil:
    section.add "thingName", valid_773346
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : The principal, such as a certificate or other credential.
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773347 = header.getOrDefault("X-Amz-Date")
  valid_773347 = validateParameter(valid_773347, JString, required = false,
                                 default = nil)
  if valid_773347 != nil:
    section.add "X-Amz-Date", valid_773347
  var valid_773348 = header.getOrDefault("X-Amz-Security-Token")
  valid_773348 = validateParameter(valid_773348, JString, required = false,
                                 default = nil)
  if valid_773348 != nil:
    section.add "X-Amz-Security-Token", valid_773348
  var valid_773349 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773349 = validateParameter(valid_773349, JString, required = false,
                                 default = nil)
  if valid_773349 != nil:
    section.add "X-Amz-Content-Sha256", valid_773349
  var valid_773350 = header.getOrDefault("X-Amz-Algorithm")
  valid_773350 = validateParameter(valid_773350, JString, required = false,
                                 default = nil)
  if valid_773350 != nil:
    section.add "X-Amz-Algorithm", valid_773350
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_773351 = header.getOrDefault("x-amzn-principal")
  valid_773351 = validateParameter(valid_773351, JString, required = true,
                                 default = nil)
  if valid_773351 != nil:
    section.add "x-amzn-principal", valid_773351
  var valid_773352 = header.getOrDefault("X-Amz-Signature")
  valid_773352 = validateParameter(valid_773352, JString, required = false,
                                 default = nil)
  if valid_773352 != nil:
    section.add "X-Amz-Signature", valid_773352
  var valid_773353 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773353 = validateParameter(valid_773353, JString, required = false,
                                 default = nil)
  if valid_773353 != nil:
    section.add "X-Amz-SignedHeaders", valid_773353
  var valid_773354 = header.getOrDefault("X-Amz-Credential")
  valid_773354 = validateParameter(valid_773354, JString, required = false,
                                 default = nil)
  if valid_773354 != nil:
    section.add "X-Amz-Credential", valid_773354
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773355: Call_AttachThingPrincipal_773343; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  let valid = call_773355.validator(path, query, header, formData, body)
  let scheme = call_773355.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773355.url(scheme.get, call_773355.host, call_773355.base,
                         call_773355.route, valid.getOrDefault("path"))
  result = hook(call_773355, url, valid)

proc call*(call_773356: Call_AttachThingPrincipal_773343; thingName: string): Recallable =
  ## attachThingPrincipal
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_773357 = newJObject()
  add(path_773357, "thingName", newJString(thingName))
  result = call_773356.call(path_773357, nil, nil, nil, nil)

var attachThingPrincipal* = Call_AttachThingPrincipal_773343(
    name: "attachThingPrincipal", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/things/{thingName}/principals#x-amzn-principal",
    validator: validate_AttachThingPrincipal_773344, base: "/",
    url: url_AttachThingPrincipal_773345, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachThingPrincipal_773358 = ref object of OpenApiRestCall_772597
proc url_DetachThingPrincipal_773360(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals#x-amzn-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DetachThingPrincipal_773359(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_773361 = path.getOrDefault("thingName")
  valid_773361 = validateParameter(valid_773361, JString, required = true,
                                 default = nil)
  if valid_773361 != nil:
    section.add "thingName", valid_773361
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773362 = header.getOrDefault("X-Amz-Date")
  valid_773362 = validateParameter(valid_773362, JString, required = false,
                                 default = nil)
  if valid_773362 != nil:
    section.add "X-Amz-Date", valid_773362
  var valid_773363 = header.getOrDefault("X-Amz-Security-Token")
  valid_773363 = validateParameter(valid_773363, JString, required = false,
                                 default = nil)
  if valid_773363 != nil:
    section.add "X-Amz-Security-Token", valid_773363
  var valid_773364 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773364 = validateParameter(valid_773364, JString, required = false,
                                 default = nil)
  if valid_773364 != nil:
    section.add "X-Amz-Content-Sha256", valid_773364
  var valid_773365 = header.getOrDefault("X-Amz-Algorithm")
  valid_773365 = validateParameter(valid_773365, JString, required = false,
                                 default = nil)
  if valid_773365 != nil:
    section.add "X-Amz-Algorithm", valid_773365
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_773366 = header.getOrDefault("x-amzn-principal")
  valid_773366 = validateParameter(valid_773366, JString, required = true,
                                 default = nil)
  if valid_773366 != nil:
    section.add "x-amzn-principal", valid_773366
  var valid_773367 = header.getOrDefault("X-Amz-Signature")
  valid_773367 = validateParameter(valid_773367, JString, required = false,
                                 default = nil)
  if valid_773367 != nil:
    section.add "X-Amz-Signature", valid_773367
  var valid_773368 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773368 = validateParameter(valid_773368, JString, required = false,
                                 default = nil)
  if valid_773368 != nil:
    section.add "X-Amz-SignedHeaders", valid_773368
  var valid_773369 = header.getOrDefault("X-Amz-Credential")
  valid_773369 = validateParameter(valid_773369, JString, required = false,
                                 default = nil)
  if valid_773369 != nil:
    section.add "X-Amz-Credential", valid_773369
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773370: Call_DetachThingPrincipal_773358; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ## 
  let valid = call_773370.validator(path, query, header, formData, body)
  let scheme = call_773370.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773370.url(scheme.get, call_773370.host, call_773370.base,
                         call_773370.route, valid.getOrDefault("path"))
  result = hook(call_773370, url, valid)

proc call*(call_773371: Call_DetachThingPrincipal_773358; thingName: string): Recallable =
  ## detachThingPrincipal
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_773372 = newJObject()
  add(path_773372, "thingName", newJString(thingName))
  result = call_773371.call(path_773372, nil, nil, nil, nil)

var detachThingPrincipal* = Call_DetachThingPrincipal_773358(
    name: "detachThingPrincipal", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/things/{thingName}/principals#x-amzn-principal",
    validator: validate_DetachThingPrincipal_773359, base: "/",
    url: url_DetachThingPrincipal_773360, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelAuditMitigationActionsTask_773373 = ref object of OpenApiRestCall_772597
proc url_CancelAuditMitigationActionsTask_773375(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CancelAuditMitigationActionsTask_773374(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The unique identifier for the task that you want to cancel. 
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_773376 = path.getOrDefault("taskId")
  valid_773376 = validateParameter(valid_773376, JString, required = true,
                                 default = nil)
  if valid_773376 != nil:
    section.add "taskId", valid_773376
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773377 = header.getOrDefault("X-Amz-Date")
  valid_773377 = validateParameter(valid_773377, JString, required = false,
                                 default = nil)
  if valid_773377 != nil:
    section.add "X-Amz-Date", valid_773377
  var valid_773378 = header.getOrDefault("X-Amz-Security-Token")
  valid_773378 = validateParameter(valid_773378, JString, required = false,
                                 default = nil)
  if valid_773378 != nil:
    section.add "X-Amz-Security-Token", valid_773378
  var valid_773379 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773379 = validateParameter(valid_773379, JString, required = false,
                                 default = nil)
  if valid_773379 != nil:
    section.add "X-Amz-Content-Sha256", valid_773379
  var valid_773380 = header.getOrDefault("X-Amz-Algorithm")
  valid_773380 = validateParameter(valid_773380, JString, required = false,
                                 default = nil)
  if valid_773380 != nil:
    section.add "X-Amz-Algorithm", valid_773380
  var valid_773381 = header.getOrDefault("X-Amz-Signature")
  valid_773381 = validateParameter(valid_773381, JString, required = false,
                                 default = nil)
  if valid_773381 != nil:
    section.add "X-Amz-Signature", valid_773381
  var valid_773382 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773382 = validateParameter(valid_773382, JString, required = false,
                                 default = nil)
  if valid_773382 != nil:
    section.add "X-Amz-SignedHeaders", valid_773382
  var valid_773383 = header.getOrDefault("X-Amz-Credential")
  valid_773383 = validateParameter(valid_773383, JString, required = false,
                                 default = nil)
  if valid_773383 != nil:
    section.add "X-Amz-Credential", valid_773383
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773384: Call_CancelAuditMitigationActionsTask_773373;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ## 
  let valid = call_773384.validator(path, query, header, formData, body)
  let scheme = call_773384.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773384.url(scheme.get, call_773384.host, call_773384.base,
                         call_773384.route, valid.getOrDefault("path"))
  result = hook(call_773384, url, valid)

proc call*(call_773385: Call_CancelAuditMitigationActionsTask_773373;
          taskId: string): Recallable =
  ## cancelAuditMitigationActionsTask
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ##   taskId: string (required)
  ##         : The unique identifier for the task that you want to cancel. 
  var path_773386 = newJObject()
  add(path_773386, "taskId", newJString(taskId))
  result = call_773385.call(path_773386, nil, nil, nil, nil)

var cancelAuditMitigationActionsTask* = Call_CancelAuditMitigationActionsTask_773373(
    name: "cancelAuditMitigationActionsTask", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/tasks/{taskId}/cancel",
    validator: validate_CancelAuditMitigationActionsTask_773374, base: "/",
    url: url_CancelAuditMitigationActionsTask_773375,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelAuditTask_773387 = ref object of OpenApiRestCall_772597
proc url_CancelAuditTask_773389(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CancelAuditTask_773388(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_773390 = path.getOrDefault("taskId")
  valid_773390 = validateParameter(valid_773390, JString, required = true,
                                 default = nil)
  if valid_773390 != nil:
    section.add "taskId", valid_773390
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773391 = header.getOrDefault("X-Amz-Date")
  valid_773391 = validateParameter(valid_773391, JString, required = false,
                                 default = nil)
  if valid_773391 != nil:
    section.add "X-Amz-Date", valid_773391
  var valid_773392 = header.getOrDefault("X-Amz-Security-Token")
  valid_773392 = validateParameter(valid_773392, JString, required = false,
                                 default = nil)
  if valid_773392 != nil:
    section.add "X-Amz-Security-Token", valid_773392
  var valid_773393 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773393 = validateParameter(valid_773393, JString, required = false,
                                 default = nil)
  if valid_773393 != nil:
    section.add "X-Amz-Content-Sha256", valid_773393
  var valid_773394 = header.getOrDefault("X-Amz-Algorithm")
  valid_773394 = validateParameter(valid_773394, JString, required = false,
                                 default = nil)
  if valid_773394 != nil:
    section.add "X-Amz-Algorithm", valid_773394
  var valid_773395 = header.getOrDefault("X-Amz-Signature")
  valid_773395 = validateParameter(valid_773395, JString, required = false,
                                 default = nil)
  if valid_773395 != nil:
    section.add "X-Amz-Signature", valid_773395
  var valid_773396 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773396 = validateParameter(valid_773396, JString, required = false,
                                 default = nil)
  if valid_773396 != nil:
    section.add "X-Amz-SignedHeaders", valid_773396
  var valid_773397 = header.getOrDefault("X-Amz-Credential")
  valid_773397 = validateParameter(valid_773397, JString, required = false,
                                 default = nil)
  if valid_773397 != nil:
    section.add "X-Amz-Credential", valid_773397
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773398: Call_CancelAuditTask_773387; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ## 
  let valid = call_773398.validator(path, query, header, formData, body)
  let scheme = call_773398.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773398.url(scheme.get, call_773398.host, call_773398.base,
                         call_773398.route, valid.getOrDefault("path"))
  result = hook(call_773398, url, valid)

proc call*(call_773399: Call_CancelAuditTask_773387; taskId: string): Recallable =
  ## cancelAuditTask
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ##   taskId: string (required)
  ##         : The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
  var path_773400 = newJObject()
  add(path_773400, "taskId", newJString(taskId))
  result = call_773399.call(path_773400, nil, nil, nil, nil)

var cancelAuditTask* = Call_CancelAuditTask_773387(name: "cancelAuditTask",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/audit/tasks/{taskId}/cancel", validator: validate_CancelAuditTask_773388,
    base: "/", url: url_CancelAuditTask_773389, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelCertificateTransfer_773401 = ref object of OpenApiRestCall_772597
proc url_CancelCertificateTransfer_773403(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cancel-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CancelCertificateTransfer_773402(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_773404 = path.getOrDefault("certificateId")
  valid_773404 = validateParameter(valid_773404, JString, required = true,
                                 default = nil)
  if valid_773404 != nil:
    section.add "certificateId", valid_773404
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773405 = header.getOrDefault("X-Amz-Date")
  valid_773405 = validateParameter(valid_773405, JString, required = false,
                                 default = nil)
  if valid_773405 != nil:
    section.add "X-Amz-Date", valid_773405
  var valid_773406 = header.getOrDefault("X-Amz-Security-Token")
  valid_773406 = validateParameter(valid_773406, JString, required = false,
                                 default = nil)
  if valid_773406 != nil:
    section.add "X-Amz-Security-Token", valid_773406
  var valid_773407 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773407 = validateParameter(valid_773407, JString, required = false,
                                 default = nil)
  if valid_773407 != nil:
    section.add "X-Amz-Content-Sha256", valid_773407
  var valid_773408 = header.getOrDefault("X-Amz-Algorithm")
  valid_773408 = validateParameter(valid_773408, JString, required = false,
                                 default = nil)
  if valid_773408 != nil:
    section.add "X-Amz-Algorithm", valid_773408
  var valid_773409 = header.getOrDefault("X-Amz-Signature")
  valid_773409 = validateParameter(valid_773409, JString, required = false,
                                 default = nil)
  if valid_773409 != nil:
    section.add "X-Amz-Signature", valid_773409
  var valid_773410 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773410 = validateParameter(valid_773410, JString, required = false,
                                 default = nil)
  if valid_773410 != nil:
    section.add "X-Amz-SignedHeaders", valid_773410
  var valid_773411 = header.getOrDefault("X-Amz-Credential")
  valid_773411 = validateParameter(valid_773411, JString, required = false,
                                 default = nil)
  if valid_773411 != nil:
    section.add "X-Amz-Credential", valid_773411
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773412: Call_CancelCertificateTransfer_773401; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ## 
  let valid = call_773412.validator(path, query, header, formData, body)
  let scheme = call_773412.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773412.url(scheme.get, call_773412.host, call_773412.base,
                         call_773412.route, valid.getOrDefault("path"))
  result = hook(call_773412, url, valid)

proc call*(call_773413: Call_CancelCertificateTransfer_773401;
          certificateId: string): Recallable =
  ## cancelCertificateTransfer
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_773414 = newJObject()
  add(path_773414, "certificateId", newJString(certificateId))
  result = call_773413.call(path_773414, nil, nil, nil, nil)

var cancelCertificateTransfer* = Call_CancelCertificateTransfer_773401(
    name: "cancelCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/cancel-certificate-transfer/{certificateId}",
    validator: validate_CancelCertificateTransfer_773402, base: "/",
    url: url_CancelCertificateTransfer_773403,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelJob_773415 = ref object of OpenApiRestCall_772597
proc url_CancelJob_773417(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CancelJob_773416(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_773418 = path.getOrDefault("jobId")
  valid_773418 = validateParameter(valid_773418, JString, required = true,
                                 default = nil)
  if valid_773418 != nil:
    section.add "jobId", valid_773418
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
  section = newJObject()
  var valid_773419 = query.getOrDefault("force")
  valid_773419 = validateParameter(valid_773419, JBool, required = false, default = nil)
  if valid_773419 != nil:
    section.add "force", valid_773419
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773420 = header.getOrDefault("X-Amz-Date")
  valid_773420 = validateParameter(valid_773420, JString, required = false,
                                 default = nil)
  if valid_773420 != nil:
    section.add "X-Amz-Date", valid_773420
  var valid_773421 = header.getOrDefault("X-Amz-Security-Token")
  valid_773421 = validateParameter(valid_773421, JString, required = false,
                                 default = nil)
  if valid_773421 != nil:
    section.add "X-Amz-Security-Token", valid_773421
  var valid_773422 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773422 = validateParameter(valid_773422, JString, required = false,
                                 default = nil)
  if valid_773422 != nil:
    section.add "X-Amz-Content-Sha256", valid_773422
  var valid_773423 = header.getOrDefault("X-Amz-Algorithm")
  valid_773423 = validateParameter(valid_773423, JString, required = false,
                                 default = nil)
  if valid_773423 != nil:
    section.add "X-Amz-Algorithm", valid_773423
  var valid_773424 = header.getOrDefault("X-Amz-Signature")
  valid_773424 = validateParameter(valid_773424, JString, required = false,
                                 default = nil)
  if valid_773424 != nil:
    section.add "X-Amz-Signature", valid_773424
  var valid_773425 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773425 = validateParameter(valid_773425, JString, required = false,
                                 default = nil)
  if valid_773425 != nil:
    section.add "X-Amz-SignedHeaders", valid_773425
  var valid_773426 = header.getOrDefault("X-Amz-Credential")
  valid_773426 = validateParameter(valid_773426, JString, required = false,
                                 default = nil)
  if valid_773426 != nil:
    section.add "X-Amz-Credential", valid_773426
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773428: Call_CancelJob_773415; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a job.
  ## 
  let valid = call_773428.validator(path, query, header, formData, body)
  let scheme = call_773428.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773428.url(scheme.get, call_773428.host, call_773428.base,
                         call_773428.route, valid.getOrDefault("path"))
  result = hook(call_773428, url, valid)

proc call*(call_773429: Call_CancelJob_773415; jobId: string; body: JsonNode;
          force: bool = false): Recallable =
  ## cancelJob
  ## Cancels a job.
  ##   force: bool
  ##        : <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   body: JObject (required)
  var path_773430 = newJObject()
  var query_773431 = newJObject()
  var body_773432 = newJObject()
  add(query_773431, "force", newJBool(force))
  add(path_773430, "jobId", newJString(jobId))
  if body != nil:
    body_773432 = body
  result = call_773429.call(path_773430, query_773431, nil, nil, body_773432)

var cancelJob* = Call_CancelJob_773415(name: "cancelJob", meth: HttpMethod.HttpPut,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}/cancel",
                                    validator: validate_CancelJob_773416,
                                    base: "/", url: url_CancelJob_773417,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelJobExecution_773433 = ref object of OpenApiRestCall_772597
proc url_CancelJobExecution_773435(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CancelJobExecution_773434(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Cancels the execution of a job for a given thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing whose execution of the job will be canceled.
  ##   jobId: JString (required)
  ##        : The ID of the job to be canceled.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_773436 = path.getOrDefault("thingName")
  valid_773436 = validateParameter(valid_773436, JString, required = true,
                                 default = nil)
  if valid_773436 != nil:
    section.add "thingName", valid_773436
  var valid_773437 = path.getOrDefault("jobId")
  valid_773437 = validateParameter(valid_773437, JString, required = true,
                                 default = nil)
  if valid_773437 != nil:
    section.add "jobId", valid_773437
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
  section = newJObject()
  var valid_773438 = query.getOrDefault("force")
  valid_773438 = validateParameter(valid_773438, JBool, required = false, default = nil)
  if valid_773438 != nil:
    section.add "force", valid_773438
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773439 = header.getOrDefault("X-Amz-Date")
  valid_773439 = validateParameter(valid_773439, JString, required = false,
                                 default = nil)
  if valid_773439 != nil:
    section.add "X-Amz-Date", valid_773439
  var valid_773440 = header.getOrDefault("X-Amz-Security-Token")
  valid_773440 = validateParameter(valid_773440, JString, required = false,
                                 default = nil)
  if valid_773440 != nil:
    section.add "X-Amz-Security-Token", valid_773440
  var valid_773441 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773441 = validateParameter(valid_773441, JString, required = false,
                                 default = nil)
  if valid_773441 != nil:
    section.add "X-Amz-Content-Sha256", valid_773441
  var valid_773442 = header.getOrDefault("X-Amz-Algorithm")
  valid_773442 = validateParameter(valid_773442, JString, required = false,
                                 default = nil)
  if valid_773442 != nil:
    section.add "X-Amz-Algorithm", valid_773442
  var valid_773443 = header.getOrDefault("X-Amz-Signature")
  valid_773443 = validateParameter(valid_773443, JString, required = false,
                                 default = nil)
  if valid_773443 != nil:
    section.add "X-Amz-Signature", valid_773443
  var valid_773444 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773444 = validateParameter(valid_773444, JString, required = false,
                                 default = nil)
  if valid_773444 != nil:
    section.add "X-Amz-SignedHeaders", valid_773444
  var valid_773445 = header.getOrDefault("X-Amz-Credential")
  valid_773445 = validateParameter(valid_773445, JString, required = false,
                                 default = nil)
  if valid_773445 != nil:
    section.add "X-Amz-Credential", valid_773445
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773447: Call_CancelJobExecution_773433; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels the execution of a job for a given thing.
  ## 
  let valid = call_773447.validator(path, query, header, formData, body)
  let scheme = call_773447.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773447.url(scheme.get, call_773447.host, call_773447.base,
                         call_773447.route, valid.getOrDefault("path"))
  result = hook(call_773447, url, valid)

proc call*(call_773448: Call_CancelJobExecution_773433; thingName: string;
          jobId: string; body: JsonNode; force: bool = false): Recallable =
  ## cancelJobExecution
  ## Cancels the execution of a job for a given thing.
  ##   force: bool
  ##        : <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
  ##   thingName: string (required)
  ##            : The name of the thing whose execution of the job will be canceled.
  ##   jobId: string (required)
  ##        : The ID of the job to be canceled.
  ##   body: JObject (required)
  var path_773449 = newJObject()
  var query_773450 = newJObject()
  var body_773451 = newJObject()
  add(query_773450, "force", newJBool(force))
  add(path_773449, "thingName", newJString(thingName))
  add(path_773449, "jobId", newJString(jobId))
  if body != nil:
    body_773451 = body
  result = call_773448.call(path_773449, query_773450, nil, nil, body_773451)

var cancelJobExecution* = Call_CancelJobExecution_773433(
    name: "cancelJobExecution", meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/things/{thingName}/jobs/{jobId}/cancel",
    validator: validate_CancelJobExecution_773434, base: "/",
    url: url_CancelJobExecution_773435, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetDefaultAuthorizer_773464 = ref object of OpenApiRestCall_772597
proc url_SetDefaultAuthorizer_773466(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_SetDefaultAuthorizer_773465(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773467 = header.getOrDefault("X-Amz-Date")
  valid_773467 = validateParameter(valid_773467, JString, required = false,
                                 default = nil)
  if valid_773467 != nil:
    section.add "X-Amz-Date", valid_773467
  var valid_773468 = header.getOrDefault("X-Amz-Security-Token")
  valid_773468 = validateParameter(valid_773468, JString, required = false,
                                 default = nil)
  if valid_773468 != nil:
    section.add "X-Amz-Security-Token", valid_773468
  var valid_773469 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773469 = validateParameter(valid_773469, JString, required = false,
                                 default = nil)
  if valid_773469 != nil:
    section.add "X-Amz-Content-Sha256", valid_773469
  var valid_773470 = header.getOrDefault("X-Amz-Algorithm")
  valid_773470 = validateParameter(valid_773470, JString, required = false,
                                 default = nil)
  if valid_773470 != nil:
    section.add "X-Amz-Algorithm", valid_773470
  var valid_773471 = header.getOrDefault("X-Amz-Signature")
  valid_773471 = validateParameter(valid_773471, JString, required = false,
                                 default = nil)
  if valid_773471 != nil:
    section.add "X-Amz-Signature", valid_773471
  var valid_773472 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773472 = validateParameter(valid_773472, JString, required = false,
                                 default = nil)
  if valid_773472 != nil:
    section.add "X-Amz-SignedHeaders", valid_773472
  var valid_773473 = header.getOrDefault("X-Amz-Credential")
  valid_773473 = validateParameter(valid_773473, JString, required = false,
                                 default = nil)
  if valid_773473 != nil:
    section.add "X-Amz-Credential", valid_773473
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773475: Call_SetDefaultAuthorizer_773464; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ## 
  let valid = call_773475.validator(path, query, header, formData, body)
  let scheme = call_773475.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773475.url(scheme.get, call_773475.host, call_773475.base,
                         call_773475.route, valid.getOrDefault("path"))
  result = hook(call_773475, url, valid)

proc call*(call_773476: Call_SetDefaultAuthorizer_773464; body: JsonNode): Recallable =
  ## setDefaultAuthorizer
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ##   body: JObject (required)
  var body_773477 = newJObject()
  if body != nil:
    body_773477 = body
  result = call_773476.call(nil, nil, nil, nil, body_773477)

var setDefaultAuthorizer* = Call_SetDefaultAuthorizer_773464(
    name: "setDefaultAuthorizer", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_SetDefaultAuthorizer_773465, base: "/",
    url: url_SetDefaultAuthorizer_773466, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeDefaultAuthorizer_773452 = ref object of OpenApiRestCall_772597
proc url_DescribeDefaultAuthorizer_773454(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_DescribeDefaultAuthorizer_773453(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes the default authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773455 = header.getOrDefault("X-Amz-Date")
  valid_773455 = validateParameter(valid_773455, JString, required = false,
                                 default = nil)
  if valid_773455 != nil:
    section.add "X-Amz-Date", valid_773455
  var valid_773456 = header.getOrDefault("X-Amz-Security-Token")
  valid_773456 = validateParameter(valid_773456, JString, required = false,
                                 default = nil)
  if valid_773456 != nil:
    section.add "X-Amz-Security-Token", valid_773456
  var valid_773457 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773457 = validateParameter(valid_773457, JString, required = false,
                                 default = nil)
  if valid_773457 != nil:
    section.add "X-Amz-Content-Sha256", valid_773457
  var valid_773458 = header.getOrDefault("X-Amz-Algorithm")
  valid_773458 = validateParameter(valid_773458, JString, required = false,
                                 default = nil)
  if valid_773458 != nil:
    section.add "X-Amz-Algorithm", valid_773458
  var valid_773459 = header.getOrDefault("X-Amz-Signature")
  valid_773459 = validateParameter(valid_773459, JString, required = false,
                                 default = nil)
  if valid_773459 != nil:
    section.add "X-Amz-Signature", valid_773459
  var valid_773460 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773460 = validateParameter(valid_773460, JString, required = false,
                                 default = nil)
  if valid_773460 != nil:
    section.add "X-Amz-SignedHeaders", valid_773460
  var valid_773461 = header.getOrDefault("X-Amz-Credential")
  valid_773461 = validateParameter(valid_773461, JString, required = false,
                                 default = nil)
  if valid_773461 != nil:
    section.add "X-Amz-Credential", valid_773461
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773462: Call_DescribeDefaultAuthorizer_773452; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes the default authorizer.
  ## 
  let valid = call_773462.validator(path, query, header, formData, body)
  let scheme = call_773462.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773462.url(scheme.get, call_773462.host, call_773462.base,
                         call_773462.route, valid.getOrDefault("path"))
  result = hook(call_773462, url, valid)

proc call*(call_773463: Call_DescribeDefaultAuthorizer_773452): Recallable =
  ## describeDefaultAuthorizer
  ## Describes the default authorizer.
  result = call_773463.call(nil, nil, nil, nil, nil)

var describeDefaultAuthorizer* = Call_DescribeDefaultAuthorizer_773452(
    name: "describeDefaultAuthorizer", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_DescribeDefaultAuthorizer_773453, base: "/",
    url: url_DescribeDefaultAuthorizer_773454,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ClearDefaultAuthorizer_773478 = ref object of OpenApiRestCall_772597
proc url_ClearDefaultAuthorizer_773480(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ClearDefaultAuthorizer_773479(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Clears the default authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773481 = header.getOrDefault("X-Amz-Date")
  valid_773481 = validateParameter(valid_773481, JString, required = false,
                                 default = nil)
  if valid_773481 != nil:
    section.add "X-Amz-Date", valid_773481
  var valid_773482 = header.getOrDefault("X-Amz-Security-Token")
  valid_773482 = validateParameter(valid_773482, JString, required = false,
                                 default = nil)
  if valid_773482 != nil:
    section.add "X-Amz-Security-Token", valid_773482
  var valid_773483 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773483 = validateParameter(valid_773483, JString, required = false,
                                 default = nil)
  if valid_773483 != nil:
    section.add "X-Amz-Content-Sha256", valid_773483
  var valid_773484 = header.getOrDefault("X-Amz-Algorithm")
  valid_773484 = validateParameter(valid_773484, JString, required = false,
                                 default = nil)
  if valid_773484 != nil:
    section.add "X-Amz-Algorithm", valid_773484
  var valid_773485 = header.getOrDefault("X-Amz-Signature")
  valid_773485 = validateParameter(valid_773485, JString, required = false,
                                 default = nil)
  if valid_773485 != nil:
    section.add "X-Amz-Signature", valid_773485
  var valid_773486 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773486 = validateParameter(valid_773486, JString, required = false,
                                 default = nil)
  if valid_773486 != nil:
    section.add "X-Amz-SignedHeaders", valid_773486
  var valid_773487 = header.getOrDefault("X-Amz-Credential")
  valid_773487 = validateParameter(valid_773487, JString, required = false,
                                 default = nil)
  if valid_773487 != nil:
    section.add "X-Amz-Credential", valid_773487
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773488: Call_ClearDefaultAuthorizer_773478; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Clears the default authorizer.
  ## 
  let valid = call_773488.validator(path, query, header, formData, body)
  let scheme = call_773488.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773488.url(scheme.get, call_773488.host, call_773488.base,
                         call_773488.route, valid.getOrDefault("path"))
  result = hook(call_773488, url, valid)

proc call*(call_773489: Call_ClearDefaultAuthorizer_773478): Recallable =
  ## clearDefaultAuthorizer
  ## Clears the default authorizer.
  result = call_773489.call(nil, nil, nil, nil, nil)

var clearDefaultAuthorizer* = Call_ClearDefaultAuthorizer_773478(
    name: "clearDefaultAuthorizer", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_ClearDefaultAuthorizer_773479, base: "/",
    url: url_ClearDefaultAuthorizer_773480, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateAuthorizer_773504 = ref object of OpenApiRestCall_772597
proc url_UpdateAuthorizer_773506(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_UpdateAuthorizer_773505(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Updates an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_773507 = path.getOrDefault("authorizerName")
  valid_773507 = validateParameter(valid_773507, JString, required = true,
                                 default = nil)
  if valid_773507 != nil:
    section.add "authorizerName", valid_773507
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773508 = header.getOrDefault("X-Amz-Date")
  valid_773508 = validateParameter(valid_773508, JString, required = false,
                                 default = nil)
  if valid_773508 != nil:
    section.add "X-Amz-Date", valid_773508
  var valid_773509 = header.getOrDefault("X-Amz-Security-Token")
  valid_773509 = validateParameter(valid_773509, JString, required = false,
                                 default = nil)
  if valid_773509 != nil:
    section.add "X-Amz-Security-Token", valid_773509
  var valid_773510 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773510 = validateParameter(valid_773510, JString, required = false,
                                 default = nil)
  if valid_773510 != nil:
    section.add "X-Amz-Content-Sha256", valid_773510
  var valid_773511 = header.getOrDefault("X-Amz-Algorithm")
  valid_773511 = validateParameter(valid_773511, JString, required = false,
                                 default = nil)
  if valid_773511 != nil:
    section.add "X-Amz-Algorithm", valid_773511
  var valid_773512 = header.getOrDefault("X-Amz-Signature")
  valid_773512 = validateParameter(valid_773512, JString, required = false,
                                 default = nil)
  if valid_773512 != nil:
    section.add "X-Amz-Signature", valid_773512
  var valid_773513 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773513 = validateParameter(valid_773513, JString, required = false,
                                 default = nil)
  if valid_773513 != nil:
    section.add "X-Amz-SignedHeaders", valid_773513
  var valid_773514 = header.getOrDefault("X-Amz-Credential")
  valid_773514 = validateParameter(valid_773514, JString, required = false,
                                 default = nil)
  if valid_773514 != nil:
    section.add "X-Amz-Credential", valid_773514
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773516: Call_UpdateAuthorizer_773504; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an authorizer.
  ## 
  let valid = call_773516.validator(path, query, header, formData, body)
  let scheme = call_773516.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773516.url(scheme.get, call_773516.host, call_773516.base,
                         call_773516.route, valid.getOrDefault("path"))
  result = hook(call_773516, url, valid)

proc call*(call_773517: Call_UpdateAuthorizer_773504; authorizerName: string;
          body: JsonNode): Recallable =
  ## updateAuthorizer
  ## Updates an authorizer.
  ##   authorizerName: string (required)
  ##                 : The authorizer name.
  ##   body: JObject (required)
  var path_773518 = newJObject()
  var body_773519 = newJObject()
  add(path_773518, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_773519 = body
  result = call_773517.call(path_773518, nil, nil, nil, body_773519)

var updateAuthorizer* = Call_UpdateAuthorizer_773504(name: "updateAuthorizer",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_UpdateAuthorizer_773505,
    base: "/", url: url_UpdateAuthorizer_773506,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateAuthorizer_773520 = ref object of OpenApiRestCall_772597
proc url_CreateAuthorizer_773522(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CreateAuthorizer_773521(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Creates an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_773523 = path.getOrDefault("authorizerName")
  valid_773523 = validateParameter(valid_773523, JString, required = true,
                                 default = nil)
  if valid_773523 != nil:
    section.add "authorizerName", valid_773523
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773524 = header.getOrDefault("X-Amz-Date")
  valid_773524 = validateParameter(valid_773524, JString, required = false,
                                 default = nil)
  if valid_773524 != nil:
    section.add "X-Amz-Date", valid_773524
  var valid_773525 = header.getOrDefault("X-Amz-Security-Token")
  valid_773525 = validateParameter(valid_773525, JString, required = false,
                                 default = nil)
  if valid_773525 != nil:
    section.add "X-Amz-Security-Token", valid_773525
  var valid_773526 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773526 = validateParameter(valid_773526, JString, required = false,
                                 default = nil)
  if valid_773526 != nil:
    section.add "X-Amz-Content-Sha256", valid_773526
  var valid_773527 = header.getOrDefault("X-Amz-Algorithm")
  valid_773527 = validateParameter(valid_773527, JString, required = false,
                                 default = nil)
  if valid_773527 != nil:
    section.add "X-Amz-Algorithm", valid_773527
  var valid_773528 = header.getOrDefault("X-Amz-Signature")
  valid_773528 = validateParameter(valid_773528, JString, required = false,
                                 default = nil)
  if valid_773528 != nil:
    section.add "X-Amz-Signature", valid_773528
  var valid_773529 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773529 = validateParameter(valid_773529, JString, required = false,
                                 default = nil)
  if valid_773529 != nil:
    section.add "X-Amz-SignedHeaders", valid_773529
  var valid_773530 = header.getOrDefault("X-Amz-Credential")
  valid_773530 = validateParameter(valid_773530, JString, required = false,
                                 default = nil)
  if valid_773530 != nil:
    section.add "X-Amz-Credential", valid_773530
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773532: Call_CreateAuthorizer_773520; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates an authorizer.
  ## 
  let valid = call_773532.validator(path, query, header, formData, body)
  let scheme = call_773532.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773532.url(scheme.get, call_773532.host, call_773532.base,
                         call_773532.route, valid.getOrDefault("path"))
  result = hook(call_773532, url, valid)

proc call*(call_773533: Call_CreateAuthorizer_773520; authorizerName: string;
          body: JsonNode): Recallable =
  ## createAuthorizer
  ## Creates an authorizer.
  ##   authorizerName: string (required)
  ##                 : The authorizer name.
  ##   body: JObject (required)
  var path_773534 = newJObject()
  var body_773535 = newJObject()
  add(path_773534, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_773535 = body
  result = call_773533.call(path_773534, nil, nil, nil, body_773535)

var createAuthorizer* = Call_CreateAuthorizer_773520(name: "createAuthorizer",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_CreateAuthorizer_773521,
    base: "/", url: url_CreateAuthorizer_773522,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuthorizer_773490 = ref object of OpenApiRestCall_772597
proc url_DescribeAuthorizer_773492(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeAuthorizer_773491(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Describes an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The name of the authorizer to describe.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_773493 = path.getOrDefault("authorizerName")
  valid_773493 = validateParameter(valid_773493, JString, required = true,
                                 default = nil)
  if valid_773493 != nil:
    section.add "authorizerName", valid_773493
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773494 = header.getOrDefault("X-Amz-Date")
  valid_773494 = validateParameter(valid_773494, JString, required = false,
                                 default = nil)
  if valid_773494 != nil:
    section.add "X-Amz-Date", valid_773494
  var valid_773495 = header.getOrDefault("X-Amz-Security-Token")
  valid_773495 = validateParameter(valid_773495, JString, required = false,
                                 default = nil)
  if valid_773495 != nil:
    section.add "X-Amz-Security-Token", valid_773495
  var valid_773496 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773496 = validateParameter(valid_773496, JString, required = false,
                                 default = nil)
  if valid_773496 != nil:
    section.add "X-Amz-Content-Sha256", valid_773496
  var valid_773497 = header.getOrDefault("X-Amz-Algorithm")
  valid_773497 = validateParameter(valid_773497, JString, required = false,
                                 default = nil)
  if valid_773497 != nil:
    section.add "X-Amz-Algorithm", valid_773497
  var valid_773498 = header.getOrDefault("X-Amz-Signature")
  valid_773498 = validateParameter(valid_773498, JString, required = false,
                                 default = nil)
  if valid_773498 != nil:
    section.add "X-Amz-Signature", valid_773498
  var valid_773499 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773499 = validateParameter(valid_773499, JString, required = false,
                                 default = nil)
  if valid_773499 != nil:
    section.add "X-Amz-SignedHeaders", valid_773499
  var valid_773500 = header.getOrDefault("X-Amz-Credential")
  valid_773500 = validateParameter(valid_773500, JString, required = false,
                                 default = nil)
  if valid_773500 != nil:
    section.add "X-Amz-Credential", valid_773500
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773501: Call_DescribeAuthorizer_773490; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes an authorizer.
  ## 
  let valid = call_773501.validator(path, query, header, formData, body)
  let scheme = call_773501.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773501.url(scheme.get, call_773501.host, call_773501.base,
                         call_773501.route, valid.getOrDefault("path"))
  result = hook(call_773501, url, valid)

proc call*(call_773502: Call_DescribeAuthorizer_773490; authorizerName: string): Recallable =
  ## describeAuthorizer
  ## Describes an authorizer.
  ##   authorizerName: string (required)
  ##                 : The name of the authorizer to describe.
  var path_773503 = newJObject()
  add(path_773503, "authorizerName", newJString(authorizerName))
  result = call_773502.call(path_773503, nil, nil, nil, nil)

var describeAuthorizer* = Call_DescribeAuthorizer_773490(
    name: "describeAuthorizer", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_DescribeAuthorizer_773491,
    base: "/", url: url_DescribeAuthorizer_773492,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteAuthorizer_773536 = ref object of OpenApiRestCall_772597
proc url_DeleteAuthorizer_773538(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteAuthorizer_773537(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Deletes an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The name of the authorizer to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_773539 = path.getOrDefault("authorizerName")
  valid_773539 = validateParameter(valid_773539, JString, required = true,
                                 default = nil)
  if valid_773539 != nil:
    section.add "authorizerName", valid_773539
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773540 = header.getOrDefault("X-Amz-Date")
  valid_773540 = validateParameter(valid_773540, JString, required = false,
                                 default = nil)
  if valid_773540 != nil:
    section.add "X-Amz-Date", valid_773540
  var valid_773541 = header.getOrDefault("X-Amz-Security-Token")
  valid_773541 = validateParameter(valid_773541, JString, required = false,
                                 default = nil)
  if valid_773541 != nil:
    section.add "X-Amz-Security-Token", valid_773541
  var valid_773542 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773542 = validateParameter(valid_773542, JString, required = false,
                                 default = nil)
  if valid_773542 != nil:
    section.add "X-Amz-Content-Sha256", valid_773542
  var valid_773543 = header.getOrDefault("X-Amz-Algorithm")
  valid_773543 = validateParameter(valid_773543, JString, required = false,
                                 default = nil)
  if valid_773543 != nil:
    section.add "X-Amz-Algorithm", valid_773543
  var valid_773544 = header.getOrDefault("X-Amz-Signature")
  valid_773544 = validateParameter(valid_773544, JString, required = false,
                                 default = nil)
  if valid_773544 != nil:
    section.add "X-Amz-Signature", valid_773544
  var valid_773545 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773545 = validateParameter(valid_773545, JString, required = false,
                                 default = nil)
  if valid_773545 != nil:
    section.add "X-Amz-SignedHeaders", valid_773545
  var valid_773546 = header.getOrDefault("X-Amz-Credential")
  valid_773546 = validateParameter(valid_773546, JString, required = false,
                                 default = nil)
  if valid_773546 != nil:
    section.add "X-Amz-Credential", valid_773546
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773547: Call_DeleteAuthorizer_773536; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an authorizer.
  ## 
  let valid = call_773547.validator(path, query, header, formData, body)
  let scheme = call_773547.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773547.url(scheme.get, call_773547.host, call_773547.base,
                         call_773547.route, valid.getOrDefault("path"))
  result = hook(call_773547, url, valid)

proc call*(call_773548: Call_DeleteAuthorizer_773536; authorizerName: string): Recallable =
  ## deleteAuthorizer
  ## Deletes an authorizer.
  ##   authorizerName: string (required)
  ##                 : The name of the authorizer to delete.
  var path_773549 = newJObject()
  add(path_773549, "authorizerName", newJString(authorizerName))
  result = call_773548.call(path_773549, nil, nil, nil, nil)

var deleteAuthorizer* = Call_DeleteAuthorizer_773536(name: "deleteAuthorizer",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_DeleteAuthorizer_773537,
    base: "/", url: url_DeleteAuthorizer_773538,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateBillingGroup_773564 = ref object of OpenApiRestCall_772597
proc url_CreateBillingGroup_773566(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CreateBillingGroup_773565(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Creates a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name you wish to give to the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_773567 = path.getOrDefault("billingGroupName")
  valid_773567 = validateParameter(valid_773567, JString, required = true,
                                 default = nil)
  if valid_773567 != nil:
    section.add "billingGroupName", valid_773567
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773568 = header.getOrDefault("X-Amz-Date")
  valid_773568 = validateParameter(valid_773568, JString, required = false,
                                 default = nil)
  if valid_773568 != nil:
    section.add "X-Amz-Date", valid_773568
  var valid_773569 = header.getOrDefault("X-Amz-Security-Token")
  valid_773569 = validateParameter(valid_773569, JString, required = false,
                                 default = nil)
  if valid_773569 != nil:
    section.add "X-Amz-Security-Token", valid_773569
  var valid_773570 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773570 = validateParameter(valid_773570, JString, required = false,
                                 default = nil)
  if valid_773570 != nil:
    section.add "X-Amz-Content-Sha256", valid_773570
  var valid_773571 = header.getOrDefault("X-Amz-Algorithm")
  valid_773571 = validateParameter(valid_773571, JString, required = false,
                                 default = nil)
  if valid_773571 != nil:
    section.add "X-Amz-Algorithm", valid_773571
  var valid_773572 = header.getOrDefault("X-Amz-Signature")
  valid_773572 = validateParameter(valid_773572, JString, required = false,
                                 default = nil)
  if valid_773572 != nil:
    section.add "X-Amz-Signature", valid_773572
  var valid_773573 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773573 = validateParameter(valid_773573, JString, required = false,
                                 default = nil)
  if valid_773573 != nil:
    section.add "X-Amz-SignedHeaders", valid_773573
  var valid_773574 = header.getOrDefault("X-Amz-Credential")
  valid_773574 = validateParameter(valid_773574, JString, required = false,
                                 default = nil)
  if valid_773574 != nil:
    section.add "X-Amz-Credential", valid_773574
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773576: Call_CreateBillingGroup_773564; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a billing group.
  ## 
  let valid = call_773576.validator(path, query, header, formData, body)
  let scheme = call_773576.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773576.url(scheme.get, call_773576.host, call_773576.base,
                         call_773576.route, valid.getOrDefault("path"))
  result = hook(call_773576, url, valid)

proc call*(call_773577: Call_CreateBillingGroup_773564; billingGroupName: string;
          body: JsonNode): Recallable =
  ## createBillingGroup
  ## Creates a billing group.
  ##   billingGroupName: string (required)
  ##                   : The name you wish to give to the billing group.
  ##   body: JObject (required)
  var path_773578 = newJObject()
  var body_773579 = newJObject()
  add(path_773578, "billingGroupName", newJString(billingGroupName))
  if body != nil:
    body_773579 = body
  result = call_773577.call(path_773578, nil, nil, nil, body_773579)

var createBillingGroup* = Call_CreateBillingGroup_773564(
    name: "createBillingGroup", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_CreateBillingGroup_773565, base: "/",
    url: url_CreateBillingGroup_773566, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeBillingGroup_773550 = ref object of OpenApiRestCall_772597
proc url_DescribeBillingGroup_773552(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeBillingGroup_773551(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_773553 = path.getOrDefault("billingGroupName")
  valid_773553 = validateParameter(valid_773553, JString, required = true,
                                 default = nil)
  if valid_773553 != nil:
    section.add "billingGroupName", valid_773553
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773554 = header.getOrDefault("X-Amz-Date")
  valid_773554 = validateParameter(valid_773554, JString, required = false,
                                 default = nil)
  if valid_773554 != nil:
    section.add "X-Amz-Date", valid_773554
  var valid_773555 = header.getOrDefault("X-Amz-Security-Token")
  valid_773555 = validateParameter(valid_773555, JString, required = false,
                                 default = nil)
  if valid_773555 != nil:
    section.add "X-Amz-Security-Token", valid_773555
  var valid_773556 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773556 = validateParameter(valid_773556, JString, required = false,
                                 default = nil)
  if valid_773556 != nil:
    section.add "X-Amz-Content-Sha256", valid_773556
  var valid_773557 = header.getOrDefault("X-Amz-Algorithm")
  valid_773557 = validateParameter(valid_773557, JString, required = false,
                                 default = nil)
  if valid_773557 != nil:
    section.add "X-Amz-Algorithm", valid_773557
  var valid_773558 = header.getOrDefault("X-Amz-Signature")
  valid_773558 = validateParameter(valid_773558, JString, required = false,
                                 default = nil)
  if valid_773558 != nil:
    section.add "X-Amz-Signature", valid_773558
  var valid_773559 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773559 = validateParameter(valid_773559, JString, required = false,
                                 default = nil)
  if valid_773559 != nil:
    section.add "X-Amz-SignedHeaders", valid_773559
  var valid_773560 = header.getOrDefault("X-Amz-Credential")
  valid_773560 = validateParameter(valid_773560, JString, required = false,
                                 default = nil)
  if valid_773560 != nil:
    section.add "X-Amz-Credential", valid_773560
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773561: Call_DescribeBillingGroup_773550; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about a billing group.
  ## 
  let valid = call_773561.validator(path, query, header, formData, body)
  let scheme = call_773561.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773561.url(scheme.get, call_773561.host, call_773561.base,
                         call_773561.route, valid.getOrDefault("path"))
  result = hook(call_773561, url, valid)

proc call*(call_773562: Call_DescribeBillingGroup_773550; billingGroupName: string): Recallable =
  ## describeBillingGroup
  ## Returns information about a billing group.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_773563 = newJObject()
  add(path_773563, "billingGroupName", newJString(billingGroupName))
  result = call_773562.call(path_773563, nil, nil, nil, nil)

var describeBillingGroup* = Call_DescribeBillingGroup_773550(
    name: "describeBillingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_DescribeBillingGroup_773551, base: "/",
    url: url_DescribeBillingGroup_773552, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateBillingGroup_773596 = ref object of OpenApiRestCall_772597
proc url_UpdateBillingGroup_773598(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_UpdateBillingGroup_773597(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Updates information about the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_773599 = path.getOrDefault("billingGroupName")
  valid_773599 = validateParameter(valid_773599, JString, required = true,
                                 default = nil)
  if valid_773599 != nil:
    section.add "billingGroupName", valid_773599
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773600 = header.getOrDefault("X-Amz-Date")
  valid_773600 = validateParameter(valid_773600, JString, required = false,
                                 default = nil)
  if valid_773600 != nil:
    section.add "X-Amz-Date", valid_773600
  var valid_773601 = header.getOrDefault("X-Amz-Security-Token")
  valid_773601 = validateParameter(valid_773601, JString, required = false,
                                 default = nil)
  if valid_773601 != nil:
    section.add "X-Amz-Security-Token", valid_773601
  var valid_773602 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773602 = validateParameter(valid_773602, JString, required = false,
                                 default = nil)
  if valid_773602 != nil:
    section.add "X-Amz-Content-Sha256", valid_773602
  var valid_773603 = header.getOrDefault("X-Amz-Algorithm")
  valid_773603 = validateParameter(valid_773603, JString, required = false,
                                 default = nil)
  if valid_773603 != nil:
    section.add "X-Amz-Algorithm", valid_773603
  var valid_773604 = header.getOrDefault("X-Amz-Signature")
  valid_773604 = validateParameter(valid_773604, JString, required = false,
                                 default = nil)
  if valid_773604 != nil:
    section.add "X-Amz-Signature", valid_773604
  var valid_773605 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773605 = validateParameter(valid_773605, JString, required = false,
                                 default = nil)
  if valid_773605 != nil:
    section.add "X-Amz-SignedHeaders", valid_773605
  var valid_773606 = header.getOrDefault("X-Amz-Credential")
  valid_773606 = validateParameter(valid_773606, JString, required = false,
                                 default = nil)
  if valid_773606 != nil:
    section.add "X-Amz-Credential", valid_773606
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773608: Call_UpdateBillingGroup_773596; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates information about the billing group.
  ## 
  let valid = call_773608.validator(path, query, header, formData, body)
  let scheme = call_773608.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773608.url(scheme.get, call_773608.host, call_773608.base,
                         call_773608.route, valid.getOrDefault("path"))
  result = hook(call_773608, url, valid)

proc call*(call_773609: Call_UpdateBillingGroup_773596; billingGroupName: string;
          body: JsonNode): Recallable =
  ## updateBillingGroup
  ## Updates information about the billing group.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  ##   body: JObject (required)
  var path_773610 = newJObject()
  var body_773611 = newJObject()
  add(path_773610, "billingGroupName", newJString(billingGroupName))
  if body != nil:
    body_773611 = body
  result = call_773609.call(path_773610, nil, nil, nil, body_773611)

var updateBillingGroup* = Call_UpdateBillingGroup_773596(
    name: "updateBillingGroup", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_UpdateBillingGroup_773597, base: "/",
    url: url_UpdateBillingGroup_773598, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteBillingGroup_773580 = ref object of OpenApiRestCall_772597
proc url_DeleteBillingGroup_773582(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteBillingGroup_773581(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deletes the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_773583 = path.getOrDefault("billingGroupName")
  valid_773583 = validateParameter(valid_773583, JString, required = true,
                                 default = nil)
  if valid_773583 != nil:
    section.add "billingGroupName", valid_773583
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.
  section = newJObject()
  var valid_773584 = query.getOrDefault("expectedVersion")
  valid_773584 = validateParameter(valid_773584, JInt, required = false, default = nil)
  if valid_773584 != nil:
    section.add "expectedVersion", valid_773584
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773585 = header.getOrDefault("X-Amz-Date")
  valid_773585 = validateParameter(valid_773585, JString, required = false,
                                 default = nil)
  if valid_773585 != nil:
    section.add "X-Amz-Date", valid_773585
  var valid_773586 = header.getOrDefault("X-Amz-Security-Token")
  valid_773586 = validateParameter(valid_773586, JString, required = false,
                                 default = nil)
  if valid_773586 != nil:
    section.add "X-Amz-Security-Token", valid_773586
  var valid_773587 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773587 = validateParameter(valid_773587, JString, required = false,
                                 default = nil)
  if valid_773587 != nil:
    section.add "X-Amz-Content-Sha256", valid_773587
  var valid_773588 = header.getOrDefault("X-Amz-Algorithm")
  valid_773588 = validateParameter(valid_773588, JString, required = false,
                                 default = nil)
  if valid_773588 != nil:
    section.add "X-Amz-Algorithm", valid_773588
  var valid_773589 = header.getOrDefault("X-Amz-Signature")
  valid_773589 = validateParameter(valid_773589, JString, required = false,
                                 default = nil)
  if valid_773589 != nil:
    section.add "X-Amz-Signature", valid_773589
  var valid_773590 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773590 = validateParameter(valid_773590, JString, required = false,
                                 default = nil)
  if valid_773590 != nil:
    section.add "X-Amz-SignedHeaders", valid_773590
  var valid_773591 = header.getOrDefault("X-Amz-Credential")
  valid_773591 = validateParameter(valid_773591, JString, required = false,
                                 default = nil)
  if valid_773591 != nil:
    section.add "X-Amz-Credential", valid_773591
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773592: Call_DeleteBillingGroup_773580; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the billing group.
  ## 
  let valid = call_773592.validator(path, query, header, formData, body)
  let scheme = call_773592.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773592.url(scheme.get, call_773592.host, call_773592.base,
                         call_773592.route, valid.getOrDefault("path"))
  result = hook(call_773592, url, valid)

proc call*(call_773593: Call_DeleteBillingGroup_773580; billingGroupName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteBillingGroup
  ## Deletes the billing group.
  ##   expectedVersion: int
  ##                  : The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_773594 = newJObject()
  var query_773595 = newJObject()
  add(query_773595, "expectedVersion", newJInt(expectedVersion))
  add(path_773594, "billingGroupName", newJString(billingGroupName))
  result = call_773593.call(path_773594, query_773595, nil, nil, nil)

var deleteBillingGroup* = Call_DeleteBillingGroup_773580(
    name: "deleteBillingGroup", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_DeleteBillingGroup_773581, base: "/",
    url: url_DeleteBillingGroup_773582, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateCertificateFromCsr_773628 = ref object of OpenApiRestCall_772597
proc url_CreateCertificateFromCsr_773630(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_CreateCertificateFromCsr_773629(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_773631 = query.getOrDefault("setAsActive")
  valid_773631 = validateParameter(valid_773631, JBool, required = false, default = nil)
  if valid_773631 != nil:
    section.add "setAsActive", valid_773631
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773632 = header.getOrDefault("X-Amz-Date")
  valid_773632 = validateParameter(valid_773632, JString, required = false,
                                 default = nil)
  if valid_773632 != nil:
    section.add "X-Amz-Date", valid_773632
  var valid_773633 = header.getOrDefault("X-Amz-Security-Token")
  valid_773633 = validateParameter(valid_773633, JString, required = false,
                                 default = nil)
  if valid_773633 != nil:
    section.add "X-Amz-Security-Token", valid_773633
  var valid_773634 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773634 = validateParameter(valid_773634, JString, required = false,
                                 default = nil)
  if valid_773634 != nil:
    section.add "X-Amz-Content-Sha256", valid_773634
  var valid_773635 = header.getOrDefault("X-Amz-Algorithm")
  valid_773635 = validateParameter(valid_773635, JString, required = false,
                                 default = nil)
  if valid_773635 != nil:
    section.add "X-Amz-Algorithm", valid_773635
  var valid_773636 = header.getOrDefault("X-Amz-Signature")
  valid_773636 = validateParameter(valid_773636, JString, required = false,
                                 default = nil)
  if valid_773636 != nil:
    section.add "X-Amz-Signature", valid_773636
  var valid_773637 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773637 = validateParameter(valid_773637, JString, required = false,
                                 default = nil)
  if valid_773637 != nil:
    section.add "X-Amz-SignedHeaders", valid_773637
  var valid_773638 = header.getOrDefault("X-Amz-Credential")
  valid_773638 = validateParameter(valid_773638, JString, required = false,
                                 default = nil)
  if valid_773638 != nil:
    section.add "X-Amz-Credential", valid_773638
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773640: Call_CreateCertificateFromCsr_773628; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ## 
  let valid = call_773640.validator(path, query, header, formData, body)
  let scheme = call_773640.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773640.url(scheme.get, call_773640.host, call_773640.base,
                         call_773640.route, valid.getOrDefault("path"))
  result = hook(call_773640, url, valid)

proc call*(call_773641: Call_CreateCertificateFromCsr_773628; body: JsonNode;
          setAsActive: bool = false): Recallable =
  ## createCertificateFromCsr
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  ##   body: JObject (required)
  var query_773642 = newJObject()
  var body_773643 = newJObject()
  add(query_773642, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_773643 = body
  result = call_773641.call(nil, query_773642, nil, nil, body_773643)

var createCertificateFromCsr* = Call_CreateCertificateFromCsr_773628(
    name: "createCertificateFromCsr", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/certificates",
    validator: validate_CreateCertificateFromCsr_773629, base: "/",
    url: url_CreateCertificateFromCsr_773630, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCertificates_773612 = ref object of OpenApiRestCall_772597
proc url_ListCertificates_773614(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListCertificates_773613(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  section = newJObject()
  var valid_773615 = query.getOrDefault("marker")
  valid_773615 = validateParameter(valid_773615, JString, required = false,
                                 default = nil)
  if valid_773615 != nil:
    section.add "marker", valid_773615
  var valid_773616 = query.getOrDefault("pageSize")
  valid_773616 = validateParameter(valid_773616, JInt, required = false, default = nil)
  if valid_773616 != nil:
    section.add "pageSize", valid_773616
  var valid_773617 = query.getOrDefault("isAscendingOrder")
  valid_773617 = validateParameter(valid_773617, JBool, required = false, default = nil)
  if valid_773617 != nil:
    section.add "isAscendingOrder", valid_773617
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773618 = header.getOrDefault("X-Amz-Date")
  valid_773618 = validateParameter(valid_773618, JString, required = false,
                                 default = nil)
  if valid_773618 != nil:
    section.add "X-Amz-Date", valid_773618
  var valid_773619 = header.getOrDefault("X-Amz-Security-Token")
  valid_773619 = validateParameter(valid_773619, JString, required = false,
                                 default = nil)
  if valid_773619 != nil:
    section.add "X-Amz-Security-Token", valid_773619
  var valid_773620 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773620 = validateParameter(valid_773620, JString, required = false,
                                 default = nil)
  if valid_773620 != nil:
    section.add "X-Amz-Content-Sha256", valid_773620
  var valid_773621 = header.getOrDefault("X-Amz-Algorithm")
  valid_773621 = validateParameter(valid_773621, JString, required = false,
                                 default = nil)
  if valid_773621 != nil:
    section.add "X-Amz-Algorithm", valid_773621
  var valid_773622 = header.getOrDefault("X-Amz-Signature")
  valid_773622 = validateParameter(valid_773622, JString, required = false,
                                 default = nil)
  if valid_773622 != nil:
    section.add "X-Amz-Signature", valid_773622
  var valid_773623 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773623 = validateParameter(valid_773623, JString, required = false,
                                 default = nil)
  if valid_773623 != nil:
    section.add "X-Amz-SignedHeaders", valid_773623
  var valid_773624 = header.getOrDefault("X-Amz-Credential")
  valid_773624 = validateParameter(valid_773624, JString, required = false,
                                 default = nil)
  if valid_773624 != nil:
    section.add "X-Amz-Credential", valid_773624
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773625: Call_ListCertificates_773612; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  let valid = call_773625.validator(path, query, header, formData, body)
  let scheme = call_773625.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773625.url(scheme.get, call_773625.host, call_773625.base,
                         call_773625.route, valid.getOrDefault("path"))
  result = hook(call_773625, url, valid)

proc call*(call_773626: Call_ListCertificates_773612; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listCertificates
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  var query_773627 = newJObject()
  add(query_773627, "marker", newJString(marker))
  add(query_773627, "pageSize", newJInt(pageSize))
  add(query_773627, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_773626.call(nil, query_773627, nil, nil, nil)

var listCertificates* = Call_ListCertificates_773612(name: "listCertificates",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/certificates",
    validator: validate_ListCertificates_773613, base: "/",
    url: url_ListCertificates_773614, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateDynamicThingGroup_773644 = ref object of OpenApiRestCall_772597
proc url_CreateDynamicThingGroup_773646(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CreateDynamicThingGroup_773645(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The dynamic thing group name to create.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_773647 = path.getOrDefault("thingGroupName")
  valid_773647 = validateParameter(valid_773647, JString, required = true,
                                 default = nil)
  if valid_773647 != nil:
    section.add "thingGroupName", valid_773647
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773648 = header.getOrDefault("X-Amz-Date")
  valid_773648 = validateParameter(valid_773648, JString, required = false,
                                 default = nil)
  if valid_773648 != nil:
    section.add "X-Amz-Date", valid_773648
  var valid_773649 = header.getOrDefault("X-Amz-Security-Token")
  valid_773649 = validateParameter(valid_773649, JString, required = false,
                                 default = nil)
  if valid_773649 != nil:
    section.add "X-Amz-Security-Token", valid_773649
  var valid_773650 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773650 = validateParameter(valid_773650, JString, required = false,
                                 default = nil)
  if valid_773650 != nil:
    section.add "X-Amz-Content-Sha256", valid_773650
  var valid_773651 = header.getOrDefault("X-Amz-Algorithm")
  valid_773651 = validateParameter(valid_773651, JString, required = false,
                                 default = nil)
  if valid_773651 != nil:
    section.add "X-Amz-Algorithm", valid_773651
  var valid_773652 = header.getOrDefault("X-Amz-Signature")
  valid_773652 = validateParameter(valid_773652, JString, required = false,
                                 default = nil)
  if valid_773652 != nil:
    section.add "X-Amz-Signature", valid_773652
  var valid_773653 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773653 = validateParameter(valid_773653, JString, required = false,
                                 default = nil)
  if valid_773653 != nil:
    section.add "X-Amz-SignedHeaders", valid_773653
  var valid_773654 = header.getOrDefault("X-Amz-Credential")
  valid_773654 = validateParameter(valid_773654, JString, required = false,
                                 default = nil)
  if valid_773654 != nil:
    section.add "X-Amz-Credential", valid_773654
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773656: Call_CreateDynamicThingGroup_773644; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a dynamic thing group.
  ## 
  let valid = call_773656.validator(path, query, header, formData, body)
  let scheme = call_773656.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773656.url(scheme.get, call_773656.host, call_773656.base,
                         call_773656.route, valid.getOrDefault("path"))
  result = hook(call_773656, url, valid)

proc call*(call_773657: Call_CreateDynamicThingGroup_773644; body: JsonNode;
          thingGroupName: string): Recallable =
  ## createDynamicThingGroup
  ## Creates a dynamic thing group.
  ##   body: JObject (required)
  ##   thingGroupName: string (required)
  ##                 : The dynamic thing group name to create.
  var path_773658 = newJObject()
  var body_773659 = newJObject()
  if body != nil:
    body_773659 = body
  add(path_773658, "thingGroupName", newJString(thingGroupName))
  result = call_773657.call(path_773658, nil, nil, nil, body_773659)

var createDynamicThingGroup* = Call_CreateDynamicThingGroup_773644(
    name: "createDynamicThingGroup", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_CreateDynamicThingGroup_773645, base: "/",
    url: url_CreateDynamicThingGroup_773646, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateDynamicThingGroup_773676 = ref object of OpenApiRestCall_772597
proc url_UpdateDynamicThingGroup_773678(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_UpdateDynamicThingGroup_773677(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the dynamic thing group to update.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_773679 = path.getOrDefault("thingGroupName")
  valid_773679 = validateParameter(valid_773679, JString, required = true,
                                 default = nil)
  if valid_773679 != nil:
    section.add "thingGroupName", valid_773679
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773680 = header.getOrDefault("X-Amz-Date")
  valid_773680 = validateParameter(valid_773680, JString, required = false,
                                 default = nil)
  if valid_773680 != nil:
    section.add "X-Amz-Date", valid_773680
  var valid_773681 = header.getOrDefault("X-Amz-Security-Token")
  valid_773681 = validateParameter(valid_773681, JString, required = false,
                                 default = nil)
  if valid_773681 != nil:
    section.add "X-Amz-Security-Token", valid_773681
  var valid_773682 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773682 = validateParameter(valid_773682, JString, required = false,
                                 default = nil)
  if valid_773682 != nil:
    section.add "X-Amz-Content-Sha256", valid_773682
  var valid_773683 = header.getOrDefault("X-Amz-Algorithm")
  valid_773683 = validateParameter(valid_773683, JString, required = false,
                                 default = nil)
  if valid_773683 != nil:
    section.add "X-Amz-Algorithm", valid_773683
  var valid_773684 = header.getOrDefault("X-Amz-Signature")
  valid_773684 = validateParameter(valid_773684, JString, required = false,
                                 default = nil)
  if valid_773684 != nil:
    section.add "X-Amz-Signature", valid_773684
  var valid_773685 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773685 = validateParameter(valid_773685, JString, required = false,
                                 default = nil)
  if valid_773685 != nil:
    section.add "X-Amz-SignedHeaders", valid_773685
  var valid_773686 = header.getOrDefault("X-Amz-Credential")
  valid_773686 = validateParameter(valid_773686, JString, required = false,
                                 default = nil)
  if valid_773686 != nil:
    section.add "X-Amz-Credential", valid_773686
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773688: Call_UpdateDynamicThingGroup_773676; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a dynamic thing group.
  ## 
  let valid = call_773688.validator(path, query, header, formData, body)
  let scheme = call_773688.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773688.url(scheme.get, call_773688.host, call_773688.base,
                         call_773688.route, valid.getOrDefault("path"))
  result = hook(call_773688, url, valid)

proc call*(call_773689: Call_UpdateDynamicThingGroup_773676; body: JsonNode;
          thingGroupName: string): Recallable =
  ## updateDynamicThingGroup
  ## Updates a dynamic thing group.
  ##   body: JObject (required)
  ##   thingGroupName: string (required)
  ##                 : The name of the dynamic thing group to update.
  var path_773690 = newJObject()
  var body_773691 = newJObject()
  if body != nil:
    body_773691 = body
  add(path_773690, "thingGroupName", newJString(thingGroupName))
  result = call_773689.call(path_773690, nil, nil, nil, body_773691)

var updateDynamicThingGroup* = Call_UpdateDynamicThingGroup_773676(
    name: "updateDynamicThingGroup", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_UpdateDynamicThingGroup_773677, base: "/",
    url: url_UpdateDynamicThingGroup_773678, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteDynamicThingGroup_773660 = ref object of OpenApiRestCall_772597
proc url_DeleteDynamicThingGroup_773662(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteDynamicThingGroup_773661(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the dynamic thing group to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_773663 = path.getOrDefault("thingGroupName")
  valid_773663 = validateParameter(valid_773663, JString, required = true,
                                 default = nil)
  if valid_773663 != nil:
    section.add "thingGroupName", valid_773663
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the dynamic thing group to delete.
  section = newJObject()
  var valid_773664 = query.getOrDefault("expectedVersion")
  valid_773664 = validateParameter(valid_773664, JInt, required = false, default = nil)
  if valid_773664 != nil:
    section.add "expectedVersion", valid_773664
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773665 = header.getOrDefault("X-Amz-Date")
  valid_773665 = validateParameter(valid_773665, JString, required = false,
                                 default = nil)
  if valid_773665 != nil:
    section.add "X-Amz-Date", valid_773665
  var valid_773666 = header.getOrDefault("X-Amz-Security-Token")
  valid_773666 = validateParameter(valid_773666, JString, required = false,
                                 default = nil)
  if valid_773666 != nil:
    section.add "X-Amz-Security-Token", valid_773666
  var valid_773667 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773667 = validateParameter(valid_773667, JString, required = false,
                                 default = nil)
  if valid_773667 != nil:
    section.add "X-Amz-Content-Sha256", valid_773667
  var valid_773668 = header.getOrDefault("X-Amz-Algorithm")
  valid_773668 = validateParameter(valid_773668, JString, required = false,
                                 default = nil)
  if valid_773668 != nil:
    section.add "X-Amz-Algorithm", valid_773668
  var valid_773669 = header.getOrDefault("X-Amz-Signature")
  valid_773669 = validateParameter(valid_773669, JString, required = false,
                                 default = nil)
  if valid_773669 != nil:
    section.add "X-Amz-Signature", valid_773669
  var valid_773670 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773670 = validateParameter(valid_773670, JString, required = false,
                                 default = nil)
  if valid_773670 != nil:
    section.add "X-Amz-SignedHeaders", valid_773670
  var valid_773671 = header.getOrDefault("X-Amz-Credential")
  valid_773671 = validateParameter(valid_773671, JString, required = false,
                                 default = nil)
  if valid_773671 != nil:
    section.add "X-Amz-Credential", valid_773671
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773672: Call_DeleteDynamicThingGroup_773660; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a dynamic thing group.
  ## 
  let valid = call_773672.validator(path, query, header, formData, body)
  let scheme = call_773672.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773672.url(scheme.get, call_773672.host, call_773672.base,
                         call_773672.route, valid.getOrDefault("path"))
  result = hook(call_773672, url, valid)

proc call*(call_773673: Call_DeleteDynamicThingGroup_773660;
          thingGroupName: string; expectedVersion: int = 0): Recallable =
  ## deleteDynamicThingGroup
  ## Deletes a dynamic thing group.
  ##   expectedVersion: int
  ##                  : The expected version of the dynamic thing group to delete.
  ##   thingGroupName: string (required)
  ##                 : The name of the dynamic thing group to delete.
  var path_773674 = newJObject()
  var query_773675 = newJObject()
  add(query_773675, "expectedVersion", newJInt(expectedVersion))
  add(path_773674, "thingGroupName", newJString(thingGroupName))
  result = call_773673.call(path_773674, query_773675, nil, nil, nil)

var deleteDynamicThingGroup* = Call_DeleteDynamicThingGroup_773660(
    name: "deleteDynamicThingGroup", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_DeleteDynamicThingGroup_773661, base: "/",
    url: url_DeleteDynamicThingGroup_773662, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateJob_773706 = ref object of OpenApiRestCall_772597
proc url_CreateJob_773708(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CreateJob_773707(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_773709 = path.getOrDefault("jobId")
  valid_773709 = validateParameter(valid_773709, JString, required = true,
                                 default = nil)
  if valid_773709 != nil:
    section.add "jobId", valid_773709
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773710 = header.getOrDefault("X-Amz-Date")
  valid_773710 = validateParameter(valid_773710, JString, required = false,
                                 default = nil)
  if valid_773710 != nil:
    section.add "X-Amz-Date", valid_773710
  var valid_773711 = header.getOrDefault("X-Amz-Security-Token")
  valid_773711 = validateParameter(valid_773711, JString, required = false,
                                 default = nil)
  if valid_773711 != nil:
    section.add "X-Amz-Security-Token", valid_773711
  var valid_773712 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773712 = validateParameter(valid_773712, JString, required = false,
                                 default = nil)
  if valid_773712 != nil:
    section.add "X-Amz-Content-Sha256", valid_773712
  var valid_773713 = header.getOrDefault("X-Amz-Algorithm")
  valid_773713 = validateParameter(valid_773713, JString, required = false,
                                 default = nil)
  if valid_773713 != nil:
    section.add "X-Amz-Algorithm", valid_773713
  var valid_773714 = header.getOrDefault("X-Amz-Signature")
  valid_773714 = validateParameter(valid_773714, JString, required = false,
                                 default = nil)
  if valid_773714 != nil:
    section.add "X-Amz-Signature", valid_773714
  var valid_773715 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773715 = validateParameter(valid_773715, JString, required = false,
                                 default = nil)
  if valid_773715 != nil:
    section.add "X-Amz-SignedHeaders", valid_773715
  var valid_773716 = header.getOrDefault("X-Amz-Credential")
  valid_773716 = validateParameter(valid_773716, JString, required = false,
                                 default = nil)
  if valid_773716 != nil:
    section.add "X-Amz-Credential", valid_773716
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773718: Call_CreateJob_773706; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a job.
  ## 
  let valid = call_773718.validator(path, query, header, formData, body)
  let scheme = call_773718.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773718.url(scheme.get, call_773718.host, call_773718.base,
                         call_773718.route, valid.getOrDefault("path"))
  result = hook(call_773718, url, valid)

proc call*(call_773719: Call_CreateJob_773706; jobId: string; body: JsonNode): Recallable =
  ## createJob
  ## Creates a job.
  ##   jobId: string (required)
  ##        : A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
  ##   body: JObject (required)
  var path_773720 = newJObject()
  var body_773721 = newJObject()
  add(path_773720, "jobId", newJString(jobId))
  if body != nil:
    body_773721 = body
  result = call_773719.call(path_773720, nil, nil, nil, body_773721)

var createJob* = Call_CreateJob_773706(name: "createJob", meth: HttpMethod.HttpPut,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_CreateJob_773707,
                                    base: "/", url: url_CreateJob_773708,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeJob_773692 = ref object of OpenApiRestCall_772597
proc url_DescribeJob_773694(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeJob_773693(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_773695 = path.getOrDefault("jobId")
  valid_773695 = validateParameter(valid_773695, JString, required = true,
                                 default = nil)
  if valid_773695 != nil:
    section.add "jobId", valid_773695
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773696 = header.getOrDefault("X-Amz-Date")
  valid_773696 = validateParameter(valid_773696, JString, required = false,
                                 default = nil)
  if valid_773696 != nil:
    section.add "X-Amz-Date", valid_773696
  var valid_773697 = header.getOrDefault("X-Amz-Security-Token")
  valid_773697 = validateParameter(valid_773697, JString, required = false,
                                 default = nil)
  if valid_773697 != nil:
    section.add "X-Amz-Security-Token", valid_773697
  var valid_773698 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773698 = validateParameter(valid_773698, JString, required = false,
                                 default = nil)
  if valid_773698 != nil:
    section.add "X-Amz-Content-Sha256", valid_773698
  var valid_773699 = header.getOrDefault("X-Amz-Algorithm")
  valid_773699 = validateParameter(valid_773699, JString, required = false,
                                 default = nil)
  if valid_773699 != nil:
    section.add "X-Amz-Algorithm", valid_773699
  var valid_773700 = header.getOrDefault("X-Amz-Signature")
  valid_773700 = validateParameter(valid_773700, JString, required = false,
                                 default = nil)
  if valid_773700 != nil:
    section.add "X-Amz-Signature", valid_773700
  var valid_773701 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773701 = validateParameter(valid_773701, JString, required = false,
                                 default = nil)
  if valid_773701 != nil:
    section.add "X-Amz-SignedHeaders", valid_773701
  var valid_773702 = header.getOrDefault("X-Amz-Credential")
  valid_773702 = validateParameter(valid_773702, JString, required = false,
                                 default = nil)
  if valid_773702 != nil:
    section.add "X-Amz-Credential", valid_773702
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773703: Call_DescribeJob_773692; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a job.
  ## 
  let valid = call_773703.validator(path, query, header, formData, body)
  let scheme = call_773703.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773703.url(scheme.get, call_773703.host, call_773703.base,
                         call_773703.route, valid.getOrDefault("path"))
  result = hook(call_773703, url, valid)

proc call*(call_773704: Call_DescribeJob_773692; jobId: string): Recallable =
  ## describeJob
  ## Describes a job.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  var path_773705 = newJObject()
  add(path_773705, "jobId", newJString(jobId))
  result = call_773704.call(path_773705, nil, nil, nil, nil)

var describeJob* = Call_DescribeJob_773692(name: "describeJob",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/jobs/{jobId}",
                                        validator: validate_DescribeJob_773693,
                                        base: "/", url: url_DescribeJob_773694,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateJob_773738 = ref object of OpenApiRestCall_772597
proc url_UpdateJob_773740(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_UpdateJob_773739(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates supported fields of the specified job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The ID of the job to be updated.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_773741 = path.getOrDefault("jobId")
  valid_773741 = validateParameter(valid_773741, JString, required = true,
                                 default = nil)
  if valid_773741 != nil:
    section.add "jobId", valid_773741
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773742 = header.getOrDefault("X-Amz-Date")
  valid_773742 = validateParameter(valid_773742, JString, required = false,
                                 default = nil)
  if valid_773742 != nil:
    section.add "X-Amz-Date", valid_773742
  var valid_773743 = header.getOrDefault("X-Amz-Security-Token")
  valid_773743 = validateParameter(valid_773743, JString, required = false,
                                 default = nil)
  if valid_773743 != nil:
    section.add "X-Amz-Security-Token", valid_773743
  var valid_773744 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773744 = validateParameter(valid_773744, JString, required = false,
                                 default = nil)
  if valid_773744 != nil:
    section.add "X-Amz-Content-Sha256", valid_773744
  var valid_773745 = header.getOrDefault("X-Amz-Algorithm")
  valid_773745 = validateParameter(valid_773745, JString, required = false,
                                 default = nil)
  if valid_773745 != nil:
    section.add "X-Amz-Algorithm", valid_773745
  var valid_773746 = header.getOrDefault("X-Amz-Signature")
  valid_773746 = validateParameter(valid_773746, JString, required = false,
                                 default = nil)
  if valid_773746 != nil:
    section.add "X-Amz-Signature", valid_773746
  var valid_773747 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773747 = validateParameter(valid_773747, JString, required = false,
                                 default = nil)
  if valid_773747 != nil:
    section.add "X-Amz-SignedHeaders", valid_773747
  var valid_773748 = header.getOrDefault("X-Amz-Credential")
  valid_773748 = validateParameter(valid_773748, JString, required = false,
                                 default = nil)
  if valid_773748 != nil:
    section.add "X-Amz-Credential", valid_773748
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773750: Call_UpdateJob_773738; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates supported fields of the specified job.
  ## 
  let valid = call_773750.validator(path, query, header, formData, body)
  let scheme = call_773750.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773750.url(scheme.get, call_773750.host, call_773750.base,
                         call_773750.route, valid.getOrDefault("path"))
  result = hook(call_773750, url, valid)

proc call*(call_773751: Call_UpdateJob_773738; jobId: string; body: JsonNode): Recallable =
  ## updateJob
  ## Updates supported fields of the specified job.
  ##   jobId: string (required)
  ##        : The ID of the job to be updated.
  ##   body: JObject (required)
  var path_773752 = newJObject()
  var body_773753 = newJObject()
  add(path_773752, "jobId", newJString(jobId))
  if body != nil:
    body_773753 = body
  result = call_773751.call(path_773752, nil, nil, nil, body_773753)

var updateJob* = Call_UpdateJob_773738(name: "updateJob", meth: HttpMethod.HttpPatch,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_UpdateJob_773739,
                                    base: "/", url: url_UpdateJob_773740,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteJob_773722 = ref object of OpenApiRestCall_772597
proc url_DeleteJob_773724(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteJob_773723(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_773725 = path.getOrDefault("jobId")
  valid_773725 = validateParameter(valid_773725, JString, required = true,
                                 default = nil)
  if valid_773725 != nil:
    section.add "jobId", valid_773725
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
  section = newJObject()
  var valid_773726 = query.getOrDefault("force")
  valid_773726 = validateParameter(valid_773726, JBool, required = false, default = nil)
  if valid_773726 != nil:
    section.add "force", valid_773726
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773727 = header.getOrDefault("X-Amz-Date")
  valid_773727 = validateParameter(valid_773727, JString, required = false,
                                 default = nil)
  if valid_773727 != nil:
    section.add "X-Amz-Date", valid_773727
  var valid_773728 = header.getOrDefault("X-Amz-Security-Token")
  valid_773728 = validateParameter(valid_773728, JString, required = false,
                                 default = nil)
  if valid_773728 != nil:
    section.add "X-Amz-Security-Token", valid_773728
  var valid_773729 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773729 = validateParameter(valid_773729, JString, required = false,
                                 default = nil)
  if valid_773729 != nil:
    section.add "X-Amz-Content-Sha256", valid_773729
  var valid_773730 = header.getOrDefault("X-Amz-Algorithm")
  valid_773730 = validateParameter(valid_773730, JString, required = false,
                                 default = nil)
  if valid_773730 != nil:
    section.add "X-Amz-Algorithm", valid_773730
  var valid_773731 = header.getOrDefault("X-Amz-Signature")
  valid_773731 = validateParameter(valid_773731, JString, required = false,
                                 default = nil)
  if valid_773731 != nil:
    section.add "X-Amz-Signature", valid_773731
  var valid_773732 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773732 = validateParameter(valid_773732, JString, required = false,
                                 default = nil)
  if valid_773732 != nil:
    section.add "X-Amz-SignedHeaders", valid_773732
  var valid_773733 = header.getOrDefault("X-Amz-Credential")
  valid_773733 = validateParameter(valid_773733, JString, required = false,
                                 default = nil)
  if valid_773733 != nil:
    section.add "X-Amz-Credential", valid_773733
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773734: Call_DeleteJob_773722; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ## 
  let valid = call_773734.validator(path, query, header, formData, body)
  let scheme = call_773734.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773734.url(scheme.get, call_773734.host, call_773734.base,
                         call_773734.route, valid.getOrDefault("path"))
  result = hook(call_773734, url, valid)

proc call*(call_773735: Call_DeleteJob_773722; jobId: string; force: bool = false): Recallable =
  ## deleteJob
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ##   force: bool
  ##        : <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
  ##   jobId: string (required)
  ##        : <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
  var path_773736 = newJObject()
  var query_773737 = newJObject()
  add(query_773737, "force", newJBool(force))
  add(path_773736, "jobId", newJString(jobId))
  result = call_773735.call(path_773736, query_773737, nil, nil, nil)

var deleteJob* = Call_DeleteJob_773722(name: "deleteJob",
                                    meth: HttpMethod.HttpDelete,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_DeleteJob_773723,
                                    base: "/", url: url_DeleteJob_773724,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateKeysAndCertificate_773754 = ref object of OpenApiRestCall_772597
proc url_CreateKeysAndCertificate_773756(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_CreateKeysAndCertificate_773755(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_773757 = query.getOrDefault("setAsActive")
  valid_773757 = validateParameter(valid_773757, JBool, required = false, default = nil)
  if valid_773757 != nil:
    section.add "setAsActive", valid_773757
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773758 = header.getOrDefault("X-Amz-Date")
  valid_773758 = validateParameter(valid_773758, JString, required = false,
                                 default = nil)
  if valid_773758 != nil:
    section.add "X-Amz-Date", valid_773758
  var valid_773759 = header.getOrDefault("X-Amz-Security-Token")
  valid_773759 = validateParameter(valid_773759, JString, required = false,
                                 default = nil)
  if valid_773759 != nil:
    section.add "X-Amz-Security-Token", valid_773759
  var valid_773760 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773760 = validateParameter(valid_773760, JString, required = false,
                                 default = nil)
  if valid_773760 != nil:
    section.add "X-Amz-Content-Sha256", valid_773760
  var valid_773761 = header.getOrDefault("X-Amz-Algorithm")
  valid_773761 = validateParameter(valid_773761, JString, required = false,
                                 default = nil)
  if valid_773761 != nil:
    section.add "X-Amz-Algorithm", valid_773761
  var valid_773762 = header.getOrDefault("X-Amz-Signature")
  valid_773762 = validateParameter(valid_773762, JString, required = false,
                                 default = nil)
  if valid_773762 != nil:
    section.add "X-Amz-Signature", valid_773762
  var valid_773763 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773763 = validateParameter(valid_773763, JString, required = false,
                                 default = nil)
  if valid_773763 != nil:
    section.add "X-Amz-SignedHeaders", valid_773763
  var valid_773764 = header.getOrDefault("X-Amz-Credential")
  valid_773764 = validateParameter(valid_773764, JString, required = false,
                                 default = nil)
  if valid_773764 != nil:
    section.add "X-Amz-Credential", valid_773764
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773765: Call_CreateKeysAndCertificate_773754; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ## 
  let valid = call_773765.validator(path, query, header, formData, body)
  let scheme = call_773765.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773765.url(scheme.get, call_773765.host, call_773765.base,
                         call_773765.route, valid.getOrDefault("path"))
  result = hook(call_773765, url, valid)

proc call*(call_773766: Call_CreateKeysAndCertificate_773754;
          setAsActive: bool = false): Recallable =
  ## createKeysAndCertificate
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  var query_773767 = newJObject()
  add(query_773767, "setAsActive", newJBool(setAsActive))
  result = call_773766.call(nil, query_773767, nil, nil, nil)

var createKeysAndCertificate* = Call_CreateKeysAndCertificate_773754(
    name: "createKeysAndCertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/keys-and-certificate",
    validator: validate_CreateKeysAndCertificate_773755, base: "/",
    url: url_CreateKeysAndCertificate_773756, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateMitigationAction_773782 = ref object of OpenApiRestCall_772597
proc url_CreateMitigationAction_773784(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CreateMitigationAction_773783(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_773785 = path.getOrDefault("actionName")
  valid_773785 = validateParameter(valid_773785, JString, required = true,
                                 default = nil)
  if valid_773785 != nil:
    section.add "actionName", valid_773785
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773786 = header.getOrDefault("X-Amz-Date")
  valid_773786 = validateParameter(valid_773786, JString, required = false,
                                 default = nil)
  if valid_773786 != nil:
    section.add "X-Amz-Date", valid_773786
  var valid_773787 = header.getOrDefault("X-Amz-Security-Token")
  valid_773787 = validateParameter(valid_773787, JString, required = false,
                                 default = nil)
  if valid_773787 != nil:
    section.add "X-Amz-Security-Token", valid_773787
  var valid_773788 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773788 = validateParameter(valid_773788, JString, required = false,
                                 default = nil)
  if valid_773788 != nil:
    section.add "X-Amz-Content-Sha256", valid_773788
  var valid_773789 = header.getOrDefault("X-Amz-Algorithm")
  valid_773789 = validateParameter(valid_773789, JString, required = false,
                                 default = nil)
  if valid_773789 != nil:
    section.add "X-Amz-Algorithm", valid_773789
  var valid_773790 = header.getOrDefault("X-Amz-Signature")
  valid_773790 = validateParameter(valid_773790, JString, required = false,
                                 default = nil)
  if valid_773790 != nil:
    section.add "X-Amz-Signature", valid_773790
  var valid_773791 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773791 = validateParameter(valid_773791, JString, required = false,
                                 default = nil)
  if valid_773791 != nil:
    section.add "X-Amz-SignedHeaders", valid_773791
  var valid_773792 = header.getOrDefault("X-Amz-Credential")
  valid_773792 = validateParameter(valid_773792, JString, required = false,
                                 default = nil)
  if valid_773792 != nil:
    section.add "X-Amz-Credential", valid_773792
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773794: Call_CreateMitigationAction_773782; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ## 
  let valid = call_773794.validator(path, query, header, formData, body)
  let scheme = call_773794.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773794.url(scheme.get, call_773794.host, call_773794.base,
                         call_773794.route, valid.getOrDefault("path"))
  result = hook(call_773794, url, valid)

proc call*(call_773795: Call_CreateMitigationAction_773782; actionName: string;
          body: JsonNode): Recallable =
  ## createMitigationAction
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ##   actionName: string (required)
  ##             : A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).
  ##   body: JObject (required)
  var path_773796 = newJObject()
  var body_773797 = newJObject()
  add(path_773796, "actionName", newJString(actionName))
  if body != nil:
    body_773797 = body
  result = call_773795.call(path_773796, nil, nil, nil, body_773797)

var createMitigationAction* = Call_CreateMitigationAction_773782(
    name: "createMitigationAction", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_CreateMitigationAction_773783, base: "/",
    url: url_CreateMitigationAction_773784, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeMitigationAction_773768 = ref object of OpenApiRestCall_772597
proc url_DescribeMitigationAction_773770(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeMitigationAction_773769(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a mitigation action.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The friendly name that uniquely identifies the mitigation action.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_773771 = path.getOrDefault("actionName")
  valid_773771 = validateParameter(valid_773771, JString, required = true,
                                 default = nil)
  if valid_773771 != nil:
    section.add "actionName", valid_773771
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773772 = header.getOrDefault("X-Amz-Date")
  valid_773772 = validateParameter(valid_773772, JString, required = false,
                                 default = nil)
  if valid_773772 != nil:
    section.add "X-Amz-Date", valid_773772
  var valid_773773 = header.getOrDefault("X-Amz-Security-Token")
  valid_773773 = validateParameter(valid_773773, JString, required = false,
                                 default = nil)
  if valid_773773 != nil:
    section.add "X-Amz-Security-Token", valid_773773
  var valid_773774 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773774 = validateParameter(valid_773774, JString, required = false,
                                 default = nil)
  if valid_773774 != nil:
    section.add "X-Amz-Content-Sha256", valid_773774
  var valid_773775 = header.getOrDefault("X-Amz-Algorithm")
  valid_773775 = validateParameter(valid_773775, JString, required = false,
                                 default = nil)
  if valid_773775 != nil:
    section.add "X-Amz-Algorithm", valid_773775
  var valid_773776 = header.getOrDefault("X-Amz-Signature")
  valid_773776 = validateParameter(valid_773776, JString, required = false,
                                 default = nil)
  if valid_773776 != nil:
    section.add "X-Amz-Signature", valid_773776
  var valid_773777 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773777 = validateParameter(valid_773777, JString, required = false,
                                 default = nil)
  if valid_773777 != nil:
    section.add "X-Amz-SignedHeaders", valid_773777
  var valid_773778 = header.getOrDefault("X-Amz-Credential")
  valid_773778 = validateParameter(valid_773778, JString, required = false,
                                 default = nil)
  if valid_773778 != nil:
    section.add "X-Amz-Credential", valid_773778
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773779: Call_DescribeMitigationAction_773768; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a mitigation action.
  ## 
  let valid = call_773779.validator(path, query, header, formData, body)
  let scheme = call_773779.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773779.url(scheme.get, call_773779.host, call_773779.base,
                         call_773779.route, valid.getOrDefault("path"))
  result = hook(call_773779, url, valid)

proc call*(call_773780: Call_DescribeMitigationAction_773768; actionName: string): Recallable =
  ## describeMitigationAction
  ## Gets information about a mitigation action.
  ##   actionName: string (required)
  ##             : The friendly name that uniquely identifies the mitigation action.
  var path_773781 = newJObject()
  add(path_773781, "actionName", newJString(actionName))
  result = call_773780.call(path_773781, nil, nil, nil, nil)

var describeMitigationAction* = Call_DescribeMitigationAction_773768(
    name: "describeMitigationAction", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_DescribeMitigationAction_773769, base: "/",
    url: url_DescribeMitigationAction_773770, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateMitigationAction_773812 = ref object of OpenApiRestCall_772597
proc url_UpdateMitigationAction_773814(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_UpdateMitigationAction_773813(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the definition for the specified mitigation action.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_773815 = path.getOrDefault("actionName")
  valid_773815 = validateParameter(valid_773815, JString, required = true,
                                 default = nil)
  if valid_773815 != nil:
    section.add "actionName", valid_773815
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773816 = header.getOrDefault("X-Amz-Date")
  valid_773816 = validateParameter(valid_773816, JString, required = false,
                                 default = nil)
  if valid_773816 != nil:
    section.add "X-Amz-Date", valid_773816
  var valid_773817 = header.getOrDefault("X-Amz-Security-Token")
  valid_773817 = validateParameter(valid_773817, JString, required = false,
                                 default = nil)
  if valid_773817 != nil:
    section.add "X-Amz-Security-Token", valid_773817
  var valid_773818 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773818 = validateParameter(valid_773818, JString, required = false,
                                 default = nil)
  if valid_773818 != nil:
    section.add "X-Amz-Content-Sha256", valid_773818
  var valid_773819 = header.getOrDefault("X-Amz-Algorithm")
  valid_773819 = validateParameter(valid_773819, JString, required = false,
                                 default = nil)
  if valid_773819 != nil:
    section.add "X-Amz-Algorithm", valid_773819
  var valid_773820 = header.getOrDefault("X-Amz-Signature")
  valid_773820 = validateParameter(valid_773820, JString, required = false,
                                 default = nil)
  if valid_773820 != nil:
    section.add "X-Amz-Signature", valid_773820
  var valid_773821 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773821 = validateParameter(valid_773821, JString, required = false,
                                 default = nil)
  if valid_773821 != nil:
    section.add "X-Amz-SignedHeaders", valid_773821
  var valid_773822 = header.getOrDefault("X-Amz-Credential")
  valid_773822 = validateParameter(valid_773822, JString, required = false,
                                 default = nil)
  if valid_773822 != nil:
    section.add "X-Amz-Credential", valid_773822
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773824: Call_UpdateMitigationAction_773812; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the definition for the specified mitigation action.
  ## 
  let valid = call_773824.validator(path, query, header, formData, body)
  let scheme = call_773824.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773824.url(scheme.get, call_773824.host, call_773824.base,
                         call_773824.route, valid.getOrDefault("path"))
  result = hook(call_773824, url, valid)

proc call*(call_773825: Call_UpdateMitigationAction_773812; actionName: string;
          body: JsonNode): Recallable =
  ## updateMitigationAction
  ## Updates the definition for the specified mitigation action.
  ##   actionName: string (required)
  ##             : The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.
  ##   body: JObject (required)
  var path_773826 = newJObject()
  var body_773827 = newJObject()
  add(path_773826, "actionName", newJString(actionName))
  if body != nil:
    body_773827 = body
  result = call_773825.call(path_773826, nil, nil, nil, body_773827)

var updateMitigationAction* = Call_UpdateMitigationAction_773812(
    name: "updateMitigationAction", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_UpdateMitigationAction_773813, base: "/",
    url: url_UpdateMitigationAction_773814, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteMitigationAction_773798 = ref object of OpenApiRestCall_772597
proc url_DeleteMitigationAction_773800(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteMitigationAction_773799(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a defined mitigation action from your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The name of the mitigation action that you want to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_773801 = path.getOrDefault("actionName")
  valid_773801 = validateParameter(valid_773801, JString, required = true,
                                 default = nil)
  if valid_773801 != nil:
    section.add "actionName", valid_773801
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773802 = header.getOrDefault("X-Amz-Date")
  valid_773802 = validateParameter(valid_773802, JString, required = false,
                                 default = nil)
  if valid_773802 != nil:
    section.add "X-Amz-Date", valid_773802
  var valid_773803 = header.getOrDefault("X-Amz-Security-Token")
  valid_773803 = validateParameter(valid_773803, JString, required = false,
                                 default = nil)
  if valid_773803 != nil:
    section.add "X-Amz-Security-Token", valid_773803
  var valid_773804 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773804 = validateParameter(valid_773804, JString, required = false,
                                 default = nil)
  if valid_773804 != nil:
    section.add "X-Amz-Content-Sha256", valid_773804
  var valid_773805 = header.getOrDefault("X-Amz-Algorithm")
  valid_773805 = validateParameter(valid_773805, JString, required = false,
                                 default = nil)
  if valid_773805 != nil:
    section.add "X-Amz-Algorithm", valid_773805
  var valid_773806 = header.getOrDefault("X-Amz-Signature")
  valid_773806 = validateParameter(valid_773806, JString, required = false,
                                 default = nil)
  if valid_773806 != nil:
    section.add "X-Amz-Signature", valid_773806
  var valid_773807 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773807 = validateParameter(valid_773807, JString, required = false,
                                 default = nil)
  if valid_773807 != nil:
    section.add "X-Amz-SignedHeaders", valid_773807
  var valid_773808 = header.getOrDefault("X-Amz-Credential")
  valid_773808 = validateParameter(valid_773808, JString, required = false,
                                 default = nil)
  if valid_773808 != nil:
    section.add "X-Amz-Credential", valid_773808
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773809: Call_DeleteMitigationAction_773798; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a defined mitigation action from your AWS account.
  ## 
  let valid = call_773809.validator(path, query, header, formData, body)
  let scheme = call_773809.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773809.url(scheme.get, call_773809.host, call_773809.base,
                         call_773809.route, valid.getOrDefault("path"))
  result = hook(call_773809, url, valid)

proc call*(call_773810: Call_DeleteMitigationAction_773798; actionName: string): Recallable =
  ## deleteMitigationAction
  ## Deletes a defined mitigation action from your AWS account.
  ##   actionName: string (required)
  ##             : The name of the mitigation action that you want to delete.
  var path_773811 = newJObject()
  add(path_773811, "actionName", newJString(actionName))
  result = call_773810.call(path_773811, nil, nil, nil, nil)

var deleteMitigationAction* = Call_DeleteMitigationAction_773798(
    name: "deleteMitigationAction", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_DeleteMitigationAction_773799, base: "/",
    url: url_DeleteMitigationAction_773800, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateOTAUpdate_773842 = ref object of OpenApiRestCall_772597
proc url_CreateOTAUpdate_773844(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CreateOTAUpdate_773843(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The ID of the OTA update to be created.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_773845 = path.getOrDefault("otaUpdateId")
  valid_773845 = validateParameter(valid_773845, JString, required = true,
                                 default = nil)
  if valid_773845 != nil:
    section.add "otaUpdateId", valid_773845
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773846 = header.getOrDefault("X-Amz-Date")
  valid_773846 = validateParameter(valid_773846, JString, required = false,
                                 default = nil)
  if valid_773846 != nil:
    section.add "X-Amz-Date", valid_773846
  var valid_773847 = header.getOrDefault("X-Amz-Security-Token")
  valid_773847 = validateParameter(valid_773847, JString, required = false,
                                 default = nil)
  if valid_773847 != nil:
    section.add "X-Amz-Security-Token", valid_773847
  var valid_773848 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773848 = validateParameter(valid_773848, JString, required = false,
                                 default = nil)
  if valid_773848 != nil:
    section.add "X-Amz-Content-Sha256", valid_773848
  var valid_773849 = header.getOrDefault("X-Amz-Algorithm")
  valid_773849 = validateParameter(valid_773849, JString, required = false,
                                 default = nil)
  if valid_773849 != nil:
    section.add "X-Amz-Algorithm", valid_773849
  var valid_773850 = header.getOrDefault("X-Amz-Signature")
  valid_773850 = validateParameter(valid_773850, JString, required = false,
                                 default = nil)
  if valid_773850 != nil:
    section.add "X-Amz-Signature", valid_773850
  var valid_773851 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773851 = validateParameter(valid_773851, JString, required = false,
                                 default = nil)
  if valid_773851 != nil:
    section.add "X-Amz-SignedHeaders", valid_773851
  var valid_773852 = header.getOrDefault("X-Amz-Credential")
  valid_773852 = validateParameter(valid_773852, JString, required = false,
                                 default = nil)
  if valid_773852 != nil:
    section.add "X-Amz-Credential", valid_773852
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773854: Call_CreateOTAUpdate_773842; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ## 
  let valid = call_773854.validator(path, query, header, formData, body)
  let scheme = call_773854.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773854.url(scheme.get, call_773854.host, call_773854.base,
                         call_773854.route, valid.getOrDefault("path"))
  result = hook(call_773854, url, valid)

proc call*(call_773855: Call_CreateOTAUpdate_773842; otaUpdateId: string;
          body: JsonNode): Recallable =
  ## createOTAUpdate
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ##   otaUpdateId: string (required)
  ##              : The ID of the OTA update to be created.
  ##   body: JObject (required)
  var path_773856 = newJObject()
  var body_773857 = newJObject()
  add(path_773856, "otaUpdateId", newJString(otaUpdateId))
  if body != nil:
    body_773857 = body
  result = call_773855.call(path_773856, nil, nil, nil, body_773857)

var createOTAUpdate* = Call_CreateOTAUpdate_773842(name: "createOTAUpdate",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_CreateOTAUpdate_773843,
    base: "/", url: url_CreateOTAUpdate_773844, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetOTAUpdate_773828 = ref object of OpenApiRestCall_772597
proc url_GetOTAUpdate_773830(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_GetOTAUpdate_773829(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets an OTA update.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The OTA update ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_773831 = path.getOrDefault("otaUpdateId")
  valid_773831 = validateParameter(valid_773831, JString, required = true,
                                 default = nil)
  if valid_773831 != nil:
    section.add "otaUpdateId", valid_773831
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773832 = header.getOrDefault("X-Amz-Date")
  valid_773832 = validateParameter(valid_773832, JString, required = false,
                                 default = nil)
  if valid_773832 != nil:
    section.add "X-Amz-Date", valid_773832
  var valid_773833 = header.getOrDefault("X-Amz-Security-Token")
  valid_773833 = validateParameter(valid_773833, JString, required = false,
                                 default = nil)
  if valid_773833 != nil:
    section.add "X-Amz-Security-Token", valid_773833
  var valid_773834 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773834 = validateParameter(valid_773834, JString, required = false,
                                 default = nil)
  if valid_773834 != nil:
    section.add "X-Amz-Content-Sha256", valid_773834
  var valid_773835 = header.getOrDefault("X-Amz-Algorithm")
  valid_773835 = validateParameter(valid_773835, JString, required = false,
                                 default = nil)
  if valid_773835 != nil:
    section.add "X-Amz-Algorithm", valid_773835
  var valid_773836 = header.getOrDefault("X-Amz-Signature")
  valid_773836 = validateParameter(valid_773836, JString, required = false,
                                 default = nil)
  if valid_773836 != nil:
    section.add "X-Amz-Signature", valid_773836
  var valid_773837 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773837 = validateParameter(valid_773837, JString, required = false,
                                 default = nil)
  if valid_773837 != nil:
    section.add "X-Amz-SignedHeaders", valid_773837
  var valid_773838 = header.getOrDefault("X-Amz-Credential")
  valid_773838 = validateParameter(valid_773838, JString, required = false,
                                 default = nil)
  if valid_773838 != nil:
    section.add "X-Amz-Credential", valid_773838
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773839: Call_GetOTAUpdate_773828; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets an OTA update.
  ## 
  let valid = call_773839.validator(path, query, header, formData, body)
  let scheme = call_773839.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773839.url(scheme.get, call_773839.host, call_773839.base,
                         call_773839.route, valid.getOrDefault("path"))
  result = hook(call_773839, url, valid)

proc call*(call_773840: Call_GetOTAUpdate_773828; otaUpdateId: string): Recallable =
  ## getOTAUpdate
  ## Gets an OTA update.
  ##   otaUpdateId: string (required)
  ##              : The OTA update ID.
  var path_773841 = newJObject()
  add(path_773841, "otaUpdateId", newJString(otaUpdateId))
  result = call_773840.call(path_773841, nil, nil, nil, nil)

var getOTAUpdate* = Call_GetOTAUpdate_773828(name: "getOTAUpdate",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_GetOTAUpdate_773829,
    base: "/", url: url_GetOTAUpdate_773830, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteOTAUpdate_773858 = ref object of OpenApiRestCall_772597
proc url_DeleteOTAUpdate_773860(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteOTAUpdate_773859(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Delete an OTA update.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The OTA update ID to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_773861 = path.getOrDefault("otaUpdateId")
  valid_773861 = validateParameter(valid_773861, JString, required = true,
                                 default = nil)
  if valid_773861 != nil:
    section.add "otaUpdateId", valid_773861
  result.add "path", section
  ## parameters in `query` object:
  ##   deleteStream: JBool
  ##               : Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.
  ##   forceDeleteAWSJob: JBool
  ##                    : Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.
  section = newJObject()
  var valid_773862 = query.getOrDefault("deleteStream")
  valid_773862 = validateParameter(valid_773862, JBool, required = false, default = nil)
  if valid_773862 != nil:
    section.add "deleteStream", valid_773862
  var valid_773863 = query.getOrDefault("forceDeleteAWSJob")
  valid_773863 = validateParameter(valid_773863, JBool, required = false, default = nil)
  if valid_773863 != nil:
    section.add "forceDeleteAWSJob", valid_773863
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773864 = header.getOrDefault("X-Amz-Date")
  valid_773864 = validateParameter(valid_773864, JString, required = false,
                                 default = nil)
  if valid_773864 != nil:
    section.add "X-Amz-Date", valid_773864
  var valid_773865 = header.getOrDefault("X-Amz-Security-Token")
  valid_773865 = validateParameter(valid_773865, JString, required = false,
                                 default = nil)
  if valid_773865 != nil:
    section.add "X-Amz-Security-Token", valid_773865
  var valid_773866 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773866 = validateParameter(valid_773866, JString, required = false,
                                 default = nil)
  if valid_773866 != nil:
    section.add "X-Amz-Content-Sha256", valid_773866
  var valid_773867 = header.getOrDefault("X-Amz-Algorithm")
  valid_773867 = validateParameter(valid_773867, JString, required = false,
                                 default = nil)
  if valid_773867 != nil:
    section.add "X-Amz-Algorithm", valid_773867
  var valid_773868 = header.getOrDefault("X-Amz-Signature")
  valid_773868 = validateParameter(valid_773868, JString, required = false,
                                 default = nil)
  if valid_773868 != nil:
    section.add "X-Amz-Signature", valid_773868
  var valid_773869 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773869 = validateParameter(valid_773869, JString, required = false,
                                 default = nil)
  if valid_773869 != nil:
    section.add "X-Amz-SignedHeaders", valid_773869
  var valid_773870 = header.getOrDefault("X-Amz-Credential")
  valid_773870 = validateParameter(valid_773870, JString, required = false,
                                 default = nil)
  if valid_773870 != nil:
    section.add "X-Amz-Credential", valid_773870
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773871: Call_DeleteOTAUpdate_773858; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete an OTA update.
  ## 
  let valid = call_773871.validator(path, query, header, formData, body)
  let scheme = call_773871.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773871.url(scheme.get, call_773871.host, call_773871.base,
                         call_773871.route, valid.getOrDefault("path"))
  result = hook(call_773871, url, valid)

proc call*(call_773872: Call_DeleteOTAUpdate_773858; otaUpdateId: string;
          deleteStream: bool = false; forceDeleteAWSJob: bool = false): Recallable =
  ## deleteOTAUpdate
  ## Delete an OTA update.
  ##   deleteStream: bool
  ##               : Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.
  ##   otaUpdateId: string (required)
  ##              : The OTA update ID to delete.
  ##   forceDeleteAWSJob: bool
  ##                    : Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.
  var path_773873 = newJObject()
  var query_773874 = newJObject()
  add(query_773874, "deleteStream", newJBool(deleteStream))
  add(path_773873, "otaUpdateId", newJString(otaUpdateId))
  add(query_773874, "forceDeleteAWSJob", newJBool(forceDeleteAWSJob))
  result = call_773872.call(path_773873, query_773874, nil, nil, nil)

var deleteOTAUpdate* = Call_DeleteOTAUpdate_773858(name: "deleteOTAUpdate",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_DeleteOTAUpdate_773859,
    base: "/", url: url_DeleteOTAUpdate_773860, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreatePolicy_773889 = ref object of OpenApiRestCall_772597
proc url_CreatePolicy_773891(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CreatePolicy_773890(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_773892 = path.getOrDefault("policyName")
  valid_773892 = validateParameter(valid_773892, JString, required = true,
                                 default = nil)
  if valid_773892 != nil:
    section.add "policyName", valid_773892
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773893 = header.getOrDefault("X-Amz-Date")
  valid_773893 = validateParameter(valid_773893, JString, required = false,
                                 default = nil)
  if valid_773893 != nil:
    section.add "X-Amz-Date", valid_773893
  var valid_773894 = header.getOrDefault("X-Amz-Security-Token")
  valid_773894 = validateParameter(valid_773894, JString, required = false,
                                 default = nil)
  if valid_773894 != nil:
    section.add "X-Amz-Security-Token", valid_773894
  var valid_773895 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773895 = validateParameter(valid_773895, JString, required = false,
                                 default = nil)
  if valid_773895 != nil:
    section.add "X-Amz-Content-Sha256", valid_773895
  var valid_773896 = header.getOrDefault("X-Amz-Algorithm")
  valid_773896 = validateParameter(valid_773896, JString, required = false,
                                 default = nil)
  if valid_773896 != nil:
    section.add "X-Amz-Algorithm", valid_773896
  var valid_773897 = header.getOrDefault("X-Amz-Signature")
  valid_773897 = validateParameter(valid_773897, JString, required = false,
                                 default = nil)
  if valid_773897 != nil:
    section.add "X-Amz-Signature", valid_773897
  var valid_773898 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773898 = validateParameter(valid_773898, JString, required = false,
                                 default = nil)
  if valid_773898 != nil:
    section.add "X-Amz-SignedHeaders", valid_773898
  var valid_773899 = header.getOrDefault("X-Amz-Credential")
  valid_773899 = validateParameter(valid_773899, JString, required = false,
                                 default = nil)
  if valid_773899 != nil:
    section.add "X-Amz-Credential", valid_773899
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773901: Call_CreatePolicy_773889; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ## 
  let valid = call_773901.validator(path, query, header, formData, body)
  let scheme = call_773901.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773901.url(scheme.get, call_773901.host, call_773901.base,
                         call_773901.route, valid.getOrDefault("path"))
  result = hook(call_773901, url, valid)

proc call*(call_773902: Call_CreatePolicy_773889; policyName: string; body: JsonNode): Recallable =
  ## createPolicy
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ##   policyName: string (required)
  ##             : The policy name.
  ##   body: JObject (required)
  var path_773903 = newJObject()
  var body_773904 = newJObject()
  add(path_773903, "policyName", newJString(policyName))
  if body != nil:
    body_773904 = body
  result = call_773902.call(path_773903, nil, nil, nil, body_773904)

var createPolicy* = Call_CreatePolicy_773889(name: "createPolicy",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/policies/{policyName}", validator: validate_CreatePolicy_773890,
    base: "/", url: url_CreatePolicy_773891, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPolicy_773875 = ref object of OpenApiRestCall_772597
proc url_GetPolicy_773877(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_GetPolicy_773876(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the specified policy with the policy document of the default version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_773878 = path.getOrDefault("policyName")
  valid_773878 = validateParameter(valid_773878, JString, required = true,
                                 default = nil)
  if valid_773878 != nil:
    section.add "policyName", valid_773878
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773879 = header.getOrDefault("X-Amz-Date")
  valid_773879 = validateParameter(valid_773879, JString, required = false,
                                 default = nil)
  if valid_773879 != nil:
    section.add "X-Amz-Date", valid_773879
  var valid_773880 = header.getOrDefault("X-Amz-Security-Token")
  valid_773880 = validateParameter(valid_773880, JString, required = false,
                                 default = nil)
  if valid_773880 != nil:
    section.add "X-Amz-Security-Token", valid_773880
  var valid_773881 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773881 = validateParameter(valid_773881, JString, required = false,
                                 default = nil)
  if valid_773881 != nil:
    section.add "X-Amz-Content-Sha256", valid_773881
  var valid_773882 = header.getOrDefault("X-Amz-Algorithm")
  valid_773882 = validateParameter(valid_773882, JString, required = false,
                                 default = nil)
  if valid_773882 != nil:
    section.add "X-Amz-Algorithm", valid_773882
  var valid_773883 = header.getOrDefault("X-Amz-Signature")
  valid_773883 = validateParameter(valid_773883, JString, required = false,
                                 default = nil)
  if valid_773883 != nil:
    section.add "X-Amz-Signature", valid_773883
  var valid_773884 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773884 = validateParameter(valid_773884, JString, required = false,
                                 default = nil)
  if valid_773884 != nil:
    section.add "X-Amz-SignedHeaders", valid_773884
  var valid_773885 = header.getOrDefault("X-Amz-Credential")
  valid_773885 = validateParameter(valid_773885, JString, required = false,
                                 default = nil)
  if valid_773885 != nil:
    section.add "X-Amz-Credential", valid_773885
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773886: Call_GetPolicy_773875; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified policy with the policy document of the default version.
  ## 
  let valid = call_773886.validator(path, query, header, formData, body)
  let scheme = call_773886.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773886.url(scheme.get, call_773886.host, call_773886.base,
                         call_773886.route, valid.getOrDefault("path"))
  result = hook(call_773886, url, valid)

proc call*(call_773887: Call_GetPolicy_773875; policyName: string): Recallable =
  ## getPolicy
  ## Gets information about the specified policy with the policy document of the default version.
  ##   policyName: string (required)
  ##             : The name of the policy.
  var path_773888 = newJObject()
  add(path_773888, "policyName", newJString(policyName))
  result = call_773887.call(path_773888, nil, nil, nil, nil)

var getPolicy* = Call_GetPolicy_773875(name: "getPolicy", meth: HttpMethod.HttpGet,
                                    host: "iot.amazonaws.com",
                                    route: "/policies/{policyName}",
                                    validator: validate_GetPolicy_773876,
                                    base: "/", url: url_GetPolicy_773877,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeletePolicy_773905 = ref object of OpenApiRestCall_772597
proc url_DeletePolicy_773907(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeletePolicy_773906(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_773908 = path.getOrDefault("policyName")
  valid_773908 = validateParameter(valid_773908, JString, required = true,
                                 default = nil)
  if valid_773908 != nil:
    section.add "policyName", valid_773908
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773909 = header.getOrDefault("X-Amz-Date")
  valid_773909 = validateParameter(valid_773909, JString, required = false,
                                 default = nil)
  if valid_773909 != nil:
    section.add "X-Amz-Date", valid_773909
  var valid_773910 = header.getOrDefault("X-Amz-Security-Token")
  valid_773910 = validateParameter(valid_773910, JString, required = false,
                                 default = nil)
  if valid_773910 != nil:
    section.add "X-Amz-Security-Token", valid_773910
  var valid_773911 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773911 = validateParameter(valid_773911, JString, required = false,
                                 default = nil)
  if valid_773911 != nil:
    section.add "X-Amz-Content-Sha256", valid_773911
  var valid_773912 = header.getOrDefault("X-Amz-Algorithm")
  valid_773912 = validateParameter(valid_773912, JString, required = false,
                                 default = nil)
  if valid_773912 != nil:
    section.add "X-Amz-Algorithm", valid_773912
  var valid_773913 = header.getOrDefault("X-Amz-Signature")
  valid_773913 = validateParameter(valid_773913, JString, required = false,
                                 default = nil)
  if valid_773913 != nil:
    section.add "X-Amz-Signature", valid_773913
  var valid_773914 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773914 = validateParameter(valid_773914, JString, required = false,
                                 default = nil)
  if valid_773914 != nil:
    section.add "X-Amz-SignedHeaders", valid_773914
  var valid_773915 = header.getOrDefault("X-Amz-Credential")
  valid_773915 = validateParameter(valid_773915, JString, required = false,
                                 default = nil)
  if valid_773915 != nil:
    section.add "X-Amz-Credential", valid_773915
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773916: Call_DeletePolicy_773905; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ## 
  let valid = call_773916.validator(path, query, header, formData, body)
  let scheme = call_773916.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773916.url(scheme.get, call_773916.host, call_773916.base,
                         call_773916.route, valid.getOrDefault("path"))
  result = hook(call_773916, url, valid)

proc call*(call_773917: Call_DeletePolicy_773905; policyName: string): Recallable =
  ## deletePolicy
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ##   policyName: string (required)
  ##             : The name of the policy to delete.
  var path_773918 = newJObject()
  add(path_773918, "policyName", newJString(policyName))
  result = call_773917.call(path_773918, nil, nil, nil, nil)

var deletePolicy* = Call_DeletePolicy_773905(name: "deletePolicy",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/policies/{policyName}", validator: validate_DeletePolicy_773906,
    base: "/", url: url_DeletePolicy_773907, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreatePolicyVersion_773933 = ref object of OpenApiRestCall_772597
proc url_CreatePolicyVersion_773935(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CreatePolicyVersion_773934(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_773936 = path.getOrDefault("policyName")
  valid_773936 = validateParameter(valid_773936, JString, required = true,
                                 default = nil)
  if valid_773936 != nil:
    section.add "policyName", valid_773936
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsDefault: JBool
  ##               : Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
  section = newJObject()
  var valid_773937 = query.getOrDefault("setAsDefault")
  valid_773937 = validateParameter(valid_773937, JBool, required = false, default = nil)
  if valid_773937 != nil:
    section.add "setAsDefault", valid_773937
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773938 = header.getOrDefault("X-Amz-Date")
  valid_773938 = validateParameter(valid_773938, JString, required = false,
                                 default = nil)
  if valid_773938 != nil:
    section.add "X-Amz-Date", valid_773938
  var valid_773939 = header.getOrDefault("X-Amz-Security-Token")
  valid_773939 = validateParameter(valid_773939, JString, required = false,
                                 default = nil)
  if valid_773939 != nil:
    section.add "X-Amz-Security-Token", valid_773939
  var valid_773940 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773940 = validateParameter(valid_773940, JString, required = false,
                                 default = nil)
  if valid_773940 != nil:
    section.add "X-Amz-Content-Sha256", valid_773940
  var valid_773941 = header.getOrDefault("X-Amz-Algorithm")
  valid_773941 = validateParameter(valid_773941, JString, required = false,
                                 default = nil)
  if valid_773941 != nil:
    section.add "X-Amz-Algorithm", valid_773941
  var valid_773942 = header.getOrDefault("X-Amz-Signature")
  valid_773942 = validateParameter(valid_773942, JString, required = false,
                                 default = nil)
  if valid_773942 != nil:
    section.add "X-Amz-Signature", valid_773942
  var valid_773943 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773943 = validateParameter(valid_773943, JString, required = false,
                                 default = nil)
  if valid_773943 != nil:
    section.add "X-Amz-SignedHeaders", valid_773943
  var valid_773944 = header.getOrDefault("X-Amz-Credential")
  valid_773944 = validateParameter(valid_773944, JString, required = false,
                                 default = nil)
  if valid_773944 != nil:
    section.add "X-Amz-Credential", valid_773944
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773946: Call_CreatePolicyVersion_773933; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ## 
  let valid = call_773946.validator(path, query, header, formData, body)
  let scheme = call_773946.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773946.url(scheme.get, call_773946.host, call_773946.base,
                         call_773946.route, valid.getOrDefault("path"))
  result = hook(call_773946, url, valid)

proc call*(call_773947: Call_CreatePolicyVersion_773933; policyName: string;
          body: JsonNode; setAsDefault: bool = false): Recallable =
  ## createPolicyVersion
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ##   setAsDefault: bool
  ##               : Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
  ##   policyName: string (required)
  ##             : The policy name.
  ##   body: JObject (required)
  var path_773948 = newJObject()
  var query_773949 = newJObject()
  var body_773950 = newJObject()
  add(query_773949, "setAsDefault", newJBool(setAsDefault))
  add(path_773948, "policyName", newJString(policyName))
  if body != nil:
    body_773950 = body
  result = call_773947.call(path_773948, query_773949, nil, nil, body_773950)

var createPolicyVersion* = Call_CreatePolicyVersion_773933(
    name: "createPolicyVersion", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/policies/{policyName}/version",
    validator: validate_CreatePolicyVersion_773934, base: "/",
    url: url_CreatePolicyVersion_773935, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicyVersions_773919 = ref object of OpenApiRestCall_772597
proc url_ListPolicyVersions_773921(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_ListPolicyVersions_773920(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Lists the versions of the specified policy and identifies the default version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_773922 = path.getOrDefault("policyName")
  valid_773922 = validateParameter(valid_773922, JString, required = true,
                                 default = nil)
  if valid_773922 != nil:
    section.add "policyName", valid_773922
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773923 = header.getOrDefault("X-Amz-Date")
  valid_773923 = validateParameter(valid_773923, JString, required = false,
                                 default = nil)
  if valid_773923 != nil:
    section.add "X-Amz-Date", valid_773923
  var valid_773924 = header.getOrDefault("X-Amz-Security-Token")
  valid_773924 = validateParameter(valid_773924, JString, required = false,
                                 default = nil)
  if valid_773924 != nil:
    section.add "X-Amz-Security-Token", valid_773924
  var valid_773925 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773925 = validateParameter(valid_773925, JString, required = false,
                                 default = nil)
  if valid_773925 != nil:
    section.add "X-Amz-Content-Sha256", valid_773925
  var valid_773926 = header.getOrDefault("X-Amz-Algorithm")
  valid_773926 = validateParameter(valid_773926, JString, required = false,
                                 default = nil)
  if valid_773926 != nil:
    section.add "X-Amz-Algorithm", valid_773926
  var valid_773927 = header.getOrDefault("X-Amz-Signature")
  valid_773927 = validateParameter(valid_773927, JString, required = false,
                                 default = nil)
  if valid_773927 != nil:
    section.add "X-Amz-Signature", valid_773927
  var valid_773928 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773928 = validateParameter(valid_773928, JString, required = false,
                                 default = nil)
  if valid_773928 != nil:
    section.add "X-Amz-SignedHeaders", valid_773928
  var valid_773929 = header.getOrDefault("X-Amz-Credential")
  valid_773929 = validateParameter(valid_773929, JString, required = false,
                                 default = nil)
  if valid_773929 != nil:
    section.add "X-Amz-Credential", valid_773929
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773930: Call_ListPolicyVersions_773919; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the versions of the specified policy and identifies the default version.
  ## 
  let valid = call_773930.validator(path, query, header, formData, body)
  let scheme = call_773930.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773930.url(scheme.get, call_773930.host, call_773930.base,
                         call_773930.route, valid.getOrDefault("path"))
  result = hook(call_773930, url, valid)

proc call*(call_773931: Call_ListPolicyVersions_773919; policyName: string): Recallable =
  ## listPolicyVersions
  ## Lists the versions of the specified policy and identifies the default version.
  ##   policyName: string (required)
  ##             : The policy name.
  var path_773932 = newJObject()
  add(path_773932, "policyName", newJString(policyName))
  result = call_773931.call(path_773932, nil, nil, nil, nil)

var listPolicyVersions* = Call_ListPolicyVersions_773919(
    name: "listPolicyVersions", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version",
    validator: validate_ListPolicyVersions_773920, base: "/",
    url: url_ListPolicyVersions_773921, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateRoleAlias_773965 = ref object of OpenApiRestCall_772597
proc url_UpdateRoleAlias_773967(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_UpdateRoleAlias_773966(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Updates a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_773968 = path.getOrDefault("roleAlias")
  valid_773968 = validateParameter(valid_773968, JString, required = true,
                                 default = nil)
  if valid_773968 != nil:
    section.add "roleAlias", valid_773968
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773969 = header.getOrDefault("X-Amz-Date")
  valid_773969 = validateParameter(valid_773969, JString, required = false,
                                 default = nil)
  if valid_773969 != nil:
    section.add "X-Amz-Date", valid_773969
  var valid_773970 = header.getOrDefault("X-Amz-Security-Token")
  valid_773970 = validateParameter(valid_773970, JString, required = false,
                                 default = nil)
  if valid_773970 != nil:
    section.add "X-Amz-Security-Token", valid_773970
  var valid_773971 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773971 = validateParameter(valid_773971, JString, required = false,
                                 default = nil)
  if valid_773971 != nil:
    section.add "X-Amz-Content-Sha256", valid_773971
  var valid_773972 = header.getOrDefault("X-Amz-Algorithm")
  valid_773972 = validateParameter(valid_773972, JString, required = false,
                                 default = nil)
  if valid_773972 != nil:
    section.add "X-Amz-Algorithm", valid_773972
  var valid_773973 = header.getOrDefault("X-Amz-Signature")
  valid_773973 = validateParameter(valid_773973, JString, required = false,
                                 default = nil)
  if valid_773973 != nil:
    section.add "X-Amz-Signature", valid_773973
  var valid_773974 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773974 = validateParameter(valid_773974, JString, required = false,
                                 default = nil)
  if valid_773974 != nil:
    section.add "X-Amz-SignedHeaders", valid_773974
  var valid_773975 = header.getOrDefault("X-Amz-Credential")
  valid_773975 = validateParameter(valid_773975, JString, required = false,
                                 default = nil)
  if valid_773975 != nil:
    section.add "X-Amz-Credential", valid_773975
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773977: Call_UpdateRoleAlias_773965; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a role alias.
  ## 
  let valid = call_773977.validator(path, query, header, formData, body)
  let scheme = call_773977.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773977.url(scheme.get, call_773977.host, call_773977.base,
                         call_773977.route, valid.getOrDefault("path"))
  result = hook(call_773977, url, valid)

proc call*(call_773978: Call_UpdateRoleAlias_773965; body: JsonNode;
          roleAlias: string): Recallable =
  ## updateRoleAlias
  ## Updates a role alias.
  ##   body: JObject (required)
  ##   roleAlias: string (required)
  ##            : The role alias to update.
  var path_773979 = newJObject()
  var body_773980 = newJObject()
  if body != nil:
    body_773980 = body
  add(path_773979, "roleAlias", newJString(roleAlias))
  result = call_773978.call(path_773979, nil, nil, nil, body_773980)

var updateRoleAlias* = Call_UpdateRoleAlias_773965(name: "updateRoleAlias",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_UpdateRoleAlias_773966,
    base: "/", url: url_UpdateRoleAlias_773967, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateRoleAlias_773981 = ref object of OpenApiRestCall_772597
proc url_CreateRoleAlias_773983(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CreateRoleAlias_773982(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias that points to a role ARN. This allows you to change the role without having to update the device.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_773984 = path.getOrDefault("roleAlias")
  valid_773984 = validateParameter(valid_773984, JString, required = true,
                                 default = nil)
  if valid_773984 != nil:
    section.add "roleAlias", valid_773984
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773985 = header.getOrDefault("X-Amz-Date")
  valid_773985 = validateParameter(valid_773985, JString, required = false,
                                 default = nil)
  if valid_773985 != nil:
    section.add "X-Amz-Date", valid_773985
  var valid_773986 = header.getOrDefault("X-Amz-Security-Token")
  valid_773986 = validateParameter(valid_773986, JString, required = false,
                                 default = nil)
  if valid_773986 != nil:
    section.add "X-Amz-Security-Token", valid_773986
  var valid_773987 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773987 = validateParameter(valid_773987, JString, required = false,
                                 default = nil)
  if valid_773987 != nil:
    section.add "X-Amz-Content-Sha256", valid_773987
  var valid_773988 = header.getOrDefault("X-Amz-Algorithm")
  valid_773988 = validateParameter(valid_773988, JString, required = false,
                                 default = nil)
  if valid_773988 != nil:
    section.add "X-Amz-Algorithm", valid_773988
  var valid_773989 = header.getOrDefault("X-Amz-Signature")
  valid_773989 = validateParameter(valid_773989, JString, required = false,
                                 default = nil)
  if valid_773989 != nil:
    section.add "X-Amz-Signature", valid_773989
  var valid_773990 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773990 = validateParameter(valid_773990, JString, required = false,
                                 default = nil)
  if valid_773990 != nil:
    section.add "X-Amz-SignedHeaders", valid_773990
  var valid_773991 = header.getOrDefault("X-Amz-Credential")
  valid_773991 = validateParameter(valid_773991, JString, required = false,
                                 default = nil)
  if valid_773991 != nil:
    section.add "X-Amz-Credential", valid_773991
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_773993: Call_CreateRoleAlias_773981; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a role alias.
  ## 
  let valid = call_773993.validator(path, query, header, formData, body)
  let scheme = call_773993.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773993.url(scheme.get, call_773993.host, call_773993.base,
                         call_773993.route, valid.getOrDefault("path"))
  result = hook(call_773993, url, valid)

proc call*(call_773994: Call_CreateRoleAlias_773981; body: JsonNode;
          roleAlias: string): Recallable =
  ## createRoleAlias
  ## Creates a role alias.
  ##   body: JObject (required)
  ##   roleAlias: string (required)
  ##            : The role alias that points to a role ARN. This allows you to change the role without having to update the device.
  var path_773995 = newJObject()
  var body_773996 = newJObject()
  if body != nil:
    body_773996 = body
  add(path_773995, "roleAlias", newJString(roleAlias))
  result = call_773994.call(path_773995, nil, nil, nil, body_773996)

var createRoleAlias* = Call_CreateRoleAlias_773981(name: "createRoleAlias",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_CreateRoleAlias_773982,
    base: "/", url: url_CreateRoleAlias_773983, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeRoleAlias_773951 = ref object of OpenApiRestCall_772597
proc url_DescribeRoleAlias_773953(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeRoleAlias_773952(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Describes a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to describe.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_773954 = path.getOrDefault("roleAlias")
  valid_773954 = validateParameter(valid_773954, JString, required = true,
                                 default = nil)
  if valid_773954 != nil:
    section.add "roleAlias", valid_773954
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_773955 = header.getOrDefault("X-Amz-Date")
  valid_773955 = validateParameter(valid_773955, JString, required = false,
                                 default = nil)
  if valid_773955 != nil:
    section.add "X-Amz-Date", valid_773955
  var valid_773956 = header.getOrDefault("X-Amz-Security-Token")
  valid_773956 = validateParameter(valid_773956, JString, required = false,
                                 default = nil)
  if valid_773956 != nil:
    section.add "X-Amz-Security-Token", valid_773956
  var valid_773957 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_773957 = validateParameter(valid_773957, JString, required = false,
                                 default = nil)
  if valid_773957 != nil:
    section.add "X-Amz-Content-Sha256", valid_773957
  var valid_773958 = header.getOrDefault("X-Amz-Algorithm")
  valid_773958 = validateParameter(valid_773958, JString, required = false,
                                 default = nil)
  if valid_773958 != nil:
    section.add "X-Amz-Algorithm", valid_773958
  var valid_773959 = header.getOrDefault("X-Amz-Signature")
  valid_773959 = validateParameter(valid_773959, JString, required = false,
                                 default = nil)
  if valid_773959 != nil:
    section.add "X-Amz-Signature", valid_773959
  var valid_773960 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_773960 = validateParameter(valid_773960, JString, required = false,
                                 default = nil)
  if valid_773960 != nil:
    section.add "X-Amz-SignedHeaders", valid_773960
  var valid_773961 = header.getOrDefault("X-Amz-Credential")
  valid_773961 = validateParameter(valid_773961, JString, required = false,
                                 default = nil)
  if valid_773961 != nil:
    section.add "X-Amz-Credential", valid_773961
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_773962: Call_DescribeRoleAlias_773951; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a role alias.
  ## 
  let valid = call_773962.validator(path, query, header, formData, body)
  let scheme = call_773962.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_773962.url(scheme.get, call_773962.host, call_773962.base,
                         call_773962.route, valid.getOrDefault("path"))
  result = hook(call_773962, url, valid)

proc call*(call_773963: Call_DescribeRoleAlias_773951; roleAlias: string): Recallable =
  ## describeRoleAlias
  ## Describes a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias to describe.
  var path_773964 = newJObject()
  add(path_773964, "roleAlias", newJString(roleAlias))
  result = call_773963.call(path_773964, nil, nil, nil, nil)

var describeRoleAlias* = Call_DescribeRoleAlias_773951(name: "describeRoleAlias",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_DescribeRoleAlias_773952,
    base: "/", url: url_DescribeRoleAlias_773953,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRoleAlias_773997 = ref object of OpenApiRestCall_772597
proc url_DeleteRoleAlias_773999(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteRoleAlias_773998(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes a role alias
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_774000 = path.getOrDefault("roleAlias")
  valid_774000 = validateParameter(valid_774000, JString, required = true,
                                 default = nil)
  if valid_774000 != nil:
    section.add "roleAlias", valid_774000
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774001 = header.getOrDefault("X-Amz-Date")
  valid_774001 = validateParameter(valid_774001, JString, required = false,
                                 default = nil)
  if valid_774001 != nil:
    section.add "X-Amz-Date", valid_774001
  var valid_774002 = header.getOrDefault("X-Amz-Security-Token")
  valid_774002 = validateParameter(valid_774002, JString, required = false,
                                 default = nil)
  if valid_774002 != nil:
    section.add "X-Amz-Security-Token", valid_774002
  var valid_774003 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774003 = validateParameter(valid_774003, JString, required = false,
                                 default = nil)
  if valid_774003 != nil:
    section.add "X-Amz-Content-Sha256", valid_774003
  var valid_774004 = header.getOrDefault("X-Amz-Algorithm")
  valid_774004 = validateParameter(valid_774004, JString, required = false,
                                 default = nil)
  if valid_774004 != nil:
    section.add "X-Amz-Algorithm", valid_774004
  var valid_774005 = header.getOrDefault("X-Amz-Signature")
  valid_774005 = validateParameter(valid_774005, JString, required = false,
                                 default = nil)
  if valid_774005 != nil:
    section.add "X-Amz-Signature", valid_774005
  var valid_774006 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774006 = validateParameter(valid_774006, JString, required = false,
                                 default = nil)
  if valid_774006 != nil:
    section.add "X-Amz-SignedHeaders", valid_774006
  var valid_774007 = header.getOrDefault("X-Amz-Credential")
  valid_774007 = validateParameter(valid_774007, JString, required = false,
                                 default = nil)
  if valid_774007 != nil:
    section.add "X-Amz-Credential", valid_774007
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774008: Call_DeleteRoleAlias_773997; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a role alias
  ## 
  let valid = call_774008.validator(path, query, header, formData, body)
  let scheme = call_774008.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774008.url(scheme.get, call_774008.host, call_774008.base,
                         call_774008.route, valid.getOrDefault("path"))
  result = hook(call_774008, url, valid)

proc call*(call_774009: Call_DeleteRoleAlias_773997; roleAlias: string): Recallable =
  ## deleteRoleAlias
  ## Deletes a role alias
  ##   roleAlias: string (required)
  ##            : The role alias to delete.
  var path_774010 = newJObject()
  add(path_774010, "roleAlias", newJString(roleAlias))
  result = call_774009.call(path_774010, nil, nil, nil, nil)

var deleteRoleAlias* = Call_DeleteRoleAlias_773997(name: "deleteRoleAlias",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_DeleteRoleAlias_773998,
    base: "/", url: url_DeleteRoleAlias_773999, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateScheduledAudit_774025 = ref object of OpenApiRestCall_772597
proc url_CreateScheduledAudit_774027(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CreateScheduledAudit_774026(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled audit that is run at a specified time interval.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name you want to give to the scheduled audit. (Max. 128 chars)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_774028 = path.getOrDefault("scheduledAuditName")
  valid_774028 = validateParameter(valid_774028, JString, required = true,
                                 default = nil)
  if valid_774028 != nil:
    section.add "scheduledAuditName", valid_774028
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774029 = header.getOrDefault("X-Amz-Date")
  valid_774029 = validateParameter(valid_774029, JString, required = false,
                                 default = nil)
  if valid_774029 != nil:
    section.add "X-Amz-Date", valid_774029
  var valid_774030 = header.getOrDefault("X-Amz-Security-Token")
  valid_774030 = validateParameter(valid_774030, JString, required = false,
                                 default = nil)
  if valid_774030 != nil:
    section.add "X-Amz-Security-Token", valid_774030
  var valid_774031 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774031 = validateParameter(valid_774031, JString, required = false,
                                 default = nil)
  if valid_774031 != nil:
    section.add "X-Amz-Content-Sha256", valid_774031
  var valid_774032 = header.getOrDefault("X-Amz-Algorithm")
  valid_774032 = validateParameter(valid_774032, JString, required = false,
                                 default = nil)
  if valid_774032 != nil:
    section.add "X-Amz-Algorithm", valid_774032
  var valid_774033 = header.getOrDefault("X-Amz-Signature")
  valid_774033 = validateParameter(valid_774033, JString, required = false,
                                 default = nil)
  if valid_774033 != nil:
    section.add "X-Amz-Signature", valid_774033
  var valid_774034 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774034 = validateParameter(valid_774034, JString, required = false,
                                 default = nil)
  if valid_774034 != nil:
    section.add "X-Amz-SignedHeaders", valid_774034
  var valid_774035 = header.getOrDefault("X-Amz-Credential")
  valid_774035 = validateParameter(valid_774035, JString, required = false,
                                 default = nil)
  if valid_774035 != nil:
    section.add "X-Amz-Credential", valid_774035
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774037: Call_CreateScheduledAudit_774025; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled audit that is run at a specified time interval.
  ## 
  let valid = call_774037.validator(path, query, header, formData, body)
  let scheme = call_774037.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774037.url(scheme.get, call_774037.host, call_774037.base,
                         call_774037.route, valid.getOrDefault("path"))
  result = hook(call_774037, url, valid)

proc call*(call_774038: Call_CreateScheduledAudit_774025;
          scheduledAuditName: string; body: JsonNode): Recallable =
  ## createScheduledAudit
  ## Creates a scheduled audit that is run at a specified time interval.
  ##   scheduledAuditName: string (required)
  ##                     : The name you want to give to the scheduled audit. (Max. 128 chars)
  ##   body: JObject (required)
  var path_774039 = newJObject()
  var body_774040 = newJObject()
  add(path_774039, "scheduledAuditName", newJString(scheduledAuditName))
  if body != nil:
    body_774040 = body
  result = call_774038.call(path_774039, nil, nil, nil, body_774040)

var createScheduledAudit* = Call_CreateScheduledAudit_774025(
    name: "createScheduledAudit", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_CreateScheduledAudit_774026, base: "/",
    url: url_CreateScheduledAudit_774027, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeScheduledAudit_774011 = ref object of OpenApiRestCall_772597
proc url_DescribeScheduledAudit_774013(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeScheduledAudit_774012(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a scheduled audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit whose information you want to get.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_774014 = path.getOrDefault("scheduledAuditName")
  valid_774014 = validateParameter(valid_774014, JString, required = true,
                                 default = nil)
  if valid_774014 != nil:
    section.add "scheduledAuditName", valid_774014
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774015 = header.getOrDefault("X-Amz-Date")
  valid_774015 = validateParameter(valid_774015, JString, required = false,
                                 default = nil)
  if valid_774015 != nil:
    section.add "X-Amz-Date", valid_774015
  var valid_774016 = header.getOrDefault("X-Amz-Security-Token")
  valid_774016 = validateParameter(valid_774016, JString, required = false,
                                 default = nil)
  if valid_774016 != nil:
    section.add "X-Amz-Security-Token", valid_774016
  var valid_774017 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774017 = validateParameter(valid_774017, JString, required = false,
                                 default = nil)
  if valid_774017 != nil:
    section.add "X-Amz-Content-Sha256", valid_774017
  var valid_774018 = header.getOrDefault("X-Amz-Algorithm")
  valid_774018 = validateParameter(valid_774018, JString, required = false,
                                 default = nil)
  if valid_774018 != nil:
    section.add "X-Amz-Algorithm", valid_774018
  var valid_774019 = header.getOrDefault("X-Amz-Signature")
  valid_774019 = validateParameter(valid_774019, JString, required = false,
                                 default = nil)
  if valid_774019 != nil:
    section.add "X-Amz-Signature", valid_774019
  var valid_774020 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774020 = validateParameter(valid_774020, JString, required = false,
                                 default = nil)
  if valid_774020 != nil:
    section.add "X-Amz-SignedHeaders", valid_774020
  var valid_774021 = header.getOrDefault("X-Amz-Credential")
  valid_774021 = validateParameter(valid_774021, JString, required = false,
                                 default = nil)
  if valid_774021 != nil:
    section.add "X-Amz-Credential", valid_774021
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774022: Call_DescribeScheduledAudit_774011; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a scheduled audit.
  ## 
  let valid = call_774022.validator(path, query, header, formData, body)
  let scheme = call_774022.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774022.url(scheme.get, call_774022.host, call_774022.base,
                         call_774022.route, valid.getOrDefault("path"))
  result = hook(call_774022, url, valid)

proc call*(call_774023: Call_DescribeScheduledAudit_774011;
          scheduledAuditName: string): Recallable =
  ## describeScheduledAudit
  ## Gets information about a scheduled audit.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit whose information you want to get.
  var path_774024 = newJObject()
  add(path_774024, "scheduledAuditName", newJString(scheduledAuditName))
  result = call_774023.call(path_774024, nil, nil, nil, nil)

var describeScheduledAudit* = Call_DescribeScheduledAudit_774011(
    name: "describeScheduledAudit", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_DescribeScheduledAudit_774012, base: "/",
    url: url_DescribeScheduledAudit_774013, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateScheduledAudit_774055 = ref object of OpenApiRestCall_772597
proc url_UpdateScheduledAudit_774057(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_UpdateScheduledAudit_774056(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit. (Max. 128 chars)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_774058 = path.getOrDefault("scheduledAuditName")
  valid_774058 = validateParameter(valid_774058, JString, required = true,
                                 default = nil)
  if valid_774058 != nil:
    section.add "scheduledAuditName", valid_774058
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774059 = header.getOrDefault("X-Amz-Date")
  valid_774059 = validateParameter(valid_774059, JString, required = false,
                                 default = nil)
  if valid_774059 != nil:
    section.add "X-Amz-Date", valid_774059
  var valid_774060 = header.getOrDefault("X-Amz-Security-Token")
  valid_774060 = validateParameter(valid_774060, JString, required = false,
                                 default = nil)
  if valid_774060 != nil:
    section.add "X-Amz-Security-Token", valid_774060
  var valid_774061 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774061 = validateParameter(valid_774061, JString, required = false,
                                 default = nil)
  if valid_774061 != nil:
    section.add "X-Amz-Content-Sha256", valid_774061
  var valid_774062 = header.getOrDefault("X-Amz-Algorithm")
  valid_774062 = validateParameter(valid_774062, JString, required = false,
                                 default = nil)
  if valid_774062 != nil:
    section.add "X-Amz-Algorithm", valid_774062
  var valid_774063 = header.getOrDefault("X-Amz-Signature")
  valid_774063 = validateParameter(valid_774063, JString, required = false,
                                 default = nil)
  if valid_774063 != nil:
    section.add "X-Amz-Signature", valid_774063
  var valid_774064 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774064 = validateParameter(valid_774064, JString, required = false,
                                 default = nil)
  if valid_774064 != nil:
    section.add "X-Amz-SignedHeaders", valid_774064
  var valid_774065 = header.getOrDefault("X-Amz-Credential")
  valid_774065 = validateParameter(valid_774065, JString, required = false,
                                 default = nil)
  if valid_774065 != nil:
    section.add "X-Amz-Credential", valid_774065
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774067: Call_UpdateScheduledAudit_774055; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ## 
  let valid = call_774067.validator(path, query, header, formData, body)
  let scheme = call_774067.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774067.url(scheme.get, call_774067.host, call_774067.base,
                         call_774067.route, valid.getOrDefault("path"))
  result = hook(call_774067, url, valid)

proc call*(call_774068: Call_UpdateScheduledAudit_774055;
          scheduledAuditName: string; body: JsonNode): Recallable =
  ## updateScheduledAudit
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit. (Max. 128 chars)
  ##   body: JObject (required)
  var path_774069 = newJObject()
  var body_774070 = newJObject()
  add(path_774069, "scheduledAuditName", newJString(scheduledAuditName))
  if body != nil:
    body_774070 = body
  result = call_774068.call(path_774069, nil, nil, nil, body_774070)

var updateScheduledAudit* = Call_UpdateScheduledAudit_774055(
    name: "updateScheduledAudit", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_UpdateScheduledAudit_774056, base: "/",
    url: url_UpdateScheduledAudit_774057, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteScheduledAudit_774041 = ref object of OpenApiRestCall_772597
proc url_DeleteScheduledAudit_774043(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteScheduledAudit_774042(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit you want to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_774044 = path.getOrDefault("scheduledAuditName")
  valid_774044 = validateParameter(valid_774044, JString, required = true,
                                 default = nil)
  if valid_774044 != nil:
    section.add "scheduledAuditName", valid_774044
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774045 = header.getOrDefault("X-Amz-Date")
  valid_774045 = validateParameter(valid_774045, JString, required = false,
                                 default = nil)
  if valid_774045 != nil:
    section.add "X-Amz-Date", valid_774045
  var valid_774046 = header.getOrDefault("X-Amz-Security-Token")
  valid_774046 = validateParameter(valid_774046, JString, required = false,
                                 default = nil)
  if valid_774046 != nil:
    section.add "X-Amz-Security-Token", valid_774046
  var valid_774047 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774047 = validateParameter(valid_774047, JString, required = false,
                                 default = nil)
  if valid_774047 != nil:
    section.add "X-Amz-Content-Sha256", valid_774047
  var valid_774048 = header.getOrDefault("X-Amz-Algorithm")
  valid_774048 = validateParameter(valid_774048, JString, required = false,
                                 default = nil)
  if valid_774048 != nil:
    section.add "X-Amz-Algorithm", valid_774048
  var valid_774049 = header.getOrDefault("X-Amz-Signature")
  valid_774049 = validateParameter(valid_774049, JString, required = false,
                                 default = nil)
  if valid_774049 != nil:
    section.add "X-Amz-Signature", valid_774049
  var valid_774050 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774050 = validateParameter(valid_774050, JString, required = false,
                                 default = nil)
  if valid_774050 != nil:
    section.add "X-Amz-SignedHeaders", valid_774050
  var valid_774051 = header.getOrDefault("X-Amz-Credential")
  valid_774051 = validateParameter(valid_774051, JString, required = false,
                                 default = nil)
  if valid_774051 != nil:
    section.add "X-Amz-Credential", valid_774051
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774052: Call_DeleteScheduledAudit_774041; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled audit.
  ## 
  let valid = call_774052.validator(path, query, header, formData, body)
  let scheme = call_774052.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774052.url(scheme.get, call_774052.host, call_774052.base,
                         call_774052.route, valid.getOrDefault("path"))
  result = hook(call_774052, url, valid)

proc call*(call_774053: Call_DeleteScheduledAudit_774041;
          scheduledAuditName: string): Recallable =
  ## deleteScheduledAudit
  ## Deletes a scheduled audit.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit you want to delete.
  var path_774054 = newJObject()
  add(path_774054, "scheduledAuditName", newJString(scheduledAuditName))
  result = call_774053.call(path_774054, nil, nil, nil, nil)

var deleteScheduledAudit* = Call_DeleteScheduledAudit_774041(
    name: "deleteScheduledAudit", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_DeleteScheduledAudit_774042, base: "/",
    url: url_DeleteScheduledAudit_774043, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateSecurityProfile_774085 = ref object of OpenApiRestCall_772597
proc url_CreateSecurityProfile_774087(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CreateSecurityProfile_774086(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name you are giving to the security profile.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_774088 = path.getOrDefault("securityProfileName")
  valid_774088 = validateParameter(valid_774088, JString, required = true,
                                 default = nil)
  if valid_774088 != nil:
    section.add "securityProfileName", valid_774088
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774089 = header.getOrDefault("X-Amz-Date")
  valid_774089 = validateParameter(valid_774089, JString, required = false,
                                 default = nil)
  if valid_774089 != nil:
    section.add "X-Amz-Date", valid_774089
  var valid_774090 = header.getOrDefault("X-Amz-Security-Token")
  valid_774090 = validateParameter(valid_774090, JString, required = false,
                                 default = nil)
  if valid_774090 != nil:
    section.add "X-Amz-Security-Token", valid_774090
  var valid_774091 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774091 = validateParameter(valid_774091, JString, required = false,
                                 default = nil)
  if valid_774091 != nil:
    section.add "X-Amz-Content-Sha256", valid_774091
  var valid_774092 = header.getOrDefault("X-Amz-Algorithm")
  valid_774092 = validateParameter(valid_774092, JString, required = false,
                                 default = nil)
  if valid_774092 != nil:
    section.add "X-Amz-Algorithm", valid_774092
  var valid_774093 = header.getOrDefault("X-Amz-Signature")
  valid_774093 = validateParameter(valid_774093, JString, required = false,
                                 default = nil)
  if valid_774093 != nil:
    section.add "X-Amz-Signature", valid_774093
  var valid_774094 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774094 = validateParameter(valid_774094, JString, required = false,
                                 default = nil)
  if valid_774094 != nil:
    section.add "X-Amz-SignedHeaders", valid_774094
  var valid_774095 = header.getOrDefault("X-Amz-Credential")
  valid_774095 = validateParameter(valid_774095, JString, required = false,
                                 default = nil)
  if valid_774095 != nil:
    section.add "X-Amz-Credential", valid_774095
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774097: Call_CreateSecurityProfile_774085; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Device Defender security profile.
  ## 
  let valid = call_774097.validator(path, query, header, formData, body)
  let scheme = call_774097.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774097.url(scheme.get, call_774097.host, call_774097.base,
                         call_774097.route, valid.getOrDefault("path"))
  result = hook(call_774097, url, valid)

proc call*(call_774098: Call_CreateSecurityProfile_774085; body: JsonNode;
          securityProfileName: string): Recallable =
  ## createSecurityProfile
  ## Creates a Device Defender security profile.
  ##   body: JObject (required)
  ##   securityProfileName: string (required)
  ##                      : The name you are giving to the security profile.
  var path_774099 = newJObject()
  var body_774100 = newJObject()
  if body != nil:
    body_774100 = body
  add(path_774099, "securityProfileName", newJString(securityProfileName))
  result = call_774098.call(path_774099, nil, nil, nil, body_774100)

var createSecurityProfile* = Call_CreateSecurityProfile_774085(
    name: "createSecurityProfile", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_CreateSecurityProfile_774086, base: "/",
    url: url_CreateSecurityProfile_774087, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeSecurityProfile_774071 = ref object of OpenApiRestCall_772597
proc url_DescribeSecurityProfile_774073(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeSecurityProfile_774072(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile whose information you want to get.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_774074 = path.getOrDefault("securityProfileName")
  valid_774074 = validateParameter(valid_774074, JString, required = true,
                                 default = nil)
  if valid_774074 != nil:
    section.add "securityProfileName", valid_774074
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774075 = header.getOrDefault("X-Amz-Date")
  valid_774075 = validateParameter(valid_774075, JString, required = false,
                                 default = nil)
  if valid_774075 != nil:
    section.add "X-Amz-Date", valid_774075
  var valid_774076 = header.getOrDefault("X-Amz-Security-Token")
  valid_774076 = validateParameter(valid_774076, JString, required = false,
                                 default = nil)
  if valid_774076 != nil:
    section.add "X-Amz-Security-Token", valid_774076
  var valid_774077 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774077 = validateParameter(valid_774077, JString, required = false,
                                 default = nil)
  if valid_774077 != nil:
    section.add "X-Amz-Content-Sha256", valid_774077
  var valid_774078 = header.getOrDefault("X-Amz-Algorithm")
  valid_774078 = validateParameter(valid_774078, JString, required = false,
                                 default = nil)
  if valid_774078 != nil:
    section.add "X-Amz-Algorithm", valid_774078
  var valid_774079 = header.getOrDefault("X-Amz-Signature")
  valid_774079 = validateParameter(valid_774079, JString, required = false,
                                 default = nil)
  if valid_774079 != nil:
    section.add "X-Amz-Signature", valid_774079
  var valid_774080 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774080 = validateParameter(valid_774080, JString, required = false,
                                 default = nil)
  if valid_774080 != nil:
    section.add "X-Amz-SignedHeaders", valid_774080
  var valid_774081 = header.getOrDefault("X-Amz-Credential")
  valid_774081 = validateParameter(valid_774081, JString, required = false,
                                 default = nil)
  if valid_774081 != nil:
    section.add "X-Amz-Credential", valid_774081
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774082: Call_DescribeSecurityProfile_774071; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a Device Defender security profile.
  ## 
  let valid = call_774082.validator(path, query, header, formData, body)
  let scheme = call_774082.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774082.url(scheme.get, call_774082.host, call_774082.base,
                         call_774082.route, valid.getOrDefault("path"))
  result = hook(call_774082, url, valid)

proc call*(call_774083: Call_DescribeSecurityProfile_774071;
          securityProfileName: string): Recallable =
  ## describeSecurityProfile
  ## Gets information about a Device Defender security profile.
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile whose information you want to get.
  var path_774084 = newJObject()
  add(path_774084, "securityProfileName", newJString(securityProfileName))
  result = call_774083.call(path_774084, nil, nil, nil, nil)

var describeSecurityProfile* = Call_DescribeSecurityProfile_774071(
    name: "describeSecurityProfile", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_DescribeSecurityProfile_774072, base: "/",
    url: url_DescribeSecurityProfile_774073, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateSecurityProfile_774117 = ref object of OpenApiRestCall_772597
proc url_UpdateSecurityProfile_774119(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_UpdateSecurityProfile_774118(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile you want to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_774120 = path.getOrDefault("securityProfileName")
  valid_774120 = validateParameter(valid_774120, JString, required = true,
                                 default = nil)
  if valid_774120 != nil:
    section.add "securityProfileName", valid_774120
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  section = newJObject()
  var valid_774121 = query.getOrDefault("expectedVersion")
  valid_774121 = validateParameter(valid_774121, JInt, required = false, default = nil)
  if valid_774121 != nil:
    section.add "expectedVersion", valid_774121
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774122 = header.getOrDefault("X-Amz-Date")
  valid_774122 = validateParameter(valid_774122, JString, required = false,
                                 default = nil)
  if valid_774122 != nil:
    section.add "X-Amz-Date", valid_774122
  var valid_774123 = header.getOrDefault("X-Amz-Security-Token")
  valid_774123 = validateParameter(valid_774123, JString, required = false,
                                 default = nil)
  if valid_774123 != nil:
    section.add "X-Amz-Security-Token", valid_774123
  var valid_774124 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774124 = validateParameter(valid_774124, JString, required = false,
                                 default = nil)
  if valid_774124 != nil:
    section.add "X-Amz-Content-Sha256", valid_774124
  var valid_774125 = header.getOrDefault("X-Amz-Algorithm")
  valid_774125 = validateParameter(valid_774125, JString, required = false,
                                 default = nil)
  if valid_774125 != nil:
    section.add "X-Amz-Algorithm", valid_774125
  var valid_774126 = header.getOrDefault("X-Amz-Signature")
  valid_774126 = validateParameter(valid_774126, JString, required = false,
                                 default = nil)
  if valid_774126 != nil:
    section.add "X-Amz-Signature", valid_774126
  var valid_774127 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774127 = validateParameter(valid_774127, JString, required = false,
                                 default = nil)
  if valid_774127 != nil:
    section.add "X-Amz-SignedHeaders", valid_774127
  var valid_774128 = header.getOrDefault("X-Amz-Credential")
  valid_774128 = validateParameter(valid_774128, JString, required = false,
                                 default = nil)
  if valid_774128 != nil:
    section.add "X-Amz-Credential", valid_774128
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774130: Call_UpdateSecurityProfile_774117; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a Device Defender security profile.
  ## 
  let valid = call_774130.validator(path, query, header, formData, body)
  let scheme = call_774130.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774130.url(scheme.get, call_774130.host, call_774130.base,
                         call_774130.route, valid.getOrDefault("path"))
  result = hook(call_774130, url, valid)

proc call*(call_774131: Call_UpdateSecurityProfile_774117; body: JsonNode;
          securityProfileName: string; expectedVersion: int = 0): Recallable =
  ## updateSecurityProfile
  ## Updates a Device Defender security profile.
  ##   expectedVersion: int
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  ##   body: JObject (required)
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile you want to update.
  var path_774132 = newJObject()
  var query_774133 = newJObject()
  var body_774134 = newJObject()
  add(query_774133, "expectedVersion", newJInt(expectedVersion))
  if body != nil:
    body_774134 = body
  add(path_774132, "securityProfileName", newJString(securityProfileName))
  result = call_774131.call(path_774132, query_774133, nil, nil, body_774134)

var updateSecurityProfile* = Call_UpdateSecurityProfile_774117(
    name: "updateSecurityProfile", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_UpdateSecurityProfile_774118, base: "/",
    url: url_UpdateSecurityProfile_774119, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteSecurityProfile_774101 = ref object of OpenApiRestCall_772597
proc url_DeleteSecurityProfile_774103(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteSecurityProfile_774102(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile to be deleted.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_774104 = path.getOrDefault("securityProfileName")
  valid_774104 = validateParameter(valid_774104, JString, required = true,
                                 default = nil)
  if valid_774104 != nil:
    section.add "securityProfileName", valid_774104
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  section = newJObject()
  var valid_774105 = query.getOrDefault("expectedVersion")
  valid_774105 = validateParameter(valid_774105, JInt, required = false, default = nil)
  if valid_774105 != nil:
    section.add "expectedVersion", valid_774105
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774106 = header.getOrDefault("X-Amz-Date")
  valid_774106 = validateParameter(valid_774106, JString, required = false,
                                 default = nil)
  if valid_774106 != nil:
    section.add "X-Amz-Date", valid_774106
  var valid_774107 = header.getOrDefault("X-Amz-Security-Token")
  valid_774107 = validateParameter(valid_774107, JString, required = false,
                                 default = nil)
  if valid_774107 != nil:
    section.add "X-Amz-Security-Token", valid_774107
  var valid_774108 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774108 = validateParameter(valid_774108, JString, required = false,
                                 default = nil)
  if valid_774108 != nil:
    section.add "X-Amz-Content-Sha256", valid_774108
  var valid_774109 = header.getOrDefault("X-Amz-Algorithm")
  valid_774109 = validateParameter(valid_774109, JString, required = false,
                                 default = nil)
  if valid_774109 != nil:
    section.add "X-Amz-Algorithm", valid_774109
  var valid_774110 = header.getOrDefault("X-Amz-Signature")
  valid_774110 = validateParameter(valid_774110, JString, required = false,
                                 default = nil)
  if valid_774110 != nil:
    section.add "X-Amz-Signature", valid_774110
  var valid_774111 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774111 = validateParameter(valid_774111, JString, required = false,
                                 default = nil)
  if valid_774111 != nil:
    section.add "X-Amz-SignedHeaders", valid_774111
  var valid_774112 = header.getOrDefault("X-Amz-Credential")
  valid_774112 = validateParameter(valid_774112, JString, required = false,
                                 default = nil)
  if valid_774112 != nil:
    section.add "X-Amz-Credential", valid_774112
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774113: Call_DeleteSecurityProfile_774101; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a Device Defender security profile.
  ## 
  let valid = call_774113.validator(path, query, header, formData, body)
  let scheme = call_774113.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774113.url(scheme.get, call_774113.host, call_774113.base,
                         call_774113.route, valid.getOrDefault("path"))
  result = hook(call_774113, url, valid)

proc call*(call_774114: Call_DeleteSecurityProfile_774101;
          securityProfileName: string; expectedVersion: int = 0): Recallable =
  ## deleteSecurityProfile
  ## Deletes a Device Defender security profile.
  ##   expectedVersion: int
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile to be deleted.
  var path_774115 = newJObject()
  var query_774116 = newJObject()
  add(query_774116, "expectedVersion", newJInt(expectedVersion))
  add(path_774115, "securityProfileName", newJString(securityProfileName))
  result = call_774114.call(path_774115, query_774116, nil, nil, nil)

var deleteSecurityProfile* = Call_DeleteSecurityProfile_774101(
    name: "deleteSecurityProfile", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_DeleteSecurityProfile_774102, base: "/",
    url: url_DeleteSecurityProfile_774103, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateStream_774149 = ref object of OpenApiRestCall_772597
proc url_UpdateStream_774151(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_UpdateStream_774150(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing stream. The stream version will be incremented by one.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_774152 = path.getOrDefault("streamId")
  valid_774152 = validateParameter(valid_774152, JString, required = true,
                                 default = nil)
  if valid_774152 != nil:
    section.add "streamId", valid_774152
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774153 = header.getOrDefault("X-Amz-Date")
  valid_774153 = validateParameter(valid_774153, JString, required = false,
                                 default = nil)
  if valid_774153 != nil:
    section.add "X-Amz-Date", valid_774153
  var valid_774154 = header.getOrDefault("X-Amz-Security-Token")
  valid_774154 = validateParameter(valid_774154, JString, required = false,
                                 default = nil)
  if valid_774154 != nil:
    section.add "X-Amz-Security-Token", valid_774154
  var valid_774155 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774155 = validateParameter(valid_774155, JString, required = false,
                                 default = nil)
  if valid_774155 != nil:
    section.add "X-Amz-Content-Sha256", valid_774155
  var valid_774156 = header.getOrDefault("X-Amz-Algorithm")
  valid_774156 = validateParameter(valid_774156, JString, required = false,
                                 default = nil)
  if valid_774156 != nil:
    section.add "X-Amz-Algorithm", valid_774156
  var valid_774157 = header.getOrDefault("X-Amz-Signature")
  valid_774157 = validateParameter(valid_774157, JString, required = false,
                                 default = nil)
  if valid_774157 != nil:
    section.add "X-Amz-Signature", valid_774157
  var valid_774158 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774158 = validateParameter(valid_774158, JString, required = false,
                                 default = nil)
  if valid_774158 != nil:
    section.add "X-Amz-SignedHeaders", valid_774158
  var valid_774159 = header.getOrDefault("X-Amz-Credential")
  valid_774159 = validateParameter(valid_774159, JString, required = false,
                                 default = nil)
  if valid_774159 != nil:
    section.add "X-Amz-Credential", valid_774159
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774161: Call_UpdateStream_774149; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing stream. The stream version will be incremented by one.
  ## 
  let valid = call_774161.validator(path, query, header, formData, body)
  let scheme = call_774161.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774161.url(scheme.get, call_774161.host, call_774161.base,
                         call_774161.route, valid.getOrDefault("path"))
  result = hook(call_774161, url, valid)

proc call*(call_774162: Call_UpdateStream_774149; body: JsonNode; streamId: string): Recallable =
  ## updateStream
  ## Updates an existing stream. The stream version will be incremented by one.
  ##   body: JObject (required)
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_774163 = newJObject()
  var body_774164 = newJObject()
  if body != nil:
    body_774164 = body
  add(path_774163, "streamId", newJString(streamId))
  result = call_774162.call(path_774163, nil, nil, nil, body_774164)

var updateStream* = Call_UpdateStream_774149(name: "updateStream",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_UpdateStream_774150,
    base: "/", url: url_UpdateStream_774151, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateStream_774165 = ref object of OpenApiRestCall_772597
proc url_CreateStream_774167(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CreateStream_774166(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream. The total size of a file associated with the stream cannot exceed more than 2 MB. The stream will be created with version 0. If a stream is created with the same streamID as a stream that existed and was deleted within last 90 days, we will resurrect that old stream by incrementing the version by 1.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_774168 = path.getOrDefault("streamId")
  valid_774168 = validateParameter(valid_774168, JString, required = true,
                                 default = nil)
  if valid_774168 != nil:
    section.add "streamId", valid_774168
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774169 = header.getOrDefault("X-Amz-Date")
  valid_774169 = validateParameter(valid_774169, JString, required = false,
                                 default = nil)
  if valid_774169 != nil:
    section.add "X-Amz-Date", valid_774169
  var valid_774170 = header.getOrDefault("X-Amz-Security-Token")
  valid_774170 = validateParameter(valid_774170, JString, required = false,
                                 default = nil)
  if valid_774170 != nil:
    section.add "X-Amz-Security-Token", valid_774170
  var valid_774171 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774171 = validateParameter(valid_774171, JString, required = false,
                                 default = nil)
  if valid_774171 != nil:
    section.add "X-Amz-Content-Sha256", valid_774171
  var valid_774172 = header.getOrDefault("X-Amz-Algorithm")
  valid_774172 = validateParameter(valid_774172, JString, required = false,
                                 default = nil)
  if valid_774172 != nil:
    section.add "X-Amz-Algorithm", valid_774172
  var valid_774173 = header.getOrDefault("X-Amz-Signature")
  valid_774173 = validateParameter(valid_774173, JString, required = false,
                                 default = nil)
  if valid_774173 != nil:
    section.add "X-Amz-Signature", valid_774173
  var valid_774174 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774174 = validateParameter(valid_774174, JString, required = false,
                                 default = nil)
  if valid_774174 != nil:
    section.add "X-Amz-SignedHeaders", valid_774174
  var valid_774175 = header.getOrDefault("X-Amz-Credential")
  valid_774175 = validateParameter(valid_774175, JString, required = false,
                                 default = nil)
  if valid_774175 != nil:
    section.add "X-Amz-Credential", valid_774175
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774177: Call_CreateStream_774165; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream. The total size of a file associated with the stream cannot exceed more than 2 MB. The stream will be created with version 0. If a stream is created with the same streamID as a stream that existed and was deleted within last 90 days, we will resurrect that old stream by incrementing the version by 1.
  ## 
  let valid = call_774177.validator(path, query, header, formData, body)
  let scheme = call_774177.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774177.url(scheme.get, call_774177.host, call_774177.base,
                         call_774177.route, valid.getOrDefault("path"))
  result = hook(call_774177, url, valid)

proc call*(call_774178: Call_CreateStream_774165; body: JsonNode; streamId: string): Recallable =
  ## createStream
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream. The total size of a file associated with the stream cannot exceed more than 2 MB. The stream will be created with version 0. If a stream is created with the same streamID as a stream that existed and was deleted within last 90 days, we will resurrect that old stream by incrementing the version by 1.
  ##   body: JObject (required)
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_774179 = newJObject()
  var body_774180 = newJObject()
  if body != nil:
    body_774180 = body
  add(path_774179, "streamId", newJString(streamId))
  result = call_774178.call(path_774179, nil, nil, nil, body_774180)

var createStream* = Call_CreateStream_774165(name: "createStream",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_CreateStream_774166,
    base: "/", url: url_CreateStream_774167, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeStream_774135 = ref object of OpenApiRestCall_772597
proc url_DescribeStream_774137(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeStream_774136(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets information about a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_774138 = path.getOrDefault("streamId")
  valid_774138 = validateParameter(valid_774138, JString, required = true,
                                 default = nil)
  if valid_774138 != nil:
    section.add "streamId", valid_774138
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774139 = header.getOrDefault("X-Amz-Date")
  valid_774139 = validateParameter(valid_774139, JString, required = false,
                                 default = nil)
  if valid_774139 != nil:
    section.add "X-Amz-Date", valid_774139
  var valid_774140 = header.getOrDefault("X-Amz-Security-Token")
  valid_774140 = validateParameter(valid_774140, JString, required = false,
                                 default = nil)
  if valid_774140 != nil:
    section.add "X-Amz-Security-Token", valid_774140
  var valid_774141 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774141 = validateParameter(valid_774141, JString, required = false,
                                 default = nil)
  if valid_774141 != nil:
    section.add "X-Amz-Content-Sha256", valid_774141
  var valid_774142 = header.getOrDefault("X-Amz-Algorithm")
  valid_774142 = validateParameter(valid_774142, JString, required = false,
                                 default = nil)
  if valid_774142 != nil:
    section.add "X-Amz-Algorithm", valid_774142
  var valid_774143 = header.getOrDefault("X-Amz-Signature")
  valid_774143 = validateParameter(valid_774143, JString, required = false,
                                 default = nil)
  if valid_774143 != nil:
    section.add "X-Amz-Signature", valid_774143
  var valid_774144 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774144 = validateParameter(valid_774144, JString, required = false,
                                 default = nil)
  if valid_774144 != nil:
    section.add "X-Amz-SignedHeaders", valid_774144
  var valid_774145 = header.getOrDefault("X-Amz-Credential")
  valid_774145 = validateParameter(valid_774145, JString, required = false,
                                 default = nil)
  if valid_774145 != nil:
    section.add "X-Amz-Credential", valid_774145
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774146: Call_DescribeStream_774135; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a stream.
  ## 
  let valid = call_774146.validator(path, query, header, formData, body)
  let scheme = call_774146.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774146.url(scheme.get, call_774146.host, call_774146.base,
                         call_774146.route, valid.getOrDefault("path"))
  result = hook(call_774146, url, valid)

proc call*(call_774147: Call_DescribeStream_774135; streamId: string): Recallable =
  ## describeStream
  ## Gets information about a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_774148 = newJObject()
  add(path_774148, "streamId", newJString(streamId))
  result = call_774147.call(path_774148, nil, nil, nil, nil)

var describeStream* = Call_DescribeStream_774135(name: "describeStream",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_DescribeStream_774136,
    base: "/", url: url_DescribeStream_774137, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteStream_774181 = ref object of OpenApiRestCall_772597
proc url_DeleteStream_774183(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteStream_774182(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_774184 = path.getOrDefault("streamId")
  valid_774184 = validateParameter(valid_774184, JString, required = true,
                                 default = nil)
  if valid_774184 != nil:
    section.add "streamId", valid_774184
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774185 = header.getOrDefault("X-Amz-Date")
  valid_774185 = validateParameter(valid_774185, JString, required = false,
                                 default = nil)
  if valid_774185 != nil:
    section.add "X-Amz-Date", valid_774185
  var valid_774186 = header.getOrDefault("X-Amz-Security-Token")
  valid_774186 = validateParameter(valid_774186, JString, required = false,
                                 default = nil)
  if valid_774186 != nil:
    section.add "X-Amz-Security-Token", valid_774186
  var valid_774187 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774187 = validateParameter(valid_774187, JString, required = false,
                                 default = nil)
  if valid_774187 != nil:
    section.add "X-Amz-Content-Sha256", valid_774187
  var valid_774188 = header.getOrDefault("X-Amz-Algorithm")
  valid_774188 = validateParameter(valid_774188, JString, required = false,
                                 default = nil)
  if valid_774188 != nil:
    section.add "X-Amz-Algorithm", valid_774188
  var valid_774189 = header.getOrDefault("X-Amz-Signature")
  valid_774189 = validateParameter(valid_774189, JString, required = false,
                                 default = nil)
  if valid_774189 != nil:
    section.add "X-Amz-Signature", valid_774189
  var valid_774190 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774190 = validateParameter(valid_774190, JString, required = false,
                                 default = nil)
  if valid_774190 != nil:
    section.add "X-Amz-SignedHeaders", valid_774190
  var valid_774191 = header.getOrDefault("X-Amz-Credential")
  valid_774191 = validateParameter(valid_774191, JString, required = false,
                                 default = nil)
  if valid_774191 != nil:
    section.add "X-Amz-Credential", valid_774191
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774192: Call_DeleteStream_774181; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a stream.
  ## 
  let valid = call_774192.validator(path, query, header, formData, body)
  let scheme = call_774192.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774192.url(scheme.get, call_774192.host, call_774192.base,
                         call_774192.route, valid.getOrDefault("path"))
  result = hook(call_774192, url, valid)

proc call*(call_774193: Call_DeleteStream_774181; streamId: string): Recallable =
  ## deleteStream
  ## Deletes a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_774194 = newJObject()
  add(path_774194, "streamId", newJString(streamId))
  result = call_774193.call(path_774194, nil, nil, nil, nil)

var deleteStream* = Call_DeleteStream_774181(name: "deleteStream",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_DeleteStream_774182,
    base: "/", url: url_DeleteStream_774183, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThing_774209 = ref object of OpenApiRestCall_772597
proc url_CreateThing_774211(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CreateThing_774210(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to create.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_774212 = path.getOrDefault("thingName")
  valid_774212 = validateParameter(valid_774212, JString, required = true,
                                 default = nil)
  if valid_774212 != nil:
    section.add "thingName", valid_774212
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774213 = header.getOrDefault("X-Amz-Date")
  valid_774213 = validateParameter(valid_774213, JString, required = false,
                                 default = nil)
  if valid_774213 != nil:
    section.add "X-Amz-Date", valid_774213
  var valid_774214 = header.getOrDefault("X-Amz-Security-Token")
  valid_774214 = validateParameter(valid_774214, JString, required = false,
                                 default = nil)
  if valid_774214 != nil:
    section.add "X-Amz-Security-Token", valid_774214
  var valid_774215 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774215 = validateParameter(valid_774215, JString, required = false,
                                 default = nil)
  if valid_774215 != nil:
    section.add "X-Amz-Content-Sha256", valid_774215
  var valid_774216 = header.getOrDefault("X-Amz-Algorithm")
  valid_774216 = validateParameter(valid_774216, JString, required = false,
                                 default = nil)
  if valid_774216 != nil:
    section.add "X-Amz-Algorithm", valid_774216
  var valid_774217 = header.getOrDefault("X-Amz-Signature")
  valid_774217 = validateParameter(valid_774217, JString, required = false,
                                 default = nil)
  if valid_774217 != nil:
    section.add "X-Amz-Signature", valid_774217
  var valid_774218 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774218 = validateParameter(valid_774218, JString, required = false,
                                 default = nil)
  if valid_774218 != nil:
    section.add "X-Amz-SignedHeaders", valid_774218
  var valid_774219 = header.getOrDefault("X-Amz-Credential")
  valid_774219 = validateParameter(valid_774219, JString, required = false,
                                 default = nil)
  if valid_774219 != nil:
    section.add "X-Amz-Credential", valid_774219
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774221: Call_CreateThing_774209; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  let valid = call_774221.validator(path, query, header, formData, body)
  let scheme = call_774221.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774221.url(scheme.get, call_774221.host, call_774221.base,
                         call_774221.route, valid.getOrDefault("path"))
  result = hook(call_774221, url, valid)

proc call*(call_774222: Call_CreateThing_774209; thingName: string; body: JsonNode): Recallable =
  ## createThing
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing to create.
  ##   body: JObject (required)
  var path_774223 = newJObject()
  var body_774224 = newJObject()
  add(path_774223, "thingName", newJString(thingName))
  if body != nil:
    body_774224 = body
  result = call_774222.call(path_774223, nil, nil, nil, body_774224)

var createThing* = Call_CreateThing_774209(name: "createThing",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_CreateThing_774210,
                                        base: "/", url: url_CreateThing_774211,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThing_774195 = ref object of OpenApiRestCall_772597
proc url_DescribeThing_774197(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeThing_774196(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the specified thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_774198 = path.getOrDefault("thingName")
  valid_774198 = validateParameter(valid_774198, JString, required = true,
                                 default = nil)
  if valid_774198 != nil:
    section.add "thingName", valid_774198
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774199 = header.getOrDefault("X-Amz-Date")
  valid_774199 = validateParameter(valid_774199, JString, required = false,
                                 default = nil)
  if valid_774199 != nil:
    section.add "X-Amz-Date", valid_774199
  var valid_774200 = header.getOrDefault("X-Amz-Security-Token")
  valid_774200 = validateParameter(valid_774200, JString, required = false,
                                 default = nil)
  if valid_774200 != nil:
    section.add "X-Amz-Security-Token", valid_774200
  var valid_774201 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774201 = validateParameter(valid_774201, JString, required = false,
                                 default = nil)
  if valid_774201 != nil:
    section.add "X-Amz-Content-Sha256", valid_774201
  var valid_774202 = header.getOrDefault("X-Amz-Algorithm")
  valid_774202 = validateParameter(valid_774202, JString, required = false,
                                 default = nil)
  if valid_774202 != nil:
    section.add "X-Amz-Algorithm", valid_774202
  var valid_774203 = header.getOrDefault("X-Amz-Signature")
  valid_774203 = validateParameter(valid_774203, JString, required = false,
                                 default = nil)
  if valid_774203 != nil:
    section.add "X-Amz-Signature", valid_774203
  var valid_774204 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774204 = validateParameter(valid_774204, JString, required = false,
                                 default = nil)
  if valid_774204 != nil:
    section.add "X-Amz-SignedHeaders", valid_774204
  var valid_774205 = header.getOrDefault("X-Amz-Credential")
  valid_774205 = validateParameter(valid_774205, JString, required = false,
                                 default = nil)
  if valid_774205 != nil:
    section.add "X-Amz-Credential", valid_774205
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774206: Call_DescribeThing_774195; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified thing.
  ## 
  let valid = call_774206.validator(path, query, header, formData, body)
  let scheme = call_774206.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774206.url(scheme.get, call_774206.host, call_774206.base,
                         call_774206.route, valid.getOrDefault("path"))
  result = hook(call_774206, url, valid)

proc call*(call_774207: Call_DescribeThing_774195; thingName: string): Recallable =
  ## describeThing
  ## Gets information about the specified thing.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_774208 = newJObject()
  add(path_774208, "thingName", newJString(thingName))
  result = call_774207.call(path_774208, nil, nil, nil, nil)

var describeThing* = Call_DescribeThing_774195(name: "describeThing",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/things/{thingName}", validator: validate_DescribeThing_774196,
    base: "/", url: url_DescribeThing_774197, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThing_774241 = ref object of OpenApiRestCall_772597
proc url_UpdateThing_774243(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_UpdateThing_774242(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the data for a thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_774244 = path.getOrDefault("thingName")
  valid_774244 = validateParameter(valid_774244, JString, required = true,
                                 default = nil)
  if valid_774244 != nil:
    section.add "thingName", valid_774244
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774245 = header.getOrDefault("X-Amz-Date")
  valid_774245 = validateParameter(valid_774245, JString, required = false,
                                 default = nil)
  if valid_774245 != nil:
    section.add "X-Amz-Date", valid_774245
  var valid_774246 = header.getOrDefault("X-Amz-Security-Token")
  valid_774246 = validateParameter(valid_774246, JString, required = false,
                                 default = nil)
  if valid_774246 != nil:
    section.add "X-Amz-Security-Token", valid_774246
  var valid_774247 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774247 = validateParameter(valid_774247, JString, required = false,
                                 default = nil)
  if valid_774247 != nil:
    section.add "X-Amz-Content-Sha256", valid_774247
  var valid_774248 = header.getOrDefault("X-Amz-Algorithm")
  valid_774248 = validateParameter(valid_774248, JString, required = false,
                                 default = nil)
  if valid_774248 != nil:
    section.add "X-Amz-Algorithm", valid_774248
  var valid_774249 = header.getOrDefault("X-Amz-Signature")
  valid_774249 = validateParameter(valid_774249, JString, required = false,
                                 default = nil)
  if valid_774249 != nil:
    section.add "X-Amz-Signature", valid_774249
  var valid_774250 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774250 = validateParameter(valid_774250, JString, required = false,
                                 default = nil)
  if valid_774250 != nil:
    section.add "X-Amz-SignedHeaders", valid_774250
  var valid_774251 = header.getOrDefault("X-Amz-Credential")
  valid_774251 = validateParameter(valid_774251, JString, required = false,
                                 default = nil)
  if valid_774251 != nil:
    section.add "X-Amz-Credential", valid_774251
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774253: Call_UpdateThing_774241; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the data for a thing.
  ## 
  let valid = call_774253.validator(path, query, header, formData, body)
  let scheme = call_774253.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774253.url(scheme.get, call_774253.host, call_774253.base,
                         call_774253.route, valid.getOrDefault("path"))
  result = hook(call_774253, url, valid)

proc call*(call_774254: Call_UpdateThing_774241; thingName: string; body: JsonNode): Recallable =
  ## updateThing
  ## Updates the data for a thing.
  ##   thingName: string (required)
  ##            : The name of the thing to update.
  ##   body: JObject (required)
  var path_774255 = newJObject()
  var body_774256 = newJObject()
  add(path_774255, "thingName", newJString(thingName))
  if body != nil:
    body_774256 = body
  result = call_774254.call(path_774255, nil, nil, nil, body_774256)

var updateThing* = Call_UpdateThing_774241(name: "updateThing",
                                        meth: HttpMethod.HttpPatch,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_UpdateThing_774242,
                                        base: "/", url: url_UpdateThing_774243,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThing_774225 = ref object of OpenApiRestCall_772597
proc url_DeleteThing_774227(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteThing_774226(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_774228 = path.getOrDefault("thingName")
  valid_774228 = validateParameter(valid_774228, JString, required = true,
                                 default = nil)
  if valid_774228 != nil:
    section.add "thingName", valid_774228
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.
  section = newJObject()
  var valid_774229 = query.getOrDefault("expectedVersion")
  valid_774229 = validateParameter(valid_774229, JInt, required = false, default = nil)
  if valid_774229 != nil:
    section.add "expectedVersion", valid_774229
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774230 = header.getOrDefault("X-Amz-Date")
  valid_774230 = validateParameter(valid_774230, JString, required = false,
                                 default = nil)
  if valid_774230 != nil:
    section.add "X-Amz-Date", valid_774230
  var valid_774231 = header.getOrDefault("X-Amz-Security-Token")
  valid_774231 = validateParameter(valid_774231, JString, required = false,
                                 default = nil)
  if valid_774231 != nil:
    section.add "X-Amz-Security-Token", valid_774231
  var valid_774232 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774232 = validateParameter(valid_774232, JString, required = false,
                                 default = nil)
  if valid_774232 != nil:
    section.add "X-Amz-Content-Sha256", valid_774232
  var valid_774233 = header.getOrDefault("X-Amz-Algorithm")
  valid_774233 = validateParameter(valid_774233, JString, required = false,
                                 default = nil)
  if valid_774233 != nil:
    section.add "X-Amz-Algorithm", valid_774233
  var valid_774234 = header.getOrDefault("X-Amz-Signature")
  valid_774234 = validateParameter(valid_774234, JString, required = false,
                                 default = nil)
  if valid_774234 != nil:
    section.add "X-Amz-Signature", valid_774234
  var valid_774235 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774235 = validateParameter(valid_774235, JString, required = false,
                                 default = nil)
  if valid_774235 != nil:
    section.add "X-Amz-SignedHeaders", valid_774235
  var valid_774236 = header.getOrDefault("X-Amz-Credential")
  valid_774236 = validateParameter(valid_774236, JString, required = false,
                                 default = nil)
  if valid_774236 != nil:
    section.add "X-Amz-Credential", valid_774236
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774237: Call_DeleteThing_774225; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ## 
  let valid = call_774237.validator(path, query, header, formData, body)
  let scheme = call_774237.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774237.url(scheme.get, call_774237.host, call_774237.base,
                         call_774237.route, valid.getOrDefault("path"))
  result = hook(call_774237, url, valid)

proc call*(call_774238: Call_DeleteThing_774225; thingName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteThing
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ##   expectedVersion: int
  ##                  : The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.
  ##   thingName: string (required)
  ##            : The name of the thing to delete.
  var path_774239 = newJObject()
  var query_774240 = newJObject()
  add(query_774240, "expectedVersion", newJInt(expectedVersion))
  add(path_774239, "thingName", newJString(thingName))
  result = call_774238.call(path_774239, query_774240, nil, nil, nil)

var deleteThing* = Call_DeleteThing_774225(name: "deleteThing",
                                        meth: HttpMethod.HttpDelete,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_DeleteThing_774226,
                                        base: "/", url: url_DeleteThing_774227,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThingGroup_774271 = ref object of OpenApiRestCall_772597
proc url_CreateThingGroup_774273(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CreateThingGroup_774272(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group name to create.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_774274 = path.getOrDefault("thingGroupName")
  valid_774274 = validateParameter(valid_774274, JString, required = true,
                                 default = nil)
  if valid_774274 != nil:
    section.add "thingGroupName", valid_774274
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774275 = header.getOrDefault("X-Amz-Date")
  valid_774275 = validateParameter(valid_774275, JString, required = false,
                                 default = nil)
  if valid_774275 != nil:
    section.add "X-Amz-Date", valid_774275
  var valid_774276 = header.getOrDefault("X-Amz-Security-Token")
  valid_774276 = validateParameter(valid_774276, JString, required = false,
                                 default = nil)
  if valid_774276 != nil:
    section.add "X-Amz-Security-Token", valid_774276
  var valid_774277 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774277 = validateParameter(valid_774277, JString, required = false,
                                 default = nil)
  if valid_774277 != nil:
    section.add "X-Amz-Content-Sha256", valid_774277
  var valid_774278 = header.getOrDefault("X-Amz-Algorithm")
  valid_774278 = validateParameter(valid_774278, JString, required = false,
                                 default = nil)
  if valid_774278 != nil:
    section.add "X-Amz-Algorithm", valid_774278
  var valid_774279 = header.getOrDefault("X-Amz-Signature")
  valid_774279 = validateParameter(valid_774279, JString, required = false,
                                 default = nil)
  if valid_774279 != nil:
    section.add "X-Amz-Signature", valid_774279
  var valid_774280 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774280 = validateParameter(valid_774280, JString, required = false,
                                 default = nil)
  if valid_774280 != nil:
    section.add "X-Amz-SignedHeaders", valid_774280
  var valid_774281 = header.getOrDefault("X-Amz-Credential")
  valid_774281 = validateParameter(valid_774281, JString, required = false,
                                 default = nil)
  if valid_774281 != nil:
    section.add "X-Amz-Credential", valid_774281
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774283: Call_CreateThingGroup_774271; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  let valid = call_774283.validator(path, query, header, formData, body)
  let scheme = call_774283.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774283.url(scheme.get, call_774283.host, call_774283.base,
                         call_774283.route, valid.getOrDefault("path"))
  result = hook(call_774283, url, valid)

proc call*(call_774284: Call_CreateThingGroup_774271; body: JsonNode;
          thingGroupName: string): Recallable =
  ## createThingGroup
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ##   body: JObject (required)
  ##   thingGroupName: string (required)
  ##                 : The thing group name to create.
  var path_774285 = newJObject()
  var body_774286 = newJObject()
  if body != nil:
    body_774286 = body
  add(path_774285, "thingGroupName", newJString(thingGroupName))
  result = call_774284.call(path_774285, nil, nil, nil, body_774286)

var createThingGroup* = Call_CreateThingGroup_774271(name: "createThingGroup",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_CreateThingGroup_774272,
    base: "/", url: url_CreateThingGroup_774273,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingGroup_774257 = ref object of OpenApiRestCall_772597
proc url_DescribeThingGroup_774259(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeThingGroup_774258(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Describe a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the thing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_774260 = path.getOrDefault("thingGroupName")
  valid_774260 = validateParameter(valid_774260, JString, required = true,
                                 default = nil)
  if valid_774260 != nil:
    section.add "thingGroupName", valid_774260
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774261 = header.getOrDefault("X-Amz-Date")
  valid_774261 = validateParameter(valid_774261, JString, required = false,
                                 default = nil)
  if valid_774261 != nil:
    section.add "X-Amz-Date", valid_774261
  var valid_774262 = header.getOrDefault("X-Amz-Security-Token")
  valid_774262 = validateParameter(valid_774262, JString, required = false,
                                 default = nil)
  if valid_774262 != nil:
    section.add "X-Amz-Security-Token", valid_774262
  var valid_774263 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774263 = validateParameter(valid_774263, JString, required = false,
                                 default = nil)
  if valid_774263 != nil:
    section.add "X-Amz-Content-Sha256", valid_774263
  var valid_774264 = header.getOrDefault("X-Amz-Algorithm")
  valid_774264 = validateParameter(valid_774264, JString, required = false,
                                 default = nil)
  if valid_774264 != nil:
    section.add "X-Amz-Algorithm", valid_774264
  var valid_774265 = header.getOrDefault("X-Amz-Signature")
  valid_774265 = validateParameter(valid_774265, JString, required = false,
                                 default = nil)
  if valid_774265 != nil:
    section.add "X-Amz-Signature", valid_774265
  var valid_774266 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774266 = validateParameter(valid_774266, JString, required = false,
                                 default = nil)
  if valid_774266 != nil:
    section.add "X-Amz-SignedHeaders", valid_774266
  var valid_774267 = header.getOrDefault("X-Amz-Credential")
  valid_774267 = validateParameter(valid_774267, JString, required = false,
                                 default = nil)
  if valid_774267 != nil:
    section.add "X-Amz-Credential", valid_774267
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774268: Call_DescribeThingGroup_774257; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describe a thing group.
  ## 
  let valid = call_774268.validator(path, query, header, formData, body)
  let scheme = call_774268.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774268.url(scheme.get, call_774268.host, call_774268.base,
                         call_774268.route, valid.getOrDefault("path"))
  result = hook(call_774268, url, valid)

proc call*(call_774269: Call_DescribeThingGroup_774257; thingGroupName: string): Recallable =
  ## describeThingGroup
  ## Describe a thing group.
  ##   thingGroupName: string (required)
  ##                 : The name of the thing group.
  var path_774270 = newJObject()
  add(path_774270, "thingGroupName", newJString(thingGroupName))
  result = call_774269.call(path_774270, nil, nil, nil, nil)

var describeThingGroup* = Call_DescribeThingGroup_774257(
    name: "describeThingGroup", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}",
    validator: validate_DescribeThingGroup_774258, base: "/",
    url: url_DescribeThingGroup_774259, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThingGroup_774303 = ref object of OpenApiRestCall_772597
proc url_UpdateThingGroup_774305(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_UpdateThingGroup_774304(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Update a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group to update.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_774306 = path.getOrDefault("thingGroupName")
  valid_774306 = validateParameter(valid_774306, JString, required = true,
                                 default = nil)
  if valid_774306 != nil:
    section.add "thingGroupName", valid_774306
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774307 = header.getOrDefault("X-Amz-Date")
  valid_774307 = validateParameter(valid_774307, JString, required = false,
                                 default = nil)
  if valid_774307 != nil:
    section.add "X-Amz-Date", valid_774307
  var valid_774308 = header.getOrDefault("X-Amz-Security-Token")
  valid_774308 = validateParameter(valid_774308, JString, required = false,
                                 default = nil)
  if valid_774308 != nil:
    section.add "X-Amz-Security-Token", valid_774308
  var valid_774309 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774309 = validateParameter(valid_774309, JString, required = false,
                                 default = nil)
  if valid_774309 != nil:
    section.add "X-Amz-Content-Sha256", valid_774309
  var valid_774310 = header.getOrDefault("X-Amz-Algorithm")
  valid_774310 = validateParameter(valid_774310, JString, required = false,
                                 default = nil)
  if valid_774310 != nil:
    section.add "X-Amz-Algorithm", valid_774310
  var valid_774311 = header.getOrDefault("X-Amz-Signature")
  valid_774311 = validateParameter(valid_774311, JString, required = false,
                                 default = nil)
  if valid_774311 != nil:
    section.add "X-Amz-Signature", valid_774311
  var valid_774312 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774312 = validateParameter(valid_774312, JString, required = false,
                                 default = nil)
  if valid_774312 != nil:
    section.add "X-Amz-SignedHeaders", valid_774312
  var valid_774313 = header.getOrDefault("X-Amz-Credential")
  valid_774313 = validateParameter(valid_774313, JString, required = false,
                                 default = nil)
  if valid_774313 != nil:
    section.add "X-Amz-Credential", valid_774313
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774315: Call_UpdateThingGroup_774303; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update a thing group.
  ## 
  let valid = call_774315.validator(path, query, header, formData, body)
  let scheme = call_774315.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774315.url(scheme.get, call_774315.host, call_774315.base,
                         call_774315.route, valid.getOrDefault("path"))
  result = hook(call_774315, url, valid)

proc call*(call_774316: Call_UpdateThingGroup_774303; body: JsonNode;
          thingGroupName: string): Recallable =
  ## updateThingGroup
  ## Update a thing group.
  ##   body: JObject (required)
  ##   thingGroupName: string (required)
  ##                 : The thing group to update.
  var path_774317 = newJObject()
  var body_774318 = newJObject()
  if body != nil:
    body_774318 = body
  add(path_774317, "thingGroupName", newJString(thingGroupName))
  result = call_774316.call(path_774317, nil, nil, nil, body_774318)

var updateThingGroup* = Call_UpdateThingGroup_774303(name: "updateThingGroup",
    meth: HttpMethod.HttpPatch, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_UpdateThingGroup_774304,
    base: "/", url: url_UpdateThingGroup_774305,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThingGroup_774287 = ref object of OpenApiRestCall_772597
proc url_DeleteThingGroup_774289(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteThingGroup_774288(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Deletes a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the thing group to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_774290 = path.getOrDefault("thingGroupName")
  valid_774290 = validateParameter(valid_774290, JString, required = true,
                                 default = nil)
  if valid_774290 != nil:
    section.add "thingGroupName", valid_774290
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the thing group to delete.
  section = newJObject()
  var valid_774291 = query.getOrDefault("expectedVersion")
  valid_774291 = validateParameter(valid_774291, JInt, required = false, default = nil)
  if valid_774291 != nil:
    section.add "expectedVersion", valid_774291
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774292 = header.getOrDefault("X-Amz-Date")
  valid_774292 = validateParameter(valid_774292, JString, required = false,
                                 default = nil)
  if valid_774292 != nil:
    section.add "X-Amz-Date", valid_774292
  var valid_774293 = header.getOrDefault("X-Amz-Security-Token")
  valid_774293 = validateParameter(valid_774293, JString, required = false,
                                 default = nil)
  if valid_774293 != nil:
    section.add "X-Amz-Security-Token", valid_774293
  var valid_774294 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774294 = validateParameter(valid_774294, JString, required = false,
                                 default = nil)
  if valid_774294 != nil:
    section.add "X-Amz-Content-Sha256", valid_774294
  var valid_774295 = header.getOrDefault("X-Amz-Algorithm")
  valid_774295 = validateParameter(valid_774295, JString, required = false,
                                 default = nil)
  if valid_774295 != nil:
    section.add "X-Amz-Algorithm", valid_774295
  var valid_774296 = header.getOrDefault("X-Amz-Signature")
  valid_774296 = validateParameter(valid_774296, JString, required = false,
                                 default = nil)
  if valid_774296 != nil:
    section.add "X-Amz-Signature", valid_774296
  var valid_774297 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774297 = validateParameter(valid_774297, JString, required = false,
                                 default = nil)
  if valid_774297 != nil:
    section.add "X-Amz-SignedHeaders", valid_774297
  var valid_774298 = header.getOrDefault("X-Amz-Credential")
  valid_774298 = validateParameter(valid_774298, JString, required = false,
                                 default = nil)
  if valid_774298 != nil:
    section.add "X-Amz-Credential", valid_774298
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774299: Call_DeleteThingGroup_774287; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a thing group.
  ## 
  let valid = call_774299.validator(path, query, header, formData, body)
  let scheme = call_774299.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774299.url(scheme.get, call_774299.host, call_774299.base,
                         call_774299.route, valid.getOrDefault("path"))
  result = hook(call_774299, url, valid)

proc call*(call_774300: Call_DeleteThingGroup_774287; thingGroupName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteThingGroup
  ## Deletes a thing group.
  ##   expectedVersion: int
  ##                  : The expected version of the thing group to delete.
  ##   thingGroupName: string (required)
  ##                 : The name of the thing group to delete.
  var path_774301 = newJObject()
  var query_774302 = newJObject()
  add(query_774302, "expectedVersion", newJInt(expectedVersion))
  add(path_774301, "thingGroupName", newJString(thingGroupName))
  result = call_774300.call(path_774301, query_774302, nil, nil, nil)

var deleteThingGroup* = Call_DeleteThingGroup_774287(name: "deleteThingGroup",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_DeleteThingGroup_774288,
    base: "/", url: url_DeleteThingGroup_774289,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThingType_774333 = ref object of OpenApiRestCall_772597
proc url_CreateThingType_774335(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CreateThingType_774334(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a new thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_774336 = path.getOrDefault("thingTypeName")
  valid_774336 = validateParameter(valid_774336, JString, required = true,
                                 default = nil)
  if valid_774336 != nil:
    section.add "thingTypeName", valid_774336
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774337 = header.getOrDefault("X-Amz-Date")
  valid_774337 = validateParameter(valid_774337, JString, required = false,
                                 default = nil)
  if valid_774337 != nil:
    section.add "X-Amz-Date", valid_774337
  var valid_774338 = header.getOrDefault("X-Amz-Security-Token")
  valid_774338 = validateParameter(valid_774338, JString, required = false,
                                 default = nil)
  if valid_774338 != nil:
    section.add "X-Amz-Security-Token", valid_774338
  var valid_774339 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774339 = validateParameter(valid_774339, JString, required = false,
                                 default = nil)
  if valid_774339 != nil:
    section.add "X-Amz-Content-Sha256", valid_774339
  var valid_774340 = header.getOrDefault("X-Amz-Algorithm")
  valid_774340 = validateParameter(valid_774340, JString, required = false,
                                 default = nil)
  if valid_774340 != nil:
    section.add "X-Amz-Algorithm", valid_774340
  var valid_774341 = header.getOrDefault("X-Amz-Signature")
  valid_774341 = validateParameter(valid_774341, JString, required = false,
                                 default = nil)
  if valid_774341 != nil:
    section.add "X-Amz-Signature", valid_774341
  var valid_774342 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774342 = validateParameter(valid_774342, JString, required = false,
                                 default = nil)
  if valid_774342 != nil:
    section.add "X-Amz-SignedHeaders", valid_774342
  var valid_774343 = header.getOrDefault("X-Amz-Credential")
  valid_774343 = validateParameter(valid_774343, JString, required = false,
                                 default = nil)
  if valid_774343 != nil:
    section.add "X-Amz-Credential", valid_774343
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774345: Call_CreateThingType_774333; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new thing type.
  ## 
  let valid = call_774345.validator(path, query, header, formData, body)
  let scheme = call_774345.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774345.url(scheme.get, call_774345.host, call_774345.base,
                         call_774345.route, valid.getOrDefault("path"))
  result = hook(call_774345, url, valid)

proc call*(call_774346: Call_CreateThingType_774333; body: JsonNode;
          thingTypeName: string): Recallable =
  ## createThingType
  ## Creates a new thing type.
  ##   body: JObject (required)
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_774347 = newJObject()
  var body_774348 = newJObject()
  if body != nil:
    body_774348 = body
  add(path_774347, "thingTypeName", newJString(thingTypeName))
  result = call_774346.call(path_774347, nil, nil, nil, body_774348)

var createThingType* = Call_CreateThingType_774333(name: "createThingType",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_CreateThingType_774334,
    base: "/", url: url_CreateThingType_774335, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingType_774319 = ref object of OpenApiRestCall_772597
proc url_DescribeThingType_774321(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeThingType_774320(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Gets information about the specified thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_774322 = path.getOrDefault("thingTypeName")
  valid_774322 = validateParameter(valid_774322, JString, required = true,
                                 default = nil)
  if valid_774322 != nil:
    section.add "thingTypeName", valid_774322
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774323 = header.getOrDefault("X-Amz-Date")
  valid_774323 = validateParameter(valid_774323, JString, required = false,
                                 default = nil)
  if valid_774323 != nil:
    section.add "X-Amz-Date", valid_774323
  var valid_774324 = header.getOrDefault("X-Amz-Security-Token")
  valid_774324 = validateParameter(valid_774324, JString, required = false,
                                 default = nil)
  if valid_774324 != nil:
    section.add "X-Amz-Security-Token", valid_774324
  var valid_774325 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774325 = validateParameter(valid_774325, JString, required = false,
                                 default = nil)
  if valid_774325 != nil:
    section.add "X-Amz-Content-Sha256", valid_774325
  var valid_774326 = header.getOrDefault("X-Amz-Algorithm")
  valid_774326 = validateParameter(valid_774326, JString, required = false,
                                 default = nil)
  if valid_774326 != nil:
    section.add "X-Amz-Algorithm", valid_774326
  var valid_774327 = header.getOrDefault("X-Amz-Signature")
  valid_774327 = validateParameter(valid_774327, JString, required = false,
                                 default = nil)
  if valid_774327 != nil:
    section.add "X-Amz-Signature", valid_774327
  var valid_774328 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774328 = validateParameter(valid_774328, JString, required = false,
                                 default = nil)
  if valid_774328 != nil:
    section.add "X-Amz-SignedHeaders", valid_774328
  var valid_774329 = header.getOrDefault("X-Amz-Credential")
  valid_774329 = validateParameter(valid_774329, JString, required = false,
                                 default = nil)
  if valid_774329 != nil:
    section.add "X-Amz-Credential", valid_774329
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774330: Call_DescribeThingType_774319; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified thing type.
  ## 
  let valid = call_774330.validator(path, query, header, formData, body)
  let scheme = call_774330.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774330.url(scheme.get, call_774330.host, call_774330.base,
                         call_774330.route, valid.getOrDefault("path"))
  result = hook(call_774330, url, valid)

proc call*(call_774331: Call_DescribeThingType_774319; thingTypeName: string): Recallable =
  ## describeThingType
  ## Gets information about the specified thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_774332 = newJObject()
  add(path_774332, "thingTypeName", newJString(thingTypeName))
  result = call_774331.call(path_774332, nil, nil, nil, nil)

var describeThingType* = Call_DescribeThingType_774319(name: "describeThingType",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_DescribeThingType_774320,
    base: "/", url: url_DescribeThingType_774321,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThingType_774349 = ref object of OpenApiRestCall_772597
proc url_DeleteThingType_774351(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteThingType_774350(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_774352 = path.getOrDefault("thingTypeName")
  valid_774352 = validateParameter(valid_774352, JString, required = true,
                                 default = nil)
  if valid_774352 != nil:
    section.add "thingTypeName", valid_774352
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774353 = header.getOrDefault("X-Amz-Date")
  valid_774353 = validateParameter(valid_774353, JString, required = false,
                                 default = nil)
  if valid_774353 != nil:
    section.add "X-Amz-Date", valid_774353
  var valid_774354 = header.getOrDefault("X-Amz-Security-Token")
  valid_774354 = validateParameter(valid_774354, JString, required = false,
                                 default = nil)
  if valid_774354 != nil:
    section.add "X-Amz-Security-Token", valid_774354
  var valid_774355 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774355 = validateParameter(valid_774355, JString, required = false,
                                 default = nil)
  if valid_774355 != nil:
    section.add "X-Amz-Content-Sha256", valid_774355
  var valid_774356 = header.getOrDefault("X-Amz-Algorithm")
  valid_774356 = validateParameter(valid_774356, JString, required = false,
                                 default = nil)
  if valid_774356 != nil:
    section.add "X-Amz-Algorithm", valid_774356
  var valid_774357 = header.getOrDefault("X-Amz-Signature")
  valid_774357 = validateParameter(valid_774357, JString, required = false,
                                 default = nil)
  if valid_774357 != nil:
    section.add "X-Amz-Signature", valid_774357
  var valid_774358 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774358 = validateParameter(valid_774358, JString, required = false,
                                 default = nil)
  if valid_774358 != nil:
    section.add "X-Amz-SignedHeaders", valid_774358
  var valid_774359 = header.getOrDefault("X-Amz-Credential")
  valid_774359 = validateParameter(valid_774359, JString, required = false,
                                 default = nil)
  if valid_774359 != nil:
    section.add "X-Amz-Credential", valid_774359
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774360: Call_DeleteThingType_774349; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ## 
  let valid = call_774360.validator(path, query, header, formData, body)
  let scheme = call_774360.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774360.url(scheme.get, call_774360.host, call_774360.base,
                         call_774360.route, valid.getOrDefault("path"))
  result = hook(call_774360, url, valid)

proc call*(call_774361: Call_DeleteThingType_774349; thingTypeName: string): Recallable =
  ## deleteThingType
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_774362 = newJObject()
  add(path_774362, "thingTypeName", newJString(thingTypeName))
  result = call_774361.call(path_774362, nil, nil, nil, nil)

var deleteThingType* = Call_DeleteThingType_774349(name: "deleteThingType",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_DeleteThingType_774350,
    base: "/", url: url_DeleteThingType_774351, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateTopicRule_774377 = ref object of OpenApiRestCall_772597
proc url_CreateTopicRule_774379(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_CreateTopicRule_774378(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_774380 = path.getOrDefault("ruleName")
  valid_774380 = validateParameter(valid_774380, JString, required = true,
                                 default = nil)
  if valid_774380 != nil:
    section.add "ruleName", valid_774380
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   x-amz-tagging: JString
  ##                : <p>Metadata which can be used to manage the topic rule.</p> <note> <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p> <p>For the CLI command-line parameter use format: --tags "key1=value1&amp;key2=value2..."</p> <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p> </note>
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774381 = header.getOrDefault("X-Amz-Date")
  valid_774381 = validateParameter(valid_774381, JString, required = false,
                                 default = nil)
  if valid_774381 != nil:
    section.add "X-Amz-Date", valid_774381
  var valid_774382 = header.getOrDefault("X-Amz-Security-Token")
  valid_774382 = validateParameter(valid_774382, JString, required = false,
                                 default = nil)
  if valid_774382 != nil:
    section.add "X-Amz-Security-Token", valid_774382
  var valid_774383 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774383 = validateParameter(valid_774383, JString, required = false,
                                 default = nil)
  if valid_774383 != nil:
    section.add "X-Amz-Content-Sha256", valid_774383
  var valid_774384 = header.getOrDefault("X-Amz-Algorithm")
  valid_774384 = validateParameter(valid_774384, JString, required = false,
                                 default = nil)
  if valid_774384 != nil:
    section.add "X-Amz-Algorithm", valid_774384
  var valid_774385 = header.getOrDefault("X-Amz-Signature")
  valid_774385 = validateParameter(valid_774385, JString, required = false,
                                 default = nil)
  if valid_774385 != nil:
    section.add "X-Amz-Signature", valid_774385
  var valid_774386 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774386 = validateParameter(valid_774386, JString, required = false,
                                 default = nil)
  if valid_774386 != nil:
    section.add "X-Amz-SignedHeaders", valid_774386
  var valid_774387 = header.getOrDefault("x-amz-tagging")
  valid_774387 = validateParameter(valid_774387, JString, required = false,
                                 default = nil)
  if valid_774387 != nil:
    section.add "x-amz-tagging", valid_774387
  var valid_774388 = header.getOrDefault("X-Amz-Credential")
  valid_774388 = validateParameter(valid_774388, JString, required = false,
                                 default = nil)
  if valid_774388 != nil:
    section.add "X-Amz-Credential", valid_774388
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774390: Call_CreateTopicRule_774377; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  let valid = call_774390.validator(path, query, header, formData, body)
  let scheme = call_774390.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774390.url(scheme.get, call_774390.host, call_774390.base,
                         call_774390.route, valid.getOrDefault("path"))
  result = hook(call_774390, url, valid)

proc call*(call_774391: Call_CreateTopicRule_774377; ruleName: string; body: JsonNode): Recallable =
  ## createTopicRule
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  ##   body: JObject (required)
  var path_774392 = newJObject()
  var body_774393 = newJObject()
  add(path_774392, "ruleName", newJString(ruleName))
  if body != nil:
    body_774393 = body
  result = call_774391.call(path_774392, nil, nil, nil, body_774393)

var createTopicRule* = Call_CreateTopicRule_774377(name: "createTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_CreateTopicRule_774378,
    base: "/", url: url_CreateTopicRule_774379, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetTopicRule_774363 = ref object of OpenApiRestCall_772597
proc url_GetTopicRule_774365(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_GetTopicRule_774364(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_774366 = path.getOrDefault("ruleName")
  valid_774366 = validateParameter(valid_774366, JString, required = true,
                                 default = nil)
  if valid_774366 != nil:
    section.add "ruleName", valid_774366
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774367 = header.getOrDefault("X-Amz-Date")
  valid_774367 = validateParameter(valid_774367, JString, required = false,
                                 default = nil)
  if valid_774367 != nil:
    section.add "X-Amz-Date", valid_774367
  var valid_774368 = header.getOrDefault("X-Amz-Security-Token")
  valid_774368 = validateParameter(valid_774368, JString, required = false,
                                 default = nil)
  if valid_774368 != nil:
    section.add "X-Amz-Security-Token", valid_774368
  var valid_774369 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774369 = validateParameter(valid_774369, JString, required = false,
                                 default = nil)
  if valid_774369 != nil:
    section.add "X-Amz-Content-Sha256", valid_774369
  var valid_774370 = header.getOrDefault("X-Amz-Algorithm")
  valid_774370 = validateParameter(valid_774370, JString, required = false,
                                 default = nil)
  if valid_774370 != nil:
    section.add "X-Amz-Algorithm", valid_774370
  var valid_774371 = header.getOrDefault("X-Amz-Signature")
  valid_774371 = validateParameter(valid_774371, JString, required = false,
                                 default = nil)
  if valid_774371 != nil:
    section.add "X-Amz-Signature", valid_774371
  var valid_774372 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774372 = validateParameter(valid_774372, JString, required = false,
                                 default = nil)
  if valid_774372 != nil:
    section.add "X-Amz-SignedHeaders", valid_774372
  var valid_774373 = header.getOrDefault("X-Amz-Credential")
  valid_774373 = validateParameter(valid_774373, JString, required = false,
                                 default = nil)
  if valid_774373 != nil:
    section.add "X-Amz-Credential", valid_774373
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774374: Call_GetTopicRule_774363; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the rule.
  ## 
  let valid = call_774374.validator(path, query, header, formData, body)
  let scheme = call_774374.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774374.url(scheme.get, call_774374.host, call_774374.base,
                         call_774374.route, valid.getOrDefault("path"))
  result = hook(call_774374, url, valid)

proc call*(call_774375: Call_GetTopicRule_774363; ruleName: string): Recallable =
  ## getTopicRule
  ## Gets information about the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  var path_774376 = newJObject()
  add(path_774376, "ruleName", newJString(ruleName))
  result = call_774375.call(path_774376, nil, nil, nil, nil)

var getTopicRule* = Call_GetTopicRule_774363(name: "getTopicRule",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/rules/{ruleName}",
    validator: validate_GetTopicRule_774364, base: "/", url: url_GetTopicRule_774365,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReplaceTopicRule_774408 = ref object of OpenApiRestCall_772597
proc url_ReplaceTopicRule_774410(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_ReplaceTopicRule_774409(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_774411 = path.getOrDefault("ruleName")
  valid_774411 = validateParameter(valid_774411, JString, required = true,
                                 default = nil)
  if valid_774411 != nil:
    section.add "ruleName", valid_774411
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774412 = header.getOrDefault("X-Amz-Date")
  valid_774412 = validateParameter(valid_774412, JString, required = false,
                                 default = nil)
  if valid_774412 != nil:
    section.add "X-Amz-Date", valid_774412
  var valid_774413 = header.getOrDefault("X-Amz-Security-Token")
  valid_774413 = validateParameter(valid_774413, JString, required = false,
                                 default = nil)
  if valid_774413 != nil:
    section.add "X-Amz-Security-Token", valid_774413
  var valid_774414 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774414 = validateParameter(valid_774414, JString, required = false,
                                 default = nil)
  if valid_774414 != nil:
    section.add "X-Amz-Content-Sha256", valid_774414
  var valid_774415 = header.getOrDefault("X-Amz-Algorithm")
  valid_774415 = validateParameter(valid_774415, JString, required = false,
                                 default = nil)
  if valid_774415 != nil:
    section.add "X-Amz-Algorithm", valid_774415
  var valid_774416 = header.getOrDefault("X-Amz-Signature")
  valid_774416 = validateParameter(valid_774416, JString, required = false,
                                 default = nil)
  if valid_774416 != nil:
    section.add "X-Amz-Signature", valid_774416
  var valid_774417 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774417 = validateParameter(valid_774417, JString, required = false,
                                 default = nil)
  if valid_774417 != nil:
    section.add "X-Amz-SignedHeaders", valid_774417
  var valid_774418 = header.getOrDefault("X-Amz-Credential")
  valid_774418 = validateParameter(valid_774418, JString, required = false,
                                 default = nil)
  if valid_774418 != nil:
    section.add "X-Amz-Credential", valid_774418
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774420: Call_ReplaceTopicRule_774408; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  let valid = call_774420.validator(path, query, header, formData, body)
  let scheme = call_774420.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774420.url(scheme.get, call_774420.host, call_774420.base,
                         call_774420.route, valid.getOrDefault("path"))
  result = hook(call_774420, url, valid)

proc call*(call_774421: Call_ReplaceTopicRule_774408; ruleName: string;
          body: JsonNode): Recallable =
  ## replaceTopicRule
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  ##   body: JObject (required)
  var path_774422 = newJObject()
  var body_774423 = newJObject()
  add(path_774422, "ruleName", newJString(ruleName))
  if body != nil:
    body_774423 = body
  result = call_774421.call(path_774422, nil, nil, nil, body_774423)

var replaceTopicRule* = Call_ReplaceTopicRule_774408(name: "replaceTopicRule",
    meth: HttpMethod.HttpPatch, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_ReplaceTopicRule_774409,
    base: "/", url: url_ReplaceTopicRule_774410,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteTopicRule_774394 = ref object of OpenApiRestCall_772597
proc url_DeleteTopicRule_774396(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteTopicRule_774395(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_774397 = path.getOrDefault("ruleName")
  valid_774397 = validateParameter(valid_774397, JString, required = true,
                                 default = nil)
  if valid_774397 != nil:
    section.add "ruleName", valid_774397
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774398 = header.getOrDefault("X-Amz-Date")
  valid_774398 = validateParameter(valid_774398, JString, required = false,
                                 default = nil)
  if valid_774398 != nil:
    section.add "X-Amz-Date", valid_774398
  var valid_774399 = header.getOrDefault("X-Amz-Security-Token")
  valid_774399 = validateParameter(valid_774399, JString, required = false,
                                 default = nil)
  if valid_774399 != nil:
    section.add "X-Amz-Security-Token", valid_774399
  var valid_774400 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774400 = validateParameter(valid_774400, JString, required = false,
                                 default = nil)
  if valid_774400 != nil:
    section.add "X-Amz-Content-Sha256", valid_774400
  var valid_774401 = header.getOrDefault("X-Amz-Algorithm")
  valid_774401 = validateParameter(valid_774401, JString, required = false,
                                 default = nil)
  if valid_774401 != nil:
    section.add "X-Amz-Algorithm", valid_774401
  var valid_774402 = header.getOrDefault("X-Amz-Signature")
  valid_774402 = validateParameter(valid_774402, JString, required = false,
                                 default = nil)
  if valid_774402 != nil:
    section.add "X-Amz-Signature", valid_774402
  var valid_774403 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774403 = validateParameter(valid_774403, JString, required = false,
                                 default = nil)
  if valid_774403 != nil:
    section.add "X-Amz-SignedHeaders", valid_774403
  var valid_774404 = header.getOrDefault("X-Amz-Credential")
  valid_774404 = validateParameter(valid_774404, JString, required = false,
                                 default = nil)
  if valid_774404 != nil:
    section.add "X-Amz-Credential", valid_774404
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774405: Call_DeleteTopicRule_774394; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the rule.
  ## 
  let valid = call_774405.validator(path, query, header, formData, body)
  let scheme = call_774405.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774405.url(scheme.get, call_774405.host, call_774405.base,
                         call_774405.route, valid.getOrDefault("path"))
  result = hook(call_774405, url, valid)

proc call*(call_774406: Call_DeleteTopicRule_774394; ruleName: string): Recallable =
  ## deleteTopicRule
  ## Deletes the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  var path_774407 = newJObject()
  add(path_774407, "ruleName", newJString(ruleName))
  result = call_774406.call(path_774407, nil, nil, nil, nil)

var deleteTopicRule* = Call_DeleteTopicRule_774394(name: "deleteTopicRule",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_DeleteTopicRule_774395,
    base: "/", url: url_DeleteTopicRule_774396, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAccountAuditConfiguration_774424 = ref object of OpenApiRestCall_772597
proc url_DescribeAccountAuditConfiguration_774426(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_DescribeAccountAuditConfiguration_774425(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774427 = header.getOrDefault("X-Amz-Date")
  valid_774427 = validateParameter(valid_774427, JString, required = false,
                                 default = nil)
  if valid_774427 != nil:
    section.add "X-Amz-Date", valid_774427
  var valid_774428 = header.getOrDefault("X-Amz-Security-Token")
  valid_774428 = validateParameter(valid_774428, JString, required = false,
                                 default = nil)
  if valid_774428 != nil:
    section.add "X-Amz-Security-Token", valid_774428
  var valid_774429 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774429 = validateParameter(valid_774429, JString, required = false,
                                 default = nil)
  if valid_774429 != nil:
    section.add "X-Amz-Content-Sha256", valid_774429
  var valid_774430 = header.getOrDefault("X-Amz-Algorithm")
  valid_774430 = validateParameter(valid_774430, JString, required = false,
                                 default = nil)
  if valid_774430 != nil:
    section.add "X-Amz-Algorithm", valid_774430
  var valid_774431 = header.getOrDefault("X-Amz-Signature")
  valid_774431 = validateParameter(valid_774431, JString, required = false,
                                 default = nil)
  if valid_774431 != nil:
    section.add "X-Amz-Signature", valid_774431
  var valid_774432 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774432 = validateParameter(valid_774432, JString, required = false,
                                 default = nil)
  if valid_774432 != nil:
    section.add "X-Amz-SignedHeaders", valid_774432
  var valid_774433 = header.getOrDefault("X-Amz-Credential")
  valid_774433 = validateParameter(valid_774433, JString, required = false,
                                 default = nil)
  if valid_774433 != nil:
    section.add "X-Amz-Credential", valid_774433
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774434: Call_DescribeAccountAuditConfiguration_774424;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  let valid = call_774434.validator(path, query, header, formData, body)
  let scheme = call_774434.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774434.url(scheme.get, call_774434.host, call_774434.base,
                         call_774434.route, valid.getOrDefault("path"))
  result = hook(call_774434, url, valid)

proc call*(call_774435: Call_DescribeAccountAuditConfiguration_774424): Recallable =
  ## describeAccountAuditConfiguration
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  result = call_774435.call(nil, nil, nil, nil, nil)

var describeAccountAuditConfiguration* = Call_DescribeAccountAuditConfiguration_774424(
    name: "describeAccountAuditConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_DescribeAccountAuditConfiguration_774425, base: "/",
    url: url_DescribeAccountAuditConfiguration_774426,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateAccountAuditConfiguration_774450 = ref object of OpenApiRestCall_772597
proc url_UpdateAccountAuditConfiguration_774452(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_UpdateAccountAuditConfiguration_774451(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774453 = header.getOrDefault("X-Amz-Date")
  valid_774453 = validateParameter(valid_774453, JString, required = false,
                                 default = nil)
  if valid_774453 != nil:
    section.add "X-Amz-Date", valid_774453
  var valid_774454 = header.getOrDefault("X-Amz-Security-Token")
  valid_774454 = validateParameter(valid_774454, JString, required = false,
                                 default = nil)
  if valid_774454 != nil:
    section.add "X-Amz-Security-Token", valid_774454
  var valid_774455 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774455 = validateParameter(valid_774455, JString, required = false,
                                 default = nil)
  if valid_774455 != nil:
    section.add "X-Amz-Content-Sha256", valid_774455
  var valid_774456 = header.getOrDefault("X-Amz-Algorithm")
  valid_774456 = validateParameter(valid_774456, JString, required = false,
                                 default = nil)
  if valid_774456 != nil:
    section.add "X-Amz-Algorithm", valid_774456
  var valid_774457 = header.getOrDefault("X-Amz-Signature")
  valid_774457 = validateParameter(valid_774457, JString, required = false,
                                 default = nil)
  if valid_774457 != nil:
    section.add "X-Amz-Signature", valid_774457
  var valid_774458 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774458 = validateParameter(valid_774458, JString, required = false,
                                 default = nil)
  if valid_774458 != nil:
    section.add "X-Amz-SignedHeaders", valid_774458
  var valid_774459 = header.getOrDefault("X-Amz-Credential")
  valid_774459 = validateParameter(valid_774459, JString, required = false,
                                 default = nil)
  if valid_774459 != nil:
    section.add "X-Amz-Credential", valid_774459
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774461: Call_UpdateAccountAuditConfiguration_774450;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  let valid = call_774461.validator(path, query, header, formData, body)
  let scheme = call_774461.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774461.url(scheme.get, call_774461.host, call_774461.base,
                         call_774461.route, valid.getOrDefault("path"))
  result = hook(call_774461, url, valid)

proc call*(call_774462: Call_UpdateAccountAuditConfiguration_774450; body: JsonNode): Recallable =
  ## updateAccountAuditConfiguration
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ##   body: JObject (required)
  var body_774463 = newJObject()
  if body != nil:
    body_774463 = body
  result = call_774462.call(nil, nil, nil, nil, body_774463)

var updateAccountAuditConfiguration* = Call_UpdateAccountAuditConfiguration_774450(
    name: "updateAccountAuditConfiguration", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_UpdateAccountAuditConfiguration_774451, base: "/",
    url: url_UpdateAccountAuditConfiguration_774452,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteAccountAuditConfiguration_774436 = ref object of OpenApiRestCall_772597
proc url_DeleteAccountAuditConfiguration_774438(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_DeleteAccountAuditConfiguration_774437(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   deleteScheduledAudits: JBool
  ##                        : If true, all scheduled audits are deleted.
  section = newJObject()
  var valid_774439 = query.getOrDefault("deleteScheduledAudits")
  valid_774439 = validateParameter(valid_774439, JBool, required = false, default = nil)
  if valid_774439 != nil:
    section.add "deleteScheduledAudits", valid_774439
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774440 = header.getOrDefault("X-Amz-Date")
  valid_774440 = validateParameter(valid_774440, JString, required = false,
                                 default = nil)
  if valid_774440 != nil:
    section.add "X-Amz-Date", valid_774440
  var valid_774441 = header.getOrDefault("X-Amz-Security-Token")
  valid_774441 = validateParameter(valid_774441, JString, required = false,
                                 default = nil)
  if valid_774441 != nil:
    section.add "X-Amz-Security-Token", valid_774441
  var valid_774442 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774442 = validateParameter(valid_774442, JString, required = false,
                                 default = nil)
  if valid_774442 != nil:
    section.add "X-Amz-Content-Sha256", valid_774442
  var valid_774443 = header.getOrDefault("X-Amz-Algorithm")
  valid_774443 = validateParameter(valid_774443, JString, required = false,
                                 default = nil)
  if valid_774443 != nil:
    section.add "X-Amz-Algorithm", valid_774443
  var valid_774444 = header.getOrDefault("X-Amz-Signature")
  valid_774444 = validateParameter(valid_774444, JString, required = false,
                                 default = nil)
  if valid_774444 != nil:
    section.add "X-Amz-Signature", valid_774444
  var valid_774445 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774445 = validateParameter(valid_774445, JString, required = false,
                                 default = nil)
  if valid_774445 != nil:
    section.add "X-Amz-SignedHeaders", valid_774445
  var valid_774446 = header.getOrDefault("X-Amz-Credential")
  valid_774446 = validateParameter(valid_774446, JString, required = false,
                                 default = nil)
  if valid_774446 != nil:
    section.add "X-Amz-Credential", valid_774446
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774447: Call_DeleteAccountAuditConfiguration_774436;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ## 
  let valid = call_774447.validator(path, query, header, formData, body)
  let scheme = call_774447.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774447.url(scheme.get, call_774447.host, call_774447.base,
                         call_774447.route, valid.getOrDefault("path"))
  result = hook(call_774447, url, valid)

proc call*(call_774448: Call_DeleteAccountAuditConfiguration_774436;
          deleteScheduledAudits: bool = false): Recallable =
  ## deleteAccountAuditConfiguration
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ##   deleteScheduledAudits: bool
  ##                        : If true, all scheduled audits are deleted.
  var query_774449 = newJObject()
  add(query_774449, "deleteScheduledAudits", newJBool(deleteScheduledAudits))
  result = call_774448.call(nil, query_774449, nil, nil, nil)

var deleteAccountAuditConfiguration* = Call_DeleteAccountAuditConfiguration_774436(
    name: "deleteAccountAuditConfiguration", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_DeleteAccountAuditConfiguration_774437, base: "/",
    url: url_DeleteAccountAuditConfiguration_774438,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateCACertificate_774478 = ref object of OpenApiRestCall_772597
proc url_UpdateCACertificate_774480(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_UpdateCACertificate_774479(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Updates a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The CA certificate identifier.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_774481 = path.getOrDefault("caCertificateId")
  valid_774481 = validateParameter(valid_774481, JString, required = true,
                                 default = nil)
  if valid_774481 != nil:
    section.add "caCertificateId", valid_774481
  result.add "path", section
  ## parameters in `query` object:
  ##   newStatus: JString
  ##            : <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  ##   newAutoRegistrationStatus: JString
  ##                            : The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
  section = newJObject()
  var valid_774495 = query.getOrDefault("newStatus")
  valid_774495 = validateParameter(valid_774495, JString, required = false,
                                 default = newJString("ACTIVE"))
  if valid_774495 != nil:
    section.add "newStatus", valid_774495
  var valid_774496 = query.getOrDefault("newAutoRegistrationStatus")
  valid_774496 = validateParameter(valid_774496, JString, required = false,
                                 default = newJString("ENABLE"))
  if valid_774496 != nil:
    section.add "newAutoRegistrationStatus", valid_774496
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774497 = header.getOrDefault("X-Amz-Date")
  valid_774497 = validateParameter(valid_774497, JString, required = false,
                                 default = nil)
  if valid_774497 != nil:
    section.add "X-Amz-Date", valid_774497
  var valid_774498 = header.getOrDefault("X-Amz-Security-Token")
  valid_774498 = validateParameter(valid_774498, JString, required = false,
                                 default = nil)
  if valid_774498 != nil:
    section.add "X-Amz-Security-Token", valid_774498
  var valid_774499 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774499 = validateParameter(valid_774499, JString, required = false,
                                 default = nil)
  if valid_774499 != nil:
    section.add "X-Amz-Content-Sha256", valid_774499
  var valid_774500 = header.getOrDefault("X-Amz-Algorithm")
  valid_774500 = validateParameter(valid_774500, JString, required = false,
                                 default = nil)
  if valid_774500 != nil:
    section.add "X-Amz-Algorithm", valid_774500
  var valid_774501 = header.getOrDefault("X-Amz-Signature")
  valid_774501 = validateParameter(valid_774501, JString, required = false,
                                 default = nil)
  if valid_774501 != nil:
    section.add "X-Amz-Signature", valid_774501
  var valid_774502 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774502 = validateParameter(valid_774502, JString, required = false,
                                 default = nil)
  if valid_774502 != nil:
    section.add "X-Amz-SignedHeaders", valid_774502
  var valid_774503 = header.getOrDefault("X-Amz-Credential")
  valid_774503 = validateParameter(valid_774503, JString, required = false,
                                 default = nil)
  if valid_774503 != nil:
    section.add "X-Amz-Credential", valid_774503
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774505: Call_UpdateCACertificate_774478; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a registered CA certificate.
  ## 
  let valid = call_774505.validator(path, query, header, formData, body)
  let scheme = call_774505.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774505.url(scheme.get, call_774505.host, call_774505.base,
                         call_774505.route, valid.getOrDefault("path"))
  result = hook(call_774505, url, valid)

proc call*(call_774506: Call_UpdateCACertificate_774478; caCertificateId: string;
          body: JsonNode; newStatus: string = "ACTIVE";
          newAutoRegistrationStatus: string = "ENABLE"): Recallable =
  ## updateCACertificate
  ## Updates a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The CA certificate identifier.
  ##   body: JObject (required)
  ##   newStatus: string
  ##            : <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  ##   newAutoRegistrationStatus: string
  ##                            : The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
  var path_774507 = newJObject()
  var query_774508 = newJObject()
  var body_774509 = newJObject()
  add(path_774507, "caCertificateId", newJString(caCertificateId))
  if body != nil:
    body_774509 = body
  add(query_774508, "newStatus", newJString(newStatus))
  add(query_774508, "newAutoRegistrationStatus",
      newJString(newAutoRegistrationStatus))
  result = call_774506.call(path_774507, query_774508, nil, nil, body_774509)

var updateCACertificate* = Call_UpdateCACertificate_774478(
    name: "updateCACertificate", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_UpdateCACertificate_774479, base: "/",
    url: url_UpdateCACertificate_774480, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeCACertificate_774464 = ref object of OpenApiRestCall_772597
proc url_DescribeCACertificate_774466(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeCACertificate_774465(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The CA certificate identifier.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_774467 = path.getOrDefault("caCertificateId")
  valid_774467 = validateParameter(valid_774467, JString, required = true,
                                 default = nil)
  if valid_774467 != nil:
    section.add "caCertificateId", valid_774467
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774468 = header.getOrDefault("X-Amz-Date")
  valid_774468 = validateParameter(valid_774468, JString, required = false,
                                 default = nil)
  if valid_774468 != nil:
    section.add "X-Amz-Date", valid_774468
  var valid_774469 = header.getOrDefault("X-Amz-Security-Token")
  valid_774469 = validateParameter(valid_774469, JString, required = false,
                                 default = nil)
  if valid_774469 != nil:
    section.add "X-Amz-Security-Token", valid_774469
  var valid_774470 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774470 = validateParameter(valid_774470, JString, required = false,
                                 default = nil)
  if valid_774470 != nil:
    section.add "X-Amz-Content-Sha256", valid_774470
  var valid_774471 = header.getOrDefault("X-Amz-Algorithm")
  valid_774471 = validateParameter(valid_774471, JString, required = false,
                                 default = nil)
  if valid_774471 != nil:
    section.add "X-Amz-Algorithm", valid_774471
  var valid_774472 = header.getOrDefault("X-Amz-Signature")
  valid_774472 = validateParameter(valid_774472, JString, required = false,
                                 default = nil)
  if valid_774472 != nil:
    section.add "X-Amz-Signature", valid_774472
  var valid_774473 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774473 = validateParameter(valid_774473, JString, required = false,
                                 default = nil)
  if valid_774473 != nil:
    section.add "X-Amz-SignedHeaders", valid_774473
  var valid_774474 = header.getOrDefault("X-Amz-Credential")
  valid_774474 = validateParameter(valid_774474, JString, required = false,
                                 default = nil)
  if valid_774474 != nil:
    section.add "X-Amz-Credential", valid_774474
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774475: Call_DescribeCACertificate_774464; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a registered CA certificate.
  ## 
  let valid = call_774475.validator(path, query, header, formData, body)
  let scheme = call_774475.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774475.url(scheme.get, call_774475.host, call_774475.base,
                         call_774475.route, valid.getOrDefault("path"))
  result = hook(call_774475, url, valid)

proc call*(call_774476: Call_DescribeCACertificate_774464; caCertificateId: string): Recallable =
  ## describeCACertificate
  ## Describes a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The CA certificate identifier.
  var path_774477 = newJObject()
  add(path_774477, "caCertificateId", newJString(caCertificateId))
  result = call_774476.call(path_774477, nil, nil, nil, nil)

var describeCACertificate* = Call_DescribeCACertificate_774464(
    name: "describeCACertificate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_DescribeCACertificate_774465, base: "/",
    url: url_DescribeCACertificate_774466, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteCACertificate_774510 = ref object of OpenApiRestCall_772597
proc url_DeleteCACertificate_774512(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteCACertificate_774511(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Deletes a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_774513 = path.getOrDefault("caCertificateId")
  valid_774513 = validateParameter(valid_774513, JString, required = true,
                                 default = nil)
  if valid_774513 != nil:
    section.add "caCertificateId", valid_774513
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774514 = header.getOrDefault("X-Amz-Date")
  valid_774514 = validateParameter(valid_774514, JString, required = false,
                                 default = nil)
  if valid_774514 != nil:
    section.add "X-Amz-Date", valid_774514
  var valid_774515 = header.getOrDefault("X-Amz-Security-Token")
  valid_774515 = validateParameter(valid_774515, JString, required = false,
                                 default = nil)
  if valid_774515 != nil:
    section.add "X-Amz-Security-Token", valid_774515
  var valid_774516 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774516 = validateParameter(valid_774516, JString, required = false,
                                 default = nil)
  if valid_774516 != nil:
    section.add "X-Amz-Content-Sha256", valid_774516
  var valid_774517 = header.getOrDefault("X-Amz-Algorithm")
  valid_774517 = validateParameter(valid_774517, JString, required = false,
                                 default = nil)
  if valid_774517 != nil:
    section.add "X-Amz-Algorithm", valid_774517
  var valid_774518 = header.getOrDefault("X-Amz-Signature")
  valid_774518 = validateParameter(valid_774518, JString, required = false,
                                 default = nil)
  if valid_774518 != nil:
    section.add "X-Amz-Signature", valid_774518
  var valid_774519 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774519 = validateParameter(valid_774519, JString, required = false,
                                 default = nil)
  if valid_774519 != nil:
    section.add "X-Amz-SignedHeaders", valid_774519
  var valid_774520 = header.getOrDefault("X-Amz-Credential")
  valid_774520 = validateParameter(valid_774520, JString, required = false,
                                 default = nil)
  if valid_774520 != nil:
    section.add "X-Amz-Credential", valid_774520
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774521: Call_DeleteCACertificate_774510; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a registered CA certificate.
  ## 
  let valid = call_774521.validator(path, query, header, formData, body)
  let scheme = call_774521.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774521.url(scheme.get, call_774521.host, call_774521.base,
                         call_774521.route, valid.getOrDefault("path"))
  result = hook(call_774521, url, valid)

proc call*(call_774522: Call_DeleteCACertificate_774510; caCertificateId: string): Recallable =
  ## deleteCACertificate
  ## Deletes a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
  var path_774523 = newJObject()
  add(path_774523, "caCertificateId", newJString(caCertificateId))
  result = call_774522.call(path_774523, nil, nil, nil, nil)

var deleteCACertificate* = Call_DeleteCACertificate_774510(
    name: "deleteCACertificate", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_DeleteCACertificate_774511, base: "/",
    url: url_DeleteCACertificate_774512, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeCertificate_774524 = ref object of OpenApiRestCall_772597
proc url_DescribeCertificate_774526(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeCertificate_774525(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets information about the specified certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_774527 = path.getOrDefault("certificateId")
  valid_774527 = validateParameter(valid_774527, JString, required = true,
                                 default = nil)
  if valid_774527 != nil:
    section.add "certificateId", valid_774527
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774528 = header.getOrDefault("X-Amz-Date")
  valid_774528 = validateParameter(valid_774528, JString, required = false,
                                 default = nil)
  if valid_774528 != nil:
    section.add "X-Amz-Date", valid_774528
  var valid_774529 = header.getOrDefault("X-Amz-Security-Token")
  valid_774529 = validateParameter(valid_774529, JString, required = false,
                                 default = nil)
  if valid_774529 != nil:
    section.add "X-Amz-Security-Token", valid_774529
  var valid_774530 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774530 = validateParameter(valid_774530, JString, required = false,
                                 default = nil)
  if valid_774530 != nil:
    section.add "X-Amz-Content-Sha256", valid_774530
  var valid_774531 = header.getOrDefault("X-Amz-Algorithm")
  valid_774531 = validateParameter(valid_774531, JString, required = false,
                                 default = nil)
  if valid_774531 != nil:
    section.add "X-Amz-Algorithm", valid_774531
  var valid_774532 = header.getOrDefault("X-Amz-Signature")
  valid_774532 = validateParameter(valid_774532, JString, required = false,
                                 default = nil)
  if valid_774532 != nil:
    section.add "X-Amz-Signature", valid_774532
  var valid_774533 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774533 = validateParameter(valid_774533, JString, required = false,
                                 default = nil)
  if valid_774533 != nil:
    section.add "X-Amz-SignedHeaders", valid_774533
  var valid_774534 = header.getOrDefault("X-Amz-Credential")
  valid_774534 = validateParameter(valid_774534, JString, required = false,
                                 default = nil)
  if valid_774534 != nil:
    section.add "X-Amz-Credential", valid_774534
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774535: Call_DescribeCertificate_774524; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified certificate.
  ## 
  let valid = call_774535.validator(path, query, header, formData, body)
  let scheme = call_774535.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774535.url(scheme.get, call_774535.host, call_774535.base,
                         call_774535.route, valid.getOrDefault("path"))
  result = hook(call_774535, url, valid)

proc call*(call_774536: Call_DescribeCertificate_774524; certificateId: string): Recallable =
  ## describeCertificate
  ## Gets information about the specified certificate.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_774537 = newJObject()
  add(path_774537, "certificateId", newJString(certificateId))
  result = call_774536.call(path_774537, nil, nil, nil, nil)

var describeCertificate* = Call_DescribeCertificate_774524(
    name: "describeCertificate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates/{certificateId}",
    validator: validate_DescribeCertificate_774525, base: "/",
    url: url_DescribeCertificate_774526, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteCertificate_774538 = ref object of OpenApiRestCall_772597
proc url_DeleteCertificate_774540(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteCertificate_774539(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_774541 = path.getOrDefault("certificateId")
  valid_774541 = validateParameter(valid_774541, JString, required = true,
                                 default = nil)
  if valid_774541 != nil:
    section.add "certificateId", valid_774541
  result.add "path", section
  ## parameters in `query` object:
  ##   forceDelete: JBool
  ##              : Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
  section = newJObject()
  var valid_774542 = query.getOrDefault("forceDelete")
  valid_774542 = validateParameter(valid_774542, JBool, required = false, default = nil)
  if valid_774542 != nil:
    section.add "forceDelete", valid_774542
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774543 = header.getOrDefault("X-Amz-Date")
  valid_774543 = validateParameter(valid_774543, JString, required = false,
                                 default = nil)
  if valid_774543 != nil:
    section.add "X-Amz-Date", valid_774543
  var valid_774544 = header.getOrDefault("X-Amz-Security-Token")
  valid_774544 = validateParameter(valid_774544, JString, required = false,
                                 default = nil)
  if valid_774544 != nil:
    section.add "X-Amz-Security-Token", valid_774544
  var valid_774545 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774545 = validateParameter(valid_774545, JString, required = false,
                                 default = nil)
  if valid_774545 != nil:
    section.add "X-Amz-Content-Sha256", valid_774545
  var valid_774546 = header.getOrDefault("X-Amz-Algorithm")
  valid_774546 = validateParameter(valid_774546, JString, required = false,
                                 default = nil)
  if valid_774546 != nil:
    section.add "X-Amz-Algorithm", valid_774546
  var valid_774547 = header.getOrDefault("X-Amz-Signature")
  valid_774547 = validateParameter(valid_774547, JString, required = false,
                                 default = nil)
  if valid_774547 != nil:
    section.add "X-Amz-Signature", valid_774547
  var valid_774548 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774548 = validateParameter(valid_774548, JString, required = false,
                                 default = nil)
  if valid_774548 != nil:
    section.add "X-Amz-SignedHeaders", valid_774548
  var valid_774549 = header.getOrDefault("X-Amz-Credential")
  valid_774549 = validateParameter(valid_774549, JString, required = false,
                                 default = nil)
  if valid_774549 != nil:
    section.add "X-Amz-Credential", valid_774549
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774550: Call_DeleteCertificate_774538; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ## 
  let valid = call_774550.validator(path, query, header, formData, body)
  let scheme = call_774550.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774550.url(scheme.get, call_774550.host, call_774550.base,
                         call_774550.route, valid.getOrDefault("path"))
  result = hook(call_774550, url, valid)

proc call*(call_774551: Call_DeleteCertificate_774538; certificateId: string;
          forceDelete: bool = false): Recallable =
  ## deleteCertificate
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ##   forceDelete: bool
  ##              : Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_774552 = newJObject()
  var query_774553 = newJObject()
  add(query_774553, "forceDelete", newJBool(forceDelete))
  add(path_774552, "certificateId", newJString(certificateId))
  result = call_774551.call(path_774552, query_774553, nil, nil, nil)

var deleteCertificate* = Call_DeleteCertificate_774538(name: "deleteCertificate",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/certificates/{certificateId}", validator: validate_DeleteCertificate_774539,
    base: "/", url: url_DeleteCertificate_774540,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteJobExecution_774554 = ref object of OpenApiRestCall_772597
proc url_DeleteJobExecution_774556(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  assert "executionNumber" in path, "`executionNumber` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/executionNumber/"),
               (kind: VariableSegment, value: "executionNumber")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeleteJobExecution_774555(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deletes a job execution.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing whose job execution will be deleted.
  ##   jobId: JString (required)
  ##        : The ID of the job whose execution on a particular device will be deleted.
  ##   executionNumber: JInt (required)
  ##                  : <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_774557 = path.getOrDefault("thingName")
  valid_774557 = validateParameter(valid_774557, JString, required = true,
                                 default = nil)
  if valid_774557 != nil:
    section.add "thingName", valid_774557
  var valid_774558 = path.getOrDefault("jobId")
  valid_774558 = validateParameter(valid_774558, JString, required = true,
                                 default = nil)
  if valid_774558 != nil:
    section.add "jobId", valid_774558
  var valid_774559 = path.getOrDefault("executionNumber")
  valid_774559 = validateParameter(valid_774559, JInt, required = true, default = nil)
  if valid_774559 != nil:
    section.add "executionNumber", valid_774559
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
  section = newJObject()
  var valid_774560 = query.getOrDefault("force")
  valid_774560 = validateParameter(valid_774560, JBool, required = false, default = nil)
  if valid_774560 != nil:
    section.add "force", valid_774560
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774561 = header.getOrDefault("X-Amz-Date")
  valid_774561 = validateParameter(valid_774561, JString, required = false,
                                 default = nil)
  if valid_774561 != nil:
    section.add "X-Amz-Date", valid_774561
  var valid_774562 = header.getOrDefault("X-Amz-Security-Token")
  valid_774562 = validateParameter(valid_774562, JString, required = false,
                                 default = nil)
  if valid_774562 != nil:
    section.add "X-Amz-Security-Token", valid_774562
  var valid_774563 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774563 = validateParameter(valid_774563, JString, required = false,
                                 default = nil)
  if valid_774563 != nil:
    section.add "X-Amz-Content-Sha256", valid_774563
  var valid_774564 = header.getOrDefault("X-Amz-Algorithm")
  valid_774564 = validateParameter(valid_774564, JString, required = false,
                                 default = nil)
  if valid_774564 != nil:
    section.add "X-Amz-Algorithm", valid_774564
  var valid_774565 = header.getOrDefault("X-Amz-Signature")
  valid_774565 = validateParameter(valid_774565, JString, required = false,
                                 default = nil)
  if valid_774565 != nil:
    section.add "X-Amz-Signature", valid_774565
  var valid_774566 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774566 = validateParameter(valid_774566, JString, required = false,
                                 default = nil)
  if valid_774566 != nil:
    section.add "X-Amz-SignedHeaders", valid_774566
  var valid_774567 = header.getOrDefault("X-Amz-Credential")
  valid_774567 = validateParameter(valid_774567, JString, required = false,
                                 default = nil)
  if valid_774567 != nil:
    section.add "X-Amz-Credential", valid_774567
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774568: Call_DeleteJobExecution_774554; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a job execution.
  ## 
  let valid = call_774568.validator(path, query, header, formData, body)
  let scheme = call_774568.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774568.url(scheme.get, call_774568.host, call_774568.base,
                         call_774568.route, valid.getOrDefault("path"))
  result = hook(call_774568, url, valid)

proc call*(call_774569: Call_DeleteJobExecution_774554; thingName: string;
          jobId: string; executionNumber: int; force: bool = false): Recallable =
  ## deleteJobExecution
  ## Deletes a job execution.
  ##   force: bool
  ##        : <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing whose job execution will be deleted.
  ##   jobId: string (required)
  ##        : The ID of the job whose execution on a particular device will be deleted.
  ##   executionNumber: int (required)
  ##                  : <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
  var path_774570 = newJObject()
  var query_774571 = newJObject()
  add(query_774571, "force", newJBool(force))
  add(path_774570, "thingName", newJString(thingName))
  add(path_774570, "jobId", newJString(jobId))
  add(path_774570, "executionNumber", newJInt(executionNumber))
  result = call_774569.call(path_774570, query_774571, nil, nil, nil)

var deleteJobExecution* = Call_DeleteJobExecution_774554(
    name: "deleteJobExecution", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}",
    validator: validate_DeleteJobExecution_774555, base: "/",
    url: url_DeleteJobExecution_774556, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPolicyVersion_774572 = ref object of OpenApiRestCall_772597
proc url_GetPolicyVersion_774574(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_GetPolicyVersion_774573(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets information about the specified policy version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_774575 = path.getOrDefault("policyName")
  valid_774575 = validateParameter(valid_774575, JString, required = true,
                                 default = nil)
  if valid_774575 != nil:
    section.add "policyName", valid_774575
  var valid_774576 = path.getOrDefault("policyVersionId")
  valid_774576 = validateParameter(valid_774576, JString, required = true,
                                 default = nil)
  if valid_774576 != nil:
    section.add "policyVersionId", valid_774576
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774577 = header.getOrDefault("X-Amz-Date")
  valid_774577 = validateParameter(valid_774577, JString, required = false,
                                 default = nil)
  if valid_774577 != nil:
    section.add "X-Amz-Date", valid_774577
  var valid_774578 = header.getOrDefault("X-Amz-Security-Token")
  valid_774578 = validateParameter(valid_774578, JString, required = false,
                                 default = nil)
  if valid_774578 != nil:
    section.add "X-Amz-Security-Token", valid_774578
  var valid_774579 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774579 = validateParameter(valid_774579, JString, required = false,
                                 default = nil)
  if valid_774579 != nil:
    section.add "X-Amz-Content-Sha256", valid_774579
  var valid_774580 = header.getOrDefault("X-Amz-Algorithm")
  valid_774580 = validateParameter(valid_774580, JString, required = false,
                                 default = nil)
  if valid_774580 != nil:
    section.add "X-Amz-Algorithm", valid_774580
  var valid_774581 = header.getOrDefault("X-Amz-Signature")
  valid_774581 = validateParameter(valid_774581, JString, required = false,
                                 default = nil)
  if valid_774581 != nil:
    section.add "X-Amz-Signature", valid_774581
  var valid_774582 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774582 = validateParameter(valid_774582, JString, required = false,
                                 default = nil)
  if valid_774582 != nil:
    section.add "X-Amz-SignedHeaders", valid_774582
  var valid_774583 = header.getOrDefault("X-Amz-Credential")
  valid_774583 = validateParameter(valid_774583, JString, required = false,
                                 default = nil)
  if valid_774583 != nil:
    section.add "X-Amz-Credential", valid_774583
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774584: Call_GetPolicyVersion_774572; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified policy version.
  ## 
  let valid = call_774584.validator(path, query, header, formData, body)
  let scheme = call_774584.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774584.url(scheme.get, call_774584.host, call_774584.base,
                         call_774584.route, valid.getOrDefault("path"))
  result = hook(call_774584, url, valid)

proc call*(call_774585: Call_GetPolicyVersion_774572; policyName: string;
          policyVersionId: string): Recallable =
  ## getPolicyVersion
  ## Gets information about the specified policy version.
  ##   policyName: string (required)
  ##             : The name of the policy.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_774586 = newJObject()
  add(path_774586, "policyName", newJString(policyName))
  add(path_774586, "policyVersionId", newJString(policyVersionId))
  result = call_774585.call(path_774586, nil, nil, nil, nil)

var getPolicyVersion* = Call_GetPolicyVersion_774572(name: "getPolicyVersion",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_GetPolicyVersion_774573, base: "/",
    url: url_GetPolicyVersion_774574, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetDefaultPolicyVersion_774602 = ref object of OpenApiRestCall_772597
proc url_SetDefaultPolicyVersion_774604(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_SetDefaultPolicyVersion_774603(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_774605 = path.getOrDefault("policyName")
  valid_774605 = validateParameter(valid_774605, JString, required = true,
                                 default = nil)
  if valid_774605 != nil:
    section.add "policyName", valid_774605
  var valid_774606 = path.getOrDefault("policyVersionId")
  valid_774606 = validateParameter(valid_774606, JString, required = true,
                                 default = nil)
  if valid_774606 != nil:
    section.add "policyVersionId", valid_774606
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774607 = header.getOrDefault("X-Amz-Date")
  valid_774607 = validateParameter(valid_774607, JString, required = false,
                                 default = nil)
  if valid_774607 != nil:
    section.add "X-Amz-Date", valid_774607
  var valid_774608 = header.getOrDefault("X-Amz-Security-Token")
  valid_774608 = validateParameter(valid_774608, JString, required = false,
                                 default = nil)
  if valid_774608 != nil:
    section.add "X-Amz-Security-Token", valid_774608
  var valid_774609 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774609 = validateParameter(valid_774609, JString, required = false,
                                 default = nil)
  if valid_774609 != nil:
    section.add "X-Amz-Content-Sha256", valid_774609
  var valid_774610 = header.getOrDefault("X-Amz-Algorithm")
  valid_774610 = validateParameter(valid_774610, JString, required = false,
                                 default = nil)
  if valid_774610 != nil:
    section.add "X-Amz-Algorithm", valid_774610
  var valid_774611 = header.getOrDefault("X-Amz-Signature")
  valid_774611 = validateParameter(valid_774611, JString, required = false,
                                 default = nil)
  if valid_774611 != nil:
    section.add "X-Amz-Signature", valid_774611
  var valid_774612 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774612 = validateParameter(valid_774612, JString, required = false,
                                 default = nil)
  if valid_774612 != nil:
    section.add "X-Amz-SignedHeaders", valid_774612
  var valid_774613 = header.getOrDefault("X-Amz-Credential")
  valid_774613 = validateParameter(valid_774613, JString, required = false,
                                 default = nil)
  if valid_774613 != nil:
    section.add "X-Amz-Credential", valid_774613
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774614: Call_SetDefaultPolicyVersion_774602; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ## 
  let valid = call_774614.validator(path, query, header, formData, body)
  let scheme = call_774614.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774614.url(scheme.get, call_774614.host, call_774614.base,
                         call_774614.route, valid.getOrDefault("path"))
  result = hook(call_774614, url, valid)

proc call*(call_774615: Call_SetDefaultPolicyVersion_774602; policyName: string;
          policyVersionId: string): Recallable =
  ## setDefaultPolicyVersion
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ##   policyName: string (required)
  ##             : The policy name.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_774616 = newJObject()
  add(path_774616, "policyName", newJString(policyName))
  add(path_774616, "policyVersionId", newJString(policyVersionId))
  result = call_774615.call(path_774616, nil, nil, nil, nil)

var setDefaultPolicyVersion* = Call_SetDefaultPolicyVersion_774602(
    name: "setDefaultPolicyVersion", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_SetDefaultPolicyVersion_774603, base: "/",
    url: url_SetDefaultPolicyVersion_774604, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeletePolicyVersion_774587 = ref object of OpenApiRestCall_772597
proc url_DeletePolicyVersion_774589(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeletePolicyVersion_774588(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_774590 = path.getOrDefault("policyName")
  valid_774590 = validateParameter(valid_774590, JString, required = true,
                                 default = nil)
  if valid_774590 != nil:
    section.add "policyName", valid_774590
  var valid_774591 = path.getOrDefault("policyVersionId")
  valid_774591 = validateParameter(valid_774591, JString, required = true,
                                 default = nil)
  if valid_774591 != nil:
    section.add "policyVersionId", valid_774591
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774592 = header.getOrDefault("X-Amz-Date")
  valid_774592 = validateParameter(valid_774592, JString, required = false,
                                 default = nil)
  if valid_774592 != nil:
    section.add "X-Amz-Date", valid_774592
  var valid_774593 = header.getOrDefault("X-Amz-Security-Token")
  valid_774593 = validateParameter(valid_774593, JString, required = false,
                                 default = nil)
  if valid_774593 != nil:
    section.add "X-Amz-Security-Token", valid_774593
  var valid_774594 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774594 = validateParameter(valid_774594, JString, required = false,
                                 default = nil)
  if valid_774594 != nil:
    section.add "X-Amz-Content-Sha256", valid_774594
  var valid_774595 = header.getOrDefault("X-Amz-Algorithm")
  valid_774595 = validateParameter(valid_774595, JString, required = false,
                                 default = nil)
  if valid_774595 != nil:
    section.add "X-Amz-Algorithm", valid_774595
  var valid_774596 = header.getOrDefault("X-Amz-Signature")
  valid_774596 = validateParameter(valid_774596, JString, required = false,
                                 default = nil)
  if valid_774596 != nil:
    section.add "X-Amz-Signature", valid_774596
  var valid_774597 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774597 = validateParameter(valid_774597, JString, required = false,
                                 default = nil)
  if valid_774597 != nil:
    section.add "X-Amz-SignedHeaders", valid_774597
  var valid_774598 = header.getOrDefault("X-Amz-Credential")
  valid_774598 = validateParameter(valid_774598, JString, required = false,
                                 default = nil)
  if valid_774598 != nil:
    section.add "X-Amz-Credential", valid_774598
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774599: Call_DeletePolicyVersion_774587; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ## 
  let valid = call_774599.validator(path, query, header, formData, body)
  let scheme = call_774599.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774599.url(scheme.get, call_774599.host, call_774599.base,
                         call_774599.route, valid.getOrDefault("path"))
  result = hook(call_774599, url, valid)

proc call*(call_774600: Call_DeletePolicyVersion_774587; policyName: string;
          policyVersionId: string): Recallable =
  ## deletePolicyVersion
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ##   policyName: string (required)
  ##             : The name of the policy.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_774601 = newJObject()
  add(path_774601, "policyName", newJString(policyName))
  add(path_774601, "policyVersionId", newJString(policyVersionId))
  result = call_774600.call(path_774601, nil, nil, nil, nil)

var deletePolicyVersion* = Call_DeletePolicyVersion_774587(
    name: "deletePolicyVersion", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_DeletePolicyVersion_774588, base: "/",
    url: url_DeletePolicyVersion_774589, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRegistrationCode_774617 = ref object of OpenApiRestCall_772597
proc url_GetRegistrationCode_774619(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetRegistrationCode_774618(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774620 = header.getOrDefault("X-Amz-Date")
  valid_774620 = validateParameter(valid_774620, JString, required = false,
                                 default = nil)
  if valid_774620 != nil:
    section.add "X-Amz-Date", valid_774620
  var valid_774621 = header.getOrDefault("X-Amz-Security-Token")
  valid_774621 = validateParameter(valid_774621, JString, required = false,
                                 default = nil)
  if valid_774621 != nil:
    section.add "X-Amz-Security-Token", valid_774621
  var valid_774622 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774622 = validateParameter(valid_774622, JString, required = false,
                                 default = nil)
  if valid_774622 != nil:
    section.add "X-Amz-Content-Sha256", valid_774622
  var valid_774623 = header.getOrDefault("X-Amz-Algorithm")
  valid_774623 = validateParameter(valid_774623, JString, required = false,
                                 default = nil)
  if valid_774623 != nil:
    section.add "X-Amz-Algorithm", valid_774623
  var valid_774624 = header.getOrDefault("X-Amz-Signature")
  valid_774624 = validateParameter(valid_774624, JString, required = false,
                                 default = nil)
  if valid_774624 != nil:
    section.add "X-Amz-Signature", valid_774624
  var valid_774625 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774625 = validateParameter(valid_774625, JString, required = false,
                                 default = nil)
  if valid_774625 != nil:
    section.add "X-Amz-SignedHeaders", valid_774625
  var valid_774626 = header.getOrDefault("X-Amz-Credential")
  valid_774626 = validateParameter(valid_774626, JString, required = false,
                                 default = nil)
  if valid_774626 != nil:
    section.add "X-Amz-Credential", valid_774626
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774627: Call_GetRegistrationCode_774617; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  ## 
  let valid = call_774627.validator(path, query, header, formData, body)
  let scheme = call_774627.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774627.url(scheme.get, call_774627.host, call_774627.base,
                         call_774627.route, valid.getOrDefault("path"))
  result = hook(call_774627, url, valid)

proc call*(call_774628: Call_GetRegistrationCode_774617): Recallable =
  ## getRegistrationCode
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  result = call_774628.call(nil, nil, nil, nil, nil)

var getRegistrationCode* = Call_GetRegistrationCode_774617(
    name: "getRegistrationCode", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/registrationcode",
    validator: validate_GetRegistrationCode_774618, base: "/",
    url: url_GetRegistrationCode_774619, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRegistrationCode_774629 = ref object of OpenApiRestCall_772597
proc url_DeleteRegistrationCode_774631(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_DeleteRegistrationCode_774630(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a CA certificate registration code.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774632 = header.getOrDefault("X-Amz-Date")
  valid_774632 = validateParameter(valid_774632, JString, required = false,
                                 default = nil)
  if valid_774632 != nil:
    section.add "X-Amz-Date", valid_774632
  var valid_774633 = header.getOrDefault("X-Amz-Security-Token")
  valid_774633 = validateParameter(valid_774633, JString, required = false,
                                 default = nil)
  if valid_774633 != nil:
    section.add "X-Amz-Security-Token", valid_774633
  var valid_774634 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774634 = validateParameter(valid_774634, JString, required = false,
                                 default = nil)
  if valid_774634 != nil:
    section.add "X-Amz-Content-Sha256", valid_774634
  var valid_774635 = header.getOrDefault("X-Amz-Algorithm")
  valid_774635 = validateParameter(valid_774635, JString, required = false,
                                 default = nil)
  if valid_774635 != nil:
    section.add "X-Amz-Algorithm", valid_774635
  var valid_774636 = header.getOrDefault("X-Amz-Signature")
  valid_774636 = validateParameter(valid_774636, JString, required = false,
                                 default = nil)
  if valid_774636 != nil:
    section.add "X-Amz-Signature", valid_774636
  var valid_774637 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774637 = validateParameter(valid_774637, JString, required = false,
                                 default = nil)
  if valid_774637 != nil:
    section.add "X-Amz-SignedHeaders", valid_774637
  var valid_774638 = header.getOrDefault("X-Amz-Credential")
  valid_774638 = validateParameter(valid_774638, JString, required = false,
                                 default = nil)
  if valid_774638 != nil:
    section.add "X-Amz-Credential", valid_774638
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774639: Call_DeleteRegistrationCode_774629; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a CA certificate registration code.
  ## 
  let valid = call_774639.validator(path, query, header, formData, body)
  let scheme = call_774639.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774639.url(scheme.get, call_774639.host, call_774639.base,
                         call_774639.route, valid.getOrDefault("path"))
  result = hook(call_774639, url, valid)

proc call*(call_774640: Call_DeleteRegistrationCode_774629): Recallable =
  ## deleteRegistrationCode
  ## Deletes a CA certificate registration code.
  result = call_774640.call(nil, nil, nil, nil, nil)

var deleteRegistrationCode* = Call_DeleteRegistrationCode_774629(
    name: "deleteRegistrationCode", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/registrationcode",
    validator: validate_DeleteRegistrationCode_774630, base: "/",
    url: url_DeleteRegistrationCode_774631, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteV2LoggingLevel_774641 = ref object of OpenApiRestCall_772597
proc url_DeleteV2LoggingLevel_774643(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_DeleteV2LoggingLevel_774642(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a logging level.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   targetType: JString (required)
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   targetName: JString (required)
  ##             : The name of the resource for which you are configuring logging.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `targetType` field"
  var valid_774644 = query.getOrDefault("targetType")
  valid_774644 = validateParameter(valid_774644, JString, required = true,
                                 default = newJString("DEFAULT"))
  if valid_774644 != nil:
    section.add "targetType", valid_774644
  var valid_774645 = query.getOrDefault("targetName")
  valid_774645 = validateParameter(valid_774645, JString, required = true,
                                 default = nil)
  if valid_774645 != nil:
    section.add "targetName", valid_774645
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774646 = header.getOrDefault("X-Amz-Date")
  valid_774646 = validateParameter(valid_774646, JString, required = false,
                                 default = nil)
  if valid_774646 != nil:
    section.add "X-Amz-Date", valid_774646
  var valid_774647 = header.getOrDefault("X-Amz-Security-Token")
  valid_774647 = validateParameter(valid_774647, JString, required = false,
                                 default = nil)
  if valid_774647 != nil:
    section.add "X-Amz-Security-Token", valid_774647
  var valid_774648 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774648 = validateParameter(valid_774648, JString, required = false,
                                 default = nil)
  if valid_774648 != nil:
    section.add "X-Amz-Content-Sha256", valid_774648
  var valid_774649 = header.getOrDefault("X-Amz-Algorithm")
  valid_774649 = validateParameter(valid_774649, JString, required = false,
                                 default = nil)
  if valid_774649 != nil:
    section.add "X-Amz-Algorithm", valid_774649
  var valid_774650 = header.getOrDefault("X-Amz-Signature")
  valid_774650 = validateParameter(valid_774650, JString, required = false,
                                 default = nil)
  if valid_774650 != nil:
    section.add "X-Amz-Signature", valid_774650
  var valid_774651 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774651 = validateParameter(valid_774651, JString, required = false,
                                 default = nil)
  if valid_774651 != nil:
    section.add "X-Amz-SignedHeaders", valid_774651
  var valid_774652 = header.getOrDefault("X-Amz-Credential")
  valid_774652 = validateParameter(valid_774652, JString, required = false,
                                 default = nil)
  if valid_774652 != nil:
    section.add "X-Amz-Credential", valid_774652
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774653: Call_DeleteV2LoggingLevel_774641; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a logging level.
  ## 
  let valid = call_774653.validator(path, query, header, formData, body)
  let scheme = call_774653.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774653.url(scheme.get, call_774653.host, call_774653.base,
                         call_774653.route, valid.getOrDefault("path"))
  result = hook(call_774653, url, valid)

proc call*(call_774654: Call_DeleteV2LoggingLevel_774641; targetName: string;
          targetType: string = "DEFAULT"): Recallable =
  ## deleteV2LoggingLevel
  ## Deletes a logging level.
  ##   targetType: string (required)
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   targetName: string (required)
  ##             : The name of the resource for which you are configuring logging.
  var query_774655 = newJObject()
  add(query_774655, "targetType", newJString(targetType))
  add(query_774655, "targetName", newJString(targetName))
  result = call_774654.call(nil, query_774655, nil, nil, nil)

var deleteV2LoggingLevel* = Call_DeleteV2LoggingLevel_774641(
    name: "deleteV2LoggingLevel", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/v2LoggingLevel#targetType&targetName",
    validator: validate_DeleteV2LoggingLevel_774642, base: "/",
    url: url_DeleteV2LoggingLevel_774643, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeprecateThingType_774656 = ref object of OpenApiRestCall_772597
proc url_DeprecateThingType_774658(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName"),
               (kind: ConstantSegment, value: "/deprecate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DeprecateThingType_774657(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type to deprecate.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_774659 = path.getOrDefault("thingTypeName")
  valid_774659 = validateParameter(valid_774659, JString, required = true,
                                 default = nil)
  if valid_774659 != nil:
    section.add "thingTypeName", valid_774659
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774660 = header.getOrDefault("X-Amz-Date")
  valid_774660 = validateParameter(valid_774660, JString, required = false,
                                 default = nil)
  if valid_774660 != nil:
    section.add "X-Amz-Date", valid_774660
  var valid_774661 = header.getOrDefault("X-Amz-Security-Token")
  valid_774661 = validateParameter(valid_774661, JString, required = false,
                                 default = nil)
  if valid_774661 != nil:
    section.add "X-Amz-Security-Token", valid_774661
  var valid_774662 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774662 = validateParameter(valid_774662, JString, required = false,
                                 default = nil)
  if valid_774662 != nil:
    section.add "X-Amz-Content-Sha256", valid_774662
  var valid_774663 = header.getOrDefault("X-Amz-Algorithm")
  valid_774663 = validateParameter(valid_774663, JString, required = false,
                                 default = nil)
  if valid_774663 != nil:
    section.add "X-Amz-Algorithm", valid_774663
  var valid_774664 = header.getOrDefault("X-Amz-Signature")
  valid_774664 = validateParameter(valid_774664, JString, required = false,
                                 default = nil)
  if valid_774664 != nil:
    section.add "X-Amz-Signature", valid_774664
  var valid_774665 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774665 = validateParameter(valid_774665, JString, required = false,
                                 default = nil)
  if valid_774665 != nil:
    section.add "X-Amz-SignedHeaders", valid_774665
  var valid_774666 = header.getOrDefault("X-Amz-Credential")
  valid_774666 = validateParameter(valid_774666, JString, required = false,
                                 default = nil)
  if valid_774666 != nil:
    section.add "X-Amz-Credential", valid_774666
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774668: Call_DeprecateThingType_774656; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ## 
  let valid = call_774668.validator(path, query, header, formData, body)
  let scheme = call_774668.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774668.url(scheme.get, call_774668.host, call_774668.base,
                         call_774668.route, valid.getOrDefault("path"))
  result = hook(call_774668, url, valid)

proc call*(call_774669: Call_DeprecateThingType_774656; body: JsonNode;
          thingTypeName: string): Recallable =
  ## deprecateThingType
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ##   body: JObject (required)
  ##   thingTypeName: string (required)
  ##                : The name of the thing type to deprecate.
  var path_774670 = newJObject()
  var body_774671 = newJObject()
  if body != nil:
    body_774671 = body
  add(path_774670, "thingTypeName", newJString(thingTypeName))
  result = call_774669.call(path_774670, nil, nil, nil, body_774671)

var deprecateThingType* = Call_DeprecateThingType_774656(
    name: "deprecateThingType", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/thing-types/{thingTypeName}/deprecate",
    validator: validate_DeprecateThingType_774657, base: "/",
    url: url_DeprecateThingType_774658, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditFinding_774672 = ref object of OpenApiRestCall_772597
proc url_DescribeAuditFinding_774674(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "findingId" in path, "`findingId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/findings/"),
               (kind: VariableSegment, value: "findingId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeAuditFinding_774673(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   findingId: JString (required)
  ##            : A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `findingId` field"
  var valid_774675 = path.getOrDefault("findingId")
  valid_774675 = validateParameter(valid_774675, JString, required = true,
                                 default = nil)
  if valid_774675 != nil:
    section.add "findingId", valid_774675
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774676 = header.getOrDefault("X-Amz-Date")
  valid_774676 = validateParameter(valid_774676, JString, required = false,
                                 default = nil)
  if valid_774676 != nil:
    section.add "X-Amz-Date", valid_774676
  var valid_774677 = header.getOrDefault("X-Amz-Security-Token")
  valid_774677 = validateParameter(valid_774677, JString, required = false,
                                 default = nil)
  if valid_774677 != nil:
    section.add "X-Amz-Security-Token", valid_774677
  var valid_774678 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774678 = validateParameter(valid_774678, JString, required = false,
                                 default = nil)
  if valid_774678 != nil:
    section.add "X-Amz-Content-Sha256", valid_774678
  var valid_774679 = header.getOrDefault("X-Amz-Algorithm")
  valid_774679 = validateParameter(valid_774679, JString, required = false,
                                 default = nil)
  if valid_774679 != nil:
    section.add "X-Amz-Algorithm", valid_774679
  var valid_774680 = header.getOrDefault("X-Amz-Signature")
  valid_774680 = validateParameter(valid_774680, JString, required = false,
                                 default = nil)
  if valid_774680 != nil:
    section.add "X-Amz-Signature", valid_774680
  var valid_774681 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774681 = validateParameter(valid_774681, JString, required = false,
                                 default = nil)
  if valid_774681 != nil:
    section.add "X-Amz-SignedHeaders", valid_774681
  var valid_774682 = header.getOrDefault("X-Amz-Credential")
  valid_774682 = validateParameter(valid_774682, JString, required = false,
                                 default = nil)
  if valid_774682 != nil:
    section.add "X-Amz-Credential", valid_774682
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774683: Call_DescribeAuditFinding_774672; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ## 
  let valid = call_774683.validator(path, query, header, formData, body)
  let scheme = call_774683.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774683.url(scheme.get, call_774683.host, call_774683.base,
                         call_774683.route, valid.getOrDefault("path"))
  result = hook(call_774683, url, valid)

proc call*(call_774684: Call_DescribeAuditFinding_774672; findingId: string): Recallable =
  ## describeAuditFinding
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ##   findingId: string (required)
  ##            : A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
  var path_774685 = newJObject()
  add(path_774685, "findingId", newJString(findingId))
  result = call_774684.call(path_774685, nil, nil, nil, nil)

var describeAuditFinding* = Call_DescribeAuditFinding_774672(
    name: "describeAuditFinding", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/findings/{findingId}",
    validator: validate_DescribeAuditFinding_774673, base: "/",
    url: url_DescribeAuditFinding_774674, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartAuditMitigationActionsTask_774700 = ref object of OpenApiRestCall_772597
proc url_StartAuditMitigationActionsTask_774702(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_StartAuditMitigationActionsTask_774701(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_774703 = path.getOrDefault("taskId")
  valid_774703 = validateParameter(valid_774703, JString, required = true,
                                 default = nil)
  if valid_774703 != nil:
    section.add "taskId", valid_774703
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774704 = header.getOrDefault("X-Amz-Date")
  valid_774704 = validateParameter(valid_774704, JString, required = false,
                                 default = nil)
  if valid_774704 != nil:
    section.add "X-Amz-Date", valid_774704
  var valid_774705 = header.getOrDefault("X-Amz-Security-Token")
  valid_774705 = validateParameter(valid_774705, JString, required = false,
                                 default = nil)
  if valid_774705 != nil:
    section.add "X-Amz-Security-Token", valid_774705
  var valid_774706 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774706 = validateParameter(valid_774706, JString, required = false,
                                 default = nil)
  if valid_774706 != nil:
    section.add "X-Amz-Content-Sha256", valid_774706
  var valid_774707 = header.getOrDefault("X-Amz-Algorithm")
  valid_774707 = validateParameter(valid_774707, JString, required = false,
                                 default = nil)
  if valid_774707 != nil:
    section.add "X-Amz-Algorithm", valid_774707
  var valid_774708 = header.getOrDefault("X-Amz-Signature")
  valid_774708 = validateParameter(valid_774708, JString, required = false,
                                 default = nil)
  if valid_774708 != nil:
    section.add "X-Amz-Signature", valid_774708
  var valid_774709 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774709 = validateParameter(valid_774709, JString, required = false,
                                 default = nil)
  if valid_774709 != nil:
    section.add "X-Amz-SignedHeaders", valid_774709
  var valid_774710 = header.getOrDefault("X-Amz-Credential")
  valid_774710 = validateParameter(valid_774710, JString, required = false,
                                 default = nil)
  if valid_774710 != nil:
    section.add "X-Amz-Credential", valid_774710
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774712: Call_StartAuditMitigationActionsTask_774700;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ## 
  let valid = call_774712.validator(path, query, header, formData, body)
  let scheme = call_774712.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774712.url(scheme.get, call_774712.host, call_774712.base,
                         call_774712.route, valid.getOrDefault("path"))
  result = hook(call_774712, url, valid)

proc call*(call_774713: Call_StartAuditMitigationActionsTask_774700;
          body: JsonNode; taskId: string): Recallable =
  ## startAuditMitigationActionsTask
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ##   body: JObject (required)
  ##   taskId: string (required)
  ##         : A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
  var path_774714 = newJObject()
  var body_774715 = newJObject()
  if body != nil:
    body_774715 = body
  add(path_774714, "taskId", newJString(taskId))
  result = call_774713.call(path_774714, nil, nil, nil, body_774715)

var startAuditMitigationActionsTask* = Call_StartAuditMitigationActionsTask_774700(
    name: "startAuditMitigationActionsTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/audit/mitigationactions/tasks/{taskId}",
    validator: validate_StartAuditMitigationActionsTask_774701, base: "/",
    url: url_StartAuditMitigationActionsTask_774702,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditMitigationActionsTask_774686 = ref object of OpenApiRestCall_772597
proc url_DescribeAuditMitigationActionsTask_774688(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeAuditMitigationActionsTask_774687(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The unique identifier for the audit mitigation task.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_774689 = path.getOrDefault("taskId")
  valid_774689 = validateParameter(valid_774689, JString, required = true,
                                 default = nil)
  if valid_774689 != nil:
    section.add "taskId", valid_774689
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774690 = header.getOrDefault("X-Amz-Date")
  valid_774690 = validateParameter(valid_774690, JString, required = false,
                                 default = nil)
  if valid_774690 != nil:
    section.add "X-Amz-Date", valid_774690
  var valid_774691 = header.getOrDefault("X-Amz-Security-Token")
  valid_774691 = validateParameter(valid_774691, JString, required = false,
                                 default = nil)
  if valid_774691 != nil:
    section.add "X-Amz-Security-Token", valid_774691
  var valid_774692 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774692 = validateParameter(valid_774692, JString, required = false,
                                 default = nil)
  if valid_774692 != nil:
    section.add "X-Amz-Content-Sha256", valid_774692
  var valid_774693 = header.getOrDefault("X-Amz-Algorithm")
  valid_774693 = validateParameter(valid_774693, JString, required = false,
                                 default = nil)
  if valid_774693 != nil:
    section.add "X-Amz-Algorithm", valid_774693
  var valid_774694 = header.getOrDefault("X-Amz-Signature")
  valid_774694 = validateParameter(valid_774694, JString, required = false,
                                 default = nil)
  if valid_774694 != nil:
    section.add "X-Amz-Signature", valid_774694
  var valid_774695 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774695 = validateParameter(valid_774695, JString, required = false,
                                 default = nil)
  if valid_774695 != nil:
    section.add "X-Amz-SignedHeaders", valid_774695
  var valid_774696 = header.getOrDefault("X-Amz-Credential")
  valid_774696 = validateParameter(valid_774696, JString, required = false,
                                 default = nil)
  if valid_774696 != nil:
    section.add "X-Amz-Credential", valid_774696
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774697: Call_DescribeAuditMitigationActionsTask_774686;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ## 
  let valid = call_774697.validator(path, query, header, formData, body)
  let scheme = call_774697.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774697.url(scheme.get, call_774697.host, call_774697.base,
                         call_774697.route, valid.getOrDefault("path"))
  result = hook(call_774697, url, valid)

proc call*(call_774698: Call_DescribeAuditMitigationActionsTask_774686;
          taskId: string): Recallable =
  ## describeAuditMitigationActionsTask
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ##   taskId: string (required)
  ##         : The unique identifier for the audit mitigation task.
  var path_774699 = newJObject()
  add(path_774699, "taskId", newJString(taskId))
  result = call_774698.call(path_774699, nil, nil, nil, nil)

var describeAuditMitigationActionsTask* = Call_DescribeAuditMitigationActionsTask_774686(
    name: "describeAuditMitigationActionsTask", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/mitigationactions/tasks/{taskId}",
    validator: validate_DescribeAuditMitigationActionsTask_774687, base: "/",
    url: url_DescribeAuditMitigationActionsTask_774688,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditTask_774716 = ref object of OpenApiRestCall_772597
proc url_DescribeAuditTask_774718(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeAuditTask_774717(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Gets information about a Device Defender audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The ID of the audit whose information you want to get.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_774719 = path.getOrDefault("taskId")
  valid_774719 = validateParameter(valid_774719, JString, required = true,
                                 default = nil)
  if valid_774719 != nil:
    section.add "taskId", valid_774719
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774720 = header.getOrDefault("X-Amz-Date")
  valid_774720 = validateParameter(valid_774720, JString, required = false,
                                 default = nil)
  if valid_774720 != nil:
    section.add "X-Amz-Date", valid_774720
  var valid_774721 = header.getOrDefault("X-Amz-Security-Token")
  valid_774721 = validateParameter(valid_774721, JString, required = false,
                                 default = nil)
  if valid_774721 != nil:
    section.add "X-Amz-Security-Token", valid_774721
  var valid_774722 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774722 = validateParameter(valid_774722, JString, required = false,
                                 default = nil)
  if valid_774722 != nil:
    section.add "X-Amz-Content-Sha256", valid_774722
  var valid_774723 = header.getOrDefault("X-Amz-Algorithm")
  valid_774723 = validateParameter(valid_774723, JString, required = false,
                                 default = nil)
  if valid_774723 != nil:
    section.add "X-Amz-Algorithm", valid_774723
  var valid_774724 = header.getOrDefault("X-Amz-Signature")
  valid_774724 = validateParameter(valid_774724, JString, required = false,
                                 default = nil)
  if valid_774724 != nil:
    section.add "X-Amz-Signature", valid_774724
  var valid_774725 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774725 = validateParameter(valid_774725, JString, required = false,
                                 default = nil)
  if valid_774725 != nil:
    section.add "X-Amz-SignedHeaders", valid_774725
  var valid_774726 = header.getOrDefault("X-Amz-Credential")
  valid_774726 = validateParameter(valid_774726, JString, required = false,
                                 default = nil)
  if valid_774726 != nil:
    section.add "X-Amz-Credential", valid_774726
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774727: Call_DescribeAuditTask_774716; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a Device Defender audit.
  ## 
  let valid = call_774727.validator(path, query, header, formData, body)
  let scheme = call_774727.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774727.url(scheme.get, call_774727.host, call_774727.base,
                         call_774727.route, valid.getOrDefault("path"))
  result = hook(call_774727, url, valid)

proc call*(call_774728: Call_DescribeAuditTask_774716; taskId: string): Recallable =
  ## describeAuditTask
  ## Gets information about a Device Defender audit.
  ##   taskId: string (required)
  ##         : The ID of the audit whose information you want to get.
  var path_774729 = newJObject()
  add(path_774729, "taskId", newJString(taskId))
  result = call_774728.call(path_774729, nil, nil, nil, nil)

var describeAuditTask* = Call_DescribeAuditTask_774716(name: "describeAuditTask",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/audit/tasks/{taskId}", validator: validate_DescribeAuditTask_774717,
    base: "/", url: url_DescribeAuditTask_774718,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeEndpoint_774730 = ref object of OpenApiRestCall_772597
proc url_DescribeEndpoint_774732(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_DescribeEndpoint_774731(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Returns a unique endpoint specific to the AWS account making the call.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endpointType: JString
  ##               : <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
  section = newJObject()
  var valid_774733 = query.getOrDefault("endpointType")
  valid_774733 = validateParameter(valid_774733, JString, required = false,
                                 default = nil)
  if valid_774733 != nil:
    section.add "endpointType", valid_774733
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774734 = header.getOrDefault("X-Amz-Date")
  valid_774734 = validateParameter(valid_774734, JString, required = false,
                                 default = nil)
  if valid_774734 != nil:
    section.add "X-Amz-Date", valid_774734
  var valid_774735 = header.getOrDefault("X-Amz-Security-Token")
  valid_774735 = validateParameter(valid_774735, JString, required = false,
                                 default = nil)
  if valid_774735 != nil:
    section.add "X-Amz-Security-Token", valid_774735
  var valid_774736 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774736 = validateParameter(valid_774736, JString, required = false,
                                 default = nil)
  if valid_774736 != nil:
    section.add "X-Amz-Content-Sha256", valid_774736
  var valid_774737 = header.getOrDefault("X-Amz-Algorithm")
  valid_774737 = validateParameter(valid_774737, JString, required = false,
                                 default = nil)
  if valid_774737 != nil:
    section.add "X-Amz-Algorithm", valid_774737
  var valid_774738 = header.getOrDefault("X-Amz-Signature")
  valid_774738 = validateParameter(valid_774738, JString, required = false,
                                 default = nil)
  if valid_774738 != nil:
    section.add "X-Amz-Signature", valid_774738
  var valid_774739 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774739 = validateParameter(valid_774739, JString, required = false,
                                 default = nil)
  if valid_774739 != nil:
    section.add "X-Amz-SignedHeaders", valid_774739
  var valid_774740 = header.getOrDefault("X-Amz-Credential")
  valid_774740 = validateParameter(valid_774740, JString, required = false,
                                 default = nil)
  if valid_774740 != nil:
    section.add "X-Amz-Credential", valid_774740
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774741: Call_DescribeEndpoint_774730; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a unique endpoint specific to the AWS account making the call.
  ## 
  let valid = call_774741.validator(path, query, header, formData, body)
  let scheme = call_774741.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774741.url(scheme.get, call_774741.host, call_774741.base,
                         call_774741.route, valid.getOrDefault("path"))
  result = hook(call_774741, url, valid)

proc call*(call_774742: Call_DescribeEndpoint_774730; endpointType: string = ""): Recallable =
  ## describeEndpoint
  ## Returns a unique endpoint specific to the AWS account making the call.
  ##   endpointType: string
  ##               : <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
  var query_774743 = newJObject()
  add(query_774743, "endpointType", newJString(endpointType))
  result = call_774742.call(nil, query_774743, nil, nil, nil)

var describeEndpoint* = Call_DescribeEndpoint_774730(name: "describeEndpoint",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/endpoint",
    validator: validate_DescribeEndpoint_774731, base: "/",
    url: url_DescribeEndpoint_774732, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeEventConfigurations_774744 = ref object of OpenApiRestCall_772597
proc url_DescribeEventConfigurations_774746(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_DescribeEventConfigurations_774745(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes event configurations.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774747 = header.getOrDefault("X-Amz-Date")
  valid_774747 = validateParameter(valid_774747, JString, required = false,
                                 default = nil)
  if valid_774747 != nil:
    section.add "X-Amz-Date", valid_774747
  var valid_774748 = header.getOrDefault("X-Amz-Security-Token")
  valid_774748 = validateParameter(valid_774748, JString, required = false,
                                 default = nil)
  if valid_774748 != nil:
    section.add "X-Amz-Security-Token", valid_774748
  var valid_774749 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774749 = validateParameter(valid_774749, JString, required = false,
                                 default = nil)
  if valid_774749 != nil:
    section.add "X-Amz-Content-Sha256", valid_774749
  var valid_774750 = header.getOrDefault("X-Amz-Algorithm")
  valid_774750 = validateParameter(valid_774750, JString, required = false,
                                 default = nil)
  if valid_774750 != nil:
    section.add "X-Amz-Algorithm", valid_774750
  var valid_774751 = header.getOrDefault("X-Amz-Signature")
  valid_774751 = validateParameter(valid_774751, JString, required = false,
                                 default = nil)
  if valid_774751 != nil:
    section.add "X-Amz-Signature", valid_774751
  var valid_774752 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774752 = validateParameter(valid_774752, JString, required = false,
                                 default = nil)
  if valid_774752 != nil:
    section.add "X-Amz-SignedHeaders", valid_774752
  var valid_774753 = header.getOrDefault("X-Amz-Credential")
  valid_774753 = validateParameter(valid_774753, JString, required = false,
                                 default = nil)
  if valid_774753 != nil:
    section.add "X-Amz-Credential", valid_774753
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774754: Call_DescribeEventConfigurations_774744; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes event configurations.
  ## 
  let valid = call_774754.validator(path, query, header, formData, body)
  let scheme = call_774754.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774754.url(scheme.get, call_774754.host, call_774754.base,
                         call_774754.route, valid.getOrDefault("path"))
  result = hook(call_774754, url, valid)

proc call*(call_774755: Call_DescribeEventConfigurations_774744): Recallable =
  ## describeEventConfigurations
  ## Describes event configurations.
  result = call_774755.call(nil, nil, nil, nil, nil)

var describeEventConfigurations* = Call_DescribeEventConfigurations_774744(
    name: "describeEventConfigurations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/event-configurations",
    validator: validate_DescribeEventConfigurations_774745, base: "/",
    url: url_DescribeEventConfigurations_774746,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateEventConfigurations_774756 = ref object of OpenApiRestCall_772597
proc url_UpdateEventConfigurations_774758(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_UpdateEventConfigurations_774757(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the event configurations.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774759 = header.getOrDefault("X-Amz-Date")
  valid_774759 = validateParameter(valid_774759, JString, required = false,
                                 default = nil)
  if valid_774759 != nil:
    section.add "X-Amz-Date", valid_774759
  var valid_774760 = header.getOrDefault("X-Amz-Security-Token")
  valid_774760 = validateParameter(valid_774760, JString, required = false,
                                 default = nil)
  if valid_774760 != nil:
    section.add "X-Amz-Security-Token", valid_774760
  var valid_774761 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774761 = validateParameter(valid_774761, JString, required = false,
                                 default = nil)
  if valid_774761 != nil:
    section.add "X-Amz-Content-Sha256", valid_774761
  var valid_774762 = header.getOrDefault("X-Amz-Algorithm")
  valid_774762 = validateParameter(valid_774762, JString, required = false,
                                 default = nil)
  if valid_774762 != nil:
    section.add "X-Amz-Algorithm", valid_774762
  var valid_774763 = header.getOrDefault("X-Amz-Signature")
  valid_774763 = validateParameter(valid_774763, JString, required = false,
                                 default = nil)
  if valid_774763 != nil:
    section.add "X-Amz-Signature", valid_774763
  var valid_774764 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774764 = validateParameter(valid_774764, JString, required = false,
                                 default = nil)
  if valid_774764 != nil:
    section.add "X-Amz-SignedHeaders", valid_774764
  var valid_774765 = header.getOrDefault("X-Amz-Credential")
  valid_774765 = validateParameter(valid_774765, JString, required = false,
                                 default = nil)
  if valid_774765 != nil:
    section.add "X-Amz-Credential", valid_774765
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774767: Call_UpdateEventConfigurations_774756; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the event configurations.
  ## 
  let valid = call_774767.validator(path, query, header, formData, body)
  let scheme = call_774767.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774767.url(scheme.get, call_774767.host, call_774767.base,
                         call_774767.route, valid.getOrDefault("path"))
  result = hook(call_774767, url, valid)

proc call*(call_774768: Call_UpdateEventConfigurations_774756; body: JsonNode): Recallable =
  ## updateEventConfigurations
  ## Updates the event configurations.
  ##   body: JObject (required)
  var body_774769 = newJObject()
  if body != nil:
    body_774769 = body
  result = call_774768.call(nil, nil, nil, nil, body_774769)

var updateEventConfigurations* = Call_UpdateEventConfigurations_774756(
    name: "updateEventConfigurations", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/event-configurations",
    validator: validate_UpdateEventConfigurations_774757, base: "/",
    url: url_UpdateEventConfigurations_774758,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeIndex_774770 = ref object of OpenApiRestCall_772597
proc url_DescribeIndex_774772(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "indexName" in path, "`indexName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/indices/"),
               (kind: VariableSegment, value: "indexName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeIndex_774771(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a search index.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   indexName: JString (required)
  ##            : The index name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `indexName` field"
  var valid_774773 = path.getOrDefault("indexName")
  valid_774773 = validateParameter(valid_774773, JString, required = true,
                                 default = nil)
  if valid_774773 != nil:
    section.add "indexName", valid_774773
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774774 = header.getOrDefault("X-Amz-Date")
  valid_774774 = validateParameter(valid_774774, JString, required = false,
                                 default = nil)
  if valid_774774 != nil:
    section.add "X-Amz-Date", valid_774774
  var valid_774775 = header.getOrDefault("X-Amz-Security-Token")
  valid_774775 = validateParameter(valid_774775, JString, required = false,
                                 default = nil)
  if valid_774775 != nil:
    section.add "X-Amz-Security-Token", valid_774775
  var valid_774776 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774776 = validateParameter(valid_774776, JString, required = false,
                                 default = nil)
  if valid_774776 != nil:
    section.add "X-Amz-Content-Sha256", valid_774776
  var valid_774777 = header.getOrDefault("X-Amz-Algorithm")
  valid_774777 = validateParameter(valid_774777, JString, required = false,
                                 default = nil)
  if valid_774777 != nil:
    section.add "X-Amz-Algorithm", valid_774777
  var valid_774778 = header.getOrDefault("X-Amz-Signature")
  valid_774778 = validateParameter(valid_774778, JString, required = false,
                                 default = nil)
  if valid_774778 != nil:
    section.add "X-Amz-Signature", valid_774778
  var valid_774779 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774779 = validateParameter(valid_774779, JString, required = false,
                                 default = nil)
  if valid_774779 != nil:
    section.add "X-Amz-SignedHeaders", valid_774779
  var valid_774780 = header.getOrDefault("X-Amz-Credential")
  valid_774780 = validateParameter(valid_774780, JString, required = false,
                                 default = nil)
  if valid_774780 != nil:
    section.add "X-Amz-Credential", valid_774780
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774781: Call_DescribeIndex_774770; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a search index.
  ## 
  let valid = call_774781.validator(path, query, header, formData, body)
  let scheme = call_774781.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774781.url(scheme.get, call_774781.host, call_774781.base,
                         call_774781.route, valid.getOrDefault("path"))
  result = hook(call_774781, url, valid)

proc call*(call_774782: Call_DescribeIndex_774770; indexName: string): Recallable =
  ## describeIndex
  ## Describes a search index.
  ##   indexName: string (required)
  ##            : The index name.
  var path_774783 = newJObject()
  add(path_774783, "indexName", newJString(indexName))
  result = call_774782.call(path_774783, nil, nil, nil, nil)

var describeIndex* = Call_DescribeIndex_774770(name: "describeIndex",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/indices/{indexName}", validator: validate_DescribeIndex_774771,
    base: "/", url: url_DescribeIndex_774772, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeJobExecution_774784 = ref object of OpenApiRestCall_772597
proc url_DescribeJobExecution_774786(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeJobExecution_774785(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a job execution.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing on which the job execution is running.
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_774787 = path.getOrDefault("thingName")
  valid_774787 = validateParameter(valid_774787, JString, required = true,
                                 default = nil)
  if valid_774787 != nil:
    section.add "thingName", valid_774787
  var valid_774788 = path.getOrDefault("jobId")
  valid_774788 = validateParameter(valid_774788, JString, required = true,
                                 default = nil)
  if valid_774788 != nil:
    section.add "jobId", valid_774788
  result.add "path", section
  ## parameters in `query` object:
  ##   executionNumber: JInt
  ##                  : A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
  section = newJObject()
  var valid_774789 = query.getOrDefault("executionNumber")
  valid_774789 = validateParameter(valid_774789, JInt, required = false, default = nil)
  if valid_774789 != nil:
    section.add "executionNumber", valid_774789
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774790 = header.getOrDefault("X-Amz-Date")
  valid_774790 = validateParameter(valid_774790, JString, required = false,
                                 default = nil)
  if valid_774790 != nil:
    section.add "X-Amz-Date", valid_774790
  var valid_774791 = header.getOrDefault("X-Amz-Security-Token")
  valid_774791 = validateParameter(valid_774791, JString, required = false,
                                 default = nil)
  if valid_774791 != nil:
    section.add "X-Amz-Security-Token", valid_774791
  var valid_774792 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774792 = validateParameter(valid_774792, JString, required = false,
                                 default = nil)
  if valid_774792 != nil:
    section.add "X-Amz-Content-Sha256", valid_774792
  var valid_774793 = header.getOrDefault("X-Amz-Algorithm")
  valid_774793 = validateParameter(valid_774793, JString, required = false,
                                 default = nil)
  if valid_774793 != nil:
    section.add "X-Amz-Algorithm", valid_774793
  var valid_774794 = header.getOrDefault("X-Amz-Signature")
  valid_774794 = validateParameter(valid_774794, JString, required = false,
                                 default = nil)
  if valid_774794 != nil:
    section.add "X-Amz-Signature", valid_774794
  var valid_774795 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774795 = validateParameter(valid_774795, JString, required = false,
                                 default = nil)
  if valid_774795 != nil:
    section.add "X-Amz-SignedHeaders", valid_774795
  var valid_774796 = header.getOrDefault("X-Amz-Credential")
  valid_774796 = validateParameter(valid_774796, JString, required = false,
                                 default = nil)
  if valid_774796 != nil:
    section.add "X-Amz-Credential", valid_774796
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774797: Call_DescribeJobExecution_774784; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a job execution.
  ## 
  let valid = call_774797.validator(path, query, header, formData, body)
  let scheme = call_774797.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774797.url(scheme.get, call_774797.host, call_774797.base,
                         call_774797.route, valid.getOrDefault("path"))
  result = hook(call_774797, url, valid)

proc call*(call_774798: Call_DescribeJobExecution_774784; thingName: string;
          jobId: string; executionNumber: int = 0): Recallable =
  ## describeJobExecution
  ## Describes a job execution.
  ##   thingName: string (required)
  ##            : The name of the thing on which the job execution is running.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   executionNumber: int
  ##                  : A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
  var path_774799 = newJObject()
  var query_774800 = newJObject()
  add(path_774799, "thingName", newJString(thingName))
  add(path_774799, "jobId", newJString(jobId))
  add(query_774800, "executionNumber", newJInt(executionNumber))
  result = call_774798.call(path_774799, query_774800, nil, nil, nil)

var describeJobExecution* = Call_DescribeJobExecution_774784(
    name: "describeJobExecution", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs/{jobId}",
    validator: validate_DescribeJobExecution_774785, base: "/",
    url: url_DescribeJobExecution_774786, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingRegistrationTask_774801 = ref object of OpenApiRestCall_772597
proc url_DescribeThingRegistrationTask_774803(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DescribeThingRegistrationTask_774802(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The task ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_774804 = path.getOrDefault("taskId")
  valid_774804 = validateParameter(valid_774804, JString, required = true,
                                 default = nil)
  if valid_774804 != nil:
    section.add "taskId", valid_774804
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774805 = header.getOrDefault("X-Amz-Date")
  valid_774805 = validateParameter(valid_774805, JString, required = false,
                                 default = nil)
  if valid_774805 != nil:
    section.add "X-Amz-Date", valid_774805
  var valid_774806 = header.getOrDefault("X-Amz-Security-Token")
  valid_774806 = validateParameter(valid_774806, JString, required = false,
                                 default = nil)
  if valid_774806 != nil:
    section.add "X-Amz-Security-Token", valid_774806
  var valid_774807 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774807 = validateParameter(valid_774807, JString, required = false,
                                 default = nil)
  if valid_774807 != nil:
    section.add "X-Amz-Content-Sha256", valid_774807
  var valid_774808 = header.getOrDefault("X-Amz-Algorithm")
  valid_774808 = validateParameter(valid_774808, JString, required = false,
                                 default = nil)
  if valid_774808 != nil:
    section.add "X-Amz-Algorithm", valid_774808
  var valid_774809 = header.getOrDefault("X-Amz-Signature")
  valid_774809 = validateParameter(valid_774809, JString, required = false,
                                 default = nil)
  if valid_774809 != nil:
    section.add "X-Amz-Signature", valid_774809
  var valid_774810 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774810 = validateParameter(valid_774810, JString, required = false,
                                 default = nil)
  if valid_774810 != nil:
    section.add "X-Amz-SignedHeaders", valid_774810
  var valid_774811 = header.getOrDefault("X-Amz-Credential")
  valid_774811 = validateParameter(valid_774811, JString, required = false,
                                 default = nil)
  if valid_774811 != nil:
    section.add "X-Amz-Credential", valid_774811
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774812: Call_DescribeThingRegistrationTask_774801; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a bulk thing provisioning task.
  ## 
  let valid = call_774812.validator(path, query, header, formData, body)
  let scheme = call_774812.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774812.url(scheme.get, call_774812.host, call_774812.base,
                         call_774812.route, valid.getOrDefault("path"))
  result = hook(call_774812, url, valid)

proc call*(call_774813: Call_DescribeThingRegistrationTask_774801; taskId: string): Recallable =
  ## describeThingRegistrationTask
  ## Describes a bulk thing provisioning task.
  ##   taskId: string (required)
  ##         : The task ID.
  var path_774814 = newJObject()
  add(path_774814, "taskId", newJString(taskId))
  result = call_774813.call(path_774814, nil, nil, nil, nil)

var describeThingRegistrationTask* = Call_DescribeThingRegistrationTask_774801(
    name: "describeThingRegistrationTask", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks/{taskId}",
    validator: validate_DescribeThingRegistrationTask_774802, base: "/",
    url: url_DescribeThingRegistrationTask_774803,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DisableTopicRule_774815 = ref object of OpenApiRestCall_772597
proc url_DisableTopicRule_774817(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName"),
               (kind: ConstantSegment, value: "/disable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_DisableTopicRule_774816(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Disables the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule to disable.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_774818 = path.getOrDefault("ruleName")
  valid_774818 = validateParameter(valid_774818, JString, required = true,
                                 default = nil)
  if valid_774818 != nil:
    section.add "ruleName", valid_774818
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774819 = header.getOrDefault("X-Amz-Date")
  valid_774819 = validateParameter(valid_774819, JString, required = false,
                                 default = nil)
  if valid_774819 != nil:
    section.add "X-Amz-Date", valid_774819
  var valid_774820 = header.getOrDefault("X-Amz-Security-Token")
  valid_774820 = validateParameter(valid_774820, JString, required = false,
                                 default = nil)
  if valid_774820 != nil:
    section.add "X-Amz-Security-Token", valid_774820
  var valid_774821 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774821 = validateParameter(valid_774821, JString, required = false,
                                 default = nil)
  if valid_774821 != nil:
    section.add "X-Amz-Content-Sha256", valid_774821
  var valid_774822 = header.getOrDefault("X-Amz-Algorithm")
  valid_774822 = validateParameter(valid_774822, JString, required = false,
                                 default = nil)
  if valid_774822 != nil:
    section.add "X-Amz-Algorithm", valid_774822
  var valid_774823 = header.getOrDefault("X-Amz-Signature")
  valid_774823 = validateParameter(valid_774823, JString, required = false,
                                 default = nil)
  if valid_774823 != nil:
    section.add "X-Amz-Signature", valid_774823
  var valid_774824 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774824 = validateParameter(valid_774824, JString, required = false,
                                 default = nil)
  if valid_774824 != nil:
    section.add "X-Amz-SignedHeaders", valid_774824
  var valid_774825 = header.getOrDefault("X-Amz-Credential")
  valid_774825 = validateParameter(valid_774825, JString, required = false,
                                 default = nil)
  if valid_774825 != nil:
    section.add "X-Amz-Credential", valid_774825
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774826: Call_DisableTopicRule_774815; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Disables the rule.
  ## 
  let valid = call_774826.validator(path, query, header, formData, body)
  let scheme = call_774826.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774826.url(scheme.get, call_774826.host, call_774826.base,
                         call_774826.route, valid.getOrDefault("path"))
  result = hook(call_774826, url, valid)

proc call*(call_774827: Call_DisableTopicRule_774815; ruleName: string): Recallable =
  ## disableTopicRule
  ## Disables the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule to disable.
  var path_774828 = newJObject()
  add(path_774828, "ruleName", newJString(ruleName))
  result = call_774827.call(path_774828, nil, nil, nil, nil)

var disableTopicRule* = Call_DisableTopicRule_774815(name: "disableTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}/disable", validator: validate_DisableTopicRule_774816,
    base: "/", url: url_DisableTopicRule_774817,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_EnableTopicRule_774829 = ref object of OpenApiRestCall_772597
proc url_EnableTopicRule_774831(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName"),
               (kind: ConstantSegment, value: "/enable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_EnableTopicRule_774830(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Enables the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the topic rule to enable.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_774832 = path.getOrDefault("ruleName")
  valid_774832 = validateParameter(valid_774832, JString, required = true,
                                 default = nil)
  if valid_774832 != nil:
    section.add "ruleName", valid_774832
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774833 = header.getOrDefault("X-Amz-Date")
  valid_774833 = validateParameter(valid_774833, JString, required = false,
                                 default = nil)
  if valid_774833 != nil:
    section.add "X-Amz-Date", valid_774833
  var valid_774834 = header.getOrDefault("X-Amz-Security-Token")
  valid_774834 = validateParameter(valid_774834, JString, required = false,
                                 default = nil)
  if valid_774834 != nil:
    section.add "X-Amz-Security-Token", valid_774834
  var valid_774835 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774835 = validateParameter(valid_774835, JString, required = false,
                                 default = nil)
  if valid_774835 != nil:
    section.add "X-Amz-Content-Sha256", valid_774835
  var valid_774836 = header.getOrDefault("X-Amz-Algorithm")
  valid_774836 = validateParameter(valid_774836, JString, required = false,
                                 default = nil)
  if valid_774836 != nil:
    section.add "X-Amz-Algorithm", valid_774836
  var valid_774837 = header.getOrDefault("X-Amz-Signature")
  valid_774837 = validateParameter(valid_774837, JString, required = false,
                                 default = nil)
  if valid_774837 != nil:
    section.add "X-Amz-Signature", valid_774837
  var valid_774838 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774838 = validateParameter(valid_774838, JString, required = false,
                                 default = nil)
  if valid_774838 != nil:
    section.add "X-Amz-SignedHeaders", valid_774838
  var valid_774839 = header.getOrDefault("X-Amz-Credential")
  valid_774839 = validateParameter(valid_774839, JString, required = false,
                                 default = nil)
  if valid_774839 != nil:
    section.add "X-Amz-Credential", valid_774839
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774840: Call_EnableTopicRule_774829; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the rule.
  ## 
  let valid = call_774840.validator(path, query, header, formData, body)
  let scheme = call_774840.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774840.url(scheme.get, call_774840.host, call_774840.base,
                         call_774840.route, valid.getOrDefault("path"))
  result = hook(call_774840, url, valid)

proc call*(call_774841: Call_EnableTopicRule_774829; ruleName: string): Recallable =
  ## enableTopicRule
  ## Enables the rule.
  ##   ruleName: string (required)
  ##           : The name of the topic rule to enable.
  var path_774842 = newJObject()
  add(path_774842, "ruleName", newJString(ruleName))
  result = call_774841.call(path_774842, nil, nil, nil, nil)

var enableTopicRule* = Call_EnableTopicRule_774829(name: "enableTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}/enable", validator: validate_EnableTopicRule_774830,
    base: "/", url: url_EnableTopicRule_774831, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEffectivePolicies_774843 = ref object of OpenApiRestCall_772597
proc url_GetEffectivePolicies_774845(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetEffectivePolicies_774844(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingName: JString
  ##            : The thing name.
  section = newJObject()
  var valid_774846 = query.getOrDefault("thingName")
  valid_774846 = validateParameter(valid_774846, JString, required = false,
                                 default = nil)
  if valid_774846 != nil:
    section.add "thingName", valid_774846
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774847 = header.getOrDefault("X-Amz-Date")
  valid_774847 = validateParameter(valid_774847, JString, required = false,
                                 default = nil)
  if valid_774847 != nil:
    section.add "X-Amz-Date", valid_774847
  var valid_774848 = header.getOrDefault("X-Amz-Security-Token")
  valid_774848 = validateParameter(valid_774848, JString, required = false,
                                 default = nil)
  if valid_774848 != nil:
    section.add "X-Amz-Security-Token", valid_774848
  var valid_774849 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774849 = validateParameter(valid_774849, JString, required = false,
                                 default = nil)
  if valid_774849 != nil:
    section.add "X-Amz-Content-Sha256", valid_774849
  var valid_774850 = header.getOrDefault("X-Amz-Algorithm")
  valid_774850 = validateParameter(valid_774850, JString, required = false,
                                 default = nil)
  if valid_774850 != nil:
    section.add "X-Amz-Algorithm", valid_774850
  var valid_774851 = header.getOrDefault("X-Amz-Signature")
  valid_774851 = validateParameter(valid_774851, JString, required = false,
                                 default = nil)
  if valid_774851 != nil:
    section.add "X-Amz-Signature", valid_774851
  var valid_774852 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774852 = validateParameter(valid_774852, JString, required = false,
                                 default = nil)
  if valid_774852 != nil:
    section.add "X-Amz-SignedHeaders", valid_774852
  var valid_774853 = header.getOrDefault("X-Amz-Credential")
  valid_774853 = validateParameter(valid_774853, JString, required = false,
                                 default = nil)
  if valid_774853 != nil:
    section.add "X-Amz-Credential", valid_774853
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774855: Call_GetEffectivePolicies_774843; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ## 
  let valid = call_774855.validator(path, query, header, formData, body)
  let scheme = call_774855.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774855.url(scheme.get, call_774855.host, call_774855.base,
                         call_774855.route, valid.getOrDefault("path"))
  result = hook(call_774855, url, valid)

proc call*(call_774856: Call_GetEffectivePolicies_774843; body: JsonNode;
          thingName: string = ""): Recallable =
  ## getEffectivePolicies
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ##   thingName: string
  ##            : The thing name.
  ##   body: JObject (required)
  var query_774857 = newJObject()
  var body_774858 = newJObject()
  add(query_774857, "thingName", newJString(thingName))
  if body != nil:
    body_774858 = body
  result = call_774856.call(nil, query_774857, nil, nil, body_774858)

var getEffectivePolicies* = Call_GetEffectivePolicies_774843(
    name: "getEffectivePolicies", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/effective-policies",
    validator: validate_GetEffectivePolicies_774844, base: "/",
    url: url_GetEffectivePolicies_774845, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateIndexingConfiguration_774871 = ref object of OpenApiRestCall_772597
proc url_UpdateIndexingConfiguration_774873(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_UpdateIndexingConfiguration_774872(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the search configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774874 = header.getOrDefault("X-Amz-Date")
  valid_774874 = validateParameter(valid_774874, JString, required = false,
                                 default = nil)
  if valid_774874 != nil:
    section.add "X-Amz-Date", valid_774874
  var valid_774875 = header.getOrDefault("X-Amz-Security-Token")
  valid_774875 = validateParameter(valid_774875, JString, required = false,
                                 default = nil)
  if valid_774875 != nil:
    section.add "X-Amz-Security-Token", valid_774875
  var valid_774876 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774876 = validateParameter(valid_774876, JString, required = false,
                                 default = nil)
  if valid_774876 != nil:
    section.add "X-Amz-Content-Sha256", valid_774876
  var valid_774877 = header.getOrDefault("X-Amz-Algorithm")
  valid_774877 = validateParameter(valid_774877, JString, required = false,
                                 default = nil)
  if valid_774877 != nil:
    section.add "X-Amz-Algorithm", valid_774877
  var valid_774878 = header.getOrDefault("X-Amz-Signature")
  valid_774878 = validateParameter(valid_774878, JString, required = false,
                                 default = nil)
  if valid_774878 != nil:
    section.add "X-Amz-Signature", valid_774878
  var valid_774879 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774879 = validateParameter(valid_774879, JString, required = false,
                                 default = nil)
  if valid_774879 != nil:
    section.add "X-Amz-SignedHeaders", valid_774879
  var valid_774880 = header.getOrDefault("X-Amz-Credential")
  valid_774880 = validateParameter(valid_774880, JString, required = false,
                                 default = nil)
  if valid_774880 != nil:
    section.add "X-Amz-Credential", valid_774880
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774882: Call_UpdateIndexingConfiguration_774871; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the search configuration.
  ## 
  let valid = call_774882.validator(path, query, header, formData, body)
  let scheme = call_774882.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774882.url(scheme.get, call_774882.host, call_774882.base,
                         call_774882.route, valid.getOrDefault("path"))
  result = hook(call_774882, url, valid)

proc call*(call_774883: Call_UpdateIndexingConfiguration_774871; body: JsonNode): Recallable =
  ## updateIndexingConfiguration
  ## Updates the search configuration.
  ##   body: JObject (required)
  var body_774884 = newJObject()
  if body != nil:
    body_774884 = body
  result = call_774883.call(nil, nil, nil, nil, body_774884)

var updateIndexingConfiguration* = Call_UpdateIndexingConfiguration_774871(
    name: "updateIndexingConfiguration", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/indexing/config",
    validator: validate_UpdateIndexingConfiguration_774872, base: "/",
    url: url_UpdateIndexingConfiguration_774873,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetIndexingConfiguration_774859 = ref object of OpenApiRestCall_772597
proc url_GetIndexingConfiguration_774861(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetIndexingConfiguration_774860(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the search configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774862 = header.getOrDefault("X-Amz-Date")
  valid_774862 = validateParameter(valid_774862, JString, required = false,
                                 default = nil)
  if valid_774862 != nil:
    section.add "X-Amz-Date", valid_774862
  var valid_774863 = header.getOrDefault("X-Amz-Security-Token")
  valid_774863 = validateParameter(valid_774863, JString, required = false,
                                 default = nil)
  if valid_774863 != nil:
    section.add "X-Amz-Security-Token", valid_774863
  var valid_774864 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774864 = validateParameter(valid_774864, JString, required = false,
                                 default = nil)
  if valid_774864 != nil:
    section.add "X-Amz-Content-Sha256", valid_774864
  var valid_774865 = header.getOrDefault("X-Amz-Algorithm")
  valid_774865 = validateParameter(valid_774865, JString, required = false,
                                 default = nil)
  if valid_774865 != nil:
    section.add "X-Amz-Algorithm", valid_774865
  var valid_774866 = header.getOrDefault("X-Amz-Signature")
  valid_774866 = validateParameter(valid_774866, JString, required = false,
                                 default = nil)
  if valid_774866 != nil:
    section.add "X-Amz-Signature", valid_774866
  var valid_774867 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774867 = validateParameter(valid_774867, JString, required = false,
                                 default = nil)
  if valid_774867 != nil:
    section.add "X-Amz-SignedHeaders", valid_774867
  var valid_774868 = header.getOrDefault("X-Amz-Credential")
  valid_774868 = validateParameter(valid_774868, JString, required = false,
                                 default = nil)
  if valid_774868 != nil:
    section.add "X-Amz-Credential", valid_774868
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774869: Call_GetIndexingConfiguration_774859; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the search configuration.
  ## 
  let valid = call_774869.validator(path, query, header, formData, body)
  let scheme = call_774869.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774869.url(scheme.get, call_774869.host, call_774869.base,
                         call_774869.route, valid.getOrDefault("path"))
  result = hook(call_774869, url, valid)

proc call*(call_774870: Call_GetIndexingConfiguration_774859): Recallable =
  ## getIndexingConfiguration
  ## Gets the search configuration.
  result = call_774870.call(nil, nil, nil, nil, nil)

var getIndexingConfiguration* = Call_GetIndexingConfiguration_774859(
    name: "getIndexingConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/indexing/config",
    validator: validate_GetIndexingConfiguration_774860, base: "/",
    url: url_GetIndexingConfiguration_774861, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetJobDocument_774885 = ref object of OpenApiRestCall_772597
proc url_GetJobDocument_774887(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/job-document")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_GetJobDocument_774886(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets a job document.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_774888 = path.getOrDefault("jobId")
  valid_774888 = validateParameter(valid_774888, JString, required = true,
                                 default = nil)
  if valid_774888 != nil:
    section.add "jobId", valid_774888
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774889 = header.getOrDefault("X-Amz-Date")
  valid_774889 = validateParameter(valid_774889, JString, required = false,
                                 default = nil)
  if valid_774889 != nil:
    section.add "X-Amz-Date", valid_774889
  var valid_774890 = header.getOrDefault("X-Amz-Security-Token")
  valid_774890 = validateParameter(valid_774890, JString, required = false,
                                 default = nil)
  if valid_774890 != nil:
    section.add "X-Amz-Security-Token", valid_774890
  var valid_774891 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774891 = validateParameter(valid_774891, JString, required = false,
                                 default = nil)
  if valid_774891 != nil:
    section.add "X-Amz-Content-Sha256", valid_774891
  var valid_774892 = header.getOrDefault("X-Amz-Algorithm")
  valid_774892 = validateParameter(valid_774892, JString, required = false,
                                 default = nil)
  if valid_774892 != nil:
    section.add "X-Amz-Algorithm", valid_774892
  var valid_774893 = header.getOrDefault("X-Amz-Signature")
  valid_774893 = validateParameter(valid_774893, JString, required = false,
                                 default = nil)
  if valid_774893 != nil:
    section.add "X-Amz-Signature", valid_774893
  var valid_774894 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774894 = validateParameter(valid_774894, JString, required = false,
                                 default = nil)
  if valid_774894 != nil:
    section.add "X-Amz-SignedHeaders", valid_774894
  var valid_774895 = header.getOrDefault("X-Amz-Credential")
  valid_774895 = validateParameter(valid_774895, JString, required = false,
                                 default = nil)
  if valid_774895 != nil:
    section.add "X-Amz-Credential", valid_774895
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774896: Call_GetJobDocument_774885; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a job document.
  ## 
  let valid = call_774896.validator(path, query, header, formData, body)
  let scheme = call_774896.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774896.url(scheme.get, call_774896.host, call_774896.base,
                         call_774896.route, valid.getOrDefault("path"))
  result = hook(call_774896, url, valid)

proc call*(call_774897: Call_GetJobDocument_774885; jobId: string): Recallable =
  ## getJobDocument
  ## Gets a job document.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  var path_774898 = newJObject()
  add(path_774898, "jobId", newJString(jobId))
  result = call_774897.call(path_774898, nil, nil, nil, nil)

var getJobDocument* = Call_GetJobDocument_774885(name: "getJobDocument",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/jobs/{jobId}/job-document", validator: validate_GetJobDocument_774886,
    base: "/", url: url_GetJobDocument_774887, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetLoggingOptions_774911 = ref object of OpenApiRestCall_772597
proc url_SetLoggingOptions_774913(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_SetLoggingOptions_774912(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774914 = header.getOrDefault("X-Amz-Date")
  valid_774914 = validateParameter(valid_774914, JString, required = false,
                                 default = nil)
  if valid_774914 != nil:
    section.add "X-Amz-Date", valid_774914
  var valid_774915 = header.getOrDefault("X-Amz-Security-Token")
  valid_774915 = validateParameter(valid_774915, JString, required = false,
                                 default = nil)
  if valid_774915 != nil:
    section.add "X-Amz-Security-Token", valid_774915
  var valid_774916 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774916 = validateParameter(valid_774916, JString, required = false,
                                 default = nil)
  if valid_774916 != nil:
    section.add "X-Amz-Content-Sha256", valid_774916
  var valid_774917 = header.getOrDefault("X-Amz-Algorithm")
  valid_774917 = validateParameter(valid_774917, JString, required = false,
                                 default = nil)
  if valid_774917 != nil:
    section.add "X-Amz-Algorithm", valid_774917
  var valid_774918 = header.getOrDefault("X-Amz-Signature")
  valid_774918 = validateParameter(valid_774918, JString, required = false,
                                 default = nil)
  if valid_774918 != nil:
    section.add "X-Amz-Signature", valid_774918
  var valid_774919 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774919 = validateParameter(valid_774919, JString, required = false,
                                 default = nil)
  if valid_774919 != nil:
    section.add "X-Amz-SignedHeaders", valid_774919
  var valid_774920 = header.getOrDefault("X-Amz-Credential")
  valid_774920 = validateParameter(valid_774920, JString, required = false,
                                 default = nil)
  if valid_774920 != nil:
    section.add "X-Amz-Credential", valid_774920
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774922: Call_SetLoggingOptions_774911; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ## 
  let valid = call_774922.validator(path, query, header, formData, body)
  let scheme = call_774922.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774922.url(scheme.get, call_774922.host, call_774922.base,
                         call_774922.route, valid.getOrDefault("path"))
  result = hook(call_774922, url, valid)

proc call*(call_774923: Call_SetLoggingOptions_774911; body: JsonNode): Recallable =
  ## setLoggingOptions
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ##   body: JObject (required)
  var body_774924 = newJObject()
  if body != nil:
    body_774924 = body
  result = call_774923.call(nil, nil, nil, nil, body_774924)

var setLoggingOptions* = Call_SetLoggingOptions_774911(name: "setLoggingOptions",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/loggingOptions",
    validator: validate_SetLoggingOptions_774912, base: "/",
    url: url_SetLoggingOptions_774913, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetLoggingOptions_774899 = ref object of OpenApiRestCall_772597
proc url_GetLoggingOptions_774901(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetLoggingOptions_774900(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774902 = header.getOrDefault("X-Amz-Date")
  valid_774902 = validateParameter(valid_774902, JString, required = false,
                                 default = nil)
  if valid_774902 != nil:
    section.add "X-Amz-Date", valid_774902
  var valid_774903 = header.getOrDefault("X-Amz-Security-Token")
  valid_774903 = validateParameter(valid_774903, JString, required = false,
                                 default = nil)
  if valid_774903 != nil:
    section.add "X-Amz-Security-Token", valid_774903
  var valid_774904 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774904 = validateParameter(valid_774904, JString, required = false,
                                 default = nil)
  if valid_774904 != nil:
    section.add "X-Amz-Content-Sha256", valid_774904
  var valid_774905 = header.getOrDefault("X-Amz-Algorithm")
  valid_774905 = validateParameter(valid_774905, JString, required = false,
                                 default = nil)
  if valid_774905 != nil:
    section.add "X-Amz-Algorithm", valid_774905
  var valid_774906 = header.getOrDefault("X-Amz-Signature")
  valid_774906 = validateParameter(valid_774906, JString, required = false,
                                 default = nil)
  if valid_774906 != nil:
    section.add "X-Amz-Signature", valid_774906
  var valid_774907 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774907 = validateParameter(valid_774907, JString, required = false,
                                 default = nil)
  if valid_774907 != nil:
    section.add "X-Amz-SignedHeaders", valid_774907
  var valid_774908 = header.getOrDefault("X-Amz-Credential")
  valid_774908 = validateParameter(valid_774908, JString, required = false,
                                 default = nil)
  if valid_774908 != nil:
    section.add "X-Amz-Credential", valid_774908
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774909: Call_GetLoggingOptions_774899; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  ## 
  let valid = call_774909.validator(path, query, header, formData, body)
  let scheme = call_774909.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774909.url(scheme.get, call_774909.host, call_774909.base,
                         call_774909.route, valid.getOrDefault("path"))
  result = hook(call_774909, url, valid)

proc call*(call_774910: Call_GetLoggingOptions_774899): Recallable =
  ## getLoggingOptions
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  result = call_774910.call(nil, nil, nil, nil, nil)

var getLoggingOptions* = Call_GetLoggingOptions_774899(name: "getLoggingOptions",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/loggingOptions",
    validator: validate_GetLoggingOptions_774900, base: "/",
    url: url_GetLoggingOptions_774901, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetStatistics_774925 = ref object of OpenApiRestCall_772597
proc url_GetStatistics_774927(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetStatistics_774926(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets statistics about things that match the specified query.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774928 = header.getOrDefault("X-Amz-Date")
  valid_774928 = validateParameter(valid_774928, JString, required = false,
                                 default = nil)
  if valid_774928 != nil:
    section.add "X-Amz-Date", valid_774928
  var valid_774929 = header.getOrDefault("X-Amz-Security-Token")
  valid_774929 = validateParameter(valid_774929, JString, required = false,
                                 default = nil)
  if valid_774929 != nil:
    section.add "X-Amz-Security-Token", valid_774929
  var valid_774930 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774930 = validateParameter(valid_774930, JString, required = false,
                                 default = nil)
  if valid_774930 != nil:
    section.add "X-Amz-Content-Sha256", valid_774930
  var valid_774931 = header.getOrDefault("X-Amz-Algorithm")
  valid_774931 = validateParameter(valid_774931, JString, required = false,
                                 default = nil)
  if valid_774931 != nil:
    section.add "X-Amz-Algorithm", valid_774931
  var valid_774932 = header.getOrDefault("X-Amz-Signature")
  valid_774932 = validateParameter(valid_774932, JString, required = false,
                                 default = nil)
  if valid_774932 != nil:
    section.add "X-Amz-Signature", valid_774932
  var valid_774933 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774933 = validateParameter(valid_774933, JString, required = false,
                                 default = nil)
  if valid_774933 != nil:
    section.add "X-Amz-SignedHeaders", valid_774933
  var valid_774934 = header.getOrDefault("X-Amz-Credential")
  valid_774934 = validateParameter(valid_774934, JString, required = false,
                                 default = nil)
  if valid_774934 != nil:
    section.add "X-Amz-Credential", valid_774934
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774936: Call_GetStatistics_774925; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets statistics about things that match the specified query.
  ## 
  let valid = call_774936.validator(path, query, header, formData, body)
  let scheme = call_774936.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774936.url(scheme.get, call_774936.host, call_774936.base,
                         call_774936.route, valid.getOrDefault("path"))
  result = hook(call_774936, url, valid)

proc call*(call_774937: Call_GetStatistics_774925; body: JsonNode): Recallable =
  ## getStatistics
  ## Gets statistics about things that match the specified query.
  ##   body: JObject (required)
  var body_774938 = newJObject()
  if body != nil:
    body_774938 = body
  result = call_774937.call(nil, nil, nil, nil, body_774938)

var getStatistics* = Call_GetStatistics_774925(name: "getStatistics",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/statistics", validator: validate_GetStatistics_774926,
    base: "/", url: url_GetStatistics_774927, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetV2LoggingOptions_774951 = ref object of OpenApiRestCall_772597
proc url_SetV2LoggingOptions_774953(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_SetV2LoggingOptions_774952(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Sets the logging options for the V2 logging service.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774954 = header.getOrDefault("X-Amz-Date")
  valid_774954 = validateParameter(valid_774954, JString, required = false,
                                 default = nil)
  if valid_774954 != nil:
    section.add "X-Amz-Date", valid_774954
  var valid_774955 = header.getOrDefault("X-Amz-Security-Token")
  valid_774955 = validateParameter(valid_774955, JString, required = false,
                                 default = nil)
  if valid_774955 != nil:
    section.add "X-Amz-Security-Token", valid_774955
  var valid_774956 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774956 = validateParameter(valid_774956, JString, required = false,
                                 default = nil)
  if valid_774956 != nil:
    section.add "X-Amz-Content-Sha256", valid_774956
  var valid_774957 = header.getOrDefault("X-Amz-Algorithm")
  valid_774957 = validateParameter(valid_774957, JString, required = false,
                                 default = nil)
  if valid_774957 != nil:
    section.add "X-Amz-Algorithm", valid_774957
  var valid_774958 = header.getOrDefault("X-Amz-Signature")
  valid_774958 = validateParameter(valid_774958, JString, required = false,
                                 default = nil)
  if valid_774958 != nil:
    section.add "X-Amz-Signature", valid_774958
  var valid_774959 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774959 = validateParameter(valid_774959, JString, required = false,
                                 default = nil)
  if valid_774959 != nil:
    section.add "X-Amz-SignedHeaders", valid_774959
  var valid_774960 = header.getOrDefault("X-Amz-Credential")
  valid_774960 = validateParameter(valid_774960, JString, required = false,
                                 default = nil)
  if valid_774960 != nil:
    section.add "X-Amz-Credential", valid_774960
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_774962: Call_SetV2LoggingOptions_774951; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the logging options for the V2 logging service.
  ## 
  let valid = call_774962.validator(path, query, header, formData, body)
  let scheme = call_774962.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774962.url(scheme.get, call_774962.host, call_774962.base,
                         call_774962.route, valid.getOrDefault("path"))
  result = hook(call_774962, url, valid)

proc call*(call_774963: Call_SetV2LoggingOptions_774951; body: JsonNode): Recallable =
  ## setV2LoggingOptions
  ## Sets the logging options for the V2 logging service.
  ##   body: JObject (required)
  var body_774964 = newJObject()
  if body != nil:
    body_774964 = body
  result = call_774963.call(nil, nil, nil, nil, body_774964)

var setV2LoggingOptions* = Call_SetV2LoggingOptions_774951(
    name: "setV2LoggingOptions", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/v2LoggingOptions",
    validator: validate_SetV2LoggingOptions_774952, base: "/",
    url: url_SetV2LoggingOptions_774953, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetV2LoggingOptions_774939 = ref object of OpenApiRestCall_772597
proc url_GetV2LoggingOptions_774941(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_GetV2LoggingOptions_774940(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets the fine grained logging options.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774942 = header.getOrDefault("X-Amz-Date")
  valid_774942 = validateParameter(valid_774942, JString, required = false,
                                 default = nil)
  if valid_774942 != nil:
    section.add "X-Amz-Date", valid_774942
  var valid_774943 = header.getOrDefault("X-Amz-Security-Token")
  valid_774943 = validateParameter(valid_774943, JString, required = false,
                                 default = nil)
  if valid_774943 != nil:
    section.add "X-Amz-Security-Token", valid_774943
  var valid_774944 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774944 = validateParameter(valid_774944, JString, required = false,
                                 default = nil)
  if valid_774944 != nil:
    section.add "X-Amz-Content-Sha256", valid_774944
  var valid_774945 = header.getOrDefault("X-Amz-Algorithm")
  valid_774945 = validateParameter(valid_774945, JString, required = false,
                                 default = nil)
  if valid_774945 != nil:
    section.add "X-Amz-Algorithm", valid_774945
  var valid_774946 = header.getOrDefault("X-Amz-Signature")
  valid_774946 = validateParameter(valid_774946, JString, required = false,
                                 default = nil)
  if valid_774946 != nil:
    section.add "X-Amz-Signature", valid_774946
  var valid_774947 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774947 = validateParameter(valid_774947, JString, required = false,
                                 default = nil)
  if valid_774947 != nil:
    section.add "X-Amz-SignedHeaders", valid_774947
  var valid_774948 = header.getOrDefault("X-Amz-Credential")
  valid_774948 = validateParameter(valid_774948, JString, required = false,
                                 default = nil)
  if valid_774948 != nil:
    section.add "X-Amz-Credential", valid_774948
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774949: Call_GetV2LoggingOptions_774939; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the fine grained logging options.
  ## 
  let valid = call_774949.validator(path, query, header, formData, body)
  let scheme = call_774949.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774949.url(scheme.get, call_774949.host, call_774949.base,
                         call_774949.route, valid.getOrDefault("path"))
  result = hook(call_774949, url, valid)

proc call*(call_774950: Call_GetV2LoggingOptions_774939): Recallable =
  ## getV2LoggingOptions
  ## Gets the fine grained logging options.
  result = call_774950.call(nil, nil, nil, nil, nil)

var getV2LoggingOptions* = Call_GetV2LoggingOptions_774939(
    name: "getV2LoggingOptions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/v2LoggingOptions",
    validator: validate_GetV2LoggingOptions_774940, base: "/",
    url: url_GetV2LoggingOptions_774941, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListActiveViolations_774965 = ref object of OpenApiRestCall_772597
proc url_ListActiveViolations_774967(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListActiveViolations_774966(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the active violations for a given Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingName: JString
  ##            : The name of the thing whose active violations are listed.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   securityProfileName: JString
  ##                      : The name of the Device Defender security profile for which violations are listed.
  section = newJObject()
  var valid_774968 = query.getOrDefault("thingName")
  valid_774968 = validateParameter(valid_774968, JString, required = false,
                                 default = nil)
  if valid_774968 != nil:
    section.add "thingName", valid_774968
  var valid_774969 = query.getOrDefault("maxResults")
  valid_774969 = validateParameter(valid_774969, JInt, required = false, default = nil)
  if valid_774969 != nil:
    section.add "maxResults", valid_774969
  var valid_774970 = query.getOrDefault("nextToken")
  valid_774970 = validateParameter(valid_774970, JString, required = false,
                                 default = nil)
  if valid_774970 != nil:
    section.add "nextToken", valid_774970
  var valid_774971 = query.getOrDefault("securityProfileName")
  valid_774971 = validateParameter(valid_774971, JString, required = false,
                                 default = nil)
  if valid_774971 != nil:
    section.add "securityProfileName", valid_774971
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774972 = header.getOrDefault("X-Amz-Date")
  valid_774972 = validateParameter(valid_774972, JString, required = false,
                                 default = nil)
  if valid_774972 != nil:
    section.add "X-Amz-Date", valid_774972
  var valid_774973 = header.getOrDefault("X-Amz-Security-Token")
  valid_774973 = validateParameter(valid_774973, JString, required = false,
                                 default = nil)
  if valid_774973 != nil:
    section.add "X-Amz-Security-Token", valid_774973
  var valid_774974 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774974 = validateParameter(valid_774974, JString, required = false,
                                 default = nil)
  if valid_774974 != nil:
    section.add "X-Amz-Content-Sha256", valid_774974
  var valid_774975 = header.getOrDefault("X-Amz-Algorithm")
  valid_774975 = validateParameter(valid_774975, JString, required = false,
                                 default = nil)
  if valid_774975 != nil:
    section.add "X-Amz-Algorithm", valid_774975
  var valid_774976 = header.getOrDefault("X-Amz-Signature")
  valid_774976 = validateParameter(valid_774976, JString, required = false,
                                 default = nil)
  if valid_774976 != nil:
    section.add "X-Amz-Signature", valid_774976
  var valid_774977 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774977 = validateParameter(valid_774977, JString, required = false,
                                 default = nil)
  if valid_774977 != nil:
    section.add "X-Amz-SignedHeaders", valid_774977
  var valid_774978 = header.getOrDefault("X-Amz-Credential")
  valid_774978 = validateParameter(valid_774978, JString, required = false,
                                 default = nil)
  if valid_774978 != nil:
    section.add "X-Amz-Credential", valid_774978
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774979: Call_ListActiveViolations_774965; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the active violations for a given Device Defender security profile.
  ## 
  let valid = call_774979.validator(path, query, header, formData, body)
  let scheme = call_774979.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774979.url(scheme.get, call_774979.host, call_774979.base,
                         call_774979.route, valid.getOrDefault("path"))
  result = hook(call_774979, url, valid)

proc call*(call_774980: Call_ListActiveViolations_774965; thingName: string = "";
          maxResults: int = 0; nextToken: string = ""; securityProfileName: string = ""): Recallable =
  ## listActiveViolations
  ## Lists the active violations for a given Device Defender security profile.
  ##   thingName: string
  ##            : The name of the thing whose active violations are listed.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string
  ##                      : The name of the Device Defender security profile for which violations are listed.
  var query_774981 = newJObject()
  add(query_774981, "thingName", newJString(thingName))
  add(query_774981, "maxResults", newJInt(maxResults))
  add(query_774981, "nextToken", newJString(nextToken))
  add(query_774981, "securityProfileName", newJString(securityProfileName))
  result = call_774980.call(nil, query_774981, nil, nil, nil)

var listActiveViolations* = Call_ListActiveViolations_774965(
    name: "listActiveViolations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/active-violations",
    validator: validate_ListActiveViolations_774966, base: "/",
    url: url_ListActiveViolations_774967, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAttachedPolicies_774982 = ref object of OpenApiRestCall_772597
proc url_ListAttachedPolicies_774984(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "target" in path, "`target` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/attached-policies/"),
               (kind: VariableSegment, value: "target")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_ListAttachedPolicies_774983(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the policies attached to the specified thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   target: JString (required)
  ##         : The group or principal for which the policies will be listed.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `target` field"
  var valid_774985 = path.getOrDefault("target")
  valid_774985 = validateParameter(valid_774985, JString, required = true,
                                 default = nil)
  if valid_774985 != nil:
    section.add "target", valid_774985
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The token to retrieve the next set of results.
  ##   pageSize: JInt
  ##           : The maximum number of results to be returned per request.
  ##   recursive: JBool
  ##            : When true, recursively list attached policies.
  section = newJObject()
  var valid_774986 = query.getOrDefault("marker")
  valid_774986 = validateParameter(valid_774986, JString, required = false,
                                 default = nil)
  if valid_774986 != nil:
    section.add "marker", valid_774986
  var valid_774987 = query.getOrDefault("pageSize")
  valid_774987 = validateParameter(valid_774987, JInt, required = false, default = nil)
  if valid_774987 != nil:
    section.add "pageSize", valid_774987
  var valid_774988 = query.getOrDefault("recursive")
  valid_774988 = validateParameter(valid_774988, JBool, required = false, default = nil)
  if valid_774988 != nil:
    section.add "recursive", valid_774988
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_774989 = header.getOrDefault("X-Amz-Date")
  valid_774989 = validateParameter(valid_774989, JString, required = false,
                                 default = nil)
  if valid_774989 != nil:
    section.add "X-Amz-Date", valid_774989
  var valid_774990 = header.getOrDefault("X-Amz-Security-Token")
  valid_774990 = validateParameter(valid_774990, JString, required = false,
                                 default = nil)
  if valid_774990 != nil:
    section.add "X-Amz-Security-Token", valid_774990
  var valid_774991 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_774991 = validateParameter(valid_774991, JString, required = false,
                                 default = nil)
  if valid_774991 != nil:
    section.add "X-Amz-Content-Sha256", valid_774991
  var valid_774992 = header.getOrDefault("X-Amz-Algorithm")
  valid_774992 = validateParameter(valid_774992, JString, required = false,
                                 default = nil)
  if valid_774992 != nil:
    section.add "X-Amz-Algorithm", valid_774992
  var valid_774993 = header.getOrDefault("X-Amz-Signature")
  valid_774993 = validateParameter(valid_774993, JString, required = false,
                                 default = nil)
  if valid_774993 != nil:
    section.add "X-Amz-Signature", valid_774993
  var valid_774994 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_774994 = validateParameter(valid_774994, JString, required = false,
                                 default = nil)
  if valid_774994 != nil:
    section.add "X-Amz-SignedHeaders", valid_774994
  var valid_774995 = header.getOrDefault("X-Amz-Credential")
  valid_774995 = validateParameter(valid_774995, JString, required = false,
                                 default = nil)
  if valid_774995 != nil:
    section.add "X-Amz-Credential", valid_774995
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_774996: Call_ListAttachedPolicies_774982; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the policies attached to the specified thing group.
  ## 
  let valid = call_774996.validator(path, query, header, formData, body)
  let scheme = call_774996.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_774996.url(scheme.get, call_774996.host, call_774996.base,
                         call_774996.route, valid.getOrDefault("path"))
  result = hook(call_774996, url, valid)

proc call*(call_774997: Call_ListAttachedPolicies_774982; target: string;
          marker: string = ""; pageSize: int = 0; recursive: bool = false): Recallable =
  ## listAttachedPolicies
  ## Lists the policies attached to the specified thing group.
  ##   marker: string
  ##         : The token to retrieve the next set of results.
  ##   pageSize: int
  ##           : The maximum number of results to be returned per request.
  ##   recursive: bool
  ##            : When true, recursively list attached policies.
  ##   target: string (required)
  ##         : The group or principal for which the policies will be listed.
  var path_774998 = newJObject()
  var query_774999 = newJObject()
  add(query_774999, "marker", newJString(marker))
  add(query_774999, "pageSize", newJInt(pageSize))
  add(query_774999, "recursive", newJBool(recursive))
  add(path_774998, "target", newJString(target))
  result = call_774997.call(path_774998, query_774999, nil, nil, nil)

var listAttachedPolicies* = Call_ListAttachedPolicies_774982(
    name: "listAttachedPolicies", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/attached-policies/{target}",
    validator: validate_ListAttachedPolicies_774983, base: "/",
    url: url_ListAttachedPolicies_774984, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditFindings_775000 = ref object of OpenApiRestCall_772597
proc url_ListAuditFindings_775002(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListAuditFindings_775001(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775003 = header.getOrDefault("X-Amz-Date")
  valid_775003 = validateParameter(valid_775003, JString, required = false,
                                 default = nil)
  if valid_775003 != nil:
    section.add "X-Amz-Date", valid_775003
  var valid_775004 = header.getOrDefault("X-Amz-Security-Token")
  valid_775004 = validateParameter(valid_775004, JString, required = false,
                                 default = nil)
  if valid_775004 != nil:
    section.add "X-Amz-Security-Token", valid_775004
  var valid_775005 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775005 = validateParameter(valid_775005, JString, required = false,
                                 default = nil)
  if valid_775005 != nil:
    section.add "X-Amz-Content-Sha256", valid_775005
  var valid_775006 = header.getOrDefault("X-Amz-Algorithm")
  valid_775006 = validateParameter(valid_775006, JString, required = false,
                                 default = nil)
  if valid_775006 != nil:
    section.add "X-Amz-Algorithm", valid_775006
  var valid_775007 = header.getOrDefault("X-Amz-Signature")
  valid_775007 = validateParameter(valid_775007, JString, required = false,
                                 default = nil)
  if valid_775007 != nil:
    section.add "X-Amz-Signature", valid_775007
  var valid_775008 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775008 = validateParameter(valid_775008, JString, required = false,
                                 default = nil)
  if valid_775008 != nil:
    section.add "X-Amz-SignedHeaders", valid_775008
  var valid_775009 = header.getOrDefault("X-Amz-Credential")
  valid_775009 = validateParameter(valid_775009, JString, required = false,
                                 default = nil)
  if valid_775009 != nil:
    section.add "X-Amz-Credential", valid_775009
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775011: Call_ListAuditFindings_775000; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ## 
  let valid = call_775011.validator(path, query, header, formData, body)
  let scheme = call_775011.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775011.url(scheme.get, call_775011.host, call_775011.base,
                         call_775011.route, valid.getOrDefault("path"))
  result = hook(call_775011, url, valid)

proc call*(call_775012: Call_ListAuditFindings_775000; body: JsonNode): Recallable =
  ## listAuditFindings
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ##   body: JObject (required)
  var body_775013 = newJObject()
  if body != nil:
    body_775013 = body
  result = call_775012.call(nil, nil, nil, nil, body_775013)

var listAuditFindings* = Call_ListAuditFindings_775000(name: "listAuditFindings",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/audit/findings",
    validator: validate_ListAuditFindings_775001, base: "/",
    url: url_ListAuditFindings_775002, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditMitigationActionsExecutions_775014 = ref object of OpenApiRestCall_772597
proc url_ListAuditMitigationActionsExecutions_775016(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListAuditMitigationActionsExecutions_775015(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the status of audit mitigation action tasks that were executed.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   findingId: JString (required)
  ##            : Specify this filter to limit results to those that were applied to a specific audit finding.
  ##   taskId: JString (required)
  ##         : Specify this filter to limit results to actions for a specific audit mitigation actions task.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   actionStatus: JString
  ##               : Specify this filter to limit results to those with a specific status.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `findingId` field"
  var valid_775017 = query.getOrDefault("findingId")
  valid_775017 = validateParameter(valid_775017, JString, required = true,
                                 default = nil)
  if valid_775017 != nil:
    section.add "findingId", valid_775017
  var valid_775018 = query.getOrDefault("taskId")
  valid_775018 = validateParameter(valid_775018, JString, required = true,
                                 default = nil)
  if valid_775018 != nil:
    section.add "taskId", valid_775018
  var valid_775019 = query.getOrDefault("maxResults")
  valid_775019 = validateParameter(valid_775019, JInt, required = false, default = nil)
  if valid_775019 != nil:
    section.add "maxResults", valid_775019
  var valid_775020 = query.getOrDefault("nextToken")
  valid_775020 = validateParameter(valid_775020, JString, required = false,
                                 default = nil)
  if valid_775020 != nil:
    section.add "nextToken", valid_775020
  var valid_775021 = query.getOrDefault("actionStatus")
  valid_775021 = validateParameter(valid_775021, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_775021 != nil:
    section.add "actionStatus", valid_775021
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775022 = header.getOrDefault("X-Amz-Date")
  valid_775022 = validateParameter(valid_775022, JString, required = false,
                                 default = nil)
  if valid_775022 != nil:
    section.add "X-Amz-Date", valid_775022
  var valid_775023 = header.getOrDefault("X-Amz-Security-Token")
  valid_775023 = validateParameter(valid_775023, JString, required = false,
                                 default = nil)
  if valid_775023 != nil:
    section.add "X-Amz-Security-Token", valid_775023
  var valid_775024 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775024 = validateParameter(valid_775024, JString, required = false,
                                 default = nil)
  if valid_775024 != nil:
    section.add "X-Amz-Content-Sha256", valid_775024
  var valid_775025 = header.getOrDefault("X-Amz-Algorithm")
  valid_775025 = validateParameter(valid_775025, JString, required = false,
                                 default = nil)
  if valid_775025 != nil:
    section.add "X-Amz-Algorithm", valid_775025
  var valid_775026 = header.getOrDefault("X-Amz-Signature")
  valid_775026 = validateParameter(valid_775026, JString, required = false,
                                 default = nil)
  if valid_775026 != nil:
    section.add "X-Amz-Signature", valid_775026
  var valid_775027 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775027 = validateParameter(valid_775027, JString, required = false,
                                 default = nil)
  if valid_775027 != nil:
    section.add "X-Amz-SignedHeaders", valid_775027
  var valid_775028 = header.getOrDefault("X-Amz-Credential")
  valid_775028 = validateParameter(valid_775028, JString, required = false,
                                 default = nil)
  if valid_775028 != nil:
    section.add "X-Amz-Credential", valid_775028
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775029: Call_ListAuditMitigationActionsExecutions_775014;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the status of audit mitigation action tasks that were executed.
  ## 
  let valid = call_775029.validator(path, query, header, formData, body)
  let scheme = call_775029.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775029.url(scheme.get, call_775029.host, call_775029.base,
                         call_775029.route, valid.getOrDefault("path"))
  result = hook(call_775029, url, valid)

proc call*(call_775030: Call_ListAuditMitigationActionsExecutions_775014;
          findingId: string; taskId: string; maxResults: int = 0;
          nextToken: string = ""; actionStatus: string = "IN_PROGRESS"): Recallable =
  ## listAuditMitigationActionsExecutions
  ## Gets the status of audit mitigation action tasks that were executed.
  ##   findingId: string (required)
  ##            : Specify this filter to limit results to those that were applied to a specific audit finding.
  ##   taskId: string (required)
  ##         : Specify this filter to limit results to actions for a specific audit mitigation actions task.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   actionStatus: string
  ##               : Specify this filter to limit results to those with a specific status.
  var query_775031 = newJObject()
  add(query_775031, "findingId", newJString(findingId))
  add(query_775031, "taskId", newJString(taskId))
  add(query_775031, "maxResults", newJInt(maxResults))
  add(query_775031, "nextToken", newJString(nextToken))
  add(query_775031, "actionStatus", newJString(actionStatus))
  result = call_775030.call(nil, query_775031, nil, nil, nil)

var listAuditMitigationActionsExecutions* = Call_ListAuditMitigationActionsExecutions_775014(
    name: "listAuditMitigationActionsExecutions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/executions#taskId&findingId",
    validator: validate_ListAuditMitigationActionsExecutions_775015, base: "/",
    url: url_ListAuditMitigationActionsExecutions_775016,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditMitigationActionsTasks_775032 = ref object of OpenApiRestCall_772597
proc url_ListAuditMitigationActionsTasks_775034(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListAuditMitigationActionsTasks_775033(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   findingId: JString
  ##            : Specify this filter to limit results to tasks that were applied to a specific audit finding.
  ##   taskStatus: JString
  ##             : Specify this filter to limit results to tasks that are in a specific state.
  ##   auditTaskId: JString
  ##              : Specify this filter to limit results to tasks that were applied to results for a specific audit.
  ##   endTime: JString (required)
  ##          : Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : Specify this filter to limit results to tasks that began on or after a specific date and time.
  section = newJObject()
  var valid_775035 = query.getOrDefault("findingId")
  valid_775035 = validateParameter(valid_775035, JString, required = false,
                                 default = nil)
  if valid_775035 != nil:
    section.add "findingId", valid_775035
  var valid_775036 = query.getOrDefault("taskStatus")
  valid_775036 = validateParameter(valid_775036, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_775036 != nil:
    section.add "taskStatus", valid_775036
  var valid_775037 = query.getOrDefault("auditTaskId")
  valid_775037 = validateParameter(valid_775037, JString, required = false,
                                 default = nil)
  if valid_775037 != nil:
    section.add "auditTaskId", valid_775037
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_775038 = query.getOrDefault("endTime")
  valid_775038 = validateParameter(valid_775038, JString, required = true,
                                 default = nil)
  if valid_775038 != nil:
    section.add "endTime", valid_775038
  var valid_775039 = query.getOrDefault("maxResults")
  valid_775039 = validateParameter(valid_775039, JInt, required = false, default = nil)
  if valid_775039 != nil:
    section.add "maxResults", valid_775039
  var valid_775040 = query.getOrDefault("nextToken")
  valid_775040 = validateParameter(valid_775040, JString, required = false,
                                 default = nil)
  if valid_775040 != nil:
    section.add "nextToken", valid_775040
  var valid_775041 = query.getOrDefault("startTime")
  valid_775041 = validateParameter(valid_775041, JString, required = true,
                                 default = nil)
  if valid_775041 != nil:
    section.add "startTime", valid_775041
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775042 = header.getOrDefault("X-Amz-Date")
  valid_775042 = validateParameter(valid_775042, JString, required = false,
                                 default = nil)
  if valid_775042 != nil:
    section.add "X-Amz-Date", valid_775042
  var valid_775043 = header.getOrDefault("X-Amz-Security-Token")
  valid_775043 = validateParameter(valid_775043, JString, required = false,
                                 default = nil)
  if valid_775043 != nil:
    section.add "X-Amz-Security-Token", valid_775043
  var valid_775044 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775044 = validateParameter(valid_775044, JString, required = false,
                                 default = nil)
  if valid_775044 != nil:
    section.add "X-Amz-Content-Sha256", valid_775044
  var valid_775045 = header.getOrDefault("X-Amz-Algorithm")
  valid_775045 = validateParameter(valid_775045, JString, required = false,
                                 default = nil)
  if valid_775045 != nil:
    section.add "X-Amz-Algorithm", valid_775045
  var valid_775046 = header.getOrDefault("X-Amz-Signature")
  valid_775046 = validateParameter(valid_775046, JString, required = false,
                                 default = nil)
  if valid_775046 != nil:
    section.add "X-Amz-Signature", valid_775046
  var valid_775047 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775047 = validateParameter(valid_775047, JString, required = false,
                                 default = nil)
  if valid_775047 != nil:
    section.add "X-Amz-SignedHeaders", valid_775047
  var valid_775048 = header.getOrDefault("X-Amz-Credential")
  valid_775048 = validateParameter(valid_775048, JString, required = false,
                                 default = nil)
  if valid_775048 != nil:
    section.add "X-Amz-Credential", valid_775048
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775049: Call_ListAuditMitigationActionsTasks_775032;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ## 
  let valid = call_775049.validator(path, query, header, formData, body)
  let scheme = call_775049.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775049.url(scheme.get, call_775049.host, call_775049.base,
                         call_775049.route, valid.getOrDefault("path"))
  result = hook(call_775049, url, valid)

proc call*(call_775050: Call_ListAuditMitigationActionsTasks_775032;
          endTime: string; startTime: string; findingId: string = "";
          taskStatus: string = "IN_PROGRESS"; auditTaskId: string = "";
          maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listAuditMitigationActionsTasks
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ##   findingId: string
  ##            : Specify this filter to limit results to tasks that were applied to a specific audit finding.
  ##   taskStatus: string
  ##             : Specify this filter to limit results to tasks that are in a specific state.
  ##   auditTaskId: string
  ##              : Specify this filter to limit results to tasks that were applied to results for a specific audit.
  ##   endTime: string (required)
  ##          : Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : Specify this filter to limit results to tasks that began on or after a specific date and time.
  var query_775051 = newJObject()
  add(query_775051, "findingId", newJString(findingId))
  add(query_775051, "taskStatus", newJString(taskStatus))
  add(query_775051, "auditTaskId", newJString(auditTaskId))
  add(query_775051, "endTime", newJString(endTime))
  add(query_775051, "maxResults", newJInt(maxResults))
  add(query_775051, "nextToken", newJString(nextToken))
  add(query_775051, "startTime", newJString(startTime))
  result = call_775050.call(nil, query_775051, nil, nil, nil)

var listAuditMitigationActionsTasks* = Call_ListAuditMitigationActionsTasks_775032(
    name: "listAuditMitigationActionsTasks", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/tasks#startTime&endTime",
    validator: validate_ListAuditMitigationActionsTasks_775033, base: "/",
    url: url_ListAuditMitigationActionsTasks_775034,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditTasks_775052 = ref object of OpenApiRestCall_772597
proc url_ListAuditTasks_775054(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListAuditTasks_775053(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the Device Defender audits that have been performed during a given time period.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   taskType: JString
  ##           : A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
  ##   taskStatus: JString
  ##             : A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
  ##   endTime: JString (required)
  ##          : The end of the time period.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
  section = newJObject()
  var valid_775055 = query.getOrDefault("taskType")
  valid_775055 = validateParameter(valid_775055, JString, required = false,
                                 default = newJString("ON_DEMAND_AUDIT_TASK"))
  if valid_775055 != nil:
    section.add "taskType", valid_775055
  var valid_775056 = query.getOrDefault("taskStatus")
  valid_775056 = validateParameter(valid_775056, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_775056 != nil:
    section.add "taskStatus", valid_775056
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_775057 = query.getOrDefault("endTime")
  valid_775057 = validateParameter(valid_775057, JString, required = true,
                                 default = nil)
  if valid_775057 != nil:
    section.add "endTime", valid_775057
  var valid_775058 = query.getOrDefault("maxResults")
  valid_775058 = validateParameter(valid_775058, JInt, required = false, default = nil)
  if valid_775058 != nil:
    section.add "maxResults", valid_775058
  var valid_775059 = query.getOrDefault("nextToken")
  valid_775059 = validateParameter(valid_775059, JString, required = false,
                                 default = nil)
  if valid_775059 != nil:
    section.add "nextToken", valid_775059
  var valid_775060 = query.getOrDefault("startTime")
  valid_775060 = validateParameter(valid_775060, JString, required = true,
                                 default = nil)
  if valid_775060 != nil:
    section.add "startTime", valid_775060
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775061 = header.getOrDefault("X-Amz-Date")
  valid_775061 = validateParameter(valid_775061, JString, required = false,
                                 default = nil)
  if valid_775061 != nil:
    section.add "X-Amz-Date", valid_775061
  var valid_775062 = header.getOrDefault("X-Amz-Security-Token")
  valid_775062 = validateParameter(valid_775062, JString, required = false,
                                 default = nil)
  if valid_775062 != nil:
    section.add "X-Amz-Security-Token", valid_775062
  var valid_775063 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775063 = validateParameter(valid_775063, JString, required = false,
                                 default = nil)
  if valid_775063 != nil:
    section.add "X-Amz-Content-Sha256", valid_775063
  var valid_775064 = header.getOrDefault("X-Amz-Algorithm")
  valid_775064 = validateParameter(valid_775064, JString, required = false,
                                 default = nil)
  if valid_775064 != nil:
    section.add "X-Amz-Algorithm", valid_775064
  var valid_775065 = header.getOrDefault("X-Amz-Signature")
  valid_775065 = validateParameter(valid_775065, JString, required = false,
                                 default = nil)
  if valid_775065 != nil:
    section.add "X-Amz-Signature", valid_775065
  var valid_775066 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775066 = validateParameter(valid_775066, JString, required = false,
                                 default = nil)
  if valid_775066 != nil:
    section.add "X-Amz-SignedHeaders", valid_775066
  var valid_775067 = header.getOrDefault("X-Amz-Credential")
  valid_775067 = validateParameter(valid_775067, JString, required = false,
                                 default = nil)
  if valid_775067 != nil:
    section.add "X-Amz-Credential", valid_775067
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775068: Call_ListAuditTasks_775052; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender audits that have been performed during a given time period.
  ## 
  let valid = call_775068.validator(path, query, header, formData, body)
  let scheme = call_775068.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775068.url(scheme.get, call_775068.host, call_775068.base,
                         call_775068.route, valid.getOrDefault("path"))
  result = hook(call_775068, url, valid)

proc call*(call_775069: Call_ListAuditTasks_775052; endTime: string;
          startTime: string; taskType: string = "ON_DEMAND_AUDIT_TASK";
          taskStatus: string = "IN_PROGRESS"; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listAuditTasks
  ## Lists the Device Defender audits that have been performed during a given time period.
  ##   taskType: string
  ##           : A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
  ##   taskStatus: string
  ##             : A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
  ##   endTime: string (required)
  ##          : The end of the time period.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
  var query_775070 = newJObject()
  add(query_775070, "taskType", newJString(taskType))
  add(query_775070, "taskStatus", newJString(taskStatus))
  add(query_775070, "endTime", newJString(endTime))
  add(query_775070, "maxResults", newJInt(maxResults))
  add(query_775070, "nextToken", newJString(nextToken))
  add(query_775070, "startTime", newJString(startTime))
  result = call_775069.call(nil, query_775070, nil, nil, nil)

var listAuditTasks* = Call_ListAuditTasks_775052(name: "listAuditTasks",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/audit/tasks#startTime&endTime", validator: validate_ListAuditTasks_775053,
    base: "/", url: url_ListAuditTasks_775054, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuthorizers_775071 = ref object of OpenApiRestCall_772597
proc url_ListAuthorizers_775073(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListAuthorizers_775072(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Lists the authorizers registered in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   status: JString
  ##         : The status of the list authorizers request.
  ##   isAscendingOrder: JBool
  ##                   : Return the list of authorizers in ascending alphabetical order.
  section = newJObject()
  var valid_775074 = query.getOrDefault("marker")
  valid_775074 = validateParameter(valid_775074, JString, required = false,
                                 default = nil)
  if valid_775074 != nil:
    section.add "marker", valid_775074
  var valid_775075 = query.getOrDefault("pageSize")
  valid_775075 = validateParameter(valid_775075, JInt, required = false, default = nil)
  if valid_775075 != nil:
    section.add "pageSize", valid_775075
  var valid_775076 = query.getOrDefault("status")
  valid_775076 = validateParameter(valid_775076, JString, required = false,
                                 default = newJString("ACTIVE"))
  if valid_775076 != nil:
    section.add "status", valid_775076
  var valid_775077 = query.getOrDefault("isAscendingOrder")
  valid_775077 = validateParameter(valid_775077, JBool, required = false, default = nil)
  if valid_775077 != nil:
    section.add "isAscendingOrder", valid_775077
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775078 = header.getOrDefault("X-Amz-Date")
  valid_775078 = validateParameter(valid_775078, JString, required = false,
                                 default = nil)
  if valid_775078 != nil:
    section.add "X-Amz-Date", valid_775078
  var valid_775079 = header.getOrDefault("X-Amz-Security-Token")
  valid_775079 = validateParameter(valid_775079, JString, required = false,
                                 default = nil)
  if valid_775079 != nil:
    section.add "X-Amz-Security-Token", valid_775079
  var valid_775080 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775080 = validateParameter(valid_775080, JString, required = false,
                                 default = nil)
  if valid_775080 != nil:
    section.add "X-Amz-Content-Sha256", valid_775080
  var valid_775081 = header.getOrDefault("X-Amz-Algorithm")
  valid_775081 = validateParameter(valid_775081, JString, required = false,
                                 default = nil)
  if valid_775081 != nil:
    section.add "X-Amz-Algorithm", valid_775081
  var valid_775082 = header.getOrDefault("X-Amz-Signature")
  valid_775082 = validateParameter(valid_775082, JString, required = false,
                                 default = nil)
  if valid_775082 != nil:
    section.add "X-Amz-Signature", valid_775082
  var valid_775083 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775083 = validateParameter(valid_775083, JString, required = false,
                                 default = nil)
  if valid_775083 != nil:
    section.add "X-Amz-SignedHeaders", valid_775083
  var valid_775084 = header.getOrDefault("X-Amz-Credential")
  valid_775084 = validateParameter(valid_775084, JString, required = false,
                                 default = nil)
  if valid_775084 != nil:
    section.add "X-Amz-Credential", valid_775084
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775085: Call_ListAuthorizers_775071; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the authorizers registered in your account.
  ## 
  let valid = call_775085.validator(path, query, header, formData, body)
  let scheme = call_775085.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775085.url(scheme.get, call_775085.host, call_775085.base,
                         call_775085.route, valid.getOrDefault("path"))
  result = hook(call_775085, url, valid)

proc call*(call_775086: Call_ListAuthorizers_775071; marker: string = "";
          pageSize: int = 0; status: string = "ACTIVE"; isAscendingOrder: bool = false): Recallable =
  ## listAuthorizers
  ## Lists the authorizers registered in your account.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   status: string
  ##         : The status of the list authorizers request.
  ##   isAscendingOrder: bool
  ##                   : Return the list of authorizers in ascending alphabetical order.
  var query_775087 = newJObject()
  add(query_775087, "marker", newJString(marker))
  add(query_775087, "pageSize", newJInt(pageSize))
  add(query_775087, "status", newJString(status))
  add(query_775087, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_775086.call(nil, query_775087, nil, nil, nil)

var listAuthorizers* = Call_ListAuthorizers_775071(name: "listAuthorizers",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/authorizers/",
    validator: validate_ListAuthorizers_775072, base: "/", url: url_ListAuthorizers_775073,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListBillingGroups_775088 = ref object of OpenApiRestCall_772597
proc url_ListBillingGroups_775090(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListBillingGroups_775089(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Lists the billing groups you have created.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   namePrefixFilter: JString
  ##                   : Limit the results to billing groups whose names have the given prefix.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  var valid_775091 = query.getOrDefault("namePrefixFilter")
  valid_775091 = validateParameter(valid_775091, JString, required = false,
                                 default = nil)
  if valid_775091 != nil:
    section.add "namePrefixFilter", valid_775091
  var valid_775092 = query.getOrDefault("maxResults")
  valid_775092 = validateParameter(valid_775092, JInt, required = false, default = nil)
  if valid_775092 != nil:
    section.add "maxResults", valid_775092
  var valid_775093 = query.getOrDefault("nextToken")
  valid_775093 = validateParameter(valid_775093, JString, required = false,
                                 default = nil)
  if valid_775093 != nil:
    section.add "nextToken", valid_775093
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775094 = header.getOrDefault("X-Amz-Date")
  valid_775094 = validateParameter(valid_775094, JString, required = false,
                                 default = nil)
  if valid_775094 != nil:
    section.add "X-Amz-Date", valid_775094
  var valid_775095 = header.getOrDefault("X-Amz-Security-Token")
  valid_775095 = validateParameter(valid_775095, JString, required = false,
                                 default = nil)
  if valid_775095 != nil:
    section.add "X-Amz-Security-Token", valid_775095
  var valid_775096 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775096 = validateParameter(valid_775096, JString, required = false,
                                 default = nil)
  if valid_775096 != nil:
    section.add "X-Amz-Content-Sha256", valid_775096
  var valid_775097 = header.getOrDefault("X-Amz-Algorithm")
  valid_775097 = validateParameter(valid_775097, JString, required = false,
                                 default = nil)
  if valid_775097 != nil:
    section.add "X-Amz-Algorithm", valid_775097
  var valid_775098 = header.getOrDefault("X-Amz-Signature")
  valid_775098 = validateParameter(valid_775098, JString, required = false,
                                 default = nil)
  if valid_775098 != nil:
    section.add "X-Amz-Signature", valid_775098
  var valid_775099 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775099 = validateParameter(valid_775099, JString, required = false,
                                 default = nil)
  if valid_775099 != nil:
    section.add "X-Amz-SignedHeaders", valid_775099
  var valid_775100 = header.getOrDefault("X-Amz-Credential")
  valid_775100 = validateParameter(valid_775100, JString, required = false,
                                 default = nil)
  if valid_775100 != nil:
    section.add "X-Amz-Credential", valid_775100
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775101: Call_ListBillingGroups_775088; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the billing groups you have created.
  ## 
  let valid = call_775101.validator(path, query, header, formData, body)
  let scheme = call_775101.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775101.url(scheme.get, call_775101.host, call_775101.base,
                         call_775101.route, valid.getOrDefault("path"))
  result = hook(call_775101, url, valid)

proc call*(call_775102: Call_ListBillingGroups_775088;
          namePrefixFilter: string = ""; maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listBillingGroups
  ## Lists the billing groups you have created.
  ##   namePrefixFilter: string
  ##                   : Limit the results to billing groups whose names have the given prefix.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var query_775103 = newJObject()
  add(query_775103, "namePrefixFilter", newJString(namePrefixFilter))
  add(query_775103, "maxResults", newJInt(maxResults))
  add(query_775103, "nextToken", newJString(nextToken))
  result = call_775102.call(nil, query_775103, nil, nil, nil)

var listBillingGroups* = Call_ListBillingGroups_775088(name: "listBillingGroups",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/billing-groups",
    validator: validate_ListBillingGroups_775089, base: "/",
    url: url_ListBillingGroups_775090, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCACertificates_775104 = ref object of OpenApiRestCall_772597
proc url_ListCACertificates_775106(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListCACertificates_775105(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Determines the order of the results.
  section = newJObject()
  var valid_775107 = query.getOrDefault("marker")
  valid_775107 = validateParameter(valid_775107, JString, required = false,
                                 default = nil)
  if valid_775107 != nil:
    section.add "marker", valid_775107
  var valid_775108 = query.getOrDefault("pageSize")
  valid_775108 = validateParameter(valid_775108, JInt, required = false, default = nil)
  if valid_775108 != nil:
    section.add "pageSize", valid_775108
  var valid_775109 = query.getOrDefault("isAscendingOrder")
  valid_775109 = validateParameter(valid_775109, JBool, required = false, default = nil)
  if valid_775109 != nil:
    section.add "isAscendingOrder", valid_775109
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775110 = header.getOrDefault("X-Amz-Date")
  valid_775110 = validateParameter(valid_775110, JString, required = false,
                                 default = nil)
  if valid_775110 != nil:
    section.add "X-Amz-Date", valid_775110
  var valid_775111 = header.getOrDefault("X-Amz-Security-Token")
  valid_775111 = validateParameter(valid_775111, JString, required = false,
                                 default = nil)
  if valid_775111 != nil:
    section.add "X-Amz-Security-Token", valid_775111
  var valid_775112 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775112 = validateParameter(valid_775112, JString, required = false,
                                 default = nil)
  if valid_775112 != nil:
    section.add "X-Amz-Content-Sha256", valid_775112
  var valid_775113 = header.getOrDefault("X-Amz-Algorithm")
  valid_775113 = validateParameter(valid_775113, JString, required = false,
                                 default = nil)
  if valid_775113 != nil:
    section.add "X-Amz-Algorithm", valid_775113
  var valid_775114 = header.getOrDefault("X-Amz-Signature")
  valid_775114 = validateParameter(valid_775114, JString, required = false,
                                 default = nil)
  if valid_775114 != nil:
    section.add "X-Amz-Signature", valid_775114
  var valid_775115 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775115 = validateParameter(valid_775115, JString, required = false,
                                 default = nil)
  if valid_775115 != nil:
    section.add "X-Amz-SignedHeaders", valid_775115
  var valid_775116 = header.getOrDefault("X-Amz-Credential")
  valid_775116 = validateParameter(valid_775116, JString, required = false,
                                 default = nil)
  if valid_775116 != nil:
    section.add "X-Amz-Credential", valid_775116
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775117: Call_ListCACertificates_775104; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  let valid = call_775117.validator(path, query, header, formData, body)
  let scheme = call_775117.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775117.url(scheme.get, call_775117.host, call_775117.base,
                         call_775117.route, valid.getOrDefault("path"))
  result = hook(call_775117, url, valid)

proc call*(call_775118: Call_ListCACertificates_775104; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listCACertificates
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Determines the order of the results.
  var query_775119 = newJObject()
  add(query_775119, "marker", newJString(marker))
  add(query_775119, "pageSize", newJInt(pageSize))
  add(query_775119, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_775118.call(nil, query_775119, nil, nil, nil)

var listCACertificates* = Call_ListCACertificates_775104(
    name: "listCACertificates", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/cacertificates", validator: validate_ListCACertificates_775105,
    base: "/", url: url_ListCACertificates_775106,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCertificatesByCA_775120 = ref object of OpenApiRestCall_772597
proc url_ListCertificatesByCA_775122(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates-by-ca/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_ListCertificatesByCA_775121(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List the device certificates signed by the specified CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_775123 = path.getOrDefault("caCertificateId")
  valid_775123 = validateParameter(valid_775123, JString, required = true,
                                 default = nil)
  if valid_775123 != nil:
    section.add "caCertificateId", valid_775123
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  section = newJObject()
  var valid_775124 = query.getOrDefault("marker")
  valid_775124 = validateParameter(valid_775124, JString, required = false,
                                 default = nil)
  if valid_775124 != nil:
    section.add "marker", valid_775124
  var valid_775125 = query.getOrDefault("pageSize")
  valid_775125 = validateParameter(valid_775125, JInt, required = false, default = nil)
  if valid_775125 != nil:
    section.add "pageSize", valid_775125
  var valid_775126 = query.getOrDefault("isAscendingOrder")
  valid_775126 = validateParameter(valid_775126, JBool, required = false, default = nil)
  if valid_775126 != nil:
    section.add "isAscendingOrder", valid_775126
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775127 = header.getOrDefault("X-Amz-Date")
  valid_775127 = validateParameter(valid_775127, JString, required = false,
                                 default = nil)
  if valid_775127 != nil:
    section.add "X-Amz-Date", valid_775127
  var valid_775128 = header.getOrDefault("X-Amz-Security-Token")
  valid_775128 = validateParameter(valid_775128, JString, required = false,
                                 default = nil)
  if valid_775128 != nil:
    section.add "X-Amz-Security-Token", valid_775128
  var valid_775129 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775129 = validateParameter(valid_775129, JString, required = false,
                                 default = nil)
  if valid_775129 != nil:
    section.add "X-Amz-Content-Sha256", valid_775129
  var valid_775130 = header.getOrDefault("X-Amz-Algorithm")
  valid_775130 = validateParameter(valid_775130, JString, required = false,
                                 default = nil)
  if valid_775130 != nil:
    section.add "X-Amz-Algorithm", valid_775130
  var valid_775131 = header.getOrDefault("X-Amz-Signature")
  valid_775131 = validateParameter(valid_775131, JString, required = false,
                                 default = nil)
  if valid_775131 != nil:
    section.add "X-Amz-Signature", valid_775131
  var valid_775132 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775132 = validateParameter(valid_775132, JString, required = false,
                                 default = nil)
  if valid_775132 != nil:
    section.add "X-Amz-SignedHeaders", valid_775132
  var valid_775133 = header.getOrDefault("X-Amz-Credential")
  valid_775133 = validateParameter(valid_775133, JString, required = false,
                                 default = nil)
  if valid_775133 != nil:
    section.add "X-Amz-Credential", valid_775133
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775134: Call_ListCertificatesByCA_775120; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the device certificates signed by the specified CA certificate.
  ## 
  let valid = call_775134.validator(path, query, header, formData, body)
  let scheme = call_775134.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775134.url(scheme.get, call_775134.host, call_775134.base,
                         call_775134.route, valid.getOrDefault("path"))
  result = hook(call_775134, url, valid)

proc call*(call_775135: Call_ListCertificatesByCA_775120; caCertificateId: string;
          marker: string = ""; pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listCertificatesByCA
  ## List the device certificates signed by the specified CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  var path_775136 = newJObject()
  var query_775137 = newJObject()
  add(path_775136, "caCertificateId", newJString(caCertificateId))
  add(query_775137, "marker", newJString(marker))
  add(query_775137, "pageSize", newJInt(pageSize))
  add(query_775137, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_775135.call(path_775136, query_775137, nil, nil, nil)

var listCertificatesByCA* = Call_ListCertificatesByCA_775120(
    name: "listCertificatesByCA", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates-by-ca/{caCertificateId}",
    validator: validate_ListCertificatesByCA_775121, base: "/",
    url: url_ListCertificatesByCA_775122, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListIndices_775138 = ref object of OpenApiRestCall_772597
proc url_ListIndices_775140(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListIndices_775139(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the search indices.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token used to get the next set of results, or null if there are no additional results.
  section = newJObject()
  var valid_775141 = query.getOrDefault("maxResults")
  valid_775141 = validateParameter(valid_775141, JInt, required = false, default = nil)
  if valid_775141 != nil:
    section.add "maxResults", valid_775141
  var valid_775142 = query.getOrDefault("nextToken")
  valid_775142 = validateParameter(valid_775142, JString, required = false,
                                 default = nil)
  if valid_775142 != nil:
    section.add "nextToken", valid_775142
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775143 = header.getOrDefault("X-Amz-Date")
  valid_775143 = validateParameter(valid_775143, JString, required = false,
                                 default = nil)
  if valid_775143 != nil:
    section.add "X-Amz-Date", valid_775143
  var valid_775144 = header.getOrDefault("X-Amz-Security-Token")
  valid_775144 = validateParameter(valid_775144, JString, required = false,
                                 default = nil)
  if valid_775144 != nil:
    section.add "X-Amz-Security-Token", valid_775144
  var valid_775145 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775145 = validateParameter(valid_775145, JString, required = false,
                                 default = nil)
  if valid_775145 != nil:
    section.add "X-Amz-Content-Sha256", valid_775145
  var valid_775146 = header.getOrDefault("X-Amz-Algorithm")
  valid_775146 = validateParameter(valid_775146, JString, required = false,
                                 default = nil)
  if valid_775146 != nil:
    section.add "X-Amz-Algorithm", valid_775146
  var valid_775147 = header.getOrDefault("X-Amz-Signature")
  valid_775147 = validateParameter(valid_775147, JString, required = false,
                                 default = nil)
  if valid_775147 != nil:
    section.add "X-Amz-Signature", valid_775147
  var valid_775148 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775148 = validateParameter(valid_775148, JString, required = false,
                                 default = nil)
  if valid_775148 != nil:
    section.add "X-Amz-SignedHeaders", valid_775148
  var valid_775149 = header.getOrDefault("X-Amz-Credential")
  valid_775149 = validateParameter(valid_775149, JString, required = false,
                                 default = nil)
  if valid_775149 != nil:
    section.add "X-Amz-Credential", valid_775149
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775150: Call_ListIndices_775138; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the search indices.
  ## 
  let valid = call_775150.validator(path, query, header, formData, body)
  let scheme = call_775150.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775150.url(scheme.get, call_775150.host, call_775150.base,
                         call_775150.route, valid.getOrDefault("path"))
  result = hook(call_775150, url, valid)

proc call*(call_775151: Call_ListIndices_775138; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listIndices
  ## Lists the search indices.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token used to get the next set of results, or null if there are no additional results.
  var query_775152 = newJObject()
  add(query_775152, "maxResults", newJInt(maxResults))
  add(query_775152, "nextToken", newJString(nextToken))
  result = call_775151.call(nil, query_775152, nil, nil, nil)

var listIndices* = Call_ListIndices_775138(name: "listIndices",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/indices",
                                        validator: validate_ListIndices_775139,
                                        base: "/", url: url_ListIndices_775140,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobExecutionsForJob_775153 = ref object of OpenApiRestCall_772597
proc url_ListJobExecutionsForJob_775155(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_ListJobExecutionsForJob_775154(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the job executions for a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_775156 = path.getOrDefault("jobId")
  valid_775156 = validateParameter(valid_775156, JString, required = true,
                                 default = nil)
  if valid_775156 != nil:
    section.add "jobId", valid_775156
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to be returned per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : The status of the job.
  section = newJObject()
  var valid_775157 = query.getOrDefault("maxResults")
  valid_775157 = validateParameter(valid_775157, JInt, required = false, default = nil)
  if valid_775157 != nil:
    section.add "maxResults", valid_775157
  var valid_775158 = query.getOrDefault("nextToken")
  valid_775158 = validateParameter(valid_775158, JString, required = false,
                                 default = nil)
  if valid_775158 != nil:
    section.add "nextToken", valid_775158
  var valid_775159 = query.getOrDefault("status")
  valid_775159 = validateParameter(valid_775159, JString, required = false,
                                 default = newJString("QUEUED"))
  if valid_775159 != nil:
    section.add "status", valid_775159
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775160 = header.getOrDefault("X-Amz-Date")
  valid_775160 = validateParameter(valid_775160, JString, required = false,
                                 default = nil)
  if valid_775160 != nil:
    section.add "X-Amz-Date", valid_775160
  var valid_775161 = header.getOrDefault("X-Amz-Security-Token")
  valid_775161 = validateParameter(valid_775161, JString, required = false,
                                 default = nil)
  if valid_775161 != nil:
    section.add "X-Amz-Security-Token", valid_775161
  var valid_775162 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775162 = validateParameter(valid_775162, JString, required = false,
                                 default = nil)
  if valid_775162 != nil:
    section.add "X-Amz-Content-Sha256", valid_775162
  var valid_775163 = header.getOrDefault("X-Amz-Algorithm")
  valid_775163 = validateParameter(valid_775163, JString, required = false,
                                 default = nil)
  if valid_775163 != nil:
    section.add "X-Amz-Algorithm", valid_775163
  var valid_775164 = header.getOrDefault("X-Amz-Signature")
  valid_775164 = validateParameter(valid_775164, JString, required = false,
                                 default = nil)
  if valid_775164 != nil:
    section.add "X-Amz-Signature", valid_775164
  var valid_775165 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775165 = validateParameter(valid_775165, JString, required = false,
                                 default = nil)
  if valid_775165 != nil:
    section.add "X-Amz-SignedHeaders", valid_775165
  var valid_775166 = header.getOrDefault("X-Amz-Credential")
  valid_775166 = validateParameter(valid_775166, JString, required = false,
                                 default = nil)
  if valid_775166 != nil:
    section.add "X-Amz-Credential", valid_775166
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775167: Call_ListJobExecutionsForJob_775153; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the job executions for a job.
  ## 
  let valid = call_775167.validator(path, query, header, formData, body)
  let scheme = call_775167.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775167.url(scheme.get, call_775167.host, call_775167.base,
                         call_775167.route, valid.getOrDefault("path"))
  result = hook(call_775167, url, valid)

proc call*(call_775168: Call_ListJobExecutionsForJob_775153; jobId: string;
          maxResults: int = 0; nextToken: string = ""; status: string = "QUEUED"): Recallable =
  ## listJobExecutionsForJob
  ## Lists the job executions for a job.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   maxResults: int
  ##             : The maximum number of results to be returned per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : The status of the job.
  var path_775169 = newJObject()
  var query_775170 = newJObject()
  add(path_775169, "jobId", newJString(jobId))
  add(query_775170, "maxResults", newJInt(maxResults))
  add(query_775170, "nextToken", newJString(nextToken))
  add(query_775170, "status", newJString(status))
  result = call_775168.call(path_775169, query_775170, nil, nil, nil)

var listJobExecutionsForJob* = Call_ListJobExecutionsForJob_775153(
    name: "listJobExecutionsForJob", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/jobs/{jobId}/things",
    validator: validate_ListJobExecutionsForJob_775154, base: "/",
    url: url_ListJobExecutionsForJob_775155, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobExecutionsForThing_775171 = ref object of OpenApiRestCall_772597
proc url_ListJobExecutionsForThing_775173(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_ListJobExecutionsForThing_775172(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the job executions for the specified thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The thing name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_775174 = path.getOrDefault("thingName")
  valid_775174 = validateParameter(valid_775174, JString, required = true,
                                 default = nil)
  if valid_775174 != nil:
    section.add "thingName", valid_775174
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to be returned per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : An optional filter that lets you search for jobs that have the specified status.
  section = newJObject()
  var valid_775175 = query.getOrDefault("maxResults")
  valid_775175 = validateParameter(valid_775175, JInt, required = false, default = nil)
  if valid_775175 != nil:
    section.add "maxResults", valid_775175
  var valid_775176 = query.getOrDefault("nextToken")
  valid_775176 = validateParameter(valid_775176, JString, required = false,
                                 default = nil)
  if valid_775176 != nil:
    section.add "nextToken", valid_775176
  var valid_775177 = query.getOrDefault("status")
  valid_775177 = validateParameter(valid_775177, JString, required = false,
                                 default = newJString("QUEUED"))
  if valid_775177 != nil:
    section.add "status", valid_775177
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775178 = header.getOrDefault("X-Amz-Date")
  valid_775178 = validateParameter(valid_775178, JString, required = false,
                                 default = nil)
  if valid_775178 != nil:
    section.add "X-Amz-Date", valid_775178
  var valid_775179 = header.getOrDefault("X-Amz-Security-Token")
  valid_775179 = validateParameter(valid_775179, JString, required = false,
                                 default = nil)
  if valid_775179 != nil:
    section.add "X-Amz-Security-Token", valid_775179
  var valid_775180 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775180 = validateParameter(valid_775180, JString, required = false,
                                 default = nil)
  if valid_775180 != nil:
    section.add "X-Amz-Content-Sha256", valid_775180
  var valid_775181 = header.getOrDefault("X-Amz-Algorithm")
  valid_775181 = validateParameter(valid_775181, JString, required = false,
                                 default = nil)
  if valid_775181 != nil:
    section.add "X-Amz-Algorithm", valid_775181
  var valid_775182 = header.getOrDefault("X-Amz-Signature")
  valid_775182 = validateParameter(valid_775182, JString, required = false,
                                 default = nil)
  if valid_775182 != nil:
    section.add "X-Amz-Signature", valid_775182
  var valid_775183 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775183 = validateParameter(valid_775183, JString, required = false,
                                 default = nil)
  if valid_775183 != nil:
    section.add "X-Amz-SignedHeaders", valid_775183
  var valid_775184 = header.getOrDefault("X-Amz-Credential")
  valid_775184 = validateParameter(valid_775184, JString, required = false,
                                 default = nil)
  if valid_775184 != nil:
    section.add "X-Amz-Credential", valid_775184
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775185: Call_ListJobExecutionsForThing_775171; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the job executions for the specified thing.
  ## 
  let valid = call_775185.validator(path, query, header, formData, body)
  let scheme = call_775185.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775185.url(scheme.get, call_775185.host, call_775185.base,
                         call_775185.route, valid.getOrDefault("path"))
  result = hook(call_775185, url, valid)

proc call*(call_775186: Call_ListJobExecutionsForThing_775171; thingName: string;
          maxResults: int = 0; nextToken: string = ""; status: string = "QUEUED"): Recallable =
  ## listJobExecutionsForThing
  ## Lists the job executions for the specified thing.
  ##   thingName: string (required)
  ##            : The thing name.
  ##   maxResults: int
  ##             : The maximum number of results to be returned per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : An optional filter that lets you search for jobs that have the specified status.
  var path_775187 = newJObject()
  var query_775188 = newJObject()
  add(path_775187, "thingName", newJString(thingName))
  add(query_775188, "maxResults", newJInt(maxResults))
  add(query_775188, "nextToken", newJString(nextToken))
  add(query_775188, "status", newJString(status))
  result = call_775186.call(path_775187, query_775188, nil, nil, nil)

var listJobExecutionsForThing* = Call_ListJobExecutionsForThing_775171(
    name: "listJobExecutionsForThing", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs",
    validator: validate_ListJobExecutionsForThing_775172, base: "/",
    url: url_ListJobExecutionsForThing_775173,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobs_775189 = ref object of OpenApiRestCall_772597
proc url_ListJobs_775191(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListJobs_775190(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists jobs.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingGroupName: JString
  ##                 : A filter that limits the returned jobs to those for the specified group.
  ##   targetSelection: JString
  ##                  : Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. 
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   thingGroupId: JString
  ##               : A filter that limits the returned jobs to those for the specified group.
  section = newJObject()
  var valid_775192 = query.getOrDefault("thingGroupName")
  valid_775192 = validateParameter(valid_775192, JString, required = false,
                                 default = nil)
  if valid_775192 != nil:
    section.add "thingGroupName", valid_775192
  var valid_775193 = query.getOrDefault("targetSelection")
  valid_775193 = validateParameter(valid_775193, JString, required = false,
                                 default = newJString("CONTINUOUS"))
  if valid_775193 != nil:
    section.add "targetSelection", valid_775193
  var valid_775194 = query.getOrDefault("maxResults")
  valid_775194 = validateParameter(valid_775194, JInt, required = false, default = nil)
  if valid_775194 != nil:
    section.add "maxResults", valid_775194
  var valid_775195 = query.getOrDefault("nextToken")
  valid_775195 = validateParameter(valid_775195, JString, required = false,
                                 default = nil)
  if valid_775195 != nil:
    section.add "nextToken", valid_775195
  var valid_775196 = query.getOrDefault("status")
  valid_775196 = validateParameter(valid_775196, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_775196 != nil:
    section.add "status", valid_775196
  var valid_775197 = query.getOrDefault("thingGroupId")
  valid_775197 = validateParameter(valid_775197, JString, required = false,
                                 default = nil)
  if valid_775197 != nil:
    section.add "thingGroupId", valid_775197
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775198 = header.getOrDefault("X-Amz-Date")
  valid_775198 = validateParameter(valid_775198, JString, required = false,
                                 default = nil)
  if valid_775198 != nil:
    section.add "X-Amz-Date", valid_775198
  var valid_775199 = header.getOrDefault("X-Amz-Security-Token")
  valid_775199 = validateParameter(valid_775199, JString, required = false,
                                 default = nil)
  if valid_775199 != nil:
    section.add "X-Amz-Security-Token", valid_775199
  var valid_775200 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775200 = validateParameter(valid_775200, JString, required = false,
                                 default = nil)
  if valid_775200 != nil:
    section.add "X-Amz-Content-Sha256", valid_775200
  var valid_775201 = header.getOrDefault("X-Amz-Algorithm")
  valid_775201 = validateParameter(valid_775201, JString, required = false,
                                 default = nil)
  if valid_775201 != nil:
    section.add "X-Amz-Algorithm", valid_775201
  var valid_775202 = header.getOrDefault("X-Amz-Signature")
  valid_775202 = validateParameter(valid_775202, JString, required = false,
                                 default = nil)
  if valid_775202 != nil:
    section.add "X-Amz-Signature", valid_775202
  var valid_775203 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775203 = validateParameter(valid_775203, JString, required = false,
                                 default = nil)
  if valid_775203 != nil:
    section.add "X-Amz-SignedHeaders", valid_775203
  var valid_775204 = header.getOrDefault("X-Amz-Credential")
  valid_775204 = validateParameter(valid_775204, JString, required = false,
                                 default = nil)
  if valid_775204 != nil:
    section.add "X-Amz-Credential", valid_775204
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775205: Call_ListJobs_775189; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists jobs.
  ## 
  let valid = call_775205.validator(path, query, header, formData, body)
  let scheme = call_775205.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775205.url(scheme.get, call_775205.host, call_775205.base,
                         call_775205.route, valid.getOrDefault("path"))
  result = hook(call_775205, url, valid)

proc call*(call_775206: Call_ListJobs_775189; thingGroupName: string = "";
          targetSelection: string = "CONTINUOUS"; maxResults: int = 0;
          nextToken: string = ""; status: string = "IN_PROGRESS";
          thingGroupId: string = ""): Recallable =
  ## listJobs
  ## Lists jobs.
  ##   thingGroupName: string
  ##                 : A filter that limits the returned jobs to those for the specified group.
  ##   targetSelection: string
  ##                  : Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. 
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   thingGroupId: string
  ##               : A filter that limits the returned jobs to those for the specified group.
  var query_775207 = newJObject()
  add(query_775207, "thingGroupName", newJString(thingGroupName))
  add(query_775207, "targetSelection", newJString(targetSelection))
  add(query_775207, "maxResults", newJInt(maxResults))
  add(query_775207, "nextToken", newJString(nextToken))
  add(query_775207, "status", newJString(status))
  add(query_775207, "thingGroupId", newJString(thingGroupId))
  result = call_775206.call(nil, query_775207, nil, nil, nil)

var listJobs* = Call_ListJobs_775189(name: "listJobs", meth: HttpMethod.HttpGet,
                                  host: "iot.amazonaws.com", route: "/jobs",
                                  validator: validate_ListJobs_775190, base: "/",
                                  url: url_ListJobs_775191,
                                  schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListMitigationActions_775208 = ref object of OpenApiRestCall_772597
proc url_ListMitigationActions_775210(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListMitigationActions_775209(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   actionType: JString
  ##             : Specify a value to limit the result to mitigation actions with a specific action type.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  section = newJObject()
  var valid_775211 = query.getOrDefault("actionType")
  valid_775211 = validateParameter(valid_775211, JString, required = false, default = newJString(
      "UPDATE_DEVICE_CERTIFICATE"))
  if valid_775211 != nil:
    section.add "actionType", valid_775211
  var valid_775212 = query.getOrDefault("maxResults")
  valid_775212 = validateParameter(valid_775212, JInt, required = false, default = nil)
  if valid_775212 != nil:
    section.add "maxResults", valid_775212
  var valid_775213 = query.getOrDefault("nextToken")
  valid_775213 = validateParameter(valid_775213, JString, required = false,
                                 default = nil)
  if valid_775213 != nil:
    section.add "nextToken", valid_775213
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775214 = header.getOrDefault("X-Amz-Date")
  valid_775214 = validateParameter(valid_775214, JString, required = false,
                                 default = nil)
  if valid_775214 != nil:
    section.add "X-Amz-Date", valid_775214
  var valid_775215 = header.getOrDefault("X-Amz-Security-Token")
  valid_775215 = validateParameter(valid_775215, JString, required = false,
                                 default = nil)
  if valid_775215 != nil:
    section.add "X-Amz-Security-Token", valid_775215
  var valid_775216 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775216 = validateParameter(valid_775216, JString, required = false,
                                 default = nil)
  if valid_775216 != nil:
    section.add "X-Amz-Content-Sha256", valid_775216
  var valid_775217 = header.getOrDefault("X-Amz-Algorithm")
  valid_775217 = validateParameter(valid_775217, JString, required = false,
                                 default = nil)
  if valid_775217 != nil:
    section.add "X-Amz-Algorithm", valid_775217
  var valid_775218 = header.getOrDefault("X-Amz-Signature")
  valid_775218 = validateParameter(valid_775218, JString, required = false,
                                 default = nil)
  if valid_775218 != nil:
    section.add "X-Amz-Signature", valid_775218
  var valid_775219 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775219 = validateParameter(valid_775219, JString, required = false,
                                 default = nil)
  if valid_775219 != nil:
    section.add "X-Amz-SignedHeaders", valid_775219
  var valid_775220 = header.getOrDefault("X-Amz-Credential")
  valid_775220 = validateParameter(valid_775220, JString, required = false,
                                 default = nil)
  if valid_775220 != nil:
    section.add "X-Amz-Credential", valid_775220
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775221: Call_ListMitigationActions_775208; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ## 
  let valid = call_775221.validator(path, query, header, formData, body)
  let scheme = call_775221.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775221.url(scheme.get, call_775221.host, call_775221.base,
                         call_775221.route, valid.getOrDefault("path"))
  result = hook(call_775221, url, valid)

proc call*(call_775222: Call_ListMitigationActions_775208;
          actionType: string = "UPDATE_DEVICE_CERTIFICATE"; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listMitigationActions
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ##   actionType: string
  ##             : Specify a value to limit the result to mitigation actions with a specific action type.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: string
  ##            : The token for the next set of results.
  var query_775223 = newJObject()
  add(query_775223, "actionType", newJString(actionType))
  add(query_775223, "maxResults", newJInt(maxResults))
  add(query_775223, "nextToken", newJString(nextToken))
  result = call_775222.call(nil, query_775223, nil, nil, nil)

var listMitigationActions* = Call_ListMitigationActions_775208(
    name: "listMitigationActions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions",
    validator: validate_ListMitigationActions_775209, base: "/",
    url: url_ListMitigationActions_775210, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListOTAUpdates_775224 = ref object of OpenApiRestCall_772597
proc url_ListOTAUpdates_775226(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListOTAUpdates_775225(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists OTA updates.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   otaUpdateStatus: JString
  ##                  : The OTA update job status.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : A token used to retrieve the next set of results.
  section = newJObject()
  var valid_775227 = query.getOrDefault("otaUpdateStatus")
  valid_775227 = validateParameter(valid_775227, JString, required = false,
                                 default = newJString("CREATE_PENDING"))
  if valid_775227 != nil:
    section.add "otaUpdateStatus", valid_775227
  var valid_775228 = query.getOrDefault("maxResults")
  valid_775228 = validateParameter(valid_775228, JInt, required = false, default = nil)
  if valid_775228 != nil:
    section.add "maxResults", valid_775228
  var valid_775229 = query.getOrDefault("nextToken")
  valid_775229 = validateParameter(valid_775229, JString, required = false,
                                 default = nil)
  if valid_775229 != nil:
    section.add "nextToken", valid_775229
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775230 = header.getOrDefault("X-Amz-Date")
  valid_775230 = validateParameter(valid_775230, JString, required = false,
                                 default = nil)
  if valid_775230 != nil:
    section.add "X-Amz-Date", valid_775230
  var valid_775231 = header.getOrDefault("X-Amz-Security-Token")
  valid_775231 = validateParameter(valid_775231, JString, required = false,
                                 default = nil)
  if valid_775231 != nil:
    section.add "X-Amz-Security-Token", valid_775231
  var valid_775232 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775232 = validateParameter(valid_775232, JString, required = false,
                                 default = nil)
  if valid_775232 != nil:
    section.add "X-Amz-Content-Sha256", valid_775232
  var valid_775233 = header.getOrDefault("X-Amz-Algorithm")
  valid_775233 = validateParameter(valid_775233, JString, required = false,
                                 default = nil)
  if valid_775233 != nil:
    section.add "X-Amz-Algorithm", valid_775233
  var valid_775234 = header.getOrDefault("X-Amz-Signature")
  valid_775234 = validateParameter(valid_775234, JString, required = false,
                                 default = nil)
  if valid_775234 != nil:
    section.add "X-Amz-Signature", valid_775234
  var valid_775235 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775235 = validateParameter(valid_775235, JString, required = false,
                                 default = nil)
  if valid_775235 != nil:
    section.add "X-Amz-SignedHeaders", valid_775235
  var valid_775236 = header.getOrDefault("X-Amz-Credential")
  valid_775236 = validateParameter(valid_775236, JString, required = false,
                                 default = nil)
  if valid_775236 != nil:
    section.add "X-Amz-Credential", valid_775236
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775237: Call_ListOTAUpdates_775224; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists OTA updates.
  ## 
  let valid = call_775237.validator(path, query, header, formData, body)
  let scheme = call_775237.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775237.url(scheme.get, call_775237.host, call_775237.base,
                         call_775237.route, valid.getOrDefault("path"))
  result = hook(call_775237, url, valid)

proc call*(call_775238: Call_ListOTAUpdates_775224;
          otaUpdateStatus: string = "CREATE_PENDING"; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listOTAUpdates
  ## Lists OTA updates.
  ##   otaUpdateStatus: string
  ##                  : The OTA update job status.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : A token used to retrieve the next set of results.
  var query_775239 = newJObject()
  add(query_775239, "otaUpdateStatus", newJString(otaUpdateStatus))
  add(query_775239, "maxResults", newJInt(maxResults))
  add(query_775239, "nextToken", newJString(nextToken))
  result = call_775238.call(nil, query_775239, nil, nil, nil)

var listOTAUpdates* = Call_ListOTAUpdates_775224(name: "listOTAUpdates",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/otaUpdates",
    validator: validate_ListOTAUpdates_775225, base: "/", url: url_ListOTAUpdates_775226,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListOutgoingCertificates_775240 = ref object of OpenApiRestCall_772597
proc url_ListOutgoingCertificates_775242(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListOutgoingCertificates_775241(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists certificates that are being transferred but not yet accepted.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  section = newJObject()
  var valid_775243 = query.getOrDefault("marker")
  valid_775243 = validateParameter(valid_775243, JString, required = false,
                                 default = nil)
  if valid_775243 != nil:
    section.add "marker", valid_775243
  var valid_775244 = query.getOrDefault("pageSize")
  valid_775244 = validateParameter(valid_775244, JInt, required = false, default = nil)
  if valid_775244 != nil:
    section.add "pageSize", valid_775244
  var valid_775245 = query.getOrDefault("isAscendingOrder")
  valid_775245 = validateParameter(valid_775245, JBool, required = false, default = nil)
  if valid_775245 != nil:
    section.add "isAscendingOrder", valid_775245
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775246 = header.getOrDefault("X-Amz-Date")
  valid_775246 = validateParameter(valid_775246, JString, required = false,
                                 default = nil)
  if valid_775246 != nil:
    section.add "X-Amz-Date", valid_775246
  var valid_775247 = header.getOrDefault("X-Amz-Security-Token")
  valid_775247 = validateParameter(valid_775247, JString, required = false,
                                 default = nil)
  if valid_775247 != nil:
    section.add "X-Amz-Security-Token", valid_775247
  var valid_775248 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775248 = validateParameter(valid_775248, JString, required = false,
                                 default = nil)
  if valid_775248 != nil:
    section.add "X-Amz-Content-Sha256", valid_775248
  var valid_775249 = header.getOrDefault("X-Amz-Algorithm")
  valid_775249 = validateParameter(valid_775249, JString, required = false,
                                 default = nil)
  if valid_775249 != nil:
    section.add "X-Amz-Algorithm", valid_775249
  var valid_775250 = header.getOrDefault("X-Amz-Signature")
  valid_775250 = validateParameter(valid_775250, JString, required = false,
                                 default = nil)
  if valid_775250 != nil:
    section.add "X-Amz-Signature", valid_775250
  var valid_775251 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775251 = validateParameter(valid_775251, JString, required = false,
                                 default = nil)
  if valid_775251 != nil:
    section.add "X-Amz-SignedHeaders", valid_775251
  var valid_775252 = header.getOrDefault("X-Amz-Credential")
  valid_775252 = validateParameter(valid_775252, JString, required = false,
                                 default = nil)
  if valid_775252 != nil:
    section.add "X-Amz-Credential", valid_775252
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775253: Call_ListOutgoingCertificates_775240; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists certificates that are being transferred but not yet accepted.
  ## 
  let valid = call_775253.validator(path, query, header, formData, body)
  let scheme = call_775253.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775253.url(scheme.get, call_775253.host, call_775253.base,
                         call_775253.route, valid.getOrDefault("path"))
  result = hook(call_775253, url, valid)

proc call*(call_775254: Call_ListOutgoingCertificates_775240; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listOutgoingCertificates
  ## Lists certificates that are being transferred but not yet accepted.
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  var query_775255 = newJObject()
  add(query_775255, "marker", newJString(marker))
  add(query_775255, "pageSize", newJInt(pageSize))
  add(query_775255, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_775254.call(nil, query_775255, nil, nil, nil)

var listOutgoingCertificates* = Call_ListOutgoingCertificates_775240(
    name: "listOutgoingCertificates", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates-out-going",
    validator: validate_ListOutgoingCertificates_775241, base: "/",
    url: url_ListOutgoingCertificates_775242, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicies_775256 = ref object of OpenApiRestCall_772597
proc url_ListPolicies_775258(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListPolicies_775257(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists your policies.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  section = newJObject()
  var valid_775259 = query.getOrDefault("marker")
  valid_775259 = validateParameter(valid_775259, JString, required = false,
                                 default = nil)
  if valid_775259 != nil:
    section.add "marker", valid_775259
  var valid_775260 = query.getOrDefault("pageSize")
  valid_775260 = validateParameter(valid_775260, JInt, required = false, default = nil)
  if valid_775260 != nil:
    section.add "pageSize", valid_775260
  var valid_775261 = query.getOrDefault("isAscendingOrder")
  valid_775261 = validateParameter(valid_775261, JBool, required = false, default = nil)
  if valid_775261 != nil:
    section.add "isAscendingOrder", valid_775261
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775262 = header.getOrDefault("X-Amz-Date")
  valid_775262 = validateParameter(valid_775262, JString, required = false,
                                 default = nil)
  if valid_775262 != nil:
    section.add "X-Amz-Date", valid_775262
  var valid_775263 = header.getOrDefault("X-Amz-Security-Token")
  valid_775263 = validateParameter(valid_775263, JString, required = false,
                                 default = nil)
  if valid_775263 != nil:
    section.add "X-Amz-Security-Token", valid_775263
  var valid_775264 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775264 = validateParameter(valid_775264, JString, required = false,
                                 default = nil)
  if valid_775264 != nil:
    section.add "X-Amz-Content-Sha256", valid_775264
  var valid_775265 = header.getOrDefault("X-Amz-Algorithm")
  valid_775265 = validateParameter(valid_775265, JString, required = false,
                                 default = nil)
  if valid_775265 != nil:
    section.add "X-Amz-Algorithm", valid_775265
  var valid_775266 = header.getOrDefault("X-Amz-Signature")
  valid_775266 = validateParameter(valid_775266, JString, required = false,
                                 default = nil)
  if valid_775266 != nil:
    section.add "X-Amz-Signature", valid_775266
  var valid_775267 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775267 = validateParameter(valid_775267, JString, required = false,
                                 default = nil)
  if valid_775267 != nil:
    section.add "X-Amz-SignedHeaders", valid_775267
  var valid_775268 = header.getOrDefault("X-Amz-Credential")
  valid_775268 = validateParameter(valid_775268, JString, required = false,
                                 default = nil)
  if valid_775268 != nil:
    section.add "X-Amz-Credential", valid_775268
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775269: Call_ListPolicies_775256; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists your policies.
  ## 
  let valid = call_775269.validator(path, query, header, formData, body)
  let scheme = call_775269.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775269.url(scheme.get, call_775269.host, call_775269.base,
                         call_775269.route, valid.getOrDefault("path"))
  result = hook(call_775269, url, valid)

proc call*(call_775270: Call_ListPolicies_775256; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listPolicies
  ## Lists your policies.
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  var query_775271 = newJObject()
  add(query_775271, "marker", newJString(marker))
  add(query_775271, "pageSize", newJInt(pageSize))
  add(query_775271, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_775270.call(nil, query_775271, nil, nil, nil)

var listPolicies* = Call_ListPolicies_775256(name: "listPolicies",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/policies",
    validator: validate_ListPolicies_775257, base: "/", url: url_ListPolicies_775258,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicyPrincipals_775272 = ref object of OpenApiRestCall_772597
proc url_ListPolicyPrincipals_775274(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListPolicyPrincipals_775273(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  section = newJObject()
  var valid_775275 = query.getOrDefault("marker")
  valid_775275 = validateParameter(valid_775275, JString, required = false,
                                 default = nil)
  if valid_775275 != nil:
    section.add "marker", valid_775275
  var valid_775276 = query.getOrDefault("pageSize")
  valid_775276 = validateParameter(valid_775276, JInt, required = false, default = nil)
  if valid_775276 != nil:
    section.add "pageSize", valid_775276
  var valid_775277 = query.getOrDefault("isAscendingOrder")
  valid_775277 = validateParameter(valid_775277, JBool, required = false, default = nil)
  if valid_775277 != nil:
    section.add "isAscendingOrder", valid_775277
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   x-amzn-iot-policy: JString (required)
  ##                    : The policy name.
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775278 = header.getOrDefault("X-Amz-Date")
  valid_775278 = validateParameter(valid_775278, JString, required = false,
                                 default = nil)
  if valid_775278 != nil:
    section.add "X-Amz-Date", valid_775278
  var valid_775279 = header.getOrDefault("X-Amz-Security-Token")
  valid_775279 = validateParameter(valid_775279, JString, required = false,
                                 default = nil)
  if valid_775279 != nil:
    section.add "X-Amz-Security-Token", valid_775279
  var valid_775280 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775280 = validateParameter(valid_775280, JString, required = false,
                                 default = nil)
  if valid_775280 != nil:
    section.add "X-Amz-Content-Sha256", valid_775280
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-policy` field"
  var valid_775281 = header.getOrDefault("x-amzn-iot-policy")
  valid_775281 = validateParameter(valid_775281, JString, required = true,
                                 default = nil)
  if valid_775281 != nil:
    section.add "x-amzn-iot-policy", valid_775281
  var valid_775282 = header.getOrDefault("X-Amz-Algorithm")
  valid_775282 = validateParameter(valid_775282, JString, required = false,
                                 default = nil)
  if valid_775282 != nil:
    section.add "X-Amz-Algorithm", valid_775282
  var valid_775283 = header.getOrDefault("X-Amz-Signature")
  valid_775283 = validateParameter(valid_775283, JString, required = false,
                                 default = nil)
  if valid_775283 != nil:
    section.add "X-Amz-Signature", valid_775283
  var valid_775284 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775284 = validateParameter(valid_775284, JString, required = false,
                                 default = nil)
  if valid_775284 != nil:
    section.add "X-Amz-SignedHeaders", valid_775284
  var valid_775285 = header.getOrDefault("X-Amz-Credential")
  valid_775285 = validateParameter(valid_775285, JString, required = false,
                                 default = nil)
  if valid_775285 != nil:
    section.add "X-Amz-Credential", valid_775285
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775286: Call_ListPolicyPrincipals_775272; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ## 
  let valid = call_775286.validator(path, query, header, formData, body)
  let scheme = call_775286.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775286.url(scheme.get, call_775286.host, call_775286.base,
                         call_775286.route, valid.getOrDefault("path"))
  result = hook(call_775286, url, valid)

proc call*(call_775287: Call_ListPolicyPrincipals_775272; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listPolicyPrincipals
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  var query_775288 = newJObject()
  add(query_775288, "marker", newJString(marker))
  add(query_775288, "pageSize", newJInt(pageSize))
  add(query_775288, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_775287.call(nil, query_775288, nil, nil, nil)

var listPolicyPrincipals* = Call_ListPolicyPrincipals_775272(
    name: "listPolicyPrincipals", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/policy-principals#x-amzn-iot-policy",
    validator: validate_ListPolicyPrincipals_775273, base: "/",
    url: url_ListPolicyPrincipals_775274, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPrincipalPolicies_775289 = ref object of OpenApiRestCall_772597
proc url_ListPrincipalPolicies_775291(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListPrincipalPolicies_775290(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, results are returned in ascending creation order.
  section = newJObject()
  var valid_775292 = query.getOrDefault("marker")
  valid_775292 = validateParameter(valid_775292, JString, required = false,
                                 default = nil)
  if valid_775292 != nil:
    section.add "marker", valid_775292
  var valid_775293 = query.getOrDefault("pageSize")
  valid_775293 = validateParameter(valid_775293, JInt, required = false, default = nil)
  if valid_775293 != nil:
    section.add "pageSize", valid_775293
  var valid_775294 = query.getOrDefault("isAscendingOrder")
  valid_775294 = validateParameter(valid_775294, JBool, required = false, default = nil)
  if valid_775294 != nil:
    section.add "isAscendingOrder", valid_775294
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : The principal.
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775295 = header.getOrDefault("X-Amz-Date")
  valid_775295 = validateParameter(valid_775295, JString, required = false,
                                 default = nil)
  if valid_775295 != nil:
    section.add "X-Amz-Date", valid_775295
  var valid_775296 = header.getOrDefault("X-Amz-Security-Token")
  valid_775296 = validateParameter(valid_775296, JString, required = false,
                                 default = nil)
  if valid_775296 != nil:
    section.add "X-Amz-Security-Token", valid_775296
  var valid_775297 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775297 = validateParameter(valid_775297, JString, required = false,
                                 default = nil)
  if valid_775297 != nil:
    section.add "X-Amz-Content-Sha256", valid_775297
  var valid_775298 = header.getOrDefault("X-Amz-Algorithm")
  valid_775298 = validateParameter(valid_775298, JString, required = false,
                                 default = nil)
  if valid_775298 != nil:
    section.add "X-Amz-Algorithm", valid_775298
  var valid_775299 = header.getOrDefault("X-Amz-Signature")
  valid_775299 = validateParameter(valid_775299, JString, required = false,
                                 default = nil)
  if valid_775299 != nil:
    section.add "X-Amz-Signature", valid_775299
  var valid_775300 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775300 = validateParameter(valid_775300, JString, required = false,
                                 default = nil)
  if valid_775300 != nil:
    section.add "X-Amz-SignedHeaders", valid_775300
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_775301 = header.getOrDefault("x-amzn-iot-principal")
  valid_775301 = validateParameter(valid_775301, JString, required = true,
                                 default = nil)
  if valid_775301 != nil:
    section.add "x-amzn-iot-principal", valid_775301
  var valid_775302 = header.getOrDefault("X-Amz-Credential")
  valid_775302 = validateParameter(valid_775302, JString, required = false,
                                 default = nil)
  if valid_775302 != nil:
    section.add "X-Amz-Credential", valid_775302
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775303: Call_ListPrincipalPolicies_775289; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ## 
  let valid = call_775303.validator(path, query, header, formData, body)
  let scheme = call_775303.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775303.url(scheme.get, call_775303.host, call_775303.base,
                         call_775303.route, valid.getOrDefault("path"))
  result = hook(call_775303, url, valid)

proc call*(call_775304: Call_ListPrincipalPolicies_775289; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listPrincipalPolicies
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, results are returned in ascending creation order.
  var query_775305 = newJObject()
  add(query_775305, "marker", newJString(marker))
  add(query_775305, "pageSize", newJInt(pageSize))
  add(query_775305, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_775304.call(nil, query_775305, nil, nil, nil)

var listPrincipalPolicies* = Call_ListPrincipalPolicies_775289(
    name: "listPrincipalPolicies", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/principal-policies#x-amzn-iot-principal",
    validator: validate_ListPrincipalPolicies_775290, base: "/",
    url: url_ListPrincipalPolicies_775291, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPrincipalThings_775306 = ref object of OpenApiRestCall_772597
proc url_ListPrincipalThings_775308(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListPrincipalThings_775307(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  var valid_775309 = query.getOrDefault("maxResults")
  valid_775309 = validateParameter(valid_775309, JInt, required = false, default = nil)
  if valid_775309 != nil:
    section.add "maxResults", valid_775309
  var valid_775310 = query.getOrDefault("nextToken")
  valid_775310 = validateParameter(valid_775310, JString, required = false,
                                 default = nil)
  if valid_775310 != nil:
    section.add "nextToken", valid_775310
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : The principal.
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775311 = header.getOrDefault("X-Amz-Date")
  valid_775311 = validateParameter(valid_775311, JString, required = false,
                                 default = nil)
  if valid_775311 != nil:
    section.add "X-Amz-Date", valid_775311
  var valid_775312 = header.getOrDefault("X-Amz-Security-Token")
  valid_775312 = validateParameter(valid_775312, JString, required = false,
                                 default = nil)
  if valid_775312 != nil:
    section.add "X-Amz-Security-Token", valid_775312
  var valid_775313 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775313 = validateParameter(valid_775313, JString, required = false,
                                 default = nil)
  if valid_775313 != nil:
    section.add "X-Amz-Content-Sha256", valid_775313
  var valid_775314 = header.getOrDefault("X-Amz-Algorithm")
  valid_775314 = validateParameter(valid_775314, JString, required = false,
                                 default = nil)
  if valid_775314 != nil:
    section.add "X-Amz-Algorithm", valid_775314
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_775315 = header.getOrDefault("x-amzn-principal")
  valid_775315 = validateParameter(valid_775315, JString, required = true,
                                 default = nil)
  if valid_775315 != nil:
    section.add "x-amzn-principal", valid_775315
  var valid_775316 = header.getOrDefault("X-Amz-Signature")
  valid_775316 = validateParameter(valid_775316, JString, required = false,
                                 default = nil)
  if valid_775316 != nil:
    section.add "X-Amz-Signature", valid_775316
  var valid_775317 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775317 = validateParameter(valid_775317, JString, required = false,
                                 default = nil)
  if valid_775317 != nil:
    section.add "X-Amz-SignedHeaders", valid_775317
  var valid_775318 = header.getOrDefault("X-Amz-Credential")
  valid_775318 = validateParameter(valid_775318, JString, required = false,
                                 default = nil)
  if valid_775318 != nil:
    section.add "X-Amz-Credential", valid_775318
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775319: Call_ListPrincipalThings_775306; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ## 
  let valid = call_775319.validator(path, query, header, formData, body)
  let scheme = call_775319.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775319.url(scheme.get, call_775319.host, call_775319.base,
                         call_775319.route, valid.getOrDefault("path"))
  result = hook(call_775319, url, valid)

proc call*(call_775320: Call_ListPrincipalThings_775306; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listPrincipalThings
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var query_775321 = newJObject()
  add(query_775321, "maxResults", newJInt(maxResults))
  add(query_775321, "nextToken", newJString(nextToken))
  result = call_775320.call(nil, query_775321, nil, nil, nil)

var listPrincipalThings* = Call_ListPrincipalThings_775306(
    name: "listPrincipalThings", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/principals/things#x-amzn-principal",
    validator: validate_ListPrincipalThings_775307, base: "/",
    url: url_ListPrincipalThings_775308, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListRoleAliases_775322 = ref object of OpenApiRestCall_772597
proc url_ListRoleAliases_775324(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListRoleAliases_775323(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Lists the role aliases registered in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   isAscendingOrder: JBool
  ##                   : Return the list of role aliases in ascending alphabetical order.
  section = newJObject()
  var valid_775325 = query.getOrDefault("marker")
  valid_775325 = validateParameter(valid_775325, JString, required = false,
                                 default = nil)
  if valid_775325 != nil:
    section.add "marker", valid_775325
  var valid_775326 = query.getOrDefault("pageSize")
  valid_775326 = validateParameter(valid_775326, JInt, required = false, default = nil)
  if valid_775326 != nil:
    section.add "pageSize", valid_775326
  var valid_775327 = query.getOrDefault("isAscendingOrder")
  valid_775327 = validateParameter(valid_775327, JBool, required = false, default = nil)
  if valid_775327 != nil:
    section.add "isAscendingOrder", valid_775327
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775328 = header.getOrDefault("X-Amz-Date")
  valid_775328 = validateParameter(valid_775328, JString, required = false,
                                 default = nil)
  if valid_775328 != nil:
    section.add "X-Amz-Date", valid_775328
  var valid_775329 = header.getOrDefault("X-Amz-Security-Token")
  valid_775329 = validateParameter(valid_775329, JString, required = false,
                                 default = nil)
  if valid_775329 != nil:
    section.add "X-Amz-Security-Token", valid_775329
  var valid_775330 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775330 = validateParameter(valid_775330, JString, required = false,
                                 default = nil)
  if valid_775330 != nil:
    section.add "X-Amz-Content-Sha256", valid_775330
  var valid_775331 = header.getOrDefault("X-Amz-Algorithm")
  valid_775331 = validateParameter(valid_775331, JString, required = false,
                                 default = nil)
  if valid_775331 != nil:
    section.add "X-Amz-Algorithm", valid_775331
  var valid_775332 = header.getOrDefault("X-Amz-Signature")
  valid_775332 = validateParameter(valid_775332, JString, required = false,
                                 default = nil)
  if valid_775332 != nil:
    section.add "X-Amz-Signature", valid_775332
  var valid_775333 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775333 = validateParameter(valid_775333, JString, required = false,
                                 default = nil)
  if valid_775333 != nil:
    section.add "X-Amz-SignedHeaders", valid_775333
  var valid_775334 = header.getOrDefault("X-Amz-Credential")
  valid_775334 = validateParameter(valid_775334, JString, required = false,
                                 default = nil)
  if valid_775334 != nil:
    section.add "X-Amz-Credential", valid_775334
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775335: Call_ListRoleAliases_775322; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the role aliases registered in your account.
  ## 
  let valid = call_775335.validator(path, query, header, formData, body)
  let scheme = call_775335.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775335.url(scheme.get, call_775335.host, call_775335.base,
                         call_775335.route, valid.getOrDefault("path"))
  result = hook(call_775335, url, valid)

proc call*(call_775336: Call_ListRoleAliases_775322; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listRoleAliases
  ## Lists the role aliases registered in your account.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   isAscendingOrder: bool
  ##                   : Return the list of role aliases in ascending alphabetical order.
  var query_775337 = newJObject()
  add(query_775337, "marker", newJString(marker))
  add(query_775337, "pageSize", newJInt(pageSize))
  add(query_775337, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_775336.call(nil, query_775337, nil, nil, nil)

var listRoleAliases* = Call_ListRoleAliases_775322(name: "listRoleAliases",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/role-aliases",
    validator: validate_ListRoleAliases_775323, base: "/", url: url_ListRoleAliases_775324,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListScheduledAudits_775338 = ref object of OpenApiRestCall_772597
proc url_ListScheduledAudits_775340(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListScheduledAudits_775339(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists all of your scheduled audits.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  section = newJObject()
  var valid_775341 = query.getOrDefault("maxResults")
  valid_775341 = validateParameter(valid_775341, JInt, required = false, default = nil)
  if valid_775341 != nil:
    section.add "maxResults", valid_775341
  var valid_775342 = query.getOrDefault("nextToken")
  valid_775342 = validateParameter(valid_775342, JString, required = false,
                                 default = nil)
  if valid_775342 != nil:
    section.add "nextToken", valid_775342
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775343 = header.getOrDefault("X-Amz-Date")
  valid_775343 = validateParameter(valid_775343, JString, required = false,
                                 default = nil)
  if valid_775343 != nil:
    section.add "X-Amz-Date", valid_775343
  var valid_775344 = header.getOrDefault("X-Amz-Security-Token")
  valid_775344 = validateParameter(valid_775344, JString, required = false,
                                 default = nil)
  if valid_775344 != nil:
    section.add "X-Amz-Security-Token", valid_775344
  var valid_775345 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775345 = validateParameter(valid_775345, JString, required = false,
                                 default = nil)
  if valid_775345 != nil:
    section.add "X-Amz-Content-Sha256", valid_775345
  var valid_775346 = header.getOrDefault("X-Amz-Algorithm")
  valid_775346 = validateParameter(valid_775346, JString, required = false,
                                 default = nil)
  if valid_775346 != nil:
    section.add "X-Amz-Algorithm", valid_775346
  var valid_775347 = header.getOrDefault("X-Amz-Signature")
  valid_775347 = validateParameter(valid_775347, JString, required = false,
                                 default = nil)
  if valid_775347 != nil:
    section.add "X-Amz-Signature", valid_775347
  var valid_775348 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775348 = validateParameter(valid_775348, JString, required = false,
                                 default = nil)
  if valid_775348 != nil:
    section.add "X-Amz-SignedHeaders", valid_775348
  var valid_775349 = header.getOrDefault("X-Amz-Credential")
  valid_775349 = validateParameter(valid_775349, JString, required = false,
                                 default = nil)
  if valid_775349 != nil:
    section.add "X-Amz-Credential", valid_775349
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775350: Call_ListScheduledAudits_775338; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all of your scheduled audits.
  ## 
  let valid = call_775350.validator(path, query, header, formData, body)
  let scheme = call_775350.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775350.url(scheme.get, call_775350.host, call_775350.base,
                         call_775350.route, valid.getOrDefault("path"))
  result = hook(call_775350, url, valid)

proc call*(call_775351: Call_ListScheduledAudits_775338; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listScheduledAudits
  ## Lists all of your scheduled audits.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: string
  ##            : The token for the next set of results.
  var query_775352 = newJObject()
  add(query_775352, "maxResults", newJInt(maxResults))
  add(query_775352, "nextToken", newJString(nextToken))
  result = call_775351.call(nil, query_775352, nil, nil, nil)

var listScheduledAudits* = Call_ListScheduledAudits_775338(
    name: "listScheduledAudits", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/scheduledaudits",
    validator: validate_ListScheduledAudits_775339, base: "/",
    url: url_ListScheduledAudits_775340, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListSecurityProfiles_775353 = ref object of OpenApiRestCall_772597
proc url_ListSecurityProfiles_775355(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListSecurityProfiles_775354(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  section = newJObject()
  var valid_775356 = query.getOrDefault("maxResults")
  valid_775356 = validateParameter(valid_775356, JInt, required = false, default = nil)
  if valid_775356 != nil:
    section.add "maxResults", valid_775356
  var valid_775357 = query.getOrDefault("nextToken")
  valid_775357 = validateParameter(valid_775357, JString, required = false,
                                 default = nil)
  if valid_775357 != nil:
    section.add "nextToken", valid_775357
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775358 = header.getOrDefault("X-Amz-Date")
  valid_775358 = validateParameter(valid_775358, JString, required = false,
                                 default = nil)
  if valid_775358 != nil:
    section.add "X-Amz-Date", valid_775358
  var valid_775359 = header.getOrDefault("X-Amz-Security-Token")
  valid_775359 = validateParameter(valid_775359, JString, required = false,
                                 default = nil)
  if valid_775359 != nil:
    section.add "X-Amz-Security-Token", valid_775359
  var valid_775360 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775360 = validateParameter(valid_775360, JString, required = false,
                                 default = nil)
  if valid_775360 != nil:
    section.add "X-Amz-Content-Sha256", valid_775360
  var valid_775361 = header.getOrDefault("X-Amz-Algorithm")
  valid_775361 = validateParameter(valid_775361, JString, required = false,
                                 default = nil)
  if valid_775361 != nil:
    section.add "X-Amz-Algorithm", valid_775361
  var valid_775362 = header.getOrDefault("X-Amz-Signature")
  valid_775362 = validateParameter(valid_775362, JString, required = false,
                                 default = nil)
  if valid_775362 != nil:
    section.add "X-Amz-Signature", valid_775362
  var valid_775363 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775363 = validateParameter(valid_775363, JString, required = false,
                                 default = nil)
  if valid_775363 != nil:
    section.add "X-Amz-SignedHeaders", valid_775363
  var valid_775364 = header.getOrDefault("X-Amz-Credential")
  valid_775364 = validateParameter(valid_775364, JString, required = false,
                                 default = nil)
  if valid_775364 != nil:
    section.add "X-Amz-Credential", valid_775364
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775365: Call_ListSecurityProfiles_775353; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ## 
  let valid = call_775365.validator(path, query, header, formData, body)
  let scheme = call_775365.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775365.url(scheme.get, call_775365.host, call_775365.base,
                         call_775365.route, valid.getOrDefault("path"))
  result = hook(call_775365, url, valid)

proc call*(call_775366: Call_ListSecurityProfiles_775353; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listSecurityProfiles
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  var query_775367 = newJObject()
  add(query_775367, "maxResults", newJInt(maxResults))
  add(query_775367, "nextToken", newJString(nextToken))
  result = call_775366.call(nil, query_775367, nil, nil, nil)

var listSecurityProfiles* = Call_ListSecurityProfiles_775353(
    name: "listSecurityProfiles", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/security-profiles",
    validator: validate_ListSecurityProfiles_775354, base: "/",
    url: url_ListSecurityProfiles_775355, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListSecurityProfilesForTarget_775368 = ref object of OpenApiRestCall_772597
proc url_ListSecurityProfilesForTarget_775370(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListSecurityProfilesForTarget_775369(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the target (thing group) whose attached security profiles you want to get.
  ##   recursive: JBool
  ##            : If true, return child groups too.
  section = newJObject()
  var valid_775371 = query.getOrDefault("maxResults")
  valid_775371 = validateParameter(valid_775371, JInt, required = false, default = nil)
  if valid_775371 != nil:
    section.add "maxResults", valid_775371
  var valid_775372 = query.getOrDefault("nextToken")
  valid_775372 = validateParameter(valid_775372, JString, required = false,
                                 default = nil)
  if valid_775372 != nil:
    section.add "nextToken", valid_775372
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_775373 = query.getOrDefault("securityProfileTargetArn")
  valid_775373 = validateParameter(valid_775373, JString, required = true,
                                 default = nil)
  if valid_775373 != nil:
    section.add "securityProfileTargetArn", valid_775373
  var valid_775374 = query.getOrDefault("recursive")
  valid_775374 = validateParameter(valid_775374, JBool, required = false, default = nil)
  if valid_775374 != nil:
    section.add "recursive", valid_775374
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775375 = header.getOrDefault("X-Amz-Date")
  valid_775375 = validateParameter(valid_775375, JString, required = false,
                                 default = nil)
  if valid_775375 != nil:
    section.add "X-Amz-Date", valid_775375
  var valid_775376 = header.getOrDefault("X-Amz-Security-Token")
  valid_775376 = validateParameter(valid_775376, JString, required = false,
                                 default = nil)
  if valid_775376 != nil:
    section.add "X-Amz-Security-Token", valid_775376
  var valid_775377 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775377 = validateParameter(valid_775377, JString, required = false,
                                 default = nil)
  if valid_775377 != nil:
    section.add "X-Amz-Content-Sha256", valid_775377
  var valid_775378 = header.getOrDefault("X-Amz-Algorithm")
  valid_775378 = validateParameter(valid_775378, JString, required = false,
                                 default = nil)
  if valid_775378 != nil:
    section.add "X-Amz-Algorithm", valid_775378
  var valid_775379 = header.getOrDefault("X-Amz-Signature")
  valid_775379 = validateParameter(valid_775379, JString, required = false,
                                 default = nil)
  if valid_775379 != nil:
    section.add "X-Amz-Signature", valid_775379
  var valid_775380 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775380 = validateParameter(valid_775380, JString, required = false,
                                 default = nil)
  if valid_775380 != nil:
    section.add "X-Amz-SignedHeaders", valid_775380
  var valid_775381 = header.getOrDefault("X-Amz-Credential")
  valid_775381 = validateParameter(valid_775381, JString, required = false,
                                 default = nil)
  if valid_775381 != nil:
    section.add "X-Amz-Credential", valid_775381
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775382: Call_ListSecurityProfilesForTarget_775368; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ## 
  let valid = call_775382.validator(path, query, header, formData, body)
  let scheme = call_775382.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775382.url(scheme.get, call_775382.host, call_775382.base,
                         call_775382.route, valid.getOrDefault("path"))
  result = hook(call_775382, url, valid)

proc call*(call_775383: Call_ListSecurityProfilesForTarget_775368;
          securityProfileTargetArn: string; maxResults: int = 0;
          nextToken: string = ""; recursive: bool = false): Recallable =
  ## listSecurityProfilesForTarget
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the target (thing group) whose attached security profiles you want to get.
  ##   recursive: bool
  ##            : If true, return child groups too.
  var query_775384 = newJObject()
  add(query_775384, "maxResults", newJInt(maxResults))
  add(query_775384, "nextToken", newJString(nextToken))
  add(query_775384, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(query_775384, "recursive", newJBool(recursive))
  result = call_775383.call(nil, query_775384, nil, nil, nil)

var listSecurityProfilesForTarget* = Call_ListSecurityProfilesForTarget_775368(
    name: "listSecurityProfilesForTarget", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/security-profiles-for-target#securityProfileTargetArn",
    validator: validate_ListSecurityProfilesForTarget_775369, base: "/",
    url: url_ListSecurityProfilesForTarget_775370,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListStreams_775385 = ref object of OpenApiRestCall_772597
proc url_ListStreams_775387(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListStreams_775386(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all of the streams in your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at a time.
  ##   nextToken: JString
  ##            : A token used to get the next set of results.
  ##   isAscendingOrder: JBool
  ##                   : Set to true to return the list of streams in ascending order.
  section = newJObject()
  var valid_775388 = query.getOrDefault("maxResults")
  valid_775388 = validateParameter(valid_775388, JInt, required = false, default = nil)
  if valid_775388 != nil:
    section.add "maxResults", valid_775388
  var valid_775389 = query.getOrDefault("nextToken")
  valid_775389 = validateParameter(valid_775389, JString, required = false,
                                 default = nil)
  if valid_775389 != nil:
    section.add "nextToken", valid_775389
  var valid_775390 = query.getOrDefault("isAscendingOrder")
  valid_775390 = validateParameter(valid_775390, JBool, required = false, default = nil)
  if valid_775390 != nil:
    section.add "isAscendingOrder", valid_775390
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775391 = header.getOrDefault("X-Amz-Date")
  valid_775391 = validateParameter(valid_775391, JString, required = false,
                                 default = nil)
  if valid_775391 != nil:
    section.add "X-Amz-Date", valid_775391
  var valid_775392 = header.getOrDefault("X-Amz-Security-Token")
  valid_775392 = validateParameter(valid_775392, JString, required = false,
                                 default = nil)
  if valid_775392 != nil:
    section.add "X-Amz-Security-Token", valid_775392
  var valid_775393 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775393 = validateParameter(valid_775393, JString, required = false,
                                 default = nil)
  if valid_775393 != nil:
    section.add "X-Amz-Content-Sha256", valid_775393
  var valid_775394 = header.getOrDefault("X-Amz-Algorithm")
  valid_775394 = validateParameter(valid_775394, JString, required = false,
                                 default = nil)
  if valid_775394 != nil:
    section.add "X-Amz-Algorithm", valid_775394
  var valid_775395 = header.getOrDefault("X-Amz-Signature")
  valid_775395 = validateParameter(valid_775395, JString, required = false,
                                 default = nil)
  if valid_775395 != nil:
    section.add "X-Amz-Signature", valid_775395
  var valid_775396 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775396 = validateParameter(valid_775396, JString, required = false,
                                 default = nil)
  if valid_775396 != nil:
    section.add "X-Amz-SignedHeaders", valid_775396
  var valid_775397 = header.getOrDefault("X-Amz-Credential")
  valid_775397 = validateParameter(valid_775397, JString, required = false,
                                 default = nil)
  if valid_775397 != nil:
    section.add "X-Amz-Credential", valid_775397
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775398: Call_ListStreams_775385; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all of the streams in your AWS account.
  ## 
  let valid = call_775398.validator(path, query, header, formData, body)
  let scheme = call_775398.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775398.url(scheme.get, call_775398.host, call_775398.base,
                         call_775398.route, valid.getOrDefault("path"))
  result = hook(call_775398, url, valid)

proc call*(call_775399: Call_ListStreams_775385; maxResults: int = 0;
          nextToken: string = ""; isAscendingOrder: bool = false): Recallable =
  ## listStreams
  ## Lists all of the streams in your AWS account.
  ##   maxResults: int
  ##             : The maximum number of results to return at a time.
  ##   nextToken: string
  ##            : A token used to get the next set of results.
  ##   isAscendingOrder: bool
  ##                   : Set to true to return the list of streams in ascending order.
  var query_775400 = newJObject()
  add(query_775400, "maxResults", newJInt(maxResults))
  add(query_775400, "nextToken", newJString(nextToken))
  add(query_775400, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_775399.call(nil, query_775400, nil, nil, nil)

var listStreams* = Call_ListStreams_775385(name: "listStreams",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/streams",
                                        validator: validate_ListStreams_775386,
                                        base: "/", url: url_ListStreams_775387,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTagsForResource_775401 = ref object of OpenApiRestCall_772597
proc url_ListTagsForResource_775403(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListTagsForResource_775402(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the tags (metadata) you have assigned to the resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   resourceArn: JString (required)
  ##              : The ARN of the resource.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `resourceArn` field"
  var valid_775404 = query.getOrDefault("resourceArn")
  valid_775404 = validateParameter(valid_775404, JString, required = true,
                                 default = nil)
  if valid_775404 != nil:
    section.add "resourceArn", valid_775404
  var valid_775405 = query.getOrDefault("nextToken")
  valid_775405 = validateParameter(valid_775405, JString, required = false,
                                 default = nil)
  if valid_775405 != nil:
    section.add "nextToken", valid_775405
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775406 = header.getOrDefault("X-Amz-Date")
  valid_775406 = validateParameter(valid_775406, JString, required = false,
                                 default = nil)
  if valid_775406 != nil:
    section.add "X-Amz-Date", valid_775406
  var valid_775407 = header.getOrDefault("X-Amz-Security-Token")
  valid_775407 = validateParameter(valid_775407, JString, required = false,
                                 default = nil)
  if valid_775407 != nil:
    section.add "X-Amz-Security-Token", valid_775407
  var valid_775408 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775408 = validateParameter(valid_775408, JString, required = false,
                                 default = nil)
  if valid_775408 != nil:
    section.add "X-Amz-Content-Sha256", valid_775408
  var valid_775409 = header.getOrDefault("X-Amz-Algorithm")
  valid_775409 = validateParameter(valid_775409, JString, required = false,
                                 default = nil)
  if valid_775409 != nil:
    section.add "X-Amz-Algorithm", valid_775409
  var valid_775410 = header.getOrDefault("X-Amz-Signature")
  valid_775410 = validateParameter(valid_775410, JString, required = false,
                                 default = nil)
  if valid_775410 != nil:
    section.add "X-Amz-Signature", valid_775410
  var valid_775411 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775411 = validateParameter(valid_775411, JString, required = false,
                                 default = nil)
  if valid_775411 != nil:
    section.add "X-Amz-SignedHeaders", valid_775411
  var valid_775412 = header.getOrDefault("X-Amz-Credential")
  valid_775412 = validateParameter(valid_775412, JString, required = false,
                                 default = nil)
  if valid_775412 != nil:
    section.add "X-Amz-Credential", valid_775412
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775413: Call_ListTagsForResource_775401; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the tags (metadata) you have assigned to the resource.
  ## 
  let valid = call_775413.validator(path, query, header, formData, body)
  let scheme = call_775413.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775413.url(scheme.get, call_775413.host, call_775413.base,
                         call_775413.route, valid.getOrDefault("path"))
  result = hook(call_775413, url, valid)

proc call*(call_775414: Call_ListTagsForResource_775401; resourceArn: string;
          nextToken: string = ""): Recallable =
  ## listTagsForResource
  ## Lists the tags (metadata) you have assigned to the resource.
  ##   resourceArn: string (required)
  ##              : The ARN of the resource.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var query_775415 = newJObject()
  add(query_775415, "resourceArn", newJString(resourceArn))
  add(query_775415, "nextToken", newJString(nextToken))
  result = call_775414.call(nil, query_775415, nil, nil, nil)

var listTagsForResource* = Call_ListTagsForResource_775401(
    name: "listTagsForResource", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/tags#resourceArn",
    validator: validate_ListTagsForResource_775402, base: "/",
    url: url_ListTagsForResource_775403, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTargetsForPolicy_775416 = ref object of OpenApiRestCall_772597
proc url_ListTargetsForPolicy_775418(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policy-targets/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_ListTargetsForPolicy_775417(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List targets for the specified policy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_775419 = path.getOrDefault("policyName")
  valid_775419 = validateParameter(valid_775419, JString, required = true,
                                 default = nil)
  if valid_775419 != nil:
    section.add "policyName", valid_775419
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  section = newJObject()
  var valid_775420 = query.getOrDefault("marker")
  valid_775420 = validateParameter(valid_775420, JString, required = false,
                                 default = nil)
  if valid_775420 != nil:
    section.add "marker", valid_775420
  var valid_775421 = query.getOrDefault("pageSize")
  valid_775421 = validateParameter(valid_775421, JInt, required = false, default = nil)
  if valid_775421 != nil:
    section.add "pageSize", valid_775421
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775422 = header.getOrDefault("X-Amz-Date")
  valid_775422 = validateParameter(valid_775422, JString, required = false,
                                 default = nil)
  if valid_775422 != nil:
    section.add "X-Amz-Date", valid_775422
  var valid_775423 = header.getOrDefault("X-Amz-Security-Token")
  valid_775423 = validateParameter(valid_775423, JString, required = false,
                                 default = nil)
  if valid_775423 != nil:
    section.add "X-Amz-Security-Token", valid_775423
  var valid_775424 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775424 = validateParameter(valid_775424, JString, required = false,
                                 default = nil)
  if valid_775424 != nil:
    section.add "X-Amz-Content-Sha256", valid_775424
  var valid_775425 = header.getOrDefault("X-Amz-Algorithm")
  valid_775425 = validateParameter(valid_775425, JString, required = false,
                                 default = nil)
  if valid_775425 != nil:
    section.add "X-Amz-Algorithm", valid_775425
  var valid_775426 = header.getOrDefault("X-Amz-Signature")
  valid_775426 = validateParameter(valid_775426, JString, required = false,
                                 default = nil)
  if valid_775426 != nil:
    section.add "X-Amz-Signature", valid_775426
  var valid_775427 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775427 = validateParameter(valid_775427, JString, required = false,
                                 default = nil)
  if valid_775427 != nil:
    section.add "X-Amz-SignedHeaders", valid_775427
  var valid_775428 = header.getOrDefault("X-Amz-Credential")
  valid_775428 = validateParameter(valid_775428, JString, required = false,
                                 default = nil)
  if valid_775428 != nil:
    section.add "X-Amz-Credential", valid_775428
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775429: Call_ListTargetsForPolicy_775416; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List targets for the specified policy.
  ## 
  let valid = call_775429.validator(path, query, header, formData, body)
  let scheme = call_775429.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775429.url(scheme.get, call_775429.host, call_775429.base,
                         call_775429.route, valid.getOrDefault("path"))
  result = hook(call_775429, url, valid)

proc call*(call_775430: Call_ListTargetsForPolicy_775416; policyName: string;
          marker: string = ""; pageSize: int = 0): Recallable =
  ## listTargetsForPolicy
  ## List targets for the specified policy.
  ##   policyName: string (required)
  ##             : The policy name.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  var path_775431 = newJObject()
  var query_775432 = newJObject()
  add(path_775431, "policyName", newJString(policyName))
  add(query_775432, "marker", newJString(marker))
  add(query_775432, "pageSize", newJInt(pageSize))
  result = call_775430.call(path_775431, query_775432, nil, nil, nil)

var listTargetsForPolicy* = Call_ListTargetsForPolicy_775416(
    name: "listTargetsForPolicy", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/policy-targets/{policyName}",
    validator: validate_ListTargetsForPolicy_775417, base: "/",
    url: url_ListTargetsForPolicy_775418, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTargetsForSecurityProfile_775433 = ref object of OpenApiRestCall_772597
proc url_ListTargetsForSecurityProfile_775435(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"),
               (kind: ConstantSegment, value: "/targets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_ListTargetsForSecurityProfile_775434(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_775436 = path.getOrDefault("securityProfileName")
  valid_775436 = validateParameter(valid_775436, JString, required = true,
                                 default = nil)
  if valid_775436 != nil:
    section.add "securityProfileName", valid_775436
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  section = newJObject()
  var valid_775437 = query.getOrDefault("maxResults")
  valid_775437 = validateParameter(valid_775437, JInt, required = false, default = nil)
  if valid_775437 != nil:
    section.add "maxResults", valid_775437
  var valid_775438 = query.getOrDefault("nextToken")
  valid_775438 = validateParameter(valid_775438, JString, required = false,
                                 default = nil)
  if valid_775438 != nil:
    section.add "nextToken", valid_775438
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775439 = header.getOrDefault("X-Amz-Date")
  valid_775439 = validateParameter(valid_775439, JString, required = false,
                                 default = nil)
  if valid_775439 != nil:
    section.add "X-Amz-Date", valid_775439
  var valid_775440 = header.getOrDefault("X-Amz-Security-Token")
  valid_775440 = validateParameter(valid_775440, JString, required = false,
                                 default = nil)
  if valid_775440 != nil:
    section.add "X-Amz-Security-Token", valid_775440
  var valid_775441 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775441 = validateParameter(valid_775441, JString, required = false,
                                 default = nil)
  if valid_775441 != nil:
    section.add "X-Amz-Content-Sha256", valid_775441
  var valid_775442 = header.getOrDefault("X-Amz-Algorithm")
  valid_775442 = validateParameter(valid_775442, JString, required = false,
                                 default = nil)
  if valid_775442 != nil:
    section.add "X-Amz-Algorithm", valid_775442
  var valid_775443 = header.getOrDefault("X-Amz-Signature")
  valid_775443 = validateParameter(valid_775443, JString, required = false,
                                 default = nil)
  if valid_775443 != nil:
    section.add "X-Amz-Signature", valid_775443
  var valid_775444 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775444 = validateParameter(valid_775444, JString, required = false,
                                 default = nil)
  if valid_775444 != nil:
    section.add "X-Amz-SignedHeaders", valid_775444
  var valid_775445 = header.getOrDefault("X-Amz-Credential")
  valid_775445 = validateParameter(valid_775445, JString, required = false,
                                 default = nil)
  if valid_775445 != nil:
    section.add "X-Amz-Credential", valid_775445
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775446: Call_ListTargetsForSecurityProfile_775433; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ## 
  let valid = call_775446.validator(path, query, header, formData, body)
  let scheme = call_775446.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775446.url(scheme.get, call_775446.host, call_775446.base,
                         call_775446.route, valid.getOrDefault("path"))
  result = hook(call_775446, url, valid)

proc call*(call_775447: Call_ListTargetsForSecurityProfile_775433;
          securityProfileName: string; maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listTargetsForSecurityProfile
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string (required)
  ##                      : The security profile.
  var path_775448 = newJObject()
  var query_775449 = newJObject()
  add(query_775449, "maxResults", newJInt(maxResults))
  add(query_775449, "nextToken", newJString(nextToken))
  add(path_775448, "securityProfileName", newJString(securityProfileName))
  result = call_775447.call(path_775448, query_775449, nil, nil, nil)

var listTargetsForSecurityProfile* = Call_ListTargetsForSecurityProfile_775433(
    name: "listTargetsForSecurityProfile", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/security-profiles/{securityProfileName}/targets",
    validator: validate_ListTargetsForSecurityProfile_775434, base: "/",
    url: url_ListTargetsForSecurityProfile_775435,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingGroups_775450 = ref object of OpenApiRestCall_772597
proc url_ListThingGroups_775452(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListThingGroups_775451(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List the thing groups in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   namePrefixFilter: JString
  ##                   : A filter that limits the results to those with the specified name prefix.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   recursive: JBool
  ##            : If true, return child groups as well.
  ##   parentGroup: JString
  ##              : A filter that limits the results to those with the specified parent group.
  section = newJObject()
  var valid_775453 = query.getOrDefault("namePrefixFilter")
  valid_775453 = validateParameter(valid_775453, JString, required = false,
                                 default = nil)
  if valid_775453 != nil:
    section.add "namePrefixFilter", valid_775453
  var valid_775454 = query.getOrDefault("maxResults")
  valid_775454 = validateParameter(valid_775454, JInt, required = false, default = nil)
  if valid_775454 != nil:
    section.add "maxResults", valid_775454
  var valid_775455 = query.getOrDefault("nextToken")
  valid_775455 = validateParameter(valid_775455, JString, required = false,
                                 default = nil)
  if valid_775455 != nil:
    section.add "nextToken", valid_775455
  var valid_775456 = query.getOrDefault("recursive")
  valid_775456 = validateParameter(valid_775456, JBool, required = false, default = nil)
  if valid_775456 != nil:
    section.add "recursive", valid_775456
  var valid_775457 = query.getOrDefault("parentGroup")
  valid_775457 = validateParameter(valid_775457, JString, required = false,
                                 default = nil)
  if valid_775457 != nil:
    section.add "parentGroup", valid_775457
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775458 = header.getOrDefault("X-Amz-Date")
  valid_775458 = validateParameter(valid_775458, JString, required = false,
                                 default = nil)
  if valid_775458 != nil:
    section.add "X-Amz-Date", valid_775458
  var valid_775459 = header.getOrDefault("X-Amz-Security-Token")
  valid_775459 = validateParameter(valid_775459, JString, required = false,
                                 default = nil)
  if valid_775459 != nil:
    section.add "X-Amz-Security-Token", valid_775459
  var valid_775460 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775460 = validateParameter(valid_775460, JString, required = false,
                                 default = nil)
  if valid_775460 != nil:
    section.add "X-Amz-Content-Sha256", valid_775460
  var valid_775461 = header.getOrDefault("X-Amz-Algorithm")
  valid_775461 = validateParameter(valid_775461, JString, required = false,
                                 default = nil)
  if valid_775461 != nil:
    section.add "X-Amz-Algorithm", valid_775461
  var valid_775462 = header.getOrDefault("X-Amz-Signature")
  valid_775462 = validateParameter(valid_775462, JString, required = false,
                                 default = nil)
  if valid_775462 != nil:
    section.add "X-Amz-Signature", valid_775462
  var valid_775463 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775463 = validateParameter(valid_775463, JString, required = false,
                                 default = nil)
  if valid_775463 != nil:
    section.add "X-Amz-SignedHeaders", valid_775463
  var valid_775464 = header.getOrDefault("X-Amz-Credential")
  valid_775464 = validateParameter(valid_775464, JString, required = false,
                                 default = nil)
  if valid_775464 != nil:
    section.add "X-Amz-Credential", valid_775464
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775465: Call_ListThingGroups_775450; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the thing groups in your account.
  ## 
  let valid = call_775465.validator(path, query, header, formData, body)
  let scheme = call_775465.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775465.url(scheme.get, call_775465.host, call_775465.base,
                         call_775465.route, valid.getOrDefault("path"))
  result = hook(call_775465, url, valid)

proc call*(call_775466: Call_ListThingGroups_775450; namePrefixFilter: string = "";
          maxResults: int = 0; nextToken: string = ""; recursive: bool = false;
          parentGroup: string = ""): Recallable =
  ## listThingGroups
  ## List the thing groups in your account.
  ##   namePrefixFilter: string
  ##                   : A filter that limits the results to those with the specified name prefix.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   recursive: bool
  ##            : If true, return child groups as well.
  ##   parentGroup: string
  ##              : A filter that limits the results to those with the specified parent group.
  var query_775467 = newJObject()
  add(query_775467, "namePrefixFilter", newJString(namePrefixFilter))
  add(query_775467, "maxResults", newJInt(maxResults))
  add(query_775467, "nextToken", newJString(nextToken))
  add(query_775467, "recursive", newJBool(recursive))
  add(query_775467, "parentGroup", newJString(parentGroup))
  result = call_775466.call(nil, query_775467, nil, nil, nil)

var listThingGroups* = Call_ListThingGroups_775450(name: "listThingGroups",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/thing-groups",
    validator: validate_ListThingGroups_775451, base: "/", url: url_ListThingGroups_775452,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingGroupsForThing_775468 = ref object of OpenApiRestCall_772597
proc url_ListThingGroupsForThing_775470(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/thing-groups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_ListThingGroupsForThing_775469(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List the thing groups to which the specified thing belongs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The thing name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_775471 = path.getOrDefault("thingName")
  valid_775471 = validateParameter(valid_775471, JString, required = true,
                                 default = nil)
  if valid_775471 != nil:
    section.add "thingName", valid_775471
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  var valid_775472 = query.getOrDefault("maxResults")
  valid_775472 = validateParameter(valid_775472, JInt, required = false, default = nil)
  if valid_775472 != nil:
    section.add "maxResults", valid_775472
  var valid_775473 = query.getOrDefault("nextToken")
  valid_775473 = validateParameter(valid_775473, JString, required = false,
                                 default = nil)
  if valid_775473 != nil:
    section.add "nextToken", valid_775473
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775474 = header.getOrDefault("X-Amz-Date")
  valid_775474 = validateParameter(valid_775474, JString, required = false,
                                 default = nil)
  if valid_775474 != nil:
    section.add "X-Amz-Date", valid_775474
  var valid_775475 = header.getOrDefault("X-Amz-Security-Token")
  valid_775475 = validateParameter(valid_775475, JString, required = false,
                                 default = nil)
  if valid_775475 != nil:
    section.add "X-Amz-Security-Token", valid_775475
  var valid_775476 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775476 = validateParameter(valid_775476, JString, required = false,
                                 default = nil)
  if valid_775476 != nil:
    section.add "X-Amz-Content-Sha256", valid_775476
  var valid_775477 = header.getOrDefault("X-Amz-Algorithm")
  valid_775477 = validateParameter(valid_775477, JString, required = false,
                                 default = nil)
  if valid_775477 != nil:
    section.add "X-Amz-Algorithm", valid_775477
  var valid_775478 = header.getOrDefault("X-Amz-Signature")
  valid_775478 = validateParameter(valid_775478, JString, required = false,
                                 default = nil)
  if valid_775478 != nil:
    section.add "X-Amz-Signature", valid_775478
  var valid_775479 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775479 = validateParameter(valid_775479, JString, required = false,
                                 default = nil)
  if valid_775479 != nil:
    section.add "X-Amz-SignedHeaders", valid_775479
  var valid_775480 = header.getOrDefault("X-Amz-Credential")
  valid_775480 = validateParameter(valid_775480, JString, required = false,
                                 default = nil)
  if valid_775480 != nil:
    section.add "X-Amz-Credential", valid_775480
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775481: Call_ListThingGroupsForThing_775468; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the thing groups to which the specified thing belongs.
  ## 
  let valid = call_775481.validator(path, query, header, formData, body)
  let scheme = call_775481.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775481.url(scheme.get, call_775481.host, call_775481.base,
                         call_775481.route, valid.getOrDefault("path"))
  result = hook(call_775481, url, valid)

proc call*(call_775482: Call_ListThingGroupsForThing_775468; thingName: string;
          maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listThingGroupsForThing
  ## List the thing groups to which the specified thing belongs.
  ##   thingName: string (required)
  ##            : The thing name.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var path_775483 = newJObject()
  var query_775484 = newJObject()
  add(path_775483, "thingName", newJString(thingName))
  add(query_775484, "maxResults", newJInt(maxResults))
  add(query_775484, "nextToken", newJString(nextToken))
  result = call_775482.call(path_775483, query_775484, nil, nil, nil)

var listThingGroupsForThing* = Call_ListThingGroupsForThing_775468(
    name: "listThingGroupsForThing", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/thing-groups",
    validator: validate_ListThingGroupsForThing_775469, base: "/",
    url: url_ListThingGroupsForThing_775470, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingPrincipals_775485 = ref object of OpenApiRestCall_772597
proc url_ListThingPrincipals_775487(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_ListThingPrincipals_775486(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_775488 = path.getOrDefault("thingName")
  valid_775488 = validateParameter(valid_775488, JString, required = true,
                                 default = nil)
  if valid_775488 != nil:
    section.add "thingName", valid_775488
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775489 = header.getOrDefault("X-Amz-Date")
  valid_775489 = validateParameter(valid_775489, JString, required = false,
                                 default = nil)
  if valid_775489 != nil:
    section.add "X-Amz-Date", valid_775489
  var valid_775490 = header.getOrDefault("X-Amz-Security-Token")
  valid_775490 = validateParameter(valid_775490, JString, required = false,
                                 default = nil)
  if valid_775490 != nil:
    section.add "X-Amz-Security-Token", valid_775490
  var valid_775491 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775491 = validateParameter(valid_775491, JString, required = false,
                                 default = nil)
  if valid_775491 != nil:
    section.add "X-Amz-Content-Sha256", valid_775491
  var valid_775492 = header.getOrDefault("X-Amz-Algorithm")
  valid_775492 = validateParameter(valid_775492, JString, required = false,
                                 default = nil)
  if valid_775492 != nil:
    section.add "X-Amz-Algorithm", valid_775492
  var valid_775493 = header.getOrDefault("X-Amz-Signature")
  valid_775493 = validateParameter(valid_775493, JString, required = false,
                                 default = nil)
  if valid_775493 != nil:
    section.add "X-Amz-Signature", valid_775493
  var valid_775494 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775494 = validateParameter(valid_775494, JString, required = false,
                                 default = nil)
  if valid_775494 != nil:
    section.add "X-Amz-SignedHeaders", valid_775494
  var valid_775495 = header.getOrDefault("X-Amz-Credential")
  valid_775495 = validateParameter(valid_775495, JString, required = false,
                                 default = nil)
  if valid_775495 != nil:
    section.add "X-Amz-Credential", valid_775495
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775496: Call_ListThingPrincipals_775485; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  let valid = call_775496.validator(path, query, header, formData, body)
  let scheme = call_775496.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775496.url(scheme.get, call_775496.host, call_775496.base,
                         call_775496.route, valid.getOrDefault("path"))
  result = hook(call_775496, url, valid)

proc call*(call_775497: Call_ListThingPrincipals_775485; thingName: string): Recallable =
  ## listThingPrincipals
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_775498 = newJObject()
  add(path_775498, "thingName", newJString(thingName))
  result = call_775497.call(path_775498, nil, nil, nil, nil)

var listThingPrincipals* = Call_ListThingPrincipals_775485(
    name: "listThingPrincipals", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/principals",
    validator: validate_ListThingPrincipals_775486, base: "/",
    url: url_ListThingPrincipals_775487, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingRegistrationTaskReports_775499 = ref object of OpenApiRestCall_772597
proc url_ListThingRegistrationTaskReports_775501(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/reports#reportType")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_ListThingRegistrationTaskReports_775500(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Information about the thing registration tasks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The id of the task.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_775502 = path.getOrDefault("taskId")
  valid_775502 = validateParameter(valid_775502, JString, required = true,
                                 default = nil)
  if valid_775502 != nil:
    section.add "taskId", valid_775502
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   reportType: JString (required)
  ##             : The type of task report.
  section = newJObject()
  var valid_775503 = query.getOrDefault("maxResults")
  valid_775503 = validateParameter(valid_775503, JInt, required = false, default = nil)
  if valid_775503 != nil:
    section.add "maxResults", valid_775503
  var valid_775504 = query.getOrDefault("nextToken")
  valid_775504 = validateParameter(valid_775504, JString, required = false,
                                 default = nil)
  if valid_775504 != nil:
    section.add "nextToken", valid_775504
  assert query != nil,
        "query argument is necessary due to required `reportType` field"
  var valid_775505 = query.getOrDefault("reportType")
  valid_775505 = validateParameter(valid_775505, JString, required = true,
                                 default = newJString("ERRORS"))
  if valid_775505 != nil:
    section.add "reportType", valid_775505
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775506 = header.getOrDefault("X-Amz-Date")
  valid_775506 = validateParameter(valid_775506, JString, required = false,
                                 default = nil)
  if valid_775506 != nil:
    section.add "X-Amz-Date", valid_775506
  var valid_775507 = header.getOrDefault("X-Amz-Security-Token")
  valid_775507 = validateParameter(valid_775507, JString, required = false,
                                 default = nil)
  if valid_775507 != nil:
    section.add "X-Amz-Security-Token", valid_775507
  var valid_775508 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775508 = validateParameter(valid_775508, JString, required = false,
                                 default = nil)
  if valid_775508 != nil:
    section.add "X-Amz-Content-Sha256", valid_775508
  var valid_775509 = header.getOrDefault("X-Amz-Algorithm")
  valid_775509 = validateParameter(valid_775509, JString, required = false,
                                 default = nil)
  if valid_775509 != nil:
    section.add "X-Amz-Algorithm", valid_775509
  var valid_775510 = header.getOrDefault("X-Amz-Signature")
  valid_775510 = validateParameter(valid_775510, JString, required = false,
                                 default = nil)
  if valid_775510 != nil:
    section.add "X-Amz-Signature", valid_775510
  var valid_775511 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775511 = validateParameter(valid_775511, JString, required = false,
                                 default = nil)
  if valid_775511 != nil:
    section.add "X-Amz-SignedHeaders", valid_775511
  var valid_775512 = header.getOrDefault("X-Amz-Credential")
  valid_775512 = validateParameter(valid_775512, JString, required = false,
                                 default = nil)
  if valid_775512 != nil:
    section.add "X-Amz-Credential", valid_775512
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775513: Call_ListThingRegistrationTaskReports_775499;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Information about the thing registration tasks.
  ## 
  let valid = call_775513.validator(path, query, header, formData, body)
  let scheme = call_775513.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775513.url(scheme.get, call_775513.host, call_775513.base,
                         call_775513.route, valid.getOrDefault("path"))
  result = hook(call_775513, url, valid)

proc call*(call_775514: Call_ListThingRegistrationTaskReports_775499;
          taskId: string; maxResults: int = 0; nextToken: string = "";
          reportType: string = "ERRORS"): Recallable =
  ## listThingRegistrationTaskReports
  ## Information about the thing registration tasks.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   reportType: string (required)
  ##             : The type of task report.
  ##   taskId: string (required)
  ##         : The id of the task.
  var path_775515 = newJObject()
  var query_775516 = newJObject()
  add(query_775516, "maxResults", newJInt(maxResults))
  add(query_775516, "nextToken", newJString(nextToken))
  add(query_775516, "reportType", newJString(reportType))
  add(path_775515, "taskId", newJString(taskId))
  result = call_775514.call(path_775515, query_775516, nil, nil, nil)

var listThingRegistrationTaskReports* = Call_ListThingRegistrationTaskReports_775499(
    name: "listThingRegistrationTaskReports", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/thing-registration-tasks/{taskId}/reports#reportType",
    validator: validate_ListThingRegistrationTaskReports_775500, base: "/",
    url: url_ListThingRegistrationTaskReports_775501,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartThingRegistrationTask_775533 = ref object of OpenApiRestCall_772597
proc url_StartThingRegistrationTask_775535(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_StartThingRegistrationTask_775534(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775536 = header.getOrDefault("X-Amz-Date")
  valid_775536 = validateParameter(valid_775536, JString, required = false,
                                 default = nil)
  if valid_775536 != nil:
    section.add "X-Amz-Date", valid_775536
  var valid_775537 = header.getOrDefault("X-Amz-Security-Token")
  valid_775537 = validateParameter(valid_775537, JString, required = false,
                                 default = nil)
  if valid_775537 != nil:
    section.add "X-Amz-Security-Token", valid_775537
  var valid_775538 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775538 = validateParameter(valid_775538, JString, required = false,
                                 default = nil)
  if valid_775538 != nil:
    section.add "X-Amz-Content-Sha256", valid_775538
  var valid_775539 = header.getOrDefault("X-Amz-Algorithm")
  valid_775539 = validateParameter(valid_775539, JString, required = false,
                                 default = nil)
  if valid_775539 != nil:
    section.add "X-Amz-Algorithm", valid_775539
  var valid_775540 = header.getOrDefault("X-Amz-Signature")
  valid_775540 = validateParameter(valid_775540, JString, required = false,
                                 default = nil)
  if valid_775540 != nil:
    section.add "X-Amz-Signature", valid_775540
  var valid_775541 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775541 = validateParameter(valid_775541, JString, required = false,
                                 default = nil)
  if valid_775541 != nil:
    section.add "X-Amz-SignedHeaders", valid_775541
  var valid_775542 = header.getOrDefault("X-Amz-Credential")
  valid_775542 = validateParameter(valid_775542, JString, required = false,
                                 default = nil)
  if valid_775542 != nil:
    section.add "X-Amz-Credential", valid_775542
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775544: Call_StartThingRegistrationTask_775533; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a bulk thing provisioning task.
  ## 
  let valid = call_775544.validator(path, query, header, formData, body)
  let scheme = call_775544.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775544.url(scheme.get, call_775544.host, call_775544.base,
                         call_775544.route, valid.getOrDefault("path"))
  result = hook(call_775544, url, valid)

proc call*(call_775545: Call_StartThingRegistrationTask_775533; body: JsonNode): Recallable =
  ## startThingRegistrationTask
  ## Creates a bulk thing provisioning task.
  ##   body: JObject (required)
  var body_775546 = newJObject()
  if body != nil:
    body_775546 = body
  result = call_775545.call(nil, nil, nil, nil, body_775546)

var startThingRegistrationTask* = Call_StartThingRegistrationTask_775533(
    name: "startThingRegistrationTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks",
    validator: validate_StartThingRegistrationTask_775534, base: "/",
    url: url_StartThingRegistrationTask_775535,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingRegistrationTasks_775517 = ref object of OpenApiRestCall_772597
proc url_ListThingRegistrationTasks_775519(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListThingRegistrationTasks_775518(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List bulk thing provisioning tasks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : The status of the bulk thing provisioning task.
  section = newJObject()
  var valid_775520 = query.getOrDefault("maxResults")
  valid_775520 = validateParameter(valid_775520, JInt, required = false, default = nil)
  if valid_775520 != nil:
    section.add "maxResults", valid_775520
  var valid_775521 = query.getOrDefault("nextToken")
  valid_775521 = validateParameter(valid_775521, JString, required = false,
                                 default = nil)
  if valid_775521 != nil:
    section.add "nextToken", valid_775521
  var valid_775522 = query.getOrDefault("status")
  valid_775522 = validateParameter(valid_775522, JString, required = false,
                                 default = newJString("InProgress"))
  if valid_775522 != nil:
    section.add "status", valid_775522
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775523 = header.getOrDefault("X-Amz-Date")
  valid_775523 = validateParameter(valid_775523, JString, required = false,
                                 default = nil)
  if valid_775523 != nil:
    section.add "X-Amz-Date", valid_775523
  var valid_775524 = header.getOrDefault("X-Amz-Security-Token")
  valid_775524 = validateParameter(valid_775524, JString, required = false,
                                 default = nil)
  if valid_775524 != nil:
    section.add "X-Amz-Security-Token", valid_775524
  var valid_775525 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775525 = validateParameter(valid_775525, JString, required = false,
                                 default = nil)
  if valid_775525 != nil:
    section.add "X-Amz-Content-Sha256", valid_775525
  var valid_775526 = header.getOrDefault("X-Amz-Algorithm")
  valid_775526 = validateParameter(valid_775526, JString, required = false,
                                 default = nil)
  if valid_775526 != nil:
    section.add "X-Amz-Algorithm", valid_775526
  var valid_775527 = header.getOrDefault("X-Amz-Signature")
  valid_775527 = validateParameter(valid_775527, JString, required = false,
                                 default = nil)
  if valid_775527 != nil:
    section.add "X-Amz-Signature", valid_775527
  var valid_775528 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775528 = validateParameter(valid_775528, JString, required = false,
                                 default = nil)
  if valid_775528 != nil:
    section.add "X-Amz-SignedHeaders", valid_775528
  var valid_775529 = header.getOrDefault("X-Amz-Credential")
  valid_775529 = validateParameter(valid_775529, JString, required = false,
                                 default = nil)
  if valid_775529 != nil:
    section.add "X-Amz-Credential", valid_775529
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775530: Call_ListThingRegistrationTasks_775517; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List bulk thing provisioning tasks.
  ## 
  let valid = call_775530.validator(path, query, header, formData, body)
  let scheme = call_775530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775530.url(scheme.get, call_775530.host, call_775530.base,
                         call_775530.route, valid.getOrDefault("path"))
  result = hook(call_775530, url, valid)

proc call*(call_775531: Call_ListThingRegistrationTasks_775517;
          maxResults: int = 0; nextToken: string = ""; status: string = "InProgress"): Recallable =
  ## listThingRegistrationTasks
  ## List bulk thing provisioning tasks.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : The status of the bulk thing provisioning task.
  var query_775532 = newJObject()
  add(query_775532, "maxResults", newJInt(maxResults))
  add(query_775532, "nextToken", newJString(nextToken))
  add(query_775532, "status", newJString(status))
  result = call_775531.call(nil, query_775532, nil, nil, nil)

var listThingRegistrationTasks* = Call_ListThingRegistrationTasks_775517(
    name: "listThingRegistrationTasks", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks",
    validator: validate_ListThingRegistrationTasks_775518, base: "/",
    url: url_ListThingRegistrationTasks_775519,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingTypes_775547 = ref object of OpenApiRestCall_772597
proc url_ListThingTypes_775549(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListThingTypes_775548(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the existing thing types.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingTypeName: JString
  ##                : The name of the thing type.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  var valid_775550 = query.getOrDefault("thingTypeName")
  valid_775550 = validateParameter(valid_775550, JString, required = false,
                                 default = nil)
  if valid_775550 != nil:
    section.add "thingTypeName", valid_775550
  var valid_775551 = query.getOrDefault("maxResults")
  valid_775551 = validateParameter(valid_775551, JInt, required = false, default = nil)
  if valid_775551 != nil:
    section.add "maxResults", valid_775551
  var valid_775552 = query.getOrDefault("nextToken")
  valid_775552 = validateParameter(valid_775552, JString, required = false,
                                 default = nil)
  if valid_775552 != nil:
    section.add "nextToken", valid_775552
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775553 = header.getOrDefault("X-Amz-Date")
  valid_775553 = validateParameter(valid_775553, JString, required = false,
                                 default = nil)
  if valid_775553 != nil:
    section.add "X-Amz-Date", valid_775553
  var valid_775554 = header.getOrDefault("X-Amz-Security-Token")
  valid_775554 = validateParameter(valid_775554, JString, required = false,
                                 default = nil)
  if valid_775554 != nil:
    section.add "X-Amz-Security-Token", valid_775554
  var valid_775555 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775555 = validateParameter(valid_775555, JString, required = false,
                                 default = nil)
  if valid_775555 != nil:
    section.add "X-Amz-Content-Sha256", valid_775555
  var valid_775556 = header.getOrDefault("X-Amz-Algorithm")
  valid_775556 = validateParameter(valid_775556, JString, required = false,
                                 default = nil)
  if valid_775556 != nil:
    section.add "X-Amz-Algorithm", valid_775556
  var valid_775557 = header.getOrDefault("X-Amz-Signature")
  valid_775557 = validateParameter(valid_775557, JString, required = false,
                                 default = nil)
  if valid_775557 != nil:
    section.add "X-Amz-Signature", valid_775557
  var valid_775558 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775558 = validateParameter(valid_775558, JString, required = false,
                                 default = nil)
  if valid_775558 != nil:
    section.add "X-Amz-SignedHeaders", valid_775558
  var valid_775559 = header.getOrDefault("X-Amz-Credential")
  valid_775559 = validateParameter(valid_775559, JString, required = false,
                                 default = nil)
  if valid_775559 != nil:
    section.add "X-Amz-Credential", valid_775559
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775560: Call_ListThingTypes_775547; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the existing thing types.
  ## 
  let valid = call_775560.validator(path, query, header, formData, body)
  let scheme = call_775560.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775560.url(scheme.get, call_775560.host, call_775560.base,
                         call_775560.route, valid.getOrDefault("path"))
  result = hook(call_775560, url, valid)

proc call*(call_775561: Call_ListThingTypes_775547; thingTypeName: string = "";
          maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listThingTypes
  ## Lists the existing thing types.
  ##   thingTypeName: string
  ##                : The name of the thing type.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var query_775562 = newJObject()
  add(query_775562, "thingTypeName", newJString(thingTypeName))
  add(query_775562, "maxResults", newJInt(maxResults))
  add(query_775562, "nextToken", newJString(nextToken))
  result = call_775561.call(nil, query_775562, nil, nil, nil)

var listThingTypes* = Call_ListThingTypes_775547(name: "listThingTypes",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/thing-types",
    validator: validate_ListThingTypes_775548, base: "/", url: url_ListThingTypes_775549,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterThing_775581 = ref object of OpenApiRestCall_772597
proc url_RegisterThing_775583(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_RegisterThing_775582(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Provisions a thing.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775584 = header.getOrDefault("X-Amz-Date")
  valid_775584 = validateParameter(valid_775584, JString, required = false,
                                 default = nil)
  if valid_775584 != nil:
    section.add "X-Amz-Date", valid_775584
  var valid_775585 = header.getOrDefault("X-Amz-Security-Token")
  valid_775585 = validateParameter(valid_775585, JString, required = false,
                                 default = nil)
  if valid_775585 != nil:
    section.add "X-Amz-Security-Token", valid_775585
  var valid_775586 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775586 = validateParameter(valid_775586, JString, required = false,
                                 default = nil)
  if valid_775586 != nil:
    section.add "X-Amz-Content-Sha256", valid_775586
  var valid_775587 = header.getOrDefault("X-Amz-Algorithm")
  valid_775587 = validateParameter(valid_775587, JString, required = false,
                                 default = nil)
  if valid_775587 != nil:
    section.add "X-Amz-Algorithm", valid_775587
  var valid_775588 = header.getOrDefault("X-Amz-Signature")
  valid_775588 = validateParameter(valid_775588, JString, required = false,
                                 default = nil)
  if valid_775588 != nil:
    section.add "X-Amz-Signature", valid_775588
  var valid_775589 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775589 = validateParameter(valid_775589, JString, required = false,
                                 default = nil)
  if valid_775589 != nil:
    section.add "X-Amz-SignedHeaders", valid_775589
  var valid_775590 = header.getOrDefault("X-Amz-Credential")
  valid_775590 = validateParameter(valid_775590, JString, required = false,
                                 default = nil)
  if valid_775590 != nil:
    section.add "X-Amz-Credential", valid_775590
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775592: Call_RegisterThing_775581; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Provisions a thing.
  ## 
  let valid = call_775592.validator(path, query, header, formData, body)
  let scheme = call_775592.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775592.url(scheme.get, call_775592.host, call_775592.base,
                         call_775592.route, valid.getOrDefault("path"))
  result = hook(call_775592, url, valid)

proc call*(call_775593: Call_RegisterThing_775581; body: JsonNode): Recallable =
  ## registerThing
  ## Provisions a thing.
  ##   body: JObject (required)
  var body_775594 = newJObject()
  if body != nil:
    body_775594 = body
  result = call_775593.call(nil, nil, nil, nil, body_775594)

var registerThing* = Call_RegisterThing_775581(name: "registerThing",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/things",
    validator: validate_RegisterThing_775582, base: "/", url: url_RegisterThing_775583,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThings_775563 = ref object of OpenApiRestCall_772597
proc url_ListThings_775565(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListThings_775564(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingTypeName: JString
  ##                : The name of the thing type used to search for things.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   attributeValue: JString
  ##                 : The attribute value used to search for things.
  ##   attributeName: JString
  ##                : The attribute name used to search for things.
  section = newJObject()
  var valid_775566 = query.getOrDefault("thingTypeName")
  valid_775566 = validateParameter(valid_775566, JString, required = false,
                                 default = nil)
  if valid_775566 != nil:
    section.add "thingTypeName", valid_775566
  var valid_775567 = query.getOrDefault("maxResults")
  valid_775567 = validateParameter(valid_775567, JInt, required = false, default = nil)
  if valid_775567 != nil:
    section.add "maxResults", valid_775567
  var valid_775568 = query.getOrDefault("nextToken")
  valid_775568 = validateParameter(valid_775568, JString, required = false,
                                 default = nil)
  if valid_775568 != nil:
    section.add "nextToken", valid_775568
  var valid_775569 = query.getOrDefault("attributeValue")
  valid_775569 = validateParameter(valid_775569, JString, required = false,
                                 default = nil)
  if valid_775569 != nil:
    section.add "attributeValue", valid_775569
  var valid_775570 = query.getOrDefault("attributeName")
  valid_775570 = validateParameter(valid_775570, JString, required = false,
                                 default = nil)
  if valid_775570 != nil:
    section.add "attributeName", valid_775570
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775571 = header.getOrDefault("X-Amz-Date")
  valid_775571 = validateParameter(valid_775571, JString, required = false,
                                 default = nil)
  if valid_775571 != nil:
    section.add "X-Amz-Date", valid_775571
  var valid_775572 = header.getOrDefault("X-Amz-Security-Token")
  valid_775572 = validateParameter(valid_775572, JString, required = false,
                                 default = nil)
  if valid_775572 != nil:
    section.add "X-Amz-Security-Token", valid_775572
  var valid_775573 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775573 = validateParameter(valid_775573, JString, required = false,
                                 default = nil)
  if valid_775573 != nil:
    section.add "X-Amz-Content-Sha256", valid_775573
  var valid_775574 = header.getOrDefault("X-Amz-Algorithm")
  valid_775574 = validateParameter(valid_775574, JString, required = false,
                                 default = nil)
  if valid_775574 != nil:
    section.add "X-Amz-Algorithm", valid_775574
  var valid_775575 = header.getOrDefault("X-Amz-Signature")
  valid_775575 = validateParameter(valid_775575, JString, required = false,
                                 default = nil)
  if valid_775575 != nil:
    section.add "X-Amz-Signature", valid_775575
  var valid_775576 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775576 = validateParameter(valid_775576, JString, required = false,
                                 default = nil)
  if valid_775576 != nil:
    section.add "X-Amz-SignedHeaders", valid_775576
  var valid_775577 = header.getOrDefault("X-Amz-Credential")
  valid_775577 = validateParameter(valid_775577, JString, required = false,
                                 default = nil)
  if valid_775577 != nil:
    section.add "X-Amz-Credential", valid_775577
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775578: Call_ListThings_775563; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ## 
  let valid = call_775578.validator(path, query, header, formData, body)
  let scheme = call_775578.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775578.url(scheme.get, call_775578.host, call_775578.base,
                         call_775578.route, valid.getOrDefault("path"))
  result = hook(call_775578, url, valid)

proc call*(call_775579: Call_ListThings_775563; thingTypeName: string = "";
          maxResults: int = 0; nextToken: string = ""; attributeValue: string = "";
          attributeName: string = ""): Recallable =
  ## listThings
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ##   thingTypeName: string
  ##                : The name of the thing type used to search for things.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   attributeValue: string
  ##                 : The attribute value used to search for things.
  ##   attributeName: string
  ##                : The attribute name used to search for things.
  var query_775580 = newJObject()
  add(query_775580, "thingTypeName", newJString(thingTypeName))
  add(query_775580, "maxResults", newJInt(maxResults))
  add(query_775580, "nextToken", newJString(nextToken))
  add(query_775580, "attributeValue", newJString(attributeValue))
  add(query_775580, "attributeName", newJString(attributeName))
  result = call_775579.call(nil, query_775580, nil, nil, nil)

var listThings* = Call_ListThings_775563(name: "listThings",
                                      meth: HttpMethod.HttpGet,
                                      host: "iot.amazonaws.com", route: "/things",
                                      validator: validate_ListThings_775564,
                                      base: "/", url: url_ListThings_775565,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingsInBillingGroup_775595 = ref object of OpenApiRestCall_772597
proc url_ListThingsInBillingGroup_775597(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_ListThingsInBillingGroup_775596(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the things you have added to the given billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_775598 = path.getOrDefault("billingGroupName")
  valid_775598 = validateParameter(valid_775598, JString, required = true,
                                 default = nil)
  if valid_775598 != nil:
    section.add "billingGroupName", valid_775598
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  var valid_775599 = query.getOrDefault("maxResults")
  valid_775599 = validateParameter(valid_775599, JInt, required = false, default = nil)
  if valid_775599 != nil:
    section.add "maxResults", valid_775599
  var valid_775600 = query.getOrDefault("nextToken")
  valid_775600 = validateParameter(valid_775600, JString, required = false,
                                 default = nil)
  if valid_775600 != nil:
    section.add "nextToken", valid_775600
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775601 = header.getOrDefault("X-Amz-Date")
  valid_775601 = validateParameter(valid_775601, JString, required = false,
                                 default = nil)
  if valid_775601 != nil:
    section.add "X-Amz-Date", valid_775601
  var valid_775602 = header.getOrDefault("X-Amz-Security-Token")
  valid_775602 = validateParameter(valid_775602, JString, required = false,
                                 default = nil)
  if valid_775602 != nil:
    section.add "X-Amz-Security-Token", valid_775602
  var valid_775603 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775603 = validateParameter(valid_775603, JString, required = false,
                                 default = nil)
  if valid_775603 != nil:
    section.add "X-Amz-Content-Sha256", valid_775603
  var valid_775604 = header.getOrDefault("X-Amz-Algorithm")
  valid_775604 = validateParameter(valid_775604, JString, required = false,
                                 default = nil)
  if valid_775604 != nil:
    section.add "X-Amz-Algorithm", valid_775604
  var valid_775605 = header.getOrDefault("X-Amz-Signature")
  valid_775605 = validateParameter(valid_775605, JString, required = false,
                                 default = nil)
  if valid_775605 != nil:
    section.add "X-Amz-Signature", valid_775605
  var valid_775606 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775606 = validateParameter(valid_775606, JString, required = false,
                                 default = nil)
  if valid_775606 != nil:
    section.add "X-Amz-SignedHeaders", valid_775606
  var valid_775607 = header.getOrDefault("X-Amz-Credential")
  valid_775607 = validateParameter(valid_775607, JString, required = false,
                                 default = nil)
  if valid_775607 != nil:
    section.add "X-Amz-Credential", valid_775607
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775608: Call_ListThingsInBillingGroup_775595; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things you have added to the given billing group.
  ## 
  let valid = call_775608.validator(path, query, header, formData, body)
  let scheme = call_775608.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775608.url(scheme.get, call_775608.host, call_775608.base,
                         call_775608.route, valid.getOrDefault("path"))
  result = hook(call_775608, url, valid)

proc call*(call_775609: Call_ListThingsInBillingGroup_775595;
          billingGroupName: string; maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listThingsInBillingGroup
  ## Lists the things you have added to the given billing group.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var path_775610 = newJObject()
  var query_775611 = newJObject()
  add(path_775610, "billingGroupName", newJString(billingGroupName))
  add(query_775611, "maxResults", newJInt(maxResults))
  add(query_775611, "nextToken", newJString(nextToken))
  result = call_775609.call(path_775610, query_775611, nil, nil, nil)

var listThingsInBillingGroup* = Call_ListThingsInBillingGroup_775595(
    name: "listThingsInBillingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}/things",
    validator: validate_ListThingsInBillingGroup_775596, base: "/",
    url: url_ListThingsInBillingGroup_775597, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingsInThingGroup_775612 = ref object of OpenApiRestCall_772597
proc url_ListThingsInThingGroup_775614(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_ListThingsInThingGroup_775613(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the things in the specified group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_775615 = path.getOrDefault("thingGroupName")
  valid_775615 = validateParameter(valid_775615, JString, required = true,
                                 default = nil)
  if valid_775615 != nil:
    section.add "thingGroupName", valid_775615
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   recursive: JBool
  ##            : When true, list things in this thing group and in all child groups as well.
  section = newJObject()
  var valid_775616 = query.getOrDefault("maxResults")
  valid_775616 = validateParameter(valid_775616, JInt, required = false, default = nil)
  if valid_775616 != nil:
    section.add "maxResults", valid_775616
  var valid_775617 = query.getOrDefault("nextToken")
  valid_775617 = validateParameter(valid_775617, JString, required = false,
                                 default = nil)
  if valid_775617 != nil:
    section.add "nextToken", valid_775617
  var valid_775618 = query.getOrDefault("recursive")
  valid_775618 = validateParameter(valid_775618, JBool, required = false, default = nil)
  if valid_775618 != nil:
    section.add "recursive", valid_775618
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775619 = header.getOrDefault("X-Amz-Date")
  valid_775619 = validateParameter(valid_775619, JString, required = false,
                                 default = nil)
  if valid_775619 != nil:
    section.add "X-Amz-Date", valid_775619
  var valid_775620 = header.getOrDefault("X-Amz-Security-Token")
  valid_775620 = validateParameter(valid_775620, JString, required = false,
                                 default = nil)
  if valid_775620 != nil:
    section.add "X-Amz-Security-Token", valid_775620
  var valid_775621 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775621 = validateParameter(valid_775621, JString, required = false,
                                 default = nil)
  if valid_775621 != nil:
    section.add "X-Amz-Content-Sha256", valid_775621
  var valid_775622 = header.getOrDefault("X-Amz-Algorithm")
  valid_775622 = validateParameter(valid_775622, JString, required = false,
                                 default = nil)
  if valid_775622 != nil:
    section.add "X-Amz-Algorithm", valid_775622
  var valid_775623 = header.getOrDefault("X-Amz-Signature")
  valid_775623 = validateParameter(valid_775623, JString, required = false,
                                 default = nil)
  if valid_775623 != nil:
    section.add "X-Amz-Signature", valid_775623
  var valid_775624 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775624 = validateParameter(valid_775624, JString, required = false,
                                 default = nil)
  if valid_775624 != nil:
    section.add "X-Amz-SignedHeaders", valid_775624
  var valid_775625 = header.getOrDefault("X-Amz-Credential")
  valid_775625 = validateParameter(valid_775625, JString, required = false,
                                 default = nil)
  if valid_775625 != nil:
    section.add "X-Amz-Credential", valid_775625
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775626: Call_ListThingsInThingGroup_775612; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things in the specified group.
  ## 
  let valid = call_775626.validator(path, query, header, formData, body)
  let scheme = call_775626.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775626.url(scheme.get, call_775626.host, call_775626.base,
                         call_775626.route, valid.getOrDefault("path"))
  result = hook(call_775626, url, valid)

proc call*(call_775627: Call_ListThingsInThingGroup_775612; thingGroupName: string;
          maxResults: int = 0; nextToken: string = ""; recursive: bool = false): Recallable =
  ## listThingsInThingGroup
  ## Lists the things in the specified group.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: string (required)
  ##                 : The thing group name.
  ##   recursive: bool
  ##            : When true, list things in this thing group and in all child groups as well.
  var path_775628 = newJObject()
  var query_775629 = newJObject()
  add(query_775629, "maxResults", newJInt(maxResults))
  add(query_775629, "nextToken", newJString(nextToken))
  add(path_775628, "thingGroupName", newJString(thingGroupName))
  add(query_775629, "recursive", newJBool(recursive))
  result = call_775627.call(path_775628, query_775629, nil, nil, nil)

var listThingsInThingGroup* = Call_ListThingsInThingGroup_775612(
    name: "listThingsInThingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-groups/{thingGroupName}/things",
    validator: validate_ListThingsInThingGroup_775613, base: "/",
    url: url_ListThingsInThingGroup_775614, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTopicRules_775630 = ref object of OpenApiRestCall_772597
proc url_ListTopicRules_775632(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListTopicRules_775631(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the rules for the specific topic.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return.
  ##   nextToken: JString
  ##            : A token used to retrieve the next value.
  ##   topic: JString
  ##        : The topic.
  ##   ruleDisabled: JBool
  ##               : Specifies whether the rule is disabled.
  section = newJObject()
  var valid_775633 = query.getOrDefault("maxResults")
  valid_775633 = validateParameter(valid_775633, JInt, required = false, default = nil)
  if valid_775633 != nil:
    section.add "maxResults", valid_775633
  var valid_775634 = query.getOrDefault("nextToken")
  valid_775634 = validateParameter(valid_775634, JString, required = false,
                                 default = nil)
  if valid_775634 != nil:
    section.add "nextToken", valid_775634
  var valid_775635 = query.getOrDefault("topic")
  valid_775635 = validateParameter(valid_775635, JString, required = false,
                                 default = nil)
  if valid_775635 != nil:
    section.add "topic", valid_775635
  var valid_775636 = query.getOrDefault("ruleDisabled")
  valid_775636 = validateParameter(valid_775636, JBool, required = false, default = nil)
  if valid_775636 != nil:
    section.add "ruleDisabled", valid_775636
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775637 = header.getOrDefault("X-Amz-Date")
  valid_775637 = validateParameter(valid_775637, JString, required = false,
                                 default = nil)
  if valid_775637 != nil:
    section.add "X-Amz-Date", valid_775637
  var valid_775638 = header.getOrDefault("X-Amz-Security-Token")
  valid_775638 = validateParameter(valid_775638, JString, required = false,
                                 default = nil)
  if valid_775638 != nil:
    section.add "X-Amz-Security-Token", valid_775638
  var valid_775639 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775639 = validateParameter(valid_775639, JString, required = false,
                                 default = nil)
  if valid_775639 != nil:
    section.add "X-Amz-Content-Sha256", valid_775639
  var valid_775640 = header.getOrDefault("X-Amz-Algorithm")
  valid_775640 = validateParameter(valid_775640, JString, required = false,
                                 default = nil)
  if valid_775640 != nil:
    section.add "X-Amz-Algorithm", valid_775640
  var valid_775641 = header.getOrDefault("X-Amz-Signature")
  valid_775641 = validateParameter(valid_775641, JString, required = false,
                                 default = nil)
  if valid_775641 != nil:
    section.add "X-Amz-Signature", valid_775641
  var valid_775642 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775642 = validateParameter(valid_775642, JString, required = false,
                                 default = nil)
  if valid_775642 != nil:
    section.add "X-Amz-SignedHeaders", valid_775642
  var valid_775643 = header.getOrDefault("X-Amz-Credential")
  valid_775643 = validateParameter(valid_775643, JString, required = false,
                                 default = nil)
  if valid_775643 != nil:
    section.add "X-Amz-Credential", valid_775643
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775644: Call_ListTopicRules_775630; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the rules for the specific topic.
  ## 
  let valid = call_775644.validator(path, query, header, formData, body)
  let scheme = call_775644.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775644.url(scheme.get, call_775644.host, call_775644.base,
                         call_775644.route, valid.getOrDefault("path"))
  result = hook(call_775644, url, valid)

proc call*(call_775645: Call_ListTopicRules_775630; maxResults: int = 0;
          nextToken: string = ""; topic: string = ""; ruleDisabled: bool = false): Recallable =
  ## listTopicRules
  ## Lists the rules for the specific topic.
  ##   maxResults: int
  ##             : The maximum number of results to return.
  ##   nextToken: string
  ##            : A token used to retrieve the next value.
  ##   topic: string
  ##        : The topic.
  ##   ruleDisabled: bool
  ##               : Specifies whether the rule is disabled.
  var query_775646 = newJObject()
  add(query_775646, "maxResults", newJInt(maxResults))
  add(query_775646, "nextToken", newJString(nextToken))
  add(query_775646, "topic", newJString(topic))
  add(query_775646, "ruleDisabled", newJBool(ruleDisabled))
  result = call_775645.call(nil, query_775646, nil, nil, nil)

var listTopicRules* = Call_ListTopicRules_775630(name: "listTopicRules",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/rules",
    validator: validate_ListTopicRules_775631, base: "/", url: url_ListTopicRules_775632,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetV2LoggingLevel_775663 = ref object of OpenApiRestCall_772597
proc url_SetV2LoggingLevel_775665(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_SetV2LoggingLevel_775664(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Sets the logging level.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775666 = header.getOrDefault("X-Amz-Date")
  valid_775666 = validateParameter(valid_775666, JString, required = false,
                                 default = nil)
  if valid_775666 != nil:
    section.add "X-Amz-Date", valid_775666
  var valid_775667 = header.getOrDefault("X-Amz-Security-Token")
  valid_775667 = validateParameter(valid_775667, JString, required = false,
                                 default = nil)
  if valid_775667 != nil:
    section.add "X-Amz-Security-Token", valid_775667
  var valid_775668 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775668 = validateParameter(valid_775668, JString, required = false,
                                 default = nil)
  if valid_775668 != nil:
    section.add "X-Amz-Content-Sha256", valid_775668
  var valid_775669 = header.getOrDefault("X-Amz-Algorithm")
  valid_775669 = validateParameter(valid_775669, JString, required = false,
                                 default = nil)
  if valid_775669 != nil:
    section.add "X-Amz-Algorithm", valid_775669
  var valid_775670 = header.getOrDefault("X-Amz-Signature")
  valid_775670 = validateParameter(valid_775670, JString, required = false,
                                 default = nil)
  if valid_775670 != nil:
    section.add "X-Amz-Signature", valid_775670
  var valid_775671 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775671 = validateParameter(valid_775671, JString, required = false,
                                 default = nil)
  if valid_775671 != nil:
    section.add "X-Amz-SignedHeaders", valid_775671
  var valid_775672 = header.getOrDefault("X-Amz-Credential")
  valid_775672 = validateParameter(valid_775672, JString, required = false,
                                 default = nil)
  if valid_775672 != nil:
    section.add "X-Amz-Credential", valid_775672
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775674: Call_SetV2LoggingLevel_775663; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the logging level.
  ## 
  let valid = call_775674.validator(path, query, header, formData, body)
  let scheme = call_775674.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775674.url(scheme.get, call_775674.host, call_775674.base,
                         call_775674.route, valid.getOrDefault("path"))
  result = hook(call_775674, url, valid)

proc call*(call_775675: Call_SetV2LoggingLevel_775663; body: JsonNode): Recallable =
  ## setV2LoggingLevel
  ## Sets the logging level.
  ##   body: JObject (required)
  var body_775676 = newJObject()
  if body != nil:
    body_775676 = body
  result = call_775675.call(nil, nil, nil, nil, body_775676)

var setV2LoggingLevel* = Call_SetV2LoggingLevel_775663(name: "setV2LoggingLevel",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/v2LoggingLevel",
    validator: validate_SetV2LoggingLevel_775664, base: "/",
    url: url_SetV2LoggingLevel_775665, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListV2LoggingLevels_775647 = ref object of OpenApiRestCall_772597
proc url_ListV2LoggingLevels_775649(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListV2LoggingLevels_775648(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists logging levels.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   targetType: JString
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token used to get the next set of results, or <b>null</b> if there are no additional results.
  section = newJObject()
  var valid_775650 = query.getOrDefault("targetType")
  valid_775650 = validateParameter(valid_775650, JString, required = false,
                                 default = newJString("DEFAULT"))
  if valid_775650 != nil:
    section.add "targetType", valid_775650
  var valid_775651 = query.getOrDefault("maxResults")
  valid_775651 = validateParameter(valid_775651, JInt, required = false, default = nil)
  if valid_775651 != nil:
    section.add "maxResults", valid_775651
  var valid_775652 = query.getOrDefault("nextToken")
  valid_775652 = validateParameter(valid_775652, JString, required = false,
                                 default = nil)
  if valid_775652 != nil:
    section.add "nextToken", valid_775652
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775653 = header.getOrDefault("X-Amz-Date")
  valid_775653 = validateParameter(valid_775653, JString, required = false,
                                 default = nil)
  if valid_775653 != nil:
    section.add "X-Amz-Date", valid_775653
  var valid_775654 = header.getOrDefault("X-Amz-Security-Token")
  valid_775654 = validateParameter(valid_775654, JString, required = false,
                                 default = nil)
  if valid_775654 != nil:
    section.add "X-Amz-Security-Token", valid_775654
  var valid_775655 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775655 = validateParameter(valid_775655, JString, required = false,
                                 default = nil)
  if valid_775655 != nil:
    section.add "X-Amz-Content-Sha256", valid_775655
  var valid_775656 = header.getOrDefault("X-Amz-Algorithm")
  valid_775656 = validateParameter(valid_775656, JString, required = false,
                                 default = nil)
  if valid_775656 != nil:
    section.add "X-Amz-Algorithm", valid_775656
  var valid_775657 = header.getOrDefault("X-Amz-Signature")
  valid_775657 = validateParameter(valid_775657, JString, required = false,
                                 default = nil)
  if valid_775657 != nil:
    section.add "X-Amz-Signature", valid_775657
  var valid_775658 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775658 = validateParameter(valid_775658, JString, required = false,
                                 default = nil)
  if valid_775658 != nil:
    section.add "X-Amz-SignedHeaders", valid_775658
  var valid_775659 = header.getOrDefault("X-Amz-Credential")
  valid_775659 = validateParameter(valid_775659, JString, required = false,
                                 default = nil)
  if valid_775659 != nil:
    section.add "X-Amz-Credential", valid_775659
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775660: Call_ListV2LoggingLevels_775647; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists logging levels.
  ## 
  let valid = call_775660.validator(path, query, header, formData, body)
  let scheme = call_775660.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775660.url(scheme.get, call_775660.host, call_775660.base,
                         call_775660.route, valid.getOrDefault("path"))
  result = hook(call_775660, url, valid)

proc call*(call_775661: Call_ListV2LoggingLevels_775647;
          targetType: string = "DEFAULT"; maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listV2LoggingLevels
  ## Lists logging levels.
  ##   targetType: string
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token used to get the next set of results, or <b>null</b> if there are no additional results.
  var query_775662 = newJObject()
  add(query_775662, "targetType", newJString(targetType))
  add(query_775662, "maxResults", newJInt(maxResults))
  add(query_775662, "nextToken", newJString(nextToken))
  result = call_775661.call(nil, query_775662, nil, nil, nil)

var listV2LoggingLevels* = Call_ListV2LoggingLevels_775647(
    name: "listV2LoggingLevels", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/v2LoggingLevel",
    validator: validate_ListV2LoggingLevels_775648, base: "/",
    url: url_ListV2LoggingLevels_775649, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListViolationEvents_775677 = ref object of OpenApiRestCall_772597
proc url_ListViolationEvents_775679(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ListViolationEvents_775678(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingName: JString
  ##            : A filter to limit results to those alerts caused by the specified thing.
  ##   endTime: JString (required)
  ##          : The end time for the alerts to be listed.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   securityProfileName: JString
  ##                      : A filter to limit results to those alerts generated by the specified security profile.
  ##   startTime: JString (required)
  ##            : The start time for the alerts to be listed.
  section = newJObject()
  var valid_775680 = query.getOrDefault("thingName")
  valid_775680 = validateParameter(valid_775680, JString, required = false,
                                 default = nil)
  if valid_775680 != nil:
    section.add "thingName", valid_775680
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_775681 = query.getOrDefault("endTime")
  valid_775681 = validateParameter(valid_775681, JString, required = true,
                                 default = nil)
  if valid_775681 != nil:
    section.add "endTime", valid_775681
  var valid_775682 = query.getOrDefault("maxResults")
  valid_775682 = validateParameter(valid_775682, JInt, required = false, default = nil)
  if valid_775682 != nil:
    section.add "maxResults", valid_775682
  var valid_775683 = query.getOrDefault("nextToken")
  valid_775683 = validateParameter(valid_775683, JString, required = false,
                                 default = nil)
  if valid_775683 != nil:
    section.add "nextToken", valid_775683
  var valid_775684 = query.getOrDefault("securityProfileName")
  valid_775684 = validateParameter(valid_775684, JString, required = false,
                                 default = nil)
  if valid_775684 != nil:
    section.add "securityProfileName", valid_775684
  var valid_775685 = query.getOrDefault("startTime")
  valid_775685 = validateParameter(valid_775685, JString, required = true,
                                 default = nil)
  if valid_775685 != nil:
    section.add "startTime", valid_775685
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775686 = header.getOrDefault("X-Amz-Date")
  valid_775686 = validateParameter(valid_775686, JString, required = false,
                                 default = nil)
  if valid_775686 != nil:
    section.add "X-Amz-Date", valid_775686
  var valid_775687 = header.getOrDefault("X-Amz-Security-Token")
  valid_775687 = validateParameter(valid_775687, JString, required = false,
                                 default = nil)
  if valid_775687 != nil:
    section.add "X-Amz-Security-Token", valid_775687
  var valid_775688 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775688 = validateParameter(valid_775688, JString, required = false,
                                 default = nil)
  if valid_775688 != nil:
    section.add "X-Amz-Content-Sha256", valid_775688
  var valid_775689 = header.getOrDefault("X-Amz-Algorithm")
  valid_775689 = validateParameter(valid_775689, JString, required = false,
                                 default = nil)
  if valid_775689 != nil:
    section.add "X-Amz-Algorithm", valid_775689
  var valid_775690 = header.getOrDefault("X-Amz-Signature")
  valid_775690 = validateParameter(valid_775690, JString, required = false,
                                 default = nil)
  if valid_775690 != nil:
    section.add "X-Amz-Signature", valid_775690
  var valid_775691 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775691 = validateParameter(valid_775691, JString, required = false,
                                 default = nil)
  if valid_775691 != nil:
    section.add "X-Amz-SignedHeaders", valid_775691
  var valid_775692 = header.getOrDefault("X-Amz-Credential")
  valid_775692 = validateParameter(valid_775692, JString, required = false,
                                 default = nil)
  if valid_775692 != nil:
    section.add "X-Amz-Credential", valid_775692
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775693: Call_ListViolationEvents_775677; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ## 
  let valid = call_775693.validator(path, query, header, formData, body)
  let scheme = call_775693.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775693.url(scheme.get, call_775693.host, call_775693.base,
                         call_775693.route, valid.getOrDefault("path"))
  result = hook(call_775693, url, valid)

proc call*(call_775694: Call_ListViolationEvents_775677; endTime: string;
          startTime: string; thingName: string = ""; maxResults: int = 0;
          nextToken: string = ""; securityProfileName: string = ""): Recallable =
  ## listViolationEvents
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ##   thingName: string
  ##            : A filter to limit results to those alerts caused by the specified thing.
  ##   endTime: string (required)
  ##          : The end time for the alerts to be listed.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string
  ##                      : A filter to limit results to those alerts generated by the specified security profile.
  ##   startTime: string (required)
  ##            : The start time for the alerts to be listed.
  var query_775695 = newJObject()
  add(query_775695, "thingName", newJString(thingName))
  add(query_775695, "endTime", newJString(endTime))
  add(query_775695, "maxResults", newJInt(maxResults))
  add(query_775695, "nextToken", newJString(nextToken))
  add(query_775695, "securityProfileName", newJString(securityProfileName))
  add(query_775695, "startTime", newJString(startTime))
  result = call_775694.call(nil, query_775695, nil, nil, nil)

var listViolationEvents* = Call_ListViolationEvents_775677(
    name: "listViolationEvents", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/violation-events#startTime&endTime",
    validator: validate_ListViolationEvents_775678, base: "/",
    url: url_ListViolationEvents_775679, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterCACertificate_775696 = ref object of OpenApiRestCall_772597
proc url_RegisterCACertificate_775698(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_RegisterCACertificate_775697(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : A boolean value that specifies if the CA certificate is set to active.
  ##   allowAutoRegistration: JBool
  ##                        : Allows this CA certificate to be used for auto registration of device certificates.
  section = newJObject()
  var valid_775699 = query.getOrDefault("setAsActive")
  valid_775699 = validateParameter(valid_775699, JBool, required = false, default = nil)
  if valid_775699 != nil:
    section.add "setAsActive", valid_775699
  var valid_775700 = query.getOrDefault("allowAutoRegistration")
  valid_775700 = validateParameter(valid_775700, JBool, required = false, default = nil)
  if valid_775700 != nil:
    section.add "allowAutoRegistration", valid_775700
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775701 = header.getOrDefault("X-Amz-Date")
  valid_775701 = validateParameter(valid_775701, JString, required = false,
                                 default = nil)
  if valid_775701 != nil:
    section.add "X-Amz-Date", valid_775701
  var valid_775702 = header.getOrDefault("X-Amz-Security-Token")
  valid_775702 = validateParameter(valid_775702, JString, required = false,
                                 default = nil)
  if valid_775702 != nil:
    section.add "X-Amz-Security-Token", valid_775702
  var valid_775703 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775703 = validateParameter(valid_775703, JString, required = false,
                                 default = nil)
  if valid_775703 != nil:
    section.add "X-Amz-Content-Sha256", valid_775703
  var valid_775704 = header.getOrDefault("X-Amz-Algorithm")
  valid_775704 = validateParameter(valid_775704, JString, required = false,
                                 default = nil)
  if valid_775704 != nil:
    section.add "X-Amz-Algorithm", valid_775704
  var valid_775705 = header.getOrDefault("X-Amz-Signature")
  valid_775705 = validateParameter(valid_775705, JString, required = false,
                                 default = nil)
  if valid_775705 != nil:
    section.add "X-Amz-Signature", valid_775705
  var valid_775706 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775706 = validateParameter(valid_775706, JString, required = false,
                                 default = nil)
  if valid_775706 != nil:
    section.add "X-Amz-SignedHeaders", valid_775706
  var valid_775707 = header.getOrDefault("X-Amz-Credential")
  valid_775707 = validateParameter(valid_775707, JString, required = false,
                                 default = nil)
  if valid_775707 != nil:
    section.add "X-Amz-Credential", valid_775707
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775709: Call_RegisterCACertificate_775696; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ## 
  let valid = call_775709.validator(path, query, header, formData, body)
  let scheme = call_775709.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775709.url(scheme.get, call_775709.host, call_775709.base,
                         call_775709.route, valid.getOrDefault("path"))
  result = hook(call_775709, url, valid)

proc call*(call_775710: Call_RegisterCACertificate_775696; body: JsonNode;
          setAsActive: bool = false; allowAutoRegistration: bool = false): Recallable =
  ## registerCACertificate
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ##   setAsActive: bool
  ##              : A boolean value that specifies if the CA certificate is set to active.
  ##   body: JObject (required)
  ##   allowAutoRegistration: bool
  ##                        : Allows this CA certificate to be used for auto registration of device certificates.
  var query_775711 = newJObject()
  var body_775712 = newJObject()
  add(query_775711, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_775712 = body
  add(query_775711, "allowAutoRegistration", newJBool(allowAutoRegistration))
  result = call_775710.call(nil, query_775711, nil, nil, body_775712)

var registerCACertificate* = Call_RegisterCACertificate_775696(
    name: "registerCACertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/cacertificate",
    validator: validate_RegisterCACertificate_775697, base: "/",
    url: url_RegisterCACertificate_775698, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterCertificate_775713 = ref object of OpenApiRestCall_772597
proc url_RegisterCertificate_775715(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_RegisterCertificate_775714(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : A boolean value that specifies if the certificate is set to active.
  section = newJObject()
  var valid_775716 = query.getOrDefault("setAsActive")
  valid_775716 = validateParameter(valid_775716, JBool, required = false, default = nil)
  if valid_775716 != nil:
    section.add "setAsActive", valid_775716
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775717 = header.getOrDefault("X-Amz-Date")
  valid_775717 = validateParameter(valid_775717, JString, required = false,
                                 default = nil)
  if valid_775717 != nil:
    section.add "X-Amz-Date", valid_775717
  var valid_775718 = header.getOrDefault("X-Amz-Security-Token")
  valid_775718 = validateParameter(valid_775718, JString, required = false,
                                 default = nil)
  if valid_775718 != nil:
    section.add "X-Amz-Security-Token", valid_775718
  var valid_775719 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775719 = validateParameter(valid_775719, JString, required = false,
                                 default = nil)
  if valid_775719 != nil:
    section.add "X-Amz-Content-Sha256", valid_775719
  var valid_775720 = header.getOrDefault("X-Amz-Algorithm")
  valid_775720 = validateParameter(valid_775720, JString, required = false,
                                 default = nil)
  if valid_775720 != nil:
    section.add "X-Amz-Algorithm", valid_775720
  var valid_775721 = header.getOrDefault("X-Amz-Signature")
  valid_775721 = validateParameter(valid_775721, JString, required = false,
                                 default = nil)
  if valid_775721 != nil:
    section.add "X-Amz-Signature", valid_775721
  var valid_775722 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775722 = validateParameter(valid_775722, JString, required = false,
                                 default = nil)
  if valid_775722 != nil:
    section.add "X-Amz-SignedHeaders", valid_775722
  var valid_775723 = header.getOrDefault("X-Amz-Credential")
  valid_775723 = validateParameter(valid_775723, JString, required = false,
                                 default = nil)
  if valid_775723 != nil:
    section.add "X-Amz-Credential", valid_775723
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775725: Call_RegisterCertificate_775713; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ## 
  let valid = call_775725.validator(path, query, header, formData, body)
  let scheme = call_775725.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775725.url(scheme.get, call_775725.host, call_775725.base,
                         call_775725.route, valid.getOrDefault("path"))
  result = hook(call_775725, url, valid)

proc call*(call_775726: Call_RegisterCertificate_775713; body: JsonNode;
          setAsActive: bool = false): Recallable =
  ## registerCertificate
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ##   setAsActive: bool
  ##              : A boolean value that specifies if the certificate is set to active.
  ##   body: JObject (required)
  var query_775727 = newJObject()
  var body_775728 = newJObject()
  add(query_775727, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_775728 = body
  result = call_775726.call(nil, query_775727, nil, nil, body_775728)

var registerCertificate* = Call_RegisterCertificate_775713(
    name: "registerCertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/certificate/register",
    validator: validate_RegisterCertificate_775714, base: "/",
    url: url_RegisterCertificate_775715, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RejectCertificateTransfer_775729 = ref object of OpenApiRestCall_772597
proc url_RejectCertificateTransfer_775731(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/reject-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_RejectCertificateTransfer_775730(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_775732 = path.getOrDefault("certificateId")
  valid_775732 = validateParameter(valid_775732, JString, required = true,
                                 default = nil)
  if valid_775732 != nil:
    section.add "certificateId", valid_775732
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775733 = header.getOrDefault("X-Amz-Date")
  valid_775733 = validateParameter(valid_775733, JString, required = false,
                                 default = nil)
  if valid_775733 != nil:
    section.add "X-Amz-Date", valid_775733
  var valid_775734 = header.getOrDefault("X-Amz-Security-Token")
  valid_775734 = validateParameter(valid_775734, JString, required = false,
                                 default = nil)
  if valid_775734 != nil:
    section.add "X-Amz-Security-Token", valid_775734
  var valid_775735 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775735 = validateParameter(valid_775735, JString, required = false,
                                 default = nil)
  if valid_775735 != nil:
    section.add "X-Amz-Content-Sha256", valid_775735
  var valid_775736 = header.getOrDefault("X-Amz-Algorithm")
  valid_775736 = validateParameter(valid_775736, JString, required = false,
                                 default = nil)
  if valid_775736 != nil:
    section.add "X-Amz-Algorithm", valid_775736
  var valid_775737 = header.getOrDefault("X-Amz-Signature")
  valid_775737 = validateParameter(valid_775737, JString, required = false,
                                 default = nil)
  if valid_775737 != nil:
    section.add "X-Amz-Signature", valid_775737
  var valid_775738 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775738 = validateParameter(valid_775738, JString, required = false,
                                 default = nil)
  if valid_775738 != nil:
    section.add "X-Amz-SignedHeaders", valid_775738
  var valid_775739 = header.getOrDefault("X-Amz-Credential")
  valid_775739 = validateParameter(valid_775739, JString, required = false,
                                 default = nil)
  if valid_775739 != nil:
    section.add "X-Amz-Credential", valid_775739
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775741: Call_RejectCertificateTransfer_775729; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ## 
  let valid = call_775741.validator(path, query, header, formData, body)
  let scheme = call_775741.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775741.url(scheme.get, call_775741.host, call_775741.base,
                         call_775741.route, valid.getOrDefault("path"))
  result = hook(call_775741, url, valid)

proc call*(call_775742: Call_RejectCertificateTransfer_775729;
          certificateId: string; body: JsonNode): Recallable =
  ## rejectCertificateTransfer
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   body: JObject (required)
  var path_775743 = newJObject()
  var body_775744 = newJObject()
  add(path_775743, "certificateId", newJString(certificateId))
  if body != nil:
    body_775744 = body
  result = call_775742.call(path_775743, nil, nil, nil, body_775744)

var rejectCertificateTransfer* = Call_RejectCertificateTransfer_775729(
    name: "rejectCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/reject-certificate-transfer/{certificateId}",
    validator: validate_RejectCertificateTransfer_775730, base: "/",
    url: url_RejectCertificateTransfer_775731,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveThingFromBillingGroup_775745 = ref object of OpenApiRestCall_772597
proc url_RemoveThingFromBillingGroup_775747(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_RemoveThingFromBillingGroup_775746(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes the given thing from the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775748 = header.getOrDefault("X-Amz-Date")
  valid_775748 = validateParameter(valid_775748, JString, required = false,
                                 default = nil)
  if valid_775748 != nil:
    section.add "X-Amz-Date", valid_775748
  var valid_775749 = header.getOrDefault("X-Amz-Security-Token")
  valid_775749 = validateParameter(valid_775749, JString, required = false,
                                 default = nil)
  if valid_775749 != nil:
    section.add "X-Amz-Security-Token", valid_775749
  var valid_775750 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775750 = validateParameter(valid_775750, JString, required = false,
                                 default = nil)
  if valid_775750 != nil:
    section.add "X-Amz-Content-Sha256", valid_775750
  var valid_775751 = header.getOrDefault("X-Amz-Algorithm")
  valid_775751 = validateParameter(valid_775751, JString, required = false,
                                 default = nil)
  if valid_775751 != nil:
    section.add "X-Amz-Algorithm", valid_775751
  var valid_775752 = header.getOrDefault("X-Amz-Signature")
  valid_775752 = validateParameter(valid_775752, JString, required = false,
                                 default = nil)
  if valid_775752 != nil:
    section.add "X-Amz-Signature", valid_775752
  var valid_775753 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775753 = validateParameter(valid_775753, JString, required = false,
                                 default = nil)
  if valid_775753 != nil:
    section.add "X-Amz-SignedHeaders", valid_775753
  var valid_775754 = header.getOrDefault("X-Amz-Credential")
  valid_775754 = validateParameter(valid_775754, JString, required = false,
                                 default = nil)
  if valid_775754 != nil:
    section.add "X-Amz-Credential", valid_775754
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775756: Call_RemoveThingFromBillingGroup_775745; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes the given thing from the billing group.
  ## 
  let valid = call_775756.validator(path, query, header, formData, body)
  let scheme = call_775756.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775756.url(scheme.get, call_775756.host, call_775756.base,
                         call_775756.route, valid.getOrDefault("path"))
  result = hook(call_775756, url, valid)

proc call*(call_775757: Call_RemoveThingFromBillingGroup_775745; body: JsonNode): Recallable =
  ## removeThingFromBillingGroup
  ## Removes the given thing from the billing group.
  ##   body: JObject (required)
  var body_775758 = newJObject()
  if body != nil:
    body_775758 = body
  result = call_775757.call(nil, nil, nil, nil, body_775758)

var removeThingFromBillingGroup* = Call_RemoveThingFromBillingGroup_775745(
    name: "removeThingFromBillingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/billing-groups/removeThingFromBillingGroup",
    validator: validate_RemoveThingFromBillingGroup_775746, base: "/",
    url: url_RemoveThingFromBillingGroup_775747,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveThingFromThingGroup_775759 = ref object of OpenApiRestCall_772597
proc url_RemoveThingFromThingGroup_775761(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_RemoveThingFromThingGroup_775760(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove the specified thing from the specified group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775762 = header.getOrDefault("X-Amz-Date")
  valid_775762 = validateParameter(valid_775762, JString, required = false,
                                 default = nil)
  if valid_775762 != nil:
    section.add "X-Amz-Date", valid_775762
  var valid_775763 = header.getOrDefault("X-Amz-Security-Token")
  valid_775763 = validateParameter(valid_775763, JString, required = false,
                                 default = nil)
  if valid_775763 != nil:
    section.add "X-Amz-Security-Token", valid_775763
  var valid_775764 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775764 = validateParameter(valid_775764, JString, required = false,
                                 default = nil)
  if valid_775764 != nil:
    section.add "X-Amz-Content-Sha256", valid_775764
  var valid_775765 = header.getOrDefault("X-Amz-Algorithm")
  valid_775765 = validateParameter(valid_775765, JString, required = false,
                                 default = nil)
  if valid_775765 != nil:
    section.add "X-Amz-Algorithm", valid_775765
  var valid_775766 = header.getOrDefault("X-Amz-Signature")
  valid_775766 = validateParameter(valid_775766, JString, required = false,
                                 default = nil)
  if valid_775766 != nil:
    section.add "X-Amz-Signature", valid_775766
  var valid_775767 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775767 = validateParameter(valid_775767, JString, required = false,
                                 default = nil)
  if valid_775767 != nil:
    section.add "X-Amz-SignedHeaders", valid_775767
  var valid_775768 = header.getOrDefault("X-Amz-Credential")
  valid_775768 = validateParameter(valid_775768, JString, required = false,
                                 default = nil)
  if valid_775768 != nil:
    section.add "X-Amz-Credential", valid_775768
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775770: Call_RemoveThingFromThingGroup_775759; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Remove the specified thing from the specified group.
  ## 
  let valid = call_775770.validator(path, query, header, formData, body)
  let scheme = call_775770.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775770.url(scheme.get, call_775770.host, call_775770.base,
                         call_775770.route, valid.getOrDefault("path"))
  result = hook(call_775770, url, valid)

proc call*(call_775771: Call_RemoveThingFromThingGroup_775759; body: JsonNode): Recallable =
  ## removeThingFromThingGroup
  ## Remove the specified thing from the specified group.
  ##   body: JObject (required)
  var body_775772 = newJObject()
  if body != nil:
    body_775772 = body
  result = call_775771.call(nil, nil, nil, nil, body_775772)

var removeThingFromThingGroup* = Call_RemoveThingFromThingGroup_775759(
    name: "removeThingFromThingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/removeThingFromThingGroup",
    validator: validate_RemoveThingFromThingGroup_775760, base: "/",
    url: url_RemoveThingFromThingGroup_775761,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_SearchIndex_775773 = ref object of OpenApiRestCall_772597
proc url_SearchIndex_775775(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_SearchIndex_775774(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## The query search index.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775776 = header.getOrDefault("X-Amz-Date")
  valid_775776 = validateParameter(valid_775776, JString, required = false,
                                 default = nil)
  if valid_775776 != nil:
    section.add "X-Amz-Date", valid_775776
  var valid_775777 = header.getOrDefault("X-Amz-Security-Token")
  valid_775777 = validateParameter(valid_775777, JString, required = false,
                                 default = nil)
  if valid_775777 != nil:
    section.add "X-Amz-Security-Token", valid_775777
  var valid_775778 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775778 = validateParameter(valid_775778, JString, required = false,
                                 default = nil)
  if valid_775778 != nil:
    section.add "X-Amz-Content-Sha256", valid_775778
  var valid_775779 = header.getOrDefault("X-Amz-Algorithm")
  valid_775779 = validateParameter(valid_775779, JString, required = false,
                                 default = nil)
  if valid_775779 != nil:
    section.add "X-Amz-Algorithm", valid_775779
  var valid_775780 = header.getOrDefault("X-Amz-Signature")
  valid_775780 = validateParameter(valid_775780, JString, required = false,
                                 default = nil)
  if valid_775780 != nil:
    section.add "X-Amz-Signature", valid_775780
  var valid_775781 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775781 = validateParameter(valid_775781, JString, required = false,
                                 default = nil)
  if valid_775781 != nil:
    section.add "X-Amz-SignedHeaders", valid_775781
  var valid_775782 = header.getOrDefault("X-Amz-Credential")
  valid_775782 = validateParameter(valid_775782, JString, required = false,
                                 default = nil)
  if valid_775782 != nil:
    section.add "X-Amz-Credential", valid_775782
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775784: Call_SearchIndex_775773; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The query search index.
  ## 
  let valid = call_775784.validator(path, query, header, formData, body)
  let scheme = call_775784.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775784.url(scheme.get, call_775784.host, call_775784.base,
                         call_775784.route, valid.getOrDefault("path"))
  result = hook(call_775784, url, valid)

proc call*(call_775785: Call_SearchIndex_775773; body: JsonNode): Recallable =
  ## searchIndex
  ## The query search index.
  ##   body: JObject (required)
  var body_775786 = newJObject()
  if body != nil:
    body_775786 = body
  result = call_775785.call(nil, nil, nil, nil, body_775786)

var searchIndex* = Call_SearchIndex_775773(name: "searchIndex",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com",
                                        route: "/indices/search",
                                        validator: validate_SearchIndex_775774,
                                        base: "/", url: url_SearchIndex_775775,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartOnDemandAuditTask_775787 = ref object of OpenApiRestCall_772597
proc url_StartOnDemandAuditTask_775789(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_StartOnDemandAuditTask_775788(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts an on-demand Device Defender audit.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775790 = header.getOrDefault("X-Amz-Date")
  valid_775790 = validateParameter(valid_775790, JString, required = false,
                                 default = nil)
  if valid_775790 != nil:
    section.add "X-Amz-Date", valid_775790
  var valid_775791 = header.getOrDefault("X-Amz-Security-Token")
  valid_775791 = validateParameter(valid_775791, JString, required = false,
                                 default = nil)
  if valid_775791 != nil:
    section.add "X-Amz-Security-Token", valid_775791
  var valid_775792 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775792 = validateParameter(valid_775792, JString, required = false,
                                 default = nil)
  if valid_775792 != nil:
    section.add "X-Amz-Content-Sha256", valid_775792
  var valid_775793 = header.getOrDefault("X-Amz-Algorithm")
  valid_775793 = validateParameter(valid_775793, JString, required = false,
                                 default = nil)
  if valid_775793 != nil:
    section.add "X-Amz-Algorithm", valid_775793
  var valid_775794 = header.getOrDefault("X-Amz-Signature")
  valid_775794 = validateParameter(valid_775794, JString, required = false,
                                 default = nil)
  if valid_775794 != nil:
    section.add "X-Amz-Signature", valid_775794
  var valid_775795 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775795 = validateParameter(valid_775795, JString, required = false,
                                 default = nil)
  if valid_775795 != nil:
    section.add "X-Amz-SignedHeaders", valid_775795
  var valid_775796 = header.getOrDefault("X-Amz-Credential")
  valid_775796 = validateParameter(valid_775796, JString, required = false,
                                 default = nil)
  if valid_775796 != nil:
    section.add "X-Amz-Credential", valid_775796
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775798: Call_StartOnDemandAuditTask_775787; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts an on-demand Device Defender audit.
  ## 
  let valid = call_775798.validator(path, query, header, formData, body)
  let scheme = call_775798.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775798.url(scheme.get, call_775798.host, call_775798.base,
                         call_775798.route, valid.getOrDefault("path"))
  result = hook(call_775798, url, valid)

proc call*(call_775799: Call_StartOnDemandAuditTask_775787; body: JsonNode): Recallable =
  ## startOnDemandAuditTask
  ## Starts an on-demand Device Defender audit.
  ##   body: JObject (required)
  var body_775800 = newJObject()
  if body != nil:
    body_775800 = body
  result = call_775799.call(nil, nil, nil, nil, body_775800)

var startOnDemandAuditTask* = Call_StartOnDemandAuditTask_775787(
    name: "startOnDemandAuditTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/audit/tasks",
    validator: validate_StartOnDemandAuditTask_775788, base: "/",
    url: url_StartOnDemandAuditTask_775789, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StopThingRegistrationTask_775801 = ref object of OpenApiRestCall_772597
proc url_StopThingRegistrationTask_775803(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_StopThingRegistrationTask_775802(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The bulk thing provisioning task ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_775804 = path.getOrDefault("taskId")
  valid_775804 = validateParameter(valid_775804, JString, required = true,
                                 default = nil)
  if valid_775804 != nil:
    section.add "taskId", valid_775804
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775805 = header.getOrDefault("X-Amz-Date")
  valid_775805 = validateParameter(valid_775805, JString, required = false,
                                 default = nil)
  if valid_775805 != nil:
    section.add "X-Amz-Date", valid_775805
  var valid_775806 = header.getOrDefault("X-Amz-Security-Token")
  valid_775806 = validateParameter(valid_775806, JString, required = false,
                                 default = nil)
  if valid_775806 != nil:
    section.add "X-Amz-Security-Token", valid_775806
  var valid_775807 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775807 = validateParameter(valid_775807, JString, required = false,
                                 default = nil)
  if valid_775807 != nil:
    section.add "X-Amz-Content-Sha256", valid_775807
  var valid_775808 = header.getOrDefault("X-Amz-Algorithm")
  valid_775808 = validateParameter(valid_775808, JString, required = false,
                                 default = nil)
  if valid_775808 != nil:
    section.add "X-Amz-Algorithm", valid_775808
  var valid_775809 = header.getOrDefault("X-Amz-Signature")
  valid_775809 = validateParameter(valid_775809, JString, required = false,
                                 default = nil)
  if valid_775809 != nil:
    section.add "X-Amz-Signature", valid_775809
  var valid_775810 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775810 = validateParameter(valid_775810, JString, required = false,
                                 default = nil)
  if valid_775810 != nil:
    section.add "X-Amz-SignedHeaders", valid_775810
  var valid_775811 = header.getOrDefault("X-Amz-Credential")
  valid_775811 = validateParameter(valid_775811, JString, required = false,
                                 default = nil)
  if valid_775811 != nil:
    section.add "X-Amz-Credential", valid_775811
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775812: Call_StopThingRegistrationTask_775801; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a bulk thing provisioning task.
  ## 
  let valid = call_775812.validator(path, query, header, formData, body)
  let scheme = call_775812.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775812.url(scheme.get, call_775812.host, call_775812.base,
                         call_775812.route, valid.getOrDefault("path"))
  result = hook(call_775812, url, valid)

proc call*(call_775813: Call_StopThingRegistrationTask_775801; taskId: string): Recallable =
  ## stopThingRegistrationTask
  ## Cancels a bulk thing provisioning task.
  ##   taskId: string (required)
  ##         : The bulk thing provisioning task ID.
  var path_775814 = newJObject()
  add(path_775814, "taskId", newJString(taskId))
  result = call_775813.call(path_775814, nil, nil, nil, nil)

var stopThingRegistrationTask* = Call_StopThingRegistrationTask_775801(
    name: "stopThingRegistrationTask", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks/{taskId}/cancel",
    validator: validate_StopThingRegistrationTask_775802, base: "/",
    url: url_StopThingRegistrationTask_775803,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_TagResource_775815 = ref object of OpenApiRestCall_772597
proc url_TagResource_775817(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_TagResource_775816(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775818 = header.getOrDefault("X-Amz-Date")
  valid_775818 = validateParameter(valid_775818, JString, required = false,
                                 default = nil)
  if valid_775818 != nil:
    section.add "X-Amz-Date", valid_775818
  var valid_775819 = header.getOrDefault("X-Amz-Security-Token")
  valid_775819 = validateParameter(valid_775819, JString, required = false,
                                 default = nil)
  if valid_775819 != nil:
    section.add "X-Amz-Security-Token", valid_775819
  var valid_775820 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775820 = validateParameter(valid_775820, JString, required = false,
                                 default = nil)
  if valid_775820 != nil:
    section.add "X-Amz-Content-Sha256", valid_775820
  var valid_775821 = header.getOrDefault("X-Amz-Algorithm")
  valid_775821 = validateParameter(valid_775821, JString, required = false,
                                 default = nil)
  if valid_775821 != nil:
    section.add "X-Amz-Algorithm", valid_775821
  var valid_775822 = header.getOrDefault("X-Amz-Signature")
  valid_775822 = validateParameter(valid_775822, JString, required = false,
                                 default = nil)
  if valid_775822 != nil:
    section.add "X-Amz-Signature", valid_775822
  var valid_775823 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775823 = validateParameter(valid_775823, JString, required = false,
                                 default = nil)
  if valid_775823 != nil:
    section.add "X-Amz-SignedHeaders", valid_775823
  var valid_775824 = header.getOrDefault("X-Amz-Credential")
  valid_775824 = validateParameter(valid_775824, JString, required = false,
                                 default = nil)
  if valid_775824 != nil:
    section.add "X-Amz-Credential", valid_775824
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775826: Call_TagResource_775815; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ## 
  let valid = call_775826.validator(path, query, header, formData, body)
  let scheme = call_775826.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775826.url(scheme.get, call_775826.host, call_775826.base,
                         call_775826.route, valid.getOrDefault("path"))
  result = hook(call_775826, url, valid)

proc call*(call_775827: Call_TagResource_775815; body: JsonNode): Recallable =
  ## tagResource
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ##   body: JObject (required)
  var body_775828 = newJObject()
  if body != nil:
    body_775828 = body
  result = call_775827.call(nil, nil, nil, nil, body_775828)

var tagResource* = Call_TagResource_775815(name: "tagResource",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com", route: "/tags",
                                        validator: validate_TagResource_775816,
                                        base: "/", url: url_TagResource_775817,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_TestAuthorization_775829 = ref object of OpenApiRestCall_772597
proc url_TestAuthorization_775831(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_TestAuthorization_775830(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   clientId: JString
  ##           : The MQTT client ID.
  section = newJObject()
  var valid_775832 = query.getOrDefault("clientId")
  valid_775832 = validateParameter(valid_775832, JString, required = false,
                                 default = nil)
  if valid_775832 != nil:
    section.add "clientId", valid_775832
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775833 = header.getOrDefault("X-Amz-Date")
  valid_775833 = validateParameter(valid_775833, JString, required = false,
                                 default = nil)
  if valid_775833 != nil:
    section.add "X-Amz-Date", valid_775833
  var valid_775834 = header.getOrDefault("X-Amz-Security-Token")
  valid_775834 = validateParameter(valid_775834, JString, required = false,
                                 default = nil)
  if valid_775834 != nil:
    section.add "X-Amz-Security-Token", valid_775834
  var valid_775835 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775835 = validateParameter(valid_775835, JString, required = false,
                                 default = nil)
  if valid_775835 != nil:
    section.add "X-Amz-Content-Sha256", valid_775835
  var valid_775836 = header.getOrDefault("X-Amz-Algorithm")
  valid_775836 = validateParameter(valid_775836, JString, required = false,
                                 default = nil)
  if valid_775836 != nil:
    section.add "X-Amz-Algorithm", valid_775836
  var valid_775837 = header.getOrDefault("X-Amz-Signature")
  valid_775837 = validateParameter(valid_775837, JString, required = false,
                                 default = nil)
  if valid_775837 != nil:
    section.add "X-Amz-Signature", valid_775837
  var valid_775838 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775838 = validateParameter(valid_775838, JString, required = false,
                                 default = nil)
  if valid_775838 != nil:
    section.add "X-Amz-SignedHeaders", valid_775838
  var valid_775839 = header.getOrDefault("X-Amz-Credential")
  valid_775839 = validateParameter(valid_775839, JString, required = false,
                                 default = nil)
  if valid_775839 != nil:
    section.add "X-Amz-Credential", valid_775839
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775841: Call_TestAuthorization_775829; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  let valid = call_775841.validator(path, query, header, formData, body)
  let scheme = call_775841.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775841.url(scheme.get, call_775841.host, call_775841.base,
                         call_775841.route, valid.getOrDefault("path"))
  result = hook(call_775841, url, valid)

proc call*(call_775842: Call_TestAuthorization_775829; body: JsonNode;
          clientId: string = ""): Recallable =
  ## testAuthorization
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ##   clientId: string
  ##           : The MQTT client ID.
  ##   body: JObject (required)
  var query_775843 = newJObject()
  var body_775844 = newJObject()
  add(query_775843, "clientId", newJString(clientId))
  if body != nil:
    body_775844 = body
  result = call_775842.call(nil, query_775843, nil, nil, body_775844)

var testAuthorization* = Call_TestAuthorization_775829(name: "testAuthorization",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/test-authorization", validator: validate_TestAuthorization_775830,
    base: "/", url: url_TestAuthorization_775831,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_TestInvokeAuthorizer_775845 = ref object of OpenApiRestCall_772597
proc url_TestInvokeAuthorizer_775847(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName"),
               (kind: ConstantSegment, value: "/test")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_TestInvokeAuthorizer_775846(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The custom authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_775848 = path.getOrDefault("authorizerName")
  valid_775848 = validateParameter(valid_775848, JString, required = true,
                                 default = nil)
  if valid_775848 != nil:
    section.add "authorizerName", valid_775848
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775849 = header.getOrDefault("X-Amz-Date")
  valid_775849 = validateParameter(valid_775849, JString, required = false,
                                 default = nil)
  if valid_775849 != nil:
    section.add "X-Amz-Date", valid_775849
  var valid_775850 = header.getOrDefault("X-Amz-Security-Token")
  valid_775850 = validateParameter(valid_775850, JString, required = false,
                                 default = nil)
  if valid_775850 != nil:
    section.add "X-Amz-Security-Token", valid_775850
  var valid_775851 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775851 = validateParameter(valid_775851, JString, required = false,
                                 default = nil)
  if valid_775851 != nil:
    section.add "X-Amz-Content-Sha256", valid_775851
  var valid_775852 = header.getOrDefault("X-Amz-Algorithm")
  valid_775852 = validateParameter(valid_775852, JString, required = false,
                                 default = nil)
  if valid_775852 != nil:
    section.add "X-Amz-Algorithm", valid_775852
  var valid_775853 = header.getOrDefault("X-Amz-Signature")
  valid_775853 = validateParameter(valid_775853, JString, required = false,
                                 default = nil)
  if valid_775853 != nil:
    section.add "X-Amz-Signature", valid_775853
  var valid_775854 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775854 = validateParameter(valid_775854, JString, required = false,
                                 default = nil)
  if valid_775854 != nil:
    section.add "X-Amz-SignedHeaders", valid_775854
  var valid_775855 = header.getOrDefault("X-Amz-Credential")
  valid_775855 = validateParameter(valid_775855, JString, required = false,
                                 default = nil)
  if valid_775855 != nil:
    section.add "X-Amz-Credential", valid_775855
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775857: Call_TestInvokeAuthorizer_775845; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  let valid = call_775857.validator(path, query, header, formData, body)
  let scheme = call_775857.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775857.url(scheme.get, call_775857.host, call_775857.base,
                         call_775857.route, valid.getOrDefault("path"))
  result = hook(call_775857, url, valid)

proc call*(call_775858: Call_TestInvokeAuthorizer_775845; authorizerName: string;
          body: JsonNode): Recallable =
  ## testInvokeAuthorizer
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ##   authorizerName: string (required)
  ##                 : The custom authorizer name.
  ##   body: JObject (required)
  var path_775859 = newJObject()
  var body_775860 = newJObject()
  add(path_775859, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_775860 = body
  result = call_775858.call(path_775859, nil, nil, nil, body_775860)

var testInvokeAuthorizer* = Call_TestInvokeAuthorizer_775845(
    name: "testInvokeAuthorizer", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/authorizer/{authorizerName}/test",
    validator: validate_TestInvokeAuthorizer_775846, base: "/",
    url: url_TestInvokeAuthorizer_775847, schemes: {Scheme.Https, Scheme.Http})
type
  Call_TransferCertificate_775861 = ref object of OpenApiRestCall_772597
proc url_TransferCertificate_775863(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/transfer-certificate/"),
               (kind: VariableSegment, value: "certificateId"),
               (kind: ConstantSegment, value: "#targetAwsAccount")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_TransferCertificate_775862(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_775864 = path.getOrDefault("certificateId")
  valid_775864 = validateParameter(valid_775864, JString, required = true,
                                 default = nil)
  if valid_775864 != nil:
    section.add "certificateId", valid_775864
  result.add "path", section
  ## parameters in `query` object:
  ##   targetAwsAccount: JString (required)
  ##                   : The AWS account.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `targetAwsAccount` field"
  var valid_775865 = query.getOrDefault("targetAwsAccount")
  valid_775865 = validateParameter(valid_775865, JString, required = true,
                                 default = nil)
  if valid_775865 != nil:
    section.add "targetAwsAccount", valid_775865
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775866 = header.getOrDefault("X-Amz-Date")
  valid_775866 = validateParameter(valid_775866, JString, required = false,
                                 default = nil)
  if valid_775866 != nil:
    section.add "X-Amz-Date", valid_775866
  var valid_775867 = header.getOrDefault("X-Amz-Security-Token")
  valid_775867 = validateParameter(valid_775867, JString, required = false,
                                 default = nil)
  if valid_775867 != nil:
    section.add "X-Amz-Security-Token", valid_775867
  var valid_775868 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775868 = validateParameter(valid_775868, JString, required = false,
                                 default = nil)
  if valid_775868 != nil:
    section.add "X-Amz-Content-Sha256", valid_775868
  var valid_775869 = header.getOrDefault("X-Amz-Algorithm")
  valid_775869 = validateParameter(valid_775869, JString, required = false,
                                 default = nil)
  if valid_775869 != nil:
    section.add "X-Amz-Algorithm", valid_775869
  var valid_775870 = header.getOrDefault("X-Amz-Signature")
  valid_775870 = validateParameter(valid_775870, JString, required = false,
                                 default = nil)
  if valid_775870 != nil:
    section.add "X-Amz-Signature", valid_775870
  var valid_775871 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775871 = validateParameter(valid_775871, JString, required = false,
                                 default = nil)
  if valid_775871 != nil:
    section.add "X-Amz-SignedHeaders", valid_775871
  var valid_775872 = header.getOrDefault("X-Amz-Credential")
  valid_775872 = validateParameter(valid_775872, JString, required = false,
                                 default = nil)
  if valid_775872 != nil:
    section.add "X-Amz-Credential", valid_775872
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775874: Call_TransferCertificate_775861; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ## 
  let valid = call_775874.validator(path, query, header, formData, body)
  let scheme = call_775874.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775874.url(scheme.get, call_775874.host, call_775874.base,
                         call_775874.route, valid.getOrDefault("path"))
  result = hook(call_775874, url, valid)

proc call*(call_775875: Call_TransferCertificate_775861; certificateId: string;
          targetAwsAccount: string; body: JsonNode): Recallable =
  ## transferCertificate
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   targetAwsAccount: string (required)
  ##                   : The AWS account.
  ##   body: JObject (required)
  var path_775876 = newJObject()
  var query_775877 = newJObject()
  var body_775878 = newJObject()
  add(path_775876, "certificateId", newJString(certificateId))
  add(query_775877, "targetAwsAccount", newJString(targetAwsAccount))
  if body != nil:
    body_775878 = body
  result = call_775875.call(path_775876, query_775877, nil, nil, body_775878)

var transferCertificate* = Call_TransferCertificate_775861(
    name: "transferCertificate", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/transfer-certificate/{certificateId}#targetAwsAccount",
    validator: validate_TransferCertificate_775862, base: "/",
    url: url_TransferCertificate_775863, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UntagResource_775879 = ref object of OpenApiRestCall_772597
proc url_UntagResource_775881(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_UntagResource_775880(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes the given tags (metadata) from the resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775882 = header.getOrDefault("X-Amz-Date")
  valid_775882 = validateParameter(valid_775882, JString, required = false,
                                 default = nil)
  if valid_775882 != nil:
    section.add "X-Amz-Date", valid_775882
  var valid_775883 = header.getOrDefault("X-Amz-Security-Token")
  valid_775883 = validateParameter(valid_775883, JString, required = false,
                                 default = nil)
  if valid_775883 != nil:
    section.add "X-Amz-Security-Token", valid_775883
  var valid_775884 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775884 = validateParameter(valid_775884, JString, required = false,
                                 default = nil)
  if valid_775884 != nil:
    section.add "X-Amz-Content-Sha256", valid_775884
  var valid_775885 = header.getOrDefault("X-Amz-Algorithm")
  valid_775885 = validateParameter(valid_775885, JString, required = false,
                                 default = nil)
  if valid_775885 != nil:
    section.add "X-Amz-Algorithm", valid_775885
  var valid_775886 = header.getOrDefault("X-Amz-Signature")
  valid_775886 = validateParameter(valid_775886, JString, required = false,
                                 default = nil)
  if valid_775886 != nil:
    section.add "X-Amz-Signature", valid_775886
  var valid_775887 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775887 = validateParameter(valid_775887, JString, required = false,
                                 default = nil)
  if valid_775887 != nil:
    section.add "X-Amz-SignedHeaders", valid_775887
  var valid_775888 = header.getOrDefault("X-Amz-Credential")
  valid_775888 = validateParameter(valid_775888, JString, required = false,
                                 default = nil)
  if valid_775888 != nil:
    section.add "X-Amz-Credential", valid_775888
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775890: Call_UntagResource_775879; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes the given tags (metadata) from the resource.
  ## 
  let valid = call_775890.validator(path, query, header, formData, body)
  let scheme = call_775890.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775890.url(scheme.get, call_775890.host, call_775890.base,
                         call_775890.route, valid.getOrDefault("path"))
  result = hook(call_775890, url, valid)

proc call*(call_775891: Call_UntagResource_775879; body: JsonNode): Recallable =
  ## untagResource
  ## Removes the given tags (metadata) from the resource.
  ##   body: JObject (required)
  var body_775892 = newJObject()
  if body != nil:
    body_775892 = body
  result = call_775891.call(nil, nil, nil, nil, body_775892)

var untagResource* = Call_UntagResource_775879(name: "untagResource",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/untag",
    validator: validate_UntagResource_775880, base: "/", url: url_UntagResource_775881,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateCertificate_775893 = ref object of OpenApiRestCall_772597
proc url_UpdateCertificate_775895(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode): string =
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId"),
               (kind: ConstantSegment, value: "#newStatus")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result = $protocol & "://" & host & base & hydrated.get()

proc validate_UpdateCertificate_775894(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_775896 = path.getOrDefault("certificateId")
  valid_775896 = validateParameter(valid_775896, JString, required = true,
                                 default = nil)
  if valid_775896 != nil:
    section.add "certificateId", valid_775896
  result.add "path", section
  ## parameters in `query` object:
  ##   newStatus: JString (required)
  ##            : <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `newStatus` field"
  var valid_775897 = query.getOrDefault("newStatus")
  valid_775897 = validateParameter(valid_775897, JString, required = true,
                                 default = newJString("ACTIVE"))
  if valid_775897 != nil:
    section.add "newStatus", valid_775897
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775898 = header.getOrDefault("X-Amz-Date")
  valid_775898 = validateParameter(valid_775898, JString, required = false,
                                 default = nil)
  if valid_775898 != nil:
    section.add "X-Amz-Date", valid_775898
  var valid_775899 = header.getOrDefault("X-Amz-Security-Token")
  valid_775899 = validateParameter(valid_775899, JString, required = false,
                                 default = nil)
  if valid_775899 != nil:
    section.add "X-Amz-Security-Token", valid_775899
  var valid_775900 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775900 = validateParameter(valid_775900, JString, required = false,
                                 default = nil)
  if valid_775900 != nil:
    section.add "X-Amz-Content-Sha256", valid_775900
  var valid_775901 = header.getOrDefault("X-Amz-Algorithm")
  valid_775901 = validateParameter(valid_775901, JString, required = false,
                                 default = nil)
  if valid_775901 != nil:
    section.add "X-Amz-Algorithm", valid_775901
  var valid_775902 = header.getOrDefault("X-Amz-Signature")
  valid_775902 = validateParameter(valid_775902, JString, required = false,
                                 default = nil)
  if valid_775902 != nil:
    section.add "X-Amz-Signature", valid_775902
  var valid_775903 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775903 = validateParameter(valid_775903, JString, required = false,
                                 default = nil)
  if valid_775903 != nil:
    section.add "X-Amz-SignedHeaders", valid_775903
  var valid_775904 = header.getOrDefault("X-Amz-Credential")
  valid_775904 = validateParameter(valid_775904, JString, required = false,
                                 default = nil)
  if valid_775904 != nil:
    section.add "X-Amz-Credential", valid_775904
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_775905: Call_UpdateCertificate_775893; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ## 
  let valid = call_775905.validator(path, query, header, formData, body)
  let scheme = call_775905.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775905.url(scheme.get, call_775905.host, call_775905.base,
                         call_775905.route, valid.getOrDefault("path"))
  result = hook(call_775905, url, valid)

proc call*(call_775906: Call_UpdateCertificate_775893; certificateId: string;
          newStatus: string = "ACTIVE"): Recallable =
  ## updateCertificate
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   newStatus: string (required)
  ##            : <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  var path_775907 = newJObject()
  var query_775908 = newJObject()
  add(path_775907, "certificateId", newJString(certificateId))
  add(query_775908, "newStatus", newJString(newStatus))
  result = call_775906.call(path_775907, query_775908, nil, nil, nil)

var updateCertificate* = Call_UpdateCertificate_775893(name: "updateCertificate",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/certificates/{certificateId}#newStatus",
    validator: validate_UpdateCertificate_775894, base: "/",
    url: url_UpdateCertificate_775895, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThingGroupsForThing_775909 = ref object of OpenApiRestCall_772597
proc url_UpdateThingGroupsForThing_775911(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_UpdateThingGroupsForThing_775910(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the groups to which the thing belongs.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775912 = header.getOrDefault("X-Amz-Date")
  valid_775912 = validateParameter(valid_775912, JString, required = false,
                                 default = nil)
  if valid_775912 != nil:
    section.add "X-Amz-Date", valid_775912
  var valid_775913 = header.getOrDefault("X-Amz-Security-Token")
  valid_775913 = validateParameter(valid_775913, JString, required = false,
                                 default = nil)
  if valid_775913 != nil:
    section.add "X-Amz-Security-Token", valid_775913
  var valid_775914 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775914 = validateParameter(valid_775914, JString, required = false,
                                 default = nil)
  if valid_775914 != nil:
    section.add "X-Amz-Content-Sha256", valid_775914
  var valid_775915 = header.getOrDefault("X-Amz-Algorithm")
  valid_775915 = validateParameter(valid_775915, JString, required = false,
                                 default = nil)
  if valid_775915 != nil:
    section.add "X-Amz-Algorithm", valid_775915
  var valid_775916 = header.getOrDefault("X-Amz-Signature")
  valid_775916 = validateParameter(valid_775916, JString, required = false,
                                 default = nil)
  if valid_775916 != nil:
    section.add "X-Amz-Signature", valid_775916
  var valid_775917 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775917 = validateParameter(valid_775917, JString, required = false,
                                 default = nil)
  if valid_775917 != nil:
    section.add "X-Amz-SignedHeaders", valid_775917
  var valid_775918 = header.getOrDefault("X-Amz-Credential")
  valid_775918 = validateParameter(valid_775918, JString, required = false,
                                 default = nil)
  if valid_775918 != nil:
    section.add "X-Amz-Credential", valid_775918
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775920: Call_UpdateThingGroupsForThing_775909; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the groups to which the thing belongs.
  ## 
  let valid = call_775920.validator(path, query, header, formData, body)
  let scheme = call_775920.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775920.url(scheme.get, call_775920.host, call_775920.base,
                         call_775920.route, valid.getOrDefault("path"))
  result = hook(call_775920, url, valid)

proc call*(call_775921: Call_UpdateThingGroupsForThing_775909; body: JsonNode): Recallable =
  ## updateThingGroupsForThing
  ## Updates the groups to which the thing belongs.
  ##   body: JObject (required)
  var body_775922 = newJObject()
  if body != nil:
    body_775922 = body
  result = call_775921.call(nil, nil, nil, nil, body_775922)

var updateThingGroupsForThing* = Call_UpdateThingGroupsForThing_775909(
    name: "updateThingGroupsForThing", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/updateThingGroupsForThing",
    validator: validate_UpdateThingGroupsForThing_775910, base: "/",
    url: url_UpdateThingGroupsForThing_775911,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ValidateSecurityProfileBehaviors_775923 = ref object of OpenApiRestCall_772597
proc url_ValidateSecurityProfileBehaviors_775925(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode): string =
  result = $protocol & "://" & host & base & route

proc validate_ValidateSecurityProfileBehaviors_775924(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validates a Device Defender security profile behaviors specification.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_775926 = header.getOrDefault("X-Amz-Date")
  valid_775926 = validateParameter(valid_775926, JString, required = false,
                                 default = nil)
  if valid_775926 != nil:
    section.add "X-Amz-Date", valid_775926
  var valid_775927 = header.getOrDefault("X-Amz-Security-Token")
  valid_775927 = validateParameter(valid_775927, JString, required = false,
                                 default = nil)
  if valid_775927 != nil:
    section.add "X-Amz-Security-Token", valid_775927
  var valid_775928 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_775928 = validateParameter(valid_775928, JString, required = false,
                                 default = nil)
  if valid_775928 != nil:
    section.add "X-Amz-Content-Sha256", valid_775928
  var valid_775929 = header.getOrDefault("X-Amz-Algorithm")
  valid_775929 = validateParameter(valid_775929, JString, required = false,
                                 default = nil)
  if valid_775929 != nil:
    section.add "X-Amz-Algorithm", valid_775929
  var valid_775930 = header.getOrDefault("X-Amz-Signature")
  valid_775930 = validateParameter(valid_775930, JString, required = false,
                                 default = nil)
  if valid_775930 != nil:
    section.add "X-Amz-Signature", valid_775930
  var valid_775931 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_775931 = validateParameter(valid_775931, JString, required = false,
                                 default = nil)
  if valid_775931 != nil:
    section.add "X-Amz-SignedHeaders", valid_775931
  var valid_775932 = header.getOrDefault("X-Amz-Credential")
  valid_775932 = validateParameter(valid_775932, JString, required = false,
                                 default = nil)
  if valid_775932 != nil:
    section.add "X-Amz-Credential", valid_775932
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_775934: Call_ValidateSecurityProfileBehaviors_775923;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Validates a Device Defender security profile behaviors specification.
  ## 
  let valid = call_775934.validator(path, query, header, formData, body)
  let scheme = call_775934.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_775934.url(scheme.get, call_775934.host, call_775934.base,
                         call_775934.route, valid.getOrDefault("path"))
  result = hook(call_775934, url, valid)

proc call*(call_775935: Call_ValidateSecurityProfileBehaviors_775923;
          body: JsonNode): Recallable =
  ## validateSecurityProfileBehaviors
  ## Validates a Device Defender security profile behaviors specification.
  ##   body: JObject (required)
  var body_775936 = newJObject()
  if body != nil:
    body_775936 = body
  result = call_775935.call(nil, nil, nil, nil, body_775936)

var validateSecurityProfileBehaviors* = Call_ValidateSecurityProfileBehaviors_775923(
    name: "validateSecurityProfileBehaviors", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/security-profile-behaviors/validate",
    validator: validate_ValidateSecurityProfileBehaviors_775924, base: "/",
    url: url_ValidateSecurityProfileBehaviors_775925,
    schemes: {Scheme.Https, Scheme.Http})
proc sign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", "")
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", "")
    region = os.getEnv("AWS_REGION", "")
  assert secret != "", "need secret key in env"
  assert access != "", "need access key in env"
  assert region != "", "need region in env"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  echo recall.headers
  recall.headers.del "Host"
  recall.url = $url

method hook(call: OpenApiRestCall; url: string; input: JsonNode): Recallable {.base.} =
  let headers = massageHeaders(input.getOrDefault("header"))
  result = newRecallable(call, url, headers, "")
  result.sign(input.getOrDefault("query"), SHA256)
