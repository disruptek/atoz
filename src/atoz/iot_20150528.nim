
import
  json, options, hashes, uri, strutils, tables, rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: AWS IoT
## version: 2015-05-28
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>AWS IoT</fullname> <p>AWS IoT provides secure, bi-directional communication between Internet-connected devices (such as sensors, actuators, embedded devices, or smart appliances) and the AWS cloud. You can discover your custom IoT-Data endpoint to communicate with, configure rules for data processing and integration with other services, organize resources associated with each device (Registry), configure logging, and create and manage policies and credentials to authenticate devices.</p> <p>For more information about how AWS IoT works, see the <a href="https://docs.aws.amazon.com/iot/latest/developerguide/aws-iot-how-it-works.html">Developer Guide</a>.</p> <p>For information about how to use the credentials provider for AWS IoT, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorizing-direct-aws.html">Authorizing Direct Calls to AWS Services</a>.</p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/iot/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_593389 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_593389](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_593389): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "iot.ap-northeast-1.amazonaws.com", "ap-southeast-1": "iot.ap-southeast-1.amazonaws.com",
                           "us-west-2": "iot.us-west-2.amazonaws.com",
                           "eu-west-2": "iot.eu-west-2.amazonaws.com", "ap-northeast-3": "iot.ap-northeast-3.amazonaws.com",
                           "eu-central-1": "iot.eu-central-1.amazonaws.com",
                           "us-east-2": "iot.us-east-2.amazonaws.com",
                           "us-east-1": "iot.us-east-1.amazonaws.com", "cn-northwest-1": "iot.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "iot.ap-south-1.amazonaws.com",
                           "eu-north-1": "iot.eu-north-1.amazonaws.com", "ap-northeast-2": "iot.ap-northeast-2.amazonaws.com",
                           "us-west-1": "iot.us-west-1.amazonaws.com",
                           "us-gov-east-1": "iot.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "iot.eu-west-3.amazonaws.com",
                           "cn-north-1": "iot.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "iot.sa-east-1.amazonaws.com",
                           "eu-west-1": "iot.eu-west-1.amazonaws.com",
                           "us-gov-west-1": "iot.us-gov-west-1.amazonaws.com", "ap-southeast-2": "iot.ap-southeast-2.amazonaws.com",
                           "ca-central-1": "iot.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "iot.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "iot.ap-southeast-1.amazonaws.com",
      "us-west-2": "iot.us-west-2.amazonaws.com",
      "eu-west-2": "iot.eu-west-2.amazonaws.com",
      "ap-northeast-3": "iot.ap-northeast-3.amazonaws.com",
      "eu-central-1": "iot.eu-central-1.amazonaws.com",
      "us-east-2": "iot.us-east-2.amazonaws.com",
      "us-east-1": "iot.us-east-1.amazonaws.com",
      "cn-northwest-1": "iot.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "iot.ap-south-1.amazonaws.com",
      "eu-north-1": "iot.eu-north-1.amazonaws.com",
      "ap-northeast-2": "iot.ap-northeast-2.amazonaws.com",
      "us-west-1": "iot.us-west-1.amazonaws.com",
      "us-gov-east-1": "iot.us-gov-east-1.amazonaws.com",
      "eu-west-3": "iot.eu-west-3.amazonaws.com",
      "cn-north-1": "iot.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "iot.sa-east-1.amazonaws.com",
      "eu-west-1": "iot.eu-west-1.amazonaws.com",
      "us-gov-west-1": "iot.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "iot.ap-southeast-2.amazonaws.com",
      "ca-central-1": "iot.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "iot"
method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_AcceptCertificateTransfer_593727 = ref object of OpenApiRestCall_593389
proc url_AcceptCertificateTransfer_593729(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/accept-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AcceptCertificateTransfer_593728(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_593855 = path.getOrDefault("certificateId")
  valid_593855 = validateParameter(valid_593855, JString, required = true,
                                 default = nil)
  if valid_593855 != nil:
    section.add "certificateId", valid_593855
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_593856 = query.getOrDefault("setAsActive")
  valid_593856 = validateParameter(valid_593856, JBool, required = false, default = nil)
  if valid_593856 != nil:
    section.add "setAsActive", valid_593856
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593857 = header.getOrDefault("X-Amz-Signature")
  valid_593857 = validateParameter(valid_593857, JString, required = false,
                                 default = nil)
  if valid_593857 != nil:
    section.add "X-Amz-Signature", valid_593857
  var valid_593858 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593858 = validateParameter(valid_593858, JString, required = false,
                                 default = nil)
  if valid_593858 != nil:
    section.add "X-Amz-Content-Sha256", valid_593858
  var valid_593859 = header.getOrDefault("X-Amz-Date")
  valid_593859 = validateParameter(valid_593859, JString, required = false,
                                 default = nil)
  if valid_593859 != nil:
    section.add "X-Amz-Date", valid_593859
  var valid_593860 = header.getOrDefault("X-Amz-Credential")
  valid_593860 = validateParameter(valid_593860, JString, required = false,
                                 default = nil)
  if valid_593860 != nil:
    section.add "X-Amz-Credential", valid_593860
  var valid_593861 = header.getOrDefault("X-Amz-Security-Token")
  valid_593861 = validateParameter(valid_593861, JString, required = false,
                                 default = nil)
  if valid_593861 != nil:
    section.add "X-Amz-Security-Token", valid_593861
  var valid_593862 = header.getOrDefault("X-Amz-Algorithm")
  valid_593862 = validateParameter(valid_593862, JString, required = false,
                                 default = nil)
  if valid_593862 != nil:
    section.add "X-Amz-Algorithm", valid_593862
  var valid_593863 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593863 = validateParameter(valid_593863, JString, required = false,
                                 default = nil)
  if valid_593863 != nil:
    section.add "X-Amz-SignedHeaders", valid_593863
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593886: Call_AcceptCertificateTransfer_593727; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ## 
  let valid = call_593886.validator(path, query, header, formData, body)
  let scheme = call_593886.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593886.url(scheme.get, call_593886.host, call_593886.base,
                         call_593886.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593886, url, valid)

proc call*(call_593957: Call_AcceptCertificateTransfer_593727;
          certificateId: string; setAsActive: bool = false): Recallable =
  ## acceptCertificateTransfer
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_593958 = newJObject()
  var query_593960 = newJObject()
  add(query_593960, "setAsActive", newJBool(setAsActive))
  add(path_593958, "certificateId", newJString(certificateId))
  result = call_593957.call(path_593958, query_593960, nil, nil, nil)

var acceptCertificateTransfer* = Call_AcceptCertificateTransfer_593727(
    name: "acceptCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/accept-certificate-transfer/{certificateId}",
    validator: validate_AcceptCertificateTransfer_593728, base: "/",
    url: url_AcceptCertificateTransfer_593729,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_AddThingToBillingGroup_593999 = ref object of OpenApiRestCall_593389
proc url_AddThingToBillingGroup_594001(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_AddThingToBillingGroup_594000(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a thing to a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594002 = header.getOrDefault("X-Amz-Signature")
  valid_594002 = validateParameter(valid_594002, JString, required = false,
                                 default = nil)
  if valid_594002 != nil:
    section.add "X-Amz-Signature", valid_594002
  var valid_594003 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594003 = validateParameter(valid_594003, JString, required = false,
                                 default = nil)
  if valid_594003 != nil:
    section.add "X-Amz-Content-Sha256", valid_594003
  var valid_594004 = header.getOrDefault("X-Amz-Date")
  valid_594004 = validateParameter(valid_594004, JString, required = false,
                                 default = nil)
  if valid_594004 != nil:
    section.add "X-Amz-Date", valid_594004
  var valid_594005 = header.getOrDefault("X-Amz-Credential")
  valid_594005 = validateParameter(valid_594005, JString, required = false,
                                 default = nil)
  if valid_594005 != nil:
    section.add "X-Amz-Credential", valid_594005
  var valid_594006 = header.getOrDefault("X-Amz-Security-Token")
  valid_594006 = validateParameter(valid_594006, JString, required = false,
                                 default = nil)
  if valid_594006 != nil:
    section.add "X-Amz-Security-Token", valid_594006
  var valid_594007 = header.getOrDefault("X-Amz-Algorithm")
  valid_594007 = validateParameter(valid_594007, JString, required = false,
                                 default = nil)
  if valid_594007 != nil:
    section.add "X-Amz-Algorithm", valid_594007
  var valid_594008 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594008 = validateParameter(valid_594008, JString, required = false,
                                 default = nil)
  if valid_594008 != nil:
    section.add "X-Amz-SignedHeaders", valid_594008
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594010: Call_AddThingToBillingGroup_593999; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a thing to a billing group.
  ## 
  let valid = call_594010.validator(path, query, header, formData, body)
  let scheme = call_594010.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594010.url(scheme.get, call_594010.host, call_594010.base,
                         call_594010.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594010, url, valid)

proc call*(call_594011: Call_AddThingToBillingGroup_593999; body: JsonNode): Recallable =
  ## addThingToBillingGroup
  ## Adds a thing to a billing group.
  ##   body: JObject (required)
  var body_594012 = newJObject()
  if body != nil:
    body_594012 = body
  result = call_594011.call(nil, nil, nil, nil, body_594012)

var addThingToBillingGroup* = Call_AddThingToBillingGroup_593999(
    name: "addThingToBillingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/billing-groups/addThingToBillingGroup",
    validator: validate_AddThingToBillingGroup_594000, base: "/",
    url: url_AddThingToBillingGroup_594001, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AddThingToThingGroup_594013 = ref object of OpenApiRestCall_593389
proc url_AddThingToThingGroup_594015(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_AddThingToThingGroup_594014(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a thing to a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594016 = header.getOrDefault("X-Amz-Signature")
  valid_594016 = validateParameter(valid_594016, JString, required = false,
                                 default = nil)
  if valid_594016 != nil:
    section.add "X-Amz-Signature", valid_594016
  var valid_594017 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594017 = validateParameter(valid_594017, JString, required = false,
                                 default = nil)
  if valid_594017 != nil:
    section.add "X-Amz-Content-Sha256", valid_594017
  var valid_594018 = header.getOrDefault("X-Amz-Date")
  valid_594018 = validateParameter(valid_594018, JString, required = false,
                                 default = nil)
  if valid_594018 != nil:
    section.add "X-Amz-Date", valid_594018
  var valid_594019 = header.getOrDefault("X-Amz-Credential")
  valid_594019 = validateParameter(valid_594019, JString, required = false,
                                 default = nil)
  if valid_594019 != nil:
    section.add "X-Amz-Credential", valid_594019
  var valid_594020 = header.getOrDefault("X-Amz-Security-Token")
  valid_594020 = validateParameter(valid_594020, JString, required = false,
                                 default = nil)
  if valid_594020 != nil:
    section.add "X-Amz-Security-Token", valid_594020
  var valid_594021 = header.getOrDefault("X-Amz-Algorithm")
  valid_594021 = validateParameter(valid_594021, JString, required = false,
                                 default = nil)
  if valid_594021 != nil:
    section.add "X-Amz-Algorithm", valid_594021
  var valid_594022 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594022 = validateParameter(valid_594022, JString, required = false,
                                 default = nil)
  if valid_594022 != nil:
    section.add "X-Amz-SignedHeaders", valid_594022
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594024: Call_AddThingToThingGroup_594013; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a thing to a thing group.
  ## 
  let valid = call_594024.validator(path, query, header, formData, body)
  let scheme = call_594024.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594024.url(scheme.get, call_594024.host, call_594024.base,
                         call_594024.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594024, url, valid)

proc call*(call_594025: Call_AddThingToThingGroup_594013; body: JsonNode): Recallable =
  ## addThingToThingGroup
  ## Adds a thing to a thing group.
  ##   body: JObject (required)
  var body_594026 = newJObject()
  if body != nil:
    body_594026 = body
  result = call_594025.call(nil, nil, nil, nil, body_594026)

var addThingToThingGroup* = Call_AddThingToThingGroup_594013(
    name: "addThingToThingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/addThingToThingGroup",
    validator: validate_AddThingToThingGroup_594014, base: "/",
    url: url_AddThingToThingGroup_594015, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AssociateTargetsWithJob_594027 = ref object of OpenApiRestCall_593389
proc url_AssociateTargetsWithJob_594029(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/targets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AssociateTargetsWithJob_594028(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_594030 = path.getOrDefault("jobId")
  valid_594030 = validateParameter(valid_594030, JString, required = true,
                                 default = nil)
  if valid_594030 != nil:
    section.add "jobId", valid_594030
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594031 = header.getOrDefault("X-Amz-Signature")
  valid_594031 = validateParameter(valid_594031, JString, required = false,
                                 default = nil)
  if valid_594031 != nil:
    section.add "X-Amz-Signature", valid_594031
  var valid_594032 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594032 = validateParameter(valid_594032, JString, required = false,
                                 default = nil)
  if valid_594032 != nil:
    section.add "X-Amz-Content-Sha256", valid_594032
  var valid_594033 = header.getOrDefault("X-Amz-Date")
  valid_594033 = validateParameter(valid_594033, JString, required = false,
                                 default = nil)
  if valid_594033 != nil:
    section.add "X-Amz-Date", valid_594033
  var valid_594034 = header.getOrDefault("X-Amz-Credential")
  valid_594034 = validateParameter(valid_594034, JString, required = false,
                                 default = nil)
  if valid_594034 != nil:
    section.add "X-Amz-Credential", valid_594034
  var valid_594035 = header.getOrDefault("X-Amz-Security-Token")
  valid_594035 = validateParameter(valid_594035, JString, required = false,
                                 default = nil)
  if valid_594035 != nil:
    section.add "X-Amz-Security-Token", valid_594035
  var valid_594036 = header.getOrDefault("X-Amz-Algorithm")
  valid_594036 = validateParameter(valid_594036, JString, required = false,
                                 default = nil)
  if valid_594036 != nil:
    section.add "X-Amz-Algorithm", valid_594036
  var valid_594037 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594037 = validateParameter(valid_594037, JString, required = false,
                                 default = nil)
  if valid_594037 != nil:
    section.add "X-Amz-SignedHeaders", valid_594037
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594039: Call_AssociateTargetsWithJob_594027; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ## 
  let valid = call_594039.validator(path, query, header, formData, body)
  let scheme = call_594039.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594039.url(scheme.get, call_594039.host, call_594039.base,
                         call_594039.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594039, url, valid)

proc call*(call_594040: Call_AssociateTargetsWithJob_594027; jobId: string;
          body: JsonNode): Recallable =
  ## associateTargetsWithJob
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   body: JObject (required)
  var path_594041 = newJObject()
  var body_594042 = newJObject()
  add(path_594041, "jobId", newJString(jobId))
  if body != nil:
    body_594042 = body
  result = call_594040.call(path_594041, nil, nil, nil, body_594042)

var associateTargetsWithJob* = Call_AssociateTargetsWithJob_594027(
    name: "associateTargetsWithJob", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/jobs/{jobId}/targets",
    validator: validate_AssociateTargetsWithJob_594028, base: "/",
    url: url_AssociateTargetsWithJob_594029, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachPolicy_594043 = ref object of OpenApiRestCall_593389
proc url_AttachPolicy_594045(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/target-policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachPolicy_594044(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Attaches a policy to the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to attach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594046 = path.getOrDefault("policyName")
  valid_594046 = validateParameter(valid_594046, JString, required = true,
                                 default = nil)
  if valid_594046 != nil:
    section.add "policyName", valid_594046
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594047 = header.getOrDefault("X-Amz-Signature")
  valid_594047 = validateParameter(valid_594047, JString, required = false,
                                 default = nil)
  if valid_594047 != nil:
    section.add "X-Amz-Signature", valid_594047
  var valid_594048 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594048 = validateParameter(valid_594048, JString, required = false,
                                 default = nil)
  if valid_594048 != nil:
    section.add "X-Amz-Content-Sha256", valid_594048
  var valid_594049 = header.getOrDefault("X-Amz-Date")
  valid_594049 = validateParameter(valid_594049, JString, required = false,
                                 default = nil)
  if valid_594049 != nil:
    section.add "X-Amz-Date", valid_594049
  var valid_594050 = header.getOrDefault("X-Amz-Credential")
  valid_594050 = validateParameter(valid_594050, JString, required = false,
                                 default = nil)
  if valid_594050 != nil:
    section.add "X-Amz-Credential", valid_594050
  var valid_594051 = header.getOrDefault("X-Amz-Security-Token")
  valid_594051 = validateParameter(valid_594051, JString, required = false,
                                 default = nil)
  if valid_594051 != nil:
    section.add "X-Amz-Security-Token", valid_594051
  var valid_594052 = header.getOrDefault("X-Amz-Algorithm")
  valid_594052 = validateParameter(valid_594052, JString, required = false,
                                 default = nil)
  if valid_594052 != nil:
    section.add "X-Amz-Algorithm", valid_594052
  var valid_594053 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594053 = validateParameter(valid_594053, JString, required = false,
                                 default = nil)
  if valid_594053 != nil:
    section.add "X-Amz-SignedHeaders", valid_594053
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594055: Call_AttachPolicy_594043; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Attaches a policy to the specified target.
  ## 
  let valid = call_594055.validator(path, query, header, formData, body)
  let scheme = call_594055.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594055.url(scheme.get, call_594055.host, call_594055.base,
                         call_594055.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594055, url, valid)

proc call*(call_594056: Call_AttachPolicy_594043; policyName: string; body: JsonNode): Recallable =
  ## attachPolicy
  ## Attaches a policy to the specified target.
  ##   policyName: string (required)
  ##             : The name of the policy to attach.
  ##   body: JObject (required)
  var path_594057 = newJObject()
  var body_594058 = newJObject()
  add(path_594057, "policyName", newJString(policyName))
  if body != nil:
    body_594058 = body
  result = call_594056.call(path_594057, nil, nil, nil, body_594058)

var attachPolicy* = Call_AttachPolicy_594043(name: "attachPolicy",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/target-policies/{policyName}", validator: validate_AttachPolicy_594044,
    base: "/", url: url_AttachPolicy_594045, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachPolicy_594059 = ref object of OpenApiRestCall_593389
proc url_DetachPolicy_594061(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/target-policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachPolicy_594060(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Detaches a policy from the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy to detach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594062 = path.getOrDefault("policyName")
  valid_594062 = validateParameter(valid_594062, JString, required = true,
                                 default = nil)
  if valid_594062 != nil:
    section.add "policyName", valid_594062
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594063 = header.getOrDefault("X-Amz-Signature")
  valid_594063 = validateParameter(valid_594063, JString, required = false,
                                 default = nil)
  if valid_594063 != nil:
    section.add "X-Amz-Signature", valid_594063
  var valid_594064 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594064 = validateParameter(valid_594064, JString, required = false,
                                 default = nil)
  if valid_594064 != nil:
    section.add "X-Amz-Content-Sha256", valid_594064
  var valid_594065 = header.getOrDefault("X-Amz-Date")
  valid_594065 = validateParameter(valid_594065, JString, required = false,
                                 default = nil)
  if valid_594065 != nil:
    section.add "X-Amz-Date", valid_594065
  var valid_594066 = header.getOrDefault("X-Amz-Credential")
  valid_594066 = validateParameter(valid_594066, JString, required = false,
                                 default = nil)
  if valid_594066 != nil:
    section.add "X-Amz-Credential", valid_594066
  var valid_594067 = header.getOrDefault("X-Amz-Security-Token")
  valid_594067 = validateParameter(valid_594067, JString, required = false,
                                 default = nil)
  if valid_594067 != nil:
    section.add "X-Amz-Security-Token", valid_594067
  var valid_594068 = header.getOrDefault("X-Amz-Algorithm")
  valid_594068 = validateParameter(valid_594068, JString, required = false,
                                 default = nil)
  if valid_594068 != nil:
    section.add "X-Amz-Algorithm", valid_594068
  var valid_594069 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594069 = validateParameter(valid_594069, JString, required = false,
                                 default = nil)
  if valid_594069 != nil:
    section.add "X-Amz-SignedHeaders", valid_594069
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594071: Call_DetachPolicy_594059; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Detaches a policy from the specified target.
  ## 
  let valid = call_594071.validator(path, query, header, formData, body)
  let scheme = call_594071.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594071.url(scheme.get, call_594071.host, call_594071.base,
                         call_594071.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594071, url, valid)

proc call*(call_594072: Call_DetachPolicy_594059; policyName: string; body: JsonNode): Recallable =
  ## detachPolicy
  ## Detaches a policy from the specified target.
  ##   policyName: string (required)
  ##             : The policy to detach.
  ##   body: JObject (required)
  var path_594073 = newJObject()
  var body_594074 = newJObject()
  add(path_594073, "policyName", newJString(policyName))
  if body != nil:
    body_594074 = body
  result = call_594072.call(path_594073, nil, nil, nil, body_594074)

var detachPolicy* = Call_DetachPolicy_594059(name: "detachPolicy",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/target-policies/{policyName}", validator: validate_DetachPolicy_594060,
    base: "/", url: url_DetachPolicy_594061, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachPrincipalPolicy_594075 = ref object of OpenApiRestCall_593389
proc url_AttachPrincipalPolicy_594077(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/principal-policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "#x-amzn-iot-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachPrincipalPolicy_594076(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594078 = path.getOrDefault("policyName")
  valid_594078 = validateParameter(valid_594078, JString, required = true,
                                 default = nil)
  if valid_594078 != nil:
    section.add "policyName", valid_594078
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594079 = header.getOrDefault("X-Amz-Signature")
  valid_594079 = validateParameter(valid_594079, JString, required = false,
                                 default = nil)
  if valid_594079 != nil:
    section.add "X-Amz-Signature", valid_594079
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_594080 = header.getOrDefault("x-amzn-iot-principal")
  valid_594080 = validateParameter(valid_594080, JString, required = true,
                                 default = nil)
  if valid_594080 != nil:
    section.add "x-amzn-iot-principal", valid_594080
  var valid_594081 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594081 = validateParameter(valid_594081, JString, required = false,
                                 default = nil)
  if valid_594081 != nil:
    section.add "X-Amz-Content-Sha256", valid_594081
  var valid_594082 = header.getOrDefault("X-Amz-Date")
  valid_594082 = validateParameter(valid_594082, JString, required = false,
                                 default = nil)
  if valid_594082 != nil:
    section.add "X-Amz-Date", valid_594082
  var valid_594083 = header.getOrDefault("X-Amz-Credential")
  valid_594083 = validateParameter(valid_594083, JString, required = false,
                                 default = nil)
  if valid_594083 != nil:
    section.add "X-Amz-Credential", valid_594083
  var valid_594084 = header.getOrDefault("X-Amz-Security-Token")
  valid_594084 = validateParameter(valid_594084, JString, required = false,
                                 default = nil)
  if valid_594084 != nil:
    section.add "X-Amz-Security-Token", valid_594084
  var valid_594085 = header.getOrDefault("X-Amz-Algorithm")
  valid_594085 = validateParameter(valid_594085, JString, required = false,
                                 default = nil)
  if valid_594085 != nil:
    section.add "X-Amz-Algorithm", valid_594085
  var valid_594086 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594086 = validateParameter(valid_594086, JString, required = false,
                                 default = nil)
  if valid_594086 != nil:
    section.add "X-Amz-SignedHeaders", valid_594086
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594087: Call_AttachPrincipalPolicy_594075; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ## 
  let valid = call_594087.validator(path, query, header, formData, body)
  let scheme = call_594087.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594087.url(scheme.get, call_594087.host, call_594087.base,
                         call_594087.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594087, url, valid)

proc call*(call_594088: Call_AttachPrincipalPolicy_594075; policyName: string): Recallable =
  ## attachPrincipalPolicy
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ##   policyName: string (required)
  ##             : The policy name.
  var path_594089 = newJObject()
  add(path_594089, "policyName", newJString(policyName))
  result = call_594088.call(path_594089, nil, nil, nil, nil)

var attachPrincipalPolicy* = Call_AttachPrincipalPolicy_594075(
    name: "attachPrincipalPolicy", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/principal-policies/{policyName}#x-amzn-iot-principal",
    validator: validate_AttachPrincipalPolicy_594076, base: "/",
    url: url_AttachPrincipalPolicy_594077, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachPrincipalPolicy_594090 = ref object of OpenApiRestCall_593389
proc url_DetachPrincipalPolicy_594092(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/principal-policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "#x-amzn-iot-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachPrincipalPolicy_594091(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to detach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594093 = path.getOrDefault("policyName")
  valid_594093 = validateParameter(valid_594093, JString, required = true,
                                 default = nil)
  if valid_594093 != nil:
    section.add "policyName", valid_594093
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : <p>The principal.</p> <p>If the principal is a certificate, specify the certificate ARN. If the principal is an Amazon Cognito identity, specify the identity ID.</p>
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594094 = header.getOrDefault("X-Amz-Signature")
  valid_594094 = validateParameter(valid_594094, JString, required = false,
                                 default = nil)
  if valid_594094 != nil:
    section.add "X-Amz-Signature", valid_594094
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_594095 = header.getOrDefault("x-amzn-iot-principal")
  valid_594095 = validateParameter(valid_594095, JString, required = true,
                                 default = nil)
  if valid_594095 != nil:
    section.add "x-amzn-iot-principal", valid_594095
  var valid_594096 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594096 = validateParameter(valid_594096, JString, required = false,
                                 default = nil)
  if valid_594096 != nil:
    section.add "X-Amz-Content-Sha256", valid_594096
  var valid_594097 = header.getOrDefault("X-Amz-Date")
  valid_594097 = validateParameter(valid_594097, JString, required = false,
                                 default = nil)
  if valid_594097 != nil:
    section.add "X-Amz-Date", valid_594097
  var valid_594098 = header.getOrDefault("X-Amz-Credential")
  valid_594098 = validateParameter(valid_594098, JString, required = false,
                                 default = nil)
  if valid_594098 != nil:
    section.add "X-Amz-Credential", valid_594098
  var valid_594099 = header.getOrDefault("X-Amz-Security-Token")
  valid_594099 = validateParameter(valid_594099, JString, required = false,
                                 default = nil)
  if valid_594099 != nil:
    section.add "X-Amz-Security-Token", valid_594099
  var valid_594100 = header.getOrDefault("X-Amz-Algorithm")
  valid_594100 = validateParameter(valid_594100, JString, required = false,
                                 default = nil)
  if valid_594100 != nil:
    section.add "X-Amz-Algorithm", valid_594100
  var valid_594101 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594101 = validateParameter(valid_594101, JString, required = false,
                                 default = nil)
  if valid_594101 != nil:
    section.add "X-Amz-SignedHeaders", valid_594101
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594102: Call_DetachPrincipalPolicy_594090; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ## 
  let valid = call_594102.validator(path, query, header, formData, body)
  let scheme = call_594102.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594102.url(scheme.get, call_594102.host, call_594102.base,
                         call_594102.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594102, url, valid)

proc call*(call_594103: Call_DetachPrincipalPolicy_594090; policyName: string): Recallable =
  ## detachPrincipalPolicy
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ##   policyName: string (required)
  ##             : The name of the policy to detach.
  var path_594104 = newJObject()
  add(path_594104, "policyName", newJString(policyName))
  result = call_594103.call(path_594104, nil, nil, nil, nil)

var detachPrincipalPolicy* = Call_DetachPrincipalPolicy_594090(
    name: "detachPrincipalPolicy", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/principal-policies/{policyName}#x-amzn-iot-principal",
    validator: validate_DetachPrincipalPolicy_594091, base: "/",
    url: url_DetachPrincipalPolicy_594092, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachSecurityProfile_594105 = ref object of OpenApiRestCall_593389
proc url_AttachSecurityProfile_594107(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"), (
        kind: ConstantSegment, value: "/targets#securityProfileTargetArn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachSecurityProfile_594106(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile that is attached.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_594108 = path.getOrDefault("securityProfileName")
  valid_594108 = validateParameter(valid_594108, JString, required = true,
                                 default = nil)
  if valid_594108 != nil:
    section.add "securityProfileName", valid_594108
  result.add "path", section
  ## parameters in `query` object:
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the target (thing group) to which the security profile is attached.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_594109 = query.getOrDefault("securityProfileTargetArn")
  valid_594109 = validateParameter(valid_594109, JString, required = true,
                                 default = nil)
  if valid_594109 != nil:
    section.add "securityProfileTargetArn", valid_594109
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594110 = header.getOrDefault("X-Amz-Signature")
  valid_594110 = validateParameter(valid_594110, JString, required = false,
                                 default = nil)
  if valid_594110 != nil:
    section.add "X-Amz-Signature", valid_594110
  var valid_594111 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594111 = validateParameter(valid_594111, JString, required = false,
                                 default = nil)
  if valid_594111 != nil:
    section.add "X-Amz-Content-Sha256", valid_594111
  var valid_594112 = header.getOrDefault("X-Amz-Date")
  valid_594112 = validateParameter(valid_594112, JString, required = false,
                                 default = nil)
  if valid_594112 != nil:
    section.add "X-Amz-Date", valid_594112
  var valid_594113 = header.getOrDefault("X-Amz-Credential")
  valid_594113 = validateParameter(valid_594113, JString, required = false,
                                 default = nil)
  if valid_594113 != nil:
    section.add "X-Amz-Credential", valid_594113
  var valid_594114 = header.getOrDefault("X-Amz-Security-Token")
  valid_594114 = validateParameter(valid_594114, JString, required = false,
                                 default = nil)
  if valid_594114 != nil:
    section.add "X-Amz-Security-Token", valid_594114
  var valid_594115 = header.getOrDefault("X-Amz-Algorithm")
  valid_594115 = validateParameter(valid_594115, JString, required = false,
                                 default = nil)
  if valid_594115 != nil:
    section.add "X-Amz-Algorithm", valid_594115
  var valid_594116 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594116 = validateParameter(valid_594116, JString, required = false,
                                 default = nil)
  if valid_594116 != nil:
    section.add "X-Amz-SignedHeaders", valid_594116
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594117: Call_AttachSecurityProfile_594105; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ## 
  let valid = call_594117.validator(path, query, header, formData, body)
  let scheme = call_594117.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594117.url(scheme.get, call_594117.host, call_594117.base,
                         call_594117.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594117, url, valid)

proc call*(call_594118: Call_AttachSecurityProfile_594105;
          securityProfileTargetArn: string; securityProfileName: string): Recallable =
  ## attachSecurityProfile
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the target (thing group) to which the security profile is attached.
  ##   securityProfileName: string (required)
  ##                      : The security profile that is attached.
  var path_594119 = newJObject()
  var query_594120 = newJObject()
  add(query_594120, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(path_594119, "securityProfileName", newJString(securityProfileName))
  result = call_594118.call(path_594119, query_594120, nil, nil, nil)

var attachSecurityProfile* = Call_AttachSecurityProfile_594105(
    name: "attachSecurityProfile", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}/targets#securityProfileTargetArn",
    validator: validate_AttachSecurityProfile_594106, base: "/",
    url: url_AttachSecurityProfile_594107, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachSecurityProfile_594121 = ref object of OpenApiRestCall_593389
proc url_DetachSecurityProfile_594123(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"), (
        kind: ConstantSegment, value: "/targets#securityProfileTargetArn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachSecurityProfile_594122(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile that is detached.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_594124 = path.getOrDefault("securityProfileName")
  valid_594124 = validateParameter(valid_594124, JString, required = true,
                                 default = nil)
  if valid_594124 != nil:
    section.add "securityProfileName", valid_594124
  result.add "path", section
  ## parameters in `query` object:
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the thing group from which the security profile is detached.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_594125 = query.getOrDefault("securityProfileTargetArn")
  valid_594125 = validateParameter(valid_594125, JString, required = true,
                                 default = nil)
  if valid_594125 != nil:
    section.add "securityProfileTargetArn", valid_594125
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594126 = header.getOrDefault("X-Amz-Signature")
  valid_594126 = validateParameter(valid_594126, JString, required = false,
                                 default = nil)
  if valid_594126 != nil:
    section.add "X-Amz-Signature", valid_594126
  var valid_594127 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594127 = validateParameter(valid_594127, JString, required = false,
                                 default = nil)
  if valid_594127 != nil:
    section.add "X-Amz-Content-Sha256", valid_594127
  var valid_594128 = header.getOrDefault("X-Amz-Date")
  valid_594128 = validateParameter(valid_594128, JString, required = false,
                                 default = nil)
  if valid_594128 != nil:
    section.add "X-Amz-Date", valid_594128
  var valid_594129 = header.getOrDefault("X-Amz-Credential")
  valid_594129 = validateParameter(valid_594129, JString, required = false,
                                 default = nil)
  if valid_594129 != nil:
    section.add "X-Amz-Credential", valid_594129
  var valid_594130 = header.getOrDefault("X-Amz-Security-Token")
  valid_594130 = validateParameter(valid_594130, JString, required = false,
                                 default = nil)
  if valid_594130 != nil:
    section.add "X-Amz-Security-Token", valid_594130
  var valid_594131 = header.getOrDefault("X-Amz-Algorithm")
  valid_594131 = validateParameter(valid_594131, JString, required = false,
                                 default = nil)
  if valid_594131 != nil:
    section.add "X-Amz-Algorithm", valid_594131
  var valid_594132 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594132 = validateParameter(valid_594132, JString, required = false,
                                 default = nil)
  if valid_594132 != nil:
    section.add "X-Amz-SignedHeaders", valid_594132
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594133: Call_DetachSecurityProfile_594121; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ## 
  let valid = call_594133.validator(path, query, header, formData, body)
  let scheme = call_594133.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594133.url(scheme.get, call_594133.host, call_594133.base,
                         call_594133.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594133, url, valid)

proc call*(call_594134: Call_DetachSecurityProfile_594121;
          securityProfileTargetArn: string; securityProfileName: string): Recallable =
  ## detachSecurityProfile
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the thing group from which the security profile is detached.
  ##   securityProfileName: string (required)
  ##                      : The security profile that is detached.
  var path_594135 = newJObject()
  var query_594136 = newJObject()
  add(query_594136, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(path_594135, "securityProfileName", newJString(securityProfileName))
  result = call_594134.call(path_594135, query_594136, nil, nil, nil)

var detachSecurityProfile* = Call_DetachSecurityProfile_594121(
    name: "detachSecurityProfile", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}/targets#securityProfileTargetArn",
    validator: validate_DetachSecurityProfile_594122, base: "/",
    url: url_DetachSecurityProfile_594123, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachThingPrincipal_594137 = ref object of OpenApiRestCall_593389
proc url_AttachThingPrincipal_594139(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals#x-amzn-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachThingPrincipal_594138(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_594140 = path.getOrDefault("thingName")
  valid_594140 = validateParameter(valid_594140, JString, required = true,
                                 default = nil)
  if valid_594140 != nil:
    section.add "thingName", valid_594140
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594141 = header.getOrDefault("X-Amz-Signature")
  valid_594141 = validateParameter(valid_594141, JString, required = false,
                                 default = nil)
  if valid_594141 != nil:
    section.add "X-Amz-Signature", valid_594141
  var valid_594142 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594142 = validateParameter(valid_594142, JString, required = false,
                                 default = nil)
  if valid_594142 != nil:
    section.add "X-Amz-Content-Sha256", valid_594142
  var valid_594143 = header.getOrDefault("X-Amz-Date")
  valid_594143 = validateParameter(valid_594143, JString, required = false,
                                 default = nil)
  if valid_594143 != nil:
    section.add "X-Amz-Date", valid_594143
  var valid_594144 = header.getOrDefault("X-Amz-Credential")
  valid_594144 = validateParameter(valid_594144, JString, required = false,
                                 default = nil)
  if valid_594144 != nil:
    section.add "X-Amz-Credential", valid_594144
  var valid_594145 = header.getOrDefault("X-Amz-Security-Token")
  valid_594145 = validateParameter(valid_594145, JString, required = false,
                                 default = nil)
  if valid_594145 != nil:
    section.add "X-Amz-Security-Token", valid_594145
  var valid_594146 = header.getOrDefault("X-Amz-Algorithm")
  valid_594146 = validateParameter(valid_594146, JString, required = false,
                                 default = nil)
  if valid_594146 != nil:
    section.add "X-Amz-Algorithm", valid_594146
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_594147 = header.getOrDefault("x-amzn-principal")
  valid_594147 = validateParameter(valid_594147, JString, required = true,
                                 default = nil)
  if valid_594147 != nil:
    section.add "x-amzn-principal", valid_594147
  var valid_594148 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594148 = validateParameter(valid_594148, JString, required = false,
                                 default = nil)
  if valid_594148 != nil:
    section.add "X-Amz-SignedHeaders", valid_594148
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594149: Call_AttachThingPrincipal_594137; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  let valid = call_594149.validator(path, query, header, formData, body)
  let scheme = call_594149.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594149.url(scheme.get, call_594149.host, call_594149.base,
                         call_594149.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594149, url, valid)

proc call*(call_594150: Call_AttachThingPrincipal_594137; thingName: string): Recallable =
  ## attachThingPrincipal
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_594151 = newJObject()
  add(path_594151, "thingName", newJString(thingName))
  result = call_594150.call(path_594151, nil, nil, nil, nil)

var attachThingPrincipal* = Call_AttachThingPrincipal_594137(
    name: "attachThingPrincipal", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/things/{thingName}/principals#x-amzn-principal",
    validator: validate_AttachThingPrincipal_594138, base: "/",
    url: url_AttachThingPrincipal_594139, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachThingPrincipal_594152 = ref object of OpenApiRestCall_593389
proc url_DetachThingPrincipal_594154(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals#x-amzn-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachThingPrincipal_594153(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_594155 = path.getOrDefault("thingName")
  valid_594155 = validateParameter(valid_594155, JString, required = true,
                                 default = nil)
  if valid_594155 != nil:
    section.add "thingName", valid_594155
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594156 = header.getOrDefault("X-Amz-Signature")
  valid_594156 = validateParameter(valid_594156, JString, required = false,
                                 default = nil)
  if valid_594156 != nil:
    section.add "X-Amz-Signature", valid_594156
  var valid_594157 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594157 = validateParameter(valid_594157, JString, required = false,
                                 default = nil)
  if valid_594157 != nil:
    section.add "X-Amz-Content-Sha256", valid_594157
  var valid_594158 = header.getOrDefault("X-Amz-Date")
  valid_594158 = validateParameter(valid_594158, JString, required = false,
                                 default = nil)
  if valid_594158 != nil:
    section.add "X-Amz-Date", valid_594158
  var valid_594159 = header.getOrDefault("X-Amz-Credential")
  valid_594159 = validateParameter(valid_594159, JString, required = false,
                                 default = nil)
  if valid_594159 != nil:
    section.add "X-Amz-Credential", valid_594159
  var valid_594160 = header.getOrDefault("X-Amz-Security-Token")
  valid_594160 = validateParameter(valid_594160, JString, required = false,
                                 default = nil)
  if valid_594160 != nil:
    section.add "X-Amz-Security-Token", valid_594160
  var valid_594161 = header.getOrDefault("X-Amz-Algorithm")
  valid_594161 = validateParameter(valid_594161, JString, required = false,
                                 default = nil)
  if valid_594161 != nil:
    section.add "X-Amz-Algorithm", valid_594161
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_594162 = header.getOrDefault("x-amzn-principal")
  valid_594162 = validateParameter(valid_594162, JString, required = true,
                                 default = nil)
  if valid_594162 != nil:
    section.add "x-amzn-principal", valid_594162
  var valid_594163 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594163 = validateParameter(valid_594163, JString, required = false,
                                 default = nil)
  if valid_594163 != nil:
    section.add "X-Amz-SignedHeaders", valid_594163
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594164: Call_DetachThingPrincipal_594152; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ## 
  let valid = call_594164.validator(path, query, header, formData, body)
  let scheme = call_594164.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594164.url(scheme.get, call_594164.host, call_594164.base,
                         call_594164.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594164, url, valid)

proc call*(call_594165: Call_DetachThingPrincipal_594152; thingName: string): Recallable =
  ## detachThingPrincipal
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_594166 = newJObject()
  add(path_594166, "thingName", newJString(thingName))
  result = call_594165.call(path_594166, nil, nil, nil, nil)

var detachThingPrincipal* = Call_DetachThingPrincipal_594152(
    name: "detachThingPrincipal", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/things/{thingName}/principals#x-amzn-principal",
    validator: validate_DetachThingPrincipal_594153, base: "/",
    url: url_DetachThingPrincipal_594154, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelAuditMitigationActionsTask_594167 = ref object of OpenApiRestCall_593389
proc url_CancelAuditMitigationActionsTask_594169(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelAuditMitigationActionsTask_594168(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The unique identifier for the task that you want to cancel. 
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_594170 = path.getOrDefault("taskId")
  valid_594170 = validateParameter(valid_594170, JString, required = true,
                                 default = nil)
  if valid_594170 != nil:
    section.add "taskId", valid_594170
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594171 = header.getOrDefault("X-Amz-Signature")
  valid_594171 = validateParameter(valid_594171, JString, required = false,
                                 default = nil)
  if valid_594171 != nil:
    section.add "X-Amz-Signature", valid_594171
  var valid_594172 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594172 = validateParameter(valid_594172, JString, required = false,
                                 default = nil)
  if valid_594172 != nil:
    section.add "X-Amz-Content-Sha256", valid_594172
  var valid_594173 = header.getOrDefault("X-Amz-Date")
  valid_594173 = validateParameter(valid_594173, JString, required = false,
                                 default = nil)
  if valid_594173 != nil:
    section.add "X-Amz-Date", valid_594173
  var valid_594174 = header.getOrDefault("X-Amz-Credential")
  valid_594174 = validateParameter(valid_594174, JString, required = false,
                                 default = nil)
  if valid_594174 != nil:
    section.add "X-Amz-Credential", valid_594174
  var valid_594175 = header.getOrDefault("X-Amz-Security-Token")
  valid_594175 = validateParameter(valid_594175, JString, required = false,
                                 default = nil)
  if valid_594175 != nil:
    section.add "X-Amz-Security-Token", valid_594175
  var valid_594176 = header.getOrDefault("X-Amz-Algorithm")
  valid_594176 = validateParameter(valid_594176, JString, required = false,
                                 default = nil)
  if valid_594176 != nil:
    section.add "X-Amz-Algorithm", valid_594176
  var valid_594177 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594177 = validateParameter(valid_594177, JString, required = false,
                                 default = nil)
  if valid_594177 != nil:
    section.add "X-Amz-SignedHeaders", valid_594177
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594178: Call_CancelAuditMitigationActionsTask_594167;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ## 
  let valid = call_594178.validator(path, query, header, formData, body)
  let scheme = call_594178.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594178.url(scheme.get, call_594178.host, call_594178.base,
                         call_594178.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594178, url, valid)

proc call*(call_594179: Call_CancelAuditMitigationActionsTask_594167;
          taskId: string): Recallable =
  ## cancelAuditMitigationActionsTask
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ##   taskId: string (required)
  ##         : The unique identifier for the task that you want to cancel. 
  var path_594180 = newJObject()
  add(path_594180, "taskId", newJString(taskId))
  result = call_594179.call(path_594180, nil, nil, nil, nil)

var cancelAuditMitigationActionsTask* = Call_CancelAuditMitigationActionsTask_594167(
    name: "cancelAuditMitigationActionsTask", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/tasks/{taskId}/cancel",
    validator: validate_CancelAuditMitigationActionsTask_594168, base: "/",
    url: url_CancelAuditMitigationActionsTask_594169,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelAuditTask_594181 = ref object of OpenApiRestCall_593389
proc url_CancelAuditTask_594183(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelAuditTask_594182(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_594184 = path.getOrDefault("taskId")
  valid_594184 = validateParameter(valid_594184, JString, required = true,
                                 default = nil)
  if valid_594184 != nil:
    section.add "taskId", valid_594184
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594185 = header.getOrDefault("X-Amz-Signature")
  valid_594185 = validateParameter(valid_594185, JString, required = false,
                                 default = nil)
  if valid_594185 != nil:
    section.add "X-Amz-Signature", valid_594185
  var valid_594186 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594186 = validateParameter(valid_594186, JString, required = false,
                                 default = nil)
  if valid_594186 != nil:
    section.add "X-Amz-Content-Sha256", valid_594186
  var valid_594187 = header.getOrDefault("X-Amz-Date")
  valid_594187 = validateParameter(valid_594187, JString, required = false,
                                 default = nil)
  if valid_594187 != nil:
    section.add "X-Amz-Date", valid_594187
  var valid_594188 = header.getOrDefault("X-Amz-Credential")
  valid_594188 = validateParameter(valid_594188, JString, required = false,
                                 default = nil)
  if valid_594188 != nil:
    section.add "X-Amz-Credential", valid_594188
  var valid_594189 = header.getOrDefault("X-Amz-Security-Token")
  valid_594189 = validateParameter(valid_594189, JString, required = false,
                                 default = nil)
  if valid_594189 != nil:
    section.add "X-Amz-Security-Token", valid_594189
  var valid_594190 = header.getOrDefault("X-Amz-Algorithm")
  valid_594190 = validateParameter(valid_594190, JString, required = false,
                                 default = nil)
  if valid_594190 != nil:
    section.add "X-Amz-Algorithm", valid_594190
  var valid_594191 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594191 = validateParameter(valid_594191, JString, required = false,
                                 default = nil)
  if valid_594191 != nil:
    section.add "X-Amz-SignedHeaders", valid_594191
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594192: Call_CancelAuditTask_594181; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ## 
  let valid = call_594192.validator(path, query, header, formData, body)
  let scheme = call_594192.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594192.url(scheme.get, call_594192.host, call_594192.base,
                         call_594192.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594192, url, valid)

proc call*(call_594193: Call_CancelAuditTask_594181; taskId: string): Recallable =
  ## cancelAuditTask
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ##   taskId: string (required)
  ##         : The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
  var path_594194 = newJObject()
  add(path_594194, "taskId", newJString(taskId))
  result = call_594193.call(path_594194, nil, nil, nil, nil)

var cancelAuditTask* = Call_CancelAuditTask_594181(name: "cancelAuditTask",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/audit/tasks/{taskId}/cancel", validator: validate_CancelAuditTask_594182,
    base: "/", url: url_CancelAuditTask_594183, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelCertificateTransfer_594195 = ref object of OpenApiRestCall_593389
proc url_CancelCertificateTransfer_594197(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cancel-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelCertificateTransfer_594196(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_594198 = path.getOrDefault("certificateId")
  valid_594198 = validateParameter(valid_594198, JString, required = true,
                                 default = nil)
  if valid_594198 != nil:
    section.add "certificateId", valid_594198
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594199 = header.getOrDefault("X-Amz-Signature")
  valid_594199 = validateParameter(valid_594199, JString, required = false,
                                 default = nil)
  if valid_594199 != nil:
    section.add "X-Amz-Signature", valid_594199
  var valid_594200 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594200 = validateParameter(valid_594200, JString, required = false,
                                 default = nil)
  if valid_594200 != nil:
    section.add "X-Amz-Content-Sha256", valid_594200
  var valid_594201 = header.getOrDefault("X-Amz-Date")
  valid_594201 = validateParameter(valid_594201, JString, required = false,
                                 default = nil)
  if valid_594201 != nil:
    section.add "X-Amz-Date", valid_594201
  var valid_594202 = header.getOrDefault("X-Amz-Credential")
  valid_594202 = validateParameter(valid_594202, JString, required = false,
                                 default = nil)
  if valid_594202 != nil:
    section.add "X-Amz-Credential", valid_594202
  var valid_594203 = header.getOrDefault("X-Amz-Security-Token")
  valid_594203 = validateParameter(valid_594203, JString, required = false,
                                 default = nil)
  if valid_594203 != nil:
    section.add "X-Amz-Security-Token", valid_594203
  var valid_594204 = header.getOrDefault("X-Amz-Algorithm")
  valid_594204 = validateParameter(valid_594204, JString, required = false,
                                 default = nil)
  if valid_594204 != nil:
    section.add "X-Amz-Algorithm", valid_594204
  var valid_594205 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594205 = validateParameter(valid_594205, JString, required = false,
                                 default = nil)
  if valid_594205 != nil:
    section.add "X-Amz-SignedHeaders", valid_594205
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594206: Call_CancelCertificateTransfer_594195; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ## 
  let valid = call_594206.validator(path, query, header, formData, body)
  let scheme = call_594206.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594206.url(scheme.get, call_594206.host, call_594206.base,
                         call_594206.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594206, url, valid)

proc call*(call_594207: Call_CancelCertificateTransfer_594195;
          certificateId: string): Recallable =
  ## cancelCertificateTransfer
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_594208 = newJObject()
  add(path_594208, "certificateId", newJString(certificateId))
  result = call_594207.call(path_594208, nil, nil, nil, nil)

var cancelCertificateTransfer* = Call_CancelCertificateTransfer_594195(
    name: "cancelCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/cancel-certificate-transfer/{certificateId}",
    validator: validate_CancelCertificateTransfer_594196, base: "/",
    url: url_CancelCertificateTransfer_594197,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelJob_594209 = ref object of OpenApiRestCall_593389
proc url_CancelJob_594211(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelJob_594210(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_594212 = path.getOrDefault("jobId")
  valid_594212 = validateParameter(valid_594212, JString, required = true,
                                 default = nil)
  if valid_594212 != nil:
    section.add "jobId", valid_594212
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
  section = newJObject()
  var valid_594213 = query.getOrDefault("force")
  valid_594213 = validateParameter(valid_594213, JBool, required = false, default = nil)
  if valid_594213 != nil:
    section.add "force", valid_594213
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594214 = header.getOrDefault("X-Amz-Signature")
  valid_594214 = validateParameter(valid_594214, JString, required = false,
                                 default = nil)
  if valid_594214 != nil:
    section.add "X-Amz-Signature", valid_594214
  var valid_594215 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594215 = validateParameter(valid_594215, JString, required = false,
                                 default = nil)
  if valid_594215 != nil:
    section.add "X-Amz-Content-Sha256", valid_594215
  var valid_594216 = header.getOrDefault("X-Amz-Date")
  valid_594216 = validateParameter(valid_594216, JString, required = false,
                                 default = nil)
  if valid_594216 != nil:
    section.add "X-Amz-Date", valid_594216
  var valid_594217 = header.getOrDefault("X-Amz-Credential")
  valid_594217 = validateParameter(valid_594217, JString, required = false,
                                 default = nil)
  if valid_594217 != nil:
    section.add "X-Amz-Credential", valid_594217
  var valid_594218 = header.getOrDefault("X-Amz-Security-Token")
  valid_594218 = validateParameter(valid_594218, JString, required = false,
                                 default = nil)
  if valid_594218 != nil:
    section.add "X-Amz-Security-Token", valid_594218
  var valid_594219 = header.getOrDefault("X-Amz-Algorithm")
  valid_594219 = validateParameter(valid_594219, JString, required = false,
                                 default = nil)
  if valid_594219 != nil:
    section.add "X-Amz-Algorithm", valid_594219
  var valid_594220 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594220 = validateParameter(valid_594220, JString, required = false,
                                 default = nil)
  if valid_594220 != nil:
    section.add "X-Amz-SignedHeaders", valid_594220
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594222: Call_CancelJob_594209; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a job.
  ## 
  let valid = call_594222.validator(path, query, header, formData, body)
  let scheme = call_594222.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594222.url(scheme.get, call_594222.host, call_594222.base,
                         call_594222.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594222, url, valid)

proc call*(call_594223: Call_CancelJob_594209; jobId: string; body: JsonNode;
          force: bool = false): Recallable =
  ## cancelJob
  ## Cancels a job.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   force: bool
  ##        : <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
  ##   body: JObject (required)
  var path_594224 = newJObject()
  var query_594225 = newJObject()
  var body_594226 = newJObject()
  add(path_594224, "jobId", newJString(jobId))
  add(query_594225, "force", newJBool(force))
  if body != nil:
    body_594226 = body
  result = call_594223.call(path_594224, query_594225, nil, nil, body_594226)

var cancelJob* = Call_CancelJob_594209(name: "cancelJob", meth: HttpMethod.HttpPut,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}/cancel",
                                    validator: validate_CancelJob_594210,
                                    base: "/", url: url_CancelJob_594211,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelJobExecution_594227 = ref object of OpenApiRestCall_593389
proc url_CancelJobExecution_594229(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelJobExecution_594228(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Cancels the execution of a job for a given thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The ID of the job to be canceled.
  ##   thingName: JString (required)
  ##            : The name of the thing whose execution of the job will be canceled.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_594230 = path.getOrDefault("jobId")
  valid_594230 = validateParameter(valid_594230, JString, required = true,
                                 default = nil)
  if valid_594230 != nil:
    section.add "jobId", valid_594230
  var valid_594231 = path.getOrDefault("thingName")
  valid_594231 = validateParameter(valid_594231, JString, required = true,
                                 default = nil)
  if valid_594231 != nil:
    section.add "thingName", valid_594231
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
  section = newJObject()
  var valid_594232 = query.getOrDefault("force")
  valid_594232 = validateParameter(valid_594232, JBool, required = false, default = nil)
  if valid_594232 != nil:
    section.add "force", valid_594232
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594233 = header.getOrDefault("X-Amz-Signature")
  valid_594233 = validateParameter(valid_594233, JString, required = false,
                                 default = nil)
  if valid_594233 != nil:
    section.add "X-Amz-Signature", valid_594233
  var valid_594234 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594234 = validateParameter(valid_594234, JString, required = false,
                                 default = nil)
  if valid_594234 != nil:
    section.add "X-Amz-Content-Sha256", valid_594234
  var valid_594235 = header.getOrDefault("X-Amz-Date")
  valid_594235 = validateParameter(valid_594235, JString, required = false,
                                 default = nil)
  if valid_594235 != nil:
    section.add "X-Amz-Date", valid_594235
  var valid_594236 = header.getOrDefault("X-Amz-Credential")
  valid_594236 = validateParameter(valid_594236, JString, required = false,
                                 default = nil)
  if valid_594236 != nil:
    section.add "X-Amz-Credential", valid_594236
  var valid_594237 = header.getOrDefault("X-Amz-Security-Token")
  valid_594237 = validateParameter(valid_594237, JString, required = false,
                                 default = nil)
  if valid_594237 != nil:
    section.add "X-Amz-Security-Token", valid_594237
  var valid_594238 = header.getOrDefault("X-Amz-Algorithm")
  valid_594238 = validateParameter(valid_594238, JString, required = false,
                                 default = nil)
  if valid_594238 != nil:
    section.add "X-Amz-Algorithm", valid_594238
  var valid_594239 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594239 = validateParameter(valid_594239, JString, required = false,
                                 default = nil)
  if valid_594239 != nil:
    section.add "X-Amz-SignedHeaders", valid_594239
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594241: Call_CancelJobExecution_594227; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels the execution of a job for a given thing.
  ## 
  let valid = call_594241.validator(path, query, header, formData, body)
  let scheme = call_594241.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594241.url(scheme.get, call_594241.host, call_594241.base,
                         call_594241.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594241, url, valid)

proc call*(call_594242: Call_CancelJobExecution_594227; jobId: string;
          thingName: string; body: JsonNode; force: bool = false): Recallable =
  ## cancelJobExecution
  ## Cancels the execution of a job for a given thing.
  ##   jobId: string (required)
  ##        : The ID of the job to be canceled.
  ##   thingName: string (required)
  ##            : The name of the thing whose execution of the job will be canceled.
  ##   force: bool
  ##        : <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
  ##   body: JObject (required)
  var path_594243 = newJObject()
  var query_594244 = newJObject()
  var body_594245 = newJObject()
  add(path_594243, "jobId", newJString(jobId))
  add(path_594243, "thingName", newJString(thingName))
  add(query_594244, "force", newJBool(force))
  if body != nil:
    body_594245 = body
  result = call_594242.call(path_594243, query_594244, nil, nil, body_594245)

var cancelJobExecution* = Call_CancelJobExecution_594227(
    name: "cancelJobExecution", meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/things/{thingName}/jobs/{jobId}/cancel",
    validator: validate_CancelJobExecution_594228, base: "/",
    url: url_CancelJobExecution_594229, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetDefaultAuthorizer_594258 = ref object of OpenApiRestCall_593389
proc url_SetDefaultAuthorizer_594260(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetDefaultAuthorizer_594259(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594261 = header.getOrDefault("X-Amz-Signature")
  valid_594261 = validateParameter(valid_594261, JString, required = false,
                                 default = nil)
  if valid_594261 != nil:
    section.add "X-Amz-Signature", valid_594261
  var valid_594262 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594262 = validateParameter(valid_594262, JString, required = false,
                                 default = nil)
  if valid_594262 != nil:
    section.add "X-Amz-Content-Sha256", valid_594262
  var valid_594263 = header.getOrDefault("X-Amz-Date")
  valid_594263 = validateParameter(valid_594263, JString, required = false,
                                 default = nil)
  if valid_594263 != nil:
    section.add "X-Amz-Date", valid_594263
  var valid_594264 = header.getOrDefault("X-Amz-Credential")
  valid_594264 = validateParameter(valid_594264, JString, required = false,
                                 default = nil)
  if valid_594264 != nil:
    section.add "X-Amz-Credential", valid_594264
  var valid_594265 = header.getOrDefault("X-Amz-Security-Token")
  valid_594265 = validateParameter(valid_594265, JString, required = false,
                                 default = nil)
  if valid_594265 != nil:
    section.add "X-Amz-Security-Token", valid_594265
  var valid_594266 = header.getOrDefault("X-Amz-Algorithm")
  valid_594266 = validateParameter(valid_594266, JString, required = false,
                                 default = nil)
  if valid_594266 != nil:
    section.add "X-Amz-Algorithm", valid_594266
  var valid_594267 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594267 = validateParameter(valid_594267, JString, required = false,
                                 default = nil)
  if valid_594267 != nil:
    section.add "X-Amz-SignedHeaders", valid_594267
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594269: Call_SetDefaultAuthorizer_594258; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ## 
  let valid = call_594269.validator(path, query, header, formData, body)
  let scheme = call_594269.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594269.url(scheme.get, call_594269.host, call_594269.base,
                         call_594269.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594269, url, valid)

proc call*(call_594270: Call_SetDefaultAuthorizer_594258; body: JsonNode): Recallable =
  ## setDefaultAuthorizer
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ##   body: JObject (required)
  var body_594271 = newJObject()
  if body != nil:
    body_594271 = body
  result = call_594270.call(nil, nil, nil, nil, body_594271)

var setDefaultAuthorizer* = Call_SetDefaultAuthorizer_594258(
    name: "setDefaultAuthorizer", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_SetDefaultAuthorizer_594259, base: "/",
    url: url_SetDefaultAuthorizer_594260, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeDefaultAuthorizer_594246 = ref object of OpenApiRestCall_593389
proc url_DescribeDefaultAuthorizer_594248(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeDefaultAuthorizer_594247(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes the default authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594249 = header.getOrDefault("X-Amz-Signature")
  valid_594249 = validateParameter(valid_594249, JString, required = false,
                                 default = nil)
  if valid_594249 != nil:
    section.add "X-Amz-Signature", valid_594249
  var valid_594250 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594250 = validateParameter(valid_594250, JString, required = false,
                                 default = nil)
  if valid_594250 != nil:
    section.add "X-Amz-Content-Sha256", valid_594250
  var valid_594251 = header.getOrDefault("X-Amz-Date")
  valid_594251 = validateParameter(valid_594251, JString, required = false,
                                 default = nil)
  if valid_594251 != nil:
    section.add "X-Amz-Date", valid_594251
  var valid_594252 = header.getOrDefault("X-Amz-Credential")
  valid_594252 = validateParameter(valid_594252, JString, required = false,
                                 default = nil)
  if valid_594252 != nil:
    section.add "X-Amz-Credential", valid_594252
  var valid_594253 = header.getOrDefault("X-Amz-Security-Token")
  valid_594253 = validateParameter(valid_594253, JString, required = false,
                                 default = nil)
  if valid_594253 != nil:
    section.add "X-Amz-Security-Token", valid_594253
  var valid_594254 = header.getOrDefault("X-Amz-Algorithm")
  valid_594254 = validateParameter(valid_594254, JString, required = false,
                                 default = nil)
  if valid_594254 != nil:
    section.add "X-Amz-Algorithm", valid_594254
  var valid_594255 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594255 = validateParameter(valid_594255, JString, required = false,
                                 default = nil)
  if valid_594255 != nil:
    section.add "X-Amz-SignedHeaders", valid_594255
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594256: Call_DescribeDefaultAuthorizer_594246; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes the default authorizer.
  ## 
  let valid = call_594256.validator(path, query, header, formData, body)
  let scheme = call_594256.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594256.url(scheme.get, call_594256.host, call_594256.base,
                         call_594256.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594256, url, valid)

proc call*(call_594257: Call_DescribeDefaultAuthorizer_594246): Recallable =
  ## describeDefaultAuthorizer
  ## Describes the default authorizer.
  result = call_594257.call(nil, nil, nil, nil, nil)

var describeDefaultAuthorizer* = Call_DescribeDefaultAuthorizer_594246(
    name: "describeDefaultAuthorizer", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_DescribeDefaultAuthorizer_594247, base: "/",
    url: url_DescribeDefaultAuthorizer_594248,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ClearDefaultAuthorizer_594272 = ref object of OpenApiRestCall_593389
proc url_ClearDefaultAuthorizer_594274(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ClearDefaultAuthorizer_594273(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Clears the default authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594275 = header.getOrDefault("X-Amz-Signature")
  valid_594275 = validateParameter(valid_594275, JString, required = false,
                                 default = nil)
  if valid_594275 != nil:
    section.add "X-Amz-Signature", valid_594275
  var valid_594276 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594276 = validateParameter(valid_594276, JString, required = false,
                                 default = nil)
  if valid_594276 != nil:
    section.add "X-Amz-Content-Sha256", valid_594276
  var valid_594277 = header.getOrDefault("X-Amz-Date")
  valid_594277 = validateParameter(valid_594277, JString, required = false,
                                 default = nil)
  if valid_594277 != nil:
    section.add "X-Amz-Date", valid_594277
  var valid_594278 = header.getOrDefault("X-Amz-Credential")
  valid_594278 = validateParameter(valid_594278, JString, required = false,
                                 default = nil)
  if valid_594278 != nil:
    section.add "X-Amz-Credential", valid_594278
  var valid_594279 = header.getOrDefault("X-Amz-Security-Token")
  valid_594279 = validateParameter(valid_594279, JString, required = false,
                                 default = nil)
  if valid_594279 != nil:
    section.add "X-Amz-Security-Token", valid_594279
  var valid_594280 = header.getOrDefault("X-Amz-Algorithm")
  valid_594280 = validateParameter(valid_594280, JString, required = false,
                                 default = nil)
  if valid_594280 != nil:
    section.add "X-Amz-Algorithm", valid_594280
  var valid_594281 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594281 = validateParameter(valid_594281, JString, required = false,
                                 default = nil)
  if valid_594281 != nil:
    section.add "X-Amz-SignedHeaders", valid_594281
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594282: Call_ClearDefaultAuthorizer_594272; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Clears the default authorizer.
  ## 
  let valid = call_594282.validator(path, query, header, formData, body)
  let scheme = call_594282.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594282.url(scheme.get, call_594282.host, call_594282.base,
                         call_594282.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594282, url, valid)

proc call*(call_594283: Call_ClearDefaultAuthorizer_594272): Recallable =
  ## clearDefaultAuthorizer
  ## Clears the default authorizer.
  result = call_594283.call(nil, nil, nil, nil, nil)

var clearDefaultAuthorizer* = Call_ClearDefaultAuthorizer_594272(
    name: "clearDefaultAuthorizer", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_ClearDefaultAuthorizer_594273, base: "/",
    url: url_ClearDefaultAuthorizer_594274, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateAuthorizer_594298 = ref object of OpenApiRestCall_593389
proc url_UpdateAuthorizer_594300(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateAuthorizer_594299(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Updates an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_594301 = path.getOrDefault("authorizerName")
  valid_594301 = validateParameter(valid_594301, JString, required = true,
                                 default = nil)
  if valid_594301 != nil:
    section.add "authorizerName", valid_594301
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594302 = header.getOrDefault("X-Amz-Signature")
  valid_594302 = validateParameter(valid_594302, JString, required = false,
                                 default = nil)
  if valid_594302 != nil:
    section.add "X-Amz-Signature", valid_594302
  var valid_594303 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594303 = validateParameter(valid_594303, JString, required = false,
                                 default = nil)
  if valid_594303 != nil:
    section.add "X-Amz-Content-Sha256", valid_594303
  var valid_594304 = header.getOrDefault("X-Amz-Date")
  valid_594304 = validateParameter(valid_594304, JString, required = false,
                                 default = nil)
  if valid_594304 != nil:
    section.add "X-Amz-Date", valid_594304
  var valid_594305 = header.getOrDefault("X-Amz-Credential")
  valid_594305 = validateParameter(valid_594305, JString, required = false,
                                 default = nil)
  if valid_594305 != nil:
    section.add "X-Amz-Credential", valid_594305
  var valid_594306 = header.getOrDefault("X-Amz-Security-Token")
  valid_594306 = validateParameter(valid_594306, JString, required = false,
                                 default = nil)
  if valid_594306 != nil:
    section.add "X-Amz-Security-Token", valid_594306
  var valid_594307 = header.getOrDefault("X-Amz-Algorithm")
  valid_594307 = validateParameter(valid_594307, JString, required = false,
                                 default = nil)
  if valid_594307 != nil:
    section.add "X-Amz-Algorithm", valid_594307
  var valid_594308 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594308 = validateParameter(valid_594308, JString, required = false,
                                 default = nil)
  if valid_594308 != nil:
    section.add "X-Amz-SignedHeaders", valid_594308
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594310: Call_UpdateAuthorizer_594298; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an authorizer.
  ## 
  let valid = call_594310.validator(path, query, header, formData, body)
  let scheme = call_594310.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594310.url(scheme.get, call_594310.host, call_594310.base,
                         call_594310.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594310, url, valid)

proc call*(call_594311: Call_UpdateAuthorizer_594298; authorizerName: string;
          body: JsonNode): Recallable =
  ## updateAuthorizer
  ## Updates an authorizer.
  ##   authorizerName: string (required)
  ##                 : The authorizer name.
  ##   body: JObject (required)
  var path_594312 = newJObject()
  var body_594313 = newJObject()
  add(path_594312, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_594313 = body
  result = call_594311.call(path_594312, nil, nil, nil, body_594313)

var updateAuthorizer* = Call_UpdateAuthorizer_594298(name: "updateAuthorizer",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_UpdateAuthorizer_594299,
    base: "/", url: url_UpdateAuthorizer_594300,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateAuthorizer_594314 = ref object of OpenApiRestCall_593389
proc url_CreateAuthorizer_594316(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateAuthorizer_594315(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Creates an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_594317 = path.getOrDefault("authorizerName")
  valid_594317 = validateParameter(valid_594317, JString, required = true,
                                 default = nil)
  if valid_594317 != nil:
    section.add "authorizerName", valid_594317
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594318 = header.getOrDefault("X-Amz-Signature")
  valid_594318 = validateParameter(valid_594318, JString, required = false,
                                 default = nil)
  if valid_594318 != nil:
    section.add "X-Amz-Signature", valid_594318
  var valid_594319 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594319 = validateParameter(valid_594319, JString, required = false,
                                 default = nil)
  if valid_594319 != nil:
    section.add "X-Amz-Content-Sha256", valid_594319
  var valid_594320 = header.getOrDefault("X-Amz-Date")
  valid_594320 = validateParameter(valid_594320, JString, required = false,
                                 default = nil)
  if valid_594320 != nil:
    section.add "X-Amz-Date", valid_594320
  var valid_594321 = header.getOrDefault("X-Amz-Credential")
  valid_594321 = validateParameter(valid_594321, JString, required = false,
                                 default = nil)
  if valid_594321 != nil:
    section.add "X-Amz-Credential", valid_594321
  var valid_594322 = header.getOrDefault("X-Amz-Security-Token")
  valid_594322 = validateParameter(valid_594322, JString, required = false,
                                 default = nil)
  if valid_594322 != nil:
    section.add "X-Amz-Security-Token", valid_594322
  var valid_594323 = header.getOrDefault("X-Amz-Algorithm")
  valid_594323 = validateParameter(valid_594323, JString, required = false,
                                 default = nil)
  if valid_594323 != nil:
    section.add "X-Amz-Algorithm", valid_594323
  var valid_594324 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594324 = validateParameter(valid_594324, JString, required = false,
                                 default = nil)
  if valid_594324 != nil:
    section.add "X-Amz-SignedHeaders", valid_594324
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594326: Call_CreateAuthorizer_594314; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates an authorizer.
  ## 
  let valid = call_594326.validator(path, query, header, formData, body)
  let scheme = call_594326.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594326.url(scheme.get, call_594326.host, call_594326.base,
                         call_594326.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594326, url, valid)

proc call*(call_594327: Call_CreateAuthorizer_594314; authorizerName: string;
          body: JsonNode): Recallable =
  ## createAuthorizer
  ## Creates an authorizer.
  ##   authorizerName: string (required)
  ##                 : The authorizer name.
  ##   body: JObject (required)
  var path_594328 = newJObject()
  var body_594329 = newJObject()
  add(path_594328, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_594329 = body
  result = call_594327.call(path_594328, nil, nil, nil, body_594329)

var createAuthorizer* = Call_CreateAuthorizer_594314(name: "createAuthorizer",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_CreateAuthorizer_594315,
    base: "/", url: url_CreateAuthorizer_594316,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuthorizer_594284 = ref object of OpenApiRestCall_593389
proc url_DescribeAuthorizer_594286(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuthorizer_594285(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Describes an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The name of the authorizer to describe.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_594287 = path.getOrDefault("authorizerName")
  valid_594287 = validateParameter(valid_594287, JString, required = true,
                                 default = nil)
  if valid_594287 != nil:
    section.add "authorizerName", valid_594287
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594288 = header.getOrDefault("X-Amz-Signature")
  valid_594288 = validateParameter(valid_594288, JString, required = false,
                                 default = nil)
  if valid_594288 != nil:
    section.add "X-Amz-Signature", valid_594288
  var valid_594289 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594289 = validateParameter(valid_594289, JString, required = false,
                                 default = nil)
  if valid_594289 != nil:
    section.add "X-Amz-Content-Sha256", valid_594289
  var valid_594290 = header.getOrDefault("X-Amz-Date")
  valid_594290 = validateParameter(valid_594290, JString, required = false,
                                 default = nil)
  if valid_594290 != nil:
    section.add "X-Amz-Date", valid_594290
  var valid_594291 = header.getOrDefault("X-Amz-Credential")
  valid_594291 = validateParameter(valid_594291, JString, required = false,
                                 default = nil)
  if valid_594291 != nil:
    section.add "X-Amz-Credential", valid_594291
  var valid_594292 = header.getOrDefault("X-Amz-Security-Token")
  valid_594292 = validateParameter(valid_594292, JString, required = false,
                                 default = nil)
  if valid_594292 != nil:
    section.add "X-Amz-Security-Token", valid_594292
  var valid_594293 = header.getOrDefault("X-Amz-Algorithm")
  valid_594293 = validateParameter(valid_594293, JString, required = false,
                                 default = nil)
  if valid_594293 != nil:
    section.add "X-Amz-Algorithm", valid_594293
  var valid_594294 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594294 = validateParameter(valid_594294, JString, required = false,
                                 default = nil)
  if valid_594294 != nil:
    section.add "X-Amz-SignedHeaders", valid_594294
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594295: Call_DescribeAuthorizer_594284; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes an authorizer.
  ## 
  let valid = call_594295.validator(path, query, header, formData, body)
  let scheme = call_594295.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594295.url(scheme.get, call_594295.host, call_594295.base,
                         call_594295.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594295, url, valid)

proc call*(call_594296: Call_DescribeAuthorizer_594284; authorizerName: string): Recallable =
  ## describeAuthorizer
  ## Describes an authorizer.
  ##   authorizerName: string (required)
  ##                 : The name of the authorizer to describe.
  var path_594297 = newJObject()
  add(path_594297, "authorizerName", newJString(authorizerName))
  result = call_594296.call(path_594297, nil, nil, nil, nil)

var describeAuthorizer* = Call_DescribeAuthorizer_594284(
    name: "describeAuthorizer", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_DescribeAuthorizer_594285,
    base: "/", url: url_DescribeAuthorizer_594286,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteAuthorizer_594330 = ref object of OpenApiRestCall_593389
proc url_DeleteAuthorizer_594332(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteAuthorizer_594331(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Deletes an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The name of the authorizer to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_594333 = path.getOrDefault("authorizerName")
  valid_594333 = validateParameter(valid_594333, JString, required = true,
                                 default = nil)
  if valid_594333 != nil:
    section.add "authorizerName", valid_594333
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594334 = header.getOrDefault("X-Amz-Signature")
  valid_594334 = validateParameter(valid_594334, JString, required = false,
                                 default = nil)
  if valid_594334 != nil:
    section.add "X-Amz-Signature", valid_594334
  var valid_594335 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594335 = validateParameter(valid_594335, JString, required = false,
                                 default = nil)
  if valid_594335 != nil:
    section.add "X-Amz-Content-Sha256", valid_594335
  var valid_594336 = header.getOrDefault("X-Amz-Date")
  valid_594336 = validateParameter(valid_594336, JString, required = false,
                                 default = nil)
  if valid_594336 != nil:
    section.add "X-Amz-Date", valid_594336
  var valid_594337 = header.getOrDefault("X-Amz-Credential")
  valid_594337 = validateParameter(valid_594337, JString, required = false,
                                 default = nil)
  if valid_594337 != nil:
    section.add "X-Amz-Credential", valid_594337
  var valid_594338 = header.getOrDefault("X-Amz-Security-Token")
  valid_594338 = validateParameter(valid_594338, JString, required = false,
                                 default = nil)
  if valid_594338 != nil:
    section.add "X-Amz-Security-Token", valid_594338
  var valid_594339 = header.getOrDefault("X-Amz-Algorithm")
  valid_594339 = validateParameter(valid_594339, JString, required = false,
                                 default = nil)
  if valid_594339 != nil:
    section.add "X-Amz-Algorithm", valid_594339
  var valid_594340 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594340 = validateParameter(valid_594340, JString, required = false,
                                 default = nil)
  if valid_594340 != nil:
    section.add "X-Amz-SignedHeaders", valid_594340
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594341: Call_DeleteAuthorizer_594330; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an authorizer.
  ## 
  let valid = call_594341.validator(path, query, header, formData, body)
  let scheme = call_594341.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594341.url(scheme.get, call_594341.host, call_594341.base,
                         call_594341.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594341, url, valid)

proc call*(call_594342: Call_DeleteAuthorizer_594330; authorizerName: string): Recallable =
  ## deleteAuthorizer
  ## Deletes an authorizer.
  ##   authorizerName: string (required)
  ##                 : The name of the authorizer to delete.
  var path_594343 = newJObject()
  add(path_594343, "authorizerName", newJString(authorizerName))
  result = call_594342.call(path_594343, nil, nil, nil, nil)

var deleteAuthorizer* = Call_DeleteAuthorizer_594330(name: "deleteAuthorizer",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_DeleteAuthorizer_594331,
    base: "/", url: url_DeleteAuthorizer_594332,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateBillingGroup_594358 = ref object of OpenApiRestCall_593389
proc url_CreateBillingGroup_594360(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateBillingGroup_594359(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Creates a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name you wish to give to the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_594361 = path.getOrDefault("billingGroupName")
  valid_594361 = validateParameter(valid_594361, JString, required = true,
                                 default = nil)
  if valid_594361 != nil:
    section.add "billingGroupName", valid_594361
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594362 = header.getOrDefault("X-Amz-Signature")
  valid_594362 = validateParameter(valid_594362, JString, required = false,
                                 default = nil)
  if valid_594362 != nil:
    section.add "X-Amz-Signature", valid_594362
  var valid_594363 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594363 = validateParameter(valid_594363, JString, required = false,
                                 default = nil)
  if valid_594363 != nil:
    section.add "X-Amz-Content-Sha256", valid_594363
  var valid_594364 = header.getOrDefault("X-Amz-Date")
  valid_594364 = validateParameter(valid_594364, JString, required = false,
                                 default = nil)
  if valid_594364 != nil:
    section.add "X-Amz-Date", valid_594364
  var valid_594365 = header.getOrDefault("X-Amz-Credential")
  valid_594365 = validateParameter(valid_594365, JString, required = false,
                                 default = nil)
  if valid_594365 != nil:
    section.add "X-Amz-Credential", valid_594365
  var valid_594366 = header.getOrDefault("X-Amz-Security-Token")
  valid_594366 = validateParameter(valid_594366, JString, required = false,
                                 default = nil)
  if valid_594366 != nil:
    section.add "X-Amz-Security-Token", valid_594366
  var valid_594367 = header.getOrDefault("X-Amz-Algorithm")
  valid_594367 = validateParameter(valid_594367, JString, required = false,
                                 default = nil)
  if valid_594367 != nil:
    section.add "X-Amz-Algorithm", valid_594367
  var valid_594368 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594368 = validateParameter(valid_594368, JString, required = false,
                                 default = nil)
  if valid_594368 != nil:
    section.add "X-Amz-SignedHeaders", valid_594368
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594370: Call_CreateBillingGroup_594358; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a billing group.
  ## 
  let valid = call_594370.validator(path, query, header, formData, body)
  let scheme = call_594370.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594370.url(scheme.get, call_594370.host, call_594370.base,
                         call_594370.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594370, url, valid)

proc call*(call_594371: Call_CreateBillingGroup_594358; body: JsonNode;
          billingGroupName: string): Recallable =
  ## createBillingGroup
  ## Creates a billing group.
  ##   body: JObject (required)
  ##   billingGroupName: string (required)
  ##                   : The name you wish to give to the billing group.
  var path_594372 = newJObject()
  var body_594373 = newJObject()
  if body != nil:
    body_594373 = body
  add(path_594372, "billingGroupName", newJString(billingGroupName))
  result = call_594371.call(path_594372, nil, nil, nil, body_594373)

var createBillingGroup* = Call_CreateBillingGroup_594358(
    name: "createBillingGroup", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_CreateBillingGroup_594359, base: "/",
    url: url_CreateBillingGroup_594360, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeBillingGroup_594344 = ref object of OpenApiRestCall_593389
proc url_DescribeBillingGroup_594346(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeBillingGroup_594345(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_594347 = path.getOrDefault("billingGroupName")
  valid_594347 = validateParameter(valid_594347, JString, required = true,
                                 default = nil)
  if valid_594347 != nil:
    section.add "billingGroupName", valid_594347
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594348 = header.getOrDefault("X-Amz-Signature")
  valid_594348 = validateParameter(valid_594348, JString, required = false,
                                 default = nil)
  if valid_594348 != nil:
    section.add "X-Amz-Signature", valid_594348
  var valid_594349 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594349 = validateParameter(valid_594349, JString, required = false,
                                 default = nil)
  if valid_594349 != nil:
    section.add "X-Amz-Content-Sha256", valid_594349
  var valid_594350 = header.getOrDefault("X-Amz-Date")
  valid_594350 = validateParameter(valid_594350, JString, required = false,
                                 default = nil)
  if valid_594350 != nil:
    section.add "X-Amz-Date", valid_594350
  var valid_594351 = header.getOrDefault("X-Amz-Credential")
  valid_594351 = validateParameter(valid_594351, JString, required = false,
                                 default = nil)
  if valid_594351 != nil:
    section.add "X-Amz-Credential", valid_594351
  var valid_594352 = header.getOrDefault("X-Amz-Security-Token")
  valid_594352 = validateParameter(valid_594352, JString, required = false,
                                 default = nil)
  if valid_594352 != nil:
    section.add "X-Amz-Security-Token", valid_594352
  var valid_594353 = header.getOrDefault("X-Amz-Algorithm")
  valid_594353 = validateParameter(valid_594353, JString, required = false,
                                 default = nil)
  if valid_594353 != nil:
    section.add "X-Amz-Algorithm", valid_594353
  var valid_594354 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594354 = validateParameter(valid_594354, JString, required = false,
                                 default = nil)
  if valid_594354 != nil:
    section.add "X-Amz-SignedHeaders", valid_594354
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594355: Call_DescribeBillingGroup_594344; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about a billing group.
  ## 
  let valid = call_594355.validator(path, query, header, formData, body)
  let scheme = call_594355.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594355.url(scheme.get, call_594355.host, call_594355.base,
                         call_594355.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594355, url, valid)

proc call*(call_594356: Call_DescribeBillingGroup_594344; billingGroupName: string): Recallable =
  ## describeBillingGroup
  ## Returns information about a billing group.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_594357 = newJObject()
  add(path_594357, "billingGroupName", newJString(billingGroupName))
  result = call_594356.call(path_594357, nil, nil, nil, nil)

var describeBillingGroup* = Call_DescribeBillingGroup_594344(
    name: "describeBillingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_DescribeBillingGroup_594345, base: "/",
    url: url_DescribeBillingGroup_594346, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateBillingGroup_594390 = ref object of OpenApiRestCall_593389
proc url_UpdateBillingGroup_594392(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateBillingGroup_594391(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Updates information about the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_594393 = path.getOrDefault("billingGroupName")
  valid_594393 = validateParameter(valid_594393, JString, required = true,
                                 default = nil)
  if valid_594393 != nil:
    section.add "billingGroupName", valid_594393
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594394 = header.getOrDefault("X-Amz-Signature")
  valid_594394 = validateParameter(valid_594394, JString, required = false,
                                 default = nil)
  if valid_594394 != nil:
    section.add "X-Amz-Signature", valid_594394
  var valid_594395 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594395 = validateParameter(valid_594395, JString, required = false,
                                 default = nil)
  if valid_594395 != nil:
    section.add "X-Amz-Content-Sha256", valid_594395
  var valid_594396 = header.getOrDefault("X-Amz-Date")
  valid_594396 = validateParameter(valid_594396, JString, required = false,
                                 default = nil)
  if valid_594396 != nil:
    section.add "X-Amz-Date", valid_594396
  var valid_594397 = header.getOrDefault("X-Amz-Credential")
  valid_594397 = validateParameter(valid_594397, JString, required = false,
                                 default = nil)
  if valid_594397 != nil:
    section.add "X-Amz-Credential", valid_594397
  var valid_594398 = header.getOrDefault("X-Amz-Security-Token")
  valid_594398 = validateParameter(valid_594398, JString, required = false,
                                 default = nil)
  if valid_594398 != nil:
    section.add "X-Amz-Security-Token", valid_594398
  var valid_594399 = header.getOrDefault("X-Amz-Algorithm")
  valid_594399 = validateParameter(valid_594399, JString, required = false,
                                 default = nil)
  if valid_594399 != nil:
    section.add "X-Amz-Algorithm", valid_594399
  var valid_594400 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594400 = validateParameter(valid_594400, JString, required = false,
                                 default = nil)
  if valid_594400 != nil:
    section.add "X-Amz-SignedHeaders", valid_594400
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594402: Call_UpdateBillingGroup_594390; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates information about the billing group.
  ## 
  let valid = call_594402.validator(path, query, header, formData, body)
  let scheme = call_594402.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594402.url(scheme.get, call_594402.host, call_594402.base,
                         call_594402.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594402, url, valid)

proc call*(call_594403: Call_UpdateBillingGroup_594390; body: JsonNode;
          billingGroupName: string): Recallable =
  ## updateBillingGroup
  ## Updates information about the billing group.
  ##   body: JObject (required)
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_594404 = newJObject()
  var body_594405 = newJObject()
  if body != nil:
    body_594405 = body
  add(path_594404, "billingGroupName", newJString(billingGroupName))
  result = call_594403.call(path_594404, nil, nil, nil, body_594405)

var updateBillingGroup* = Call_UpdateBillingGroup_594390(
    name: "updateBillingGroup", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_UpdateBillingGroup_594391, base: "/",
    url: url_UpdateBillingGroup_594392, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteBillingGroup_594374 = ref object of OpenApiRestCall_593389
proc url_DeleteBillingGroup_594376(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteBillingGroup_594375(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deletes the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_594377 = path.getOrDefault("billingGroupName")
  valid_594377 = validateParameter(valid_594377, JString, required = true,
                                 default = nil)
  if valid_594377 != nil:
    section.add "billingGroupName", valid_594377
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.
  section = newJObject()
  var valid_594378 = query.getOrDefault("expectedVersion")
  valid_594378 = validateParameter(valid_594378, JInt, required = false, default = nil)
  if valid_594378 != nil:
    section.add "expectedVersion", valid_594378
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594379 = header.getOrDefault("X-Amz-Signature")
  valid_594379 = validateParameter(valid_594379, JString, required = false,
                                 default = nil)
  if valid_594379 != nil:
    section.add "X-Amz-Signature", valid_594379
  var valid_594380 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594380 = validateParameter(valid_594380, JString, required = false,
                                 default = nil)
  if valid_594380 != nil:
    section.add "X-Amz-Content-Sha256", valid_594380
  var valid_594381 = header.getOrDefault("X-Amz-Date")
  valid_594381 = validateParameter(valid_594381, JString, required = false,
                                 default = nil)
  if valid_594381 != nil:
    section.add "X-Amz-Date", valid_594381
  var valid_594382 = header.getOrDefault("X-Amz-Credential")
  valid_594382 = validateParameter(valid_594382, JString, required = false,
                                 default = nil)
  if valid_594382 != nil:
    section.add "X-Amz-Credential", valid_594382
  var valid_594383 = header.getOrDefault("X-Amz-Security-Token")
  valid_594383 = validateParameter(valid_594383, JString, required = false,
                                 default = nil)
  if valid_594383 != nil:
    section.add "X-Amz-Security-Token", valid_594383
  var valid_594384 = header.getOrDefault("X-Amz-Algorithm")
  valid_594384 = validateParameter(valid_594384, JString, required = false,
                                 default = nil)
  if valid_594384 != nil:
    section.add "X-Amz-Algorithm", valid_594384
  var valid_594385 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594385 = validateParameter(valid_594385, JString, required = false,
                                 default = nil)
  if valid_594385 != nil:
    section.add "X-Amz-SignedHeaders", valid_594385
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594386: Call_DeleteBillingGroup_594374; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the billing group.
  ## 
  let valid = call_594386.validator(path, query, header, formData, body)
  let scheme = call_594386.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594386.url(scheme.get, call_594386.host, call_594386.base,
                         call_594386.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594386, url, valid)

proc call*(call_594387: Call_DeleteBillingGroup_594374; billingGroupName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteBillingGroup
  ## Deletes the billing group.
  ##   expectedVersion: int
  ##                  : The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_594388 = newJObject()
  var query_594389 = newJObject()
  add(query_594389, "expectedVersion", newJInt(expectedVersion))
  add(path_594388, "billingGroupName", newJString(billingGroupName))
  result = call_594387.call(path_594388, query_594389, nil, nil, nil)

var deleteBillingGroup* = Call_DeleteBillingGroup_594374(
    name: "deleteBillingGroup", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_DeleteBillingGroup_594375, base: "/",
    url: url_DeleteBillingGroup_594376, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateCertificateFromCsr_594422 = ref object of OpenApiRestCall_593389
proc url_CreateCertificateFromCsr_594424(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateCertificateFromCsr_594423(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_594425 = query.getOrDefault("setAsActive")
  valid_594425 = validateParameter(valid_594425, JBool, required = false, default = nil)
  if valid_594425 != nil:
    section.add "setAsActive", valid_594425
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594426 = header.getOrDefault("X-Amz-Signature")
  valid_594426 = validateParameter(valid_594426, JString, required = false,
                                 default = nil)
  if valid_594426 != nil:
    section.add "X-Amz-Signature", valid_594426
  var valid_594427 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594427 = validateParameter(valid_594427, JString, required = false,
                                 default = nil)
  if valid_594427 != nil:
    section.add "X-Amz-Content-Sha256", valid_594427
  var valid_594428 = header.getOrDefault("X-Amz-Date")
  valid_594428 = validateParameter(valid_594428, JString, required = false,
                                 default = nil)
  if valid_594428 != nil:
    section.add "X-Amz-Date", valid_594428
  var valid_594429 = header.getOrDefault("X-Amz-Credential")
  valid_594429 = validateParameter(valid_594429, JString, required = false,
                                 default = nil)
  if valid_594429 != nil:
    section.add "X-Amz-Credential", valid_594429
  var valid_594430 = header.getOrDefault("X-Amz-Security-Token")
  valid_594430 = validateParameter(valid_594430, JString, required = false,
                                 default = nil)
  if valid_594430 != nil:
    section.add "X-Amz-Security-Token", valid_594430
  var valid_594431 = header.getOrDefault("X-Amz-Algorithm")
  valid_594431 = validateParameter(valid_594431, JString, required = false,
                                 default = nil)
  if valid_594431 != nil:
    section.add "X-Amz-Algorithm", valid_594431
  var valid_594432 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594432 = validateParameter(valid_594432, JString, required = false,
                                 default = nil)
  if valid_594432 != nil:
    section.add "X-Amz-SignedHeaders", valid_594432
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594434: Call_CreateCertificateFromCsr_594422; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ## 
  let valid = call_594434.validator(path, query, header, formData, body)
  let scheme = call_594434.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594434.url(scheme.get, call_594434.host, call_594434.base,
                         call_594434.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594434, url, valid)

proc call*(call_594435: Call_CreateCertificateFromCsr_594422; body: JsonNode;
          setAsActive: bool = false): Recallable =
  ## createCertificateFromCsr
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  ##   body: JObject (required)
  var query_594436 = newJObject()
  var body_594437 = newJObject()
  add(query_594436, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_594437 = body
  result = call_594435.call(nil, query_594436, nil, nil, body_594437)

var createCertificateFromCsr* = Call_CreateCertificateFromCsr_594422(
    name: "createCertificateFromCsr", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/certificates",
    validator: validate_CreateCertificateFromCsr_594423, base: "/",
    url: url_CreateCertificateFromCsr_594424, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCertificates_594406 = ref object of OpenApiRestCall_593389
proc url_ListCertificates_594408(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListCertificates_594407(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_594409 = query.getOrDefault("isAscendingOrder")
  valid_594409 = validateParameter(valid_594409, JBool, required = false, default = nil)
  if valid_594409 != nil:
    section.add "isAscendingOrder", valid_594409
  var valid_594410 = query.getOrDefault("pageSize")
  valid_594410 = validateParameter(valid_594410, JInt, required = false, default = nil)
  if valid_594410 != nil:
    section.add "pageSize", valid_594410
  var valid_594411 = query.getOrDefault("marker")
  valid_594411 = validateParameter(valid_594411, JString, required = false,
                                 default = nil)
  if valid_594411 != nil:
    section.add "marker", valid_594411
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594412 = header.getOrDefault("X-Amz-Signature")
  valid_594412 = validateParameter(valid_594412, JString, required = false,
                                 default = nil)
  if valid_594412 != nil:
    section.add "X-Amz-Signature", valid_594412
  var valid_594413 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594413 = validateParameter(valid_594413, JString, required = false,
                                 default = nil)
  if valid_594413 != nil:
    section.add "X-Amz-Content-Sha256", valid_594413
  var valid_594414 = header.getOrDefault("X-Amz-Date")
  valid_594414 = validateParameter(valid_594414, JString, required = false,
                                 default = nil)
  if valid_594414 != nil:
    section.add "X-Amz-Date", valid_594414
  var valid_594415 = header.getOrDefault("X-Amz-Credential")
  valid_594415 = validateParameter(valid_594415, JString, required = false,
                                 default = nil)
  if valid_594415 != nil:
    section.add "X-Amz-Credential", valid_594415
  var valid_594416 = header.getOrDefault("X-Amz-Security-Token")
  valid_594416 = validateParameter(valid_594416, JString, required = false,
                                 default = nil)
  if valid_594416 != nil:
    section.add "X-Amz-Security-Token", valid_594416
  var valid_594417 = header.getOrDefault("X-Amz-Algorithm")
  valid_594417 = validateParameter(valid_594417, JString, required = false,
                                 default = nil)
  if valid_594417 != nil:
    section.add "X-Amz-Algorithm", valid_594417
  var valid_594418 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594418 = validateParameter(valid_594418, JString, required = false,
                                 default = nil)
  if valid_594418 != nil:
    section.add "X-Amz-SignedHeaders", valid_594418
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594419: Call_ListCertificates_594406; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  let valid = call_594419.validator(path, query, header, formData, body)
  let scheme = call_594419.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594419.url(scheme.get, call_594419.host, call_594419.base,
                         call_594419.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594419, url, valid)

proc call*(call_594420: Call_ListCertificates_594406;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listCertificates
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_594421 = newJObject()
  add(query_594421, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_594421, "pageSize", newJInt(pageSize))
  add(query_594421, "marker", newJString(marker))
  result = call_594420.call(nil, query_594421, nil, nil, nil)

var listCertificates* = Call_ListCertificates_594406(name: "listCertificates",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/certificates",
    validator: validate_ListCertificates_594407, base: "/",
    url: url_ListCertificates_594408, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateDynamicThingGroup_594438 = ref object of OpenApiRestCall_593389
proc url_CreateDynamicThingGroup_594440(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateDynamicThingGroup_594439(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The dynamic thing group name to create.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_594441 = path.getOrDefault("thingGroupName")
  valid_594441 = validateParameter(valid_594441, JString, required = true,
                                 default = nil)
  if valid_594441 != nil:
    section.add "thingGroupName", valid_594441
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594442 = header.getOrDefault("X-Amz-Signature")
  valid_594442 = validateParameter(valid_594442, JString, required = false,
                                 default = nil)
  if valid_594442 != nil:
    section.add "X-Amz-Signature", valid_594442
  var valid_594443 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594443 = validateParameter(valid_594443, JString, required = false,
                                 default = nil)
  if valid_594443 != nil:
    section.add "X-Amz-Content-Sha256", valid_594443
  var valid_594444 = header.getOrDefault("X-Amz-Date")
  valid_594444 = validateParameter(valid_594444, JString, required = false,
                                 default = nil)
  if valid_594444 != nil:
    section.add "X-Amz-Date", valid_594444
  var valid_594445 = header.getOrDefault("X-Amz-Credential")
  valid_594445 = validateParameter(valid_594445, JString, required = false,
                                 default = nil)
  if valid_594445 != nil:
    section.add "X-Amz-Credential", valid_594445
  var valid_594446 = header.getOrDefault("X-Amz-Security-Token")
  valid_594446 = validateParameter(valid_594446, JString, required = false,
                                 default = nil)
  if valid_594446 != nil:
    section.add "X-Amz-Security-Token", valid_594446
  var valid_594447 = header.getOrDefault("X-Amz-Algorithm")
  valid_594447 = validateParameter(valid_594447, JString, required = false,
                                 default = nil)
  if valid_594447 != nil:
    section.add "X-Amz-Algorithm", valid_594447
  var valid_594448 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594448 = validateParameter(valid_594448, JString, required = false,
                                 default = nil)
  if valid_594448 != nil:
    section.add "X-Amz-SignedHeaders", valid_594448
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594450: Call_CreateDynamicThingGroup_594438; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a dynamic thing group.
  ## 
  let valid = call_594450.validator(path, query, header, formData, body)
  let scheme = call_594450.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594450.url(scheme.get, call_594450.host, call_594450.base,
                         call_594450.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594450, url, valid)

proc call*(call_594451: Call_CreateDynamicThingGroup_594438;
          thingGroupName: string; body: JsonNode): Recallable =
  ## createDynamicThingGroup
  ## Creates a dynamic thing group.
  ##   thingGroupName: string (required)
  ##                 : The dynamic thing group name to create.
  ##   body: JObject (required)
  var path_594452 = newJObject()
  var body_594453 = newJObject()
  add(path_594452, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_594453 = body
  result = call_594451.call(path_594452, nil, nil, nil, body_594453)

var createDynamicThingGroup* = Call_CreateDynamicThingGroup_594438(
    name: "createDynamicThingGroup", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_CreateDynamicThingGroup_594439, base: "/",
    url: url_CreateDynamicThingGroup_594440, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateDynamicThingGroup_594470 = ref object of OpenApiRestCall_593389
proc url_UpdateDynamicThingGroup_594472(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateDynamicThingGroup_594471(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the dynamic thing group to update.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_594473 = path.getOrDefault("thingGroupName")
  valid_594473 = validateParameter(valid_594473, JString, required = true,
                                 default = nil)
  if valid_594473 != nil:
    section.add "thingGroupName", valid_594473
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594474 = header.getOrDefault("X-Amz-Signature")
  valid_594474 = validateParameter(valid_594474, JString, required = false,
                                 default = nil)
  if valid_594474 != nil:
    section.add "X-Amz-Signature", valid_594474
  var valid_594475 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594475 = validateParameter(valid_594475, JString, required = false,
                                 default = nil)
  if valid_594475 != nil:
    section.add "X-Amz-Content-Sha256", valid_594475
  var valid_594476 = header.getOrDefault("X-Amz-Date")
  valid_594476 = validateParameter(valid_594476, JString, required = false,
                                 default = nil)
  if valid_594476 != nil:
    section.add "X-Amz-Date", valid_594476
  var valid_594477 = header.getOrDefault("X-Amz-Credential")
  valid_594477 = validateParameter(valid_594477, JString, required = false,
                                 default = nil)
  if valid_594477 != nil:
    section.add "X-Amz-Credential", valid_594477
  var valid_594478 = header.getOrDefault("X-Amz-Security-Token")
  valid_594478 = validateParameter(valid_594478, JString, required = false,
                                 default = nil)
  if valid_594478 != nil:
    section.add "X-Amz-Security-Token", valid_594478
  var valid_594479 = header.getOrDefault("X-Amz-Algorithm")
  valid_594479 = validateParameter(valid_594479, JString, required = false,
                                 default = nil)
  if valid_594479 != nil:
    section.add "X-Amz-Algorithm", valid_594479
  var valid_594480 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594480 = validateParameter(valid_594480, JString, required = false,
                                 default = nil)
  if valid_594480 != nil:
    section.add "X-Amz-SignedHeaders", valid_594480
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594482: Call_UpdateDynamicThingGroup_594470; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a dynamic thing group.
  ## 
  let valid = call_594482.validator(path, query, header, formData, body)
  let scheme = call_594482.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594482.url(scheme.get, call_594482.host, call_594482.base,
                         call_594482.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594482, url, valid)

proc call*(call_594483: Call_UpdateDynamicThingGroup_594470;
          thingGroupName: string; body: JsonNode): Recallable =
  ## updateDynamicThingGroup
  ## Updates a dynamic thing group.
  ##   thingGroupName: string (required)
  ##                 : The name of the dynamic thing group to update.
  ##   body: JObject (required)
  var path_594484 = newJObject()
  var body_594485 = newJObject()
  add(path_594484, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_594485 = body
  result = call_594483.call(path_594484, nil, nil, nil, body_594485)

var updateDynamicThingGroup* = Call_UpdateDynamicThingGroup_594470(
    name: "updateDynamicThingGroup", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_UpdateDynamicThingGroup_594471, base: "/",
    url: url_UpdateDynamicThingGroup_594472, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteDynamicThingGroup_594454 = ref object of OpenApiRestCall_593389
proc url_DeleteDynamicThingGroup_594456(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteDynamicThingGroup_594455(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the dynamic thing group to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_594457 = path.getOrDefault("thingGroupName")
  valid_594457 = validateParameter(valid_594457, JString, required = true,
                                 default = nil)
  if valid_594457 != nil:
    section.add "thingGroupName", valid_594457
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the dynamic thing group to delete.
  section = newJObject()
  var valid_594458 = query.getOrDefault("expectedVersion")
  valid_594458 = validateParameter(valid_594458, JInt, required = false, default = nil)
  if valid_594458 != nil:
    section.add "expectedVersion", valid_594458
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594459 = header.getOrDefault("X-Amz-Signature")
  valid_594459 = validateParameter(valid_594459, JString, required = false,
                                 default = nil)
  if valid_594459 != nil:
    section.add "X-Amz-Signature", valid_594459
  var valid_594460 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594460 = validateParameter(valid_594460, JString, required = false,
                                 default = nil)
  if valid_594460 != nil:
    section.add "X-Amz-Content-Sha256", valid_594460
  var valid_594461 = header.getOrDefault("X-Amz-Date")
  valid_594461 = validateParameter(valid_594461, JString, required = false,
                                 default = nil)
  if valid_594461 != nil:
    section.add "X-Amz-Date", valid_594461
  var valid_594462 = header.getOrDefault("X-Amz-Credential")
  valid_594462 = validateParameter(valid_594462, JString, required = false,
                                 default = nil)
  if valid_594462 != nil:
    section.add "X-Amz-Credential", valid_594462
  var valid_594463 = header.getOrDefault("X-Amz-Security-Token")
  valid_594463 = validateParameter(valid_594463, JString, required = false,
                                 default = nil)
  if valid_594463 != nil:
    section.add "X-Amz-Security-Token", valid_594463
  var valid_594464 = header.getOrDefault("X-Amz-Algorithm")
  valid_594464 = validateParameter(valid_594464, JString, required = false,
                                 default = nil)
  if valid_594464 != nil:
    section.add "X-Amz-Algorithm", valid_594464
  var valid_594465 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594465 = validateParameter(valid_594465, JString, required = false,
                                 default = nil)
  if valid_594465 != nil:
    section.add "X-Amz-SignedHeaders", valid_594465
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594466: Call_DeleteDynamicThingGroup_594454; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a dynamic thing group.
  ## 
  let valid = call_594466.validator(path, query, header, formData, body)
  let scheme = call_594466.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594466.url(scheme.get, call_594466.host, call_594466.base,
                         call_594466.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594466, url, valid)

proc call*(call_594467: Call_DeleteDynamicThingGroup_594454;
          thingGroupName: string; expectedVersion: int = 0): Recallable =
  ## deleteDynamicThingGroup
  ## Deletes a dynamic thing group.
  ##   expectedVersion: int
  ##                  : The expected version of the dynamic thing group to delete.
  ##   thingGroupName: string (required)
  ##                 : The name of the dynamic thing group to delete.
  var path_594468 = newJObject()
  var query_594469 = newJObject()
  add(query_594469, "expectedVersion", newJInt(expectedVersion))
  add(path_594468, "thingGroupName", newJString(thingGroupName))
  result = call_594467.call(path_594468, query_594469, nil, nil, nil)

var deleteDynamicThingGroup* = Call_DeleteDynamicThingGroup_594454(
    name: "deleteDynamicThingGroup", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_DeleteDynamicThingGroup_594455, base: "/",
    url: url_DeleteDynamicThingGroup_594456, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateJob_594500 = ref object of OpenApiRestCall_593389
proc url_CreateJob_594502(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateJob_594501(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_594503 = path.getOrDefault("jobId")
  valid_594503 = validateParameter(valid_594503, JString, required = true,
                                 default = nil)
  if valid_594503 != nil:
    section.add "jobId", valid_594503
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594504 = header.getOrDefault("X-Amz-Signature")
  valid_594504 = validateParameter(valid_594504, JString, required = false,
                                 default = nil)
  if valid_594504 != nil:
    section.add "X-Amz-Signature", valid_594504
  var valid_594505 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594505 = validateParameter(valid_594505, JString, required = false,
                                 default = nil)
  if valid_594505 != nil:
    section.add "X-Amz-Content-Sha256", valid_594505
  var valid_594506 = header.getOrDefault("X-Amz-Date")
  valid_594506 = validateParameter(valid_594506, JString, required = false,
                                 default = nil)
  if valid_594506 != nil:
    section.add "X-Amz-Date", valid_594506
  var valid_594507 = header.getOrDefault("X-Amz-Credential")
  valid_594507 = validateParameter(valid_594507, JString, required = false,
                                 default = nil)
  if valid_594507 != nil:
    section.add "X-Amz-Credential", valid_594507
  var valid_594508 = header.getOrDefault("X-Amz-Security-Token")
  valid_594508 = validateParameter(valid_594508, JString, required = false,
                                 default = nil)
  if valid_594508 != nil:
    section.add "X-Amz-Security-Token", valid_594508
  var valid_594509 = header.getOrDefault("X-Amz-Algorithm")
  valid_594509 = validateParameter(valid_594509, JString, required = false,
                                 default = nil)
  if valid_594509 != nil:
    section.add "X-Amz-Algorithm", valid_594509
  var valid_594510 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594510 = validateParameter(valid_594510, JString, required = false,
                                 default = nil)
  if valid_594510 != nil:
    section.add "X-Amz-SignedHeaders", valid_594510
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594512: Call_CreateJob_594500; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a job.
  ## 
  let valid = call_594512.validator(path, query, header, formData, body)
  let scheme = call_594512.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594512.url(scheme.get, call_594512.host, call_594512.base,
                         call_594512.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594512, url, valid)

proc call*(call_594513: Call_CreateJob_594500; jobId: string; body: JsonNode): Recallable =
  ## createJob
  ## Creates a job.
  ##   jobId: string (required)
  ##        : A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
  ##   body: JObject (required)
  var path_594514 = newJObject()
  var body_594515 = newJObject()
  add(path_594514, "jobId", newJString(jobId))
  if body != nil:
    body_594515 = body
  result = call_594513.call(path_594514, nil, nil, nil, body_594515)

var createJob* = Call_CreateJob_594500(name: "createJob", meth: HttpMethod.HttpPut,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_CreateJob_594501,
                                    base: "/", url: url_CreateJob_594502,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeJob_594486 = ref object of OpenApiRestCall_593389
proc url_DescribeJob_594488(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeJob_594487(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_594489 = path.getOrDefault("jobId")
  valid_594489 = validateParameter(valid_594489, JString, required = true,
                                 default = nil)
  if valid_594489 != nil:
    section.add "jobId", valid_594489
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594490 = header.getOrDefault("X-Amz-Signature")
  valid_594490 = validateParameter(valid_594490, JString, required = false,
                                 default = nil)
  if valid_594490 != nil:
    section.add "X-Amz-Signature", valid_594490
  var valid_594491 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594491 = validateParameter(valid_594491, JString, required = false,
                                 default = nil)
  if valid_594491 != nil:
    section.add "X-Amz-Content-Sha256", valid_594491
  var valid_594492 = header.getOrDefault("X-Amz-Date")
  valid_594492 = validateParameter(valid_594492, JString, required = false,
                                 default = nil)
  if valid_594492 != nil:
    section.add "X-Amz-Date", valid_594492
  var valid_594493 = header.getOrDefault("X-Amz-Credential")
  valid_594493 = validateParameter(valid_594493, JString, required = false,
                                 default = nil)
  if valid_594493 != nil:
    section.add "X-Amz-Credential", valid_594493
  var valid_594494 = header.getOrDefault("X-Amz-Security-Token")
  valid_594494 = validateParameter(valid_594494, JString, required = false,
                                 default = nil)
  if valid_594494 != nil:
    section.add "X-Amz-Security-Token", valid_594494
  var valid_594495 = header.getOrDefault("X-Amz-Algorithm")
  valid_594495 = validateParameter(valid_594495, JString, required = false,
                                 default = nil)
  if valid_594495 != nil:
    section.add "X-Amz-Algorithm", valid_594495
  var valid_594496 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594496 = validateParameter(valid_594496, JString, required = false,
                                 default = nil)
  if valid_594496 != nil:
    section.add "X-Amz-SignedHeaders", valid_594496
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594497: Call_DescribeJob_594486; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a job.
  ## 
  let valid = call_594497.validator(path, query, header, formData, body)
  let scheme = call_594497.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594497.url(scheme.get, call_594497.host, call_594497.base,
                         call_594497.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594497, url, valid)

proc call*(call_594498: Call_DescribeJob_594486; jobId: string): Recallable =
  ## describeJob
  ## Describes a job.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  var path_594499 = newJObject()
  add(path_594499, "jobId", newJString(jobId))
  result = call_594498.call(path_594499, nil, nil, nil, nil)

var describeJob* = Call_DescribeJob_594486(name: "describeJob",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/jobs/{jobId}",
                                        validator: validate_DescribeJob_594487,
                                        base: "/", url: url_DescribeJob_594488,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateJob_594532 = ref object of OpenApiRestCall_593389
proc url_UpdateJob_594534(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateJob_594533(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates supported fields of the specified job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The ID of the job to be updated.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_594535 = path.getOrDefault("jobId")
  valid_594535 = validateParameter(valid_594535, JString, required = true,
                                 default = nil)
  if valid_594535 != nil:
    section.add "jobId", valid_594535
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594536 = header.getOrDefault("X-Amz-Signature")
  valid_594536 = validateParameter(valid_594536, JString, required = false,
                                 default = nil)
  if valid_594536 != nil:
    section.add "X-Amz-Signature", valid_594536
  var valid_594537 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594537 = validateParameter(valid_594537, JString, required = false,
                                 default = nil)
  if valid_594537 != nil:
    section.add "X-Amz-Content-Sha256", valid_594537
  var valid_594538 = header.getOrDefault("X-Amz-Date")
  valid_594538 = validateParameter(valid_594538, JString, required = false,
                                 default = nil)
  if valid_594538 != nil:
    section.add "X-Amz-Date", valid_594538
  var valid_594539 = header.getOrDefault("X-Amz-Credential")
  valid_594539 = validateParameter(valid_594539, JString, required = false,
                                 default = nil)
  if valid_594539 != nil:
    section.add "X-Amz-Credential", valid_594539
  var valid_594540 = header.getOrDefault("X-Amz-Security-Token")
  valid_594540 = validateParameter(valid_594540, JString, required = false,
                                 default = nil)
  if valid_594540 != nil:
    section.add "X-Amz-Security-Token", valid_594540
  var valid_594541 = header.getOrDefault("X-Amz-Algorithm")
  valid_594541 = validateParameter(valid_594541, JString, required = false,
                                 default = nil)
  if valid_594541 != nil:
    section.add "X-Amz-Algorithm", valid_594541
  var valid_594542 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594542 = validateParameter(valid_594542, JString, required = false,
                                 default = nil)
  if valid_594542 != nil:
    section.add "X-Amz-SignedHeaders", valid_594542
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594544: Call_UpdateJob_594532; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates supported fields of the specified job.
  ## 
  let valid = call_594544.validator(path, query, header, formData, body)
  let scheme = call_594544.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594544.url(scheme.get, call_594544.host, call_594544.base,
                         call_594544.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594544, url, valid)

proc call*(call_594545: Call_UpdateJob_594532; jobId: string; body: JsonNode): Recallable =
  ## updateJob
  ## Updates supported fields of the specified job.
  ##   jobId: string (required)
  ##        : The ID of the job to be updated.
  ##   body: JObject (required)
  var path_594546 = newJObject()
  var body_594547 = newJObject()
  add(path_594546, "jobId", newJString(jobId))
  if body != nil:
    body_594547 = body
  result = call_594545.call(path_594546, nil, nil, nil, body_594547)

var updateJob* = Call_UpdateJob_594532(name: "updateJob", meth: HttpMethod.HttpPatch,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_UpdateJob_594533,
                                    base: "/", url: url_UpdateJob_594534,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteJob_594516 = ref object of OpenApiRestCall_593389
proc url_DeleteJob_594518(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteJob_594517(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_594519 = path.getOrDefault("jobId")
  valid_594519 = validateParameter(valid_594519, JString, required = true,
                                 default = nil)
  if valid_594519 != nil:
    section.add "jobId", valid_594519
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
  section = newJObject()
  var valid_594520 = query.getOrDefault("force")
  valid_594520 = validateParameter(valid_594520, JBool, required = false, default = nil)
  if valid_594520 != nil:
    section.add "force", valid_594520
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594521 = header.getOrDefault("X-Amz-Signature")
  valid_594521 = validateParameter(valid_594521, JString, required = false,
                                 default = nil)
  if valid_594521 != nil:
    section.add "X-Amz-Signature", valid_594521
  var valid_594522 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594522 = validateParameter(valid_594522, JString, required = false,
                                 default = nil)
  if valid_594522 != nil:
    section.add "X-Amz-Content-Sha256", valid_594522
  var valid_594523 = header.getOrDefault("X-Amz-Date")
  valid_594523 = validateParameter(valid_594523, JString, required = false,
                                 default = nil)
  if valid_594523 != nil:
    section.add "X-Amz-Date", valid_594523
  var valid_594524 = header.getOrDefault("X-Amz-Credential")
  valid_594524 = validateParameter(valid_594524, JString, required = false,
                                 default = nil)
  if valid_594524 != nil:
    section.add "X-Amz-Credential", valid_594524
  var valid_594525 = header.getOrDefault("X-Amz-Security-Token")
  valid_594525 = validateParameter(valid_594525, JString, required = false,
                                 default = nil)
  if valid_594525 != nil:
    section.add "X-Amz-Security-Token", valid_594525
  var valid_594526 = header.getOrDefault("X-Amz-Algorithm")
  valid_594526 = validateParameter(valid_594526, JString, required = false,
                                 default = nil)
  if valid_594526 != nil:
    section.add "X-Amz-Algorithm", valid_594526
  var valid_594527 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594527 = validateParameter(valid_594527, JString, required = false,
                                 default = nil)
  if valid_594527 != nil:
    section.add "X-Amz-SignedHeaders", valid_594527
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594528: Call_DeleteJob_594516; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ## 
  let valid = call_594528.validator(path, query, header, formData, body)
  let scheme = call_594528.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594528.url(scheme.get, call_594528.host, call_594528.base,
                         call_594528.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594528, url, valid)

proc call*(call_594529: Call_DeleteJob_594516; jobId: string; force: bool = false): Recallable =
  ## deleteJob
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ##   jobId: string (required)
  ##        : <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
  ##   force: bool
  ##        : <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
  var path_594530 = newJObject()
  var query_594531 = newJObject()
  add(path_594530, "jobId", newJString(jobId))
  add(query_594531, "force", newJBool(force))
  result = call_594529.call(path_594530, query_594531, nil, nil, nil)

var deleteJob* = Call_DeleteJob_594516(name: "deleteJob",
                                    meth: HttpMethod.HttpDelete,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_DeleteJob_594517,
                                    base: "/", url: url_DeleteJob_594518,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateKeysAndCertificate_594548 = ref object of OpenApiRestCall_593389
proc url_CreateKeysAndCertificate_594550(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateKeysAndCertificate_594549(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_594551 = query.getOrDefault("setAsActive")
  valid_594551 = validateParameter(valid_594551, JBool, required = false, default = nil)
  if valid_594551 != nil:
    section.add "setAsActive", valid_594551
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594552 = header.getOrDefault("X-Amz-Signature")
  valid_594552 = validateParameter(valid_594552, JString, required = false,
                                 default = nil)
  if valid_594552 != nil:
    section.add "X-Amz-Signature", valid_594552
  var valid_594553 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594553 = validateParameter(valid_594553, JString, required = false,
                                 default = nil)
  if valid_594553 != nil:
    section.add "X-Amz-Content-Sha256", valid_594553
  var valid_594554 = header.getOrDefault("X-Amz-Date")
  valid_594554 = validateParameter(valid_594554, JString, required = false,
                                 default = nil)
  if valid_594554 != nil:
    section.add "X-Amz-Date", valid_594554
  var valid_594555 = header.getOrDefault("X-Amz-Credential")
  valid_594555 = validateParameter(valid_594555, JString, required = false,
                                 default = nil)
  if valid_594555 != nil:
    section.add "X-Amz-Credential", valid_594555
  var valid_594556 = header.getOrDefault("X-Amz-Security-Token")
  valid_594556 = validateParameter(valid_594556, JString, required = false,
                                 default = nil)
  if valid_594556 != nil:
    section.add "X-Amz-Security-Token", valid_594556
  var valid_594557 = header.getOrDefault("X-Amz-Algorithm")
  valid_594557 = validateParameter(valid_594557, JString, required = false,
                                 default = nil)
  if valid_594557 != nil:
    section.add "X-Amz-Algorithm", valid_594557
  var valid_594558 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594558 = validateParameter(valid_594558, JString, required = false,
                                 default = nil)
  if valid_594558 != nil:
    section.add "X-Amz-SignedHeaders", valid_594558
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594559: Call_CreateKeysAndCertificate_594548; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ## 
  let valid = call_594559.validator(path, query, header, formData, body)
  let scheme = call_594559.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594559.url(scheme.get, call_594559.host, call_594559.base,
                         call_594559.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594559, url, valid)

proc call*(call_594560: Call_CreateKeysAndCertificate_594548;
          setAsActive: bool = false): Recallable =
  ## createKeysAndCertificate
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  var query_594561 = newJObject()
  add(query_594561, "setAsActive", newJBool(setAsActive))
  result = call_594560.call(nil, query_594561, nil, nil, nil)

var createKeysAndCertificate* = Call_CreateKeysAndCertificate_594548(
    name: "createKeysAndCertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/keys-and-certificate",
    validator: validate_CreateKeysAndCertificate_594549, base: "/",
    url: url_CreateKeysAndCertificate_594550, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateMitigationAction_594576 = ref object of OpenApiRestCall_593389
proc url_CreateMitigationAction_594578(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateMitigationAction_594577(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_594579 = path.getOrDefault("actionName")
  valid_594579 = validateParameter(valid_594579, JString, required = true,
                                 default = nil)
  if valid_594579 != nil:
    section.add "actionName", valid_594579
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594580 = header.getOrDefault("X-Amz-Signature")
  valid_594580 = validateParameter(valid_594580, JString, required = false,
                                 default = nil)
  if valid_594580 != nil:
    section.add "X-Amz-Signature", valid_594580
  var valid_594581 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594581 = validateParameter(valid_594581, JString, required = false,
                                 default = nil)
  if valid_594581 != nil:
    section.add "X-Amz-Content-Sha256", valid_594581
  var valid_594582 = header.getOrDefault("X-Amz-Date")
  valid_594582 = validateParameter(valid_594582, JString, required = false,
                                 default = nil)
  if valid_594582 != nil:
    section.add "X-Amz-Date", valid_594582
  var valid_594583 = header.getOrDefault("X-Amz-Credential")
  valid_594583 = validateParameter(valid_594583, JString, required = false,
                                 default = nil)
  if valid_594583 != nil:
    section.add "X-Amz-Credential", valid_594583
  var valid_594584 = header.getOrDefault("X-Amz-Security-Token")
  valid_594584 = validateParameter(valid_594584, JString, required = false,
                                 default = nil)
  if valid_594584 != nil:
    section.add "X-Amz-Security-Token", valid_594584
  var valid_594585 = header.getOrDefault("X-Amz-Algorithm")
  valid_594585 = validateParameter(valid_594585, JString, required = false,
                                 default = nil)
  if valid_594585 != nil:
    section.add "X-Amz-Algorithm", valid_594585
  var valid_594586 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594586 = validateParameter(valid_594586, JString, required = false,
                                 default = nil)
  if valid_594586 != nil:
    section.add "X-Amz-SignedHeaders", valid_594586
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594588: Call_CreateMitigationAction_594576; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ## 
  let valid = call_594588.validator(path, query, header, formData, body)
  let scheme = call_594588.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594588.url(scheme.get, call_594588.host, call_594588.base,
                         call_594588.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594588, url, valid)

proc call*(call_594589: Call_CreateMitigationAction_594576; actionName: string;
          body: JsonNode): Recallable =
  ## createMitigationAction
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ##   actionName: string (required)
  ##             : A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).
  ##   body: JObject (required)
  var path_594590 = newJObject()
  var body_594591 = newJObject()
  add(path_594590, "actionName", newJString(actionName))
  if body != nil:
    body_594591 = body
  result = call_594589.call(path_594590, nil, nil, nil, body_594591)

var createMitigationAction* = Call_CreateMitigationAction_594576(
    name: "createMitigationAction", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_CreateMitigationAction_594577, base: "/",
    url: url_CreateMitigationAction_594578, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeMitigationAction_594562 = ref object of OpenApiRestCall_593389
proc url_DescribeMitigationAction_594564(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeMitigationAction_594563(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a mitigation action.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The friendly name that uniquely identifies the mitigation action.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_594565 = path.getOrDefault("actionName")
  valid_594565 = validateParameter(valid_594565, JString, required = true,
                                 default = nil)
  if valid_594565 != nil:
    section.add "actionName", valid_594565
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594566 = header.getOrDefault("X-Amz-Signature")
  valid_594566 = validateParameter(valid_594566, JString, required = false,
                                 default = nil)
  if valid_594566 != nil:
    section.add "X-Amz-Signature", valid_594566
  var valid_594567 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594567 = validateParameter(valid_594567, JString, required = false,
                                 default = nil)
  if valid_594567 != nil:
    section.add "X-Amz-Content-Sha256", valid_594567
  var valid_594568 = header.getOrDefault("X-Amz-Date")
  valid_594568 = validateParameter(valid_594568, JString, required = false,
                                 default = nil)
  if valid_594568 != nil:
    section.add "X-Amz-Date", valid_594568
  var valid_594569 = header.getOrDefault("X-Amz-Credential")
  valid_594569 = validateParameter(valid_594569, JString, required = false,
                                 default = nil)
  if valid_594569 != nil:
    section.add "X-Amz-Credential", valid_594569
  var valid_594570 = header.getOrDefault("X-Amz-Security-Token")
  valid_594570 = validateParameter(valid_594570, JString, required = false,
                                 default = nil)
  if valid_594570 != nil:
    section.add "X-Amz-Security-Token", valid_594570
  var valid_594571 = header.getOrDefault("X-Amz-Algorithm")
  valid_594571 = validateParameter(valid_594571, JString, required = false,
                                 default = nil)
  if valid_594571 != nil:
    section.add "X-Amz-Algorithm", valid_594571
  var valid_594572 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594572 = validateParameter(valid_594572, JString, required = false,
                                 default = nil)
  if valid_594572 != nil:
    section.add "X-Amz-SignedHeaders", valid_594572
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594573: Call_DescribeMitigationAction_594562; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a mitigation action.
  ## 
  let valid = call_594573.validator(path, query, header, formData, body)
  let scheme = call_594573.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594573.url(scheme.get, call_594573.host, call_594573.base,
                         call_594573.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594573, url, valid)

proc call*(call_594574: Call_DescribeMitigationAction_594562; actionName: string): Recallable =
  ## describeMitigationAction
  ## Gets information about a mitigation action.
  ##   actionName: string (required)
  ##             : The friendly name that uniquely identifies the mitigation action.
  var path_594575 = newJObject()
  add(path_594575, "actionName", newJString(actionName))
  result = call_594574.call(path_594575, nil, nil, nil, nil)

var describeMitigationAction* = Call_DescribeMitigationAction_594562(
    name: "describeMitigationAction", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_DescribeMitigationAction_594563, base: "/",
    url: url_DescribeMitigationAction_594564, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateMitigationAction_594606 = ref object of OpenApiRestCall_593389
proc url_UpdateMitigationAction_594608(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateMitigationAction_594607(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the definition for the specified mitigation action.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_594609 = path.getOrDefault("actionName")
  valid_594609 = validateParameter(valid_594609, JString, required = true,
                                 default = nil)
  if valid_594609 != nil:
    section.add "actionName", valid_594609
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594610 = header.getOrDefault("X-Amz-Signature")
  valid_594610 = validateParameter(valid_594610, JString, required = false,
                                 default = nil)
  if valid_594610 != nil:
    section.add "X-Amz-Signature", valid_594610
  var valid_594611 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594611 = validateParameter(valid_594611, JString, required = false,
                                 default = nil)
  if valid_594611 != nil:
    section.add "X-Amz-Content-Sha256", valid_594611
  var valid_594612 = header.getOrDefault("X-Amz-Date")
  valid_594612 = validateParameter(valid_594612, JString, required = false,
                                 default = nil)
  if valid_594612 != nil:
    section.add "X-Amz-Date", valid_594612
  var valid_594613 = header.getOrDefault("X-Amz-Credential")
  valid_594613 = validateParameter(valid_594613, JString, required = false,
                                 default = nil)
  if valid_594613 != nil:
    section.add "X-Amz-Credential", valid_594613
  var valid_594614 = header.getOrDefault("X-Amz-Security-Token")
  valid_594614 = validateParameter(valid_594614, JString, required = false,
                                 default = nil)
  if valid_594614 != nil:
    section.add "X-Amz-Security-Token", valid_594614
  var valid_594615 = header.getOrDefault("X-Amz-Algorithm")
  valid_594615 = validateParameter(valid_594615, JString, required = false,
                                 default = nil)
  if valid_594615 != nil:
    section.add "X-Amz-Algorithm", valid_594615
  var valid_594616 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594616 = validateParameter(valid_594616, JString, required = false,
                                 default = nil)
  if valid_594616 != nil:
    section.add "X-Amz-SignedHeaders", valid_594616
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594618: Call_UpdateMitigationAction_594606; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the definition for the specified mitigation action.
  ## 
  let valid = call_594618.validator(path, query, header, formData, body)
  let scheme = call_594618.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594618.url(scheme.get, call_594618.host, call_594618.base,
                         call_594618.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594618, url, valid)

proc call*(call_594619: Call_UpdateMitigationAction_594606; actionName: string;
          body: JsonNode): Recallable =
  ## updateMitigationAction
  ## Updates the definition for the specified mitigation action.
  ##   actionName: string (required)
  ##             : The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.
  ##   body: JObject (required)
  var path_594620 = newJObject()
  var body_594621 = newJObject()
  add(path_594620, "actionName", newJString(actionName))
  if body != nil:
    body_594621 = body
  result = call_594619.call(path_594620, nil, nil, nil, body_594621)

var updateMitigationAction* = Call_UpdateMitigationAction_594606(
    name: "updateMitigationAction", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_UpdateMitigationAction_594607, base: "/",
    url: url_UpdateMitigationAction_594608, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteMitigationAction_594592 = ref object of OpenApiRestCall_593389
proc url_DeleteMitigationAction_594594(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteMitigationAction_594593(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a defined mitigation action from your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The name of the mitigation action that you want to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_594595 = path.getOrDefault("actionName")
  valid_594595 = validateParameter(valid_594595, JString, required = true,
                                 default = nil)
  if valid_594595 != nil:
    section.add "actionName", valid_594595
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594596 = header.getOrDefault("X-Amz-Signature")
  valid_594596 = validateParameter(valid_594596, JString, required = false,
                                 default = nil)
  if valid_594596 != nil:
    section.add "X-Amz-Signature", valid_594596
  var valid_594597 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594597 = validateParameter(valid_594597, JString, required = false,
                                 default = nil)
  if valid_594597 != nil:
    section.add "X-Amz-Content-Sha256", valid_594597
  var valid_594598 = header.getOrDefault("X-Amz-Date")
  valid_594598 = validateParameter(valid_594598, JString, required = false,
                                 default = nil)
  if valid_594598 != nil:
    section.add "X-Amz-Date", valid_594598
  var valid_594599 = header.getOrDefault("X-Amz-Credential")
  valid_594599 = validateParameter(valid_594599, JString, required = false,
                                 default = nil)
  if valid_594599 != nil:
    section.add "X-Amz-Credential", valid_594599
  var valid_594600 = header.getOrDefault("X-Amz-Security-Token")
  valid_594600 = validateParameter(valid_594600, JString, required = false,
                                 default = nil)
  if valid_594600 != nil:
    section.add "X-Amz-Security-Token", valid_594600
  var valid_594601 = header.getOrDefault("X-Amz-Algorithm")
  valid_594601 = validateParameter(valid_594601, JString, required = false,
                                 default = nil)
  if valid_594601 != nil:
    section.add "X-Amz-Algorithm", valid_594601
  var valid_594602 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594602 = validateParameter(valid_594602, JString, required = false,
                                 default = nil)
  if valid_594602 != nil:
    section.add "X-Amz-SignedHeaders", valid_594602
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594603: Call_DeleteMitigationAction_594592; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a defined mitigation action from your AWS account.
  ## 
  let valid = call_594603.validator(path, query, header, formData, body)
  let scheme = call_594603.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594603.url(scheme.get, call_594603.host, call_594603.base,
                         call_594603.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594603, url, valid)

proc call*(call_594604: Call_DeleteMitigationAction_594592; actionName: string): Recallable =
  ## deleteMitigationAction
  ## Deletes a defined mitigation action from your AWS account.
  ##   actionName: string (required)
  ##             : The name of the mitigation action that you want to delete.
  var path_594605 = newJObject()
  add(path_594605, "actionName", newJString(actionName))
  result = call_594604.call(path_594605, nil, nil, nil, nil)

var deleteMitigationAction* = Call_DeleteMitigationAction_594592(
    name: "deleteMitigationAction", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_DeleteMitigationAction_594593, base: "/",
    url: url_DeleteMitigationAction_594594, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateOTAUpdate_594636 = ref object of OpenApiRestCall_593389
proc url_CreateOTAUpdate_594638(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateOTAUpdate_594637(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The ID of the OTA update to be created.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_594639 = path.getOrDefault("otaUpdateId")
  valid_594639 = validateParameter(valid_594639, JString, required = true,
                                 default = nil)
  if valid_594639 != nil:
    section.add "otaUpdateId", valid_594639
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594640 = header.getOrDefault("X-Amz-Signature")
  valid_594640 = validateParameter(valid_594640, JString, required = false,
                                 default = nil)
  if valid_594640 != nil:
    section.add "X-Amz-Signature", valid_594640
  var valid_594641 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594641 = validateParameter(valid_594641, JString, required = false,
                                 default = nil)
  if valid_594641 != nil:
    section.add "X-Amz-Content-Sha256", valid_594641
  var valid_594642 = header.getOrDefault("X-Amz-Date")
  valid_594642 = validateParameter(valid_594642, JString, required = false,
                                 default = nil)
  if valid_594642 != nil:
    section.add "X-Amz-Date", valid_594642
  var valid_594643 = header.getOrDefault("X-Amz-Credential")
  valid_594643 = validateParameter(valid_594643, JString, required = false,
                                 default = nil)
  if valid_594643 != nil:
    section.add "X-Amz-Credential", valid_594643
  var valid_594644 = header.getOrDefault("X-Amz-Security-Token")
  valid_594644 = validateParameter(valid_594644, JString, required = false,
                                 default = nil)
  if valid_594644 != nil:
    section.add "X-Amz-Security-Token", valid_594644
  var valid_594645 = header.getOrDefault("X-Amz-Algorithm")
  valid_594645 = validateParameter(valid_594645, JString, required = false,
                                 default = nil)
  if valid_594645 != nil:
    section.add "X-Amz-Algorithm", valid_594645
  var valid_594646 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594646 = validateParameter(valid_594646, JString, required = false,
                                 default = nil)
  if valid_594646 != nil:
    section.add "X-Amz-SignedHeaders", valid_594646
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594648: Call_CreateOTAUpdate_594636; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ## 
  let valid = call_594648.validator(path, query, header, formData, body)
  let scheme = call_594648.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594648.url(scheme.get, call_594648.host, call_594648.base,
                         call_594648.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594648, url, valid)

proc call*(call_594649: Call_CreateOTAUpdate_594636; body: JsonNode;
          otaUpdateId: string): Recallable =
  ## createOTAUpdate
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ##   body: JObject (required)
  ##   otaUpdateId: string (required)
  ##              : The ID of the OTA update to be created.
  var path_594650 = newJObject()
  var body_594651 = newJObject()
  if body != nil:
    body_594651 = body
  add(path_594650, "otaUpdateId", newJString(otaUpdateId))
  result = call_594649.call(path_594650, nil, nil, nil, body_594651)

var createOTAUpdate* = Call_CreateOTAUpdate_594636(name: "createOTAUpdate",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_CreateOTAUpdate_594637,
    base: "/", url: url_CreateOTAUpdate_594638, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetOTAUpdate_594622 = ref object of OpenApiRestCall_593389
proc url_GetOTAUpdate_594624(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOTAUpdate_594623(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets an OTA update.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The OTA update ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_594625 = path.getOrDefault("otaUpdateId")
  valid_594625 = validateParameter(valid_594625, JString, required = true,
                                 default = nil)
  if valid_594625 != nil:
    section.add "otaUpdateId", valid_594625
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594626 = header.getOrDefault("X-Amz-Signature")
  valid_594626 = validateParameter(valid_594626, JString, required = false,
                                 default = nil)
  if valid_594626 != nil:
    section.add "X-Amz-Signature", valid_594626
  var valid_594627 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594627 = validateParameter(valid_594627, JString, required = false,
                                 default = nil)
  if valid_594627 != nil:
    section.add "X-Amz-Content-Sha256", valid_594627
  var valid_594628 = header.getOrDefault("X-Amz-Date")
  valid_594628 = validateParameter(valid_594628, JString, required = false,
                                 default = nil)
  if valid_594628 != nil:
    section.add "X-Amz-Date", valid_594628
  var valid_594629 = header.getOrDefault("X-Amz-Credential")
  valid_594629 = validateParameter(valid_594629, JString, required = false,
                                 default = nil)
  if valid_594629 != nil:
    section.add "X-Amz-Credential", valid_594629
  var valid_594630 = header.getOrDefault("X-Amz-Security-Token")
  valid_594630 = validateParameter(valid_594630, JString, required = false,
                                 default = nil)
  if valid_594630 != nil:
    section.add "X-Amz-Security-Token", valid_594630
  var valid_594631 = header.getOrDefault("X-Amz-Algorithm")
  valid_594631 = validateParameter(valid_594631, JString, required = false,
                                 default = nil)
  if valid_594631 != nil:
    section.add "X-Amz-Algorithm", valid_594631
  var valid_594632 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594632 = validateParameter(valid_594632, JString, required = false,
                                 default = nil)
  if valid_594632 != nil:
    section.add "X-Amz-SignedHeaders", valid_594632
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594633: Call_GetOTAUpdate_594622; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets an OTA update.
  ## 
  let valid = call_594633.validator(path, query, header, formData, body)
  let scheme = call_594633.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594633.url(scheme.get, call_594633.host, call_594633.base,
                         call_594633.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594633, url, valid)

proc call*(call_594634: Call_GetOTAUpdate_594622; otaUpdateId: string): Recallable =
  ## getOTAUpdate
  ## Gets an OTA update.
  ##   otaUpdateId: string (required)
  ##              : The OTA update ID.
  var path_594635 = newJObject()
  add(path_594635, "otaUpdateId", newJString(otaUpdateId))
  result = call_594634.call(path_594635, nil, nil, nil, nil)

var getOTAUpdate* = Call_GetOTAUpdate_594622(name: "getOTAUpdate",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_GetOTAUpdate_594623,
    base: "/", url: url_GetOTAUpdate_594624, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteOTAUpdate_594652 = ref object of OpenApiRestCall_593389
proc url_DeleteOTAUpdate_594654(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOTAUpdate_594653(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Delete an OTA update.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The OTA update ID to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_594655 = path.getOrDefault("otaUpdateId")
  valid_594655 = validateParameter(valid_594655, JString, required = true,
                                 default = nil)
  if valid_594655 != nil:
    section.add "otaUpdateId", valid_594655
  result.add "path", section
  ## parameters in `query` object:
  ##   deleteStream: JBool
  ##               : Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.
  ##   forceDeleteAWSJob: JBool
  ##                    : Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.
  section = newJObject()
  var valid_594656 = query.getOrDefault("deleteStream")
  valid_594656 = validateParameter(valid_594656, JBool, required = false, default = nil)
  if valid_594656 != nil:
    section.add "deleteStream", valid_594656
  var valid_594657 = query.getOrDefault("forceDeleteAWSJob")
  valid_594657 = validateParameter(valid_594657, JBool, required = false, default = nil)
  if valid_594657 != nil:
    section.add "forceDeleteAWSJob", valid_594657
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594658 = header.getOrDefault("X-Amz-Signature")
  valid_594658 = validateParameter(valid_594658, JString, required = false,
                                 default = nil)
  if valid_594658 != nil:
    section.add "X-Amz-Signature", valid_594658
  var valid_594659 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594659 = validateParameter(valid_594659, JString, required = false,
                                 default = nil)
  if valid_594659 != nil:
    section.add "X-Amz-Content-Sha256", valid_594659
  var valid_594660 = header.getOrDefault("X-Amz-Date")
  valid_594660 = validateParameter(valid_594660, JString, required = false,
                                 default = nil)
  if valid_594660 != nil:
    section.add "X-Amz-Date", valid_594660
  var valid_594661 = header.getOrDefault("X-Amz-Credential")
  valid_594661 = validateParameter(valid_594661, JString, required = false,
                                 default = nil)
  if valid_594661 != nil:
    section.add "X-Amz-Credential", valid_594661
  var valid_594662 = header.getOrDefault("X-Amz-Security-Token")
  valid_594662 = validateParameter(valid_594662, JString, required = false,
                                 default = nil)
  if valid_594662 != nil:
    section.add "X-Amz-Security-Token", valid_594662
  var valid_594663 = header.getOrDefault("X-Amz-Algorithm")
  valid_594663 = validateParameter(valid_594663, JString, required = false,
                                 default = nil)
  if valid_594663 != nil:
    section.add "X-Amz-Algorithm", valid_594663
  var valid_594664 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594664 = validateParameter(valid_594664, JString, required = false,
                                 default = nil)
  if valid_594664 != nil:
    section.add "X-Amz-SignedHeaders", valid_594664
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594665: Call_DeleteOTAUpdate_594652; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete an OTA update.
  ## 
  let valid = call_594665.validator(path, query, header, formData, body)
  let scheme = call_594665.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594665.url(scheme.get, call_594665.host, call_594665.base,
                         call_594665.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594665, url, valid)

proc call*(call_594666: Call_DeleteOTAUpdate_594652; otaUpdateId: string;
          deleteStream: bool = false; forceDeleteAWSJob: bool = false): Recallable =
  ## deleteOTAUpdate
  ## Delete an OTA update.
  ##   deleteStream: bool
  ##               : Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.
  ##   otaUpdateId: string (required)
  ##              : The OTA update ID to delete.
  ##   forceDeleteAWSJob: bool
  ##                    : Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.
  var path_594667 = newJObject()
  var query_594668 = newJObject()
  add(query_594668, "deleteStream", newJBool(deleteStream))
  add(path_594667, "otaUpdateId", newJString(otaUpdateId))
  add(query_594668, "forceDeleteAWSJob", newJBool(forceDeleteAWSJob))
  result = call_594666.call(path_594667, query_594668, nil, nil, nil)

var deleteOTAUpdate* = Call_DeleteOTAUpdate_594652(name: "deleteOTAUpdate",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_DeleteOTAUpdate_594653,
    base: "/", url: url_DeleteOTAUpdate_594654, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreatePolicy_594683 = ref object of OpenApiRestCall_593389
proc url_CreatePolicy_594685(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreatePolicy_594684(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594686 = path.getOrDefault("policyName")
  valid_594686 = validateParameter(valid_594686, JString, required = true,
                                 default = nil)
  if valid_594686 != nil:
    section.add "policyName", valid_594686
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594687 = header.getOrDefault("X-Amz-Signature")
  valid_594687 = validateParameter(valid_594687, JString, required = false,
                                 default = nil)
  if valid_594687 != nil:
    section.add "X-Amz-Signature", valid_594687
  var valid_594688 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594688 = validateParameter(valid_594688, JString, required = false,
                                 default = nil)
  if valid_594688 != nil:
    section.add "X-Amz-Content-Sha256", valid_594688
  var valid_594689 = header.getOrDefault("X-Amz-Date")
  valid_594689 = validateParameter(valid_594689, JString, required = false,
                                 default = nil)
  if valid_594689 != nil:
    section.add "X-Amz-Date", valid_594689
  var valid_594690 = header.getOrDefault("X-Amz-Credential")
  valid_594690 = validateParameter(valid_594690, JString, required = false,
                                 default = nil)
  if valid_594690 != nil:
    section.add "X-Amz-Credential", valid_594690
  var valid_594691 = header.getOrDefault("X-Amz-Security-Token")
  valid_594691 = validateParameter(valid_594691, JString, required = false,
                                 default = nil)
  if valid_594691 != nil:
    section.add "X-Amz-Security-Token", valid_594691
  var valid_594692 = header.getOrDefault("X-Amz-Algorithm")
  valid_594692 = validateParameter(valid_594692, JString, required = false,
                                 default = nil)
  if valid_594692 != nil:
    section.add "X-Amz-Algorithm", valid_594692
  var valid_594693 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594693 = validateParameter(valid_594693, JString, required = false,
                                 default = nil)
  if valid_594693 != nil:
    section.add "X-Amz-SignedHeaders", valid_594693
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594695: Call_CreatePolicy_594683; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ## 
  let valid = call_594695.validator(path, query, header, formData, body)
  let scheme = call_594695.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594695.url(scheme.get, call_594695.host, call_594695.base,
                         call_594695.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594695, url, valid)

proc call*(call_594696: Call_CreatePolicy_594683; policyName: string; body: JsonNode): Recallable =
  ## createPolicy
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ##   policyName: string (required)
  ##             : The policy name.
  ##   body: JObject (required)
  var path_594697 = newJObject()
  var body_594698 = newJObject()
  add(path_594697, "policyName", newJString(policyName))
  if body != nil:
    body_594698 = body
  result = call_594696.call(path_594697, nil, nil, nil, body_594698)

var createPolicy* = Call_CreatePolicy_594683(name: "createPolicy",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/policies/{policyName}", validator: validate_CreatePolicy_594684,
    base: "/", url: url_CreatePolicy_594685, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPolicy_594669 = ref object of OpenApiRestCall_593389
proc url_GetPolicy_594671(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetPolicy_594670(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the specified policy with the policy document of the default version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594672 = path.getOrDefault("policyName")
  valid_594672 = validateParameter(valid_594672, JString, required = true,
                                 default = nil)
  if valid_594672 != nil:
    section.add "policyName", valid_594672
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594673 = header.getOrDefault("X-Amz-Signature")
  valid_594673 = validateParameter(valid_594673, JString, required = false,
                                 default = nil)
  if valid_594673 != nil:
    section.add "X-Amz-Signature", valid_594673
  var valid_594674 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594674 = validateParameter(valid_594674, JString, required = false,
                                 default = nil)
  if valid_594674 != nil:
    section.add "X-Amz-Content-Sha256", valid_594674
  var valid_594675 = header.getOrDefault("X-Amz-Date")
  valid_594675 = validateParameter(valid_594675, JString, required = false,
                                 default = nil)
  if valid_594675 != nil:
    section.add "X-Amz-Date", valid_594675
  var valid_594676 = header.getOrDefault("X-Amz-Credential")
  valid_594676 = validateParameter(valid_594676, JString, required = false,
                                 default = nil)
  if valid_594676 != nil:
    section.add "X-Amz-Credential", valid_594676
  var valid_594677 = header.getOrDefault("X-Amz-Security-Token")
  valid_594677 = validateParameter(valid_594677, JString, required = false,
                                 default = nil)
  if valid_594677 != nil:
    section.add "X-Amz-Security-Token", valid_594677
  var valid_594678 = header.getOrDefault("X-Amz-Algorithm")
  valid_594678 = validateParameter(valid_594678, JString, required = false,
                                 default = nil)
  if valid_594678 != nil:
    section.add "X-Amz-Algorithm", valid_594678
  var valid_594679 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594679 = validateParameter(valid_594679, JString, required = false,
                                 default = nil)
  if valid_594679 != nil:
    section.add "X-Amz-SignedHeaders", valid_594679
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594680: Call_GetPolicy_594669; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified policy with the policy document of the default version.
  ## 
  let valid = call_594680.validator(path, query, header, formData, body)
  let scheme = call_594680.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594680.url(scheme.get, call_594680.host, call_594680.base,
                         call_594680.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594680, url, valid)

proc call*(call_594681: Call_GetPolicy_594669; policyName: string): Recallable =
  ## getPolicy
  ## Gets information about the specified policy with the policy document of the default version.
  ##   policyName: string (required)
  ##             : The name of the policy.
  var path_594682 = newJObject()
  add(path_594682, "policyName", newJString(policyName))
  result = call_594681.call(path_594682, nil, nil, nil, nil)

var getPolicy* = Call_GetPolicy_594669(name: "getPolicy", meth: HttpMethod.HttpGet,
                                    host: "iot.amazonaws.com",
                                    route: "/policies/{policyName}",
                                    validator: validate_GetPolicy_594670,
                                    base: "/", url: url_GetPolicy_594671,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeletePolicy_594699 = ref object of OpenApiRestCall_593389
proc url_DeletePolicy_594701(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeletePolicy_594700(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594702 = path.getOrDefault("policyName")
  valid_594702 = validateParameter(valid_594702, JString, required = true,
                                 default = nil)
  if valid_594702 != nil:
    section.add "policyName", valid_594702
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594703 = header.getOrDefault("X-Amz-Signature")
  valid_594703 = validateParameter(valid_594703, JString, required = false,
                                 default = nil)
  if valid_594703 != nil:
    section.add "X-Amz-Signature", valid_594703
  var valid_594704 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594704 = validateParameter(valid_594704, JString, required = false,
                                 default = nil)
  if valid_594704 != nil:
    section.add "X-Amz-Content-Sha256", valid_594704
  var valid_594705 = header.getOrDefault("X-Amz-Date")
  valid_594705 = validateParameter(valid_594705, JString, required = false,
                                 default = nil)
  if valid_594705 != nil:
    section.add "X-Amz-Date", valid_594705
  var valid_594706 = header.getOrDefault("X-Amz-Credential")
  valid_594706 = validateParameter(valid_594706, JString, required = false,
                                 default = nil)
  if valid_594706 != nil:
    section.add "X-Amz-Credential", valid_594706
  var valid_594707 = header.getOrDefault("X-Amz-Security-Token")
  valid_594707 = validateParameter(valid_594707, JString, required = false,
                                 default = nil)
  if valid_594707 != nil:
    section.add "X-Amz-Security-Token", valid_594707
  var valid_594708 = header.getOrDefault("X-Amz-Algorithm")
  valid_594708 = validateParameter(valid_594708, JString, required = false,
                                 default = nil)
  if valid_594708 != nil:
    section.add "X-Amz-Algorithm", valid_594708
  var valid_594709 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594709 = validateParameter(valid_594709, JString, required = false,
                                 default = nil)
  if valid_594709 != nil:
    section.add "X-Amz-SignedHeaders", valid_594709
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594710: Call_DeletePolicy_594699; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ## 
  let valid = call_594710.validator(path, query, header, formData, body)
  let scheme = call_594710.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594710.url(scheme.get, call_594710.host, call_594710.base,
                         call_594710.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594710, url, valid)

proc call*(call_594711: Call_DeletePolicy_594699; policyName: string): Recallable =
  ## deletePolicy
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ##   policyName: string (required)
  ##             : The name of the policy to delete.
  var path_594712 = newJObject()
  add(path_594712, "policyName", newJString(policyName))
  result = call_594711.call(path_594712, nil, nil, nil, nil)

var deletePolicy* = Call_DeletePolicy_594699(name: "deletePolicy",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/policies/{policyName}", validator: validate_DeletePolicy_594700,
    base: "/", url: url_DeletePolicy_594701, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreatePolicyVersion_594727 = ref object of OpenApiRestCall_593389
proc url_CreatePolicyVersion_594729(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreatePolicyVersion_594728(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594730 = path.getOrDefault("policyName")
  valid_594730 = validateParameter(valid_594730, JString, required = true,
                                 default = nil)
  if valid_594730 != nil:
    section.add "policyName", valid_594730
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsDefault: JBool
  ##               : Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
  section = newJObject()
  var valid_594731 = query.getOrDefault("setAsDefault")
  valid_594731 = validateParameter(valid_594731, JBool, required = false, default = nil)
  if valid_594731 != nil:
    section.add "setAsDefault", valid_594731
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594732 = header.getOrDefault("X-Amz-Signature")
  valid_594732 = validateParameter(valid_594732, JString, required = false,
                                 default = nil)
  if valid_594732 != nil:
    section.add "X-Amz-Signature", valid_594732
  var valid_594733 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594733 = validateParameter(valid_594733, JString, required = false,
                                 default = nil)
  if valid_594733 != nil:
    section.add "X-Amz-Content-Sha256", valid_594733
  var valid_594734 = header.getOrDefault("X-Amz-Date")
  valid_594734 = validateParameter(valid_594734, JString, required = false,
                                 default = nil)
  if valid_594734 != nil:
    section.add "X-Amz-Date", valid_594734
  var valid_594735 = header.getOrDefault("X-Amz-Credential")
  valid_594735 = validateParameter(valid_594735, JString, required = false,
                                 default = nil)
  if valid_594735 != nil:
    section.add "X-Amz-Credential", valid_594735
  var valid_594736 = header.getOrDefault("X-Amz-Security-Token")
  valid_594736 = validateParameter(valid_594736, JString, required = false,
                                 default = nil)
  if valid_594736 != nil:
    section.add "X-Amz-Security-Token", valid_594736
  var valid_594737 = header.getOrDefault("X-Amz-Algorithm")
  valid_594737 = validateParameter(valid_594737, JString, required = false,
                                 default = nil)
  if valid_594737 != nil:
    section.add "X-Amz-Algorithm", valid_594737
  var valid_594738 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594738 = validateParameter(valid_594738, JString, required = false,
                                 default = nil)
  if valid_594738 != nil:
    section.add "X-Amz-SignedHeaders", valid_594738
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594740: Call_CreatePolicyVersion_594727; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ## 
  let valid = call_594740.validator(path, query, header, formData, body)
  let scheme = call_594740.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594740.url(scheme.get, call_594740.host, call_594740.base,
                         call_594740.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594740, url, valid)

proc call*(call_594741: Call_CreatePolicyVersion_594727; policyName: string;
          body: JsonNode; setAsDefault: bool = false): Recallable =
  ## createPolicyVersion
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ##   policyName: string (required)
  ##             : The policy name.
  ##   setAsDefault: bool
  ##               : Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
  ##   body: JObject (required)
  var path_594742 = newJObject()
  var query_594743 = newJObject()
  var body_594744 = newJObject()
  add(path_594742, "policyName", newJString(policyName))
  add(query_594743, "setAsDefault", newJBool(setAsDefault))
  if body != nil:
    body_594744 = body
  result = call_594741.call(path_594742, query_594743, nil, nil, body_594744)

var createPolicyVersion* = Call_CreatePolicyVersion_594727(
    name: "createPolicyVersion", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/policies/{policyName}/version",
    validator: validate_CreatePolicyVersion_594728, base: "/",
    url: url_CreatePolicyVersion_594729, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicyVersions_594713 = ref object of OpenApiRestCall_593389
proc url_ListPolicyVersions_594715(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListPolicyVersions_594714(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Lists the versions of the specified policy and identifies the default version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_594716 = path.getOrDefault("policyName")
  valid_594716 = validateParameter(valid_594716, JString, required = true,
                                 default = nil)
  if valid_594716 != nil:
    section.add "policyName", valid_594716
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594717 = header.getOrDefault("X-Amz-Signature")
  valid_594717 = validateParameter(valid_594717, JString, required = false,
                                 default = nil)
  if valid_594717 != nil:
    section.add "X-Amz-Signature", valid_594717
  var valid_594718 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594718 = validateParameter(valid_594718, JString, required = false,
                                 default = nil)
  if valid_594718 != nil:
    section.add "X-Amz-Content-Sha256", valid_594718
  var valid_594719 = header.getOrDefault("X-Amz-Date")
  valid_594719 = validateParameter(valid_594719, JString, required = false,
                                 default = nil)
  if valid_594719 != nil:
    section.add "X-Amz-Date", valid_594719
  var valid_594720 = header.getOrDefault("X-Amz-Credential")
  valid_594720 = validateParameter(valid_594720, JString, required = false,
                                 default = nil)
  if valid_594720 != nil:
    section.add "X-Amz-Credential", valid_594720
  var valid_594721 = header.getOrDefault("X-Amz-Security-Token")
  valid_594721 = validateParameter(valid_594721, JString, required = false,
                                 default = nil)
  if valid_594721 != nil:
    section.add "X-Amz-Security-Token", valid_594721
  var valid_594722 = header.getOrDefault("X-Amz-Algorithm")
  valid_594722 = validateParameter(valid_594722, JString, required = false,
                                 default = nil)
  if valid_594722 != nil:
    section.add "X-Amz-Algorithm", valid_594722
  var valid_594723 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594723 = validateParameter(valid_594723, JString, required = false,
                                 default = nil)
  if valid_594723 != nil:
    section.add "X-Amz-SignedHeaders", valid_594723
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594724: Call_ListPolicyVersions_594713; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the versions of the specified policy and identifies the default version.
  ## 
  let valid = call_594724.validator(path, query, header, formData, body)
  let scheme = call_594724.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594724.url(scheme.get, call_594724.host, call_594724.base,
                         call_594724.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594724, url, valid)

proc call*(call_594725: Call_ListPolicyVersions_594713; policyName: string): Recallable =
  ## listPolicyVersions
  ## Lists the versions of the specified policy and identifies the default version.
  ##   policyName: string (required)
  ##             : The policy name.
  var path_594726 = newJObject()
  add(path_594726, "policyName", newJString(policyName))
  result = call_594725.call(path_594726, nil, nil, nil, nil)

var listPolicyVersions* = Call_ListPolicyVersions_594713(
    name: "listPolicyVersions", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version",
    validator: validate_ListPolicyVersions_594714, base: "/",
    url: url_ListPolicyVersions_594715, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateRoleAlias_594759 = ref object of OpenApiRestCall_593389
proc url_UpdateRoleAlias_594761(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateRoleAlias_594760(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Updates a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_594762 = path.getOrDefault("roleAlias")
  valid_594762 = validateParameter(valid_594762, JString, required = true,
                                 default = nil)
  if valid_594762 != nil:
    section.add "roleAlias", valid_594762
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594763 = header.getOrDefault("X-Amz-Signature")
  valid_594763 = validateParameter(valid_594763, JString, required = false,
                                 default = nil)
  if valid_594763 != nil:
    section.add "X-Amz-Signature", valid_594763
  var valid_594764 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594764 = validateParameter(valid_594764, JString, required = false,
                                 default = nil)
  if valid_594764 != nil:
    section.add "X-Amz-Content-Sha256", valid_594764
  var valid_594765 = header.getOrDefault("X-Amz-Date")
  valid_594765 = validateParameter(valid_594765, JString, required = false,
                                 default = nil)
  if valid_594765 != nil:
    section.add "X-Amz-Date", valid_594765
  var valid_594766 = header.getOrDefault("X-Amz-Credential")
  valid_594766 = validateParameter(valid_594766, JString, required = false,
                                 default = nil)
  if valid_594766 != nil:
    section.add "X-Amz-Credential", valid_594766
  var valid_594767 = header.getOrDefault("X-Amz-Security-Token")
  valid_594767 = validateParameter(valid_594767, JString, required = false,
                                 default = nil)
  if valid_594767 != nil:
    section.add "X-Amz-Security-Token", valid_594767
  var valid_594768 = header.getOrDefault("X-Amz-Algorithm")
  valid_594768 = validateParameter(valid_594768, JString, required = false,
                                 default = nil)
  if valid_594768 != nil:
    section.add "X-Amz-Algorithm", valid_594768
  var valid_594769 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594769 = validateParameter(valid_594769, JString, required = false,
                                 default = nil)
  if valid_594769 != nil:
    section.add "X-Amz-SignedHeaders", valid_594769
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594771: Call_UpdateRoleAlias_594759; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a role alias.
  ## 
  let valid = call_594771.validator(path, query, header, formData, body)
  let scheme = call_594771.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594771.url(scheme.get, call_594771.host, call_594771.base,
                         call_594771.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594771, url, valid)

proc call*(call_594772: Call_UpdateRoleAlias_594759; roleAlias: string;
          body: JsonNode): Recallable =
  ## updateRoleAlias
  ## Updates a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias to update.
  ##   body: JObject (required)
  var path_594773 = newJObject()
  var body_594774 = newJObject()
  add(path_594773, "roleAlias", newJString(roleAlias))
  if body != nil:
    body_594774 = body
  result = call_594772.call(path_594773, nil, nil, nil, body_594774)

var updateRoleAlias* = Call_UpdateRoleAlias_594759(name: "updateRoleAlias",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_UpdateRoleAlias_594760,
    base: "/", url: url_UpdateRoleAlias_594761, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateRoleAlias_594775 = ref object of OpenApiRestCall_593389
proc url_CreateRoleAlias_594777(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateRoleAlias_594776(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias that points to a role ARN. This allows you to change the role without having to update the device.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_594778 = path.getOrDefault("roleAlias")
  valid_594778 = validateParameter(valid_594778, JString, required = true,
                                 default = nil)
  if valid_594778 != nil:
    section.add "roleAlias", valid_594778
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594779 = header.getOrDefault("X-Amz-Signature")
  valid_594779 = validateParameter(valid_594779, JString, required = false,
                                 default = nil)
  if valid_594779 != nil:
    section.add "X-Amz-Signature", valid_594779
  var valid_594780 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594780 = validateParameter(valid_594780, JString, required = false,
                                 default = nil)
  if valid_594780 != nil:
    section.add "X-Amz-Content-Sha256", valid_594780
  var valid_594781 = header.getOrDefault("X-Amz-Date")
  valid_594781 = validateParameter(valid_594781, JString, required = false,
                                 default = nil)
  if valid_594781 != nil:
    section.add "X-Amz-Date", valid_594781
  var valid_594782 = header.getOrDefault("X-Amz-Credential")
  valid_594782 = validateParameter(valid_594782, JString, required = false,
                                 default = nil)
  if valid_594782 != nil:
    section.add "X-Amz-Credential", valid_594782
  var valid_594783 = header.getOrDefault("X-Amz-Security-Token")
  valid_594783 = validateParameter(valid_594783, JString, required = false,
                                 default = nil)
  if valid_594783 != nil:
    section.add "X-Amz-Security-Token", valid_594783
  var valid_594784 = header.getOrDefault("X-Amz-Algorithm")
  valid_594784 = validateParameter(valid_594784, JString, required = false,
                                 default = nil)
  if valid_594784 != nil:
    section.add "X-Amz-Algorithm", valid_594784
  var valid_594785 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594785 = validateParameter(valid_594785, JString, required = false,
                                 default = nil)
  if valid_594785 != nil:
    section.add "X-Amz-SignedHeaders", valid_594785
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594787: Call_CreateRoleAlias_594775; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a role alias.
  ## 
  let valid = call_594787.validator(path, query, header, formData, body)
  let scheme = call_594787.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594787.url(scheme.get, call_594787.host, call_594787.base,
                         call_594787.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594787, url, valid)

proc call*(call_594788: Call_CreateRoleAlias_594775; roleAlias: string;
          body: JsonNode): Recallable =
  ## createRoleAlias
  ## Creates a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias that points to a role ARN. This allows you to change the role without having to update the device.
  ##   body: JObject (required)
  var path_594789 = newJObject()
  var body_594790 = newJObject()
  add(path_594789, "roleAlias", newJString(roleAlias))
  if body != nil:
    body_594790 = body
  result = call_594788.call(path_594789, nil, nil, nil, body_594790)

var createRoleAlias* = Call_CreateRoleAlias_594775(name: "createRoleAlias",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_CreateRoleAlias_594776,
    base: "/", url: url_CreateRoleAlias_594777, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeRoleAlias_594745 = ref object of OpenApiRestCall_593389
proc url_DescribeRoleAlias_594747(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeRoleAlias_594746(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Describes a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to describe.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_594748 = path.getOrDefault("roleAlias")
  valid_594748 = validateParameter(valid_594748, JString, required = true,
                                 default = nil)
  if valid_594748 != nil:
    section.add "roleAlias", valid_594748
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594749 = header.getOrDefault("X-Amz-Signature")
  valid_594749 = validateParameter(valid_594749, JString, required = false,
                                 default = nil)
  if valid_594749 != nil:
    section.add "X-Amz-Signature", valid_594749
  var valid_594750 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594750 = validateParameter(valid_594750, JString, required = false,
                                 default = nil)
  if valid_594750 != nil:
    section.add "X-Amz-Content-Sha256", valid_594750
  var valid_594751 = header.getOrDefault("X-Amz-Date")
  valid_594751 = validateParameter(valid_594751, JString, required = false,
                                 default = nil)
  if valid_594751 != nil:
    section.add "X-Amz-Date", valid_594751
  var valid_594752 = header.getOrDefault("X-Amz-Credential")
  valid_594752 = validateParameter(valid_594752, JString, required = false,
                                 default = nil)
  if valid_594752 != nil:
    section.add "X-Amz-Credential", valid_594752
  var valid_594753 = header.getOrDefault("X-Amz-Security-Token")
  valid_594753 = validateParameter(valid_594753, JString, required = false,
                                 default = nil)
  if valid_594753 != nil:
    section.add "X-Amz-Security-Token", valid_594753
  var valid_594754 = header.getOrDefault("X-Amz-Algorithm")
  valid_594754 = validateParameter(valid_594754, JString, required = false,
                                 default = nil)
  if valid_594754 != nil:
    section.add "X-Amz-Algorithm", valid_594754
  var valid_594755 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594755 = validateParameter(valid_594755, JString, required = false,
                                 default = nil)
  if valid_594755 != nil:
    section.add "X-Amz-SignedHeaders", valid_594755
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594756: Call_DescribeRoleAlias_594745; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a role alias.
  ## 
  let valid = call_594756.validator(path, query, header, formData, body)
  let scheme = call_594756.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594756.url(scheme.get, call_594756.host, call_594756.base,
                         call_594756.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594756, url, valid)

proc call*(call_594757: Call_DescribeRoleAlias_594745; roleAlias: string): Recallable =
  ## describeRoleAlias
  ## Describes a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias to describe.
  var path_594758 = newJObject()
  add(path_594758, "roleAlias", newJString(roleAlias))
  result = call_594757.call(path_594758, nil, nil, nil, nil)

var describeRoleAlias* = Call_DescribeRoleAlias_594745(name: "describeRoleAlias",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_DescribeRoleAlias_594746,
    base: "/", url: url_DescribeRoleAlias_594747,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRoleAlias_594791 = ref object of OpenApiRestCall_593389
proc url_DeleteRoleAlias_594793(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteRoleAlias_594792(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes a role alias
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_594794 = path.getOrDefault("roleAlias")
  valid_594794 = validateParameter(valid_594794, JString, required = true,
                                 default = nil)
  if valid_594794 != nil:
    section.add "roleAlias", valid_594794
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594795 = header.getOrDefault("X-Amz-Signature")
  valid_594795 = validateParameter(valid_594795, JString, required = false,
                                 default = nil)
  if valid_594795 != nil:
    section.add "X-Amz-Signature", valid_594795
  var valid_594796 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594796 = validateParameter(valid_594796, JString, required = false,
                                 default = nil)
  if valid_594796 != nil:
    section.add "X-Amz-Content-Sha256", valid_594796
  var valid_594797 = header.getOrDefault("X-Amz-Date")
  valid_594797 = validateParameter(valid_594797, JString, required = false,
                                 default = nil)
  if valid_594797 != nil:
    section.add "X-Amz-Date", valid_594797
  var valid_594798 = header.getOrDefault("X-Amz-Credential")
  valid_594798 = validateParameter(valid_594798, JString, required = false,
                                 default = nil)
  if valid_594798 != nil:
    section.add "X-Amz-Credential", valid_594798
  var valid_594799 = header.getOrDefault("X-Amz-Security-Token")
  valid_594799 = validateParameter(valid_594799, JString, required = false,
                                 default = nil)
  if valid_594799 != nil:
    section.add "X-Amz-Security-Token", valid_594799
  var valid_594800 = header.getOrDefault("X-Amz-Algorithm")
  valid_594800 = validateParameter(valid_594800, JString, required = false,
                                 default = nil)
  if valid_594800 != nil:
    section.add "X-Amz-Algorithm", valid_594800
  var valid_594801 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594801 = validateParameter(valid_594801, JString, required = false,
                                 default = nil)
  if valid_594801 != nil:
    section.add "X-Amz-SignedHeaders", valid_594801
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594802: Call_DeleteRoleAlias_594791; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a role alias
  ## 
  let valid = call_594802.validator(path, query, header, formData, body)
  let scheme = call_594802.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594802.url(scheme.get, call_594802.host, call_594802.base,
                         call_594802.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594802, url, valid)

proc call*(call_594803: Call_DeleteRoleAlias_594791; roleAlias: string): Recallable =
  ## deleteRoleAlias
  ## Deletes a role alias
  ##   roleAlias: string (required)
  ##            : The role alias to delete.
  var path_594804 = newJObject()
  add(path_594804, "roleAlias", newJString(roleAlias))
  result = call_594803.call(path_594804, nil, nil, nil, nil)

var deleteRoleAlias* = Call_DeleteRoleAlias_594791(name: "deleteRoleAlias",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_DeleteRoleAlias_594792,
    base: "/", url: url_DeleteRoleAlias_594793, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateScheduledAudit_594819 = ref object of OpenApiRestCall_593389
proc url_CreateScheduledAudit_594821(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateScheduledAudit_594820(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled audit that is run at a specified time interval.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name you want to give to the scheduled audit. (Max. 128 chars)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_594822 = path.getOrDefault("scheduledAuditName")
  valid_594822 = validateParameter(valid_594822, JString, required = true,
                                 default = nil)
  if valid_594822 != nil:
    section.add "scheduledAuditName", valid_594822
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594823 = header.getOrDefault("X-Amz-Signature")
  valid_594823 = validateParameter(valid_594823, JString, required = false,
                                 default = nil)
  if valid_594823 != nil:
    section.add "X-Amz-Signature", valid_594823
  var valid_594824 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594824 = validateParameter(valid_594824, JString, required = false,
                                 default = nil)
  if valid_594824 != nil:
    section.add "X-Amz-Content-Sha256", valid_594824
  var valid_594825 = header.getOrDefault("X-Amz-Date")
  valid_594825 = validateParameter(valid_594825, JString, required = false,
                                 default = nil)
  if valid_594825 != nil:
    section.add "X-Amz-Date", valid_594825
  var valid_594826 = header.getOrDefault("X-Amz-Credential")
  valid_594826 = validateParameter(valid_594826, JString, required = false,
                                 default = nil)
  if valid_594826 != nil:
    section.add "X-Amz-Credential", valid_594826
  var valid_594827 = header.getOrDefault("X-Amz-Security-Token")
  valid_594827 = validateParameter(valid_594827, JString, required = false,
                                 default = nil)
  if valid_594827 != nil:
    section.add "X-Amz-Security-Token", valid_594827
  var valid_594828 = header.getOrDefault("X-Amz-Algorithm")
  valid_594828 = validateParameter(valid_594828, JString, required = false,
                                 default = nil)
  if valid_594828 != nil:
    section.add "X-Amz-Algorithm", valid_594828
  var valid_594829 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594829 = validateParameter(valid_594829, JString, required = false,
                                 default = nil)
  if valid_594829 != nil:
    section.add "X-Amz-SignedHeaders", valid_594829
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594831: Call_CreateScheduledAudit_594819; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled audit that is run at a specified time interval.
  ## 
  let valid = call_594831.validator(path, query, header, formData, body)
  let scheme = call_594831.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594831.url(scheme.get, call_594831.host, call_594831.base,
                         call_594831.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594831, url, valid)

proc call*(call_594832: Call_CreateScheduledAudit_594819;
          scheduledAuditName: string; body: JsonNode): Recallable =
  ## createScheduledAudit
  ## Creates a scheduled audit that is run at a specified time interval.
  ##   scheduledAuditName: string (required)
  ##                     : The name you want to give to the scheduled audit. (Max. 128 chars)
  ##   body: JObject (required)
  var path_594833 = newJObject()
  var body_594834 = newJObject()
  add(path_594833, "scheduledAuditName", newJString(scheduledAuditName))
  if body != nil:
    body_594834 = body
  result = call_594832.call(path_594833, nil, nil, nil, body_594834)

var createScheduledAudit* = Call_CreateScheduledAudit_594819(
    name: "createScheduledAudit", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_CreateScheduledAudit_594820, base: "/",
    url: url_CreateScheduledAudit_594821, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeScheduledAudit_594805 = ref object of OpenApiRestCall_593389
proc url_DescribeScheduledAudit_594807(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeScheduledAudit_594806(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a scheduled audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit whose information you want to get.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_594808 = path.getOrDefault("scheduledAuditName")
  valid_594808 = validateParameter(valid_594808, JString, required = true,
                                 default = nil)
  if valid_594808 != nil:
    section.add "scheduledAuditName", valid_594808
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594809 = header.getOrDefault("X-Amz-Signature")
  valid_594809 = validateParameter(valid_594809, JString, required = false,
                                 default = nil)
  if valid_594809 != nil:
    section.add "X-Amz-Signature", valid_594809
  var valid_594810 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594810 = validateParameter(valid_594810, JString, required = false,
                                 default = nil)
  if valid_594810 != nil:
    section.add "X-Amz-Content-Sha256", valid_594810
  var valid_594811 = header.getOrDefault("X-Amz-Date")
  valid_594811 = validateParameter(valid_594811, JString, required = false,
                                 default = nil)
  if valid_594811 != nil:
    section.add "X-Amz-Date", valid_594811
  var valid_594812 = header.getOrDefault("X-Amz-Credential")
  valid_594812 = validateParameter(valid_594812, JString, required = false,
                                 default = nil)
  if valid_594812 != nil:
    section.add "X-Amz-Credential", valid_594812
  var valid_594813 = header.getOrDefault("X-Amz-Security-Token")
  valid_594813 = validateParameter(valid_594813, JString, required = false,
                                 default = nil)
  if valid_594813 != nil:
    section.add "X-Amz-Security-Token", valid_594813
  var valid_594814 = header.getOrDefault("X-Amz-Algorithm")
  valid_594814 = validateParameter(valid_594814, JString, required = false,
                                 default = nil)
  if valid_594814 != nil:
    section.add "X-Amz-Algorithm", valid_594814
  var valid_594815 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594815 = validateParameter(valid_594815, JString, required = false,
                                 default = nil)
  if valid_594815 != nil:
    section.add "X-Amz-SignedHeaders", valid_594815
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594816: Call_DescribeScheduledAudit_594805; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a scheduled audit.
  ## 
  let valid = call_594816.validator(path, query, header, formData, body)
  let scheme = call_594816.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594816.url(scheme.get, call_594816.host, call_594816.base,
                         call_594816.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594816, url, valid)

proc call*(call_594817: Call_DescribeScheduledAudit_594805;
          scheduledAuditName: string): Recallable =
  ## describeScheduledAudit
  ## Gets information about a scheduled audit.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit whose information you want to get.
  var path_594818 = newJObject()
  add(path_594818, "scheduledAuditName", newJString(scheduledAuditName))
  result = call_594817.call(path_594818, nil, nil, nil, nil)

var describeScheduledAudit* = Call_DescribeScheduledAudit_594805(
    name: "describeScheduledAudit", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_DescribeScheduledAudit_594806, base: "/",
    url: url_DescribeScheduledAudit_594807, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateScheduledAudit_594849 = ref object of OpenApiRestCall_593389
proc url_UpdateScheduledAudit_594851(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateScheduledAudit_594850(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit. (Max. 128 chars)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_594852 = path.getOrDefault("scheduledAuditName")
  valid_594852 = validateParameter(valid_594852, JString, required = true,
                                 default = nil)
  if valid_594852 != nil:
    section.add "scheduledAuditName", valid_594852
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594853 = header.getOrDefault("X-Amz-Signature")
  valid_594853 = validateParameter(valid_594853, JString, required = false,
                                 default = nil)
  if valid_594853 != nil:
    section.add "X-Amz-Signature", valid_594853
  var valid_594854 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594854 = validateParameter(valid_594854, JString, required = false,
                                 default = nil)
  if valid_594854 != nil:
    section.add "X-Amz-Content-Sha256", valid_594854
  var valid_594855 = header.getOrDefault("X-Amz-Date")
  valid_594855 = validateParameter(valid_594855, JString, required = false,
                                 default = nil)
  if valid_594855 != nil:
    section.add "X-Amz-Date", valid_594855
  var valid_594856 = header.getOrDefault("X-Amz-Credential")
  valid_594856 = validateParameter(valid_594856, JString, required = false,
                                 default = nil)
  if valid_594856 != nil:
    section.add "X-Amz-Credential", valid_594856
  var valid_594857 = header.getOrDefault("X-Amz-Security-Token")
  valid_594857 = validateParameter(valid_594857, JString, required = false,
                                 default = nil)
  if valid_594857 != nil:
    section.add "X-Amz-Security-Token", valid_594857
  var valid_594858 = header.getOrDefault("X-Amz-Algorithm")
  valid_594858 = validateParameter(valid_594858, JString, required = false,
                                 default = nil)
  if valid_594858 != nil:
    section.add "X-Amz-Algorithm", valid_594858
  var valid_594859 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594859 = validateParameter(valid_594859, JString, required = false,
                                 default = nil)
  if valid_594859 != nil:
    section.add "X-Amz-SignedHeaders", valid_594859
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594861: Call_UpdateScheduledAudit_594849; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ## 
  let valid = call_594861.validator(path, query, header, formData, body)
  let scheme = call_594861.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594861.url(scheme.get, call_594861.host, call_594861.base,
                         call_594861.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594861, url, valid)

proc call*(call_594862: Call_UpdateScheduledAudit_594849;
          scheduledAuditName: string; body: JsonNode): Recallable =
  ## updateScheduledAudit
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit. (Max. 128 chars)
  ##   body: JObject (required)
  var path_594863 = newJObject()
  var body_594864 = newJObject()
  add(path_594863, "scheduledAuditName", newJString(scheduledAuditName))
  if body != nil:
    body_594864 = body
  result = call_594862.call(path_594863, nil, nil, nil, body_594864)

var updateScheduledAudit* = Call_UpdateScheduledAudit_594849(
    name: "updateScheduledAudit", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_UpdateScheduledAudit_594850, base: "/",
    url: url_UpdateScheduledAudit_594851, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteScheduledAudit_594835 = ref object of OpenApiRestCall_593389
proc url_DeleteScheduledAudit_594837(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteScheduledAudit_594836(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit you want to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_594838 = path.getOrDefault("scheduledAuditName")
  valid_594838 = validateParameter(valid_594838, JString, required = true,
                                 default = nil)
  if valid_594838 != nil:
    section.add "scheduledAuditName", valid_594838
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594839 = header.getOrDefault("X-Amz-Signature")
  valid_594839 = validateParameter(valid_594839, JString, required = false,
                                 default = nil)
  if valid_594839 != nil:
    section.add "X-Amz-Signature", valid_594839
  var valid_594840 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594840 = validateParameter(valid_594840, JString, required = false,
                                 default = nil)
  if valid_594840 != nil:
    section.add "X-Amz-Content-Sha256", valid_594840
  var valid_594841 = header.getOrDefault("X-Amz-Date")
  valid_594841 = validateParameter(valid_594841, JString, required = false,
                                 default = nil)
  if valid_594841 != nil:
    section.add "X-Amz-Date", valid_594841
  var valid_594842 = header.getOrDefault("X-Amz-Credential")
  valid_594842 = validateParameter(valid_594842, JString, required = false,
                                 default = nil)
  if valid_594842 != nil:
    section.add "X-Amz-Credential", valid_594842
  var valid_594843 = header.getOrDefault("X-Amz-Security-Token")
  valid_594843 = validateParameter(valid_594843, JString, required = false,
                                 default = nil)
  if valid_594843 != nil:
    section.add "X-Amz-Security-Token", valid_594843
  var valid_594844 = header.getOrDefault("X-Amz-Algorithm")
  valid_594844 = validateParameter(valid_594844, JString, required = false,
                                 default = nil)
  if valid_594844 != nil:
    section.add "X-Amz-Algorithm", valid_594844
  var valid_594845 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594845 = validateParameter(valid_594845, JString, required = false,
                                 default = nil)
  if valid_594845 != nil:
    section.add "X-Amz-SignedHeaders", valid_594845
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594846: Call_DeleteScheduledAudit_594835; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled audit.
  ## 
  let valid = call_594846.validator(path, query, header, formData, body)
  let scheme = call_594846.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594846.url(scheme.get, call_594846.host, call_594846.base,
                         call_594846.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594846, url, valid)

proc call*(call_594847: Call_DeleteScheduledAudit_594835;
          scheduledAuditName: string): Recallable =
  ## deleteScheduledAudit
  ## Deletes a scheduled audit.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit you want to delete.
  var path_594848 = newJObject()
  add(path_594848, "scheduledAuditName", newJString(scheduledAuditName))
  result = call_594847.call(path_594848, nil, nil, nil, nil)

var deleteScheduledAudit* = Call_DeleteScheduledAudit_594835(
    name: "deleteScheduledAudit", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_DeleteScheduledAudit_594836, base: "/",
    url: url_DeleteScheduledAudit_594837, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateSecurityProfile_594879 = ref object of OpenApiRestCall_593389
proc url_CreateSecurityProfile_594881(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateSecurityProfile_594880(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name you are giving to the security profile.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_594882 = path.getOrDefault("securityProfileName")
  valid_594882 = validateParameter(valid_594882, JString, required = true,
                                 default = nil)
  if valid_594882 != nil:
    section.add "securityProfileName", valid_594882
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594883 = header.getOrDefault("X-Amz-Signature")
  valid_594883 = validateParameter(valid_594883, JString, required = false,
                                 default = nil)
  if valid_594883 != nil:
    section.add "X-Amz-Signature", valid_594883
  var valid_594884 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594884 = validateParameter(valid_594884, JString, required = false,
                                 default = nil)
  if valid_594884 != nil:
    section.add "X-Amz-Content-Sha256", valid_594884
  var valid_594885 = header.getOrDefault("X-Amz-Date")
  valid_594885 = validateParameter(valid_594885, JString, required = false,
                                 default = nil)
  if valid_594885 != nil:
    section.add "X-Amz-Date", valid_594885
  var valid_594886 = header.getOrDefault("X-Amz-Credential")
  valid_594886 = validateParameter(valid_594886, JString, required = false,
                                 default = nil)
  if valid_594886 != nil:
    section.add "X-Amz-Credential", valid_594886
  var valid_594887 = header.getOrDefault("X-Amz-Security-Token")
  valid_594887 = validateParameter(valid_594887, JString, required = false,
                                 default = nil)
  if valid_594887 != nil:
    section.add "X-Amz-Security-Token", valid_594887
  var valid_594888 = header.getOrDefault("X-Amz-Algorithm")
  valid_594888 = validateParameter(valid_594888, JString, required = false,
                                 default = nil)
  if valid_594888 != nil:
    section.add "X-Amz-Algorithm", valid_594888
  var valid_594889 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594889 = validateParameter(valid_594889, JString, required = false,
                                 default = nil)
  if valid_594889 != nil:
    section.add "X-Amz-SignedHeaders", valid_594889
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594891: Call_CreateSecurityProfile_594879; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Device Defender security profile.
  ## 
  let valid = call_594891.validator(path, query, header, formData, body)
  let scheme = call_594891.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594891.url(scheme.get, call_594891.host, call_594891.base,
                         call_594891.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594891, url, valid)

proc call*(call_594892: Call_CreateSecurityProfile_594879; body: JsonNode;
          securityProfileName: string): Recallable =
  ## createSecurityProfile
  ## Creates a Device Defender security profile.
  ##   body: JObject (required)
  ##   securityProfileName: string (required)
  ##                      : The name you are giving to the security profile.
  var path_594893 = newJObject()
  var body_594894 = newJObject()
  if body != nil:
    body_594894 = body
  add(path_594893, "securityProfileName", newJString(securityProfileName))
  result = call_594892.call(path_594893, nil, nil, nil, body_594894)

var createSecurityProfile* = Call_CreateSecurityProfile_594879(
    name: "createSecurityProfile", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_CreateSecurityProfile_594880, base: "/",
    url: url_CreateSecurityProfile_594881, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeSecurityProfile_594865 = ref object of OpenApiRestCall_593389
proc url_DescribeSecurityProfile_594867(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeSecurityProfile_594866(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile whose information you want to get.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_594868 = path.getOrDefault("securityProfileName")
  valid_594868 = validateParameter(valid_594868, JString, required = true,
                                 default = nil)
  if valid_594868 != nil:
    section.add "securityProfileName", valid_594868
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594869 = header.getOrDefault("X-Amz-Signature")
  valid_594869 = validateParameter(valid_594869, JString, required = false,
                                 default = nil)
  if valid_594869 != nil:
    section.add "X-Amz-Signature", valid_594869
  var valid_594870 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594870 = validateParameter(valid_594870, JString, required = false,
                                 default = nil)
  if valid_594870 != nil:
    section.add "X-Amz-Content-Sha256", valid_594870
  var valid_594871 = header.getOrDefault("X-Amz-Date")
  valid_594871 = validateParameter(valid_594871, JString, required = false,
                                 default = nil)
  if valid_594871 != nil:
    section.add "X-Amz-Date", valid_594871
  var valid_594872 = header.getOrDefault("X-Amz-Credential")
  valid_594872 = validateParameter(valid_594872, JString, required = false,
                                 default = nil)
  if valid_594872 != nil:
    section.add "X-Amz-Credential", valid_594872
  var valid_594873 = header.getOrDefault("X-Amz-Security-Token")
  valid_594873 = validateParameter(valid_594873, JString, required = false,
                                 default = nil)
  if valid_594873 != nil:
    section.add "X-Amz-Security-Token", valid_594873
  var valid_594874 = header.getOrDefault("X-Amz-Algorithm")
  valid_594874 = validateParameter(valid_594874, JString, required = false,
                                 default = nil)
  if valid_594874 != nil:
    section.add "X-Amz-Algorithm", valid_594874
  var valid_594875 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594875 = validateParameter(valid_594875, JString, required = false,
                                 default = nil)
  if valid_594875 != nil:
    section.add "X-Amz-SignedHeaders", valid_594875
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594876: Call_DescribeSecurityProfile_594865; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a Device Defender security profile.
  ## 
  let valid = call_594876.validator(path, query, header, formData, body)
  let scheme = call_594876.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594876.url(scheme.get, call_594876.host, call_594876.base,
                         call_594876.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594876, url, valid)

proc call*(call_594877: Call_DescribeSecurityProfile_594865;
          securityProfileName: string): Recallable =
  ## describeSecurityProfile
  ## Gets information about a Device Defender security profile.
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile whose information you want to get.
  var path_594878 = newJObject()
  add(path_594878, "securityProfileName", newJString(securityProfileName))
  result = call_594877.call(path_594878, nil, nil, nil, nil)

var describeSecurityProfile* = Call_DescribeSecurityProfile_594865(
    name: "describeSecurityProfile", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_DescribeSecurityProfile_594866, base: "/",
    url: url_DescribeSecurityProfile_594867, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateSecurityProfile_594911 = ref object of OpenApiRestCall_593389
proc url_UpdateSecurityProfile_594913(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateSecurityProfile_594912(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile you want to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_594914 = path.getOrDefault("securityProfileName")
  valid_594914 = validateParameter(valid_594914, JString, required = true,
                                 default = nil)
  if valid_594914 != nil:
    section.add "securityProfileName", valid_594914
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  section = newJObject()
  var valid_594915 = query.getOrDefault("expectedVersion")
  valid_594915 = validateParameter(valid_594915, JInt, required = false, default = nil)
  if valid_594915 != nil:
    section.add "expectedVersion", valid_594915
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594916 = header.getOrDefault("X-Amz-Signature")
  valid_594916 = validateParameter(valid_594916, JString, required = false,
                                 default = nil)
  if valid_594916 != nil:
    section.add "X-Amz-Signature", valid_594916
  var valid_594917 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594917 = validateParameter(valid_594917, JString, required = false,
                                 default = nil)
  if valid_594917 != nil:
    section.add "X-Amz-Content-Sha256", valid_594917
  var valid_594918 = header.getOrDefault("X-Amz-Date")
  valid_594918 = validateParameter(valid_594918, JString, required = false,
                                 default = nil)
  if valid_594918 != nil:
    section.add "X-Amz-Date", valid_594918
  var valid_594919 = header.getOrDefault("X-Amz-Credential")
  valid_594919 = validateParameter(valid_594919, JString, required = false,
                                 default = nil)
  if valid_594919 != nil:
    section.add "X-Amz-Credential", valid_594919
  var valid_594920 = header.getOrDefault("X-Amz-Security-Token")
  valid_594920 = validateParameter(valid_594920, JString, required = false,
                                 default = nil)
  if valid_594920 != nil:
    section.add "X-Amz-Security-Token", valid_594920
  var valid_594921 = header.getOrDefault("X-Amz-Algorithm")
  valid_594921 = validateParameter(valid_594921, JString, required = false,
                                 default = nil)
  if valid_594921 != nil:
    section.add "X-Amz-Algorithm", valid_594921
  var valid_594922 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594922 = validateParameter(valid_594922, JString, required = false,
                                 default = nil)
  if valid_594922 != nil:
    section.add "X-Amz-SignedHeaders", valid_594922
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594924: Call_UpdateSecurityProfile_594911; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a Device Defender security profile.
  ## 
  let valid = call_594924.validator(path, query, header, formData, body)
  let scheme = call_594924.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594924.url(scheme.get, call_594924.host, call_594924.base,
                         call_594924.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594924, url, valid)

proc call*(call_594925: Call_UpdateSecurityProfile_594911; body: JsonNode;
          securityProfileName: string; expectedVersion: int = 0): Recallable =
  ## updateSecurityProfile
  ## Updates a Device Defender security profile.
  ##   expectedVersion: int
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  ##   body: JObject (required)
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile you want to update.
  var path_594926 = newJObject()
  var query_594927 = newJObject()
  var body_594928 = newJObject()
  add(query_594927, "expectedVersion", newJInt(expectedVersion))
  if body != nil:
    body_594928 = body
  add(path_594926, "securityProfileName", newJString(securityProfileName))
  result = call_594925.call(path_594926, query_594927, nil, nil, body_594928)

var updateSecurityProfile* = Call_UpdateSecurityProfile_594911(
    name: "updateSecurityProfile", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_UpdateSecurityProfile_594912, base: "/",
    url: url_UpdateSecurityProfile_594913, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteSecurityProfile_594895 = ref object of OpenApiRestCall_593389
proc url_DeleteSecurityProfile_594897(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteSecurityProfile_594896(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile to be deleted.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_594898 = path.getOrDefault("securityProfileName")
  valid_594898 = validateParameter(valid_594898, JString, required = true,
                                 default = nil)
  if valid_594898 != nil:
    section.add "securityProfileName", valid_594898
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  section = newJObject()
  var valid_594899 = query.getOrDefault("expectedVersion")
  valid_594899 = validateParameter(valid_594899, JInt, required = false, default = nil)
  if valid_594899 != nil:
    section.add "expectedVersion", valid_594899
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594900 = header.getOrDefault("X-Amz-Signature")
  valid_594900 = validateParameter(valid_594900, JString, required = false,
                                 default = nil)
  if valid_594900 != nil:
    section.add "X-Amz-Signature", valid_594900
  var valid_594901 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594901 = validateParameter(valid_594901, JString, required = false,
                                 default = nil)
  if valid_594901 != nil:
    section.add "X-Amz-Content-Sha256", valid_594901
  var valid_594902 = header.getOrDefault("X-Amz-Date")
  valid_594902 = validateParameter(valid_594902, JString, required = false,
                                 default = nil)
  if valid_594902 != nil:
    section.add "X-Amz-Date", valid_594902
  var valid_594903 = header.getOrDefault("X-Amz-Credential")
  valid_594903 = validateParameter(valid_594903, JString, required = false,
                                 default = nil)
  if valid_594903 != nil:
    section.add "X-Amz-Credential", valid_594903
  var valid_594904 = header.getOrDefault("X-Amz-Security-Token")
  valid_594904 = validateParameter(valid_594904, JString, required = false,
                                 default = nil)
  if valid_594904 != nil:
    section.add "X-Amz-Security-Token", valid_594904
  var valid_594905 = header.getOrDefault("X-Amz-Algorithm")
  valid_594905 = validateParameter(valid_594905, JString, required = false,
                                 default = nil)
  if valid_594905 != nil:
    section.add "X-Amz-Algorithm", valid_594905
  var valid_594906 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594906 = validateParameter(valid_594906, JString, required = false,
                                 default = nil)
  if valid_594906 != nil:
    section.add "X-Amz-SignedHeaders", valid_594906
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594907: Call_DeleteSecurityProfile_594895; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a Device Defender security profile.
  ## 
  let valid = call_594907.validator(path, query, header, formData, body)
  let scheme = call_594907.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594907.url(scheme.get, call_594907.host, call_594907.base,
                         call_594907.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594907, url, valid)

proc call*(call_594908: Call_DeleteSecurityProfile_594895;
          securityProfileName: string; expectedVersion: int = 0): Recallable =
  ## deleteSecurityProfile
  ## Deletes a Device Defender security profile.
  ##   expectedVersion: int
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile to be deleted.
  var path_594909 = newJObject()
  var query_594910 = newJObject()
  add(query_594910, "expectedVersion", newJInt(expectedVersion))
  add(path_594909, "securityProfileName", newJString(securityProfileName))
  result = call_594908.call(path_594909, query_594910, nil, nil, nil)

var deleteSecurityProfile* = Call_DeleteSecurityProfile_594895(
    name: "deleteSecurityProfile", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_DeleteSecurityProfile_594896, base: "/",
    url: url_DeleteSecurityProfile_594897, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateStream_594943 = ref object of OpenApiRestCall_593389
proc url_UpdateStream_594945(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateStream_594944(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing stream. The stream version will be incremented by one.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_594946 = path.getOrDefault("streamId")
  valid_594946 = validateParameter(valid_594946, JString, required = true,
                                 default = nil)
  if valid_594946 != nil:
    section.add "streamId", valid_594946
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594947 = header.getOrDefault("X-Amz-Signature")
  valid_594947 = validateParameter(valid_594947, JString, required = false,
                                 default = nil)
  if valid_594947 != nil:
    section.add "X-Amz-Signature", valid_594947
  var valid_594948 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594948 = validateParameter(valid_594948, JString, required = false,
                                 default = nil)
  if valid_594948 != nil:
    section.add "X-Amz-Content-Sha256", valid_594948
  var valid_594949 = header.getOrDefault("X-Amz-Date")
  valid_594949 = validateParameter(valid_594949, JString, required = false,
                                 default = nil)
  if valid_594949 != nil:
    section.add "X-Amz-Date", valid_594949
  var valid_594950 = header.getOrDefault("X-Amz-Credential")
  valid_594950 = validateParameter(valid_594950, JString, required = false,
                                 default = nil)
  if valid_594950 != nil:
    section.add "X-Amz-Credential", valid_594950
  var valid_594951 = header.getOrDefault("X-Amz-Security-Token")
  valid_594951 = validateParameter(valid_594951, JString, required = false,
                                 default = nil)
  if valid_594951 != nil:
    section.add "X-Amz-Security-Token", valid_594951
  var valid_594952 = header.getOrDefault("X-Amz-Algorithm")
  valid_594952 = validateParameter(valid_594952, JString, required = false,
                                 default = nil)
  if valid_594952 != nil:
    section.add "X-Amz-Algorithm", valid_594952
  var valid_594953 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594953 = validateParameter(valid_594953, JString, required = false,
                                 default = nil)
  if valid_594953 != nil:
    section.add "X-Amz-SignedHeaders", valid_594953
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594955: Call_UpdateStream_594943; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing stream. The stream version will be incremented by one.
  ## 
  let valid = call_594955.validator(path, query, header, formData, body)
  let scheme = call_594955.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594955.url(scheme.get, call_594955.host, call_594955.base,
                         call_594955.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594955, url, valid)

proc call*(call_594956: Call_UpdateStream_594943; streamId: string; body: JsonNode): Recallable =
  ## updateStream
  ## Updates an existing stream. The stream version will be incremented by one.
  ##   streamId: string (required)
  ##           : The stream ID.
  ##   body: JObject (required)
  var path_594957 = newJObject()
  var body_594958 = newJObject()
  add(path_594957, "streamId", newJString(streamId))
  if body != nil:
    body_594958 = body
  result = call_594956.call(path_594957, nil, nil, nil, body_594958)

var updateStream* = Call_UpdateStream_594943(name: "updateStream",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_UpdateStream_594944,
    base: "/", url: url_UpdateStream_594945, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateStream_594959 = ref object of OpenApiRestCall_593389
proc url_CreateStream_594961(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateStream_594960(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_594962 = path.getOrDefault("streamId")
  valid_594962 = validateParameter(valid_594962, JString, required = true,
                                 default = nil)
  if valid_594962 != nil:
    section.add "streamId", valid_594962
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594963 = header.getOrDefault("X-Amz-Signature")
  valid_594963 = validateParameter(valid_594963, JString, required = false,
                                 default = nil)
  if valid_594963 != nil:
    section.add "X-Amz-Signature", valid_594963
  var valid_594964 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594964 = validateParameter(valid_594964, JString, required = false,
                                 default = nil)
  if valid_594964 != nil:
    section.add "X-Amz-Content-Sha256", valid_594964
  var valid_594965 = header.getOrDefault("X-Amz-Date")
  valid_594965 = validateParameter(valid_594965, JString, required = false,
                                 default = nil)
  if valid_594965 != nil:
    section.add "X-Amz-Date", valid_594965
  var valid_594966 = header.getOrDefault("X-Amz-Credential")
  valid_594966 = validateParameter(valid_594966, JString, required = false,
                                 default = nil)
  if valid_594966 != nil:
    section.add "X-Amz-Credential", valid_594966
  var valid_594967 = header.getOrDefault("X-Amz-Security-Token")
  valid_594967 = validateParameter(valid_594967, JString, required = false,
                                 default = nil)
  if valid_594967 != nil:
    section.add "X-Amz-Security-Token", valid_594967
  var valid_594968 = header.getOrDefault("X-Amz-Algorithm")
  valid_594968 = validateParameter(valid_594968, JString, required = false,
                                 default = nil)
  if valid_594968 != nil:
    section.add "X-Amz-Algorithm", valid_594968
  var valid_594969 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594969 = validateParameter(valid_594969, JString, required = false,
                                 default = nil)
  if valid_594969 != nil:
    section.add "X-Amz-SignedHeaders", valid_594969
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594971: Call_CreateStream_594959; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.
  ## 
  let valid = call_594971.validator(path, query, header, formData, body)
  let scheme = call_594971.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594971.url(scheme.get, call_594971.host, call_594971.base,
                         call_594971.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594971, url, valid)

proc call*(call_594972: Call_CreateStream_594959; streamId: string; body: JsonNode): Recallable =
  ## createStream
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  ##   body: JObject (required)
  var path_594973 = newJObject()
  var body_594974 = newJObject()
  add(path_594973, "streamId", newJString(streamId))
  if body != nil:
    body_594974 = body
  result = call_594972.call(path_594973, nil, nil, nil, body_594974)

var createStream* = Call_CreateStream_594959(name: "createStream",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_CreateStream_594960,
    base: "/", url: url_CreateStream_594961, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeStream_594929 = ref object of OpenApiRestCall_593389
proc url_DescribeStream_594931(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeStream_594930(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets information about a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_594932 = path.getOrDefault("streamId")
  valid_594932 = validateParameter(valid_594932, JString, required = true,
                                 default = nil)
  if valid_594932 != nil:
    section.add "streamId", valid_594932
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594933 = header.getOrDefault("X-Amz-Signature")
  valid_594933 = validateParameter(valid_594933, JString, required = false,
                                 default = nil)
  if valid_594933 != nil:
    section.add "X-Amz-Signature", valid_594933
  var valid_594934 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594934 = validateParameter(valid_594934, JString, required = false,
                                 default = nil)
  if valid_594934 != nil:
    section.add "X-Amz-Content-Sha256", valid_594934
  var valid_594935 = header.getOrDefault("X-Amz-Date")
  valid_594935 = validateParameter(valid_594935, JString, required = false,
                                 default = nil)
  if valid_594935 != nil:
    section.add "X-Amz-Date", valid_594935
  var valid_594936 = header.getOrDefault("X-Amz-Credential")
  valid_594936 = validateParameter(valid_594936, JString, required = false,
                                 default = nil)
  if valid_594936 != nil:
    section.add "X-Amz-Credential", valid_594936
  var valid_594937 = header.getOrDefault("X-Amz-Security-Token")
  valid_594937 = validateParameter(valid_594937, JString, required = false,
                                 default = nil)
  if valid_594937 != nil:
    section.add "X-Amz-Security-Token", valid_594937
  var valid_594938 = header.getOrDefault("X-Amz-Algorithm")
  valid_594938 = validateParameter(valid_594938, JString, required = false,
                                 default = nil)
  if valid_594938 != nil:
    section.add "X-Amz-Algorithm", valid_594938
  var valid_594939 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594939 = validateParameter(valid_594939, JString, required = false,
                                 default = nil)
  if valid_594939 != nil:
    section.add "X-Amz-SignedHeaders", valid_594939
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594940: Call_DescribeStream_594929; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a stream.
  ## 
  let valid = call_594940.validator(path, query, header, formData, body)
  let scheme = call_594940.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594940.url(scheme.get, call_594940.host, call_594940.base,
                         call_594940.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594940, url, valid)

proc call*(call_594941: Call_DescribeStream_594929; streamId: string): Recallable =
  ## describeStream
  ## Gets information about a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_594942 = newJObject()
  add(path_594942, "streamId", newJString(streamId))
  result = call_594941.call(path_594942, nil, nil, nil, nil)

var describeStream* = Call_DescribeStream_594929(name: "describeStream",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_DescribeStream_594930,
    base: "/", url: url_DescribeStream_594931, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteStream_594975 = ref object of OpenApiRestCall_593389
proc url_DeleteStream_594977(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteStream_594976(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_594978 = path.getOrDefault("streamId")
  valid_594978 = validateParameter(valid_594978, JString, required = true,
                                 default = nil)
  if valid_594978 != nil:
    section.add "streamId", valid_594978
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594979 = header.getOrDefault("X-Amz-Signature")
  valid_594979 = validateParameter(valid_594979, JString, required = false,
                                 default = nil)
  if valid_594979 != nil:
    section.add "X-Amz-Signature", valid_594979
  var valid_594980 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594980 = validateParameter(valid_594980, JString, required = false,
                                 default = nil)
  if valid_594980 != nil:
    section.add "X-Amz-Content-Sha256", valid_594980
  var valid_594981 = header.getOrDefault("X-Amz-Date")
  valid_594981 = validateParameter(valid_594981, JString, required = false,
                                 default = nil)
  if valid_594981 != nil:
    section.add "X-Amz-Date", valid_594981
  var valid_594982 = header.getOrDefault("X-Amz-Credential")
  valid_594982 = validateParameter(valid_594982, JString, required = false,
                                 default = nil)
  if valid_594982 != nil:
    section.add "X-Amz-Credential", valid_594982
  var valid_594983 = header.getOrDefault("X-Amz-Security-Token")
  valid_594983 = validateParameter(valid_594983, JString, required = false,
                                 default = nil)
  if valid_594983 != nil:
    section.add "X-Amz-Security-Token", valid_594983
  var valid_594984 = header.getOrDefault("X-Amz-Algorithm")
  valid_594984 = validateParameter(valid_594984, JString, required = false,
                                 default = nil)
  if valid_594984 != nil:
    section.add "X-Amz-Algorithm", valid_594984
  var valid_594985 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594985 = validateParameter(valid_594985, JString, required = false,
                                 default = nil)
  if valid_594985 != nil:
    section.add "X-Amz-SignedHeaders", valid_594985
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594986: Call_DeleteStream_594975; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a stream.
  ## 
  let valid = call_594986.validator(path, query, header, formData, body)
  let scheme = call_594986.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594986.url(scheme.get, call_594986.host, call_594986.base,
                         call_594986.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594986, url, valid)

proc call*(call_594987: Call_DeleteStream_594975; streamId: string): Recallable =
  ## deleteStream
  ## Deletes a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_594988 = newJObject()
  add(path_594988, "streamId", newJString(streamId))
  result = call_594987.call(path_594988, nil, nil, nil, nil)

var deleteStream* = Call_DeleteStream_594975(name: "deleteStream",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_DeleteStream_594976,
    base: "/", url: url_DeleteStream_594977, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThing_595003 = ref object of OpenApiRestCall_593389
proc url_CreateThing_595005(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateThing_595004(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to create.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_595006 = path.getOrDefault("thingName")
  valid_595006 = validateParameter(valid_595006, JString, required = true,
                                 default = nil)
  if valid_595006 != nil:
    section.add "thingName", valid_595006
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595007 = header.getOrDefault("X-Amz-Signature")
  valid_595007 = validateParameter(valid_595007, JString, required = false,
                                 default = nil)
  if valid_595007 != nil:
    section.add "X-Amz-Signature", valid_595007
  var valid_595008 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595008 = validateParameter(valid_595008, JString, required = false,
                                 default = nil)
  if valid_595008 != nil:
    section.add "X-Amz-Content-Sha256", valid_595008
  var valid_595009 = header.getOrDefault("X-Amz-Date")
  valid_595009 = validateParameter(valid_595009, JString, required = false,
                                 default = nil)
  if valid_595009 != nil:
    section.add "X-Amz-Date", valid_595009
  var valid_595010 = header.getOrDefault("X-Amz-Credential")
  valid_595010 = validateParameter(valid_595010, JString, required = false,
                                 default = nil)
  if valid_595010 != nil:
    section.add "X-Amz-Credential", valid_595010
  var valid_595011 = header.getOrDefault("X-Amz-Security-Token")
  valid_595011 = validateParameter(valid_595011, JString, required = false,
                                 default = nil)
  if valid_595011 != nil:
    section.add "X-Amz-Security-Token", valid_595011
  var valid_595012 = header.getOrDefault("X-Amz-Algorithm")
  valid_595012 = validateParameter(valid_595012, JString, required = false,
                                 default = nil)
  if valid_595012 != nil:
    section.add "X-Amz-Algorithm", valid_595012
  var valid_595013 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595013 = validateParameter(valid_595013, JString, required = false,
                                 default = nil)
  if valid_595013 != nil:
    section.add "X-Amz-SignedHeaders", valid_595013
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595015: Call_CreateThing_595003; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  let valid = call_595015.validator(path, query, header, formData, body)
  let scheme = call_595015.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595015.url(scheme.get, call_595015.host, call_595015.base,
                         call_595015.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595015, url, valid)

proc call*(call_595016: Call_CreateThing_595003; thingName: string; body: JsonNode): Recallable =
  ## createThing
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing to create.
  ##   body: JObject (required)
  var path_595017 = newJObject()
  var body_595018 = newJObject()
  add(path_595017, "thingName", newJString(thingName))
  if body != nil:
    body_595018 = body
  result = call_595016.call(path_595017, nil, nil, nil, body_595018)

var createThing* = Call_CreateThing_595003(name: "createThing",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_CreateThing_595004,
                                        base: "/", url: url_CreateThing_595005,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThing_594989 = ref object of OpenApiRestCall_593389
proc url_DescribeThing_594991(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThing_594990(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the specified thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_594992 = path.getOrDefault("thingName")
  valid_594992 = validateParameter(valid_594992, JString, required = true,
                                 default = nil)
  if valid_594992 != nil:
    section.add "thingName", valid_594992
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594993 = header.getOrDefault("X-Amz-Signature")
  valid_594993 = validateParameter(valid_594993, JString, required = false,
                                 default = nil)
  if valid_594993 != nil:
    section.add "X-Amz-Signature", valid_594993
  var valid_594994 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594994 = validateParameter(valid_594994, JString, required = false,
                                 default = nil)
  if valid_594994 != nil:
    section.add "X-Amz-Content-Sha256", valid_594994
  var valid_594995 = header.getOrDefault("X-Amz-Date")
  valid_594995 = validateParameter(valid_594995, JString, required = false,
                                 default = nil)
  if valid_594995 != nil:
    section.add "X-Amz-Date", valid_594995
  var valid_594996 = header.getOrDefault("X-Amz-Credential")
  valid_594996 = validateParameter(valid_594996, JString, required = false,
                                 default = nil)
  if valid_594996 != nil:
    section.add "X-Amz-Credential", valid_594996
  var valid_594997 = header.getOrDefault("X-Amz-Security-Token")
  valid_594997 = validateParameter(valid_594997, JString, required = false,
                                 default = nil)
  if valid_594997 != nil:
    section.add "X-Amz-Security-Token", valid_594997
  var valid_594998 = header.getOrDefault("X-Amz-Algorithm")
  valid_594998 = validateParameter(valid_594998, JString, required = false,
                                 default = nil)
  if valid_594998 != nil:
    section.add "X-Amz-Algorithm", valid_594998
  var valid_594999 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594999 = validateParameter(valid_594999, JString, required = false,
                                 default = nil)
  if valid_594999 != nil:
    section.add "X-Amz-SignedHeaders", valid_594999
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595000: Call_DescribeThing_594989; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified thing.
  ## 
  let valid = call_595000.validator(path, query, header, formData, body)
  let scheme = call_595000.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595000.url(scheme.get, call_595000.host, call_595000.base,
                         call_595000.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595000, url, valid)

proc call*(call_595001: Call_DescribeThing_594989; thingName: string): Recallable =
  ## describeThing
  ## Gets information about the specified thing.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_595002 = newJObject()
  add(path_595002, "thingName", newJString(thingName))
  result = call_595001.call(path_595002, nil, nil, nil, nil)

var describeThing* = Call_DescribeThing_594989(name: "describeThing",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/things/{thingName}", validator: validate_DescribeThing_594990,
    base: "/", url: url_DescribeThing_594991, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThing_595035 = ref object of OpenApiRestCall_593389
proc url_UpdateThing_595037(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateThing_595036(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the data for a thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_595038 = path.getOrDefault("thingName")
  valid_595038 = validateParameter(valid_595038, JString, required = true,
                                 default = nil)
  if valid_595038 != nil:
    section.add "thingName", valid_595038
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595039 = header.getOrDefault("X-Amz-Signature")
  valid_595039 = validateParameter(valid_595039, JString, required = false,
                                 default = nil)
  if valid_595039 != nil:
    section.add "X-Amz-Signature", valid_595039
  var valid_595040 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595040 = validateParameter(valid_595040, JString, required = false,
                                 default = nil)
  if valid_595040 != nil:
    section.add "X-Amz-Content-Sha256", valid_595040
  var valid_595041 = header.getOrDefault("X-Amz-Date")
  valid_595041 = validateParameter(valid_595041, JString, required = false,
                                 default = nil)
  if valid_595041 != nil:
    section.add "X-Amz-Date", valid_595041
  var valid_595042 = header.getOrDefault("X-Amz-Credential")
  valid_595042 = validateParameter(valid_595042, JString, required = false,
                                 default = nil)
  if valid_595042 != nil:
    section.add "X-Amz-Credential", valid_595042
  var valid_595043 = header.getOrDefault("X-Amz-Security-Token")
  valid_595043 = validateParameter(valid_595043, JString, required = false,
                                 default = nil)
  if valid_595043 != nil:
    section.add "X-Amz-Security-Token", valid_595043
  var valid_595044 = header.getOrDefault("X-Amz-Algorithm")
  valid_595044 = validateParameter(valid_595044, JString, required = false,
                                 default = nil)
  if valid_595044 != nil:
    section.add "X-Amz-Algorithm", valid_595044
  var valid_595045 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595045 = validateParameter(valid_595045, JString, required = false,
                                 default = nil)
  if valid_595045 != nil:
    section.add "X-Amz-SignedHeaders", valid_595045
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595047: Call_UpdateThing_595035; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the data for a thing.
  ## 
  let valid = call_595047.validator(path, query, header, formData, body)
  let scheme = call_595047.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595047.url(scheme.get, call_595047.host, call_595047.base,
                         call_595047.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595047, url, valid)

proc call*(call_595048: Call_UpdateThing_595035; thingName: string; body: JsonNode): Recallable =
  ## updateThing
  ## Updates the data for a thing.
  ##   thingName: string (required)
  ##            : The name of the thing to update.
  ##   body: JObject (required)
  var path_595049 = newJObject()
  var body_595050 = newJObject()
  add(path_595049, "thingName", newJString(thingName))
  if body != nil:
    body_595050 = body
  result = call_595048.call(path_595049, nil, nil, nil, body_595050)

var updateThing* = Call_UpdateThing_595035(name: "updateThing",
                                        meth: HttpMethod.HttpPatch,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_UpdateThing_595036,
                                        base: "/", url: url_UpdateThing_595037,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThing_595019 = ref object of OpenApiRestCall_593389
proc url_DeleteThing_595021(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteThing_595020(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_595022 = path.getOrDefault("thingName")
  valid_595022 = validateParameter(valid_595022, JString, required = true,
                                 default = nil)
  if valid_595022 != nil:
    section.add "thingName", valid_595022
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.
  section = newJObject()
  var valid_595023 = query.getOrDefault("expectedVersion")
  valid_595023 = validateParameter(valid_595023, JInt, required = false, default = nil)
  if valid_595023 != nil:
    section.add "expectedVersion", valid_595023
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595024 = header.getOrDefault("X-Amz-Signature")
  valid_595024 = validateParameter(valid_595024, JString, required = false,
                                 default = nil)
  if valid_595024 != nil:
    section.add "X-Amz-Signature", valid_595024
  var valid_595025 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595025 = validateParameter(valid_595025, JString, required = false,
                                 default = nil)
  if valid_595025 != nil:
    section.add "X-Amz-Content-Sha256", valid_595025
  var valid_595026 = header.getOrDefault("X-Amz-Date")
  valid_595026 = validateParameter(valid_595026, JString, required = false,
                                 default = nil)
  if valid_595026 != nil:
    section.add "X-Amz-Date", valid_595026
  var valid_595027 = header.getOrDefault("X-Amz-Credential")
  valid_595027 = validateParameter(valid_595027, JString, required = false,
                                 default = nil)
  if valid_595027 != nil:
    section.add "X-Amz-Credential", valid_595027
  var valid_595028 = header.getOrDefault("X-Amz-Security-Token")
  valid_595028 = validateParameter(valid_595028, JString, required = false,
                                 default = nil)
  if valid_595028 != nil:
    section.add "X-Amz-Security-Token", valid_595028
  var valid_595029 = header.getOrDefault("X-Amz-Algorithm")
  valid_595029 = validateParameter(valid_595029, JString, required = false,
                                 default = nil)
  if valid_595029 != nil:
    section.add "X-Amz-Algorithm", valid_595029
  var valid_595030 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595030 = validateParameter(valid_595030, JString, required = false,
                                 default = nil)
  if valid_595030 != nil:
    section.add "X-Amz-SignedHeaders", valid_595030
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595031: Call_DeleteThing_595019; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ## 
  let valid = call_595031.validator(path, query, header, formData, body)
  let scheme = call_595031.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595031.url(scheme.get, call_595031.host, call_595031.base,
                         call_595031.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595031, url, valid)

proc call*(call_595032: Call_DeleteThing_595019; thingName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteThing
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ##   expectedVersion: int
  ##                  : The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.
  ##   thingName: string (required)
  ##            : The name of the thing to delete.
  var path_595033 = newJObject()
  var query_595034 = newJObject()
  add(query_595034, "expectedVersion", newJInt(expectedVersion))
  add(path_595033, "thingName", newJString(thingName))
  result = call_595032.call(path_595033, query_595034, nil, nil, nil)

var deleteThing* = Call_DeleteThing_595019(name: "deleteThing",
                                        meth: HttpMethod.HttpDelete,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_DeleteThing_595020,
                                        base: "/", url: url_DeleteThing_595021,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThingGroup_595065 = ref object of OpenApiRestCall_593389
proc url_CreateThingGroup_595067(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateThingGroup_595066(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group name to create.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_595068 = path.getOrDefault("thingGroupName")
  valid_595068 = validateParameter(valid_595068, JString, required = true,
                                 default = nil)
  if valid_595068 != nil:
    section.add "thingGroupName", valid_595068
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595069 = header.getOrDefault("X-Amz-Signature")
  valid_595069 = validateParameter(valid_595069, JString, required = false,
                                 default = nil)
  if valid_595069 != nil:
    section.add "X-Amz-Signature", valid_595069
  var valid_595070 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595070 = validateParameter(valid_595070, JString, required = false,
                                 default = nil)
  if valid_595070 != nil:
    section.add "X-Amz-Content-Sha256", valid_595070
  var valid_595071 = header.getOrDefault("X-Amz-Date")
  valid_595071 = validateParameter(valid_595071, JString, required = false,
                                 default = nil)
  if valid_595071 != nil:
    section.add "X-Amz-Date", valid_595071
  var valid_595072 = header.getOrDefault("X-Amz-Credential")
  valid_595072 = validateParameter(valid_595072, JString, required = false,
                                 default = nil)
  if valid_595072 != nil:
    section.add "X-Amz-Credential", valid_595072
  var valid_595073 = header.getOrDefault("X-Amz-Security-Token")
  valid_595073 = validateParameter(valid_595073, JString, required = false,
                                 default = nil)
  if valid_595073 != nil:
    section.add "X-Amz-Security-Token", valid_595073
  var valid_595074 = header.getOrDefault("X-Amz-Algorithm")
  valid_595074 = validateParameter(valid_595074, JString, required = false,
                                 default = nil)
  if valid_595074 != nil:
    section.add "X-Amz-Algorithm", valid_595074
  var valid_595075 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595075 = validateParameter(valid_595075, JString, required = false,
                                 default = nil)
  if valid_595075 != nil:
    section.add "X-Amz-SignedHeaders", valid_595075
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595077: Call_CreateThingGroup_595065; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  let valid = call_595077.validator(path, query, header, formData, body)
  let scheme = call_595077.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595077.url(scheme.get, call_595077.host, call_595077.base,
                         call_595077.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595077, url, valid)

proc call*(call_595078: Call_CreateThingGroup_595065; thingGroupName: string;
          body: JsonNode): Recallable =
  ## createThingGroup
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ##   thingGroupName: string (required)
  ##                 : The thing group name to create.
  ##   body: JObject (required)
  var path_595079 = newJObject()
  var body_595080 = newJObject()
  add(path_595079, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_595080 = body
  result = call_595078.call(path_595079, nil, nil, nil, body_595080)

var createThingGroup* = Call_CreateThingGroup_595065(name: "createThingGroup",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_CreateThingGroup_595066,
    base: "/", url: url_CreateThingGroup_595067,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingGroup_595051 = ref object of OpenApiRestCall_593389
proc url_DescribeThingGroup_595053(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThingGroup_595052(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Describe a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the thing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_595054 = path.getOrDefault("thingGroupName")
  valid_595054 = validateParameter(valid_595054, JString, required = true,
                                 default = nil)
  if valid_595054 != nil:
    section.add "thingGroupName", valid_595054
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595055 = header.getOrDefault("X-Amz-Signature")
  valid_595055 = validateParameter(valid_595055, JString, required = false,
                                 default = nil)
  if valid_595055 != nil:
    section.add "X-Amz-Signature", valid_595055
  var valid_595056 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595056 = validateParameter(valid_595056, JString, required = false,
                                 default = nil)
  if valid_595056 != nil:
    section.add "X-Amz-Content-Sha256", valid_595056
  var valid_595057 = header.getOrDefault("X-Amz-Date")
  valid_595057 = validateParameter(valid_595057, JString, required = false,
                                 default = nil)
  if valid_595057 != nil:
    section.add "X-Amz-Date", valid_595057
  var valid_595058 = header.getOrDefault("X-Amz-Credential")
  valid_595058 = validateParameter(valid_595058, JString, required = false,
                                 default = nil)
  if valid_595058 != nil:
    section.add "X-Amz-Credential", valid_595058
  var valid_595059 = header.getOrDefault("X-Amz-Security-Token")
  valid_595059 = validateParameter(valid_595059, JString, required = false,
                                 default = nil)
  if valid_595059 != nil:
    section.add "X-Amz-Security-Token", valid_595059
  var valid_595060 = header.getOrDefault("X-Amz-Algorithm")
  valid_595060 = validateParameter(valid_595060, JString, required = false,
                                 default = nil)
  if valid_595060 != nil:
    section.add "X-Amz-Algorithm", valid_595060
  var valid_595061 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595061 = validateParameter(valid_595061, JString, required = false,
                                 default = nil)
  if valid_595061 != nil:
    section.add "X-Amz-SignedHeaders", valid_595061
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595062: Call_DescribeThingGroup_595051; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describe a thing group.
  ## 
  let valid = call_595062.validator(path, query, header, formData, body)
  let scheme = call_595062.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595062.url(scheme.get, call_595062.host, call_595062.base,
                         call_595062.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595062, url, valid)

proc call*(call_595063: Call_DescribeThingGroup_595051; thingGroupName: string): Recallable =
  ## describeThingGroup
  ## Describe a thing group.
  ##   thingGroupName: string (required)
  ##                 : The name of the thing group.
  var path_595064 = newJObject()
  add(path_595064, "thingGroupName", newJString(thingGroupName))
  result = call_595063.call(path_595064, nil, nil, nil, nil)

var describeThingGroup* = Call_DescribeThingGroup_595051(
    name: "describeThingGroup", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}",
    validator: validate_DescribeThingGroup_595052, base: "/",
    url: url_DescribeThingGroup_595053, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThingGroup_595097 = ref object of OpenApiRestCall_593389
proc url_UpdateThingGroup_595099(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateThingGroup_595098(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Update a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group to update.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_595100 = path.getOrDefault("thingGroupName")
  valid_595100 = validateParameter(valid_595100, JString, required = true,
                                 default = nil)
  if valid_595100 != nil:
    section.add "thingGroupName", valid_595100
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595101 = header.getOrDefault("X-Amz-Signature")
  valid_595101 = validateParameter(valid_595101, JString, required = false,
                                 default = nil)
  if valid_595101 != nil:
    section.add "X-Amz-Signature", valid_595101
  var valid_595102 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595102 = validateParameter(valid_595102, JString, required = false,
                                 default = nil)
  if valid_595102 != nil:
    section.add "X-Amz-Content-Sha256", valid_595102
  var valid_595103 = header.getOrDefault("X-Amz-Date")
  valid_595103 = validateParameter(valid_595103, JString, required = false,
                                 default = nil)
  if valid_595103 != nil:
    section.add "X-Amz-Date", valid_595103
  var valid_595104 = header.getOrDefault("X-Amz-Credential")
  valid_595104 = validateParameter(valid_595104, JString, required = false,
                                 default = nil)
  if valid_595104 != nil:
    section.add "X-Amz-Credential", valid_595104
  var valid_595105 = header.getOrDefault("X-Amz-Security-Token")
  valid_595105 = validateParameter(valid_595105, JString, required = false,
                                 default = nil)
  if valid_595105 != nil:
    section.add "X-Amz-Security-Token", valid_595105
  var valid_595106 = header.getOrDefault("X-Amz-Algorithm")
  valid_595106 = validateParameter(valid_595106, JString, required = false,
                                 default = nil)
  if valid_595106 != nil:
    section.add "X-Amz-Algorithm", valid_595106
  var valid_595107 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595107 = validateParameter(valid_595107, JString, required = false,
                                 default = nil)
  if valid_595107 != nil:
    section.add "X-Amz-SignedHeaders", valid_595107
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595109: Call_UpdateThingGroup_595097; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update a thing group.
  ## 
  let valid = call_595109.validator(path, query, header, formData, body)
  let scheme = call_595109.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595109.url(scheme.get, call_595109.host, call_595109.base,
                         call_595109.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595109, url, valid)

proc call*(call_595110: Call_UpdateThingGroup_595097; thingGroupName: string;
          body: JsonNode): Recallable =
  ## updateThingGroup
  ## Update a thing group.
  ##   thingGroupName: string (required)
  ##                 : The thing group to update.
  ##   body: JObject (required)
  var path_595111 = newJObject()
  var body_595112 = newJObject()
  add(path_595111, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_595112 = body
  result = call_595110.call(path_595111, nil, nil, nil, body_595112)

var updateThingGroup* = Call_UpdateThingGroup_595097(name: "updateThingGroup",
    meth: HttpMethod.HttpPatch, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_UpdateThingGroup_595098,
    base: "/", url: url_UpdateThingGroup_595099,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThingGroup_595081 = ref object of OpenApiRestCall_593389
proc url_DeleteThingGroup_595083(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteThingGroup_595082(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Deletes a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the thing group to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_595084 = path.getOrDefault("thingGroupName")
  valid_595084 = validateParameter(valid_595084, JString, required = true,
                                 default = nil)
  if valid_595084 != nil:
    section.add "thingGroupName", valid_595084
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the thing group to delete.
  section = newJObject()
  var valid_595085 = query.getOrDefault("expectedVersion")
  valid_595085 = validateParameter(valid_595085, JInt, required = false, default = nil)
  if valid_595085 != nil:
    section.add "expectedVersion", valid_595085
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595086 = header.getOrDefault("X-Amz-Signature")
  valid_595086 = validateParameter(valid_595086, JString, required = false,
                                 default = nil)
  if valid_595086 != nil:
    section.add "X-Amz-Signature", valid_595086
  var valid_595087 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595087 = validateParameter(valid_595087, JString, required = false,
                                 default = nil)
  if valid_595087 != nil:
    section.add "X-Amz-Content-Sha256", valid_595087
  var valid_595088 = header.getOrDefault("X-Amz-Date")
  valid_595088 = validateParameter(valid_595088, JString, required = false,
                                 default = nil)
  if valid_595088 != nil:
    section.add "X-Amz-Date", valid_595088
  var valid_595089 = header.getOrDefault("X-Amz-Credential")
  valid_595089 = validateParameter(valid_595089, JString, required = false,
                                 default = nil)
  if valid_595089 != nil:
    section.add "X-Amz-Credential", valid_595089
  var valid_595090 = header.getOrDefault("X-Amz-Security-Token")
  valid_595090 = validateParameter(valid_595090, JString, required = false,
                                 default = nil)
  if valid_595090 != nil:
    section.add "X-Amz-Security-Token", valid_595090
  var valid_595091 = header.getOrDefault("X-Amz-Algorithm")
  valid_595091 = validateParameter(valid_595091, JString, required = false,
                                 default = nil)
  if valid_595091 != nil:
    section.add "X-Amz-Algorithm", valid_595091
  var valid_595092 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595092 = validateParameter(valid_595092, JString, required = false,
                                 default = nil)
  if valid_595092 != nil:
    section.add "X-Amz-SignedHeaders", valid_595092
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595093: Call_DeleteThingGroup_595081; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a thing group.
  ## 
  let valid = call_595093.validator(path, query, header, formData, body)
  let scheme = call_595093.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595093.url(scheme.get, call_595093.host, call_595093.base,
                         call_595093.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595093, url, valid)

proc call*(call_595094: Call_DeleteThingGroup_595081; thingGroupName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteThingGroup
  ## Deletes a thing group.
  ##   expectedVersion: int
  ##                  : The expected version of the thing group to delete.
  ##   thingGroupName: string (required)
  ##                 : The name of the thing group to delete.
  var path_595095 = newJObject()
  var query_595096 = newJObject()
  add(query_595096, "expectedVersion", newJInt(expectedVersion))
  add(path_595095, "thingGroupName", newJString(thingGroupName))
  result = call_595094.call(path_595095, query_595096, nil, nil, nil)

var deleteThingGroup* = Call_DeleteThingGroup_595081(name: "deleteThingGroup",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_DeleteThingGroup_595082,
    base: "/", url: url_DeleteThingGroup_595083,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThingType_595127 = ref object of OpenApiRestCall_593389
proc url_CreateThingType_595129(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateThingType_595128(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a new thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_595130 = path.getOrDefault("thingTypeName")
  valid_595130 = validateParameter(valid_595130, JString, required = true,
                                 default = nil)
  if valid_595130 != nil:
    section.add "thingTypeName", valid_595130
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595131 = header.getOrDefault("X-Amz-Signature")
  valid_595131 = validateParameter(valid_595131, JString, required = false,
                                 default = nil)
  if valid_595131 != nil:
    section.add "X-Amz-Signature", valid_595131
  var valid_595132 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595132 = validateParameter(valid_595132, JString, required = false,
                                 default = nil)
  if valid_595132 != nil:
    section.add "X-Amz-Content-Sha256", valid_595132
  var valid_595133 = header.getOrDefault("X-Amz-Date")
  valid_595133 = validateParameter(valid_595133, JString, required = false,
                                 default = nil)
  if valid_595133 != nil:
    section.add "X-Amz-Date", valid_595133
  var valid_595134 = header.getOrDefault("X-Amz-Credential")
  valid_595134 = validateParameter(valid_595134, JString, required = false,
                                 default = nil)
  if valid_595134 != nil:
    section.add "X-Amz-Credential", valid_595134
  var valid_595135 = header.getOrDefault("X-Amz-Security-Token")
  valid_595135 = validateParameter(valid_595135, JString, required = false,
                                 default = nil)
  if valid_595135 != nil:
    section.add "X-Amz-Security-Token", valid_595135
  var valid_595136 = header.getOrDefault("X-Amz-Algorithm")
  valid_595136 = validateParameter(valid_595136, JString, required = false,
                                 default = nil)
  if valid_595136 != nil:
    section.add "X-Amz-Algorithm", valid_595136
  var valid_595137 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595137 = validateParameter(valid_595137, JString, required = false,
                                 default = nil)
  if valid_595137 != nil:
    section.add "X-Amz-SignedHeaders", valid_595137
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595139: Call_CreateThingType_595127; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new thing type.
  ## 
  let valid = call_595139.validator(path, query, header, formData, body)
  let scheme = call_595139.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595139.url(scheme.get, call_595139.host, call_595139.base,
                         call_595139.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595139, url, valid)

proc call*(call_595140: Call_CreateThingType_595127; thingTypeName: string;
          body: JsonNode): Recallable =
  ## createThingType
  ## Creates a new thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  ##   body: JObject (required)
  var path_595141 = newJObject()
  var body_595142 = newJObject()
  add(path_595141, "thingTypeName", newJString(thingTypeName))
  if body != nil:
    body_595142 = body
  result = call_595140.call(path_595141, nil, nil, nil, body_595142)

var createThingType* = Call_CreateThingType_595127(name: "createThingType",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_CreateThingType_595128,
    base: "/", url: url_CreateThingType_595129, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingType_595113 = ref object of OpenApiRestCall_593389
proc url_DescribeThingType_595115(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThingType_595114(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Gets information about the specified thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_595116 = path.getOrDefault("thingTypeName")
  valid_595116 = validateParameter(valid_595116, JString, required = true,
                                 default = nil)
  if valid_595116 != nil:
    section.add "thingTypeName", valid_595116
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595117 = header.getOrDefault("X-Amz-Signature")
  valid_595117 = validateParameter(valid_595117, JString, required = false,
                                 default = nil)
  if valid_595117 != nil:
    section.add "X-Amz-Signature", valid_595117
  var valid_595118 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595118 = validateParameter(valid_595118, JString, required = false,
                                 default = nil)
  if valid_595118 != nil:
    section.add "X-Amz-Content-Sha256", valid_595118
  var valid_595119 = header.getOrDefault("X-Amz-Date")
  valid_595119 = validateParameter(valid_595119, JString, required = false,
                                 default = nil)
  if valid_595119 != nil:
    section.add "X-Amz-Date", valid_595119
  var valid_595120 = header.getOrDefault("X-Amz-Credential")
  valid_595120 = validateParameter(valid_595120, JString, required = false,
                                 default = nil)
  if valid_595120 != nil:
    section.add "X-Amz-Credential", valid_595120
  var valid_595121 = header.getOrDefault("X-Amz-Security-Token")
  valid_595121 = validateParameter(valid_595121, JString, required = false,
                                 default = nil)
  if valid_595121 != nil:
    section.add "X-Amz-Security-Token", valid_595121
  var valid_595122 = header.getOrDefault("X-Amz-Algorithm")
  valid_595122 = validateParameter(valid_595122, JString, required = false,
                                 default = nil)
  if valid_595122 != nil:
    section.add "X-Amz-Algorithm", valid_595122
  var valid_595123 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595123 = validateParameter(valid_595123, JString, required = false,
                                 default = nil)
  if valid_595123 != nil:
    section.add "X-Amz-SignedHeaders", valid_595123
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595124: Call_DescribeThingType_595113; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified thing type.
  ## 
  let valid = call_595124.validator(path, query, header, formData, body)
  let scheme = call_595124.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595124.url(scheme.get, call_595124.host, call_595124.base,
                         call_595124.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595124, url, valid)

proc call*(call_595125: Call_DescribeThingType_595113; thingTypeName: string): Recallable =
  ## describeThingType
  ## Gets information about the specified thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_595126 = newJObject()
  add(path_595126, "thingTypeName", newJString(thingTypeName))
  result = call_595125.call(path_595126, nil, nil, nil, nil)

var describeThingType* = Call_DescribeThingType_595113(name: "describeThingType",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_DescribeThingType_595114,
    base: "/", url: url_DescribeThingType_595115,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThingType_595143 = ref object of OpenApiRestCall_593389
proc url_DeleteThingType_595145(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteThingType_595144(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_595146 = path.getOrDefault("thingTypeName")
  valid_595146 = validateParameter(valid_595146, JString, required = true,
                                 default = nil)
  if valid_595146 != nil:
    section.add "thingTypeName", valid_595146
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595147 = header.getOrDefault("X-Amz-Signature")
  valid_595147 = validateParameter(valid_595147, JString, required = false,
                                 default = nil)
  if valid_595147 != nil:
    section.add "X-Amz-Signature", valid_595147
  var valid_595148 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595148 = validateParameter(valid_595148, JString, required = false,
                                 default = nil)
  if valid_595148 != nil:
    section.add "X-Amz-Content-Sha256", valid_595148
  var valid_595149 = header.getOrDefault("X-Amz-Date")
  valid_595149 = validateParameter(valid_595149, JString, required = false,
                                 default = nil)
  if valid_595149 != nil:
    section.add "X-Amz-Date", valid_595149
  var valid_595150 = header.getOrDefault("X-Amz-Credential")
  valid_595150 = validateParameter(valid_595150, JString, required = false,
                                 default = nil)
  if valid_595150 != nil:
    section.add "X-Amz-Credential", valid_595150
  var valid_595151 = header.getOrDefault("X-Amz-Security-Token")
  valid_595151 = validateParameter(valid_595151, JString, required = false,
                                 default = nil)
  if valid_595151 != nil:
    section.add "X-Amz-Security-Token", valid_595151
  var valid_595152 = header.getOrDefault("X-Amz-Algorithm")
  valid_595152 = validateParameter(valid_595152, JString, required = false,
                                 default = nil)
  if valid_595152 != nil:
    section.add "X-Amz-Algorithm", valid_595152
  var valid_595153 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595153 = validateParameter(valid_595153, JString, required = false,
                                 default = nil)
  if valid_595153 != nil:
    section.add "X-Amz-SignedHeaders", valid_595153
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595154: Call_DeleteThingType_595143; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ## 
  let valid = call_595154.validator(path, query, header, formData, body)
  let scheme = call_595154.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595154.url(scheme.get, call_595154.host, call_595154.base,
                         call_595154.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595154, url, valid)

proc call*(call_595155: Call_DeleteThingType_595143; thingTypeName: string): Recallable =
  ## deleteThingType
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_595156 = newJObject()
  add(path_595156, "thingTypeName", newJString(thingTypeName))
  result = call_595155.call(path_595156, nil, nil, nil, nil)

var deleteThingType* = Call_DeleteThingType_595143(name: "deleteThingType",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_DeleteThingType_595144,
    base: "/", url: url_DeleteThingType_595145, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateTopicRule_595171 = ref object of OpenApiRestCall_593389
proc url_CreateTopicRule_595173(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateTopicRule_595172(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_595174 = path.getOrDefault("ruleName")
  valid_595174 = validateParameter(valid_595174, JString, required = true,
                                 default = nil)
  if valid_595174 != nil:
    section.add "ruleName", valid_595174
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   x-amz-tagging: JString
  ##                : <p>Metadata which can be used to manage the topic rule.</p> <note> <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p> <p>For the CLI command-line parameter use format: --tags "key1=value1&amp;key2=value2..."</p> <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p> </note>
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595175 = header.getOrDefault("x-amz-tagging")
  valid_595175 = validateParameter(valid_595175, JString, required = false,
                                 default = nil)
  if valid_595175 != nil:
    section.add "x-amz-tagging", valid_595175
  var valid_595176 = header.getOrDefault("X-Amz-Signature")
  valid_595176 = validateParameter(valid_595176, JString, required = false,
                                 default = nil)
  if valid_595176 != nil:
    section.add "X-Amz-Signature", valid_595176
  var valid_595177 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595177 = validateParameter(valid_595177, JString, required = false,
                                 default = nil)
  if valid_595177 != nil:
    section.add "X-Amz-Content-Sha256", valid_595177
  var valid_595178 = header.getOrDefault("X-Amz-Date")
  valid_595178 = validateParameter(valid_595178, JString, required = false,
                                 default = nil)
  if valid_595178 != nil:
    section.add "X-Amz-Date", valid_595178
  var valid_595179 = header.getOrDefault("X-Amz-Credential")
  valid_595179 = validateParameter(valid_595179, JString, required = false,
                                 default = nil)
  if valid_595179 != nil:
    section.add "X-Amz-Credential", valid_595179
  var valid_595180 = header.getOrDefault("X-Amz-Security-Token")
  valid_595180 = validateParameter(valid_595180, JString, required = false,
                                 default = nil)
  if valid_595180 != nil:
    section.add "X-Amz-Security-Token", valid_595180
  var valid_595181 = header.getOrDefault("X-Amz-Algorithm")
  valid_595181 = validateParameter(valid_595181, JString, required = false,
                                 default = nil)
  if valid_595181 != nil:
    section.add "X-Amz-Algorithm", valid_595181
  var valid_595182 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595182 = validateParameter(valid_595182, JString, required = false,
                                 default = nil)
  if valid_595182 != nil:
    section.add "X-Amz-SignedHeaders", valid_595182
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595184: Call_CreateTopicRule_595171; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  let valid = call_595184.validator(path, query, header, formData, body)
  let scheme = call_595184.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595184.url(scheme.get, call_595184.host, call_595184.base,
                         call_595184.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595184, url, valid)

proc call*(call_595185: Call_CreateTopicRule_595171; ruleName: string; body: JsonNode): Recallable =
  ## createTopicRule
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  ##   body: JObject (required)
  var path_595186 = newJObject()
  var body_595187 = newJObject()
  add(path_595186, "ruleName", newJString(ruleName))
  if body != nil:
    body_595187 = body
  result = call_595185.call(path_595186, nil, nil, nil, body_595187)

var createTopicRule* = Call_CreateTopicRule_595171(name: "createTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_CreateTopicRule_595172,
    base: "/", url: url_CreateTopicRule_595173, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetTopicRule_595157 = ref object of OpenApiRestCall_593389
proc url_GetTopicRule_595159(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTopicRule_595158(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_595160 = path.getOrDefault("ruleName")
  valid_595160 = validateParameter(valid_595160, JString, required = true,
                                 default = nil)
  if valid_595160 != nil:
    section.add "ruleName", valid_595160
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595161 = header.getOrDefault("X-Amz-Signature")
  valid_595161 = validateParameter(valid_595161, JString, required = false,
                                 default = nil)
  if valid_595161 != nil:
    section.add "X-Amz-Signature", valid_595161
  var valid_595162 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595162 = validateParameter(valid_595162, JString, required = false,
                                 default = nil)
  if valid_595162 != nil:
    section.add "X-Amz-Content-Sha256", valid_595162
  var valid_595163 = header.getOrDefault("X-Amz-Date")
  valid_595163 = validateParameter(valid_595163, JString, required = false,
                                 default = nil)
  if valid_595163 != nil:
    section.add "X-Amz-Date", valid_595163
  var valid_595164 = header.getOrDefault("X-Amz-Credential")
  valid_595164 = validateParameter(valid_595164, JString, required = false,
                                 default = nil)
  if valid_595164 != nil:
    section.add "X-Amz-Credential", valid_595164
  var valid_595165 = header.getOrDefault("X-Amz-Security-Token")
  valid_595165 = validateParameter(valid_595165, JString, required = false,
                                 default = nil)
  if valid_595165 != nil:
    section.add "X-Amz-Security-Token", valid_595165
  var valid_595166 = header.getOrDefault("X-Amz-Algorithm")
  valid_595166 = validateParameter(valid_595166, JString, required = false,
                                 default = nil)
  if valid_595166 != nil:
    section.add "X-Amz-Algorithm", valid_595166
  var valid_595167 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595167 = validateParameter(valid_595167, JString, required = false,
                                 default = nil)
  if valid_595167 != nil:
    section.add "X-Amz-SignedHeaders", valid_595167
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595168: Call_GetTopicRule_595157; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the rule.
  ## 
  let valid = call_595168.validator(path, query, header, formData, body)
  let scheme = call_595168.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595168.url(scheme.get, call_595168.host, call_595168.base,
                         call_595168.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595168, url, valid)

proc call*(call_595169: Call_GetTopicRule_595157; ruleName: string): Recallable =
  ## getTopicRule
  ## Gets information about the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  var path_595170 = newJObject()
  add(path_595170, "ruleName", newJString(ruleName))
  result = call_595169.call(path_595170, nil, nil, nil, nil)

var getTopicRule* = Call_GetTopicRule_595157(name: "getTopicRule",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/rules/{ruleName}",
    validator: validate_GetTopicRule_595158, base: "/", url: url_GetTopicRule_595159,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReplaceTopicRule_595202 = ref object of OpenApiRestCall_593389
proc url_ReplaceTopicRule_595204(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ReplaceTopicRule_595203(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_595205 = path.getOrDefault("ruleName")
  valid_595205 = validateParameter(valid_595205, JString, required = true,
                                 default = nil)
  if valid_595205 != nil:
    section.add "ruleName", valid_595205
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595206 = header.getOrDefault("X-Amz-Signature")
  valid_595206 = validateParameter(valid_595206, JString, required = false,
                                 default = nil)
  if valid_595206 != nil:
    section.add "X-Amz-Signature", valid_595206
  var valid_595207 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595207 = validateParameter(valid_595207, JString, required = false,
                                 default = nil)
  if valid_595207 != nil:
    section.add "X-Amz-Content-Sha256", valid_595207
  var valid_595208 = header.getOrDefault("X-Amz-Date")
  valid_595208 = validateParameter(valid_595208, JString, required = false,
                                 default = nil)
  if valid_595208 != nil:
    section.add "X-Amz-Date", valid_595208
  var valid_595209 = header.getOrDefault("X-Amz-Credential")
  valid_595209 = validateParameter(valid_595209, JString, required = false,
                                 default = nil)
  if valid_595209 != nil:
    section.add "X-Amz-Credential", valid_595209
  var valid_595210 = header.getOrDefault("X-Amz-Security-Token")
  valid_595210 = validateParameter(valid_595210, JString, required = false,
                                 default = nil)
  if valid_595210 != nil:
    section.add "X-Amz-Security-Token", valid_595210
  var valid_595211 = header.getOrDefault("X-Amz-Algorithm")
  valid_595211 = validateParameter(valid_595211, JString, required = false,
                                 default = nil)
  if valid_595211 != nil:
    section.add "X-Amz-Algorithm", valid_595211
  var valid_595212 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595212 = validateParameter(valid_595212, JString, required = false,
                                 default = nil)
  if valid_595212 != nil:
    section.add "X-Amz-SignedHeaders", valid_595212
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595214: Call_ReplaceTopicRule_595202; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  let valid = call_595214.validator(path, query, header, formData, body)
  let scheme = call_595214.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595214.url(scheme.get, call_595214.host, call_595214.base,
                         call_595214.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595214, url, valid)

proc call*(call_595215: Call_ReplaceTopicRule_595202; ruleName: string;
          body: JsonNode): Recallable =
  ## replaceTopicRule
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  ##   body: JObject (required)
  var path_595216 = newJObject()
  var body_595217 = newJObject()
  add(path_595216, "ruleName", newJString(ruleName))
  if body != nil:
    body_595217 = body
  result = call_595215.call(path_595216, nil, nil, nil, body_595217)

var replaceTopicRule* = Call_ReplaceTopicRule_595202(name: "replaceTopicRule",
    meth: HttpMethod.HttpPatch, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_ReplaceTopicRule_595203,
    base: "/", url: url_ReplaceTopicRule_595204,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteTopicRule_595188 = ref object of OpenApiRestCall_593389
proc url_DeleteTopicRule_595190(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTopicRule_595189(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_595191 = path.getOrDefault("ruleName")
  valid_595191 = validateParameter(valid_595191, JString, required = true,
                                 default = nil)
  if valid_595191 != nil:
    section.add "ruleName", valid_595191
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595192 = header.getOrDefault("X-Amz-Signature")
  valid_595192 = validateParameter(valid_595192, JString, required = false,
                                 default = nil)
  if valid_595192 != nil:
    section.add "X-Amz-Signature", valid_595192
  var valid_595193 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595193 = validateParameter(valid_595193, JString, required = false,
                                 default = nil)
  if valid_595193 != nil:
    section.add "X-Amz-Content-Sha256", valid_595193
  var valid_595194 = header.getOrDefault("X-Amz-Date")
  valid_595194 = validateParameter(valid_595194, JString, required = false,
                                 default = nil)
  if valid_595194 != nil:
    section.add "X-Amz-Date", valid_595194
  var valid_595195 = header.getOrDefault("X-Amz-Credential")
  valid_595195 = validateParameter(valid_595195, JString, required = false,
                                 default = nil)
  if valid_595195 != nil:
    section.add "X-Amz-Credential", valid_595195
  var valid_595196 = header.getOrDefault("X-Amz-Security-Token")
  valid_595196 = validateParameter(valid_595196, JString, required = false,
                                 default = nil)
  if valid_595196 != nil:
    section.add "X-Amz-Security-Token", valid_595196
  var valid_595197 = header.getOrDefault("X-Amz-Algorithm")
  valid_595197 = validateParameter(valid_595197, JString, required = false,
                                 default = nil)
  if valid_595197 != nil:
    section.add "X-Amz-Algorithm", valid_595197
  var valid_595198 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595198 = validateParameter(valid_595198, JString, required = false,
                                 default = nil)
  if valid_595198 != nil:
    section.add "X-Amz-SignedHeaders", valid_595198
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595199: Call_DeleteTopicRule_595188; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the rule.
  ## 
  let valid = call_595199.validator(path, query, header, formData, body)
  let scheme = call_595199.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595199.url(scheme.get, call_595199.host, call_595199.base,
                         call_595199.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595199, url, valid)

proc call*(call_595200: Call_DeleteTopicRule_595188; ruleName: string): Recallable =
  ## deleteTopicRule
  ## Deletes the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  var path_595201 = newJObject()
  add(path_595201, "ruleName", newJString(ruleName))
  result = call_595200.call(path_595201, nil, nil, nil, nil)

var deleteTopicRule* = Call_DeleteTopicRule_595188(name: "deleteTopicRule",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_DeleteTopicRule_595189,
    base: "/", url: url_DeleteTopicRule_595190, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAccountAuditConfiguration_595218 = ref object of OpenApiRestCall_593389
proc url_DescribeAccountAuditConfiguration_595220(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeAccountAuditConfiguration_595219(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595221 = header.getOrDefault("X-Amz-Signature")
  valid_595221 = validateParameter(valid_595221, JString, required = false,
                                 default = nil)
  if valid_595221 != nil:
    section.add "X-Amz-Signature", valid_595221
  var valid_595222 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595222 = validateParameter(valid_595222, JString, required = false,
                                 default = nil)
  if valid_595222 != nil:
    section.add "X-Amz-Content-Sha256", valid_595222
  var valid_595223 = header.getOrDefault("X-Amz-Date")
  valid_595223 = validateParameter(valid_595223, JString, required = false,
                                 default = nil)
  if valid_595223 != nil:
    section.add "X-Amz-Date", valid_595223
  var valid_595224 = header.getOrDefault("X-Amz-Credential")
  valid_595224 = validateParameter(valid_595224, JString, required = false,
                                 default = nil)
  if valid_595224 != nil:
    section.add "X-Amz-Credential", valid_595224
  var valid_595225 = header.getOrDefault("X-Amz-Security-Token")
  valid_595225 = validateParameter(valid_595225, JString, required = false,
                                 default = nil)
  if valid_595225 != nil:
    section.add "X-Amz-Security-Token", valid_595225
  var valid_595226 = header.getOrDefault("X-Amz-Algorithm")
  valid_595226 = validateParameter(valid_595226, JString, required = false,
                                 default = nil)
  if valid_595226 != nil:
    section.add "X-Amz-Algorithm", valid_595226
  var valid_595227 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595227 = validateParameter(valid_595227, JString, required = false,
                                 default = nil)
  if valid_595227 != nil:
    section.add "X-Amz-SignedHeaders", valid_595227
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595228: Call_DescribeAccountAuditConfiguration_595218;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  let valid = call_595228.validator(path, query, header, formData, body)
  let scheme = call_595228.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595228.url(scheme.get, call_595228.host, call_595228.base,
                         call_595228.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595228, url, valid)

proc call*(call_595229: Call_DescribeAccountAuditConfiguration_595218): Recallable =
  ## describeAccountAuditConfiguration
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  result = call_595229.call(nil, nil, nil, nil, nil)

var describeAccountAuditConfiguration* = Call_DescribeAccountAuditConfiguration_595218(
    name: "describeAccountAuditConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_DescribeAccountAuditConfiguration_595219, base: "/",
    url: url_DescribeAccountAuditConfiguration_595220,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateAccountAuditConfiguration_595244 = ref object of OpenApiRestCall_593389
proc url_UpdateAccountAuditConfiguration_595246(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateAccountAuditConfiguration_595245(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595247 = header.getOrDefault("X-Amz-Signature")
  valid_595247 = validateParameter(valid_595247, JString, required = false,
                                 default = nil)
  if valid_595247 != nil:
    section.add "X-Amz-Signature", valid_595247
  var valid_595248 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595248 = validateParameter(valid_595248, JString, required = false,
                                 default = nil)
  if valid_595248 != nil:
    section.add "X-Amz-Content-Sha256", valid_595248
  var valid_595249 = header.getOrDefault("X-Amz-Date")
  valid_595249 = validateParameter(valid_595249, JString, required = false,
                                 default = nil)
  if valid_595249 != nil:
    section.add "X-Amz-Date", valid_595249
  var valid_595250 = header.getOrDefault("X-Amz-Credential")
  valid_595250 = validateParameter(valid_595250, JString, required = false,
                                 default = nil)
  if valid_595250 != nil:
    section.add "X-Amz-Credential", valid_595250
  var valid_595251 = header.getOrDefault("X-Amz-Security-Token")
  valid_595251 = validateParameter(valid_595251, JString, required = false,
                                 default = nil)
  if valid_595251 != nil:
    section.add "X-Amz-Security-Token", valid_595251
  var valid_595252 = header.getOrDefault("X-Amz-Algorithm")
  valid_595252 = validateParameter(valid_595252, JString, required = false,
                                 default = nil)
  if valid_595252 != nil:
    section.add "X-Amz-Algorithm", valid_595252
  var valid_595253 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595253 = validateParameter(valid_595253, JString, required = false,
                                 default = nil)
  if valid_595253 != nil:
    section.add "X-Amz-SignedHeaders", valid_595253
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595255: Call_UpdateAccountAuditConfiguration_595244;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  let valid = call_595255.validator(path, query, header, formData, body)
  let scheme = call_595255.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595255.url(scheme.get, call_595255.host, call_595255.base,
                         call_595255.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595255, url, valid)

proc call*(call_595256: Call_UpdateAccountAuditConfiguration_595244; body: JsonNode): Recallable =
  ## updateAccountAuditConfiguration
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ##   body: JObject (required)
  var body_595257 = newJObject()
  if body != nil:
    body_595257 = body
  result = call_595256.call(nil, nil, nil, nil, body_595257)

var updateAccountAuditConfiguration* = Call_UpdateAccountAuditConfiguration_595244(
    name: "updateAccountAuditConfiguration", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_UpdateAccountAuditConfiguration_595245, base: "/",
    url: url_UpdateAccountAuditConfiguration_595246,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteAccountAuditConfiguration_595230 = ref object of OpenApiRestCall_593389
proc url_DeleteAccountAuditConfiguration_595232(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteAccountAuditConfiguration_595231(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   deleteScheduledAudits: JBool
  ##                        : If true, all scheduled audits are deleted.
  section = newJObject()
  var valid_595233 = query.getOrDefault("deleteScheduledAudits")
  valid_595233 = validateParameter(valid_595233, JBool, required = false, default = nil)
  if valid_595233 != nil:
    section.add "deleteScheduledAudits", valid_595233
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595234 = header.getOrDefault("X-Amz-Signature")
  valid_595234 = validateParameter(valid_595234, JString, required = false,
                                 default = nil)
  if valid_595234 != nil:
    section.add "X-Amz-Signature", valid_595234
  var valid_595235 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595235 = validateParameter(valid_595235, JString, required = false,
                                 default = nil)
  if valid_595235 != nil:
    section.add "X-Amz-Content-Sha256", valid_595235
  var valid_595236 = header.getOrDefault("X-Amz-Date")
  valid_595236 = validateParameter(valid_595236, JString, required = false,
                                 default = nil)
  if valid_595236 != nil:
    section.add "X-Amz-Date", valid_595236
  var valid_595237 = header.getOrDefault("X-Amz-Credential")
  valid_595237 = validateParameter(valid_595237, JString, required = false,
                                 default = nil)
  if valid_595237 != nil:
    section.add "X-Amz-Credential", valid_595237
  var valid_595238 = header.getOrDefault("X-Amz-Security-Token")
  valid_595238 = validateParameter(valid_595238, JString, required = false,
                                 default = nil)
  if valid_595238 != nil:
    section.add "X-Amz-Security-Token", valid_595238
  var valid_595239 = header.getOrDefault("X-Amz-Algorithm")
  valid_595239 = validateParameter(valid_595239, JString, required = false,
                                 default = nil)
  if valid_595239 != nil:
    section.add "X-Amz-Algorithm", valid_595239
  var valid_595240 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595240 = validateParameter(valid_595240, JString, required = false,
                                 default = nil)
  if valid_595240 != nil:
    section.add "X-Amz-SignedHeaders", valid_595240
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595241: Call_DeleteAccountAuditConfiguration_595230;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ## 
  let valid = call_595241.validator(path, query, header, formData, body)
  let scheme = call_595241.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595241.url(scheme.get, call_595241.host, call_595241.base,
                         call_595241.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595241, url, valid)

proc call*(call_595242: Call_DeleteAccountAuditConfiguration_595230;
          deleteScheduledAudits: bool = false): Recallable =
  ## deleteAccountAuditConfiguration
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ##   deleteScheduledAudits: bool
  ##                        : If true, all scheduled audits are deleted.
  var query_595243 = newJObject()
  add(query_595243, "deleteScheduledAudits", newJBool(deleteScheduledAudits))
  result = call_595242.call(nil, query_595243, nil, nil, nil)

var deleteAccountAuditConfiguration* = Call_DeleteAccountAuditConfiguration_595230(
    name: "deleteAccountAuditConfiguration", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_DeleteAccountAuditConfiguration_595231, base: "/",
    url: url_DeleteAccountAuditConfiguration_595232,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateCACertificate_595272 = ref object of OpenApiRestCall_593389
proc url_UpdateCACertificate_595274(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateCACertificate_595273(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Updates a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The CA certificate identifier.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_595275 = path.getOrDefault("caCertificateId")
  valid_595275 = validateParameter(valid_595275, JString, required = true,
                                 default = nil)
  if valid_595275 != nil:
    section.add "caCertificateId", valid_595275
  result.add "path", section
  ## parameters in `query` object:
  ##   newAutoRegistrationStatus: JString
  ##                            : The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
  ##   newStatus: JString
  ##            : <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  section = newJObject()
  var valid_595289 = query.getOrDefault("newAutoRegistrationStatus")
  valid_595289 = validateParameter(valid_595289, JString, required = false,
                                 default = newJString("ENABLE"))
  if valid_595289 != nil:
    section.add "newAutoRegistrationStatus", valid_595289
  var valid_595290 = query.getOrDefault("newStatus")
  valid_595290 = validateParameter(valid_595290, JString, required = false,
                                 default = newJString("ACTIVE"))
  if valid_595290 != nil:
    section.add "newStatus", valid_595290
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595291 = header.getOrDefault("X-Amz-Signature")
  valid_595291 = validateParameter(valid_595291, JString, required = false,
                                 default = nil)
  if valid_595291 != nil:
    section.add "X-Amz-Signature", valid_595291
  var valid_595292 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595292 = validateParameter(valid_595292, JString, required = false,
                                 default = nil)
  if valid_595292 != nil:
    section.add "X-Amz-Content-Sha256", valid_595292
  var valid_595293 = header.getOrDefault("X-Amz-Date")
  valid_595293 = validateParameter(valid_595293, JString, required = false,
                                 default = nil)
  if valid_595293 != nil:
    section.add "X-Amz-Date", valid_595293
  var valid_595294 = header.getOrDefault("X-Amz-Credential")
  valid_595294 = validateParameter(valid_595294, JString, required = false,
                                 default = nil)
  if valid_595294 != nil:
    section.add "X-Amz-Credential", valid_595294
  var valid_595295 = header.getOrDefault("X-Amz-Security-Token")
  valid_595295 = validateParameter(valid_595295, JString, required = false,
                                 default = nil)
  if valid_595295 != nil:
    section.add "X-Amz-Security-Token", valid_595295
  var valid_595296 = header.getOrDefault("X-Amz-Algorithm")
  valid_595296 = validateParameter(valid_595296, JString, required = false,
                                 default = nil)
  if valid_595296 != nil:
    section.add "X-Amz-Algorithm", valid_595296
  var valid_595297 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595297 = validateParameter(valid_595297, JString, required = false,
                                 default = nil)
  if valid_595297 != nil:
    section.add "X-Amz-SignedHeaders", valid_595297
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595299: Call_UpdateCACertificate_595272; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a registered CA certificate.
  ## 
  let valid = call_595299.validator(path, query, header, formData, body)
  let scheme = call_595299.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595299.url(scheme.get, call_595299.host, call_595299.base,
                         call_595299.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595299, url, valid)

proc call*(call_595300: Call_UpdateCACertificate_595272; caCertificateId: string;
          body: JsonNode; newAutoRegistrationStatus: string = "ENABLE";
          newStatus: string = "ACTIVE"): Recallable =
  ## updateCACertificate
  ## Updates a registered CA certificate.
  ##   newAutoRegistrationStatus: string
  ##                            : The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
  ##   caCertificateId: string (required)
  ##                  : The CA certificate identifier.
  ##   newStatus: string
  ##            : <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  ##   body: JObject (required)
  var path_595301 = newJObject()
  var query_595302 = newJObject()
  var body_595303 = newJObject()
  add(query_595302, "newAutoRegistrationStatus",
      newJString(newAutoRegistrationStatus))
  add(path_595301, "caCertificateId", newJString(caCertificateId))
  add(query_595302, "newStatus", newJString(newStatus))
  if body != nil:
    body_595303 = body
  result = call_595300.call(path_595301, query_595302, nil, nil, body_595303)

var updateCACertificate* = Call_UpdateCACertificate_595272(
    name: "updateCACertificate", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_UpdateCACertificate_595273, base: "/",
    url: url_UpdateCACertificate_595274, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeCACertificate_595258 = ref object of OpenApiRestCall_593389
proc url_DescribeCACertificate_595260(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeCACertificate_595259(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The CA certificate identifier.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_595261 = path.getOrDefault("caCertificateId")
  valid_595261 = validateParameter(valid_595261, JString, required = true,
                                 default = nil)
  if valid_595261 != nil:
    section.add "caCertificateId", valid_595261
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595262 = header.getOrDefault("X-Amz-Signature")
  valid_595262 = validateParameter(valid_595262, JString, required = false,
                                 default = nil)
  if valid_595262 != nil:
    section.add "X-Amz-Signature", valid_595262
  var valid_595263 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595263 = validateParameter(valid_595263, JString, required = false,
                                 default = nil)
  if valid_595263 != nil:
    section.add "X-Amz-Content-Sha256", valid_595263
  var valid_595264 = header.getOrDefault("X-Amz-Date")
  valid_595264 = validateParameter(valid_595264, JString, required = false,
                                 default = nil)
  if valid_595264 != nil:
    section.add "X-Amz-Date", valid_595264
  var valid_595265 = header.getOrDefault("X-Amz-Credential")
  valid_595265 = validateParameter(valid_595265, JString, required = false,
                                 default = nil)
  if valid_595265 != nil:
    section.add "X-Amz-Credential", valid_595265
  var valid_595266 = header.getOrDefault("X-Amz-Security-Token")
  valid_595266 = validateParameter(valid_595266, JString, required = false,
                                 default = nil)
  if valid_595266 != nil:
    section.add "X-Amz-Security-Token", valid_595266
  var valid_595267 = header.getOrDefault("X-Amz-Algorithm")
  valid_595267 = validateParameter(valid_595267, JString, required = false,
                                 default = nil)
  if valid_595267 != nil:
    section.add "X-Amz-Algorithm", valid_595267
  var valid_595268 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595268 = validateParameter(valid_595268, JString, required = false,
                                 default = nil)
  if valid_595268 != nil:
    section.add "X-Amz-SignedHeaders", valid_595268
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595269: Call_DescribeCACertificate_595258; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a registered CA certificate.
  ## 
  let valid = call_595269.validator(path, query, header, formData, body)
  let scheme = call_595269.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595269.url(scheme.get, call_595269.host, call_595269.base,
                         call_595269.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595269, url, valid)

proc call*(call_595270: Call_DescribeCACertificate_595258; caCertificateId: string): Recallable =
  ## describeCACertificate
  ## Describes a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The CA certificate identifier.
  var path_595271 = newJObject()
  add(path_595271, "caCertificateId", newJString(caCertificateId))
  result = call_595270.call(path_595271, nil, nil, nil, nil)

var describeCACertificate* = Call_DescribeCACertificate_595258(
    name: "describeCACertificate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_DescribeCACertificate_595259, base: "/",
    url: url_DescribeCACertificate_595260, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteCACertificate_595304 = ref object of OpenApiRestCall_593389
proc url_DeleteCACertificate_595306(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteCACertificate_595305(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Deletes a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_595307 = path.getOrDefault("caCertificateId")
  valid_595307 = validateParameter(valid_595307, JString, required = true,
                                 default = nil)
  if valid_595307 != nil:
    section.add "caCertificateId", valid_595307
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595308 = header.getOrDefault("X-Amz-Signature")
  valid_595308 = validateParameter(valid_595308, JString, required = false,
                                 default = nil)
  if valid_595308 != nil:
    section.add "X-Amz-Signature", valid_595308
  var valid_595309 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595309 = validateParameter(valid_595309, JString, required = false,
                                 default = nil)
  if valid_595309 != nil:
    section.add "X-Amz-Content-Sha256", valid_595309
  var valid_595310 = header.getOrDefault("X-Amz-Date")
  valid_595310 = validateParameter(valid_595310, JString, required = false,
                                 default = nil)
  if valid_595310 != nil:
    section.add "X-Amz-Date", valid_595310
  var valid_595311 = header.getOrDefault("X-Amz-Credential")
  valid_595311 = validateParameter(valid_595311, JString, required = false,
                                 default = nil)
  if valid_595311 != nil:
    section.add "X-Amz-Credential", valid_595311
  var valid_595312 = header.getOrDefault("X-Amz-Security-Token")
  valid_595312 = validateParameter(valid_595312, JString, required = false,
                                 default = nil)
  if valid_595312 != nil:
    section.add "X-Amz-Security-Token", valid_595312
  var valid_595313 = header.getOrDefault("X-Amz-Algorithm")
  valid_595313 = validateParameter(valid_595313, JString, required = false,
                                 default = nil)
  if valid_595313 != nil:
    section.add "X-Amz-Algorithm", valid_595313
  var valid_595314 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595314 = validateParameter(valid_595314, JString, required = false,
                                 default = nil)
  if valid_595314 != nil:
    section.add "X-Amz-SignedHeaders", valid_595314
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595315: Call_DeleteCACertificate_595304; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a registered CA certificate.
  ## 
  let valid = call_595315.validator(path, query, header, formData, body)
  let scheme = call_595315.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595315.url(scheme.get, call_595315.host, call_595315.base,
                         call_595315.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595315, url, valid)

proc call*(call_595316: Call_DeleteCACertificate_595304; caCertificateId: string): Recallable =
  ## deleteCACertificate
  ## Deletes a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
  var path_595317 = newJObject()
  add(path_595317, "caCertificateId", newJString(caCertificateId))
  result = call_595316.call(path_595317, nil, nil, nil, nil)

var deleteCACertificate* = Call_DeleteCACertificate_595304(
    name: "deleteCACertificate", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_DeleteCACertificate_595305, base: "/",
    url: url_DeleteCACertificate_595306, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeCertificate_595318 = ref object of OpenApiRestCall_593389
proc url_DescribeCertificate_595320(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeCertificate_595319(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets information about the specified certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_595321 = path.getOrDefault("certificateId")
  valid_595321 = validateParameter(valid_595321, JString, required = true,
                                 default = nil)
  if valid_595321 != nil:
    section.add "certificateId", valid_595321
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595322 = header.getOrDefault("X-Amz-Signature")
  valid_595322 = validateParameter(valid_595322, JString, required = false,
                                 default = nil)
  if valid_595322 != nil:
    section.add "X-Amz-Signature", valid_595322
  var valid_595323 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595323 = validateParameter(valid_595323, JString, required = false,
                                 default = nil)
  if valid_595323 != nil:
    section.add "X-Amz-Content-Sha256", valid_595323
  var valid_595324 = header.getOrDefault("X-Amz-Date")
  valid_595324 = validateParameter(valid_595324, JString, required = false,
                                 default = nil)
  if valid_595324 != nil:
    section.add "X-Amz-Date", valid_595324
  var valid_595325 = header.getOrDefault("X-Amz-Credential")
  valid_595325 = validateParameter(valid_595325, JString, required = false,
                                 default = nil)
  if valid_595325 != nil:
    section.add "X-Amz-Credential", valid_595325
  var valid_595326 = header.getOrDefault("X-Amz-Security-Token")
  valid_595326 = validateParameter(valid_595326, JString, required = false,
                                 default = nil)
  if valid_595326 != nil:
    section.add "X-Amz-Security-Token", valid_595326
  var valid_595327 = header.getOrDefault("X-Amz-Algorithm")
  valid_595327 = validateParameter(valid_595327, JString, required = false,
                                 default = nil)
  if valid_595327 != nil:
    section.add "X-Amz-Algorithm", valid_595327
  var valid_595328 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595328 = validateParameter(valid_595328, JString, required = false,
                                 default = nil)
  if valid_595328 != nil:
    section.add "X-Amz-SignedHeaders", valid_595328
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595329: Call_DescribeCertificate_595318; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified certificate.
  ## 
  let valid = call_595329.validator(path, query, header, formData, body)
  let scheme = call_595329.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595329.url(scheme.get, call_595329.host, call_595329.base,
                         call_595329.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595329, url, valid)

proc call*(call_595330: Call_DescribeCertificate_595318; certificateId: string): Recallable =
  ## describeCertificate
  ## Gets information about the specified certificate.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_595331 = newJObject()
  add(path_595331, "certificateId", newJString(certificateId))
  result = call_595330.call(path_595331, nil, nil, nil, nil)

var describeCertificate* = Call_DescribeCertificate_595318(
    name: "describeCertificate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates/{certificateId}",
    validator: validate_DescribeCertificate_595319, base: "/",
    url: url_DescribeCertificate_595320, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteCertificate_595332 = ref object of OpenApiRestCall_593389
proc url_DeleteCertificate_595334(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteCertificate_595333(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_595335 = path.getOrDefault("certificateId")
  valid_595335 = validateParameter(valid_595335, JString, required = true,
                                 default = nil)
  if valid_595335 != nil:
    section.add "certificateId", valid_595335
  result.add "path", section
  ## parameters in `query` object:
  ##   forceDelete: JBool
  ##              : Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
  section = newJObject()
  var valid_595336 = query.getOrDefault("forceDelete")
  valid_595336 = validateParameter(valid_595336, JBool, required = false, default = nil)
  if valid_595336 != nil:
    section.add "forceDelete", valid_595336
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595337 = header.getOrDefault("X-Amz-Signature")
  valid_595337 = validateParameter(valid_595337, JString, required = false,
                                 default = nil)
  if valid_595337 != nil:
    section.add "X-Amz-Signature", valid_595337
  var valid_595338 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595338 = validateParameter(valid_595338, JString, required = false,
                                 default = nil)
  if valid_595338 != nil:
    section.add "X-Amz-Content-Sha256", valid_595338
  var valid_595339 = header.getOrDefault("X-Amz-Date")
  valid_595339 = validateParameter(valid_595339, JString, required = false,
                                 default = nil)
  if valid_595339 != nil:
    section.add "X-Amz-Date", valid_595339
  var valid_595340 = header.getOrDefault("X-Amz-Credential")
  valid_595340 = validateParameter(valid_595340, JString, required = false,
                                 default = nil)
  if valid_595340 != nil:
    section.add "X-Amz-Credential", valid_595340
  var valid_595341 = header.getOrDefault("X-Amz-Security-Token")
  valid_595341 = validateParameter(valid_595341, JString, required = false,
                                 default = nil)
  if valid_595341 != nil:
    section.add "X-Amz-Security-Token", valid_595341
  var valid_595342 = header.getOrDefault("X-Amz-Algorithm")
  valid_595342 = validateParameter(valid_595342, JString, required = false,
                                 default = nil)
  if valid_595342 != nil:
    section.add "X-Amz-Algorithm", valid_595342
  var valid_595343 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595343 = validateParameter(valid_595343, JString, required = false,
                                 default = nil)
  if valid_595343 != nil:
    section.add "X-Amz-SignedHeaders", valid_595343
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595344: Call_DeleteCertificate_595332; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ## 
  let valid = call_595344.validator(path, query, header, formData, body)
  let scheme = call_595344.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595344.url(scheme.get, call_595344.host, call_595344.base,
                         call_595344.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595344, url, valid)

proc call*(call_595345: Call_DeleteCertificate_595332; certificateId: string;
          forceDelete: bool = false): Recallable =
  ## deleteCertificate
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ##   forceDelete: bool
  ##              : Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_595346 = newJObject()
  var query_595347 = newJObject()
  add(query_595347, "forceDelete", newJBool(forceDelete))
  add(path_595346, "certificateId", newJString(certificateId))
  result = call_595345.call(path_595346, query_595347, nil, nil, nil)

var deleteCertificate* = Call_DeleteCertificate_595332(name: "deleteCertificate",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/certificates/{certificateId}", validator: validate_DeleteCertificate_595333,
    base: "/", url: url_DeleteCertificate_595334,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteJobExecution_595348 = ref object of OpenApiRestCall_593389
proc url_DeleteJobExecution_595350(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  assert "executionNumber" in path, "`executionNumber` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/executionNumber/"),
               (kind: VariableSegment, value: "executionNumber")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteJobExecution_595349(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deletes a job execution.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   executionNumber: JInt (required)
  ##                  : <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
  ##   jobId: JString (required)
  ##        : The ID of the job whose execution on a particular device will be deleted.
  ##   thingName: JString (required)
  ##            : The name of the thing whose job execution will be deleted.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `executionNumber` field"
  var valid_595351 = path.getOrDefault("executionNumber")
  valid_595351 = validateParameter(valid_595351, JInt, required = true, default = nil)
  if valid_595351 != nil:
    section.add "executionNumber", valid_595351
  var valid_595352 = path.getOrDefault("jobId")
  valid_595352 = validateParameter(valid_595352, JString, required = true,
                                 default = nil)
  if valid_595352 != nil:
    section.add "jobId", valid_595352
  var valid_595353 = path.getOrDefault("thingName")
  valid_595353 = validateParameter(valid_595353, JString, required = true,
                                 default = nil)
  if valid_595353 != nil:
    section.add "thingName", valid_595353
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
  section = newJObject()
  var valid_595354 = query.getOrDefault("force")
  valid_595354 = validateParameter(valid_595354, JBool, required = false, default = nil)
  if valid_595354 != nil:
    section.add "force", valid_595354
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595355 = header.getOrDefault("X-Amz-Signature")
  valid_595355 = validateParameter(valid_595355, JString, required = false,
                                 default = nil)
  if valid_595355 != nil:
    section.add "X-Amz-Signature", valid_595355
  var valid_595356 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595356 = validateParameter(valid_595356, JString, required = false,
                                 default = nil)
  if valid_595356 != nil:
    section.add "X-Amz-Content-Sha256", valid_595356
  var valid_595357 = header.getOrDefault("X-Amz-Date")
  valid_595357 = validateParameter(valid_595357, JString, required = false,
                                 default = nil)
  if valid_595357 != nil:
    section.add "X-Amz-Date", valid_595357
  var valid_595358 = header.getOrDefault("X-Amz-Credential")
  valid_595358 = validateParameter(valid_595358, JString, required = false,
                                 default = nil)
  if valid_595358 != nil:
    section.add "X-Amz-Credential", valid_595358
  var valid_595359 = header.getOrDefault("X-Amz-Security-Token")
  valid_595359 = validateParameter(valid_595359, JString, required = false,
                                 default = nil)
  if valid_595359 != nil:
    section.add "X-Amz-Security-Token", valid_595359
  var valid_595360 = header.getOrDefault("X-Amz-Algorithm")
  valid_595360 = validateParameter(valid_595360, JString, required = false,
                                 default = nil)
  if valid_595360 != nil:
    section.add "X-Amz-Algorithm", valid_595360
  var valid_595361 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595361 = validateParameter(valid_595361, JString, required = false,
                                 default = nil)
  if valid_595361 != nil:
    section.add "X-Amz-SignedHeaders", valid_595361
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595362: Call_DeleteJobExecution_595348; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a job execution.
  ## 
  let valid = call_595362.validator(path, query, header, formData, body)
  let scheme = call_595362.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595362.url(scheme.get, call_595362.host, call_595362.base,
                         call_595362.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595362, url, valid)

proc call*(call_595363: Call_DeleteJobExecution_595348; executionNumber: int;
          jobId: string; thingName: string; force: bool = false): Recallable =
  ## deleteJobExecution
  ## Deletes a job execution.
  ##   executionNumber: int (required)
  ##                  : <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
  ##   jobId: string (required)
  ##        : The ID of the job whose execution on a particular device will be deleted.
  ##   thingName: string (required)
  ##            : The name of the thing whose job execution will be deleted.
  ##   force: bool
  ##        : <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
  var path_595364 = newJObject()
  var query_595365 = newJObject()
  add(path_595364, "executionNumber", newJInt(executionNumber))
  add(path_595364, "jobId", newJString(jobId))
  add(path_595364, "thingName", newJString(thingName))
  add(query_595365, "force", newJBool(force))
  result = call_595363.call(path_595364, query_595365, nil, nil, nil)

var deleteJobExecution* = Call_DeleteJobExecution_595348(
    name: "deleteJobExecution", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}",
    validator: validate_DeleteJobExecution_595349, base: "/",
    url: url_DeleteJobExecution_595350, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPolicyVersion_595366 = ref object of OpenApiRestCall_593389
proc url_GetPolicyVersion_595368(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetPolicyVersion_595367(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets information about the specified policy version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_595369 = path.getOrDefault("policyName")
  valid_595369 = validateParameter(valid_595369, JString, required = true,
                                 default = nil)
  if valid_595369 != nil:
    section.add "policyName", valid_595369
  var valid_595370 = path.getOrDefault("policyVersionId")
  valid_595370 = validateParameter(valid_595370, JString, required = true,
                                 default = nil)
  if valid_595370 != nil:
    section.add "policyVersionId", valid_595370
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595371 = header.getOrDefault("X-Amz-Signature")
  valid_595371 = validateParameter(valid_595371, JString, required = false,
                                 default = nil)
  if valid_595371 != nil:
    section.add "X-Amz-Signature", valid_595371
  var valid_595372 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595372 = validateParameter(valid_595372, JString, required = false,
                                 default = nil)
  if valid_595372 != nil:
    section.add "X-Amz-Content-Sha256", valid_595372
  var valid_595373 = header.getOrDefault("X-Amz-Date")
  valid_595373 = validateParameter(valid_595373, JString, required = false,
                                 default = nil)
  if valid_595373 != nil:
    section.add "X-Amz-Date", valid_595373
  var valid_595374 = header.getOrDefault("X-Amz-Credential")
  valid_595374 = validateParameter(valid_595374, JString, required = false,
                                 default = nil)
  if valid_595374 != nil:
    section.add "X-Amz-Credential", valid_595374
  var valid_595375 = header.getOrDefault("X-Amz-Security-Token")
  valid_595375 = validateParameter(valid_595375, JString, required = false,
                                 default = nil)
  if valid_595375 != nil:
    section.add "X-Amz-Security-Token", valid_595375
  var valid_595376 = header.getOrDefault("X-Amz-Algorithm")
  valid_595376 = validateParameter(valid_595376, JString, required = false,
                                 default = nil)
  if valid_595376 != nil:
    section.add "X-Amz-Algorithm", valid_595376
  var valid_595377 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595377 = validateParameter(valid_595377, JString, required = false,
                                 default = nil)
  if valid_595377 != nil:
    section.add "X-Amz-SignedHeaders", valid_595377
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595378: Call_GetPolicyVersion_595366; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified policy version.
  ## 
  let valid = call_595378.validator(path, query, header, formData, body)
  let scheme = call_595378.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595378.url(scheme.get, call_595378.host, call_595378.base,
                         call_595378.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595378, url, valid)

proc call*(call_595379: Call_GetPolicyVersion_595366; policyName: string;
          policyVersionId: string): Recallable =
  ## getPolicyVersion
  ## Gets information about the specified policy version.
  ##   policyName: string (required)
  ##             : The name of the policy.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_595380 = newJObject()
  add(path_595380, "policyName", newJString(policyName))
  add(path_595380, "policyVersionId", newJString(policyVersionId))
  result = call_595379.call(path_595380, nil, nil, nil, nil)

var getPolicyVersion* = Call_GetPolicyVersion_595366(name: "getPolicyVersion",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_GetPolicyVersion_595367, base: "/",
    url: url_GetPolicyVersion_595368, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetDefaultPolicyVersion_595396 = ref object of OpenApiRestCall_593389
proc url_SetDefaultPolicyVersion_595398(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_SetDefaultPolicyVersion_595397(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_595399 = path.getOrDefault("policyName")
  valid_595399 = validateParameter(valid_595399, JString, required = true,
                                 default = nil)
  if valid_595399 != nil:
    section.add "policyName", valid_595399
  var valid_595400 = path.getOrDefault("policyVersionId")
  valid_595400 = validateParameter(valid_595400, JString, required = true,
                                 default = nil)
  if valid_595400 != nil:
    section.add "policyVersionId", valid_595400
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595401 = header.getOrDefault("X-Amz-Signature")
  valid_595401 = validateParameter(valid_595401, JString, required = false,
                                 default = nil)
  if valid_595401 != nil:
    section.add "X-Amz-Signature", valid_595401
  var valid_595402 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595402 = validateParameter(valid_595402, JString, required = false,
                                 default = nil)
  if valid_595402 != nil:
    section.add "X-Amz-Content-Sha256", valid_595402
  var valid_595403 = header.getOrDefault("X-Amz-Date")
  valid_595403 = validateParameter(valid_595403, JString, required = false,
                                 default = nil)
  if valid_595403 != nil:
    section.add "X-Amz-Date", valid_595403
  var valid_595404 = header.getOrDefault("X-Amz-Credential")
  valid_595404 = validateParameter(valid_595404, JString, required = false,
                                 default = nil)
  if valid_595404 != nil:
    section.add "X-Amz-Credential", valid_595404
  var valid_595405 = header.getOrDefault("X-Amz-Security-Token")
  valid_595405 = validateParameter(valid_595405, JString, required = false,
                                 default = nil)
  if valid_595405 != nil:
    section.add "X-Amz-Security-Token", valid_595405
  var valid_595406 = header.getOrDefault("X-Amz-Algorithm")
  valid_595406 = validateParameter(valid_595406, JString, required = false,
                                 default = nil)
  if valid_595406 != nil:
    section.add "X-Amz-Algorithm", valid_595406
  var valid_595407 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595407 = validateParameter(valid_595407, JString, required = false,
                                 default = nil)
  if valid_595407 != nil:
    section.add "X-Amz-SignedHeaders", valid_595407
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595408: Call_SetDefaultPolicyVersion_595396; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ## 
  let valid = call_595408.validator(path, query, header, formData, body)
  let scheme = call_595408.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595408.url(scheme.get, call_595408.host, call_595408.base,
                         call_595408.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595408, url, valid)

proc call*(call_595409: Call_SetDefaultPolicyVersion_595396; policyName: string;
          policyVersionId: string): Recallable =
  ## setDefaultPolicyVersion
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ##   policyName: string (required)
  ##             : The policy name.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_595410 = newJObject()
  add(path_595410, "policyName", newJString(policyName))
  add(path_595410, "policyVersionId", newJString(policyVersionId))
  result = call_595409.call(path_595410, nil, nil, nil, nil)

var setDefaultPolicyVersion* = Call_SetDefaultPolicyVersion_595396(
    name: "setDefaultPolicyVersion", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_SetDefaultPolicyVersion_595397, base: "/",
    url: url_SetDefaultPolicyVersion_595398, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeletePolicyVersion_595381 = ref object of OpenApiRestCall_593389
proc url_DeletePolicyVersion_595383(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeletePolicyVersion_595382(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_595384 = path.getOrDefault("policyName")
  valid_595384 = validateParameter(valid_595384, JString, required = true,
                                 default = nil)
  if valid_595384 != nil:
    section.add "policyName", valid_595384
  var valid_595385 = path.getOrDefault("policyVersionId")
  valid_595385 = validateParameter(valid_595385, JString, required = true,
                                 default = nil)
  if valid_595385 != nil:
    section.add "policyVersionId", valid_595385
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595386 = header.getOrDefault("X-Amz-Signature")
  valid_595386 = validateParameter(valid_595386, JString, required = false,
                                 default = nil)
  if valid_595386 != nil:
    section.add "X-Amz-Signature", valid_595386
  var valid_595387 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595387 = validateParameter(valid_595387, JString, required = false,
                                 default = nil)
  if valid_595387 != nil:
    section.add "X-Amz-Content-Sha256", valid_595387
  var valid_595388 = header.getOrDefault("X-Amz-Date")
  valid_595388 = validateParameter(valid_595388, JString, required = false,
                                 default = nil)
  if valid_595388 != nil:
    section.add "X-Amz-Date", valid_595388
  var valid_595389 = header.getOrDefault("X-Amz-Credential")
  valid_595389 = validateParameter(valid_595389, JString, required = false,
                                 default = nil)
  if valid_595389 != nil:
    section.add "X-Amz-Credential", valid_595389
  var valid_595390 = header.getOrDefault("X-Amz-Security-Token")
  valid_595390 = validateParameter(valid_595390, JString, required = false,
                                 default = nil)
  if valid_595390 != nil:
    section.add "X-Amz-Security-Token", valid_595390
  var valid_595391 = header.getOrDefault("X-Amz-Algorithm")
  valid_595391 = validateParameter(valid_595391, JString, required = false,
                                 default = nil)
  if valid_595391 != nil:
    section.add "X-Amz-Algorithm", valid_595391
  var valid_595392 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595392 = validateParameter(valid_595392, JString, required = false,
                                 default = nil)
  if valid_595392 != nil:
    section.add "X-Amz-SignedHeaders", valid_595392
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595393: Call_DeletePolicyVersion_595381; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ## 
  let valid = call_595393.validator(path, query, header, formData, body)
  let scheme = call_595393.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595393.url(scheme.get, call_595393.host, call_595393.base,
                         call_595393.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595393, url, valid)

proc call*(call_595394: Call_DeletePolicyVersion_595381; policyName: string;
          policyVersionId: string): Recallable =
  ## deletePolicyVersion
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ##   policyName: string (required)
  ##             : The name of the policy.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_595395 = newJObject()
  add(path_595395, "policyName", newJString(policyName))
  add(path_595395, "policyVersionId", newJString(policyVersionId))
  result = call_595394.call(path_595395, nil, nil, nil, nil)

var deletePolicyVersion* = Call_DeletePolicyVersion_595381(
    name: "deletePolicyVersion", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_DeletePolicyVersion_595382, base: "/",
    url: url_DeletePolicyVersion_595383, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRegistrationCode_595411 = ref object of OpenApiRestCall_593389
proc url_GetRegistrationCode_595413(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRegistrationCode_595412(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595414 = header.getOrDefault("X-Amz-Signature")
  valid_595414 = validateParameter(valid_595414, JString, required = false,
                                 default = nil)
  if valid_595414 != nil:
    section.add "X-Amz-Signature", valid_595414
  var valid_595415 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595415 = validateParameter(valid_595415, JString, required = false,
                                 default = nil)
  if valid_595415 != nil:
    section.add "X-Amz-Content-Sha256", valid_595415
  var valid_595416 = header.getOrDefault("X-Amz-Date")
  valid_595416 = validateParameter(valid_595416, JString, required = false,
                                 default = nil)
  if valid_595416 != nil:
    section.add "X-Amz-Date", valid_595416
  var valid_595417 = header.getOrDefault("X-Amz-Credential")
  valid_595417 = validateParameter(valid_595417, JString, required = false,
                                 default = nil)
  if valid_595417 != nil:
    section.add "X-Amz-Credential", valid_595417
  var valid_595418 = header.getOrDefault("X-Amz-Security-Token")
  valid_595418 = validateParameter(valid_595418, JString, required = false,
                                 default = nil)
  if valid_595418 != nil:
    section.add "X-Amz-Security-Token", valid_595418
  var valid_595419 = header.getOrDefault("X-Amz-Algorithm")
  valid_595419 = validateParameter(valid_595419, JString, required = false,
                                 default = nil)
  if valid_595419 != nil:
    section.add "X-Amz-Algorithm", valid_595419
  var valid_595420 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595420 = validateParameter(valid_595420, JString, required = false,
                                 default = nil)
  if valid_595420 != nil:
    section.add "X-Amz-SignedHeaders", valid_595420
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595421: Call_GetRegistrationCode_595411; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  ## 
  let valid = call_595421.validator(path, query, header, formData, body)
  let scheme = call_595421.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595421.url(scheme.get, call_595421.host, call_595421.base,
                         call_595421.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595421, url, valid)

proc call*(call_595422: Call_GetRegistrationCode_595411): Recallable =
  ## getRegistrationCode
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  result = call_595422.call(nil, nil, nil, nil, nil)

var getRegistrationCode* = Call_GetRegistrationCode_595411(
    name: "getRegistrationCode", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/registrationcode",
    validator: validate_GetRegistrationCode_595412, base: "/",
    url: url_GetRegistrationCode_595413, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRegistrationCode_595423 = ref object of OpenApiRestCall_593389
proc url_DeleteRegistrationCode_595425(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteRegistrationCode_595424(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a CA certificate registration code.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595426 = header.getOrDefault("X-Amz-Signature")
  valid_595426 = validateParameter(valid_595426, JString, required = false,
                                 default = nil)
  if valid_595426 != nil:
    section.add "X-Amz-Signature", valid_595426
  var valid_595427 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595427 = validateParameter(valid_595427, JString, required = false,
                                 default = nil)
  if valid_595427 != nil:
    section.add "X-Amz-Content-Sha256", valid_595427
  var valid_595428 = header.getOrDefault("X-Amz-Date")
  valid_595428 = validateParameter(valid_595428, JString, required = false,
                                 default = nil)
  if valid_595428 != nil:
    section.add "X-Amz-Date", valid_595428
  var valid_595429 = header.getOrDefault("X-Amz-Credential")
  valid_595429 = validateParameter(valid_595429, JString, required = false,
                                 default = nil)
  if valid_595429 != nil:
    section.add "X-Amz-Credential", valid_595429
  var valid_595430 = header.getOrDefault("X-Amz-Security-Token")
  valid_595430 = validateParameter(valid_595430, JString, required = false,
                                 default = nil)
  if valid_595430 != nil:
    section.add "X-Amz-Security-Token", valid_595430
  var valid_595431 = header.getOrDefault("X-Amz-Algorithm")
  valid_595431 = validateParameter(valid_595431, JString, required = false,
                                 default = nil)
  if valid_595431 != nil:
    section.add "X-Amz-Algorithm", valid_595431
  var valid_595432 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595432 = validateParameter(valid_595432, JString, required = false,
                                 default = nil)
  if valid_595432 != nil:
    section.add "X-Amz-SignedHeaders", valid_595432
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595433: Call_DeleteRegistrationCode_595423; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a CA certificate registration code.
  ## 
  let valid = call_595433.validator(path, query, header, formData, body)
  let scheme = call_595433.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595433.url(scheme.get, call_595433.host, call_595433.base,
                         call_595433.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595433, url, valid)

proc call*(call_595434: Call_DeleteRegistrationCode_595423): Recallable =
  ## deleteRegistrationCode
  ## Deletes a CA certificate registration code.
  result = call_595434.call(nil, nil, nil, nil, nil)

var deleteRegistrationCode* = Call_DeleteRegistrationCode_595423(
    name: "deleteRegistrationCode", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/registrationcode",
    validator: validate_DeleteRegistrationCode_595424, base: "/",
    url: url_DeleteRegistrationCode_595425, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteV2LoggingLevel_595435 = ref object of OpenApiRestCall_593389
proc url_DeleteV2LoggingLevel_595437(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteV2LoggingLevel_595436(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a logging level.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   targetName: JString (required)
  ##             : The name of the resource for which you are configuring logging.
  ##   targetType: JString (required)
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `targetName` field"
  var valid_595438 = query.getOrDefault("targetName")
  valid_595438 = validateParameter(valid_595438, JString, required = true,
                                 default = nil)
  if valid_595438 != nil:
    section.add "targetName", valid_595438
  var valid_595439 = query.getOrDefault("targetType")
  valid_595439 = validateParameter(valid_595439, JString, required = true,
                                 default = newJString("DEFAULT"))
  if valid_595439 != nil:
    section.add "targetType", valid_595439
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595440 = header.getOrDefault("X-Amz-Signature")
  valid_595440 = validateParameter(valid_595440, JString, required = false,
                                 default = nil)
  if valid_595440 != nil:
    section.add "X-Amz-Signature", valid_595440
  var valid_595441 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595441 = validateParameter(valid_595441, JString, required = false,
                                 default = nil)
  if valid_595441 != nil:
    section.add "X-Amz-Content-Sha256", valid_595441
  var valid_595442 = header.getOrDefault("X-Amz-Date")
  valid_595442 = validateParameter(valid_595442, JString, required = false,
                                 default = nil)
  if valid_595442 != nil:
    section.add "X-Amz-Date", valid_595442
  var valid_595443 = header.getOrDefault("X-Amz-Credential")
  valid_595443 = validateParameter(valid_595443, JString, required = false,
                                 default = nil)
  if valid_595443 != nil:
    section.add "X-Amz-Credential", valid_595443
  var valid_595444 = header.getOrDefault("X-Amz-Security-Token")
  valid_595444 = validateParameter(valid_595444, JString, required = false,
                                 default = nil)
  if valid_595444 != nil:
    section.add "X-Amz-Security-Token", valid_595444
  var valid_595445 = header.getOrDefault("X-Amz-Algorithm")
  valid_595445 = validateParameter(valid_595445, JString, required = false,
                                 default = nil)
  if valid_595445 != nil:
    section.add "X-Amz-Algorithm", valid_595445
  var valid_595446 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595446 = validateParameter(valid_595446, JString, required = false,
                                 default = nil)
  if valid_595446 != nil:
    section.add "X-Amz-SignedHeaders", valid_595446
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595447: Call_DeleteV2LoggingLevel_595435; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a logging level.
  ## 
  let valid = call_595447.validator(path, query, header, formData, body)
  let scheme = call_595447.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595447.url(scheme.get, call_595447.host, call_595447.base,
                         call_595447.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595447, url, valid)

proc call*(call_595448: Call_DeleteV2LoggingLevel_595435; targetName: string;
          targetType: string = "DEFAULT"): Recallable =
  ## deleteV2LoggingLevel
  ## Deletes a logging level.
  ##   targetName: string (required)
  ##             : The name of the resource for which you are configuring logging.
  ##   targetType: string (required)
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  var query_595449 = newJObject()
  add(query_595449, "targetName", newJString(targetName))
  add(query_595449, "targetType", newJString(targetType))
  result = call_595448.call(nil, query_595449, nil, nil, nil)

var deleteV2LoggingLevel* = Call_DeleteV2LoggingLevel_595435(
    name: "deleteV2LoggingLevel", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/v2LoggingLevel#targetType&targetName",
    validator: validate_DeleteV2LoggingLevel_595436, base: "/",
    url: url_DeleteV2LoggingLevel_595437, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeprecateThingType_595450 = ref object of OpenApiRestCall_593389
proc url_DeprecateThingType_595452(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName"),
               (kind: ConstantSegment, value: "/deprecate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeprecateThingType_595451(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type to deprecate.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_595453 = path.getOrDefault("thingTypeName")
  valid_595453 = validateParameter(valid_595453, JString, required = true,
                                 default = nil)
  if valid_595453 != nil:
    section.add "thingTypeName", valid_595453
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595454 = header.getOrDefault("X-Amz-Signature")
  valid_595454 = validateParameter(valid_595454, JString, required = false,
                                 default = nil)
  if valid_595454 != nil:
    section.add "X-Amz-Signature", valid_595454
  var valid_595455 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595455 = validateParameter(valid_595455, JString, required = false,
                                 default = nil)
  if valid_595455 != nil:
    section.add "X-Amz-Content-Sha256", valid_595455
  var valid_595456 = header.getOrDefault("X-Amz-Date")
  valid_595456 = validateParameter(valid_595456, JString, required = false,
                                 default = nil)
  if valid_595456 != nil:
    section.add "X-Amz-Date", valid_595456
  var valid_595457 = header.getOrDefault("X-Amz-Credential")
  valid_595457 = validateParameter(valid_595457, JString, required = false,
                                 default = nil)
  if valid_595457 != nil:
    section.add "X-Amz-Credential", valid_595457
  var valid_595458 = header.getOrDefault("X-Amz-Security-Token")
  valid_595458 = validateParameter(valid_595458, JString, required = false,
                                 default = nil)
  if valid_595458 != nil:
    section.add "X-Amz-Security-Token", valid_595458
  var valid_595459 = header.getOrDefault("X-Amz-Algorithm")
  valid_595459 = validateParameter(valid_595459, JString, required = false,
                                 default = nil)
  if valid_595459 != nil:
    section.add "X-Amz-Algorithm", valid_595459
  var valid_595460 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595460 = validateParameter(valid_595460, JString, required = false,
                                 default = nil)
  if valid_595460 != nil:
    section.add "X-Amz-SignedHeaders", valid_595460
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595462: Call_DeprecateThingType_595450; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ## 
  let valid = call_595462.validator(path, query, header, formData, body)
  let scheme = call_595462.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595462.url(scheme.get, call_595462.host, call_595462.base,
                         call_595462.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595462, url, valid)

proc call*(call_595463: Call_DeprecateThingType_595450; thingTypeName: string;
          body: JsonNode): Recallable =
  ## deprecateThingType
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type to deprecate.
  ##   body: JObject (required)
  var path_595464 = newJObject()
  var body_595465 = newJObject()
  add(path_595464, "thingTypeName", newJString(thingTypeName))
  if body != nil:
    body_595465 = body
  result = call_595463.call(path_595464, nil, nil, nil, body_595465)

var deprecateThingType* = Call_DeprecateThingType_595450(
    name: "deprecateThingType", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/thing-types/{thingTypeName}/deprecate",
    validator: validate_DeprecateThingType_595451, base: "/",
    url: url_DeprecateThingType_595452, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditFinding_595466 = ref object of OpenApiRestCall_593389
proc url_DescribeAuditFinding_595468(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "findingId" in path, "`findingId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/findings/"),
               (kind: VariableSegment, value: "findingId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuditFinding_595467(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   findingId: JString (required)
  ##            : A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `findingId` field"
  var valid_595469 = path.getOrDefault("findingId")
  valid_595469 = validateParameter(valid_595469, JString, required = true,
                                 default = nil)
  if valid_595469 != nil:
    section.add "findingId", valid_595469
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595470 = header.getOrDefault("X-Amz-Signature")
  valid_595470 = validateParameter(valid_595470, JString, required = false,
                                 default = nil)
  if valid_595470 != nil:
    section.add "X-Amz-Signature", valid_595470
  var valid_595471 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595471 = validateParameter(valid_595471, JString, required = false,
                                 default = nil)
  if valid_595471 != nil:
    section.add "X-Amz-Content-Sha256", valid_595471
  var valid_595472 = header.getOrDefault("X-Amz-Date")
  valid_595472 = validateParameter(valid_595472, JString, required = false,
                                 default = nil)
  if valid_595472 != nil:
    section.add "X-Amz-Date", valid_595472
  var valid_595473 = header.getOrDefault("X-Amz-Credential")
  valid_595473 = validateParameter(valid_595473, JString, required = false,
                                 default = nil)
  if valid_595473 != nil:
    section.add "X-Amz-Credential", valid_595473
  var valid_595474 = header.getOrDefault("X-Amz-Security-Token")
  valid_595474 = validateParameter(valid_595474, JString, required = false,
                                 default = nil)
  if valid_595474 != nil:
    section.add "X-Amz-Security-Token", valid_595474
  var valid_595475 = header.getOrDefault("X-Amz-Algorithm")
  valid_595475 = validateParameter(valid_595475, JString, required = false,
                                 default = nil)
  if valid_595475 != nil:
    section.add "X-Amz-Algorithm", valid_595475
  var valid_595476 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595476 = validateParameter(valid_595476, JString, required = false,
                                 default = nil)
  if valid_595476 != nil:
    section.add "X-Amz-SignedHeaders", valid_595476
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595477: Call_DescribeAuditFinding_595466; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ## 
  let valid = call_595477.validator(path, query, header, formData, body)
  let scheme = call_595477.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595477.url(scheme.get, call_595477.host, call_595477.base,
                         call_595477.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595477, url, valid)

proc call*(call_595478: Call_DescribeAuditFinding_595466; findingId: string): Recallable =
  ## describeAuditFinding
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ##   findingId: string (required)
  ##            : A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
  var path_595479 = newJObject()
  add(path_595479, "findingId", newJString(findingId))
  result = call_595478.call(path_595479, nil, nil, nil, nil)

var describeAuditFinding* = Call_DescribeAuditFinding_595466(
    name: "describeAuditFinding", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/findings/{findingId}",
    validator: validate_DescribeAuditFinding_595467, base: "/",
    url: url_DescribeAuditFinding_595468, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartAuditMitigationActionsTask_595494 = ref object of OpenApiRestCall_593389
proc url_StartAuditMitigationActionsTask_595496(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_StartAuditMitigationActionsTask_595495(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_595497 = path.getOrDefault("taskId")
  valid_595497 = validateParameter(valid_595497, JString, required = true,
                                 default = nil)
  if valid_595497 != nil:
    section.add "taskId", valid_595497
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595498 = header.getOrDefault("X-Amz-Signature")
  valid_595498 = validateParameter(valid_595498, JString, required = false,
                                 default = nil)
  if valid_595498 != nil:
    section.add "X-Amz-Signature", valid_595498
  var valid_595499 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595499 = validateParameter(valid_595499, JString, required = false,
                                 default = nil)
  if valid_595499 != nil:
    section.add "X-Amz-Content-Sha256", valid_595499
  var valid_595500 = header.getOrDefault("X-Amz-Date")
  valid_595500 = validateParameter(valid_595500, JString, required = false,
                                 default = nil)
  if valid_595500 != nil:
    section.add "X-Amz-Date", valid_595500
  var valid_595501 = header.getOrDefault("X-Amz-Credential")
  valid_595501 = validateParameter(valid_595501, JString, required = false,
                                 default = nil)
  if valid_595501 != nil:
    section.add "X-Amz-Credential", valid_595501
  var valid_595502 = header.getOrDefault("X-Amz-Security-Token")
  valid_595502 = validateParameter(valid_595502, JString, required = false,
                                 default = nil)
  if valid_595502 != nil:
    section.add "X-Amz-Security-Token", valid_595502
  var valid_595503 = header.getOrDefault("X-Amz-Algorithm")
  valid_595503 = validateParameter(valid_595503, JString, required = false,
                                 default = nil)
  if valid_595503 != nil:
    section.add "X-Amz-Algorithm", valid_595503
  var valid_595504 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595504 = validateParameter(valid_595504, JString, required = false,
                                 default = nil)
  if valid_595504 != nil:
    section.add "X-Amz-SignedHeaders", valid_595504
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595506: Call_StartAuditMitigationActionsTask_595494;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ## 
  let valid = call_595506.validator(path, query, header, formData, body)
  let scheme = call_595506.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595506.url(scheme.get, call_595506.host, call_595506.base,
                         call_595506.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595506, url, valid)

proc call*(call_595507: Call_StartAuditMitigationActionsTask_595494;
          body: JsonNode; taskId: string): Recallable =
  ## startAuditMitigationActionsTask
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ##   body: JObject (required)
  ##   taskId: string (required)
  ##         : A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
  var path_595508 = newJObject()
  var body_595509 = newJObject()
  if body != nil:
    body_595509 = body
  add(path_595508, "taskId", newJString(taskId))
  result = call_595507.call(path_595508, nil, nil, nil, body_595509)

var startAuditMitigationActionsTask* = Call_StartAuditMitigationActionsTask_595494(
    name: "startAuditMitigationActionsTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/audit/mitigationactions/tasks/{taskId}",
    validator: validate_StartAuditMitigationActionsTask_595495, base: "/",
    url: url_StartAuditMitigationActionsTask_595496,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditMitigationActionsTask_595480 = ref object of OpenApiRestCall_593389
proc url_DescribeAuditMitigationActionsTask_595482(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuditMitigationActionsTask_595481(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The unique identifier for the audit mitigation task.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_595483 = path.getOrDefault("taskId")
  valid_595483 = validateParameter(valid_595483, JString, required = true,
                                 default = nil)
  if valid_595483 != nil:
    section.add "taskId", valid_595483
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595484 = header.getOrDefault("X-Amz-Signature")
  valid_595484 = validateParameter(valid_595484, JString, required = false,
                                 default = nil)
  if valid_595484 != nil:
    section.add "X-Amz-Signature", valid_595484
  var valid_595485 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595485 = validateParameter(valid_595485, JString, required = false,
                                 default = nil)
  if valid_595485 != nil:
    section.add "X-Amz-Content-Sha256", valid_595485
  var valid_595486 = header.getOrDefault("X-Amz-Date")
  valid_595486 = validateParameter(valid_595486, JString, required = false,
                                 default = nil)
  if valid_595486 != nil:
    section.add "X-Amz-Date", valid_595486
  var valid_595487 = header.getOrDefault("X-Amz-Credential")
  valid_595487 = validateParameter(valid_595487, JString, required = false,
                                 default = nil)
  if valid_595487 != nil:
    section.add "X-Amz-Credential", valid_595487
  var valid_595488 = header.getOrDefault("X-Amz-Security-Token")
  valid_595488 = validateParameter(valid_595488, JString, required = false,
                                 default = nil)
  if valid_595488 != nil:
    section.add "X-Amz-Security-Token", valid_595488
  var valid_595489 = header.getOrDefault("X-Amz-Algorithm")
  valid_595489 = validateParameter(valid_595489, JString, required = false,
                                 default = nil)
  if valid_595489 != nil:
    section.add "X-Amz-Algorithm", valid_595489
  var valid_595490 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595490 = validateParameter(valid_595490, JString, required = false,
                                 default = nil)
  if valid_595490 != nil:
    section.add "X-Amz-SignedHeaders", valid_595490
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595491: Call_DescribeAuditMitigationActionsTask_595480;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ## 
  let valid = call_595491.validator(path, query, header, formData, body)
  let scheme = call_595491.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595491.url(scheme.get, call_595491.host, call_595491.base,
                         call_595491.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595491, url, valid)

proc call*(call_595492: Call_DescribeAuditMitigationActionsTask_595480;
          taskId: string): Recallable =
  ## describeAuditMitigationActionsTask
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ##   taskId: string (required)
  ##         : The unique identifier for the audit mitigation task.
  var path_595493 = newJObject()
  add(path_595493, "taskId", newJString(taskId))
  result = call_595492.call(path_595493, nil, nil, nil, nil)

var describeAuditMitigationActionsTask* = Call_DescribeAuditMitigationActionsTask_595480(
    name: "describeAuditMitigationActionsTask", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/mitigationactions/tasks/{taskId}",
    validator: validate_DescribeAuditMitigationActionsTask_595481, base: "/",
    url: url_DescribeAuditMitigationActionsTask_595482,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditTask_595510 = ref object of OpenApiRestCall_593389
proc url_DescribeAuditTask_595512(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuditTask_595511(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Gets information about a Device Defender audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The ID of the audit whose information you want to get.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_595513 = path.getOrDefault("taskId")
  valid_595513 = validateParameter(valid_595513, JString, required = true,
                                 default = nil)
  if valid_595513 != nil:
    section.add "taskId", valid_595513
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595514 = header.getOrDefault("X-Amz-Signature")
  valid_595514 = validateParameter(valid_595514, JString, required = false,
                                 default = nil)
  if valid_595514 != nil:
    section.add "X-Amz-Signature", valid_595514
  var valid_595515 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595515 = validateParameter(valid_595515, JString, required = false,
                                 default = nil)
  if valid_595515 != nil:
    section.add "X-Amz-Content-Sha256", valid_595515
  var valid_595516 = header.getOrDefault("X-Amz-Date")
  valid_595516 = validateParameter(valid_595516, JString, required = false,
                                 default = nil)
  if valid_595516 != nil:
    section.add "X-Amz-Date", valid_595516
  var valid_595517 = header.getOrDefault("X-Amz-Credential")
  valid_595517 = validateParameter(valid_595517, JString, required = false,
                                 default = nil)
  if valid_595517 != nil:
    section.add "X-Amz-Credential", valid_595517
  var valid_595518 = header.getOrDefault("X-Amz-Security-Token")
  valid_595518 = validateParameter(valid_595518, JString, required = false,
                                 default = nil)
  if valid_595518 != nil:
    section.add "X-Amz-Security-Token", valid_595518
  var valid_595519 = header.getOrDefault("X-Amz-Algorithm")
  valid_595519 = validateParameter(valid_595519, JString, required = false,
                                 default = nil)
  if valid_595519 != nil:
    section.add "X-Amz-Algorithm", valid_595519
  var valid_595520 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595520 = validateParameter(valid_595520, JString, required = false,
                                 default = nil)
  if valid_595520 != nil:
    section.add "X-Amz-SignedHeaders", valid_595520
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595521: Call_DescribeAuditTask_595510; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a Device Defender audit.
  ## 
  let valid = call_595521.validator(path, query, header, formData, body)
  let scheme = call_595521.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595521.url(scheme.get, call_595521.host, call_595521.base,
                         call_595521.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595521, url, valid)

proc call*(call_595522: Call_DescribeAuditTask_595510; taskId: string): Recallable =
  ## describeAuditTask
  ## Gets information about a Device Defender audit.
  ##   taskId: string (required)
  ##         : The ID of the audit whose information you want to get.
  var path_595523 = newJObject()
  add(path_595523, "taskId", newJString(taskId))
  result = call_595522.call(path_595523, nil, nil, nil, nil)

var describeAuditTask* = Call_DescribeAuditTask_595510(name: "describeAuditTask",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/audit/tasks/{taskId}", validator: validate_DescribeAuditTask_595511,
    base: "/", url: url_DescribeAuditTask_595512,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeEndpoint_595524 = ref object of OpenApiRestCall_593389
proc url_DescribeEndpoint_595526(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeEndpoint_595525(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Returns a unique endpoint specific to the AWS account making the call.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endpointType: JString
  ##               : <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
  section = newJObject()
  var valid_595527 = query.getOrDefault("endpointType")
  valid_595527 = validateParameter(valid_595527, JString, required = false,
                                 default = nil)
  if valid_595527 != nil:
    section.add "endpointType", valid_595527
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595528 = header.getOrDefault("X-Amz-Signature")
  valid_595528 = validateParameter(valid_595528, JString, required = false,
                                 default = nil)
  if valid_595528 != nil:
    section.add "X-Amz-Signature", valid_595528
  var valid_595529 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595529 = validateParameter(valid_595529, JString, required = false,
                                 default = nil)
  if valid_595529 != nil:
    section.add "X-Amz-Content-Sha256", valid_595529
  var valid_595530 = header.getOrDefault("X-Amz-Date")
  valid_595530 = validateParameter(valid_595530, JString, required = false,
                                 default = nil)
  if valid_595530 != nil:
    section.add "X-Amz-Date", valid_595530
  var valid_595531 = header.getOrDefault("X-Amz-Credential")
  valid_595531 = validateParameter(valid_595531, JString, required = false,
                                 default = nil)
  if valid_595531 != nil:
    section.add "X-Amz-Credential", valid_595531
  var valid_595532 = header.getOrDefault("X-Amz-Security-Token")
  valid_595532 = validateParameter(valid_595532, JString, required = false,
                                 default = nil)
  if valid_595532 != nil:
    section.add "X-Amz-Security-Token", valid_595532
  var valid_595533 = header.getOrDefault("X-Amz-Algorithm")
  valid_595533 = validateParameter(valid_595533, JString, required = false,
                                 default = nil)
  if valid_595533 != nil:
    section.add "X-Amz-Algorithm", valid_595533
  var valid_595534 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595534 = validateParameter(valid_595534, JString, required = false,
                                 default = nil)
  if valid_595534 != nil:
    section.add "X-Amz-SignedHeaders", valid_595534
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595535: Call_DescribeEndpoint_595524; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a unique endpoint specific to the AWS account making the call.
  ## 
  let valid = call_595535.validator(path, query, header, formData, body)
  let scheme = call_595535.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595535.url(scheme.get, call_595535.host, call_595535.base,
                         call_595535.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595535, url, valid)

proc call*(call_595536: Call_DescribeEndpoint_595524; endpointType: string = ""): Recallable =
  ## describeEndpoint
  ## Returns a unique endpoint specific to the AWS account making the call.
  ##   endpointType: string
  ##               : <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
  var query_595537 = newJObject()
  add(query_595537, "endpointType", newJString(endpointType))
  result = call_595536.call(nil, query_595537, nil, nil, nil)

var describeEndpoint* = Call_DescribeEndpoint_595524(name: "describeEndpoint",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/endpoint",
    validator: validate_DescribeEndpoint_595525, base: "/",
    url: url_DescribeEndpoint_595526, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeEventConfigurations_595538 = ref object of OpenApiRestCall_593389
proc url_DescribeEventConfigurations_595540(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeEventConfigurations_595539(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes event configurations.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595541 = header.getOrDefault("X-Amz-Signature")
  valid_595541 = validateParameter(valid_595541, JString, required = false,
                                 default = nil)
  if valid_595541 != nil:
    section.add "X-Amz-Signature", valid_595541
  var valid_595542 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595542 = validateParameter(valid_595542, JString, required = false,
                                 default = nil)
  if valid_595542 != nil:
    section.add "X-Amz-Content-Sha256", valid_595542
  var valid_595543 = header.getOrDefault("X-Amz-Date")
  valid_595543 = validateParameter(valid_595543, JString, required = false,
                                 default = nil)
  if valid_595543 != nil:
    section.add "X-Amz-Date", valid_595543
  var valid_595544 = header.getOrDefault("X-Amz-Credential")
  valid_595544 = validateParameter(valid_595544, JString, required = false,
                                 default = nil)
  if valid_595544 != nil:
    section.add "X-Amz-Credential", valid_595544
  var valid_595545 = header.getOrDefault("X-Amz-Security-Token")
  valid_595545 = validateParameter(valid_595545, JString, required = false,
                                 default = nil)
  if valid_595545 != nil:
    section.add "X-Amz-Security-Token", valid_595545
  var valid_595546 = header.getOrDefault("X-Amz-Algorithm")
  valid_595546 = validateParameter(valid_595546, JString, required = false,
                                 default = nil)
  if valid_595546 != nil:
    section.add "X-Amz-Algorithm", valid_595546
  var valid_595547 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595547 = validateParameter(valid_595547, JString, required = false,
                                 default = nil)
  if valid_595547 != nil:
    section.add "X-Amz-SignedHeaders", valid_595547
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595548: Call_DescribeEventConfigurations_595538; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes event configurations.
  ## 
  let valid = call_595548.validator(path, query, header, formData, body)
  let scheme = call_595548.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595548.url(scheme.get, call_595548.host, call_595548.base,
                         call_595548.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595548, url, valid)

proc call*(call_595549: Call_DescribeEventConfigurations_595538): Recallable =
  ## describeEventConfigurations
  ## Describes event configurations.
  result = call_595549.call(nil, nil, nil, nil, nil)

var describeEventConfigurations* = Call_DescribeEventConfigurations_595538(
    name: "describeEventConfigurations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/event-configurations",
    validator: validate_DescribeEventConfigurations_595539, base: "/",
    url: url_DescribeEventConfigurations_595540,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateEventConfigurations_595550 = ref object of OpenApiRestCall_593389
proc url_UpdateEventConfigurations_595552(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateEventConfigurations_595551(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the event configurations.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595553 = header.getOrDefault("X-Amz-Signature")
  valid_595553 = validateParameter(valid_595553, JString, required = false,
                                 default = nil)
  if valid_595553 != nil:
    section.add "X-Amz-Signature", valid_595553
  var valid_595554 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595554 = validateParameter(valid_595554, JString, required = false,
                                 default = nil)
  if valid_595554 != nil:
    section.add "X-Amz-Content-Sha256", valid_595554
  var valid_595555 = header.getOrDefault("X-Amz-Date")
  valid_595555 = validateParameter(valid_595555, JString, required = false,
                                 default = nil)
  if valid_595555 != nil:
    section.add "X-Amz-Date", valid_595555
  var valid_595556 = header.getOrDefault("X-Amz-Credential")
  valid_595556 = validateParameter(valid_595556, JString, required = false,
                                 default = nil)
  if valid_595556 != nil:
    section.add "X-Amz-Credential", valid_595556
  var valid_595557 = header.getOrDefault("X-Amz-Security-Token")
  valid_595557 = validateParameter(valid_595557, JString, required = false,
                                 default = nil)
  if valid_595557 != nil:
    section.add "X-Amz-Security-Token", valid_595557
  var valid_595558 = header.getOrDefault("X-Amz-Algorithm")
  valid_595558 = validateParameter(valid_595558, JString, required = false,
                                 default = nil)
  if valid_595558 != nil:
    section.add "X-Amz-Algorithm", valid_595558
  var valid_595559 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595559 = validateParameter(valid_595559, JString, required = false,
                                 default = nil)
  if valid_595559 != nil:
    section.add "X-Amz-SignedHeaders", valid_595559
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595561: Call_UpdateEventConfigurations_595550; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the event configurations.
  ## 
  let valid = call_595561.validator(path, query, header, formData, body)
  let scheme = call_595561.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595561.url(scheme.get, call_595561.host, call_595561.base,
                         call_595561.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595561, url, valid)

proc call*(call_595562: Call_UpdateEventConfigurations_595550; body: JsonNode): Recallable =
  ## updateEventConfigurations
  ## Updates the event configurations.
  ##   body: JObject (required)
  var body_595563 = newJObject()
  if body != nil:
    body_595563 = body
  result = call_595562.call(nil, nil, nil, nil, body_595563)

var updateEventConfigurations* = Call_UpdateEventConfigurations_595550(
    name: "updateEventConfigurations", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/event-configurations",
    validator: validate_UpdateEventConfigurations_595551, base: "/",
    url: url_UpdateEventConfigurations_595552,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeIndex_595564 = ref object of OpenApiRestCall_593389
proc url_DescribeIndex_595566(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "indexName" in path, "`indexName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/indices/"),
               (kind: VariableSegment, value: "indexName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeIndex_595565(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a search index.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   indexName: JString (required)
  ##            : The index name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `indexName` field"
  var valid_595567 = path.getOrDefault("indexName")
  valid_595567 = validateParameter(valid_595567, JString, required = true,
                                 default = nil)
  if valid_595567 != nil:
    section.add "indexName", valid_595567
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595568 = header.getOrDefault("X-Amz-Signature")
  valid_595568 = validateParameter(valid_595568, JString, required = false,
                                 default = nil)
  if valid_595568 != nil:
    section.add "X-Amz-Signature", valid_595568
  var valid_595569 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595569 = validateParameter(valid_595569, JString, required = false,
                                 default = nil)
  if valid_595569 != nil:
    section.add "X-Amz-Content-Sha256", valid_595569
  var valid_595570 = header.getOrDefault("X-Amz-Date")
  valid_595570 = validateParameter(valid_595570, JString, required = false,
                                 default = nil)
  if valid_595570 != nil:
    section.add "X-Amz-Date", valid_595570
  var valid_595571 = header.getOrDefault("X-Amz-Credential")
  valid_595571 = validateParameter(valid_595571, JString, required = false,
                                 default = nil)
  if valid_595571 != nil:
    section.add "X-Amz-Credential", valid_595571
  var valid_595572 = header.getOrDefault("X-Amz-Security-Token")
  valid_595572 = validateParameter(valid_595572, JString, required = false,
                                 default = nil)
  if valid_595572 != nil:
    section.add "X-Amz-Security-Token", valid_595572
  var valid_595573 = header.getOrDefault("X-Amz-Algorithm")
  valid_595573 = validateParameter(valid_595573, JString, required = false,
                                 default = nil)
  if valid_595573 != nil:
    section.add "X-Amz-Algorithm", valid_595573
  var valid_595574 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595574 = validateParameter(valid_595574, JString, required = false,
                                 default = nil)
  if valid_595574 != nil:
    section.add "X-Amz-SignedHeaders", valid_595574
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595575: Call_DescribeIndex_595564; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a search index.
  ## 
  let valid = call_595575.validator(path, query, header, formData, body)
  let scheme = call_595575.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595575.url(scheme.get, call_595575.host, call_595575.base,
                         call_595575.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595575, url, valid)

proc call*(call_595576: Call_DescribeIndex_595564; indexName: string): Recallable =
  ## describeIndex
  ## Describes a search index.
  ##   indexName: string (required)
  ##            : The index name.
  var path_595577 = newJObject()
  add(path_595577, "indexName", newJString(indexName))
  result = call_595576.call(path_595577, nil, nil, nil, nil)

var describeIndex* = Call_DescribeIndex_595564(name: "describeIndex",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/indices/{indexName}", validator: validate_DescribeIndex_595565,
    base: "/", url: url_DescribeIndex_595566, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeJobExecution_595578 = ref object of OpenApiRestCall_593389
proc url_DescribeJobExecution_595580(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeJobExecution_595579(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a job execution.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   thingName: JString (required)
  ##            : The name of the thing on which the job execution is running.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_595581 = path.getOrDefault("jobId")
  valid_595581 = validateParameter(valid_595581, JString, required = true,
                                 default = nil)
  if valid_595581 != nil:
    section.add "jobId", valid_595581
  var valid_595582 = path.getOrDefault("thingName")
  valid_595582 = validateParameter(valid_595582, JString, required = true,
                                 default = nil)
  if valid_595582 != nil:
    section.add "thingName", valid_595582
  result.add "path", section
  ## parameters in `query` object:
  ##   executionNumber: JInt
  ##                  : A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
  section = newJObject()
  var valid_595583 = query.getOrDefault("executionNumber")
  valid_595583 = validateParameter(valid_595583, JInt, required = false, default = nil)
  if valid_595583 != nil:
    section.add "executionNumber", valid_595583
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595584 = header.getOrDefault("X-Amz-Signature")
  valid_595584 = validateParameter(valid_595584, JString, required = false,
                                 default = nil)
  if valid_595584 != nil:
    section.add "X-Amz-Signature", valid_595584
  var valid_595585 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595585 = validateParameter(valid_595585, JString, required = false,
                                 default = nil)
  if valid_595585 != nil:
    section.add "X-Amz-Content-Sha256", valid_595585
  var valid_595586 = header.getOrDefault("X-Amz-Date")
  valid_595586 = validateParameter(valid_595586, JString, required = false,
                                 default = nil)
  if valid_595586 != nil:
    section.add "X-Amz-Date", valid_595586
  var valid_595587 = header.getOrDefault("X-Amz-Credential")
  valid_595587 = validateParameter(valid_595587, JString, required = false,
                                 default = nil)
  if valid_595587 != nil:
    section.add "X-Amz-Credential", valid_595587
  var valid_595588 = header.getOrDefault("X-Amz-Security-Token")
  valid_595588 = validateParameter(valid_595588, JString, required = false,
                                 default = nil)
  if valid_595588 != nil:
    section.add "X-Amz-Security-Token", valid_595588
  var valid_595589 = header.getOrDefault("X-Amz-Algorithm")
  valid_595589 = validateParameter(valid_595589, JString, required = false,
                                 default = nil)
  if valid_595589 != nil:
    section.add "X-Amz-Algorithm", valid_595589
  var valid_595590 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595590 = validateParameter(valid_595590, JString, required = false,
                                 default = nil)
  if valid_595590 != nil:
    section.add "X-Amz-SignedHeaders", valid_595590
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595591: Call_DescribeJobExecution_595578; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a job execution.
  ## 
  let valid = call_595591.validator(path, query, header, formData, body)
  let scheme = call_595591.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595591.url(scheme.get, call_595591.host, call_595591.base,
                         call_595591.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595591, url, valid)

proc call*(call_595592: Call_DescribeJobExecution_595578; jobId: string;
          thingName: string; executionNumber: int = 0): Recallable =
  ## describeJobExecution
  ## Describes a job execution.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   executionNumber: int
  ##                  : A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
  ##   thingName: string (required)
  ##            : The name of the thing on which the job execution is running.
  var path_595593 = newJObject()
  var query_595594 = newJObject()
  add(path_595593, "jobId", newJString(jobId))
  add(query_595594, "executionNumber", newJInt(executionNumber))
  add(path_595593, "thingName", newJString(thingName))
  result = call_595592.call(path_595593, query_595594, nil, nil, nil)

var describeJobExecution* = Call_DescribeJobExecution_595578(
    name: "describeJobExecution", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs/{jobId}",
    validator: validate_DescribeJobExecution_595579, base: "/",
    url: url_DescribeJobExecution_595580, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingRegistrationTask_595595 = ref object of OpenApiRestCall_593389
proc url_DescribeThingRegistrationTask_595597(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThingRegistrationTask_595596(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The task ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_595598 = path.getOrDefault("taskId")
  valid_595598 = validateParameter(valid_595598, JString, required = true,
                                 default = nil)
  if valid_595598 != nil:
    section.add "taskId", valid_595598
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595599 = header.getOrDefault("X-Amz-Signature")
  valid_595599 = validateParameter(valid_595599, JString, required = false,
                                 default = nil)
  if valid_595599 != nil:
    section.add "X-Amz-Signature", valid_595599
  var valid_595600 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595600 = validateParameter(valid_595600, JString, required = false,
                                 default = nil)
  if valid_595600 != nil:
    section.add "X-Amz-Content-Sha256", valid_595600
  var valid_595601 = header.getOrDefault("X-Amz-Date")
  valid_595601 = validateParameter(valid_595601, JString, required = false,
                                 default = nil)
  if valid_595601 != nil:
    section.add "X-Amz-Date", valid_595601
  var valid_595602 = header.getOrDefault("X-Amz-Credential")
  valid_595602 = validateParameter(valid_595602, JString, required = false,
                                 default = nil)
  if valid_595602 != nil:
    section.add "X-Amz-Credential", valid_595602
  var valid_595603 = header.getOrDefault("X-Amz-Security-Token")
  valid_595603 = validateParameter(valid_595603, JString, required = false,
                                 default = nil)
  if valid_595603 != nil:
    section.add "X-Amz-Security-Token", valid_595603
  var valid_595604 = header.getOrDefault("X-Amz-Algorithm")
  valid_595604 = validateParameter(valid_595604, JString, required = false,
                                 default = nil)
  if valid_595604 != nil:
    section.add "X-Amz-Algorithm", valid_595604
  var valid_595605 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595605 = validateParameter(valid_595605, JString, required = false,
                                 default = nil)
  if valid_595605 != nil:
    section.add "X-Amz-SignedHeaders", valid_595605
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595606: Call_DescribeThingRegistrationTask_595595; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a bulk thing provisioning task.
  ## 
  let valid = call_595606.validator(path, query, header, formData, body)
  let scheme = call_595606.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595606.url(scheme.get, call_595606.host, call_595606.base,
                         call_595606.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595606, url, valid)

proc call*(call_595607: Call_DescribeThingRegistrationTask_595595; taskId: string): Recallable =
  ## describeThingRegistrationTask
  ## Describes a bulk thing provisioning task.
  ##   taskId: string (required)
  ##         : The task ID.
  var path_595608 = newJObject()
  add(path_595608, "taskId", newJString(taskId))
  result = call_595607.call(path_595608, nil, nil, nil, nil)

var describeThingRegistrationTask* = Call_DescribeThingRegistrationTask_595595(
    name: "describeThingRegistrationTask", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks/{taskId}",
    validator: validate_DescribeThingRegistrationTask_595596, base: "/",
    url: url_DescribeThingRegistrationTask_595597,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DisableTopicRule_595609 = ref object of OpenApiRestCall_593389
proc url_DisableTopicRule_595611(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName"),
               (kind: ConstantSegment, value: "/disable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DisableTopicRule_595610(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Disables the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule to disable.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_595612 = path.getOrDefault("ruleName")
  valid_595612 = validateParameter(valid_595612, JString, required = true,
                                 default = nil)
  if valid_595612 != nil:
    section.add "ruleName", valid_595612
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595613 = header.getOrDefault("X-Amz-Signature")
  valid_595613 = validateParameter(valid_595613, JString, required = false,
                                 default = nil)
  if valid_595613 != nil:
    section.add "X-Amz-Signature", valid_595613
  var valid_595614 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595614 = validateParameter(valid_595614, JString, required = false,
                                 default = nil)
  if valid_595614 != nil:
    section.add "X-Amz-Content-Sha256", valid_595614
  var valid_595615 = header.getOrDefault("X-Amz-Date")
  valid_595615 = validateParameter(valid_595615, JString, required = false,
                                 default = nil)
  if valid_595615 != nil:
    section.add "X-Amz-Date", valid_595615
  var valid_595616 = header.getOrDefault("X-Amz-Credential")
  valid_595616 = validateParameter(valid_595616, JString, required = false,
                                 default = nil)
  if valid_595616 != nil:
    section.add "X-Amz-Credential", valid_595616
  var valid_595617 = header.getOrDefault("X-Amz-Security-Token")
  valid_595617 = validateParameter(valid_595617, JString, required = false,
                                 default = nil)
  if valid_595617 != nil:
    section.add "X-Amz-Security-Token", valid_595617
  var valid_595618 = header.getOrDefault("X-Amz-Algorithm")
  valid_595618 = validateParameter(valid_595618, JString, required = false,
                                 default = nil)
  if valid_595618 != nil:
    section.add "X-Amz-Algorithm", valid_595618
  var valid_595619 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595619 = validateParameter(valid_595619, JString, required = false,
                                 default = nil)
  if valid_595619 != nil:
    section.add "X-Amz-SignedHeaders", valid_595619
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595620: Call_DisableTopicRule_595609; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Disables the rule.
  ## 
  let valid = call_595620.validator(path, query, header, formData, body)
  let scheme = call_595620.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595620.url(scheme.get, call_595620.host, call_595620.base,
                         call_595620.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595620, url, valid)

proc call*(call_595621: Call_DisableTopicRule_595609; ruleName: string): Recallable =
  ## disableTopicRule
  ## Disables the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule to disable.
  var path_595622 = newJObject()
  add(path_595622, "ruleName", newJString(ruleName))
  result = call_595621.call(path_595622, nil, nil, nil, nil)

var disableTopicRule* = Call_DisableTopicRule_595609(name: "disableTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}/disable", validator: validate_DisableTopicRule_595610,
    base: "/", url: url_DisableTopicRule_595611,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_EnableTopicRule_595623 = ref object of OpenApiRestCall_593389
proc url_EnableTopicRule_595625(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName"),
               (kind: ConstantSegment, value: "/enable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_EnableTopicRule_595624(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Enables the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the topic rule to enable.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_595626 = path.getOrDefault("ruleName")
  valid_595626 = validateParameter(valid_595626, JString, required = true,
                                 default = nil)
  if valid_595626 != nil:
    section.add "ruleName", valid_595626
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595627 = header.getOrDefault("X-Amz-Signature")
  valid_595627 = validateParameter(valid_595627, JString, required = false,
                                 default = nil)
  if valid_595627 != nil:
    section.add "X-Amz-Signature", valid_595627
  var valid_595628 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595628 = validateParameter(valid_595628, JString, required = false,
                                 default = nil)
  if valid_595628 != nil:
    section.add "X-Amz-Content-Sha256", valid_595628
  var valid_595629 = header.getOrDefault("X-Amz-Date")
  valid_595629 = validateParameter(valid_595629, JString, required = false,
                                 default = nil)
  if valid_595629 != nil:
    section.add "X-Amz-Date", valid_595629
  var valid_595630 = header.getOrDefault("X-Amz-Credential")
  valid_595630 = validateParameter(valid_595630, JString, required = false,
                                 default = nil)
  if valid_595630 != nil:
    section.add "X-Amz-Credential", valid_595630
  var valid_595631 = header.getOrDefault("X-Amz-Security-Token")
  valid_595631 = validateParameter(valid_595631, JString, required = false,
                                 default = nil)
  if valid_595631 != nil:
    section.add "X-Amz-Security-Token", valid_595631
  var valid_595632 = header.getOrDefault("X-Amz-Algorithm")
  valid_595632 = validateParameter(valid_595632, JString, required = false,
                                 default = nil)
  if valid_595632 != nil:
    section.add "X-Amz-Algorithm", valid_595632
  var valid_595633 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595633 = validateParameter(valid_595633, JString, required = false,
                                 default = nil)
  if valid_595633 != nil:
    section.add "X-Amz-SignedHeaders", valid_595633
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595634: Call_EnableTopicRule_595623; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the rule.
  ## 
  let valid = call_595634.validator(path, query, header, formData, body)
  let scheme = call_595634.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595634.url(scheme.get, call_595634.host, call_595634.base,
                         call_595634.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595634, url, valid)

proc call*(call_595635: Call_EnableTopicRule_595623; ruleName: string): Recallable =
  ## enableTopicRule
  ## Enables the rule.
  ##   ruleName: string (required)
  ##           : The name of the topic rule to enable.
  var path_595636 = newJObject()
  add(path_595636, "ruleName", newJString(ruleName))
  result = call_595635.call(path_595636, nil, nil, nil, nil)

var enableTopicRule* = Call_EnableTopicRule_595623(name: "enableTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}/enable", validator: validate_EnableTopicRule_595624,
    base: "/", url: url_EnableTopicRule_595625, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCardinality_595637 = ref object of OpenApiRestCall_593389
proc url_GetCardinality_595639(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCardinality_595638(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Returns the number of things with distinct values for the aggregation field. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595640 = header.getOrDefault("X-Amz-Signature")
  valid_595640 = validateParameter(valid_595640, JString, required = false,
                                 default = nil)
  if valid_595640 != nil:
    section.add "X-Amz-Signature", valid_595640
  var valid_595641 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595641 = validateParameter(valid_595641, JString, required = false,
                                 default = nil)
  if valid_595641 != nil:
    section.add "X-Amz-Content-Sha256", valid_595641
  var valid_595642 = header.getOrDefault("X-Amz-Date")
  valid_595642 = validateParameter(valid_595642, JString, required = false,
                                 default = nil)
  if valid_595642 != nil:
    section.add "X-Amz-Date", valid_595642
  var valid_595643 = header.getOrDefault("X-Amz-Credential")
  valid_595643 = validateParameter(valid_595643, JString, required = false,
                                 default = nil)
  if valid_595643 != nil:
    section.add "X-Amz-Credential", valid_595643
  var valid_595644 = header.getOrDefault("X-Amz-Security-Token")
  valid_595644 = validateParameter(valid_595644, JString, required = false,
                                 default = nil)
  if valid_595644 != nil:
    section.add "X-Amz-Security-Token", valid_595644
  var valid_595645 = header.getOrDefault("X-Amz-Algorithm")
  valid_595645 = validateParameter(valid_595645, JString, required = false,
                                 default = nil)
  if valid_595645 != nil:
    section.add "X-Amz-Algorithm", valid_595645
  var valid_595646 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595646 = validateParameter(valid_595646, JString, required = false,
                                 default = nil)
  if valid_595646 != nil:
    section.add "X-Amz-SignedHeaders", valid_595646
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595648: Call_GetCardinality_595637; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the number of things with distinct values for the aggregation field. 
  ## 
  let valid = call_595648.validator(path, query, header, formData, body)
  let scheme = call_595648.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595648.url(scheme.get, call_595648.host, call_595648.base,
                         call_595648.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595648, url, valid)

proc call*(call_595649: Call_GetCardinality_595637; body: JsonNode): Recallable =
  ## getCardinality
  ## Returns the number of things with distinct values for the aggregation field. 
  ##   body: JObject (required)
  var body_595650 = newJObject()
  if body != nil:
    body_595650 = body
  result = call_595649.call(nil, nil, nil, nil, body_595650)

var getCardinality* = Call_GetCardinality_595637(name: "getCardinality",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/cardinality", validator: validate_GetCardinality_595638,
    base: "/", url: url_GetCardinality_595639, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEffectivePolicies_595651 = ref object of OpenApiRestCall_593389
proc url_GetEffectivePolicies_595653(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEffectivePolicies_595652(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingName: JString
  ##            : The thing name.
  section = newJObject()
  var valid_595654 = query.getOrDefault("thingName")
  valid_595654 = validateParameter(valid_595654, JString, required = false,
                                 default = nil)
  if valid_595654 != nil:
    section.add "thingName", valid_595654
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595655 = header.getOrDefault("X-Amz-Signature")
  valid_595655 = validateParameter(valid_595655, JString, required = false,
                                 default = nil)
  if valid_595655 != nil:
    section.add "X-Amz-Signature", valid_595655
  var valid_595656 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595656 = validateParameter(valid_595656, JString, required = false,
                                 default = nil)
  if valid_595656 != nil:
    section.add "X-Amz-Content-Sha256", valid_595656
  var valid_595657 = header.getOrDefault("X-Amz-Date")
  valid_595657 = validateParameter(valid_595657, JString, required = false,
                                 default = nil)
  if valid_595657 != nil:
    section.add "X-Amz-Date", valid_595657
  var valid_595658 = header.getOrDefault("X-Amz-Credential")
  valid_595658 = validateParameter(valid_595658, JString, required = false,
                                 default = nil)
  if valid_595658 != nil:
    section.add "X-Amz-Credential", valid_595658
  var valid_595659 = header.getOrDefault("X-Amz-Security-Token")
  valid_595659 = validateParameter(valid_595659, JString, required = false,
                                 default = nil)
  if valid_595659 != nil:
    section.add "X-Amz-Security-Token", valid_595659
  var valid_595660 = header.getOrDefault("X-Amz-Algorithm")
  valid_595660 = validateParameter(valid_595660, JString, required = false,
                                 default = nil)
  if valid_595660 != nil:
    section.add "X-Amz-Algorithm", valid_595660
  var valid_595661 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595661 = validateParameter(valid_595661, JString, required = false,
                                 default = nil)
  if valid_595661 != nil:
    section.add "X-Amz-SignedHeaders", valid_595661
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595663: Call_GetEffectivePolicies_595651; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ## 
  let valid = call_595663.validator(path, query, header, formData, body)
  let scheme = call_595663.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595663.url(scheme.get, call_595663.host, call_595663.base,
                         call_595663.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595663, url, valid)

proc call*(call_595664: Call_GetEffectivePolicies_595651; body: JsonNode;
          thingName: string = ""): Recallable =
  ## getEffectivePolicies
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ##   thingName: string
  ##            : The thing name.
  ##   body: JObject (required)
  var query_595665 = newJObject()
  var body_595666 = newJObject()
  add(query_595665, "thingName", newJString(thingName))
  if body != nil:
    body_595666 = body
  result = call_595664.call(nil, query_595665, nil, nil, body_595666)

var getEffectivePolicies* = Call_GetEffectivePolicies_595651(
    name: "getEffectivePolicies", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/effective-policies",
    validator: validate_GetEffectivePolicies_595652, base: "/",
    url: url_GetEffectivePolicies_595653, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateIndexingConfiguration_595679 = ref object of OpenApiRestCall_593389
proc url_UpdateIndexingConfiguration_595681(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateIndexingConfiguration_595680(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the search configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595682 = header.getOrDefault("X-Amz-Signature")
  valid_595682 = validateParameter(valid_595682, JString, required = false,
                                 default = nil)
  if valid_595682 != nil:
    section.add "X-Amz-Signature", valid_595682
  var valid_595683 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595683 = validateParameter(valid_595683, JString, required = false,
                                 default = nil)
  if valid_595683 != nil:
    section.add "X-Amz-Content-Sha256", valid_595683
  var valid_595684 = header.getOrDefault("X-Amz-Date")
  valid_595684 = validateParameter(valid_595684, JString, required = false,
                                 default = nil)
  if valid_595684 != nil:
    section.add "X-Amz-Date", valid_595684
  var valid_595685 = header.getOrDefault("X-Amz-Credential")
  valid_595685 = validateParameter(valid_595685, JString, required = false,
                                 default = nil)
  if valid_595685 != nil:
    section.add "X-Amz-Credential", valid_595685
  var valid_595686 = header.getOrDefault("X-Amz-Security-Token")
  valid_595686 = validateParameter(valid_595686, JString, required = false,
                                 default = nil)
  if valid_595686 != nil:
    section.add "X-Amz-Security-Token", valid_595686
  var valid_595687 = header.getOrDefault("X-Amz-Algorithm")
  valid_595687 = validateParameter(valid_595687, JString, required = false,
                                 default = nil)
  if valid_595687 != nil:
    section.add "X-Amz-Algorithm", valid_595687
  var valid_595688 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595688 = validateParameter(valid_595688, JString, required = false,
                                 default = nil)
  if valid_595688 != nil:
    section.add "X-Amz-SignedHeaders", valid_595688
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595690: Call_UpdateIndexingConfiguration_595679; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the search configuration.
  ## 
  let valid = call_595690.validator(path, query, header, formData, body)
  let scheme = call_595690.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595690.url(scheme.get, call_595690.host, call_595690.base,
                         call_595690.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595690, url, valid)

proc call*(call_595691: Call_UpdateIndexingConfiguration_595679; body: JsonNode): Recallable =
  ## updateIndexingConfiguration
  ## Updates the search configuration.
  ##   body: JObject (required)
  var body_595692 = newJObject()
  if body != nil:
    body_595692 = body
  result = call_595691.call(nil, nil, nil, nil, body_595692)

var updateIndexingConfiguration* = Call_UpdateIndexingConfiguration_595679(
    name: "updateIndexingConfiguration", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/indexing/config",
    validator: validate_UpdateIndexingConfiguration_595680, base: "/",
    url: url_UpdateIndexingConfiguration_595681,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetIndexingConfiguration_595667 = ref object of OpenApiRestCall_593389
proc url_GetIndexingConfiguration_595669(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetIndexingConfiguration_595668(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the search configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595670 = header.getOrDefault("X-Amz-Signature")
  valid_595670 = validateParameter(valid_595670, JString, required = false,
                                 default = nil)
  if valid_595670 != nil:
    section.add "X-Amz-Signature", valid_595670
  var valid_595671 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595671 = validateParameter(valid_595671, JString, required = false,
                                 default = nil)
  if valid_595671 != nil:
    section.add "X-Amz-Content-Sha256", valid_595671
  var valid_595672 = header.getOrDefault("X-Amz-Date")
  valid_595672 = validateParameter(valid_595672, JString, required = false,
                                 default = nil)
  if valid_595672 != nil:
    section.add "X-Amz-Date", valid_595672
  var valid_595673 = header.getOrDefault("X-Amz-Credential")
  valid_595673 = validateParameter(valid_595673, JString, required = false,
                                 default = nil)
  if valid_595673 != nil:
    section.add "X-Amz-Credential", valid_595673
  var valid_595674 = header.getOrDefault("X-Amz-Security-Token")
  valid_595674 = validateParameter(valid_595674, JString, required = false,
                                 default = nil)
  if valid_595674 != nil:
    section.add "X-Amz-Security-Token", valid_595674
  var valid_595675 = header.getOrDefault("X-Amz-Algorithm")
  valid_595675 = validateParameter(valid_595675, JString, required = false,
                                 default = nil)
  if valid_595675 != nil:
    section.add "X-Amz-Algorithm", valid_595675
  var valid_595676 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595676 = validateParameter(valid_595676, JString, required = false,
                                 default = nil)
  if valid_595676 != nil:
    section.add "X-Amz-SignedHeaders", valid_595676
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595677: Call_GetIndexingConfiguration_595667; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the search configuration.
  ## 
  let valid = call_595677.validator(path, query, header, formData, body)
  let scheme = call_595677.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595677.url(scheme.get, call_595677.host, call_595677.base,
                         call_595677.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595677, url, valid)

proc call*(call_595678: Call_GetIndexingConfiguration_595667): Recallable =
  ## getIndexingConfiguration
  ## Gets the search configuration.
  result = call_595678.call(nil, nil, nil, nil, nil)

var getIndexingConfiguration* = Call_GetIndexingConfiguration_595667(
    name: "getIndexingConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/indexing/config",
    validator: validate_GetIndexingConfiguration_595668, base: "/",
    url: url_GetIndexingConfiguration_595669, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetJobDocument_595693 = ref object of OpenApiRestCall_593389
proc url_GetJobDocument_595695(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/job-document")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetJobDocument_595694(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets a job document.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_595696 = path.getOrDefault("jobId")
  valid_595696 = validateParameter(valid_595696, JString, required = true,
                                 default = nil)
  if valid_595696 != nil:
    section.add "jobId", valid_595696
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595697 = header.getOrDefault("X-Amz-Signature")
  valid_595697 = validateParameter(valid_595697, JString, required = false,
                                 default = nil)
  if valid_595697 != nil:
    section.add "X-Amz-Signature", valid_595697
  var valid_595698 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595698 = validateParameter(valid_595698, JString, required = false,
                                 default = nil)
  if valid_595698 != nil:
    section.add "X-Amz-Content-Sha256", valid_595698
  var valid_595699 = header.getOrDefault("X-Amz-Date")
  valid_595699 = validateParameter(valid_595699, JString, required = false,
                                 default = nil)
  if valid_595699 != nil:
    section.add "X-Amz-Date", valid_595699
  var valid_595700 = header.getOrDefault("X-Amz-Credential")
  valid_595700 = validateParameter(valid_595700, JString, required = false,
                                 default = nil)
  if valid_595700 != nil:
    section.add "X-Amz-Credential", valid_595700
  var valid_595701 = header.getOrDefault("X-Amz-Security-Token")
  valid_595701 = validateParameter(valid_595701, JString, required = false,
                                 default = nil)
  if valid_595701 != nil:
    section.add "X-Amz-Security-Token", valid_595701
  var valid_595702 = header.getOrDefault("X-Amz-Algorithm")
  valid_595702 = validateParameter(valid_595702, JString, required = false,
                                 default = nil)
  if valid_595702 != nil:
    section.add "X-Amz-Algorithm", valid_595702
  var valid_595703 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595703 = validateParameter(valid_595703, JString, required = false,
                                 default = nil)
  if valid_595703 != nil:
    section.add "X-Amz-SignedHeaders", valid_595703
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595704: Call_GetJobDocument_595693; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a job document.
  ## 
  let valid = call_595704.validator(path, query, header, formData, body)
  let scheme = call_595704.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595704.url(scheme.get, call_595704.host, call_595704.base,
                         call_595704.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595704, url, valid)

proc call*(call_595705: Call_GetJobDocument_595693; jobId: string): Recallable =
  ## getJobDocument
  ## Gets a job document.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  var path_595706 = newJObject()
  add(path_595706, "jobId", newJString(jobId))
  result = call_595705.call(path_595706, nil, nil, nil, nil)

var getJobDocument* = Call_GetJobDocument_595693(name: "getJobDocument",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/jobs/{jobId}/job-document", validator: validate_GetJobDocument_595694,
    base: "/", url: url_GetJobDocument_595695, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetLoggingOptions_595719 = ref object of OpenApiRestCall_593389
proc url_SetLoggingOptions_595721(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetLoggingOptions_595720(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595722 = header.getOrDefault("X-Amz-Signature")
  valid_595722 = validateParameter(valid_595722, JString, required = false,
                                 default = nil)
  if valid_595722 != nil:
    section.add "X-Amz-Signature", valid_595722
  var valid_595723 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595723 = validateParameter(valid_595723, JString, required = false,
                                 default = nil)
  if valid_595723 != nil:
    section.add "X-Amz-Content-Sha256", valid_595723
  var valid_595724 = header.getOrDefault("X-Amz-Date")
  valid_595724 = validateParameter(valid_595724, JString, required = false,
                                 default = nil)
  if valid_595724 != nil:
    section.add "X-Amz-Date", valid_595724
  var valid_595725 = header.getOrDefault("X-Amz-Credential")
  valid_595725 = validateParameter(valid_595725, JString, required = false,
                                 default = nil)
  if valid_595725 != nil:
    section.add "X-Amz-Credential", valid_595725
  var valid_595726 = header.getOrDefault("X-Amz-Security-Token")
  valid_595726 = validateParameter(valid_595726, JString, required = false,
                                 default = nil)
  if valid_595726 != nil:
    section.add "X-Amz-Security-Token", valid_595726
  var valid_595727 = header.getOrDefault("X-Amz-Algorithm")
  valid_595727 = validateParameter(valid_595727, JString, required = false,
                                 default = nil)
  if valid_595727 != nil:
    section.add "X-Amz-Algorithm", valid_595727
  var valid_595728 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595728 = validateParameter(valid_595728, JString, required = false,
                                 default = nil)
  if valid_595728 != nil:
    section.add "X-Amz-SignedHeaders", valid_595728
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595730: Call_SetLoggingOptions_595719; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ## 
  let valid = call_595730.validator(path, query, header, formData, body)
  let scheme = call_595730.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595730.url(scheme.get, call_595730.host, call_595730.base,
                         call_595730.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595730, url, valid)

proc call*(call_595731: Call_SetLoggingOptions_595719; body: JsonNode): Recallable =
  ## setLoggingOptions
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ##   body: JObject (required)
  var body_595732 = newJObject()
  if body != nil:
    body_595732 = body
  result = call_595731.call(nil, nil, nil, nil, body_595732)

var setLoggingOptions* = Call_SetLoggingOptions_595719(name: "setLoggingOptions",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/loggingOptions",
    validator: validate_SetLoggingOptions_595720, base: "/",
    url: url_SetLoggingOptions_595721, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetLoggingOptions_595707 = ref object of OpenApiRestCall_593389
proc url_GetLoggingOptions_595709(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetLoggingOptions_595708(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595710 = header.getOrDefault("X-Amz-Signature")
  valid_595710 = validateParameter(valid_595710, JString, required = false,
                                 default = nil)
  if valid_595710 != nil:
    section.add "X-Amz-Signature", valid_595710
  var valid_595711 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595711 = validateParameter(valid_595711, JString, required = false,
                                 default = nil)
  if valid_595711 != nil:
    section.add "X-Amz-Content-Sha256", valid_595711
  var valid_595712 = header.getOrDefault("X-Amz-Date")
  valid_595712 = validateParameter(valid_595712, JString, required = false,
                                 default = nil)
  if valid_595712 != nil:
    section.add "X-Amz-Date", valid_595712
  var valid_595713 = header.getOrDefault("X-Amz-Credential")
  valid_595713 = validateParameter(valid_595713, JString, required = false,
                                 default = nil)
  if valid_595713 != nil:
    section.add "X-Amz-Credential", valid_595713
  var valid_595714 = header.getOrDefault("X-Amz-Security-Token")
  valid_595714 = validateParameter(valid_595714, JString, required = false,
                                 default = nil)
  if valid_595714 != nil:
    section.add "X-Amz-Security-Token", valid_595714
  var valid_595715 = header.getOrDefault("X-Amz-Algorithm")
  valid_595715 = validateParameter(valid_595715, JString, required = false,
                                 default = nil)
  if valid_595715 != nil:
    section.add "X-Amz-Algorithm", valid_595715
  var valid_595716 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595716 = validateParameter(valid_595716, JString, required = false,
                                 default = nil)
  if valid_595716 != nil:
    section.add "X-Amz-SignedHeaders", valid_595716
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595717: Call_GetLoggingOptions_595707; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  ## 
  let valid = call_595717.validator(path, query, header, formData, body)
  let scheme = call_595717.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595717.url(scheme.get, call_595717.host, call_595717.base,
                         call_595717.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595717, url, valid)

proc call*(call_595718: Call_GetLoggingOptions_595707): Recallable =
  ## getLoggingOptions
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  result = call_595718.call(nil, nil, nil, nil, nil)

var getLoggingOptions* = Call_GetLoggingOptions_595707(name: "getLoggingOptions",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/loggingOptions",
    validator: validate_GetLoggingOptions_595708, base: "/",
    url: url_GetLoggingOptions_595709, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPercentiles_595733 = ref object of OpenApiRestCall_593389
proc url_GetPercentiles_595735(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetPercentiles_595734(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Returns the percentile values for the aggregation field. The results from GetPercentiles is an approximation. The default percentile groupings are: 1,5,25,50,75,95,99. You can specify custom percentile grouping using the percents argument to the GetPercentiles API.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595736 = header.getOrDefault("X-Amz-Signature")
  valid_595736 = validateParameter(valid_595736, JString, required = false,
                                 default = nil)
  if valid_595736 != nil:
    section.add "X-Amz-Signature", valid_595736
  var valid_595737 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595737 = validateParameter(valid_595737, JString, required = false,
                                 default = nil)
  if valid_595737 != nil:
    section.add "X-Amz-Content-Sha256", valid_595737
  var valid_595738 = header.getOrDefault("X-Amz-Date")
  valid_595738 = validateParameter(valid_595738, JString, required = false,
                                 default = nil)
  if valid_595738 != nil:
    section.add "X-Amz-Date", valid_595738
  var valid_595739 = header.getOrDefault("X-Amz-Credential")
  valid_595739 = validateParameter(valid_595739, JString, required = false,
                                 default = nil)
  if valid_595739 != nil:
    section.add "X-Amz-Credential", valid_595739
  var valid_595740 = header.getOrDefault("X-Amz-Security-Token")
  valid_595740 = validateParameter(valid_595740, JString, required = false,
                                 default = nil)
  if valid_595740 != nil:
    section.add "X-Amz-Security-Token", valid_595740
  var valid_595741 = header.getOrDefault("X-Amz-Algorithm")
  valid_595741 = validateParameter(valid_595741, JString, required = false,
                                 default = nil)
  if valid_595741 != nil:
    section.add "X-Amz-Algorithm", valid_595741
  var valid_595742 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595742 = validateParameter(valid_595742, JString, required = false,
                                 default = nil)
  if valid_595742 != nil:
    section.add "X-Amz-SignedHeaders", valid_595742
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595744: Call_GetPercentiles_595733; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the percentile values for the aggregation field. The results from GetPercentiles is an approximation. The default percentile groupings are: 1,5,25,50,75,95,99. You can specify custom percentile grouping using the percents argument to the GetPercentiles API.
  ## 
  let valid = call_595744.validator(path, query, header, formData, body)
  let scheme = call_595744.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595744.url(scheme.get, call_595744.host, call_595744.base,
                         call_595744.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595744, url, valid)

proc call*(call_595745: Call_GetPercentiles_595733; body: JsonNode): Recallable =
  ## getPercentiles
  ## Returns the percentile values for the aggregation field. The results from GetPercentiles is an approximation. The default percentile groupings are: 1,5,25,50,75,95,99. You can specify custom percentile grouping using the percents argument to the GetPercentiles API.
  ##   body: JObject (required)
  var body_595746 = newJObject()
  if body != nil:
    body_595746 = body
  result = call_595745.call(nil, nil, nil, nil, body_595746)

var getPercentiles* = Call_GetPercentiles_595733(name: "getPercentiles",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/percentiles", validator: validate_GetPercentiles_595734,
    base: "/", url: url_GetPercentiles_595735, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetStatistics_595747 = ref object of OpenApiRestCall_593389
proc url_GetStatistics_595749(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetStatistics_595748(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets statistics returns the count, average, sum, minimum, maximum, sumOfSquares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type String, only the count statistic is returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595750 = header.getOrDefault("X-Amz-Signature")
  valid_595750 = validateParameter(valid_595750, JString, required = false,
                                 default = nil)
  if valid_595750 != nil:
    section.add "X-Amz-Signature", valid_595750
  var valid_595751 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595751 = validateParameter(valid_595751, JString, required = false,
                                 default = nil)
  if valid_595751 != nil:
    section.add "X-Amz-Content-Sha256", valid_595751
  var valid_595752 = header.getOrDefault("X-Amz-Date")
  valid_595752 = validateParameter(valid_595752, JString, required = false,
                                 default = nil)
  if valid_595752 != nil:
    section.add "X-Amz-Date", valid_595752
  var valid_595753 = header.getOrDefault("X-Amz-Credential")
  valid_595753 = validateParameter(valid_595753, JString, required = false,
                                 default = nil)
  if valid_595753 != nil:
    section.add "X-Amz-Credential", valid_595753
  var valid_595754 = header.getOrDefault("X-Amz-Security-Token")
  valid_595754 = validateParameter(valid_595754, JString, required = false,
                                 default = nil)
  if valid_595754 != nil:
    section.add "X-Amz-Security-Token", valid_595754
  var valid_595755 = header.getOrDefault("X-Amz-Algorithm")
  valid_595755 = validateParameter(valid_595755, JString, required = false,
                                 default = nil)
  if valid_595755 != nil:
    section.add "X-Amz-Algorithm", valid_595755
  var valid_595756 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595756 = validateParameter(valid_595756, JString, required = false,
                                 default = nil)
  if valid_595756 != nil:
    section.add "X-Amz-SignedHeaders", valid_595756
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595758: Call_GetStatistics_595747; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets statistics returns the count, average, sum, minimum, maximum, sumOfSquares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type String, only the count statistic is returned.
  ## 
  let valid = call_595758.validator(path, query, header, formData, body)
  let scheme = call_595758.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595758.url(scheme.get, call_595758.host, call_595758.base,
                         call_595758.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595758, url, valid)

proc call*(call_595759: Call_GetStatistics_595747; body: JsonNode): Recallable =
  ## getStatistics
  ## Gets statistics returns the count, average, sum, minimum, maximum, sumOfSquares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type String, only the count statistic is returned.
  ##   body: JObject (required)
  var body_595760 = newJObject()
  if body != nil:
    body_595760 = body
  result = call_595759.call(nil, nil, nil, nil, body_595760)

var getStatistics* = Call_GetStatistics_595747(name: "getStatistics",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/statistics", validator: validate_GetStatistics_595748,
    base: "/", url: url_GetStatistics_595749, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetV2LoggingOptions_595773 = ref object of OpenApiRestCall_593389
proc url_SetV2LoggingOptions_595775(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetV2LoggingOptions_595774(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Sets the logging options for the V2 logging service.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595776 = header.getOrDefault("X-Amz-Signature")
  valid_595776 = validateParameter(valid_595776, JString, required = false,
                                 default = nil)
  if valid_595776 != nil:
    section.add "X-Amz-Signature", valid_595776
  var valid_595777 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595777 = validateParameter(valid_595777, JString, required = false,
                                 default = nil)
  if valid_595777 != nil:
    section.add "X-Amz-Content-Sha256", valid_595777
  var valid_595778 = header.getOrDefault("X-Amz-Date")
  valid_595778 = validateParameter(valid_595778, JString, required = false,
                                 default = nil)
  if valid_595778 != nil:
    section.add "X-Amz-Date", valid_595778
  var valid_595779 = header.getOrDefault("X-Amz-Credential")
  valid_595779 = validateParameter(valid_595779, JString, required = false,
                                 default = nil)
  if valid_595779 != nil:
    section.add "X-Amz-Credential", valid_595779
  var valid_595780 = header.getOrDefault("X-Amz-Security-Token")
  valid_595780 = validateParameter(valid_595780, JString, required = false,
                                 default = nil)
  if valid_595780 != nil:
    section.add "X-Amz-Security-Token", valid_595780
  var valid_595781 = header.getOrDefault("X-Amz-Algorithm")
  valid_595781 = validateParameter(valid_595781, JString, required = false,
                                 default = nil)
  if valid_595781 != nil:
    section.add "X-Amz-Algorithm", valid_595781
  var valid_595782 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595782 = validateParameter(valid_595782, JString, required = false,
                                 default = nil)
  if valid_595782 != nil:
    section.add "X-Amz-SignedHeaders", valid_595782
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595784: Call_SetV2LoggingOptions_595773; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the logging options for the V2 logging service.
  ## 
  let valid = call_595784.validator(path, query, header, formData, body)
  let scheme = call_595784.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595784.url(scheme.get, call_595784.host, call_595784.base,
                         call_595784.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595784, url, valid)

proc call*(call_595785: Call_SetV2LoggingOptions_595773; body: JsonNode): Recallable =
  ## setV2LoggingOptions
  ## Sets the logging options for the V2 logging service.
  ##   body: JObject (required)
  var body_595786 = newJObject()
  if body != nil:
    body_595786 = body
  result = call_595785.call(nil, nil, nil, nil, body_595786)

var setV2LoggingOptions* = Call_SetV2LoggingOptions_595773(
    name: "setV2LoggingOptions", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/v2LoggingOptions",
    validator: validate_SetV2LoggingOptions_595774, base: "/",
    url: url_SetV2LoggingOptions_595775, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetV2LoggingOptions_595761 = ref object of OpenApiRestCall_593389
proc url_GetV2LoggingOptions_595763(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV2LoggingOptions_595762(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets the fine grained logging options.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595764 = header.getOrDefault("X-Amz-Signature")
  valid_595764 = validateParameter(valid_595764, JString, required = false,
                                 default = nil)
  if valid_595764 != nil:
    section.add "X-Amz-Signature", valid_595764
  var valid_595765 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595765 = validateParameter(valid_595765, JString, required = false,
                                 default = nil)
  if valid_595765 != nil:
    section.add "X-Amz-Content-Sha256", valid_595765
  var valid_595766 = header.getOrDefault("X-Amz-Date")
  valid_595766 = validateParameter(valid_595766, JString, required = false,
                                 default = nil)
  if valid_595766 != nil:
    section.add "X-Amz-Date", valid_595766
  var valid_595767 = header.getOrDefault("X-Amz-Credential")
  valid_595767 = validateParameter(valid_595767, JString, required = false,
                                 default = nil)
  if valid_595767 != nil:
    section.add "X-Amz-Credential", valid_595767
  var valid_595768 = header.getOrDefault("X-Amz-Security-Token")
  valid_595768 = validateParameter(valid_595768, JString, required = false,
                                 default = nil)
  if valid_595768 != nil:
    section.add "X-Amz-Security-Token", valid_595768
  var valid_595769 = header.getOrDefault("X-Amz-Algorithm")
  valid_595769 = validateParameter(valid_595769, JString, required = false,
                                 default = nil)
  if valid_595769 != nil:
    section.add "X-Amz-Algorithm", valid_595769
  var valid_595770 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595770 = validateParameter(valid_595770, JString, required = false,
                                 default = nil)
  if valid_595770 != nil:
    section.add "X-Amz-SignedHeaders", valid_595770
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595771: Call_GetV2LoggingOptions_595761; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the fine grained logging options.
  ## 
  let valid = call_595771.validator(path, query, header, formData, body)
  let scheme = call_595771.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595771.url(scheme.get, call_595771.host, call_595771.base,
                         call_595771.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595771, url, valid)

proc call*(call_595772: Call_GetV2LoggingOptions_595761): Recallable =
  ## getV2LoggingOptions
  ## Gets the fine grained logging options.
  result = call_595772.call(nil, nil, nil, nil, nil)

var getV2LoggingOptions* = Call_GetV2LoggingOptions_595761(
    name: "getV2LoggingOptions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/v2LoggingOptions",
    validator: validate_GetV2LoggingOptions_595762, base: "/",
    url: url_GetV2LoggingOptions_595763, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListActiveViolations_595787 = ref object of OpenApiRestCall_593389
proc url_ListActiveViolations_595789(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListActiveViolations_595788(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the active violations for a given Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   securityProfileName: JString
  ##                      : The name of the Device Defender security profile for which violations are listed.
  ##   thingName: JString
  ##            : The name of the thing whose active violations are listed.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_595790 = query.getOrDefault("nextToken")
  valid_595790 = validateParameter(valid_595790, JString, required = false,
                                 default = nil)
  if valid_595790 != nil:
    section.add "nextToken", valid_595790
  var valid_595791 = query.getOrDefault("securityProfileName")
  valid_595791 = validateParameter(valid_595791, JString, required = false,
                                 default = nil)
  if valid_595791 != nil:
    section.add "securityProfileName", valid_595791
  var valid_595792 = query.getOrDefault("thingName")
  valid_595792 = validateParameter(valid_595792, JString, required = false,
                                 default = nil)
  if valid_595792 != nil:
    section.add "thingName", valid_595792
  var valid_595793 = query.getOrDefault("maxResults")
  valid_595793 = validateParameter(valid_595793, JInt, required = false, default = nil)
  if valid_595793 != nil:
    section.add "maxResults", valid_595793
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595794 = header.getOrDefault("X-Amz-Signature")
  valid_595794 = validateParameter(valid_595794, JString, required = false,
                                 default = nil)
  if valid_595794 != nil:
    section.add "X-Amz-Signature", valid_595794
  var valid_595795 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595795 = validateParameter(valid_595795, JString, required = false,
                                 default = nil)
  if valid_595795 != nil:
    section.add "X-Amz-Content-Sha256", valid_595795
  var valid_595796 = header.getOrDefault("X-Amz-Date")
  valid_595796 = validateParameter(valid_595796, JString, required = false,
                                 default = nil)
  if valid_595796 != nil:
    section.add "X-Amz-Date", valid_595796
  var valid_595797 = header.getOrDefault("X-Amz-Credential")
  valid_595797 = validateParameter(valid_595797, JString, required = false,
                                 default = nil)
  if valid_595797 != nil:
    section.add "X-Amz-Credential", valid_595797
  var valid_595798 = header.getOrDefault("X-Amz-Security-Token")
  valid_595798 = validateParameter(valid_595798, JString, required = false,
                                 default = nil)
  if valid_595798 != nil:
    section.add "X-Amz-Security-Token", valid_595798
  var valid_595799 = header.getOrDefault("X-Amz-Algorithm")
  valid_595799 = validateParameter(valid_595799, JString, required = false,
                                 default = nil)
  if valid_595799 != nil:
    section.add "X-Amz-Algorithm", valid_595799
  var valid_595800 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595800 = validateParameter(valid_595800, JString, required = false,
                                 default = nil)
  if valid_595800 != nil:
    section.add "X-Amz-SignedHeaders", valid_595800
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595801: Call_ListActiveViolations_595787; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the active violations for a given Device Defender security profile.
  ## 
  let valid = call_595801.validator(path, query, header, formData, body)
  let scheme = call_595801.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595801.url(scheme.get, call_595801.host, call_595801.base,
                         call_595801.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595801, url, valid)

proc call*(call_595802: Call_ListActiveViolations_595787; nextToken: string = "";
          securityProfileName: string = ""; thingName: string = ""; maxResults: int = 0): Recallable =
  ## listActiveViolations
  ## Lists the active violations for a given Device Defender security profile.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string
  ##                      : The name of the Device Defender security profile for which violations are listed.
  ##   thingName: string
  ##            : The name of the thing whose active violations are listed.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_595803 = newJObject()
  add(query_595803, "nextToken", newJString(nextToken))
  add(query_595803, "securityProfileName", newJString(securityProfileName))
  add(query_595803, "thingName", newJString(thingName))
  add(query_595803, "maxResults", newJInt(maxResults))
  result = call_595802.call(nil, query_595803, nil, nil, nil)

var listActiveViolations* = Call_ListActiveViolations_595787(
    name: "listActiveViolations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/active-violations",
    validator: validate_ListActiveViolations_595788, base: "/",
    url: url_ListActiveViolations_595789, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAttachedPolicies_595804 = ref object of OpenApiRestCall_593389
proc url_ListAttachedPolicies_595806(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "target" in path, "`target` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/attached-policies/"),
               (kind: VariableSegment, value: "target")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListAttachedPolicies_595805(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the policies attached to the specified thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   target: JString (required)
  ##         : The group or principal for which the policies will be listed.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `target` field"
  var valid_595807 = path.getOrDefault("target")
  valid_595807 = validateParameter(valid_595807, JString, required = true,
                                 default = nil)
  if valid_595807 != nil:
    section.add "target", valid_595807
  result.add "path", section
  ## parameters in `query` object:
  ##   pageSize: JInt
  ##           : The maximum number of results to be returned per request.
  ##   recursive: JBool
  ##            : When true, recursively list attached policies.
  ##   marker: JString
  ##         : The token to retrieve the next set of results.
  section = newJObject()
  var valid_595808 = query.getOrDefault("pageSize")
  valid_595808 = validateParameter(valid_595808, JInt, required = false, default = nil)
  if valid_595808 != nil:
    section.add "pageSize", valid_595808
  var valid_595809 = query.getOrDefault("recursive")
  valid_595809 = validateParameter(valid_595809, JBool, required = false, default = nil)
  if valid_595809 != nil:
    section.add "recursive", valid_595809
  var valid_595810 = query.getOrDefault("marker")
  valid_595810 = validateParameter(valid_595810, JString, required = false,
                                 default = nil)
  if valid_595810 != nil:
    section.add "marker", valid_595810
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595811 = header.getOrDefault("X-Amz-Signature")
  valid_595811 = validateParameter(valid_595811, JString, required = false,
                                 default = nil)
  if valid_595811 != nil:
    section.add "X-Amz-Signature", valid_595811
  var valid_595812 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595812 = validateParameter(valid_595812, JString, required = false,
                                 default = nil)
  if valid_595812 != nil:
    section.add "X-Amz-Content-Sha256", valid_595812
  var valid_595813 = header.getOrDefault("X-Amz-Date")
  valid_595813 = validateParameter(valid_595813, JString, required = false,
                                 default = nil)
  if valid_595813 != nil:
    section.add "X-Amz-Date", valid_595813
  var valid_595814 = header.getOrDefault("X-Amz-Credential")
  valid_595814 = validateParameter(valid_595814, JString, required = false,
                                 default = nil)
  if valid_595814 != nil:
    section.add "X-Amz-Credential", valid_595814
  var valid_595815 = header.getOrDefault("X-Amz-Security-Token")
  valid_595815 = validateParameter(valid_595815, JString, required = false,
                                 default = nil)
  if valid_595815 != nil:
    section.add "X-Amz-Security-Token", valid_595815
  var valid_595816 = header.getOrDefault("X-Amz-Algorithm")
  valid_595816 = validateParameter(valid_595816, JString, required = false,
                                 default = nil)
  if valid_595816 != nil:
    section.add "X-Amz-Algorithm", valid_595816
  var valid_595817 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595817 = validateParameter(valid_595817, JString, required = false,
                                 default = nil)
  if valid_595817 != nil:
    section.add "X-Amz-SignedHeaders", valid_595817
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595818: Call_ListAttachedPolicies_595804; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the policies attached to the specified thing group.
  ## 
  let valid = call_595818.validator(path, query, header, formData, body)
  let scheme = call_595818.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595818.url(scheme.get, call_595818.host, call_595818.base,
                         call_595818.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595818, url, valid)

proc call*(call_595819: Call_ListAttachedPolicies_595804; target: string;
          pageSize: int = 0; recursive: bool = false; marker: string = ""): Recallable =
  ## listAttachedPolicies
  ## Lists the policies attached to the specified thing group.
  ##   pageSize: int
  ##           : The maximum number of results to be returned per request.
  ##   recursive: bool
  ##            : When true, recursively list attached policies.
  ##   target: string (required)
  ##         : The group or principal for which the policies will be listed.
  ##   marker: string
  ##         : The token to retrieve the next set of results.
  var path_595820 = newJObject()
  var query_595821 = newJObject()
  add(query_595821, "pageSize", newJInt(pageSize))
  add(query_595821, "recursive", newJBool(recursive))
  add(path_595820, "target", newJString(target))
  add(query_595821, "marker", newJString(marker))
  result = call_595819.call(path_595820, query_595821, nil, nil, nil)

var listAttachedPolicies* = Call_ListAttachedPolicies_595804(
    name: "listAttachedPolicies", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/attached-policies/{target}",
    validator: validate_ListAttachedPolicies_595805, base: "/",
    url: url_ListAttachedPolicies_595806, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditFindings_595822 = ref object of OpenApiRestCall_593389
proc url_ListAuditFindings_595824(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditFindings_595823(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595825 = header.getOrDefault("X-Amz-Signature")
  valid_595825 = validateParameter(valid_595825, JString, required = false,
                                 default = nil)
  if valid_595825 != nil:
    section.add "X-Amz-Signature", valid_595825
  var valid_595826 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595826 = validateParameter(valid_595826, JString, required = false,
                                 default = nil)
  if valid_595826 != nil:
    section.add "X-Amz-Content-Sha256", valid_595826
  var valid_595827 = header.getOrDefault("X-Amz-Date")
  valid_595827 = validateParameter(valid_595827, JString, required = false,
                                 default = nil)
  if valid_595827 != nil:
    section.add "X-Amz-Date", valid_595827
  var valid_595828 = header.getOrDefault("X-Amz-Credential")
  valid_595828 = validateParameter(valid_595828, JString, required = false,
                                 default = nil)
  if valid_595828 != nil:
    section.add "X-Amz-Credential", valid_595828
  var valid_595829 = header.getOrDefault("X-Amz-Security-Token")
  valid_595829 = validateParameter(valid_595829, JString, required = false,
                                 default = nil)
  if valid_595829 != nil:
    section.add "X-Amz-Security-Token", valid_595829
  var valid_595830 = header.getOrDefault("X-Amz-Algorithm")
  valid_595830 = validateParameter(valid_595830, JString, required = false,
                                 default = nil)
  if valid_595830 != nil:
    section.add "X-Amz-Algorithm", valid_595830
  var valid_595831 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595831 = validateParameter(valid_595831, JString, required = false,
                                 default = nil)
  if valid_595831 != nil:
    section.add "X-Amz-SignedHeaders", valid_595831
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595833: Call_ListAuditFindings_595822; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ## 
  let valid = call_595833.validator(path, query, header, formData, body)
  let scheme = call_595833.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595833.url(scheme.get, call_595833.host, call_595833.base,
                         call_595833.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595833, url, valid)

proc call*(call_595834: Call_ListAuditFindings_595822; body: JsonNode): Recallable =
  ## listAuditFindings
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ##   body: JObject (required)
  var body_595835 = newJObject()
  if body != nil:
    body_595835 = body
  result = call_595834.call(nil, nil, nil, nil, body_595835)

var listAuditFindings* = Call_ListAuditFindings_595822(name: "listAuditFindings",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/audit/findings",
    validator: validate_ListAuditFindings_595823, base: "/",
    url: url_ListAuditFindings_595824, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditMitigationActionsExecutions_595836 = ref object of OpenApiRestCall_593389
proc url_ListAuditMitigationActionsExecutions_595838(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditMitigationActionsExecutions_595837(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the status of audit mitigation action tasks that were executed.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   actionStatus: JString
  ##               : Specify this filter to limit results to those with a specific status.
  ##   taskId: JString (required)
  ##         : Specify this filter to limit results to actions for a specific audit mitigation actions task.
  ##   findingId: JString (required)
  ##            : Specify this filter to limit results to those that were applied to a specific audit finding.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  var valid_595839 = query.getOrDefault("nextToken")
  valid_595839 = validateParameter(valid_595839, JString, required = false,
                                 default = nil)
  if valid_595839 != nil:
    section.add "nextToken", valid_595839
  var valid_595840 = query.getOrDefault("actionStatus")
  valid_595840 = validateParameter(valid_595840, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_595840 != nil:
    section.add "actionStatus", valid_595840
  assert query != nil, "query argument is necessary due to required `taskId` field"
  var valid_595841 = query.getOrDefault("taskId")
  valid_595841 = validateParameter(valid_595841, JString, required = true,
                                 default = nil)
  if valid_595841 != nil:
    section.add "taskId", valid_595841
  var valid_595842 = query.getOrDefault("findingId")
  valid_595842 = validateParameter(valid_595842, JString, required = true,
                                 default = nil)
  if valid_595842 != nil:
    section.add "findingId", valid_595842
  var valid_595843 = query.getOrDefault("maxResults")
  valid_595843 = validateParameter(valid_595843, JInt, required = false, default = nil)
  if valid_595843 != nil:
    section.add "maxResults", valid_595843
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595844 = header.getOrDefault("X-Amz-Signature")
  valid_595844 = validateParameter(valid_595844, JString, required = false,
                                 default = nil)
  if valid_595844 != nil:
    section.add "X-Amz-Signature", valid_595844
  var valid_595845 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595845 = validateParameter(valid_595845, JString, required = false,
                                 default = nil)
  if valid_595845 != nil:
    section.add "X-Amz-Content-Sha256", valid_595845
  var valid_595846 = header.getOrDefault("X-Amz-Date")
  valid_595846 = validateParameter(valid_595846, JString, required = false,
                                 default = nil)
  if valid_595846 != nil:
    section.add "X-Amz-Date", valid_595846
  var valid_595847 = header.getOrDefault("X-Amz-Credential")
  valid_595847 = validateParameter(valid_595847, JString, required = false,
                                 default = nil)
  if valid_595847 != nil:
    section.add "X-Amz-Credential", valid_595847
  var valid_595848 = header.getOrDefault("X-Amz-Security-Token")
  valid_595848 = validateParameter(valid_595848, JString, required = false,
                                 default = nil)
  if valid_595848 != nil:
    section.add "X-Amz-Security-Token", valid_595848
  var valid_595849 = header.getOrDefault("X-Amz-Algorithm")
  valid_595849 = validateParameter(valid_595849, JString, required = false,
                                 default = nil)
  if valid_595849 != nil:
    section.add "X-Amz-Algorithm", valid_595849
  var valid_595850 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595850 = validateParameter(valid_595850, JString, required = false,
                                 default = nil)
  if valid_595850 != nil:
    section.add "X-Amz-SignedHeaders", valid_595850
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595851: Call_ListAuditMitigationActionsExecutions_595836;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the status of audit mitigation action tasks that were executed.
  ## 
  let valid = call_595851.validator(path, query, header, formData, body)
  let scheme = call_595851.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595851.url(scheme.get, call_595851.host, call_595851.base,
                         call_595851.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595851, url, valid)

proc call*(call_595852: Call_ListAuditMitigationActionsExecutions_595836;
          taskId: string; findingId: string; nextToken: string = "";
          actionStatus: string = "IN_PROGRESS"; maxResults: int = 0): Recallable =
  ## listAuditMitigationActionsExecutions
  ## Gets the status of audit mitigation action tasks that were executed.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   actionStatus: string
  ##               : Specify this filter to limit results to those with a specific status.
  ##   taskId: string (required)
  ##         : Specify this filter to limit results to actions for a specific audit mitigation actions task.
  ##   findingId: string (required)
  ##            : Specify this filter to limit results to those that were applied to a specific audit finding.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_595853 = newJObject()
  add(query_595853, "nextToken", newJString(nextToken))
  add(query_595853, "actionStatus", newJString(actionStatus))
  add(query_595853, "taskId", newJString(taskId))
  add(query_595853, "findingId", newJString(findingId))
  add(query_595853, "maxResults", newJInt(maxResults))
  result = call_595852.call(nil, query_595853, nil, nil, nil)

var listAuditMitigationActionsExecutions* = Call_ListAuditMitigationActionsExecutions_595836(
    name: "listAuditMitigationActionsExecutions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/executions#taskId&findingId",
    validator: validate_ListAuditMitigationActionsExecutions_595837, base: "/",
    url: url_ListAuditMitigationActionsExecutions_595838,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditMitigationActionsTasks_595854 = ref object of OpenApiRestCall_593389
proc url_ListAuditMitigationActionsTasks_595856(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditMitigationActionsTasks_595855(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endTime: JString (required)
  ##          : Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : Specify this filter to limit results to tasks that began on or after a specific date and time.
  ##   findingId: JString
  ##            : Specify this filter to limit results to tasks that were applied to a specific audit finding.
  ##   taskStatus: JString
  ##             : Specify this filter to limit results to tasks that are in a specific state.
  ##   auditTaskId: JString
  ##              : Specify this filter to limit results to tasks that were applied to results for a specific audit.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_595857 = query.getOrDefault("endTime")
  valid_595857 = validateParameter(valid_595857, JString, required = true,
                                 default = nil)
  if valid_595857 != nil:
    section.add "endTime", valid_595857
  var valid_595858 = query.getOrDefault("nextToken")
  valid_595858 = validateParameter(valid_595858, JString, required = false,
                                 default = nil)
  if valid_595858 != nil:
    section.add "nextToken", valid_595858
  var valid_595859 = query.getOrDefault("startTime")
  valid_595859 = validateParameter(valid_595859, JString, required = true,
                                 default = nil)
  if valid_595859 != nil:
    section.add "startTime", valid_595859
  var valid_595860 = query.getOrDefault("findingId")
  valid_595860 = validateParameter(valid_595860, JString, required = false,
                                 default = nil)
  if valid_595860 != nil:
    section.add "findingId", valid_595860
  var valid_595861 = query.getOrDefault("taskStatus")
  valid_595861 = validateParameter(valid_595861, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_595861 != nil:
    section.add "taskStatus", valid_595861
  var valid_595862 = query.getOrDefault("auditTaskId")
  valid_595862 = validateParameter(valid_595862, JString, required = false,
                                 default = nil)
  if valid_595862 != nil:
    section.add "auditTaskId", valid_595862
  var valid_595863 = query.getOrDefault("maxResults")
  valid_595863 = validateParameter(valid_595863, JInt, required = false, default = nil)
  if valid_595863 != nil:
    section.add "maxResults", valid_595863
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595864 = header.getOrDefault("X-Amz-Signature")
  valid_595864 = validateParameter(valid_595864, JString, required = false,
                                 default = nil)
  if valid_595864 != nil:
    section.add "X-Amz-Signature", valid_595864
  var valid_595865 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595865 = validateParameter(valid_595865, JString, required = false,
                                 default = nil)
  if valid_595865 != nil:
    section.add "X-Amz-Content-Sha256", valid_595865
  var valid_595866 = header.getOrDefault("X-Amz-Date")
  valid_595866 = validateParameter(valid_595866, JString, required = false,
                                 default = nil)
  if valid_595866 != nil:
    section.add "X-Amz-Date", valid_595866
  var valid_595867 = header.getOrDefault("X-Amz-Credential")
  valid_595867 = validateParameter(valid_595867, JString, required = false,
                                 default = nil)
  if valid_595867 != nil:
    section.add "X-Amz-Credential", valid_595867
  var valid_595868 = header.getOrDefault("X-Amz-Security-Token")
  valid_595868 = validateParameter(valid_595868, JString, required = false,
                                 default = nil)
  if valid_595868 != nil:
    section.add "X-Amz-Security-Token", valid_595868
  var valid_595869 = header.getOrDefault("X-Amz-Algorithm")
  valid_595869 = validateParameter(valid_595869, JString, required = false,
                                 default = nil)
  if valid_595869 != nil:
    section.add "X-Amz-Algorithm", valid_595869
  var valid_595870 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595870 = validateParameter(valid_595870, JString, required = false,
                                 default = nil)
  if valid_595870 != nil:
    section.add "X-Amz-SignedHeaders", valid_595870
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595871: Call_ListAuditMitigationActionsTasks_595854;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ## 
  let valid = call_595871.validator(path, query, header, formData, body)
  let scheme = call_595871.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595871.url(scheme.get, call_595871.host, call_595871.base,
                         call_595871.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595871, url, valid)

proc call*(call_595872: Call_ListAuditMitigationActionsTasks_595854;
          endTime: string; startTime: string; nextToken: string = "";
          findingId: string = ""; taskStatus: string = "IN_PROGRESS";
          auditTaskId: string = ""; maxResults: int = 0): Recallable =
  ## listAuditMitigationActionsTasks
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ##   endTime: string (required)
  ##          : Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : Specify this filter to limit results to tasks that began on or after a specific date and time.
  ##   findingId: string
  ##            : Specify this filter to limit results to tasks that were applied to a specific audit finding.
  ##   taskStatus: string
  ##             : Specify this filter to limit results to tasks that are in a specific state.
  ##   auditTaskId: string
  ##              : Specify this filter to limit results to tasks that were applied to results for a specific audit.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_595873 = newJObject()
  add(query_595873, "endTime", newJString(endTime))
  add(query_595873, "nextToken", newJString(nextToken))
  add(query_595873, "startTime", newJString(startTime))
  add(query_595873, "findingId", newJString(findingId))
  add(query_595873, "taskStatus", newJString(taskStatus))
  add(query_595873, "auditTaskId", newJString(auditTaskId))
  add(query_595873, "maxResults", newJInt(maxResults))
  result = call_595872.call(nil, query_595873, nil, nil, nil)

var listAuditMitigationActionsTasks* = Call_ListAuditMitigationActionsTasks_595854(
    name: "listAuditMitigationActionsTasks", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/tasks#startTime&endTime",
    validator: validate_ListAuditMitigationActionsTasks_595855, base: "/",
    url: url_ListAuditMitigationActionsTasks_595856,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditTasks_595874 = ref object of OpenApiRestCall_593389
proc url_ListAuditTasks_595876(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditTasks_595875(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the Device Defender audits that have been performed during a given time period.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endTime: JString (required)
  ##          : The end of the time period.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
  ##   taskStatus: JString
  ##             : A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
  ##   taskType: JString
  ##           : A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_595877 = query.getOrDefault("endTime")
  valid_595877 = validateParameter(valid_595877, JString, required = true,
                                 default = nil)
  if valid_595877 != nil:
    section.add "endTime", valid_595877
  var valid_595878 = query.getOrDefault("nextToken")
  valid_595878 = validateParameter(valid_595878, JString, required = false,
                                 default = nil)
  if valid_595878 != nil:
    section.add "nextToken", valid_595878
  var valid_595879 = query.getOrDefault("startTime")
  valid_595879 = validateParameter(valid_595879, JString, required = true,
                                 default = nil)
  if valid_595879 != nil:
    section.add "startTime", valid_595879
  var valid_595880 = query.getOrDefault("taskStatus")
  valid_595880 = validateParameter(valid_595880, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_595880 != nil:
    section.add "taskStatus", valid_595880
  var valid_595881 = query.getOrDefault("taskType")
  valid_595881 = validateParameter(valid_595881, JString, required = false,
                                 default = newJString("ON_DEMAND_AUDIT_TASK"))
  if valid_595881 != nil:
    section.add "taskType", valid_595881
  var valid_595882 = query.getOrDefault("maxResults")
  valid_595882 = validateParameter(valid_595882, JInt, required = false, default = nil)
  if valid_595882 != nil:
    section.add "maxResults", valid_595882
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595883 = header.getOrDefault("X-Amz-Signature")
  valid_595883 = validateParameter(valid_595883, JString, required = false,
                                 default = nil)
  if valid_595883 != nil:
    section.add "X-Amz-Signature", valid_595883
  var valid_595884 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595884 = validateParameter(valid_595884, JString, required = false,
                                 default = nil)
  if valid_595884 != nil:
    section.add "X-Amz-Content-Sha256", valid_595884
  var valid_595885 = header.getOrDefault("X-Amz-Date")
  valid_595885 = validateParameter(valid_595885, JString, required = false,
                                 default = nil)
  if valid_595885 != nil:
    section.add "X-Amz-Date", valid_595885
  var valid_595886 = header.getOrDefault("X-Amz-Credential")
  valid_595886 = validateParameter(valid_595886, JString, required = false,
                                 default = nil)
  if valid_595886 != nil:
    section.add "X-Amz-Credential", valid_595886
  var valid_595887 = header.getOrDefault("X-Amz-Security-Token")
  valid_595887 = validateParameter(valid_595887, JString, required = false,
                                 default = nil)
  if valid_595887 != nil:
    section.add "X-Amz-Security-Token", valid_595887
  var valid_595888 = header.getOrDefault("X-Amz-Algorithm")
  valid_595888 = validateParameter(valid_595888, JString, required = false,
                                 default = nil)
  if valid_595888 != nil:
    section.add "X-Amz-Algorithm", valid_595888
  var valid_595889 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595889 = validateParameter(valid_595889, JString, required = false,
                                 default = nil)
  if valid_595889 != nil:
    section.add "X-Amz-SignedHeaders", valid_595889
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595890: Call_ListAuditTasks_595874; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender audits that have been performed during a given time period.
  ## 
  let valid = call_595890.validator(path, query, header, formData, body)
  let scheme = call_595890.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595890.url(scheme.get, call_595890.host, call_595890.base,
                         call_595890.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595890, url, valid)

proc call*(call_595891: Call_ListAuditTasks_595874; endTime: string;
          startTime: string; nextToken: string = "";
          taskStatus: string = "IN_PROGRESS";
          taskType: string = "ON_DEMAND_AUDIT_TASK"; maxResults: int = 0): Recallable =
  ## listAuditTasks
  ## Lists the Device Defender audits that have been performed during a given time period.
  ##   endTime: string (required)
  ##          : The end of the time period.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
  ##   taskStatus: string
  ##             : A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
  ##   taskType: string
  ##           : A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_595892 = newJObject()
  add(query_595892, "endTime", newJString(endTime))
  add(query_595892, "nextToken", newJString(nextToken))
  add(query_595892, "startTime", newJString(startTime))
  add(query_595892, "taskStatus", newJString(taskStatus))
  add(query_595892, "taskType", newJString(taskType))
  add(query_595892, "maxResults", newJInt(maxResults))
  result = call_595891.call(nil, query_595892, nil, nil, nil)

var listAuditTasks* = Call_ListAuditTasks_595874(name: "listAuditTasks",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/audit/tasks#startTime&endTime", validator: validate_ListAuditTasks_595875,
    base: "/", url: url_ListAuditTasks_595876, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuthorizers_595893 = ref object of OpenApiRestCall_593389
proc url_ListAuthorizers_595895(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuthorizers_595894(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Lists the authorizers registered in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Return the list of authorizers in ascending alphabetical order.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   status: JString
  ##         : The status of the list authorizers request.
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  section = newJObject()
  var valid_595896 = query.getOrDefault("isAscendingOrder")
  valid_595896 = validateParameter(valid_595896, JBool, required = false, default = nil)
  if valid_595896 != nil:
    section.add "isAscendingOrder", valid_595896
  var valid_595897 = query.getOrDefault("pageSize")
  valid_595897 = validateParameter(valid_595897, JInt, required = false, default = nil)
  if valid_595897 != nil:
    section.add "pageSize", valid_595897
  var valid_595898 = query.getOrDefault("status")
  valid_595898 = validateParameter(valid_595898, JString, required = false,
                                 default = newJString("ACTIVE"))
  if valid_595898 != nil:
    section.add "status", valid_595898
  var valid_595899 = query.getOrDefault("marker")
  valid_595899 = validateParameter(valid_595899, JString, required = false,
                                 default = nil)
  if valid_595899 != nil:
    section.add "marker", valid_595899
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595900 = header.getOrDefault("X-Amz-Signature")
  valid_595900 = validateParameter(valid_595900, JString, required = false,
                                 default = nil)
  if valid_595900 != nil:
    section.add "X-Amz-Signature", valid_595900
  var valid_595901 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595901 = validateParameter(valid_595901, JString, required = false,
                                 default = nil)
  if valid_595901 != nil:
    section.add "X-Amz-Content-Sha256", valid_595901
  var valid_595902 = header.getOrDefault("X-Amz-Date")
  valid_595902 = validateParameter(valid_595902, JString, required = false,
                                 default = nil)
  if valid_595902 != nil:
    section.add "X-Amz-Date", valid_595902
  var valid_595903 = header.getOrDefault("X-Amz-Credential")
  valid_595903 = validateParameter(valid_595903, JString, required = false,
                                 default = nil)
  if valid_595903 != nil:
    section.add "X-Amz-Credential", valid_595903
  var valid_595904 = header.getOrDefault("X-Amz-Security-Token")
  valid_595904 = validateParameter(valid_595904, JString, required = false,
                                 default = nil)
  if valid_595904 != nil:
    section.add "X-Amz-Security-Token", valid_595904
  var valid_595905 = header.getOrDefault("X-Amz-Algorithm")
  valid_595905 = validateParameter(valid_595905, JString, required = false,
                                 default = nil)
  if valid_595905 != nil:
    section.add "X-Amz-Algorithm", valid_595905
  var valid_595906 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595906 = validateParameter(valid_595906, JString, required = false,
                                 default = nil)
  if valid_595906 != nil:
    section.add "X-Amz-SignedHeaders", valid_595906
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595907: Call_ListAuthorizers_595893; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the authorizers registered in your account.
  ## 
  let valid = call_595907.validator(path, query, header, formData, body)
  let scheme = call_595907.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595907.url(scheme.get, call_595907.host, call_595907.base,
                         call_595907.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595907, url, valid)

proc call*(call_595908: Call_ListAuthorizers_595893;
          isAscendingOrder: bool = false; pageSize: int = 0; status: string = "ACTIVE";
          marker: string = ""): Recallable =
  ## listAuthorizers
  ## Lists the authorizers registered in your account.
  ##   isAscendingOrder: bool
  ##                   : Return the list of authorizers in ascending alphabetical order.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   status: string
  ##         : The status of the list authorizers request.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  var query_595909 = newJObject()
  add(query_595909, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_595909, "pageSize", newJInt(pageSize))
  add(query_595909, "status", newJString(status))
  add(query_595909, "marker", newJString(marker))
  result = call_595908.call(nil, query_595909, nil, nil, nil)

var listAuthorizers* = Call_ListAuthorizers_595893(name: "listAuthorizers",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/authorizers/",
    validator: validate_ListAuthorizers_595894, base: "/", url: url_ListAuthorizers_595895,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListBillingGroups_595910 = ref object of OpenApiRestCall_593389
proc url_ListBillingGroups_595912(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListBillingGroups_595911(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Lists the billing groups you have created.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   namePrefixFilter: JString
  ##                   : Limit the results to billing groups whose names have the given prefix.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_595913 = query.getOrDefault("nextToken")
  valid_595913 = validateParameter(valid_595913, JString, required = false,
                                 default = nil)
  if valid_595913 != nil:
    section.add "nextToken", valid_595913
  var valid_595914 = query.getOrDefault("namePrefixFilter")
  valid_595914 = validateParameter(valid_595914, JString, required = false,
                                 default = nil)
  if valid_595914 != nil:
    section.add "namePrefixFilter", valid_595914
  var valid_595915 = query.getOrDefault("maxResults")
  valid_595915 = validateParameter(valid_595915, JInt, required = false, default = nil)
  if valid_595915 != nil:
    section.add "maxResults", valid_595915
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595916 = header.getOrDefault("X-Amz-Signature")
  valid_595916 = validateParameter(valid_595916, JString, required = false,
                                 default = nil)
  if valid_595916 != nil:
    section.add "X-Amz-Signature", valid_595916
  var valid_595917 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595917 = validateParameter(valid_595917, JString, required = false,
                                 default = nil)
  if valid_595917 != nil:
    section.add "X-Amz-Content-Sha256", valid_595917
  var valid_595918 = header.getOrDefault("X-Amz-Date")
  valid_595918 = validateParameter(valid_595918, JString, required = false,
                                 default = nil)
  if valid_595918 != nil:
    section.add "X-Amz-Date", valid_595918
  var valid_595919 = header.getOrDefault("X-Amz-Credential")
  valid_595919 = validateParameter(valid_595919, JString, required = false,
                                 default = nil)
  if valid_595919 != nil:
    section.add "X-Amz-Credential", valid_595919
  var valid_595920 = header.getOrDefault("X-Amz-Security-Token")
  valid_595920 = validateParameter(valid_595920, JString, required = false,
                                 default = nil)
  if valid_595920 != nil:
    section.add "X-Amz-Security-Token", valid_595920
  var valid_595921 = header.getOrDefault("X-Amz-Algorithm")
  valid_595921 = validateParameter(valid_595921, JString, required = false,
                                 default = nil)
  if valid_595921 != nil:
    section.add "X-Amz-Algorithm", valid_595921
  var valid_595922 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595922 = validateParameter(valid_595922, JString, required = false,
                                 default = nil)
  if valid_595922 != nil:
    section.add "X-Amz-SignedHeaders", valid_595922
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595923: Call_ListBillingGroups_595910; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the billing groups you have created.
  ## 
  let valid = call_595923.validator(path, query, header, formData, body)
  let scheme = call_595923.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595923.url(scheme.get, call_595923.host, call_595923.base,
                         call_595923.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595923, url, valid)

proc call*(call_595924: Call_ListBillingGroups_595910; nextToken: string = "";
          namePrefixFilter: string = ""; maxResults: int = 0): Recallable =
  ## listBillingGroups
  ## Lists the billing groups you have created.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   namePrefixFilter: string
  ##                   : Limit the results to billing groups whose names have the given prefix.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var query_595925 = newJObject()
  add(query_595925, "nextToken", newJString(nextToken))
  add(query_595925, "namePrefixFilter", newJString(namePrefixFilter))
  add(query_595925, "maxResults", newJInt(maxResults))
  result = call_595924.call(nil, query_595925, nil, nil, nil)

var listBillingGroups* = Call_ListBillingGroups_595910(name: "listBillingGroups",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/billing-groups",
    validator: validate_ListBillingGroups_595911, base: "/",
    url: url_ListBillingGroups_595912, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCACertificates_595926 = ref object of OpenApiRestCall_593389
proc url_ListCACertificates_595928(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListCACertificates_595927(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Determines the order of the results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_595929 = query.getOrDefault("isAscendingOrder")
  valid_595929 = validateParameter(valid_595929, JBool, required = false, default = nil)
  if valid_595929 != nil:
    section.add "isAscendingOrder", valid_595929
  var valid_595930 = query.getOrDefault("pageSize")
  valid_595930 = validateParameter(valid_595930, JInt, required = false, default = nil)
  if valid_595930 != nil:
    section.add "pageSize", valid_595930
  var valid_595931 = query.getOrDefault("marker")
  valid_595931 = validateParameter(valid_595931, JString, required = false,
                                 default = nil)
  if valid_595931 != nil:
    section.add "marker", valid_595931
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595932 = header.getOrDefault("X-Amz-Signature")
  valid_595932 = validateParameter(valid_595932, JString, required = false,
                                 default = nil)
  if valid_595932 != nil:
    section.add "X-Amz-Signature", valid_595932
  var valid_595933 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595933 = validateParameter(valid_595933, JString, required = false,
                                 default = nil)
  if valid_595933 != nil:
    section.add "X-Amz-Content-Sha256", valid_595933
  var valid_595934 = header.getOrDefault("X-Amz-Date")
  valid_595934 = validateParameter(valid_595934, JString, required = false,
                                 default = nil)
  if valid_595934 != nil:
    section.add "X-Amz-Date", valid_595934
  var valid_595935 = header.getOrDefault("X-Amz-Credential")
  valid_595935 = validateParameter(valid_595935, JString, required = false,
                                 default = nil)
  if valid_595935 != nil:
    section.add "X-Amz-Credential", valid_595935
  var valid_595936 = header.getOrDefault("X-Amz-Security-Token")
  valid_595936 = validateParameter(valid_595936, JString, required = false,
                                 default = nil)
  if valid_595936 != nil:
    section.add "X-Amz-Security-Token", valid_595936
  var valid_595937 = header.getOrDefault("X-Amz-Algorithm")
  valid_595937 = validateParameter(valid_595937, JString, required = false,
                                 default = nil)
  if valid_595937 != nil:
    section.add "X-Amz-Algorithm", valid_595937
  var valid_595938 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595938 = validateParameter(valid_595938, JString, required = false,
                                 default = nil)
  if valid_595938 != nil:
    section.add "X-Amz-SignedHeaders", valid_595938
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595939: Call_ListCACertificates_595926; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  let valid = call_595939.validator(path, query, header, formData, body)
  let scheme = call_595939.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595939.url(scheme.get, call_595939.host, call_595939.base,
                         call_595939.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595939, url, valid)

proc call*(call_595940: Call_ListCACertificates_595926;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listCACertificates
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ##   isAscendingOrder: bool
  ##                   : Determines the order of the results.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_595941 = newJObject()
  add(query_595941, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_595941, "pageSize", newJInt(pageSize))
  add(query_595941, "marker", newJString(marker))
  result = call_595940.call(nil, query_595941, nil, nil, nil)

var listCACertificates* = Call_ListCACertificates_595926(
    name: "listCACertificates", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/cacertificates", validator: validate_ListCACertificates_595927,
    base: "/", url: url_ListCACertificates_595928,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCertificatesByCA_595942 = ref object of OpenApiRestCall_593389
proc url_ListCertificatesByCA_595944(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates-by-ca/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListCertificatesByCA_595943(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List the device certificates signed by the specified CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_595945 = path.getOrDefault("caCertificateId")
  valid_595945 = validateParameter(valid_595945, JString, required = true,
                                 default = nil)
  if valid_595945 != nil:
    section.add "caCertificateId", valid_595945
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_595946 = query.getOrDefault("isAscendingOrder")
  valid_595946 = validateParameter(valid_595946, JBool, required = false, default = nil)
  if valid_595946 != nil:
    section.add "isAscendingOrder", valid_595946
  var valid_595947 = query.getOrDefault("pageSize")
  valid_595947 = validateParameter(valid_595947, JInt, required = false, default = nil)
  if valid_595947 != nil:
    section.add "pageSize", valid_595947
  var valid_595948 = query.getOrDefault("marker")
  valid_595948 = validateParameter(valid_595948, JString, required = false,
                                 default = nil)
  if valid_595948 != nil:
    section.add "marker", valid_595948
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595949 = header.getOrDefault("X-Amz-Signature")
  valid_595949 = validateParameter(valid_595949, JString, required = false,
                                 default = nil)
  if valid_595949 != nil:
    section.add "X-Amz-Signature", valid_595949
  var valid_595950 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595950 = validateParameter(valid_595950, JString, required = false,
                                 default = nil)
  if valid_595950 != nil:
    section.add "X-Amz-Content-Sha256", valid_595950
  var valid_595951 = header.getOrDefault("X-Amz-Date")
  valid_595951 = validateParameter(valid_595951, JString, required = false,
                                 default = nil)
  if valid_595951 != nil:
    section.add "X-Amz-Date", valid_595951
  var valid_595952 = header.getOrDefault("X-Amz-Credential")
  valid_595952 = validateParameter(valid_595952, JString, required = false,
                                 default = nil)
  if valid_595952 != nil:
    section.add "X-Amz-Credential", valid_595952
  var valid_595953 = header.getOrDefault("X-Amz-Security-Token")
  valid_595953 = validateParameter(valid_595953, JString, required = false,
                                 default = nil)
  if valid_595953 != nil:
    section.add "X-Amz-Security-Token", valid_595953
  var valid_595954 = header.getOrDefault("X-Amz-Algorithm")
  valid_595954 = validateParameter(valid_595954, JString, required = false,
                                 default = nil)
  if valid_595954 != nil:
    section.add "X-Amz-Algorithm", valid_595954
  var valid_595955 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595955 = validateParameter(valid_595955, JString, required = false,
                                 default = nil)
  if valid_595955 != nil:
    section.add "X-Amz-SignedHeaders", valid_595955
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595956: Call_ListCertificatesByCA_595942; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the device certificates signed by the specified CA certificate.
  ## 
  let valid = call_595956.validator(path, query, header, formData, body)
  let scheme = call_595956.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595956.url(scheme.get, call_595956.host, call_595956.base,
                         call_595956.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595956, url, valid)

proc call*(call_595957: Call_ListCertificatesByCA_595942; caCertificateId: string;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listCertificatesByCA
  ## List the device certificates signed by the specified CA certificate.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: int
  ##           : The result page size.
  ##   caCertificateId: string (required)
  ##                  : The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
  ##   marker: string
  ##         : The marker for the next set of results.
  var path_595958 = newJObject()
  var query_595959 = newJObject()
  add(query_595959, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_595959, "pageSize", newJInt(pageSize))
  add(path_595958, "caCertificateId", newJString(caCertificateId))
  add(query_595959, "marker", newJString(marker))
  result = call_595957.call(path_595958, query_595959, nil, nil, nil)

var listCertificatesByCA* = Call_ListCertificatesByCA_595942(
    name: "listCertificatesByCA", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates-by-ca/{caCertificateId}",
    validator: validate_ListCertificatesByCA_595943, base: "/",
    url: url_ListCertificatesByCA_595944, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListIndices_595960 = ref object of OpenApiRestCall_593389
proc url_ListIndices_595962(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListIndices_595961(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the search indices.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token used to get the next set of results, or null if there are no additional results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_595963 = query.getOrDefault("nextToken")
  valid_595963 = validateParameter(valid_595963, JString, required = false,
                                 default = nil)
  if valid_595963 != nil:
    section.add "nextToken", valid_595963
  var valid_595964 = query.getOrDefault("maxResults")
  valid_595964 = validateParameter(valid_595964, JInt, required = false, default = nil)
  if valid_595964 != nil:
    section.add "maxResults", valid_595964
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595965 = header.getOrDefault("X-Amz-Signature")
  valid_595965 = validateParameter(valid_595965, JString, required = false,
                                 default = nil)
  if valid_595965 != nil:
    section.add "X-Amz-Signature", valid_595965
  var valid_595966 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595966 = validateParameter(valid_595966, JString, required = false,
                                 default = nil)
  if valid_595966 != nil:
    section.add "X-Amz-Content-Sha256", valid_595966
  var valid_595967 = header.getOrDefault("X-Amz-Date")
  valid_595967 = validateParameter(valid_595967, JString, required = false,
                                 default = nil)
  if valid_595967 != nil:
    section.add "X-Amz-Date", valid_595967
  var valid_595968 = header.getOrDefault("X-Amz-Credential")
  valid_595968 = validateParameter(valid_595968, JString, required = false,
                                 default = nil)
  if valid_595968 != nil:
    section.add "X-Amz-Credential", valid_595968
  var valid_595969 = header.getOrDefault("X-Amz-Security-Token")
  valid_595969 = validateParameter(valid_595969, JString, required = false,
                                 default = nil)
  if valid_595969 != nil:
    section.add "X-Amz-Security-Token", valid_595969
  var valid_595970 = header.getOrDefault("X-Amz-Algorithm")
  valid_595970 = validateParameter(valid_595970, JString, required = false,
                                 default = nil)
  if valid_595970 != nil:
    section.add "X-Amz-Algorithm", valid_595970
  var valid_595971 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595971 = validateParameter(valid_595971, JString, required = false,
                                 default = nil)
  if valid_595971 != nil:
    section.add "X-Amz-SignedHeaders", valid_595971
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595972: Call_ListIndices_595960; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the search indices.
  ## 
  let valid = call_595972.validator(path, query, header, formData, body)
  let scheme = call_595972.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595972.url(scheme.get, call_595972.host, call_595972.base,
                         call_595972.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595972, url, valid)

proc call*(call_595973: Call_ListIndices_595960; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listIndices
  ## Lists the search indices.
  ##   nextToken: string
  ##            : The token used to get the next set of results, or null if there are no additional results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_595974 = newJObject()
  add(query_595974, "nextToken", newJString(nextToken))
  add(query_595974, "maxResults", newJInt(maxResults))
  result = call_595973.call(nil, query_595974, nil, nil, nil)

var listIndices* = Call_ListIndices_595960(name: "listIndices",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/indices",
                                        validator: validate_ListIndices_595961,
                                        base: "/", url: url_ListIndices_595962,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobExecutionsForJob_595975 = ref object of OpenApiRestCall_593389
proc url_ListJobExecutionsForJob_595977(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListJobExecutionsForJob_595976(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the job executions for a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_595978 = path.getOrDefault("jobId")
  valid_595978 = validateParameter(valid_595978, JString, required = true,
                                 default = nil)
  if valid_595978 != nil:
    section.add "jobId", valid_595978
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : The status of the job.
  ##   maxResults: JInt
  ##             : The maximum number of results to be returned per request.
  section = newJObject()
  var valid_595979 = query.getOrDefault("nextToken")
  valid_595979 = validateParameter(valid_595979, JString, required = false,
                                 default = nil)
  if valid_595979 != nil:
    section.add "nextToken", valid_595979
  var valid_595980 = query.getOrDefault("status")
  valid_595980 = validateParameter(valid_595980, JString, required = false,
                                 default = newJString("QUEUED"))
  if valid_595980 != nil:
    section.add "status", valid_595980
  var valid_595981 = query.getOrDefault("maxResults")
  valid_595981 = validateParameter(valid_595981, JInt, required = false, default = nil)
  if valid_595981 != nil:
    section.add "maxResults", valid_595981
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595982 = header.getOrDefault("X-Amz-Signature")
  valid_595982 = validateParameter(valid_595982, JString, required = false,
                                 default = nil)
  if valid_595982 != nil:
    section.add "X-Amz-Signature", valid_595982
  var valid_595983 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595983 = validateParameter(valid_595983, JString, required = false,
                                 default = nil)
  if valid_595983 != nil:
    section.add "X-Amz-Content-Sha256", valid_595983
  var valid_595984 = header.getOrDefault("X-Amz-Date")
  valid_595984 = validateParameter(valid_595984, JString, required = false,
                                 default = nil)
  if valid_595984 != nil:
    section.add "X-Amz-Date", valid_595984
  var valid_595985 = header.getOrDefault("X-Amz-Credential")
  valid_595985 = validateParameter(valid_595985, JString, required = false,
                                 default = nil)
  if valid_595985 != nil:
    section.add "X-Amz-Credential", valid_595985
  var valid_595986 = header.getOrDefault("X-Amz-Security-Token")
  valid_595986 = validateParameter(valid_595986, JString, required = false,
                                 default = nil)
  if valid_595986 != nil:
    section.add "X-Amz-Security-Token", valid_595986
  var valid_595987 = header.getOrDefault("X-Amz-Algorithm")
  valid_595987 = validateParameter(valid_595987, JString, required = false,
                                 default = nil)
  if valid_595987 != nil:
    section.add "X-Amz-Algorithm", valid_595987
  var valid_595988 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595988 = validateParameter(valid_595988, JString, required = false,
                                 default = nil)
  if valid_595988 != nil:
    section.add "X-Amz-SignedHeaders", valid_595988
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595989: Call_ListJobExecutionsForJob_595975; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the job executions for a job.
  ## 
  let valid = call_595989.validator(path, query, header, formData, body)
  let scheme = call_595989.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595989.url(scheme.get, call_595989.host, call_595989.base,
                         call_595989.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595989, url, valid)

proc call*(call_595990: Call_ListJobExecutionsForJob_595975; jobId: string;
          nextToken: string = ""; status: string = "QUEUED"; maxResults: int = 0): Recallable =
  ## listJobExecutionsForJob
  ## Lists the job executions for a job.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   status: string
  ##         : The status of the job.
  ##   maxResults: int
  ##             : The maximum number of results to be returned per request.
  var path_595991 = newJObject()
  var query_595992 = newJObject()
  add(query_595992, "nextToken", newJString(nextToken))
  add(path_595991, "jobId", newJString(jobId))
  add(query_595992, "status", newJString(status))
  add(query_595992, "maxResults", newJInt(maxResults))
  result = call_595990.call(path_595991, query_595992, nil, nil, nil)

var listJobExecutionsForJob* = Call_ListJobExecutionsForJob_595975(
    name: "listJobExecutionsForJob", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/jobs/{jobId}/things",
    validator: validate_ListJobExecutionsForJob_595976, base: "/",
    url: url_ListJobExecutionsForJob_595977, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobExecutionsForThing_595993 = ref object of OpenApiRestCall_593389
proc url_ListJobExecutionsForThing_595995(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListJobExecutionsForThing_595994(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the job executions for the specified thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The thing name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_595996 = path.getOrDefault("thingName")
  valid_595996 = validateParameter(valid_595996, JString, required = true,
                                 default = nil)
  if valid_595996 != nil:
    section.add "thingName", valid_595996
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: JInt
  ##             : The maximum number of results to be returned per request.
  section = newJObject()
  var valid_595997 = query.getOrDefault("nextToken")
  valid_595997 = validateParameter(valid_595997, JString, required = false,
                                 default = nil)
  if valid_595997 != nil:
    section.add "nextToken", valid_595997
  var valid_595998 = query.getOrDefault("status")
  valid_595998 = validateParameter(valid_595998, JString, required = false,
                                 default = newJString("QUEUED"))
  if valid_595998 != nil:
    section.add "status", valid_595998
  var valid_595999 = query.getOrDefault("maxResults")
  valid_595999 = validateParameter(valid_595999, JInt, required = false, default = nil)
  if valid_595999 != nil:
    section.add "maxResults", valid_595999
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596000 = header.getOrDefault("X-Amz-Signature")
  valid_596000 = validateParameter(valid_596000, JString, required = false,
                                 default = nil)
  if valid_596000 != nil:
    section.add "X-Amz-Signature", valid_596000
  var valid_596001 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596001 = validateParameter(valid_596001, JString, required = false,
                                 default = nil)
  if valid_596001 != nil:
    section.add "X-Amz-Content-Sha256", valid_596001
  var valid_596002 = header.getOrDefault("X-Amz-Date")
  valid_596002 = validateParameter(valid_596002, JString, required = false,
                                 default = nil)
  if valid_596002 != nil:
    section.add "X-Amz-Date", valid_596002
  var valid_596003 = header.getOrDefault("X-Amz-Credential")
  valid_596003 = validateParameter(valid_596003, JString, required = false,
                                 default = nil)
  if valid_596003 != nil:
    section.add "X-Amz-Credential", valid_596003
  var valid_596004 = header.getOrDefault("X-Amz-Security-Token")
  valid_596004 = validateParameter(valid_596004, JString, required = false,
                                 default = nil)
  if valid_596004 != nil:
    section.add "X-Amz-Security-Token", valid_596004
  var valid_596005 = header.getOrDefault("X-Amz-Algorithm")
  valid_596005 = validateParameter(valid_596005, JString, required = false,
                                 default = nil)
  if valid_596005 != nil:
    section.add "X-Amz-Algorithm", valid_596005
  var valid_596006 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596006 = validateParameter(valid_596006, JString, required = false,
                                 default = nil)
  if valid_596006 != nil:
    section.add "X-Amz-SignedHeaders", valid_596006
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596007: Call_ListJobExecutionsForThing_595993; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the job executions for the specified thing.
  ## 
  let valid = call_596007.validator(path, query, header, formData, body)
  let scheme = call_596007.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596007.url(scheme.get, call_596007.host, call_596007.base,
                         call_596007.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596007, url, valid)

proc call*(call_596008: Call_ListJobExecutionsForThing_595993; thingName: string;
          nextToken: string = ""; status: string = "QUEUED"; maxResults: int = 0): Recallable =
  ## listJobExecutionsForThing
  ## Lists the job executions for the specified thing.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingName: string (required)
  ##            : The thing name.
  ##   status: string
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: int
  ##             : The maximum number of results to be returned per request.
  var path_596009 = newJObject()
  var query_596010 = newJObject()
  add(query_596010, "nextToken", newJString(nextToken))
  add(path_596009, "thingName", newJString(thingName))
  add(query_596010, "status", newJString(status))
  add(query_596010, "maxResults", newJInt(maxResults))
  result = call_596008.call(path_596009, query_596010, nil, nil, nil)

var listJobExecutionsForThing* = Call_ListJobExecutionsForThing_595993(
    name: "listJobExecutionsForThing", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs",
    validator: validate_ListJobExecutionsForThing_595994, base: "/",
    url: url_ListJobExecutionsForThing_595995,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobs_596011 = ref object of OpenApiRestCall_593389
proc url_ListJobs_596013(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListJobs_596012(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists jobs.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: JString
  ##                 : A filter that limits the returned jobs to those for the specified group.
  ##   targetSelection: JString
  ##                  : Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. 
  ##   thingGroupId: JString
  ##               : A filter that limits the returned jobs to those for the specified group.
  ##   status: JString
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_596014 = query.getOrDefault("nextToken")
  valid_596014 = validateParameter(valid_596014, JString, required = false,
                                 default = nil)
  if valid_596014 != nil:
    section.add "nextToken", valid_596014
  var valid_596015 = query.getOrDefault("thingGroupName")
  valid_596015 = validateParameter(valid_596015, JString, required = false,
                                 default = nil)
  if valid_596015 != nil:
    section.add "thingGroupName", valid_596015
  var valid_596016 = query.getOrDefault("targetSelection")
  valid_596016 = validateParameter(valid_596016, JString, required = false,
                                 default = newJString("CONTINUOUS"))
  if valid_596016 != nil:
    section.add "targetSelection", valid_596016
  var valid_596017 = query.getOrDefault("thingGroupId")
  valid_596017 = validateParameter(valid_596017, JString, required = false,
                                 default = nil)
  if valid_596017 != nil:
    section.add "thingGroupId", valid_596017
  var valid_596018 = query.getOrDefault("status")
  valid_596018 = validateParameter(valid_596018, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_596018 != nil:
    section.add "status", valid_596018
  var valid_596019 = query.getOrDefault("maxResults")
  valid_596019 = validateParameter(valid_596019, JInt, required = false, default = nil)
  if valid_596019 != nil:
    section.add "maxResults", valid_596019
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596020 = header.getOrDefault("X-Amz-Signature")
  valid_596020 = validateParameter(valid_596020, JString, required = false,
                                 default = nil)
  if valid_596020 != nil:
    section.add "X-Amz-Signature", valid_596020
  var valid_596021 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596021 = validateParameter(valid_596021, JString, required = false,
                                 default = nil)
  if valid_596021 != nil:
    section.add "X-Amz-Content-Sha256", valid_596021
  var valid_596022 = header.getOrDefault("X-Amz-Date")
  valid_596022 = validateParameter(valid_596022, JString, required = false,
                                 default = nil)
  if valid_596022 != nil:
    section.add "X-Amz-Date", valid_596022
  var valid_596023 = header.getOrDefault("X-Amz-Credential")
  valid_596023 = validateParameter(valid_596023, JString, required = false,
                                 default = nil)
  if valid_596023 != nil:
    section.add "X-Amz-Credential", valid_596023
  var valid_596024 = header.getOrDefault("X-Amz-Security-Token")
  valid_596024 = validateParameter(valid_596024, JString, required = false,
                                 default = nil)
  if valid_596024 != nil:
    section.add "X-Amz-Security-Token", valid_596024
  var valid_596025 = header.getOrDefault("X-Amz-Algorithm")
  valid_596025 = validateParameter(valid_596025, JString, required = false,
                                 default = nil)
  if valid_596025 != nil:
    section.add "X-Amz-Algorithm", valid_596025
  var valid_596026 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596026 = validateParameter(valid_596026, JString, required = false,
                                 default = nil)
  if valid_596026 != nil:
    section.add "X-Amz-SignedHeaders", valid_596026
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596027: Call_ListJobs_596011; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists jobs.
  ## 
  let valid = call_596027.validator(path, query, header, formData, body)
  let scheme = call_596027.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596027.url(scheme.get, call_596027.host, call_596027.base,
                         call_596027.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596027, url, valid)

proc call*(call_596028: Call_ListJobs_596011; nextToken: string = "";
          thingGroupName: string = ""; targetSelection: string = "CONTINUOUS";
          thingGroupId: string = ""; status: string = "IN_PROGRESS"; maxResults: int = 0): Recallable =
  ## listJobs
  ## Lists jobs.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: string
  ##                 : A filter that limits the returned jobs to those for the specified group.
  ##   targetSelection: string
  ##                  : Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. 
  ##   thingGroupId: string
  ##               : A filter that limits the returned jobs to those for the specified group.
  ##   status: string
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var query_596029 = newJObject()
  add(query_596029, "nextToken", newJString(nextToken))
  add(query_596029, "thingGroupName", newJString(thingGroupName))
  add(query_596029, "targetSelection", newJString(targetSelection))
  add(query_596029, "thingGroupId", newJString(thingGroupId))
  add(query_596029, "status", newJString(status))
  add(query_596029, "maxResults", newJInt(maxResults))
  result = call_596028.call(nil, query_596029, nil, nil, nil)

var listJobs* = Call_ListJobs_596011(name: "listJobs", meth: HttpMethod.HttpGet,
                                  host: "iot.amazonaws.com", route: "/jobs",
                                  validator: validate_ListJobs_596012, base: "/",
                                  url: url_ListJobs_596013,
                                  schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListMitigationActions_596030 = ref object of OpenApiRestCall_593389
proc url_ListMitigationActions_596032(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListMitigationActions_596031(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   actionType: JString
  ##             : Specify a value to limit the result to mitigation actions with a specific action type.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  var valid_596033 = query.getOrDefault("nextToken")
  valid_596033 = validateParameter(valid_596033, JString, required = false,
                                 default = nil)
  if valid_596033 != nil:
    section.add "nextToken", valid_596033
  var valid_596034 = query.getOrDefault("actionType")
  valid_596034 = validateParameter(valid_596034, JString, required = false, default = newJString(
      "UPDATE_DEVICE_CERTIFICATE"))
  if valid_596034 != nil:
    section.add "actionType", valid_596034
  var valid_596035 = query.getOrDefault("maxResults")
  valid_596035 = validateParameter(valid_596035, JInt, required = false, default = nil)
  if valid_596035 != nil:
    section.add "maxResults", valid_596035
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596036 = header.getOrDefault("X-Amz-Signature")
  valid_596036 = validateParameter(valid_596036, JString, required = false,
                                 default = nil)
  if valid_596036 != nil:
    section.add "X-Amz-Signature", valid_596036
  var valid_596037 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596037 = validateParameter(valid_596037, JString, required = false,
                                 default = nil)
  if valid_596037 != nil:
    section.add "X-Amz-Content-Sha256", valid_596037
  var valid_596038 = header.getOrDefault("X-Amz-Date")
  valid_596038 = validateParameter(valid_596038, JString, required = false,
                                 default = nil)
  if valid_596038 != nil:
    section.add "X-Amz-Date", valid_596038
  var valid_596039 = header.getOrDefault("X-Amz-Credential")
  valid_596039 = validateParameter(valid_596039, JString, required = false,
                                 default = nil)
  if valid_596039 != nil:
    section.add "X-Amz-Credential", valid_596039
  var valid_596040 = header.getOrDefault("X-Amz-Security-Token")
  valid_596040 = validateParameter(valid_596040, JString, required = false,
                                 default = nil)
  if valid_596040 != nil:
    section.add "X-Amz-Security-Token", valid_596040
  var valid_596041 = header.getOrDefault("X-Amz-Algorithm")
  valid_596041 = validateParameter(valid_596041, JString, required = false,
                                 default = nil)
  if valid_596041 != nil:
    section.add "X-Amz-Algorithm", valid_596041
  var valid_596042 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596042 = validateParameter(valid_596042, JString, required = false,
                                 default = nil)
  if valid_596042 != nil:
    section.add "X-Amz-SignedHeaders", valid_596042
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596043: Call_ListMitigationActions_596030; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ## 
  let valid = call_596043.validator(path, query, header, formData, body)
  let scheme = call_596043.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596043.url(scheme.get, call_596043.host, call_596043.base,
                         call_596043.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596043, url, valid)

proc call*(call_596044: Call_ListMitigationActions_596030; nextToken: string = "";
          actionType: string = "UPDATE_DEVICE_CERTIFICATE"; maxResults: int = 0): Recallable =
  ## listMitigationActions
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   actionType: string
  ##             : Specify a value to limit the result to mitigation actions with a specific action type.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_596045 = newJObject()
  add(query_596045, "nextToken", newJString(nextToken))
  add(query_596045, "actionType", newJString(actionType))
  add(query_596045, "maxResults", newJInt(maxResults))
  result = call_596044.call(nil, query_596045, nil, nil, nil)

var listMitigationActions* = Call_ListMitigationActions_596030(
    name: "listMitigationActions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions",
    validator: validate_ListMitigationActions_596031, base: "/",
    url: url_ListMitigationActions_596032, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListOTAUpdates_596046 = ref object of OpenApiRestCall_593389
proc url_ListOTAUpdates_596048(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListOTAUpdates_596047(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists OTA updates.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token used to retrieve the next set of results.
  ##   otaUpdateStatus: JString
  ##                  : The OTA update job status.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_596049 = query.getOrDefault("nextToken")
  valid_596049 = validateParameter(valid_596049, JString, required = false,
                                 default = nil)
  if valid_596049 != nil:
    section.add "nextToken", valid_596049
  var valid_596050 = query.getOrDefault("otaUpdateStatus")
  valid_596050 = validateParameter(valid_596050, JString, required = false,
                                 default = newJString("CREATE_PENDING"))
  if valid_596050 != nil:
    section.add "otaUpdateStatus", valid_596050
  var valid_596051 = query.getOrDefault("maxResults")
  valid_596051 = validateParameter(valid_596051, JInt, required = false, default = nil)
  if valid_596051 != nil:
    section.add "maxResults", valid_596051
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596052 = header.getOrDefault("X-Amz-Signature")
  valid_596052 = validateParameter(valid_596052, JString, required = false,
                                 default = nil)
  if valid_596052 != nil:
    section.add "X-Amz-Signature", valid_596052
  var valid_596053 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596053 = validateParameter(valid_596053, JString, required = false,
                                 default = nil)
  if valid_596053 != nil:
    section.add "X-Amz-Content-Sha256", valid_596053
  var valid_596054 = header.getOrDefault("X-Amz-Date")
  valid_596054 = validateParameter(valid_596054, JString, required = false,
                                 default = nil)
  if valid_596054 != nil:
    section.add "X-Amz-Date", valid_596054
  var valid_596055 = header.getOrDefault("X-Amz-Credential")
  valid_596055 = validateParameter(valid_596055, JString, required = false,
                                 default = nil)
  if valid_596055 != nil:
    section.add "X-Amz-Credential", valid_596055
  var valid_596056 = header.getOrDefault("X-Amz-Security-Token")
  valid_596056 = validateParameter(valid_596056, JString, required = false,
                                 default = nil)
  if valid_596056 != nil:
    section.add "X-Amz-Security-Token", valid_596056
  var valid_596057 = header.getOrDefault("X-Amz-Algorithm")
  valid_596057 = validateParameter(valid_596057, JString, required = false,
                                 default = nil)
  if valid_596057 != nil:
    section.add "X-Amz-Algorithm", valid_596057
  var valid_596058 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596058 = validateParameter(valid_596058, JString, required = false,
                                 default = nil)
  if valid_596058 != nil:
    section.add "X-Amz-SignedHeaders", valid_596058
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596059: Call_ListOTAUpdates_596046; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists OTA updates.
  ## 
  let valid = call_596059.validator(path, query, header, formData, body)
  let scheme = call_596059.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596059.url(scheme.get, call_596059.host, call_596059.base,
                         call_596059.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596059, url, valid)

proc call*(call_596060: Call_ListOTAUpdates_596046; nextToken: string = "";
          otaUpdateStatus: string = "CREATE_PENDING"; maxResults: int = 0): Recallable =
  ## listOTAUpdates
  ## Lists OTA updates.
  ##   nextToken: string
  ##            : A token used to retrieve the next set of results.
  ##   otaUpdateStatus: string
  ##                  : The OTA update job status.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_596061 = newJObject()
  add(query_596061, "nextToken", newJString(nextToken))
  add(query_596061, "otaUpdateStatus", newJString(otaUpdateStatus))
  add(query_596061, "maxResults", newJInt(maxResults))
  result = call_596060.call(nil, query_596061, nil, nil, nil)

var listOTAUpdates* = Call_ListOTAUpdates_596046(name: "listOTAUpdates",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/otaUpdates",
    validator: validate_ListOTAUpdates_596047, base: "/", url: url_ListOTAUpdates_596048,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListOutgoingCertificates_596062 = ref object of OpenApiRestCall_593389
proc url_ListOutgoingCertificates_596064(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListOutgoingCertificates_596063(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists certificates that are being transferred but not yet accepted.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_596065 = query.getOrDefault("isAscendingOrder")
  valid_596065 = validateParameter(valid_596065, JBool, required = false, default = nil)
  if valid_596065 != nil:
    section.add "isAscendingOrder", valid_596065
  var valid_596066 = query.getOrDefault("pageSize")
  valid_596066 = validateParameter(valid_596066, JInt, required = false, default = nil)
  if valid_596066 != nil:
    section.add "pageSize", valid_596066
  var valid_596067 = query.getOrDefault("marker")
  valid_596067 = validateParameter(valid_596067, JString, required = false,
                                 default = nil)
  if valid_596067 != nil:
    section.add "marker", valid_596067
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596068 = header.getOrDefault("X-Amz-Signature")
  valid_596068 = validateParameter(valid_596068, JString, required = false,
                                 default = nil)
  if valid_596068 != nil:
    section.add "X-Amz-Signature", valid_596068
  var valid_596069 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596069 = validateParameter(valid_596069, JString, required = false,
                                 default = nil)
  if valid_596069 != nil:
    section.add "X-Amz-Content-Sha256", valid_596069
  var valid_596070 = header.getOrDefault("X-Amz-Date")
  valid_596070 = validateParameter(valid_596070, JString, required = false,
                                 default = nil)
  if valid_596070 != nil:
    section.add "X-Amz-Date", valid_596070
  var valid_596071 = header.getOrDefault("X-Amz-Credential")
  valid_596071 = validateParameter(valid_596071, JString, required = false,
                                 default = nil)
  if valid_596071 != nil:
    section.add "X-Amz-Credential", valid_596071
  var valid_596072 = header.getOrDefault("X-Amz-Security-Token")
  valid_596072 = validateParameter(valid_596072, JString, required = false,
                                 default = nil)
  if valid_596072 != nil:
    section.add "X-Amz-Security-Token", valid_596072
  var valid_596073 = header.getOrDefault("X-Amz-Algorithm")
  valid_596073 = validateParameter(valid_596073, JString, required = false,
                                 default = nil)
  if valid_596073 != nil:
    section.add "X-Amz-Algorithm", valid_596073
  var valid_596074 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596074 = validateParameter(valid_596074, JString, required = false,
                                 default = nil)
  if valid_596074 != nil:
    section.add "X-Amz-SignedHeaders", valid_596074
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596075: Call_ListOutgoingCertificates_596062; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists certificates that are being transferred but not yet accepted.
  ## 
  let valid = call_596075.validator(path, query, header, formData, body)
  let scheme = call_596075.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596075.url(scheme.get, call_596075.host, call_596075.base,
                         call_596075.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596075, url, valid)

proc call*(call_596076: Call_ListOutgoingCertificates_596062;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listOutgoingCertificates
  ## Lists certificates that are being transferred but not yet accepted.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_596077 = newJObject()
  add(query_596077, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_596077, "pageSize", newJInt(pageSize))
  add(query_596077, "marker", newJString(marker))
  result = call_596076.call(nil, query_596077, nil, nil, nil)

var listOutgoingCertificates* = Call_ListOutgoingCertificates_596062(
    name: "listOutgoingCertificates", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates-out-going",
    validator: validate_ListOutgoingCertificates_596063, base: "/",
    url: url_ListOutgoingCertificates_596064, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicies_596078 = ref object of OpenApiRestCall_593389
proc url_ListPolicies_596080(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPolicies_596079(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists your policies.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_596081 = query.getOrDefault("isAscendingOrder")
  valid_596081 = validateParameter(valid_596081, JBool, required = false, default = nil)
  if valid_596081 != nil:
    section.add "isAscendingOrder", valid_596081
  var valid_596082 = query.getOrDefault("pageSize")
  valid_596082 = validateParameter(valid_596082, JInt, required = false, default = nil)
  if valid_596082 != nil:
    section.add "pageSize", valid_596082
  var valid_596083 = query.getOrDefault("marker")
  valid_596083 = validateParameter(valid_596083, JString, required = false,
                                 default = nil)
  if valid_596083 != nil:
    section.add "marker", valid_596083
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596084 = header.getOrDefault("X-Amz-Signature")
  valid_596084 = validateParameter(valid_596084, JString, required = false,
                                 default = nil)
  if valid_596084 != nil:
    section.add "X-Amz-Signature", valid_596084
  var valid_596085 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596085 = validateParameter(valid_596085, JString, required = false,
                                 default = nil)
  if valid_596085 != nil:
    section.add "X-Amz-Content-Sha256", valid_596085
  var valid_596086 = header.getOrDefault("X-Amz-Date")
  valid_596086 = validateParameter(valid_596086, JString, required = false,
                                 default = nil)
  if valid_596086 != nil:
    section.add "X-Amz-Date", valid_596086
  var valid_596087 = header.getOrDefault("X-Amz-Credential")
  valid_596087 = validateParameter(valid_596087, JString, required = false,
                                 default = nil)
  if valid_596087 != nil:
    section.add "X-Amz-Credential", valid_596087
  var valid_596088 = header.getOrDefault("X-Amz-Security-Token")
  valid_596088 = validateParameter(valid_596088, JString, required = false,
                                 default = nil)
  if valid_596088 != nil:
    section.add "X-Amz-Security-Token", valid_596088
  var valid_596089 = header.getOrDefault("X-Amz-Algorithm")
  valid_596089 = validateParameter(valid_596089, JString, required = false,
                                 default = nil)
  if valid_596089 != nil:
    section.add "X-Amz-Algorithm", valid_596089
  var valid_596090 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596090 = validateParameter(valid_596090, JString, required = false,
                                 default = nil)
  if valid_596090 != nil:
    section.add "X-Amz-SignedHeaders", valid_596090
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596091: Call_ListPolicies_596078; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists your policies.
  ## 
  let valid = call_596091.validator(path, query, header, formData, body)
  let scheme = call_596091.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596091.url(scheme.get, call_596091.host, call_596091.base,
                         call_596091.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596091, url, valid)

proc call*(call_596092: Call_ListPolicies_596078; isAscendingOrder: bool = false;
          pageSize: int = 0; marker: string = ""): Recallable =
  ## listPolicies
  ## Lists your policies.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_596093 = newJObject()
  add(query_596093, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_596093, "pageSize", newJInt(pageSize))
  add(query_596093, "marker", newJString(marker))
  result = call_596092.call(nil, query_596093, nil, nil, nil)

var listPolicies* = Call_ListPolicies_596078(name: "listPolicies",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/policies",
    validator: validate_ListPolicies_596079, base: "/", url: url_ListPolicies_596080,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicyPrincipals_596094 = ref object of OpenApiRestCall_593389
proc url_ListPolicyPrincipals_596096(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPolicyPrincipals_596095(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_596097 = query.getOrDefault("isAscendingOrder")
  valid_596097 = validateParameter(valid_596097, JBool, required = false, default = nil)
  if valid_596097 != nil:
    section.add "isAscendingOrder", valid_596097
  var valid_596098 = query.getOrDefault("pageSize")
  valid_596098 = validateParameter(valid_596098, JInt, required = false, default = nil)
  if valid_596098 != nil:
    section.add "pageSize", valid_596098
  var valid_596099 = query.getOrDefault("marker")
  valid_596099 = validateParameter(valid_596099, JString, required = false,
                                 default = nil)
  if valid_596099 != nil:
    section.add "marker", valid_596099
  result.add "query", section
  ## parameters in `header` object:
  ##   x-amzn-iot-policy: JString (required)
  ##                    : The policy name.
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-policy` field"
  var valid_596100 = header.getOrDefault("x-amzn-iot-policy")
  valid_596100 = validateParameter(valid_596100, JString, required = true,
                                 default = nil)
  if valid_596100 != nil:
    section.add "x-amzn-iot-policy", valid_596100
  var valid_596101 = header.getOrDefault("X-Amz-Signature")
  valid_596101 = validateParameter(valid_596101, JString, required = false,
                                 default = nil)
  if valid_596101 != nil:
    section.add "X-Amz-Signature", valid_596101
  var valid_596102 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596102 = validateParameter(valid_596102, JString, required = false,
                                 default = nil)
  if valid_596102 != nil:
    section.add "X-Amz-Content-Sha256", valid_596102
  var valid_596103 = header.getOrDefault("X-Amz-Date")
  valid_596103 = validateParameter(valid_596103, JString, required = false,
                                 default = nil)
  if valid_596103 != nil:
    section.add "X-Amz-Date", valid_596103
  var valid_596104 = header.getOrDefault("X-Amz-Credential")
  valid_596104 = validateParameter(valid_596104, JString, required = false,
                                 default = nil)
  if valid_596104 != nil:
    section.add "X-Amz-Credential", valid_596104
  var valid_596105 = header.getOrDefault("X-Amz-Security-Token")
  valid_596105 = validateParameter(valid_596105, JString, required = false,
                                 default = nil)
  if valid_596105 != nil:
    section.add "X-Amz-Security-Token", valid_596105
  var valid_596106 = header.getOrDefault("X-Amz-Algorithm")
  valid_596106 = validateParameter(valid_596106, JString, required = false,
                                 default = nil)
  if valid_596106 != nil:
    section.add "X-Amz-Algorithm", valid_596106
  var valid_596107 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596107 = validateParameter(valid_596107, JString, required = false,
                                 default = nil)
  if valid_596107 != nil:
    section.add "X-Amz-SignedHeaders", valid_596107
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596108: Call_ListPolicyPrincipals_596094; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ## 
  let valid = call_596108.validator(path, query, header, formData, body)
  let scheme = call_596108.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596108.url(scheme.get, call_596108.host, call_596108.base,
                         call_596108.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596108, url, valid)

proc call*(call_596109: Call_ListPolicyPrincipals_596094;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listPolicyPrincipals
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_596110 = newJObject()
  add(query_596110, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_596110, "pageSize", newJInt(pageSize))
  add(query_596110, "marker", newJString(marker))
  result = call_596109.call(nil, query_596110, nil, nil, nil)

var listPolicyPrincipals* = Call_ListPolicyPrincipals_596094(
    name: "listPolicyPrincipals", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/policy-principals#x-amzn-iot-policy",
    validator: validate_ListPolicyPrincipals_596095, base: "/",
    url: url_ListPolicyPrincipals_596096, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPrincipalPolicies_596111 = ref object of OpenApiRestCall_593389
proc url_ListPrincipalPolicies_596113(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPrincipalPolicies_596112(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, results are returned in ascending creation order.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_596114 = query.getOrDefault("isAscendingOrder")
  valid_596114 = validateParameter(valid_596114, JBool, required = false, default = nil)
  if valid_596114 != nil:
    section.add "isAscendingOrder", valid_596114
  var valid_596115 = query.getOrDefault("pageSize")
  valid_596115 = validateParameter(valid_596115, JInt, required = false, default = nil)
  if valid_596115 != nil:
    section.add "pageSize", valid_596115
  var valid_596116 = query.getOrDefault("marker")
  valid_596116 = validateParameter(valid_596116, JString, required = false,
                                 default = nil)
  if valid_596116 != nil:
    section.add "marker", valid_596116
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : The principal.
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596117 = header.getOrDefault("X-Amz-Signature")
  valid_596117 = validateParameter(valid_596117, JString, required = false,
                                 default = nil)
  if valid_596117 != nil:
    section.add "X-Amz-Signature", valid_596117
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_596118 = header.getOrDefault("x-amzn-iot-principal")
  valid_596118 = validateParameter(valid_596118, JString, required = true,
                                 default = nil)
  if valid_596118 != nil:
    section.add "x-amzn-iot-principal", valid_596118
  var valid_596119 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596119 = validateParameter(valid_596119, JString, required = false,
                                 default = nil)
  if valid_596119 != nil:
    section.add "X-Amz-Content-Sha256", valid_596119
  var valid_596120 = header.getOrDefault("X-Amz-Date")
  valid_596120 = validateParameter(valid_596120, JString, required = false,
                                 default = nil)
  if valid_596120 != nil:
    section.add "X-Amz-Date", valid_596120
  var valid_596121 = header.getOrDefault("X-Amz-Credential")
  valid_596121 = validateParameter(valid_596121, JString, required = false,
                                 default = nil)
  if valid_596121 != nil:
    section.add "X-Amz-Credential", valid_596121
  var valid_596122 = header.getOrDefault("X-Amz-Security-Token")
  valid_596122 = validateParameter(valid_596122, JString, required = false,
                                 default = nil)
  if valid_596122 != nil:
    section.add "X-Amz-Security-Token", valid_596122
  var valid_596123 = header.getOrDefault("X-Amz-Algorithm")
  valid_596123 = validateParameter(valid_596123, JString, required = false,
                                 default = nil)
  if valid_596123 != nil:
    section.add "X-Amz-Algorithm", valid_596123
  var valid_596124 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596124 = validateParameter(valid_596124, JString, required = false,
                                 default = nil)
  if valid_596124 != nil:
    section.add "X-Amz-SignedHeaders", valid_596124
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596125: Call_ListPrincipalPolicies_596111; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ## 
  let valid = call_596125.validator(path, query, header, formData, body)
  let scheme = call_596125.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596125.url(scheme.get, call_596125.host, call_596125.base,
                         call_596125.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596125, url, valid)

proc call*(call_596126: Call_ListPrincipalPolicies_596111;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listPrincipalPolicies
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, results are returned in ascending creation order.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_596127 = newJObject()
  add(query_596127, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_596127, "pageSize", newJInt(pageSize))
  add(query_596127, "marker", newJString(marker))
  result = call_596126.call(nil, query_596127, nil, nil, nil)

var listPrincipalPolicies* = Call_ListPrincipalPolicies_596111(
    name: "listPrincipalPolicies", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/principal-policies#x-amzn-iot-principal",
    validator: validate_ListPrincipalPolicies_596112, base: "/",
    url: url_ListPrincipalPolicies_596113, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPrincipalThings_596128 = ref object of OpenApiRestCall_593389
proc url_ListPrincipalThings_596130(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPrincipalThings_596129(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  section = newJObject()
  var valid_596131 = query.getOrDefault("nextToken")
  valid_596131 = validateParameter(valid_596131, JString, required = false,
                                 default = nil)
  if valid_596131 != nil:
    section.add "nextToken", valid_596131
  var valid_596132 = query.getOrDefault("maxResults")
  valid_596132 = validateParameter(valid_596132, JInt, required = false, default = nil)
  if valid_596132 != nil:
    section.add "maxResults", valid_596132
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : The principal.
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596133 = header.getOrDefault("X-Amz-Signature")
  valid_596133 = validateParameter(valid_596133, JString, required = false,
                                 default = nil)
  if valid_596133 != nil:
    section.add "X-Amz-Signature", valid_596133
  var valid_596134 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596134 = validateParameter(valid_596134, JString, required = false,
                                 default = nil)
  if valid_596134 != nil:
    section.add "X-Amz-Content-Sha256", valid_596134
  var valid_596135 = header.getOrDefault("X-Amz-Date")
  valid_596135 = validateParameter(valid_596135, JString, required = false,
                                 default = nil)
  if valid_596135 != nil:
    section.add "X-Amz-Date", valid_596135
  var valid_596136 = header.getOrDefault("X-Amz-Credential")
  valid_596136 = validateParameter(valid_596136, JString, required = false,
                                 default = nil)
  if valid_596136 != nil:
    section.add "X-Amz-Credential", valid_596136
  var valid_596137 = header.getOrDefault("X-Amz-Security-Token")
  valid_596137 = validateParameter(valid_596137, JString, required = false,
                                 default = nil)
  if valid_596137 != nil:
    section.add "X-Amz-Security-Token", valid_596137
  var valid_596138 = header.getOrDefault("X-Amz-Algorithm")
  valid_596138 = validateParameter(valid_596138, JString, required = false,
                                 default = nil)
  if valid_596138 != nil:
    section.add "X-Amz-Algorithm", valid_596138
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_596139 = header.getOrDefault("x-amzn-principal")
  valid_596139 = validateParameter(valid_596139, JString, required = true,
                                 default = nil)
  if valid_596139 != nil:
    section.add "x-amzn-principal", valid_596139
  var valid_596140 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596140 = validateParameter(valid_596140, JString, required = false,
                                 default = nil)
  if valid_596140 != nil:
    section.add "X-Amz-SignedHeaders", valid_596140
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596141: Call_ListPrincipalThings_596128; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ## 
  let valid = call_596141.validator(path, query, header, formData, body)
  let scheme = call_596141.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596141.url(scheme.get, call_596141.host, call_596141.base,
                         call_596141.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596141, url, valid)

proc call*(call_596142: Call_ListPrincipalThings_596128; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listPrincipalThings
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  var query_596143 = newJObject()
  add(query_596143, "nextToken", newJString(nextToken))
  add(query_596143, "maxResults", newJInt(maxResults))
  result = call_596142.call(nil, query_596143, nil, nil, nil)

var listPrincipalThings* = Call_ListPrincipalThings_596128(
    name: "listPrincipalThings", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/principals/things#x-amzn-principal",
    validator: validate_ListPrincipalThings_596129, base: "/",
    url: url_ListPrincipalThings_596130, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListRoleAliases_596144 = ref object of OpenApiRestCall_593389
proc url_ListRoleAliases_596146(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListRoleAliases_596145(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Lists the role aliases registered in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Return the list of role aliases in ascending alphabetical order.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  section = newJObject()
  var valid_596147 = query.getOrDefault("isAscendingOrder")
  valid_596147 = validateParameter(valid_596147, JBool, required = false, default = nil)
  if valid_596147 != nil:
    section.add "isAscendingOrder", valid_596147
  var valid_596148 = query.getOrDefault("pageSize")
  valid_596148 = validateParameter(valid_596148, JInt, required = false, default = nil)
  if valid_596148 != nil:
    section.add "pageSize", valid_596148
  var valid_596149 = query.getOrDefault("marker")
  valid_596149 = validateParameter(valid_596149, JString, required = false,
                                 default = nil)
  if valid_596149 != nil:
    section.add "marker", valid_596149
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596150 = header.getOrDefault("X-Amz-Signature")
  valid_596150 = validateParameter(valid_596150, JString, required = false,
                                 default = nil)
  if valid_596150 != nil:
    section.add "X-Amz-Signature", valid_596150
  var valid_596151 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596151 = validateParameter(valid_596151, JString, required = false,
                                 default = nil)
  if valid_596151 != nil:
    section.add "X-Amz-Content-Sha256", valid_596151
  var valid_596152 = header.getOrDefault("X-Amz-Date")
  valid_596152 = validateParameter(valid_596152, JString, required = false,
                                 default = nil)
  if valid_596152 != nil:
    section.add "X-Amz-Date", valid_596152
  var valid_596153 = header.getOrDefault("X-Amz-Credential")
  valid_596153 = validateParameter(valid_596153, JString, required = false,
                                 default = nil)
  if valid_596153 != nil:
    section.add "X-Amz-Credential", valid_596153
  var valid_596154 = header.getOrDefault("X-Amz-Security-Token")
  valid_596154 = validateParameter(valid_596154, JString, required = false,
                                 default = nil)
  if valid_596154 != nil:
    section.add "X-Amz-Security-Token", valid_596154
  var valid_596155 = header.getOrDefault("X-Amz-Algorithm")
  valid_596155 = validateParameter(valid_596155, JString, required = false,
                                 default = nil)
  if valid_596155 != nil:
    section.add "X-Amz-Algorithm", valid_596155
  var valid_596156 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596156 = validateParameter(valid_596156, JString, required = false,
                                 default = nil)
  if valid_596156 != nil:
    section.add "X-Amz-SignedHeaders", valid_596156
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596157: Call_ListRoleAliases_596144; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the role aliases registered in your account.
  ## 
  let valid = call_596157.validator(path, query, header, formData, body)
  let scheme = call_596157.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596157.url(scheme.get, call_596157.host, call_596157.base,
                         call_596157.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596157, url, valid)

proc call*(call_596158: Call_ListRoleAliases_596144;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listRoleAliases
  ## Lists the role aliases registered in your account.
  ##   isAscendingOrder: bool
  ##                   : Return the list of role aliases in ascending alphabetical order.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  var query_596159 = newJObject()
  add(query_596159, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_596159, "pageSize", newJInt(pageSize))
  add(query_596159, "marker", newJString(marker))
  result = call_596158.call(nil, query_596159, nil, nil, nil)

var listRoleAliases* = Call_ListRoleAliases_596144(name: "listRoleAliases",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/role-aliases",
    validator: validate_ListRoleAliases_596145, base: "/", url: url_ListRoleAliases_596146,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListScheduledAudits_596160 = ref object of OpenApiRestCall_593389
proc url_ListScheduledAudits_596162(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListScheduledAudits_596161(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists all of your scheduled audits.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  var valid_596163 = query.getOrDefault("nextToken")
  valid_596163 = validateParameter(valid_596163, JString, required = false,
                                 default = nil)
  if valid_596163 != nil:
    section.add "nextToken", valid_596163
  var valid_596164 = query.getOrDefault("maxResults")
  valid_596164 = validateParameter(valid_596164, JInt, required = false, default = nil)
  if valid_596164 != nil:
    section.add "maxResults", valid_596164
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596165 = header.getOrDefault("X-Amz-Signature")
  valid_596165 = validateParameter(valid_596165, JString, required = false,
                                 default = nil)
  if valid_596165 != nil:
    section.add "X-Amz-Signature", valid_596165
  var valid_596166 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596166 = validateParameter(valid_596166, JString, required = false,
                                 default = nil)
  if valid_596166 != nil:
    section.add "X-Amz-Content-Sha256", valid_596166
  var valid_596167 = header.getOrDefault("X-Amz-Date")
  valid_596167 = validateParameter(valid_596167, JString, required = false,
                                 default = nil)
  if valid_596167 != nil:
    section.add "X-Amz-Date", valid_596167
  var valid_596168 = header.getOrDefault("X-Amz-Credential")
  valid_596168 = validateParameter(valid_596168, JString, required = false,
                                 default = nil)
  if valid_596168 != nil:
    section.add "X-Amz-Credential", valid_596168
  var valid_596169 = header.getOrDefault("X-Amz-Security-Token")
  valid_596169 = validateParameter(valid_596169, JString, required = false,
                                 default = nil)
  if valid_596169 != nil:
    section.add "X-Amz-Security-Token", valid_596169
  var valid_596170 = header.getOrDefault("X-Amz-Algorithm")
  valid_596170 = validateParameter(valid_596170, JString, required = false,
                                 default = nil)
  if valid_596170 != nil:
    section.add "X-Amz-Algorithm", valid_596170
  var valid_596171 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596171 = validateParameter(valid_596171, JString, required = false,
                                 default = nil)
  if valid_596171 != nil:
    section.add "X-Amz-SignedHeaders", valid_596171
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596172: Call_ListScheduledAudits_596160; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all of your scheduled audits.
  ## 
  let valid = call_596172.validator(path, query, header, formData, body)
  let scheme = call_596172.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596172.url(scheme.get, call_596172.host, call_596172.base,
                         call_596172.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596172, url, valid)

proc call*(call_596173: Call_ListScheduledAudits_596160; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listScheduledAudits
  ## Lists all of your scheduled audits.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_596174 = newJObject()
  add(query_596174, "nextToken", newJString(nextToken))
  add(query_596174, "maxResults", newJInt(maxResults))
  result = call_596173.call(nil, query_596174, nil, nil, nil)

var listScheduledAudits* = Call_ListScheduledAudits_596160(
    name: "listScheduledAudits", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/scheduledaudits",
    validator: validate_ListScheduledAudits_596161, base: "/",
    url: url_ListScheduledAudits_596162, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListSecurityProfiles_596175 = ref object of OpenApiRestCall_593389
proc url_ListSecurityProfiles_596177(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListSecurityProfiles_596176(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_596178 = query.getOrDefault("nextToken")
  valid_596178 = validateParameter(valid_596178, JString, required = false,
                                 default = nil)
  if valid_596178 != nil:
    section.add "nextToken", valid_596178
  var valid_596179 = query.getOrDefault("maxResults")
  valid_596179 = validateParameter(valid_596179, JInt, required = false, default = nil)
  if valid_596179 != nil:
    section.add "maxResults", valid_596179
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596180 = header.getOrDefault("X-Amz-Signature")
  valid_596180 = validateParameter(valid_596180, JString, required = false,
                                 default = nil)
  if valid_596180 != nil:
    section.add "X-Amz-Signature", valid_596180
  var valid_596181 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596181 = validateParameter(valid_596181, JString, required = false,
                                 default = nil)
  if valid_596181 != nil:
    section.add "X-Amz-Content-Sha256", valid_596181
  var valid_596182 = header.getOrDefault("X-Amz-Date")
  valid_596182 = validateParameter(valid_596182, JString, required = false,
                                 default = nil)
  if valid_596182 != nil:
    section.add "X-Amz-Date", valid_596182
  var valid_596183 = header.getOrDefault("X-Amz-Credential")
  valid_596183 = validateParameter(valid_596183, JString, required = false,
                                 default = nil)
  if valid_596183 != nil:
    section.add "X-Amz-Credential", valid_596183
  var valid_596184 = header.getOrDefault("X-Amz-Security-Token")
  valid_596184 = validateParameter(valid_596184, JString, required = false,
                                 default = nil)
  if valid_596184 != nil:
    section.add "X-Amz-Security-Token", valid_596184
  var valid_596185 = header.getOrDefault("X-Amz-Algorithm")
  valid_596185 = validateParameter(valid_596185, JString, required = false,
                                 default = nil)
  if valid_596185 != nil:
    section.add "X-Amz-Algorithm", valid_596185
  var valid_596186 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596186 = validateParameter(valid_596186, JString, required = false,
                                 default = nil)
  if valid_596186 != nil:
    section.add "X-Amz-SignedHeaders", valid_596186
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596187: Call_ListSecurityProfiles_596175; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ## 
  let valid = call_596187.validator(path, query, header, formData, body)
  let scheme = call_596187.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596187.url(scheme.get, call_596187.host, call_596187.base,
                         call_596187.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596187, url, valid)

proc call*(call_596188: Call_ListSecurityProfiles_596175; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listSecurityProfiles
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_596189 = newJObject()
  add(query_596189, "nextToken", newJString(nextToken))
  add(query_596189, "maxResults", newJInt(maxResults))
  result = call_596188.call(nil, query_596189, nil, nil, nil)

var listSecurityProfiles* = Call_ListSecurityProfiles_596175(
    name: "listSecurityProfiles", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/security-profiles",
    validator: validate_ListSecurityProfiles_596176, base: "/",
    url: url_ListSecurityProfiles_596177, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListSecurityProfilesForTarget_596190 = ref object of OpenApiRestCall_593389
proc url_ListSecurityProfilesForTarget_596192(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListSecurityProfilesForTarget_596191(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   recursive: JBool
  ##            : If true, return child groups too.
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the target (thing group) whose attached security profiles you want to get.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_596193 = query.getOrDefault("nextToken")
  valid_596193 = validateParameter(valid_596193, JString, required = false,
                                 default = nil)
  if valid_596193 != nil:
    section.add "nextToken", valid_596193
  var valid_596194 = query.getOrDefault("recursive")
  valid_596194 = validateParameter(valid_596194, JBool, required = false, default = nil)
  if valid_596194 != nil:
    section.add "recursive", valid_596194
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_596195 = query.getOrDefault("securityProfileTargetArn")
  valid_596195 = validateParameter(valid_596195, JString, required = true,
                                 default = nil)
  if valid_596195 != nil:
    section.add "securityProfileTargetArn", valid_596195
  var valid_596196 = query.getOrDefault("maxResults")
  valid_596196 = validateParameter(valid_596196, JInt, required = false, default = nil)
  if valid_596196 != nil:
    section.add "maxResults", valid_596196
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596197 = header.getOrDefault("X-Amz-Signature")
  valid_596197 = validateParameter(valid_596197, JString, required = false,
                                 default = nil)
  if valid_596197 != nil:
    section.add "X-Amz-Signature", valid_596197
  var valid_596198 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596198 = validateParameter(valid_596198, JString, required = false,
                                 default = nil)
  if valid_596198 != nil:
    section.add "X-Amz-Content-Sha256", valid_596198
  var valid_596199 = header.getOrDefault("X-Amz-Date")
  valid_596199 = validateParameter(valid_596199, JString, required = false,
                                 default = nil)
  if valid_596199 != nil:
    section.add "X-Amz-Date", valid_596199
  var valid_596200 = header.getOrDefault("X-Amz-Credential")
  valid_596200 = validateParameter(valid_596200, JString, required = false,
                                 default = nil)
  if valid_596200 != nil:
    section.add "X-Amz-Credential", valid_596200
  var valid_596201 = header.getOrDefault("X-Amz-Security-Token")
  valid_596201 = validateParameter(valid_596201, JString, required = false,
                                 default = nil)
  if valid_596201 != nil:
    section.add "X-Amz-Security-Token", valid_596201
  var valid_596202 = header.getOrDefault("X-Amz-Algorithm")
  valid_596202 = validateParameter(valid_596202, JString, required = false,
                                 default = nil)
  if valid_596202 != nil:
    section.add "X-Amz-Algorithm", valid_596202
  var valid_596203 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596203 = validateParameter(valid_596203, JString, required = false,
                                 default = nil)
  if valid_596203 != nil:
    section.add "X-Amz-SignedHeaders", valid_596203
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596204: Call_ListSecurityProfilesForTarget_596190; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ## 
  let valid = call_596204.validator(path, query, header, formData, body)
  let scheme = call_596204.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596204.url(scheme.get, call_596204.host, call_596204.base,
                         call_596204.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596204, url, valid)

proc call*(call_596205: Call_ListSecurityProfilesForTarget_596190;
          securityProfileTargetArn: string; nextToken: string = "";
          recursive: bool = false; maxResults: int = 0): Recallable =
  ## listSecurityProfilesForTarget
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   recursive: bool
  ##            : If true, return child groups too.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the target (thing group) whose attached security profiles you want to get.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_596206 = newJObject()
  add(query_596206, "nextToken", newJString(nextToken))
  add(query_596206, "recursive", newJBool(recursive))
  add(query_596206, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(query_596206, "maxResults", newJInt(maxResults))
  result = call_596205.call(nil, query_596206, nil, nil, nil)

var listSecurityProfilesForTarget* = Call_ListSecurityProfilesForTarget_596190(
    name: "listSecurityProfilesForTarget", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/security-profiles-for-target#securityProfileTargetArn",
    validator: validate_ListSecurityProfilesForTarget_596191, base: "/",
    url: url_ListSecurityProfilesForTarget_596192,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListStreams_596207 = ref object of OpenApiRestCall_593389
proc url_ListStreams_596209(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListStreams_596208(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all of the streams in your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token used to get the next set of results.
  ##   isAscendingOrder: JBool
  ##                   : Set to true to return the list of streams in ascending order.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at a time.
  section = newJObject()
  var valid_596210 = query.getOrDefault("nextToken")
  valid_596210 = validateParameter(valid_596210, JString, required = false,
                                 default = nil)
  if valid_596210 != nil:
    section.add "nextToken", valid_596210
  var valid_596211 = query.getOrDefault("isAscendingOrder")
  valid_596211 = validateParameter(valid_596211, JBool, required = false, default = nil)
  if valid_596211 != nil:
    section.add "isAscendingOrder", valid_596211
  var valid_596212 = query.getOrDefault("maxResults")
  valid_596212 = validateParameter(valid_596212, JInt, required = false, default = nil)
  if valid_596212 != nil:
    section.add "maxResults", valid_596212
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596213 = header.getOrDefault("X-Amz-Signature")
  valid_596213 = validateParameter(valid_596213, JString, required = false,
                                 default = nil)
  if valid_596213 != nil:
    section.add "X-Amz-Signature", valid_596213
  var valid_596214 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596214 = validateParameter(valid_596214, JString, required = false,
                                 default = nil)
  if valid_596214 != nil:
    section.add "X-Amz-Content-Sha256", valid_596214
  var valid_596215 = header.getOrDefault("X-Amz-Date")
  valid_596215 = validateParameter(valid_596215, JString, required = false,
                                 default = nil)
  if valid_596215 != nil:
    section.add "X-Amz-Date", valid_596215
  var valid_596216 = header.getOrDefault("X-Amz-Credential")
  valid_596216 = validateParameter(valid_596216, JString, required = false,
                                 default = nil)
  if valid_596216 != nil:
    section.add "X-Amz-Credential", valid_596216
  var valid_596217 = header.getOrDefault("X-Amz-Security-Token")
  valid_596217 = validateParameter(valid_596217, JString, required = false,
                                 default = nil)
  if valid_596217 != nil:
    section.add "X-Amz-Security-Token", valid_596217
  var valid_596218 = header.getOrDefault("X-Amz-Algorithm")
  valid_596218 = validateParameter(valid_596218, JString, required = false,
                                 default = nil)
  if valid_596218 != nil:
    section.add "X-Amz-Algorithm", valid_596218
  var valid_596219 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596219 = validateParameter(valid_596219, JString, required = false,
                                 default = nil)
  if valid_596219 != nil:
    section.add "X-Amz-SignedHeaders", valid_596219
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596220: Call_ListStreams_596207; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all of the streams in your AWS account.
  ## 
  let valid = call_596220.validator(path, query, header, formData, body)
  let scheme = call_596220.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596220.url(scheme.get, call_596220.host, call_596220.base,
                         call_596220.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596220, url, valid)

proc call*(call_596221: Call_ListStreams_596207; nextToken: string = "";
          isAscendingOrder: bool = false; maxResults: int = 0): Recallable =
  ## listStreams
  ## Lists all of the streams in your AWS account.
  ##   nextToken: string
  ##            : A token used to get the next set of results.
  ##   isAscendingOrder: bool
  ##                   : Set to true to return the list of streams in ascending order.
  ##   maxResults: int
  ##             : The maximum number of results to return at a time.
  var query_596222 = newJObject()
  add(query_596222, "nextToken", newJString(nextToken))
  add(query_596222, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_596222, "maxResults", newJInt(maxResults))
  result = call_596221.call(nil, query_596222, nil, nil, nil)

var listStreams* = Call_ListStreams_596207(name: "listStreams",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/streams",
                                        validator: validate_ListStreams_596208,
                                        base: "/", url: url_ListStreams_596209,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTagsForResource_596223 = ref object of OpenApiRestCall_593389
proc url_ListTagsForResource_596225(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListTagsForResource_596224(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the tags (metadata) you have assigned to the resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   resourceArn: JString (required)
  ##              : The ARN of the resource.
  section = newJObject()
  var valid_596226 = query.getOrDefault("nextToken")
  valid_596226 = validateParameter(valid_596226, JString, required = false,
                                 default = nil)
  if valid_596226 != nil:
    section.add "nextToken", valid_596226
  assert query != nil,
        "query argument is necessary due to required `resourceArn` field"
  var valid_596227 = query.getOrDefault("resourceArn")
  valid_596227 = validateParameter(valid_596227, JString, required = true,
                                 default = nil)
  if valid_596227 != nil:
    section.add "resourceArn", valid_596227
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596228 = header.getOrDefault("X-Amz-Signature")
  valid_596228 = validateParameter(valid_596228, JString, required = false,
                                 default = nil)
  if valid_596228 != nil:
    section.add "X-Amz-Signature", valid_596228
  var valid_596229 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596229 = validateParameter(valid_596229, JString, required = false,
                                 default = nil)
  if valid_596229 != nil:
    section.add "X-Amz-Content-Sha256", valid_596229
  var valid_596230 = header.getOrDefault("X-Amz-Date")
  valid_596230 = validateParameter(valid_596230, JString, required = false,
                                 default = nil)
  if valid_596230 != nil:
    section.add "X-Amz-Date", valid_596230
  var valid_596231 = header.getOrDefault("X-Amz-Credential")
  valid_596231 = validateParameter(valid_596231, JString, required = false,
                                 default = nil)
  if valid_596231 != nil:
    section.add "X-Amz-Credential", valid_596231
  var valid_596232 = header.getOrDefault("X-Amz-Security-Token")
  valid_596232 = validateParameter(valid_596232, JString, required = false,
                                 default = nil)
  if valid_596232 != nil:
    section.add "X-Amz-Security-Token", valid_596232
  var valid_596233 = header.getOrDefault("X-Amz-Algorithm")
  valid_596233 = validateParameter(valid_596233, JString, required = false,
                                 default = nil)
  if valid_596233 != nil:
    section.add "X-Amz-Algorithm", valid_596233
  var valid_596234 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596234 = validateParameter(valid_596234, JString, required = false,
                                 default = nil)
  if valid_596234 != nil:
    section.add "X-Amz-SignedHeaders", valid_596234
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596235: Call_ListTagsForResource_596223; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the tags (metadata) you have assigned to the resource.
  ## 
  let valid = call_596235.validator(path, query, header, formData, body)
  let scheme = call_596235.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596235.url(scheme.get, call_596235.host, call_596235.base,
                         call_596235.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596235, url, valid)

proc call*(call_596236: Call_ListTagsForResource_596223; resourceArn: string;
          nextToken: string = ""): Recallable =
  ## listTagsForResource
  ## Lists the tags (metadata) you have assigned to the resource.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   resourceArn: string (required)
  ##              : The ARN of the resource.
  var query_596237 = newJObject()
  add(query_596237, "nextToken", newJString(nextToken))
  add(query_596237, "resourceArn", newJString(resourceArn))
  result = call_596236.call(nil, query_596237, nil, nil, nil)

var listTagsForResource* = Call_ListTagsForResource_596223(
    name: "listTagsForResource", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/tags#resourceArn",
    validator: validate_ListTagsForResource_596224, base: "/",
    url: url_ListTagsForResource_596225, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTargetsForPolicy_596238 = ref object of OpenApiRestCall_593389
proc url_ListTargetsForPolicy_596240(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policy-targets/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListTargetsForPolicy_596239(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List targets for the specified policy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_596241 = path.getOrDefault("policyName")
  valid_596241 = validateParameter(valid_596241, JString, required = true,
                                 default = nil)
  if valid_596241 != nil:
    section.add "policyName", valid_596241
  result.add "path", section
  ## parameters in `query` object:
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  section = newJObject()
  var valid_596242 = query.getOrDefault("pageSize")
  valid_596242 = validateParameter(valid_596242, JInt, required = false, default = nil)
  if valid_596242 != nil:
    section.add "pageSize", valid_596242
  var valid_596243 = query.getOrDefault("marker")
  valid_596243 = validateParameter(valid_596243, JString, required = false,
                                 default = nil)
  if valid_596243 != nil:
    section.add "marker", valid_596243
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596244 = header.getOrDefault("X-Amz-Signature")
  valid_596244 = validateParameter(valid_596244, JString, required = false,
                                 default = nil)
  if valid_596244 != nil:
    section.add "X-Amz-Signature", valid_596244
  var valid_596245 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596245 = validateParameter(valid_596245, JString, required = false,
                                 default = nil)
  if valid_596245 != nil:
    section.add "X-Amz-Content-Sha256", valid_596245
  var valid_596246 = header.getOrDefault("X-Amz-Date")
  valid_596246 = validateParameter(valid_596246, JString, required = false,
                                 default = nil)
  if valid_596246 != nil:
    section.add "X-Amz-Date", valid_596246
  var valid_596247 = header.getOrDefault("X-Amz-Credential")
  valid_596247 = validateParameter(valid_596247, JString, required = false,
                                 default = nil)
  if valid_596247 != nil:
    section.add "X-Amz-Credential", valid_596247
  var valid_596248 = header.getOrDefault("X-Amz-Security-Token")
  valid_596248 = validateParameter(valid_596248, JString, required = false,
                                 default = nil)
  if valid_596248 != nil:
    section.add "X-Amz-Security-Token", valid_596248
  var valid_596249 = header.getOrDefault("X-Amz-Algorithm")
  valid_596249 = validateParameter(valid_596249, JString, required = false,
                                 default = nil)
  if valid_596249 != nil:
    section.add "X-Amz-Algorithm", valid_596249
  var valid_596250 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596250 = validateParameter(valid_596250, JString, required = false,
                                 default = nil)
  if valid_596250 != nil:
    section.add "X-Amz-SignedHeaders", valid_596250
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596251: Call_ListTargetsForPolicy_596238; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List targets for the specified policy.
  ## 
  let valid = call_596251.validator(path, query, header, formData, body)
  let scheme = call_596251.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596251.url(scheme.get, call_596251.host, call_596251.base,
                         call_596251.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596251, url, valid)

proc call*(call_596252: Call_ListTargetsForPolicy_596238; policyName: string;
          pageSize: int = 0; marker: string = ""): Recallable =
  ## listTargetsForPolicy
  ## List targets for the specified policy.
  ##   policyName: string (required)
  ##             : The policy name.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  var path_596253 = newJObject()
  var query_596254 = newJObject()
  add(path_596253, "policyName", newJString(policyName))
  add(query_596254, "pageSize", newJInt(pageSize))
  add(query_596254, "marker", newJString(marker))
  result = call_596252.call(path_596253, query_596254, nil, nil, nil)

var listTargetsForPolicy* = Call_ListTargetsForPolicy_596238(
    name: "listTargetsForPolicy", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/policy-targets/{policyName}",
    validator: validate_ListTargetsForPolicy_596239, base: "/",
    url: url_ListTargetsForPolicy_596240, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTargetsForSecurityProfile_596255 = ref object of OpenApiRestCall_593389
proc url_ListTargetsForSecurityProfile_596257(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"),
               (kind: ConstantSegment, value: "/targets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListTargetsForSecurityProfile_596256(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_596258 = path.getOrDefault("securityProfileName")
  valid_596258 = validateParameter(valid_596258, JString, required = true,
                                 default = nil)
  if valid_596258 != nil:
    section.add "securityProfileName", valid_596258
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_596259 = query.getOrDefault("nextToken")
  valid_596259 = validateParameter(valid_596259, JString, required = false,
                                 default = nil)
  if valid_596259 != nil:
    section.add "nextToken", valid_596259
  var valid_596260 = query.getOrDefault("maxResults")
  valid_596260 = validateParameter(valid_596260, JInt, required = false, default = nil)
  if valid_596260 != nil:
    section.add "maxResults", valid_596260
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596261 = header.getOrDefault("X-Amz-Signature")
  valid_596261 = validateParameter(valid_596261, JString, required = false,
                                 default = nil)
  if valid_596261 != nil:
    section.add "X-Amz-Signature", valid_596261
  var valid_596262 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596262 = validateParameter(valid_596262, JString, required = false,
                                 default = nil)
  if valid_596262 != nil:
    section.add "X-Amz-Content-Sha256", valid_596262
  var valid_596263 = header.getOrDefault("X-Amz-Date")
  valid_596263 = validateParameter(valid_596263, JString, required = false,
                                 default = nil)
  if valid_596263 != nil:
    section.add "X-Amz-Date", valid_596263
  var valid_596264 = header.getOrDefault("X-Amz-Credential")
  valid_596264 = validateParameter(valid_596264, JString, required = false,
                                 default = nil)
  if valid_596264 != nil:
    section.add "X-Amz-Credential", valid_596264
  var valid_596265 = header.getOrDefault("X-Amz-Security-Token")
  valid_596265 = validateParameter(valid_596265, JString, required = false,
                                 default = nil)
  if valid_596265 != nil:
    section.add "X-Amz-Security-Token", valid_596265
  var valid_596266 = header.getOrDefault("X-Amz-Algorithm")
  valid_596266 = validateParameter(valid_596266, JString, required = false,
                                 default = nil)
  if valid_596266 != nil:
    section.add "X-Amz-Algorithm", valid_596266
  var valid_596267 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596267 = validateParameter(valid_596267, JString, required = false,
                                 default = nil)
  if valid_596267 != nil:
    section.add "X-Amz-SignedHeaders", valid_596267
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596268: Call_ListTargetsForSecurityProfile_596255; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ## 
  let valid = call_596268.validator(path, query, header, formData, body)
  let scheme = call_596268.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596268.url(scheme.get, call_596268.host, call_596268.base,
                         call_596268.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596268, url, valid)

proc call*(call_596269: Call_ListTargetsForSecurityProfile_596255;
          securityProfileName: string; nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listTargetsForSecurityProfile
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string (required)
  ##                      : The security profile.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_596270 = newJObject()
  var query_596271 = newJObject()
  add(query_596271, "nextToken", newJString(nextToken))
  add(path_596270, "securityProfileName", newJString(securityProfileName))
  add(query_596271, "maxResults", newJInt(maxResults))
  result = call_596269.call(path_596270, query_596271, nil, nil, nil)

var listTargetsForSecurityProfile* = Call_ListTargetsForSecurityProfile_596255(
    name: "listTargetsForSecurityProfile", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/security-profiles/{securityProfileName}/targets",
    validator: validate_ListTargetsForSecurityProfile_596256, base: "/",
    url: url_ListTargetsForSecurityProfile_596257,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingGroups_596272 = ref object of OpenApiRestCall_593389
proc url_ListThingGroups_596274(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThingGroups_596273(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List the thing groups in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   recursive: JBool
  ##            : If true, return child groups as well.
  ##   parentGroup: JString
  ##              : A filter that limits the results to those with the specified parent group.
  ##   namePrefixFilter: JString
  ##                   : A filter that limits the results to those with the specified name prefix.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_596275 = query.getOrDefault("nextToken")
  valid_596275 = validateParameter(valid_596275, JString, required = false,
                                 default = nil)
  if valid_596275 != nil:
    section.add "nextToken", valid_596275
  var valid_596276 = query.getOrDefault("recursive")
  valid_596276 = validateParameter(valid_596276, JBool, required = false, default = nil)
  if valid_596276 != nil:
    section.add "recursive", valid_596276
  var valid_596277 = query.getOrDefault("parentGroup")
  valid_596277 = validateParameter(valid_596277, JString, required = false,
                                 default = nil)
  if valid_596277 != nil:
    section.add "parentGroup", valid_596277
  var valid_596278 = query.getOrDefault("namePrefixFilter")
  valid_596278 = validateParameter(valid_596278, JString, required = false,
                                 default = nil)
  if valid_596278 != nil:
    section.add "namePrefixFilter", valid_596278
  var valid_596279 = query.getOrDefault("maxResults")
  valid_596279 = validateParameter(valid_596279, JInt, required = false, default = nil)
  if valid_596279 != nil:
    section.add "maxResults", valid_596279
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596280 = header.getOrDefault("X-Amz-Signature")
  valid_596280 = validateParameter(valid_596280, JString, required = false,
                                 default = nil)
  if valid_596280 != nil:
    section.add "X-Amz-Signature", valid_596280
  var valid_596281 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596281 = validateParameter(valid_596281, JString, required = false,
                                 default = nil)
  if valid_596281 != nil:
    section.add "X-Amz-Content-Sha256", valid_596281
  var valid_596282 = header.getOrDefault("X-Amz-Date")
  valid_596282 = validateParameter(valid_596282, JString, required = false,
                                 default = nil)
  if valid_596282 != nil:
    section.add "X-Amz-Date", valid_596282
  var valid_596283 = header.getOrDefault("X-Amz-Credential")
  valid_596283 = validateParameter(valid_596283, JString, required = false,
                                 default = nil)
  if valid_596283 != nil:
    section.add "X-Amz-Credential", valid_596283
  var valid_596284 = header.getOrDefault("X-Amz-Security-Token")
  valid_596284 = validateParameter(valid_596284, JString, required = false,
                                 default = nil)
  if valid_596284 != nil:
    section.add "X-Amz-Security-Token", valid_596284
  var valid_596285 = header.getOrDefault("X-Amz-Algorithm")
  valid_596285 = validateParameter(valid_596285, JString, required = false,
                                 default = nil)
  if valid_596285 != nil:
    section.add "X-Amz-Algorithm", valid_596285
  var valid_596286 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596286 = validateParameter(valid_596286, JString, required = false,
                                 default = nil)
  if valid_596286 != nil:
    section.add "X-Amz-SignedHeaders", valid_596286
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596287: Call_ListThingGroups_596272; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the thing groups in your account.
  ## 
  let valid = call_596287.validator(path, query, header, formData, body)
  let scheme = call_596287.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596287.url(scheme.get, call_596287.host, call_596287.base,
                         call_596287.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596287, url, valid)

proc call*(call_596288: Call_ListThingGroups_596272; nextToken: string = "";
          recursive: bool = false; parentGroup: string = "";
          namePrefixFilter: string = ""; maxResults: int = 0): Recallable =
  ## listThingGroups
  ## List the thing groups in your account.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   recursive: bool
  ##            : If true, return child groups as well.
  ##   parentGroup: string
  ##              : A filter that limits the results to those with the specified parent group.
  ##   namePrefixFilter: string
  ##                   : A filter that limits the results to those with the specified name prefix.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_596289 = newJObject()
  add(query_596289, "nextToken", newJString(nextToken))
  add(query_596289, "recursive", newJBool(recursive))
  add(query_596289, "parentGroup", newJString(parentGroup))
  add(query_596289, "namePrefixFilter", newJString(namePrefixFilter))
  add(query_596289, "maxResults", newJInt(maxResults))
  result = call_596288.call(nil, query_596289, nil, nil, nil)

var listThingGroups* = Call_ListThingGroups_596272(name: "listThingGroups",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/thing-groups",
    validator: validate_ListThingGroups_596273, base: "/", url: url_ListThingGroups_596274,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingGroupsForThing_596290 = ref object of OpenApiRestCall_593389
proc url_ListThingGroupsForThing_596292(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/thing-groups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingGroupsForThing_596291(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List the thing groups to which the specified thing belongs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The thing name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_596293 = path.getOrDefault("thingName")
  valid_596293 = validateParameter(valid_596293, JString, required = true,
                                 default = nil)
  if valid_596293 != nil:
    section.add "thingName", valid_596293
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_596294 = query.getOrDefault("nextToken")
  valid_596294 = validateParameter(valid_596294, JString, required = false,
                                 default = nil)
  if valid_596294 != nil:
    section.add "nextToken", valid_596294
  var valid_596295 = query.getOrDefault("maxResults")
  valid_596295 = validateParameter(valid_596295, JInt, required = false, default = nil)
  if valid_596295 != nil:
    section.add "maxResults", valid_596295
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596296 = header.getOrDefault("X-Amz-Signature")
  valid_596296 = validateParameter(valid_596296, JString, required = false,
                                 default = nil)
  if valid_596296 != nil:
    section.add "X-Amz-Signature", valid_596296
  var valid_596297 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596297 = validateParameter(valid_596297, JString, required = false,
                                 default = nil)
  if valid_596297 != nil:
    section.add "X-Amz-Content-Sha256", valid_596297
  var valid_596298 = header.getOrDefault("X-Amz-Date")
  valid_596298 = validateParameter(valid_596298, JString, required = false,
                                 default = nil)
  if valid_596298 != nil:
    section.add "X-Amz-Date", valid_596298
  var valid_596299 = header.getOrDefault("X-Amz-Credential")
  valid_596299 = validateParameter(valid_596299, JString, required = false,
                                 default = nil)
  if valid_596299 != nil:
    section.add "X-Amz-Credential", valid_596299
  var valid_596300 = header.getOrDefault("X-Amz-Security-Token")
  valid_596300 = validateParameter(valid_596300, JString, required = false,
                                 default = nil)
  if valid_596300 != nil:
    section.add "X-Amz-Security-Token", valid_596300
  var valid_596301 = header.getOrDefault("X-Amz-Algorithm")
  valid_596301 = validateParameter(valid_596301, JString, required = false,
                                 default = nil)
  if valid_596301 != nil:
    section.add "X-Amz-Algorithm", valid_596301
  var valid_596302 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596302 = validateParameter(valid_596302, JString, required = false,
                                 default = nil)
  if valid_596302 != nil:
    section.add "X-Amz-SignedHeaders", valid_596302
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596303: Call_ListThingGroupsForThing_596290; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the thing groups to which the specified thing belongs.
  ## 
  let valid = call_596303.validator(path, query, header, formData, body)
  let scheme = call_596303.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596303.url(scheme.get, call_596303.host, call_596303.base,
                         call_596303.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596303, url, valid)

proc call*(call_596304: Call_ListThingGroupsForThing_596290; thingName: string;
          nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listThingGroupsForThing
  ## List the thing groups to which the specified thing belongs.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingName: string (required)
  ##            : The thing name.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_596305 = newJObject()
  var query_596306 = newJObject()
  add(query_596306, "nextToken", newJString(nextToken))
  add(path_596305, "thingName", newJString(thingName))
  add(query_596306, "maxResults", newJInt(maxResults))
  result = call_596304.call(path_596305, query_596306, nil, nil, nil)

var listThingGroupsForThing* = Call_ListThingGroupsForThing_596290(
    name: "listThingGroupsForThing", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/thing-groups",
    validator: validate_ListThingGroupsForThing_596291, base: "/",
    url: url_ListThingGroupsForThing_596292, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingPrincipals_596307 = ref object of OpenApiRestCall_593389
proc url_ListThingPrincipals_596309(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingPrincipals_596308(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_596310 = path.getOrDefault("thingName")
  valid_596310 = validateParameter(valid_596310, JString, required = true,
                                 default = nil)
  if valid_596310 != nil:
    section.add "thingName", valid_596310
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596311 = header.getOrDefault("X-Amz-Signature")
  valid_596311 = validateParameter(valid_596311, JString, required = false,
                                 default = nil)
  if valid_596311 != nil:
    section.add "X-Amz-Signature", valid_596311
  var valid_596312 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596312 = validateParameter(valid_596312, JString, required = false,
                                 default = nil)
  if valid_596312 != nil:
    section.add "X-Amz-Content-Sha256", valid_596312
  var valid_596313 = header.getOrDefault("X-Amz-Date")
  valid_596313 = validateParameter(valid_596313, JString, required = false,
                                 default = nil)
  if valid_596313 != nil:
    section.add "X-Amz-Date", valid_596313
  var valid_596314 = header.getOrDefault("X-Amz-Credential")
  valid_596314 = validateParameter(valid_596314, JString, required = false,
                                 default = nil)
  if valid_596314 != nil:
    section.add "X-Amz-Credential", valid_596314
  var valid_596315 = header.getOrDefault("X-Amz-Security-Token")
  valid_596315 = validateParameter(valid_596315, JString, required = false,
                                 default = nil)
  if valid_596315 != nil:
    section.add "X-Amz-Security-Token", valid_596315
  var valid_596316 = header.getOrDefault("X-Amz-Algorithm")
  valid_596316 = validateParameter(valid_596316, JString, required = false,
                                 default = nil)
  if valid_596316 != nil:
    section.add "X-Amz-Algorithm", valid_596316
  var valid_596317 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596317 = validateParameter(valid_596317, JString, required = false,
                                 default = nil)
  if valid_596317 != nil:
    section.add "X-Amz-SignedHeaders", valid_596317
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596318: Call_ListThingPrincipals_596307; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  let valid = call_596318.validator(path, query, header, formData, body)
  let scheme = call_596318.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596318.url(scheme.get, call_596318.host, call_596318.base,
                         call_596318.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596318, url, valid)

proc call*(call_596319: Call_ListThingPrincipals_596307; thingName: string): Recallable =
  ## listThingPrincipals
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_596320 = newJObject()
  add(path_596320, "thingName", newJString(thingName))
  result = call_596319.call(path_596320, nil, nil, nil, nil)

var listThingPrincipals* = Call_ListThingPrincipals_596307(
    name: "listThingPrincipals", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/principals",
    validator: validate_ListThingPrincipals_596308, base: "/",
    url: url_ListThingPrincipals_596309, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingRegistrationTaskReports_596321 = ref object of OpenApiRestCall_593389
proc url_ListThingRegistrationTaskReports_596323(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/reports#reportType")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingRegistrationTaskReports_596322(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Information about the thing registration tasks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The id of the task.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_596324 = path.getOrDefault("taskId")
  valid_596324 = validateParameter(valid_596324, JString, required = true,
                                 default = nil)
  if valid_596324 != nil:
    section.add "taskId", valid_596324
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   reportType: JString (required)
  ##             : The type of task report.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_596325 = query.getOrDefault("nextToken")
  valid_596325 = validateParameter(valid_596325, JString, required = false,
                                 default = nil)
  if valid_596325 != nil:
    section.add "nextToken", valid_596325
  assert query != nil,
        "query argument is necessary due to required `reportType` field"
  var valid_596326 = query.getOrDefault("reportType")
  valid_596326 = validateParameter(valid_596326, JString, required = true,
                                 default = newJString("ERRORS"))
  if valid_596326 != nil:
    section.add "reportType", valid_596326
  var valid_596327 = query.getOrDefault("maxResults")
  valid_596327 = validateParameter(valid_596327, JInt, required = false, default = nil)
  if valid_596327 != nil:
    section.add "maxResults", valid_596327
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596328 = header.getOrDefault("X-Amz-Signature")
  valid_596328 = validateParameter(valid_596328, JString, required = false,
                                 default = nil)
  if valid_596328 != nil:
    section.add "X-Amz-Signature", valid_596328
  var valid_596329 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596329 = validateParameter(valid_596329, JString, required = false,
                                 default = nil)
  if valid_596329 != nil:
    section.add "X-Amz-Content-Sha256", valid_596329
  var valid_596330 = header.getOrDefault("X-Amz-Date")
  valid_596330 = validateParameter(valid_596330, JString, required = false,
                                 default = nil)
  if valid_596330 != nil:
    section.add "X-Amz-Date", valid_596330
  var valid_596331 = header.getOrDefault("X-Amz-Credential")
  valid_596331 = validateParameter(valid_596331, JString, required = false,
                                 default = nil)
  if valid_596331 != nil:
    section.add "X-Amz-Credential", valid_596331
  var valid_596332 = header.getOrDefault("X-Amz-Security-Token")
  valid_596332 = validateParameter(valid_596332, JString, required = false,
                                 default = nil)
  if valid_596332 != nil:
    section.add "X-Amz-Security-Token", valid_596332
  var valid_596333 = header.getOrDefault("X-Amz-Algorithm")
  valid_596333 = validateParameter(valid_596333, JString, required = false,
                                 default = nil)
  if valid_596333 != nil:
    section.add "X-Amz-Algorithm", valid_596333
  var valid_596334 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596334 = validateParameter(valid_596334, JString, required = false,
                                 default = nil)
  if valid_596334 != nil:
    section.add "X-Amz-SignedHeaders", valid_596334
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596335: Call_ListThingRegistrationTaskReports_596321;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Information about the thing registration tasks.
  ## 
  let valid = call_596335.validator(path, query, header, formData, body)
  let scheme = call_596335.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596335.url(scheme.get, call_596335.host, call_596335.base,
                         call_596335.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596335, url, valid)

proc call*(call_596336: Call_ListThingRegistrationTaskReports_596321;
          taskId: string; nextToken: string = ""; reportType: string = "ERRORS";
          maxResults: int = 0): Recallable =
  ## listThingRegistrationTaskReports
  ## Information about the thing registration tasks.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   taskId: string (required)
  ##         : The id of the task.
  ##   reportType: string (required)
  ##             : The type of task report.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var path_596337 = newJObject()
  var query_596338 = newJObject()
  add(query_596338, "nextToken", newJString(nextToken))
  add(path_596337, "taskId", newJString(taskId))
  add(query_596338, "reportType", newJString(reportType))
  add(query_596338, "maxResults", newJInt(maxResults))
  result = call_596336.call(path_596337, query_596338, nil, nil, nil)

var listThingRegistrationTaskReports* = Call_ListThingRegistrationTaskReports_596321(
    name: "listThingRegistrationTaskReports", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/thing-registration-tasks/{taskId}/reports#reportType",
    validator: validate_ListThingRegistrationTaskReports_596322, base: "/",
    url: url_ListThingRegistrationTaskReports_596323,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartThingRegistrationTask_596355 = ref object of OpenApiRestCall_593389
proc url_StartThingRegistrationTask_596357(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_StartThingRegistrationTask_596356(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596358 = header.getOrDefault("X-Amz-Signature")
  valid_596358 = validateParameter(valid_596358, JString, required = false,
                                 default = nil)
  if valid_596358 != nil:
    section.add "X-Amz-Signature", valid_596358
  var valid_596359 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596359 = validateParameter(valid_596359, JString, required = false,
                                 default = nil)
  if valid_596359 != nil:
    section.add "X-Amz-Content-Sha256", valid_596359
  var valid_596360 = header.getOrDefault("X-Amz-Date")
  valid_596360 = validateParameter(valid_596360, JString, required = false,
                                 default = nil)
  if valid_596360 != nil:
    section.add "X-Amz-Date", valid_596360
  var valid_596361 = header.getOrDefault("X-Amz-Credential")
  valid_596361 = validateParameter(valid_596361, JString, required = false,
                                 default = nil)
  if valid_596361 != nil:
    section.add "X-Amz-Credential", valid_596361
  var valid_596362 = header.getOrDefault("X-Amz-Security-Token")
  valid_596362 = validateParameter(valid_596362, JString, required = false,
                                 default = nil)
  if valid_596362 != nil:
    section.add "X-Amz-Security-Token", valid_596362
  var valid_596363 = header.getOrDefault("X-Amz-Algorithm")
  valid_596363 = validateParameter(valid_596363, JString, required = false,
                                 default = nil)
  if valid_596363 != nil:
    section.add "X-Amz-Algorithm", valid_596363
  var valid_596364 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596364 = validateParameter(valid_596364, JString, required = false,
                                 default = nil)
  if valid_596364 != nil:
    section.add "X-Amz-SignedHeaders", valid_596364
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596366: Call_StartThingRegistrationTask_596355; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a bulk thing provisioning task.
  ## 
  let valid = call_596366.validator(path, query, header, formData, body)
  let scheme = call_596366.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596366.url(scheme.get, call_596366.host, call_596366.base,
                         call_596366.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596366, url, valid)

proc call*(call_596367: Call_StartThingRegistrationTask_596355; body: JsonNode): Recallable =
  ## startThingRegistrationTask
  ## Creates a bulk thing provisioning task.
  ##   body: JObject (required)
  var body_596368 = newJObject()
  if body != nil:
    body_596368 = body
  result = call_596367.call(nil, nil, nil, nil, body_596368)

var startThingRegistrationTask* = Call_StartThingRegistrationTask_596355(
    name: "startThingRegistrationTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks",
    validator: validate_StartThingRegistrationTask_596356, base: "/",
    url: url_StartThingRegistrationTask_596357,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingRegistrationTasks_596339 = ref object of OpenApiRestCall_593389
proc url_ListThingRegistrationTasks_596341(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThingRegistrationTasks_596340(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List bulk thing provisioning tasks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : The status of the bulk thing provisioning task.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_596342 = query.getOrDefault("nextToken")
  valid_596342 = validateParameter(valid_596342, JString, required = false,
                                 default = nil)
  if valid_596342 != nil:
    section.add "nextToken", valid_596342
  var valid_596343 = query.getOrDefault("status")
  valid_596343 = validateParameter(valid_596343, JString, required = false,
                                 default = newJString("InProgress"))
  if valid_596343 != nil:
    section.add "status", valid_596343
  var valid_596344 = query.getOrDefault("maxResults")
  valid_596344 = validateParameter(valid_596344, JInt, required = false, default = nil)
  if valid_596344 != nil:
    section.add "maxResults", valid_596344
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596345 = header.getOrDefault("X-Amz-Signature")
  valid_596345 = validateParameter(valid_596345, JString, required = false,
                                 default = nil)
  if valid_596345 != nil:
    section.add "X-Amz-Signature", valid_596345
  var valid_596346 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596346 = validateParameter(valid_596346, JString, required = false,
                                 default = nil)
  if valid_596346 != nil:
    section.add "X-Amz-Content-Sha256", valid_596346
  var valid_596347 = header.getOrDefault("X-Amz-Date")
  valid_596347 = validateParameter(valid_596347, JString, required = false,
                                 default = nil)
  if valid_596347 != nil:
    section.add "X-Amz-Date", valid_596347
  var valid_596348 = header.getOrDefault("X-Amz-Credential")
  valid_596348 = validateParameter(valid_596348, JString, required = false,
                                 default = nil)
  if valid_596348 != nil:
    section.add "X-Amz-Credential", valid_596348
  var valid_596349 = header.getOrDefault("X-Amz-Security-Token")
  valid_596349 = validateParameter(valid_596349, JString, required = false,
                                 default = nil)
  if valid_596349 != nil:
    section.add "X-Amz-Security-Token", valid_596349
  var valid_596350 = header.getOrDefault("X-Amz-Algorithm")
  valid_596350 = validateParameter(valid_596350, JString, required = false,
                                 default = nil)
  if valid_596350 != nil:
    section.add "X-Amz-Algorithm", valid_596350
  var valid_596351 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596351 = validateParameter(valid_596351, JString, required = false,
                                 default = nil)
  if valid_596351 != nil:
    section.add "X-Amz-SignedHeaders", valid_596351
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596352: Call_ListThingRegistrationTasks_596339; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List bulk thing provisioning tasks.
  ## 
  let valid = call_596352.validator(path, query, header, formData, body)
  let scheme = call_596352.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596352.url(scheme.get, call_596352.host, call_596352.base,
                         call_596352.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596352, url, valid)

proc call*(call_596353: Call_ListThingRegistrationTasks_596339;
          nextToken: string = ""; status: string = "InProgress"; maxResults: int = 0): Recallable =
  ## listThingRegistrationTasks
  ## List bulk thing provisioning tasks.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : The status of the bulk thing provisioning task.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_596354 = newJObject()
  add(query_596354, "nextToken", newJString(nextToken))
  add(query_596354, "status", newJString(status))
  add(query_596354, "maxResults", newJInt(maxResults))
  result = call_596353.call(nil, query_596354, nil, nil, nil)

var listThingRegistrationTasks* = Call_ListThingRegistrationTasks_596339(
    name: "listThingRegistrationTasks", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks",
    validator: validate_ListThingRegistrationTasks_596340, base: "/",
    url: url_ListThingRegistrationTasks_596341,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingTypes_596369 = ref object of OpenApiRestCall_593389
proc url_ListThingTypes_596371(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThingTypes_596370(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the existing thing types.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   thingTypeName: JString
  ##                : The name of the thing type.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  section = newJObject()
  var valid_596372 = query.getOrDefault("nextToken")
  valid_596372 = validateParameter(valid_596372, JString, required = false,
                                 default = nil)
  if valid_596372 != nil:
    section.add "nextToken", valid_596372
  var valid_596373 = query.getOrDefault("thingTypeName")
  valid_596373 = validateParameter(valid_596373, JString, required = false,
                                 default = nil)
  if valid_596373 != nil:
    section.add "thingTypeName", valid_596373
  var valid_596374 = query.getOrDefault("maxResults")
  valid_596374 = validateParameter(valid_596374, JInt, required = false, default = nil)
  if valid_596374 != nil:
    section.add "maxResults", valid_596374
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596375 = header.getOrDefault("X-Amz-Signature")
  valid_596375 = validateParameter(valid_596375, JString, required = false,
                                 default = nil)
  if valid_596375 != nil:
    section.add "X-Amz-Signature", valid_596375
  var valid_596376 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596376 = validateParameter(valid_596376, JString, required = false,
                                 default = nil)
  if valid_596376 != nil:
    section.add "X-Amz-Content-Sha256", valid_596376
  var valid_596377 = header.getOrDefault("X-Amz-Date")
  valid_596377 = validateParameter(valid_596377, JString, required = false,
                                 default = nil)
  if valid_596377 != nil:
    section.add "X-Amz-Date", valid_596377
  var valid_596378 = header.getOrDefault("X-Amz-Credential")
  valid_596378 = validateParameter(valid_596378, JString, required = false,
                                 default = nil)
  if valid_596378 != nil:
    section.add "X-Amz-Credential", valid_596378
  var valid_596379 = header.getOrDefault("X-Amz-Security-Token")
  valid_596379 = validateParameter(valid_596379, JString, required = false,
                                 default = nil)
  if valid_596379 != nil:
    section.add "X-Amz-Security-Token", valid_596379
  var valid_596380 = header.getOrDefault("X-Amz-Algorithm")
  valid_596380 = validateParameter(valid_596380, JString, required = false,
                                 default = nil)
  if valid_596380 != nil:
    section.add "X-Amz-Algorithm", valid_596380
  var valid_596381 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596381 = validateParameter(valid_596381, JString, required = false,
                                 default = nil)
  if valid_596381 != nil:
    section.add "X-Amz-SignedHeaders", valid_596381
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596382: Call_ListThingTypes_596369; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the existing thing types.
  ## 
  let valid = call_596382.validator(path, query, header, formData, body)
  let scheme = call_596382.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596382.url(scheme.get, call_596382.host, call_596382.base,
                         call_596382.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596382, url, valid)

proc call*(call_596383: Call_ListThingTypes_596369; nextToken: string = "";
          thingTypeName: string = ""; maxResults: int = 0): Recallable =
  ## listThingTypes
  ## Lists the existing thing types.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingTypeName: string
  ##                : The name of the thing type.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  var query_596384 = newJObject()
  add(query_596384, "nextToken", newJString(nextToken))
  add(query_596384, "thingTypeName", newJString(thingTypeName))
  add(query_596384, "maxResults", newJInt(maxResults))
  result = call_596383.call(nil, query_596384, nil, nil, nil)

var listThingTypes* = Call_ListThingTypes_596369(name: "listThingTypes",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/thing-types",
    validator: validate_ListThingTypes_596370, base: "/", url: url_ListThingTypes_596371,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterThing_596403 = ref object of OpenApiRestCall_593389
proc url_RegisterThing_596405(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RegisterThing_596404(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596406 = header.getOrDefault("X-Amz-Signature")
  valid_596406 = validateParameter(valid_596406, JString, required = false,
                                 default = nil)
  if valid_596406 != nil:
    section.add "X-Amz-Signature", valid_596406
  var valid_596407 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596407 = validateParameter(valid_596407, JString, required = false,
                                 default = nil)
  if valid_596407 != nil:
    section.add "X-Amz-Content-Sha256", valid_596407
  var valid_596408 = header.getOrDefault("X-Amz-Date")
  valid_596408 = validateParameter(valid_596408, JString, required = false,
                                 default = nil)
  if valid_596408 != nil:
    section.add "X-Amz-Date", valid_596408
  var valid_596409 = header.getOrDefault("X-Amz-Credential")
  valid_596409 = validateParameter(valid_596409, JString, required = false,
                                 default = nil)
  if valid_596409 != nil:
    section.add "X-Amz-Credential", valid_596409
  var valid_596410 = header.getOrDefault("X-Amz-Security-Token")
  valid_596410 = validateParameter(valid_596410, JString, required = false,
                                 default = nil)
  if valid_596410 != nil:
    section.add "X-Amz-Security-Token", valid_596410
  var valid_596411 = header.getOrDefault("X-Amz-Algorithm")
  valid_596411 = validateParameter(valid_596411, JString, required = false,
                                 default = nil)
  if valid_596411 != nil:
    section.add "X-Amz-Algorithm", valid_596411
  var valid_596412 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596412 = validateParameter(valid_596412, JString, required = false,
                                 default = nil)
  if valid_596412 != nil:
    section.add "X-Amz-SignedHeaders", valid_596412
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596414: Call_RegisterThing_596403; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.
  ## 
  let valid = call_596414.validator(path, query, header, formData, body)
  let scheme = call_596414.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596414.url(scheme.get, call_596414.host, call_596414.base,
                         call_596414.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596414, url, valid)

proc call*(call_596415: Call_RegisterThing_596403; body: JsonNode): Recallable =
  ## registerThing
  ## Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.
  ##   body: JObject (required)
  var body_596416 = newJObject()
  if body != nil:
    body_596416 = body
  result = call_596415.call(nil, nil, nil, nil, body_596416)

var registerThing* = Call_RegisterThing_596403(name: "registerThing",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/things",
    validator: validate_RegisterThing_596404, base: "/", url: url_RegisterThing_596405,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThings_596385 = ref object of OpenApiRestCall_593389
proc url_ListThings_596387(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThings_596386(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   attributeName: JString
  ##                : The attribute name used to search for things.
  ##   thingTypeName: JString
  ##                : The name of the thing type used to search for things.
  ##   attributeValue: JString
  ##                 : The attribute value used to search for things.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  section = newJObject()
  var valid_596388 = query.getOrDefault("nextToken")
  valid_596388 = validateParameter(valid_596388, JString, required = false,
                                 default = nil)
  if valid_596388 != nil:
    section.add "nextToken", valid_596388
  var valid_596389 = query.getOrDefault("attributeName")
  valid_596389 = validateParameter(valid_596389, JString, required = false,
                                 default = nil)
  if valid_596389 != nil:
    section.add "attributeName", valid_596389
  var valid_596390 = query.getOrDefault("thingTypeName")
  valid_596390 = validateParameter(valid_596390, JString, required = false,
                                 default = nil)
  if valid_596390 != nil:
    section.add "thingTypeName", valid_596390
  var valid_596391 = query.getOrDefault("attributeValue")
  valid_596391 = validateParameter(valid_596391, JString, required = false,
                                 default = nil)
  if valid_596391 != nil:
    section.add "attributeValue", valid_596391
  var valid_596392 = query.getOrDefault("maxResults")
  valid_596392 = validateParameter(valid_596392, JInt, required = false, default = nil)
  if valid_596392 != nil:
    section.add "maxResults", valid_596392
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596393 = header.getOrDefault("X-Amz-Signature")
  valid_596393 = validateParameter(valid_596393, JString, required = false,
                                 default = nil)
  if valid_596393 != nil:
    section.add "X-Amz-Signature", valid_596393
  var valid_596394 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596394 = validateParameter(valid_596394, JString, required = false,
                                 default = nil)
  if valid_596394 != nil:
    section.add "X-Amz-Content-Sha256", valid_596394
  var valid_596395 = header.getOrDefault("X-Amz-Date")
  valid_596395 = validateParameter(valid_596395, JString, required = false,
                                 default = nil)
  if valid_596395 != nil:
    section.add "X-Amz-Date", valid_596395
  var valid_596396 = header.getOrDefault("X-Amz-Credential")
  valid_596396 = validateParameter(valid_596396, JString, required = false,
                                 default = nil)
  if valid_596396 != nil:
    section.add "X-Amz-Credential", valid_596396
  var valid_596397 = header.getOrDefault("X-Amz-Security-Token")
  valid_596397 = validateParameter(valid_596397, JString, required = false,
                                 default = nil)
  if valid_596397 != nil:
    section.add "X-Amz-Security-Token", valid_596397
  var valid_596398 = header.getOrDefault("X-Amz-Algorithm")
  valid_596398 = validateParameter(valid_596398, JString, required = false,
                                 default = nil)
  if valid_596398 != nil:
    section.add "X-Amz-Algorithm", valid_596398
  var valid_596399 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596399 = validateParameter(valid_596399, JString, required = false,
                                 default = nil)
  if valid_596399 != nil:
    section.add "X-Amz-SignedHeaders", valid_596399
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596400: Call_ListThings_596385; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ## 
  let valid = call_596400.validator(path, query, header, formData, body)
  let scheme = call_596400.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596400.url(scheme.get, call_596400.host, call_596400.base,
                         call_596400.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596400, url, valid)

proc call*(call_596401: Call_ListThings_596385; nextToken: string = "";
          attributeName: string = ""; thingTypeName: string = "";
          attributeValue: string = ""; maxResults: int = 0): Recallable =
  ## listThings
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   attributeName: string
  ##                : The attribute name used to search for things.
  ##   thingTypeName: string
  ##                : The name of the thing type used to search for things.
  ##   attributeValue: string
  ##                 : The attribute value used to search for things.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  var query_596402 = newJObject()
  add(query_596402, "nextToken", newJString(nextToken))
  add(query_596402, "attributeName", newJString(attributeName))
  add(query_596402, "thingTypeName", newJString(thingTypeName))
  add(query_596402, "attributeValue", newJString(attributeValue))
  add(query_596402, "maxResults", newJInt(maxResults))
  result = call_596401.call(nil, query_596402, nil, nil, nil)

var listThings* = Call_ListThings_596385(name: "listThings",
                                      meth: HttpMethod.HttpGet,
                                      host: "iot.amazonaws.com", route: "/things",
                                      validator: validate_ListThings_596386,
                                      base: "/", url: url_ListThings_596387,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingsInBillingGroup_596417 = ref object of OpenApiRestCall_593389
proc url_ListThingsInBillingGroup_596419(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingsInBillingGroup_596418(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the things you have added to the given billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_596420 = path.getOrDefault("billingGroupName")
  valid_596420 = validateParameter(valid_596420, JString, required = true,
                                 default = nil)
  if valid_596420 != nil:
    section.add "billingGroupName", valid_596420
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_596421 = query.getOrDefault("nextToken")
  valid_596421 = validateParameter(valid_596421, JString, required = false,
                                 default = nil)
  if valid_596421 != nil:
    section.add "nextToken", valid_596421
  var valid_596422 = query.getOrDefault("maxResults")
  valid_596422 = validateParameter(valid_596422, JInt, required = false, default = nil)
  if valid_596422 != nil:
    section.add "maxResults", valid_596422
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596423 = header.getOrDefault("X-Amz-Signature")
  valid_596423 = validateParameter(valid_596423, JString, required = false,
                                 default = nil)
  if valid_596423 != nil:
    section.add "X-Amz-Signature", valid_596423
  var valid_596424 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596424 = validateParameter(valid_596424, JString, required = false,
                                 default = nil)
  if valid_596424 != nil:
    section.add "X-Amz-Content-Sha256", valid_596424
  var valid_596425 = header.getOrDefault("X-Amz-Date")
  valid_596425 = validateParameter(valid_596425, JString, required = false,
                                 default = nil)
  if valid_596425 != nil:
    section.add "X-Amz-Date", valid_596425
  var valid_596426 = header.getOrDefault("X-Amz-Credential")
  valid_596426 = validateParameter(valid_596426, JString, required = false,
                                 default = nil)
  if valid_596426 != nil:
    section.add "X-Amz-Credential", valid_596426
  var valid_596427 = header.getOrDefault("X-Amz-Security-Token")
  valid_596427 = validateParameter(valid_596427, JString, required = false,
                                 default = nil)
  if valid_596427 != nil:
    section.add "X-Amz-Security-Token", valid_596427
  var valid_596428 = header.getOrDefault("X-Amz-Algorithm")
  valid_596428 = validateParameter(valid_596428, JString, required = false,
                                 default = nil)
  if valid_596428 != nil:
    section.add "X-Amz-Algorithm", valid_596428
  var valid_596429 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596429 = validateParameter(valid_596429, JString, required = false,
                                 default = nil)
  if valid_596429 != nil:
    section.add "X-Amz-SignedHeaders", valid_596429
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596430: Call_ListThingsInBillingGroup_596417; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things you have added to the given billing group.
  ## 
  let valid = call_596430.validator(path, query, header, formData, body)
  let scheme = call_596430.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596430.url(scheme.get, call_596430.host, call_596430.base,
                         call_596430.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596430, url, valid)

proc call*(call_596431: Call_ListThingsInBillingGroup_596417;
          billingGroupName: string; nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listThingsInBillingGroup
  ## Lists the things you have added to the given billing group.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var path_596432 = newJObject()
  var query_596433 = newJObject()
  add(query_596433, "nextToken", newJString(nextToken))
  add(path_596432, "billingGroupName", newJString(billingGroupName))
  add(query_596433, "maxResults", newJInt(maxResults))
  result = call_596431.call(path_596432, query_596433, nil, nil, nil)

var listThingsInBillingGroup* = Call_ListThingsInBillingGroup_596417(
    name: "listThingsInBillingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}/things",
    validator: validate_ListThingsInBillingGroup_596418, base: "/",
    url: url_ListThingsInBillingGroup_596419, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingsInThingGroup_596434 = ref object of OpenApiRestCall_593389
proc url_ListThingsInThingGroup_596436(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingsInThingGroup_596435(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the things in the specified group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_596437 = path.getOrDefault("thingGroupName")
  valid_596437 = validateParameter(valid_596437, JString, required = true,
                                 default = nil)
  if valid_596437 != nil:
    section.add "thingGroupName", valid_596437
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   recursive: JBool
  ##            : When true, list things in this thing group and in all child groups as well.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_596438 = query.getOrDefault("nextToken")
  valid_596438 = validateParameter(valid_596438, JString, required = false,
                                 default = nil)
  if valid_596438 != nil:
    section.add "nextToken", valid_596438
  var valid_596439 = query.getOrDefault("recursive")
  valid_596439 = validateParameter(valid_596439, JBool, required = false, default = nil)
  if valid_596439 != nil:
    section.add "recursive", valid_596439
  var valid_596440 = query.getOrDefault("maxResults")
  valid_596440 = validateParameter(valid_596440, JInt, required = false, default = nil)
  if valid_596440 != nil:
    section.add "maxResults", valid_596440
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596441 = header.getOrDefault("X-Amz-Signature")
  valid_596441 = validateParameter(valid_596441, JString, required = false,
                                 default = nil)
  if valid_596441 != nil:
    section.add "X-Amz-Signature", valid_596441
  var valid_596442 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596442 = validateParameter(valid_596442, JString, required = false,
                                 default = nil)
  if valid_596442 != nil:
    section.add "X-Amz-Content-Sha256", valid_596442
  var valid_596443 = header.getOrDefault("X-Amz-Date")
  valid_596443 = validateParameter(valid_596443, JString, required = false,
                                 default = nil)
  if valid_596443 != nil:
    section.add "X-Amz-Date", valid_596443
  var valid_596444 = header.getOrDefault("X-Amz-Credential")
  valid_596444 = validateParameter(valid_596444, JString, required = false,
                                 default = nil)
  if valid_596444 != nil:
    section.add "X-Amz-Credential", valid_596444
  var valid_596445 = header.getOrDefault("X-Amz-Security-Token")
  valid_596445 = validateParameter(valid_596445, JString, required = false,
                                 default = nil)
  if valid_596445 != nil:
    section.add "X-Amz-Security-Token", valid_596445
  var valid_596446 = header.getOrDefault("X-Amz-Algorithm")
  valid_596446 = validateParameter(valid_596446, JString, required = false,
                                 default = nil)
  if valid_596446 != nil:
    section.add "X-Amz-Algorithm", valid_596446
  var valid_596447 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596447 = validateParameter(valid_596447, JString, required = false,
                                 default = nil)
  if valid_596447 != nil:
    section.add "X-Amz-SignedHeaders", valid_596447
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596448: Call_ListThingsInThingGroup_596434; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things in the specified group.
  ## 
  let valid = call_596448.validator(path, query, header, formData, body)
  let scheme = call_596448.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596448.url(scheme.get, call_596448.host, call_596448.base,
                         call_596448.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596448, url, valid)

proc call*(call_596449: Call_ListThingsInThingGroup_596434; thingGroupName: string;
          nextToken: string = ""; recursive: bool = false; maxResults: int = 0): Recallable =
  ## listThingsInThingGroup
  ## Lists the things in the specified group.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: string (required)
  ##                 : The thing group name.
  ##   recursive: bool
  ##            : When true, list things in this thing group and in all child groups as well.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_596450 = newJObject()
  var query_596451 = newJObject()
  add(query_596451, "nextToken", newJString(nextToken))
  add(path_596450, "thingGroupName", newJString(thingGroupName))
  add(query_596451, "recursive", newJBool(recursive))
  add(query_596451, "maxResults", newJInt(maxResults))
  result = call_596449.call(path_596450, query_596451, nil, nil, nil)

var listThingsInThingGroup* = Call_ListThingsInThingGroup_596434(
    name: "listThingsInThingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-groups/{thingGroupName}/things",
    validator: validate_ListThingsInThingGroup_596435, base: "/",
    url: url_ListThingsInThingGroup_596436, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTopicRules_596452 = ref object of OpenApiRestCall_593389
proc url_ListTopicRules_596454(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListTopicRules_596453(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the rules for the specific topic.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token used to retrieve the next value.
  ##   topic: JString
  ##        : The topic.
  ##   ruleDisabled: JBool
  ##               : Specifies whether the rule is disabled.
  ##   maxResults: JInt
  ##             : The maximum number of results to return.
  section = newJObject()
  var valid_596455 = query.getOrDefault("nextToken")
  valid_596455 = validateParameter(valid_596455, JString, required = false,
                                 default = nil)
  if valid_596455 != nil:
    section.add "nextToken", valid_596455
  var valid_596456 = query.getOrDefault("topic")
  valid_596456 = validateParameter(valid_596456, JString, required = false,
                                 default = nil)
  if valid_596456 != nil:
    section.add "topic", valid_596456
  var valid_596457 = query.getOrDefault("ruleDisabled")
  valid_596457 = validateParameter(valid_596457, JBool, required = false, default = nil)
  if valid_596457 != nil:
    section.add "ruleDisabled", valid_596457
  var valid_596458 = query.getOrDefault("maxResults")
  valid_596458 = validateParameter(valid_596458, JInt, required = false, default = nil)
  if valid_596458 != nil:
    section.add "maxResults", valid_596458
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596459 = header.getOrDefault("X-Amz-Signature")
  valid_596459 = validateParameter(valid_596459, JString, required = false,
                                 default = nil)
  if valid_596459 != nil:
    section.add "X-Amz-Signature", valid_596459
  var valid_596460 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596460 = validateParameter(valid_596460, JString, required = false,
                                 default = nil)
  if valid_596460 != nil:
    section.add "X-Amz-Content-Sha256", valid_596460
  var valid_596461 = header.getOrDefault("X-Amz-Date")
  valid_596461 = validateParameter(valid_596461, JString, required = false,
                                 default = nil)
  if valid_596461 != nil:
    section.add "X-Amz-Date", valid_596461
  var valid_596462 = header.getOrDefault("X-Amz-Credential")
  valid_596462 = validateParameter(valid_596462, JString, required = false,
                                 default = nil)
  if valid_596462 != nil:
    section.add "X-Amz-Credential", valid_596462
  var valid_596463 = header.getOrDefault("X-Amz-Security-Token")
  valid_596463 = validateParameter(valid_596463, JString, required = false,
                                 default = nil)
  if valid_596463 != nil:
    section.add "X-Amz-Security-Token", valid_596463
  var valid_596464 = header.getOrDefault("X-Amz-Algorithm")
  valid_596464 = validateParameter(valid_596464, JString, required = false,
                                 default = nil)
  if valid_596464 != nil:
    section.add "X-Amz-Algorithm", valid_596464
  var valid_596465 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596465 = validateParameter(valid_596465, JString, required = false,
                                 default = nil)
  if valid_596465 != nil:
    section.add "X-Amz-SignedHeaders", valid_596465
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596466: Call_ListTopicRules_596452; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the rules for the specific topic.
  ## 
  let valid = call_596466.validator(path, query, header, formData, body)
  let scheme = call_596466.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596466.url(scheme.get, call_596466.host, call_596466.base,
                         call_596466.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596466, url, valid)

proc call*(call_596467: Call_ListTopicRules_596452; nextToken: string = "";
          topic: string = ""; ruleDisabled: bool = false; maxResults: int = 0): Recallable =
  ## listTopicRules
  ## Lists the rules for the specific topic.
  ##   nextToken: string
  ##            : A token used to retrieve the next value.
  ##   topic: string
  ##        : The topic.
  ##   ruleDisabled: bool
  ##               : Specifies whether the rule is disabled.
  ##   maxResults: int
  ##             : The maximum number of results to return.
  var query_596468 = newJObject()
  add(query_596468, "nextToken", newJString(nextToken))
  add(query_596468, "topic", newJString(topic))
  add(query_596468, "ruleDisabled", newJBool(ruleDisabled))
  add(query_596468, "maxResults", newJInt(maxResults))
  result = call_596467.call(nil, query_596468, nil, nil, nil)

var listTopicRules* = Call_ListTopicRules_596452(name: "listTopicRules",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/rules",
    validator: validate_ListTopicRules_596453, base: "/", url: url_ListTopicRules_596454,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetV2LoggingLevel_596485 = ref object of OpenApiRestCall_593389
proc url_SetV2LoggingLevel_596487(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetV2LoggingLevel_596486(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Sets the logging level.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596488 = header.getOrDefault("X-Amz-Signature")
  valid_596488 = validateParameter(valid_596488, JString, required = false,
                                 default = nil)
  if valid_596488 != nil:
    section.add "X-Amz-Signature", valid_596488
  var valid_596489 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596489 = validateParameter(valid_596489, JString, required = false,
                                 default = nil)
  if valid_596489 != nil:
    section.add "X-Amz-Content-Sha256", valid_596489
  var valid_596490 = header.getOrDefault("X-Amz-Date")
  valid_596490 = validateParameter(valid_596490, JString, required = false,
                                 default = nil)
  if valid_596490 != nil:
    section.add "X-Amz-Date", valid_596490
  var valid_596491 = header.getOrDefault("X-Amz-Credential")
  valid_596491 = validateParameter(valid_596491, JString, required = false,
                                 default = nil)
  if valid_596491 != nil:
    section.add "X-Amz-Credential", valid_596491
  var valid_596492 = header.getOrDefault("X-Amz-Security-Token")
  valid_596492 = validateParameter(valid_596492, JString, required = false,
                                 default = nil)
  if valid_596492 != nil:
    section.add "X-Amz-Security-Token", valid_596492
  var valid_596493 = header.getOrDefault("X-Amz-Algorithm")
  valid_596493 = validateParameter(valid_596493, JString, required = false,
                                 default = nil)
  if valid_596493 != nil:
    section.add "X-Amz-Algorithm", valid_596493
  var valid_596494 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596494 = validateParameter(valid_596494, JString, required = false,
                                 default = nil)
  if valid_596494 != nil:
    section.add "X-Amz-SignedHeaders", valid_596494
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596496: Call_SetV2LoggingLevel_596485; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the logging level.
  ## 
  let valid = call_596496.validator(path, query, header, formData, body)
  let scheme = call_596496.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596496.url(scheme.get, call_596496.host, call_596496.base,
                         call_596496.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596496, url, valid)

proc call*(call_596497: Call_SetV2LoggingLevel_596485; body: JsonNode): Recallable =
  ## setV2LoggingLevel
  ## Sets the logging level.
  ##   body: JObject (required)
  var body_596498 = newJObject()
  if body != nil:
    body_596498 = body
  result = call_596497.call(nil, nil, nil, nil, body_596498)

var setV2LoggingLevel* = Call_SetV2LoggingLevel_596485(name: "setV2LoggingLevel",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/v2LoggingLevel",
    validator: validate_SetV2LoggingLevel_596486, base: "/",
    url: url_SetV2LoggingLevel_596487, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListV2LoggingLevels_596469 = ref object of OpenApiRestCall_593389
proc url_ListV2LoggingLevels_596471(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListV2LoggingLevels_596470(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists logging levels.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token used to get the next set of results, or <b>null</b> if there are no additional results.
  ##   targetType: JString
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_596472 = query.getOrDefault("nextToken")
  valid_596472 = validateParameter(valid_596472, JString, required = false,
                                 default = nil)
  if valid_596472 != nil:
    section.add "nextToken", valid_596472
  var valid_596473 = query.getOrDefault("targetType")
  valid_596473 = validateParameter(valid_596473, JString, required = false,
                                 default = newJString("DEFAULT"))
  if valid_596473 != nil:
    section.add "targetType", valid_596473
  var valid_596474 = query.getOrDefault("maxResults")
  valid_596474 = validateParameter(valid_596474, JInt, required = false, default = nil)
  if valid_596474 != nil:
    section.add "maxResults", valid_596474
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596475 = header.getOrDefault("X-Amz-Signature")
  valid_596475 = validateParameter(valid_596475, JString, required = false,
                                 default = nil)
  if valid_596475 != nil:
    section.add "X-Amz-Signature", valid_596475
  var valid_596476 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596476 = validateParameter(valid_596476, JString, required = false,
                                 default = nil)
  if valid_596476 != nil:
    section.add "X-Amz-Content-Sha256", valid_596476
  var valid_596477 = header.getOrDefault("X-Amz-Date")
  valid_596477 = validateParameter(valid_596477, JString, required = false,
                                 default = nil)
  if valid_596477 != nil:
    section.add "X-Amz-Date", valid_596477
  var valid_596478 = header.getOrDefault("X-Amz-Credential")
  valid_596478 = validateParameter(valid_596478, JString, required = false,
                                 default = nil)
  if valid_596478 != nil:
    section.add "X-Amz-Credential", valid_596478
  var valid_596479 = header.getOrDefault("X-Amz-Security-Token")
  valid_596479 = validateParameter(valid_596479, JString, required = false,
                                 default = nil)
  if valid_596479 != nil:
    section.add "X-Amz-Security-Token", valid_596479
  var valid_596480 = header.getOrDefault("X-Amz-Algorithm")
  valid_596480 = validateParameter(valid_596480, JString, required = false,
                                 default = nil)
  if valid_596480 != nil:
    section.add "X-Amz-Algorithm", valid_596480
  var valid_596481 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596481 = validateParameter(valid_596481, JString, required = false,
                                 default = nil)
  if valid_596481 != nil:
    section.add "X-Amz-SignedHeaders", valid_596481
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596482: Call_ListV2LoggingLevels_596469; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists logging levels.
  ## 
  let valid = call_596482.validator(path, query, header, formData, body)
  let scheme = call_596482.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596482.url(scheme.get, call_596482.host, call_596482.base,
                         call_596482.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596482, url, valid)

proc call*(call_596483: Call_ListV2LoggingLevels_596469; nextToken: string = "";
          targetType: string = "DEFAULT"; maxResults: int = 0): Recallable =
  ## listV2LoggingLevels
  ## Lists logging levels.
  ##   nextToken: string
  ##            : The token used to get the next set of results, or <b>null</b> if there are no additional results.
  ##   targetType: string
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_596484 = newJObject()
  add(query_596484, "nextToken", newJString(nextToken))
  add(query_596484, "targetType", newJString(targetType))
  add(query_596484, "maxResults", newJInt(maxResults))
  result = call_596483.call(nil, query_596484, nil, nil, nil)

var listV2LoggingLevels* = Call_ListV2LoggingLevels_596469(
    name: "listV2LoggingLevels", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/v2LoggingLevel",
    validator: validate_ListV2LoggingLevels_596470, base: "/",
    url: url_ListV2LoggingLevels_596471, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListViolationEvents_596499 = ref object of OpenApiRestCall_593389
proc url_ListViolationEvents_596501(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListViolationEvents_596500(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endTime: JString (required)
  ##          : The end time for the alerts to be listed.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : The start time for the alerts to be listed.
  ##   securityProfileName: JString
  ##                      : A filter to limit results to those alerts generated by the specified security profile.
  ##   thingName: JString
  ##            : A filter to limit results to those alerts caused by the specified thing.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_596502 = query.getOrDefault("endTime")
  valid_596502 = validateParameter(valid_596502, JString, required = true,
                                 default = nil)
  if valid_596502 != nil:
    section.add "endTime", valid_596502
  var valid_596503 = query.getOrDefault("nextToken")
  valid_596503 = validateParameter(valid_596503, JString, required = false,
                                 default = nil)
  if valid_596503 != nil:
    section.add "nextToken", valid_596503
  var valid_596504 = query.getOrDefault("startTime")
  valid_596504 = validateParameter(valid_596504, JString, required = true,
                                 default = nil)
  if valid_596504 != nil:
    section.add "startTime", valid_596504
  var valid_596505 = query.getOrDefault("securityProfileName")
  valid_596505 = validateParameter(valid_596505, JString, required = false,
                                 default = nil)
  if valid_596505 != nil:
    section.add "securityProfileName", valid_596505
  var valid_596506 = query.getOrDefault("thingName")
  valid_596506 = validateParameter(valid_596506, JString, required = false,
                                 default = nil)
  if valid_596506 != nil:
    section.add "thingName", valid_596506
  var valid_596507 = query.getOrDefault("maxResults")
  valid_596507 = validateParameter(valid_596507, JInt, required = false, default = nil)
  if valid_596507 != nil:
    section.add "maxResults", valid_596507
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596508 = header.getOrDefault("X-Amz-Signature")
  valid_596508 = validateParameter(valid_596508, JString, required = false,
                                 default = nil)
  if valid_596508 != nil:
    section.add "X-Amz-Signature", valid_596508
  var valid_596509 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596509 = validateParameter(valid_596509, JString, required = false,
                                 default = nil)
  if valid_596509 != nil:
    section.add "X-Amz-Content-Sha256", valid_596509
  var valid_596510 = header.getOrDefault("X-Amz-Date")
  valid_596510 = validateParameter(valid_596510, JString, required = false,
                                 default = nil)
  if valid_596510 != nil:
    section.add "X-Amz-Date", valid_596510
  var valid_596511 = header.getOrDefault("X-Amz-Credential")
  valid_596511 = validateParameter(valid_596511, JString, required = false,
                                 default = nil)
  if valid_596511 != nil:
    section.add "X-Amz-Credential", valid_596511
  var valid_596512 = header.getOrDefault("X-Amz-Security-Token")
  valid_596512 = validateParameter(valid_596512, JString, required = false,
                                 default = nil)
  if valid_596512 != nil:
    section.add "X-Amz-Security-Token", valid_596512
  var valid_596513 = header.getOrDefault("X-Amz-Algorithm")
  valid_596513 = validateParameter(valid_596513, JString, required = false,
                                 default = nil)
  if valid_596513 != nil:
    section.add "X-Amz-Algorithm", valid_596513
  var valid_596514 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596514 = validateParameter(valid_596514, JString, required = false,
                                 default = nil)
  if valid_596514 != nil:
    section.add "X-Amz-SignedHeaders", valid_596514
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596515: Call_ListViolationEvents_596499; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ## 
  let valid = call_596515.validator(path, query, header, formData, body)
  let scheme = call_596515.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596515.url(scheme.get, call_596515.host, call_596515.base,
                         call_596515.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596515, url, valid)

proc call*(call_596516: Call_ListViolationEvents_596499; endTime: string;
          startTime: string; nextToken: string = ""; securityProfileName: string = "";
          thingName: string = ""; maxResults: int = 0): Recallable =
  ## listViolationEvents
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ##   endTime: string (required)
  ##          : The end time for the alerts to be listed.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : The start time for the alerts to be listed.
  ##   securityProfileName: string
  ##                      : A filter to limit results to those alerts generated by the specified security profile.
  ##   thingName: string
  ##            : A filter to limit results to those alerts caused by the specified thing.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_596517 = newJObject()
  add(query_596517, "endTime", newJString(endTime))
  add(query_596517, "nextToken", newJString(nextToken))
  add(query_596517, "startTime", newJString(startTime))
  add(query_596517, "securityProfileName", newJString(securityProfileName))
  add(query_596517, "thingName", newJString(thingName))
  add(query_596517, "maxResults", newJInt(maxResults))
  result = call_596516.call(nil, query_596517, nil, nil, nil)

var listViolationEvents* = Call_ListViolationEvents_596499(
    name: "listViolationEvents", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/violation-events#startTime&endTime",
    validator: validate_ListViolationEvents_596500, base: "/",
    url: url_ListViolationEvents_596501, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterCACertificate_596518 = ref object of OpenApiRestCall_593389
proc url_RegisterCACertificate_596520(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RegisterCACertificate_596519(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   allowAutoRegistration: JBool
  ##                        : Allows this CA certificate to be used for auto registration of device certificates.
  ##   setAsActive: JBool
  ##              : A boolean value that specifies if the CA certificate is set to active.
  section = newJObject()
  var valid_596521 = query.getOrDefault("allowAutoRegistration")
  valid_596521 = validateParameter(valid_596521, JBool, required = false, default = nil)
  if valid_596521 != nil:
    section.add "allowAutoRegistration", valid_596521
  var valid_596522 = query.getOrDefault("setAsActive")
  valid_596522 = validateParameter(valid_596522, JBool, required = false, default = nil)
  if valid_596522 != nil:
    section.add "setAsActive", valid_596522
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596523 = header.getOrDefault("X-Amz-Signature")
  valid_596523 = validateParameter(valid_596523, JString, required = false,
                                 default = nil)
  if valid_596523 != nil:
    section.add "X-Amz-Signature", valid_596523
  var valid_596524 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596524 = validateParameter(valid_596524, JString, required = false,
                                 default = nil)
  if valid_596524 != nil:
    section.add "X-Amz-Content-Sha256", valid_596524
  var valid_596525 = header.getOrDefault("X-Amz-Date")
  valid_596525 = validateParameter(valid_596525, JString, required = false,
                                 default = nil)
  if valid_596525 != nil:
    section.add "X-Amz-Date", valid_596525
  var valid_596526 = header.getOrDefault("X-Amz-Credential")
  valid_596526 = validateParameter(valid_596526, JString, required = false,
                                 default = nil)
  if valid_596526 != nil:
    section.add "X-Amz-Credential", valid_596526
  var valid_596527 = header.getOrDefault("X-Amz-Security-Token")
  valid_596527 = validateParameter(valid_596527, JString, required = false,
                                 default = nil)
  if valid_596527 != nil:
    section.add "X-Amz-Security-Token", valid_596527
  var valid_596528 = header.getOrDefault("X-Amz-Algorithm")
  valid_596528 = validateParameter(valid_596528, JString, required = false,
                                 default = nil)
  if valid_596528 != nil:
    section.add "X-Amz-Algorithm", valid_596528
  var valid_596529 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596529 = validateParameter(valid_596529, JString, required = false,
                                 default = nil)
  if valid_596529 != nil:
    section.add "X-Amz-SignedHeaders", valid_596529
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596531: Call_RegisterCACertificate_596518; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ## 
  let valid = call_596531.validator(path, query, header, formData, body)
  let scheme = call_596531.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596531.url(scheme.get, call_596531.host, call_596531.base,
                         call_596531.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596531, url, valid)

proc call*(call_596532: Call_RegisterCACertificate_596518; body: JsonNode;
          allowAutoRegistration: bool = false; setAsActive: bool = false): Recallable =
  ## registerCACertificate
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ##   allowAutoRegistration: bool
  ##                        : Allows this CA certificate to be used for auto registration of device certificates.
  ##   setAsActive: bool
  ##              : A boolean value that specifies if the CA certificate is set to active.
  ##   body: JObject (required)
  var query_596533 = newJObject()
  var body_596534 = newJObject()
  add(query_596533, "allowAutoRegistration", newJBool(allowAutoRegistration))
  add(query_596533, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_596534 = body
  result = call_596532.call(nil, query_596533, nil, nil, body_596534)

var registerCACertificate* = Call_RegisterCACertificate_596518(
    name: "registerCACertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/cacertificate",
    validator: validate_RegisterCACertificate_596519, base: "/",
    url: url_RegisterCACertificate_596520, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterCertificate_596535 = ref object of OpenApiRestCall_593389
proc url_RegisterCertificate_596537(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RegisterCertificate_596536(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : A boolean value that specifies if the certificate is set to active.
  section = newJObject()
  var valid_596538 = query.getOrDefault("setAsActive")
  valid_596538 = validateParameter(valid_596538, JBool, required = false, default = nil)
  if valid_596538 != nil:
    section.add "setAsActive", valid_596538
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596539 = header.getOrDefault("X-Amz-Signature")
  valid_596539 = validateParameter(valid_596539, JString, required = false,
                                 default = nil)
  if valid_596539 != nil:
    section.add "X-Amz-Signature", valid_596539
  var valid_596540 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596540 = validateParameter(valid_596540, JString, required = false,
                                 default = nil)
  if valid_596540 != nil:
    section.add "X-Amz-Content-Sha256", valid_596540
  var valid_596541 = header.getOrDefault("X-Amz-Date")
  valid_596541 = validateParameter(valid_596541, JString, required = false,
                                 default = nil)
  if valid_596541 != nil:
    section.add "X-Amz-Date", valid_596541
  var valid_596542 = header.getOrDefault("X-Amz-Credential")
  valid_596542 = validateParameter(valid_596542, JString, required = false,
                                 default = nil)
  if valid_596542 != nil:
    section.add "X-Amz-Credential", valid_596542
  var valid_596543 = header.getOrDefault("X-Amz-Security-Token")
  valid_596543 = validateParameter(valid_596543, JString, required = false,
                                 default = nil)
  if valid_596543 != nil:
    section.add "X-Amz-Security-Token", valid_596543
  var valid_596544 = header.getOrDefault("X-Amz-Algorithm")
  valid_596544 = validateParameter(valid_596544, JString, required = false,
                                 default = nil)
  if valid_596544 != nil:
    section.add "X-Amz-Algorithm", valid_596544
  var valid_596545 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596545 = validateParameter(valid_596545, JString, required = false,
                                 default = nil)
  if valid_596545 != nil:
    section.add "X-Amz-SignedHeaders", valid_596545
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596547: Call_RegisterCertificate_596535; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ## 
  let valid = call_596547.validator(path, query, header, formData, body)
  let scheme = call_596547.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596547.url(scheme.get, call_596547.host, call_596547.base,
                         call_596547.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596547, url, valid)

proc call*(call_596548: Call_RegisterCertificate_596535; body: JsonNode;
          setAsActive: bool = false): Recallable =
  ## registerCertificate
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ##   setAsActive: bool
  ##              : A boolean value that specifies if the certificate is set to active.
  ##   body: JObject (required)
  var query_596549 = newJObject()
  var body_596550 = newJObject()
  add(query_596549, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_596550 = body
  result = call_596548.call(nil, query_596549, nil, nil, body_596550)

var registerCertificate* = Call_RegisterCertificate_596535(
    name: "registerCertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/certificate/register",
    validator: validate_RegisterCertificate_596536, base: "/",
    url: url_RegisterCertificate_596537, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RejectCertificateTransfer_596551 = ref object of OpenApiRestCall_593389
proc url_RejectCertificateTransfer_596553(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/reject-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_RejectCertificateTransfer_596552(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_596554 = path.getOrDefault("certificateId")
  valid_596554 = validateParameter(valid_596554, JString, required = true,
                                 default = nil)
  if valid_596554 != nil:
    section.add "certificateId", valid_596554
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596555 = header.getOrDefault("X-Amz-Signature")
  valid_596555 = validateParameter(valid_596555, JString, required = false,
                                 default = nil)
  if valid_596555 != nil:
    section.add "X-Amz-Signature", valid_596555
  var valid_596556 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596556 = validateParameter(valid_596556, JString, required = false,
                                 default = nil)
  if valid_596556 != nil:
    section.add "X-Amz-Content-Sha256", valid_596556
  var valid_596557 = header.getOrDefault("X-Amz-Date")
  valid_596557 = validateParameter(valid_596557, JString, required = false,
                                 default = nil)
  if valid_596557 != nil:
    section.add "X-Amz-Date", valid_596557
  var valid_596558 = header.getOrDefault("X-Amz-Credential")
  valid_596558 = validateParameter(valid_596558, JString, required = false,
                                 default = nil)
  if valid_596558 != nil:
    section.add "X-Amz-Credential", valid_596558
  var valid_596559 = header.getOrDefault("X-Amz-Security-Token")
  valid_596559 = validateParameter(valid_596559, JString, required = false,
                                 default = nil)
  if valid_596559 != nil:
    section.add "X-Amz-Security-Token", valid_596559
  var valid_596560 = header.getOrDefault("X-Amz-Algorithm")
  valid_596560 = validateParameter(valid_596560, JString, required = false,
                                 default = nil)
  if valid_596560 != nil:
    section.add "X-Amz-Algorithm", valid_596560
  var valid_596561 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596561 = validateParameter(valid_596561, JString, required = false,
                                 default = nil)
  if valid_596561 != nil:
    section.add "X-Amz-SignedHeaders", valid_596561
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596563: Call_RejectCertificateTransfer_596551; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ## 
  let valid = call_596563.validator(path, query, header, formData, body)
  let scheme = call_596563.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596563.url(scheme.get, call_596563.host, call_596563.base,
                         call_596563.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596563, url, valid)

proc call*(call_596564: Call_RejectCertificateTransfer_596551; body: JsonNode;
          certificateId: string): Recallable =
  ## rejectCertificateTransfer
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ##   body: JObject (required)
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_596565 = newJObject()
  var body_596566 = newJObject()
  if body != nil:
    body_596566 = body
  add(path_596565, "certificateId", newJString(certificateId))
  result = call_596564.call(path_596565, nil, nil, nil, body_596566)

var rejectCertificateTransfer* = Call_RejectCertificateTransfer_596551(
    name: "rejectCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/reject-certificate-transfer/{certificateId}",
    validator: validate_RejectCertificateTransfer_596552, base: "/",
    url: url_RejectCertificateTransfer_596553,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveThingFromBillingGroup_596567 = ref object of OpenApiRestCall_593389
proc url_RemoveThingFromBillingGroup_596569(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RemoveThingFromBillingGroup_596568(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes the given thing from the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596570 = header.getOrDefault("X-Amz-Signature")
  valid_596570 = validateParameter(valid_596570, JString, required = false,
                                 default = nil)
  if valid_596570 != nil:
    section.add "X-Amz-Signature", valid_596570
  var valid_596571 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596571 = validateParameter(valid_596571, JString, required = false,
                                 default = nil)
  if valid_596571 != nil:
    section.add "X-Amz-Content-Sha256", valid_596571
  var valid_596572 = header.getOrDefault("X-Amz-Date")
  valid_596572 = validateParameter(valid_596572, JString, required = false,
                                 default = nil)
  if valid_596572 != nil:
    section.add "X-Amz-Date", valid_596572
  var valid_596573 = header.getOrDefault("X-Amz-Credential")
  valid_596573 = validateParameter(valid_596573, JString, required = false,
                                 default = nil)
  if valid_596573 != nil:
    section.add "X-Amz-Credential", valid_596573
  var valid_596574 = header.getOrDefault("X-Amz-Security-Token")
  valid_596574 = validateParameter(valid_596574, JString, required = false,
                                 default = nil)
  if valid_596574 != nil:
    section.add "X-Amz-Security-Token", valid_596574
  var valid_596575 = header.getOrDefault("X-Amz-Algorithm")
  valid_596575 = validateParameter(valid_596575, JString, required = false,
                                 default = nil)
  if valid_596575 != nil:
    section.add "X-Amz-Algorithm", valid_596575
  var valid_596576 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596576 = validateParameter(valid_596576, JString, required = false,
                                 default = nil)
  if valid_596576 != nil:
    section.add "X-Amz-SignedHeaders", valid_596576
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596578: Call_RemoveThingFromBillingGroup_596567; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes the given thing from the billing group.
  ## 
  let valid = call_596578.validator(path, query, header, formData, body)
  let scheme = call_596578.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596578.url(scheme.get, call_596578.host, call_596578.base,
                         call_596578.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596578, url, valid)

proc call*(call_596579: Call_RemoveThingFromBillingGroup_596567; body: JsonNode): Recallable =
  ## removeThingFromBillingGroup
  ## Removes the given thing from the billing group.
  ##   body: JObject (required)
  var body_596580 = newJObject()
  if body != nil:
    body_596580 = body
  result = call_596579.call(nil, nil, nil, nil, body_596580)

var removeThingFromBillingGroup* = Call_RemoveThingFromBillingGroup_596567(
    name: "removeThingFromBillingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/billing-groups/removeThingFromBillingGroup",
    validator: validate_RemoveThingFromBillingGroup_596568, base: "/",
    url: url_RemoveThingFromBillingGroup_596569,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveThingFromThingGroup_596581 = ref object of OpenApiRestCall_593389
proc url_RemoveThingFromThingGroup_596583(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RemoveThingFromThingGroup_596582(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove the specified thing from the specified group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596584 = header.getOrDefault("X-Amz-Signature")
  valid_596584 = validateParameter(valid_596584, JString, required = false,
                                 default = nil)
  if valid_596584 != nil:
    section.add "X-Amz-Signature", valid_596584
  var valid_596585 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596585 = validateParameter(valid_596585, JString, required = false,
                                 default = nil)
  if valid_596585 != nil:
    section.add "X-Amz-Content-Sha256", valid_596585
  var valid_596586 = header.getOrDefault("X-Amz-Date")
  valid_596586 = validateParameter(valid_596586, JString, required = false,
                                 default = nil)
  if valid_596586 != nil:
    section.add "X-Amz-Date", valid_596586
  var valid_596587 = header.getOrDefault("X-Amz-Credential")
  valid_596587 = validateParameter(valid_596587, JString, required = false,
                                 default = nil)
  if valid_596587 != nil:
    section.add "X-Amz-Credential", valid_596587
  var valid_596588 = header.getOrDefault("X-Amz-Security-Token")
  valid_596588 = validateParameter(valid_596588, JString, required = false,
                                 default = nil)
  if valid_596588 != nil:
    section.add "X-Amz-Security-Token", valid_596588
  var valid_596589 = header.getOrDefault("X-Amz-Algorithm")
  valid_596589 = validateParameter(valid_596589, JString, required = false,
                                 default = nil)
  if valid_596589 != nil:
    section.add "X-Amz-Algorithm", valid_596589
  var valid_596590 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596590 = validateParameter(valid_596590, JString, required = false,
                                 default = nil)
  if valid_596590 != nil:
    section.add "X-Amz-SignedHeaders", valid_596590
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596592: Call_RemoveThingFromThingGroup_596581; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Remove the specified thing from the specified group.
  ## 
  let valid = call_596592.validator(path, query, header, formData, body)
  let scheme = call_596592.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596592.url(scheme.get, call_596592.host, call_596592.base,
                         call_596592.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596592, url, valid)

proc call*(call_596593: Call_RemoveThingFromThingGroup_596581; body: JsonNode): Recallable =
  ## removeThingFromThingGroup
  ## Remove the specified thing from the specified group.
  ##   body: JObject (required)
  var body_596594 = newJObject()
  if body != nil:
    body_596594 = body
  result = call_596593.call(nil, nil, nil, nil, body_596594)

var removeThingFromThingGroup* = Call_RemoveThingFromThingGroup_596581(
    name: "removeThingFromThingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/removeThingFromThingGroup",
    validator: validate_RemoveThingFromThingGroup_596582, base: "/",
    url: url_RemoveThingFromThingGroup_596583,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_SearchIndex_596595 = ref object of OpenApiRestCall_593389
proc url_SearchIndex_596597(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SearchIndex_596596(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## The query search index.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596598 = header.getOrDefault("X-Amz-Signature")
  valid_596598 = validateParameter(valid_596598, JString, required = false,
                                 default = nil)
  if valid_596598 != nil:
    section.add "X-Amz-Signature", valid_596598
  var valid_596599 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596599 = validateParameter(valid_596599, JString, required = false,
                                 default = nil)
  if valid_596599 != nil:
    section.add "X-Amz-Content-Sha256", valid_596599
  var valid_596600 = header.getOrDefault("X-Amz-Date")
  valid_596600 = validateParameter(valid_596600, JString, required = false,
                                 default = nil)
  if valid_596600 != nil:
    section.add "X-Amz-Date", valid_596600
  var valid_596601 = header.getOrDefault("X-Amz-Credential")
  valid_596601 = validateParameter(valid_596601, JString, required = false,
                                 default = nil)
  if valid_596601 != nil:
    section.add "X-Amz-Credential", valid_596601
  var valid_596602 = header.getOrDefault("X-Amz-Security-Token")
  valid_596602 = validateParameter(valid_596602, JString, required = false,
                                 default = nil)
  if valid_596602 != nil:
    section.add "X-Amz-Security-Token", valid_596602
  var valid_596603 = header.getOrDefault("X-Amz-Algorithm")
  valid_596603 = validateParameter(valid_596603, JString, required = false,
                                 default = nil)
  if valid_596603 != nil:
    section.add "X-Amz-Algorithm", valid_596603
  var valid_596604 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596604 = validateParameter(valid_596604, JString, required = false,
                                 default = nil)
  if valid_596604 != nil:
    section.add "X-Amz-SignedHeaders", valid_596604
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596606: Call_SearchIndex_596595; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The query search index.
  ## 
  let valid = call_596606.validator(path, query, header, formData, body)
  let scheme = call_596606.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596606.url(scheme.get, call_596606.host, call_596606.base,
                         call_596606.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596606, url, valid)

proc call*(call_596607: Call_SearchIndex_596595; body: JsonNode): Recallable =
  ## searchIndex
  ## The query search index.
  ##   body: JObject (required)
  var body_596608 = newJObject()
  if body != nil:
    body_596608 = body
  result = call_596607.call(nil, nil, nil, nil, body_596608)

var searchIndex* = Call_SearchIndex_596595(name: "searchIndex",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com",
                                        route: "/indices/search",
                                        validator: validate_SearchIndex_596596,
                                        base: "/", url: url_SearchIndex_596597,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartOnDemandAuditTask_596609 = ref object of OpenApiRestCall_593389
proc url_StartOnDemandAuditTask_596611(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_StartOnDemandAuditTask_596610(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts an on-demand Device Defender audit.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596612 = header.getOrDefault("X-Amz-Signature")
  valid_596612 = validateParameter(valid_596612, JString, required = false,
                                 default = nil)
  if valid_596612 != nil:
    section.add "X-Amz-Signature", valid_596612
  var valid_596613 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596613 = validateParameter(valid_596613, JString, required = false,
                                 default = nil)
  if valid_596613 != nil:
    section.add "X-Amz-Content-Sha256", valid_596613
  var valid_596614 = header.getOrDefault("X-Amz-Date")
  valid_596614 = validateParameter(valid_596614, JString, required = false,
                                 default = nil)
  if valid_596614 != nil:
    section.add "X-Amz-Date", valid_596614
  var valid_596615 = header.getOrDefault("X-Amz-Credential")
  valid_596615 = validateParameter(valid_596615, JString, required = false,
                                 default = nil)
  if valid_596615 != nil:
    section.add "X-Amz-Credential", valid_596615
  var valid_596616 = header.getOrDefault("X-Amz-Security-Token")
  valid_596616 = validateParameter(valid_596616, JString, required = false,
                                 default = nil)
  if valid_596616 != nil:
    section.add "X-Amz-Security-Token", valid_596616
  var valid_596617 = header.getOrDefault("X-Amz-Algorithm")
  valid_596617 = validateParameter(valid_596617, JString, required = false,
                                 default = nil)
  if valid_596617 != nil:
    section.add "X-Amz-Algorithm", valid_596617
  var valid_596618 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596618 = validateParameter(valid_596618, JString, required = false,
                                 default = nil)
  if valid_596618 != nil:
    section.add "X-Amz-SignedHeaders", valid_596618
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596620: Call_StartOnDemandAuditTask_596609; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts an on-demand Device Defender audit.
  ## 
  let valid = call_596620.validator(path, query, header, formData, body)
  let scheme = call_596620.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596620.url(scheme.get, call_596620.host, call_596620.base,
                         call_596620.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596620, url, valid)

proc call*(call_596621: Call_StartOnDemandAuditTask_596609; body: JsonNode): Recallable =
  ## startOnDemandAuditTask
  ## Starts an on-demand Device Defender audit.
  ##   body: JObject (required)
  var body_596622 = newJObject()
  if body != nil:
    body_596622 = body
  result = call_596621.call(nil, nil, nil, nil, body_596622)

var startOnDemandAuditTask* = Call_StartOnDemandAuditTask_596609(
    name: "startOnDemandAuditTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/audit/tasks",
    validator: validate_StartOnDemandAuditTask_596610, base: "/",
    url: url_StartOnDemandAuditTask_596611, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StopThingRegistrationTask_596623 = ref object of OpenApiRestCall_593389
proc url_StopThingRegistrationTask_596625(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_StopThingRegistrationTask_596624(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The bulk thing provisioning task ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_596626 = path.getOrDefault("taskId")
  valid_596626 = validateParameter(valid_596626, JString, required = true,
                                 default = nil)
  if valid_596626 != nil:
    section.add "taskId", valid_596626
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596627 = header.getOrDefault("X-Amz-Signature")
  valid_596627 = validateParameter(valid_596627, JString, required = false,
                                 default = nil)
  if valid_596627 != nil:
    section.add "X-Amz-Signature", valid_596627
  var valid_596628 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596628 = validateParameter(valid_596628, JString, required = false,
                                 default = nil)
  if valid_596628 != nil:
    section.add "X-Amz-Content-Sha256", valid_596628
  var valid_596629 = header.getOrDefault("X-Amz-Date")
  valid_596629 = validateParameter(valid_596629, JString, required = false,
                                 default = nil)
  if valid_596629 != nil:
    section.add "X-Amz-Date", valid_596629
  var valid_596630 = header.getOrDefault("X-Amz-Credential")
  valid_596630 = validateParameter(valid_596630, JString, required = false,
                                 default = nil)
  if valid_596630 != nil:
    section.add "X-Amz-Credential", valid_596630
  var valid_596631 = header.getOrDefault("X-Amz-Security-Token")
  valid_596631 = validateParameter(valid_596631, JString, required = false,
                                 default = nil)
  if valid_596631 != nil:
    section.add "X-Amz-Security-Token", valid_596631
  var valid_596632 = header.getOrDefault("X-Amz-Algorithm")
  valid_596632 = validateParameter(valid_596632, JString, required = false,
                                 default = nil)
  if valid_596632 != nil:
    section.add "X-Amz-Algorithm", valid_596632
  var valid_596633 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596633 = validateParameter(valid_596633, JString, required = false,
                                 default = nil)
  if valid_596633 != nil:
    section.add "X-Amz-SignedHeaders", valid_596633
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596634: Call_StopThingRegistrationTask_596623; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a bulk thing provisioning task.
  ## 
  let valid = call_596634.validator(path, query, header, formData, body)
  let scheme = call_596634.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596634.url(scheme.get, call_596634.host, call_596634.base,
                         call_596634.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596634, url, valid)

proc call*(call_596635: Call_StopThingRegistrationTask_596623; taskId: string): Recallable =
  ## stopThingRegistrationTask
  ## Cancels a bulk thing provisioning task.
  ##   taskId: string (required)
  ##         : The bulk thing provisioning task ID.
  var path_596636 = newJObject()
  add(path_596636, "taskId", newJString(taskId))
  result = call_596635.call(path_596636, nil, nil, nil, nil)

var stopThingRegistrationTask* = Call_StopThingRegistrationTask_596623(
    name: "stopThingRegistrationTask", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks/{taskId}/cancel",
    validator: validate_StopThingRegistrationTask_596624, base: "/",
    url: url_StopThingRegistrationTask_596625,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_TagResource_596637 = ref object of OpenApiRestCall_593389
proc url_TagResource_596639(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_TagResource_596638(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596640 = header.getOrDefault("X-Amz-Signature")
  valid_596640 = validateParameter(valid_596640, JString, required = false,
                                 default = nil)
  if valid_596640 != nil:
    section.add "X-Amz-Signature", valid_596640
  var valid_596641 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596641 = validateParameter(valid_596641, JString, required = false,
                                 default = nil)
  if valid_596641 != nil:
    section.add "X-Amz-Content-Sha256", valid_596641
  var valid_596642 = header.getOrDefault("X-Amz-Date")
  valid_596642 = validateParameter(valid_596642, JString, required = false,
                                 default = nil)
  if valid_596642 != nil:
    section.add "X-Amz-Date", valid_596642
  var valid_596643 = header.getOrDefault("X-Amz-Credential")
  valid_596643 = validateParameter(valid_596643, JString, required = false,
                                 default = nil)
  if valid_596643 != nil:
    section.add "X-Amz-Credential", valid_596643
  var valid_596644 = header.getOrDefault("X-Amz-Security-Token")
  valid_596644 = validateParameter(valid_596644, JString, required = false,
                                 default = nil)
  if valid_596644 != nil:
    section.add "X-Amz-Security-Token", valid_596644
  var valid_596645 = header.getOrDefault("X-Amz-Algorithm")
  valid_596645 = validateParameter(valid_596645, JString, required = false,
                                 default = nil)
  if valid_596645 != nil:
    section.add "X-Amz-Algorithm", valid_596645
  var valid_596646 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596646 = validateParameter(valid_596646, JString, required = false,
                                 default = nil)
  if valid_596646 != nil:
    section.add "X-Amz-SignedHeaders", valid_596646
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596648: Call_TagResource_596637; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ## 
  let valid = call_596648.validator(path, query, header, formData, body)
  let scheme = call_596648.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596648.url(scheme.get, call_596648.host, call_596648.base,
                         call_596648.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596648, url, valid)

proc call*(call_596649: Call_TagResource_596637; body: JsonNode): Recallable =
  ## tagResource
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ##   body: JObject (required)
  var body_596650 = newJObject()
  if body != nil:
    body_596650 = body
  result = call_596649.call(nil, nil, nil, nil, body_596650)

var tagResource* = Call_TagResource_596637(name: "tagResource",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com", route: "/tags",
                                        validator: validate_TagResource_596638,
                                        base: "/", url: url_TagResource_596639,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_TestAuthorization_596651 = ref object of OpenApiRestCall_593389
proc url_TestAuthorization_596653(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_TestAuthorization_596652(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   clientId: JString
  ##           : The MQTT client ID.
  section = newJObject()
  var valid_596654 = query.getOrDefault("clientId")
  valid_596654 = validateParameter(valid_596654, JString, required = false,
                                 default = nil)
  if valid_596654 != nil:
    section.add "clientId", valid_596654
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596655 = header.getOrDefault("X-Amz-Signature")
  valid_596655 = validateParameter(valid_596655, JString, required = false,
                                 default = nil)
  if valid_596655 != nil:
    section.add "X-Amz-Signature", valid_596655
  var valid_596656 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596656 = validateParameter(valid_596656, JString, required = false,
                                 default = nil)
  if valid_596656 != nil:
    section.add "X-Amz-Content-Sha256", valid_596656
  var valid_596657 = header.getOrDefault("X-Amz-Date")
  valid_596657 = validateParameter(valid_596657, JString, required = false,
                                 default = nil)
  if valid_596657 != nil:
    section.add "X-Amz-Date", valid_596657
  var valid_596658 = header.getOrDefault("X-Amz-Credential")
  valid_596658 = validateParameter(valid_596658, JString, required = false,
                                 default = nil)
  if valid_596658 != nil:
    section.add "X-Amz-Credential", valid_596658
  var valid_596659 = header.getOrDefault("X-Amz-Security-Token")
  valid_596659 = validateParameter(valid_596659, JString, required = false,
                                 default = nil)
  if valid_596659 != nil:
    section.add "X-Amz-Security-Token", valid_596659
  var valid_596660 = header.getOrDefault("X-Amz-Algorithm")
  valid_596660 = validateParameter(valid_596660, JString, required = false,
                                 default = nil)
  if valid_596660 != nil:
    section.add "X-Amz-Algorithm", valid_596660
  var valid_596661 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596661 = validateParameter(valid_596661, JString, required = false,
                                 default = nil)
  if valid_596661 != nil:
    section.add "X-Amz-SignedHeaders", valid_596661
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596663: Call_TestAuthorization_596651; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  let valid = call_596663.validator(path, query, header, formData, body)
  let scheme = call_596663.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596663.url(scheme.get, call_596663.host, call_596663.base,
                         call_596663.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596663, url, valid)

proc call*(call_596664: Call_TestAuthorization_596651; body: JsonNode;
          clientId: string = ""): Recallable =
  ## testAuthorization
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ##   clientId: string
  ##           : The MQTT client ID.
  ##   body: JObject (required)
  var query_596665 = newJObject()
  var body_596666 = newJObject()
  add(query_596665, "clientId", newJString(clientId))
  if body != nil:
    body_596666 = body
  result = call_596664.call(nil, query_596665, nil, nil, body_596666)

var testAuthorization* = Call_TestAuthorization_596651(name: "testAuthorization",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/test-authorization", validator: validate_TestAuthorization_596652,
    base: "/", url: url_TestAuthorization_596653,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_TestInvokeAuthorizer_596667 = ref object of OpenApiRestCall_593389
proc url_TestInvokeAuthorizer_596669(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName"),
               (kind: ConstantSegment, value: "/test")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_TestInvokeAuthorizer_596668(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The custom authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_596670 = path.getOrDefault("authorizerName")
  valid_596670 = validateParameter(valid_596670, JString, required = true,
                                 default = nil)
  if valid_596670 != nil:
    section.add "authorizerName", valid_596670
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596671 = header.getOrDefault("X-Amz-Signature")
  valid_596671 = validateParameter(valid_596671, JString, required = false,
                                 default = nil)
  if valid_596671 != nil:
    section.add "X-Amz-Signature", valid_596671
  var valid_596672 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596672 = validateParameter(valid_596672, JString, required = false,
                                 default = nil)
  if valid_596672 != nil:
    section.add "X-Amz-Content-Sha256", valid_596672
  var valid_596673 = header.getOrDefault("X-Amz-Date")
  valid_596673 = validateParameter(valid_596673, JString, required = false,
                                 default = nil)
  if valid_596673 != nil:
    section.add "X-Amz-Date", valid_596673
  var valid_596674 = header.getOrDefault("X-Amz-Credential")
  valid_596674 = validateParameter(valid_596674, JString, required = false,
                                 default = nil)
  if valid_596674 != nil:
    section.add "X-Amz-Credential", valid_596674
  var valid_596675 = header.getOrDefault("X-Amz-Security-Token")
  valid_596675 = validateParameter(valid_596675, JString, required = false,
                                 default = nil)
  if valid_596675 != nil:
    section.add "X-Amz-Security-Token", valid_596675
  var valid_596676 = header.getOrDefault("X-Amz-Algorithm")
  valid_596676 = validateParameter(valid_596676, JString, required = false,
                                 default = nil)
  if valid_596676 != nil:
    section.add "X-Amz-Algorithm", valid_596676
  var valid_596677 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596677 = validateParameter(valid_596677, JString, required = false,
                                 default = nil)
  if valid_596677 != nil:
    section.add "X-Amz-SignedHeaders", valid_596677
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596679: Call_TestInvokeAuthorizer_596667; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  let valid = call_596679.validator(path, query, header, formData, body)
  let scheme = call_596679.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596679.url(scheme.get, call_596679.host, call_596679.base,
                         call_596679.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596679, url, valid)

proc call*(call_596680: Call_TestInvokeAuthorizer_596667; authorizerName: string;
          body: JsonNode): Recallable =
  ## testInvokeAuthorizer
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ##   authorizerName: string (required)
  ##                 : The custom authorizer name.
  ##   body: JObject (required)
  var path_596681 = newJObject()
  var body_596682 = newJObject()
  add(path_596681, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_596682 = body
  result = call_596680.call(path_596681, nil, nil, nil, body_596682)

var testInvokeAuthorizer* = Call_TestInvokeAuthorizer_596667(
    name: "testInvokeAuthorizer", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/authorizer/{authorizerName}/test",
    validator: validate_TestInvokeAuthorizer_596668, base: "/",
    url: url_TestInvokeAuthorizer_596669, schemes: {Scheme.Https, Scheme.Http})
type
  Call_TransferCertificate_596683 = ref object of OpenApiRestCall_593389
proc url_TransferCertificate_596685(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/transfer-certificate/"),
               (kind: VariableSegment, value: "certificateId"),
               (kind: ConstantSegment, value: "#targetAwsAccount")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_TransferCertificate_596684(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_596686 = path.getOrDefault("certificateId")
  valid_596686 = validateParameter(valid_596686, JString, required = true,
                                 default = nil)
  if valid_596686 != nil:
    section.add "certificateId", valid_596686
  result.add "path", section
  ## parameters in `query` object:
  ##   targetAwsAccount: JString (required)
  ##                   : The AWS account.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `targetAwsAccount` field"
  var valid_596687 = query.getOrDefault("targetAwsAccount")
  valid_596687 = validateParameter(valid_596687, JString, required = true,
                                 default = nil)
  if valid_596687 != nil:
    section.add "targetAwsAccount", valid_596687
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596688 = header.getOrDefault("X-Amz-Signature")
  valid_596688 = validateParameter(valid_596688, JString, required = false,
                                 default = nil)
  if valid_596688 != nil:
    section.add "X-Amz-Signature", valid_596688
  var valid_596689 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596689 = validateParameter(valid_596689, JString, required = false,
                                 default = nil)
  if valid_596689 != nil:
    section.add "X-Amz-Content-Sha256", valid_596689
  var valid_596690 = header.getOrDefault("X-Amz-Date")
  valid_596690 = validateParameter(valid_596690, JString, required = false,
                                 default = nil)
  if valid_596690 != nil:
    section.add "X-Amz-Date", valid_596690
  var valid_596691 = header.getOrDefault("X-Amz-Credential")
  valid_596691 = validateParameter(valid_596691, JString, required = false,
                                 default = nil)
  if valid_596691 != nil:
    section.add "X-Amz-Credential", valid_596691
  var valid_596692 = header.getOrDefault("X-Amz-Security-Token")
  valid_596692 = validateParameter(valid_596692, JString, required = false,
                                 default = nil)
  if valid_596692 != nil:
    section.add "X-Amz-Security-Token", valid_596692
  var valid_596693 = header.getOrDefault("X-Amz-Algorithm")
  valid_596693 = validateParameter(valid_596693, JString, required = false,
                                 default = nil)
  if valid_596693 != nil:
    section.add "X-Amz-Algorithm", valid_596693
  var valid_596694 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596694 = validateParameter(valid_596694, JString, required = false,
                                 default = nil)
  if valid_596694 != nil:
    section.add "X-Amz-SignedHeaders", valid_596694
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596696: Call_TransferCertificate_596683; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ## 
  let valid = call_596696.validator(path, query, header, formData, body)
  let scheme = call_596696.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596696.url(scheme.get, call_596696.host, call_596696.base,
                         call_596696.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596696, url, valid)

proc call*(call_596697: Call_TransferCertificate_596683; body: JsonNode;
          certificateId: string; targetAwsAccount: string): Recallable =
  ## transferCertificate
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ##   body: JObject (required)
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   targetAwsAccount: string (required)
  ##                   : The AWS account.
  var path_596698 = newJObject()
  var query_596699 = newJObject()
  var body_596700 = newJObject()
  if body != nil:
    body_596700 = body
  add(path_596698, "certificateId", newJString(certificateId))
  add(query_596699, "targetAwsAccount", newJString(targetAwsAccount))
  result = call_596697.call(path_596698, query_596699, nil, nil, body_596700)

var transferCertificate* = Call_TransferCertificate_596683(
    name: "transferCertificate", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/transfer-certificate/{certificateId}#targetAwsAccount",
    validator: validate_TransferCertificate_596684, base: "/",
    url: url_TransferCertificate_596685, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UntagResource_596701 = ref object of OpenApiRestCall_593389
proc url_UntagResource_596703(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UntagResource_596702(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes the given tags (metadata) from the resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596704 = header.getOrDefault("X-Amz-Signature")
  valid_596704 = validateParameter(valid_596704, JString, required = false,
                                 default = nil)
  if valid_596704 != nil:
    section.add "X-Amz-Signature", valid_596704
  var valid_596705 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596705 = validateParameter(valid_596705, JString, required = false,
                                 default = nil)
  if valid_596705 != nil:
    section.add "X-Amz-Content-Sha256", valid_596705
  var valid_596706 = header.getOrDefault("X-Amz-Date")
  valid_596706 = validateParameter(valid_596706, JString, required = false,
                                 default = nil)
  if valid_596706 != nil:
    section.add "X-Amz-Date", valid_596706
  var valid_596707 = header.getOrDefault("X-Amz-Credential")
  valid_596707 = validateParameter(valid_596707, JString, required = false,
                                 default = nil)
  if valid_596707 != nil:
    section.add "X-Amz-Credential", valid_596707
  var valid_596708 = header.getOrDefault("X-Amz-Security-Token")
  valid_596708 = validateParameter(valid_596708, JString, required = false,
                                 default = nil)
  if valid_596708 != nil:
    section.add "X-Amz-Security-Token", valid_596708
  var valid_596709 = header.getOrDefault("X-Amz-Algorithm")
  valid_596709 = validateParameter(valid_596709, JString, required = false,
                                 default = nil)
  if valid_596709 != nil:
    section.add "X-Amz-Algorithm", valid_596709
  var valid_596710 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596710 = validateParameter(valid_596710, JString, required = false,
                                 default = nil)
  if valid_596710 != nil:
    section.add "X-Amz-SignedHeaders", valid_596710
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596712: Call_UntagResource_596701; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes the given tags (metadata) from the resource.
  ## 
  let valid = call_596712.validator(path, query, header, formData, body)
  let scheme = call_596712.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596712.url(scheme.get, call_596712.host, call_596712.base,
                         call_596712.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596712, url, valid)

proc call*(call_596713: Call_UntagResource_596701; body: JsonNode): Recallable =
  ## untagResource
  ## Removes the given tags (metadata) from the resource.
  ##   body: JObject (required)
  var body_596714 = newJObject()
  if body != nil:
    body_596714 = body
  result = call_596713.call(nil, nil, nil, nil, body_596714)

var untagResource* = Call_UntagResource_596701(name: "untagResource",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/untag",
    validator: validate_UntagResource_596702, base: "/", url: url_UntagResource_596703,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateCertificate_596715 = ref object of OpenApiRestCall_593389
proc url_UpdateCertificate_596717(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId"),
               (kind: ConstantSegment, value: "#newStatus")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateCertificate_596716(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_596718 = path.getOrDefault("certificateId")
  valid_596718 = validateParameter(valid_596718, JString, required = true,
                                 default = nil)
  if valid_596718 != nil:
    section.add "certificateId", valid_596718
  result.add "path", section
  ## parameters in `query` object:
  ##   newStatus: JString (required)
  ##            : <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `newStatus` field"
  var valid_596719 = query.getOrDefault("newStatus")
  valid_596719 = validateParameter(valid_596719, JString, required = true,
                                 default = newJString("ACTIVE"))
  if valid_596719 != nil:
    section.add "newStatus", valid_596719
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596720 = header.getOrDefault("X-Amz-Signature")
  valid_596720 = validateParameter(valid_596720, JString, required = false,
                                 default = nil)
  if valid_596720 != nil:
    section.add "X-Amz-Signature", valid_596720
  var valid_596721 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596721 = validateParameter(valid_596721, JString, required = false,
                                 default = nil)
  if valid_596721 != nil:
    section.add "X-Amz-Content-Sha256", valid_596721
  var valid_596722 = header.getOrDefault("X-Amz-Date")
  valid_596722 = validateParameter(valid_596722, JString, required = false,
                                 default = nil)
  if valid_596722 != nil:
    section.add "X-Amz-Date", valid_596722
  var valid_596723 = header.getOrDefault("X-Amz-Credential")
  valid_596723 = validateParameter(valid_596723, JString, required = false,
                                 default = nil)
  if valid_596723 != nil:
    section.add "X-Amz-Credential", valid_596723
  var valid_596724 = header.getOrDefault("X-Amz-Security-Token")
  valid_596724 = validateParameter(valid_596724, JString, required = false,
                                 default = nil)
  if valid_596724 != nil:
    section.add "X-Amz-Security-Token", valid_596724
  var valid_596725 = header.getOrDefault("X-Amz-Algorithm")
  valid_596725 = validateParameter(valid_596725, JString, required = false,
                                 default = nil)
  if valid_596725 != nil:
    section.add "X-Amz-Algorithm", valid_596725
  var valid_596726 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596726 = validateParameter(valid_596726, JString, required = false,
                                 default = nil)
  if valid_596726 != nil:
    section.add "X-Amz-SignedHeaders", valid_596726
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596727: Call_UpdateCertificate_596715; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ## 
  let valid = call_596727.validator(path, query, header, formData, body)
  let scheme = call_596727.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596727.url(scheme.get, call_596727.host, call_596727.base,
                         call_596727.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596727, url, valid)

proc call*(call_596728: Call_UpdateCertificate_596715; certificateId: string;
          newStatus: string = "ACTIVE"): Recallable =
  ## updateCertificate
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ##   newStatus: string (required)
  ##            : <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_596729 = newJObject()
  var query_596730 = newJObject()
  add(query_596730, "newStatus", newJString(newStatus))
  add(path_596729, "certificateId", newJString(certificateId))
  result = call_596728.call(path_596729, query_596730, nil, nil, nil)

var updateCertificate* = Call_UpdateCertificate_596715(name: "updateCertificate",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/certificates/{certificateId}#newStatus",
    validator: validate_UpdateCertificate_596716, base: "/",
    url: url_UpdateCertificate_596717, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThingGroupsForThing_596731 = ref object of OpenApiRestCall_593389
proc url_UpdateThingGroupsForThing_596733(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateThingGroupsForThing_596732(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the groups to which the thing belongs.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596734 = header.getOrDefault("X-Amz-Signature")
  valid_596734 = validateParameter(valid_596734, JString, required = false,
                                 default = nil)
  if valid_596734 != nil:
    section.add "X-Amz-Signature", valid_596734
  var valid_596735 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596735 = validateParameter(valid_596735, JString, required = false,
                                 default = nil)
  if valid_596735 != nil:
    section.add "X-Amz-Content-Sha256", valid_596735
  var valid_596736 = header.getOrDefault("X-Amz-Date")
  valid_596736 = validateParameter(valid_596736, JString, required = false,
                                 default = nil)
  if valid_596736 != nil:
    section.add "X-Amz-Date", valid_596736
  var valid_596737 = header.getOrDefault("X-Amz-Credential")
  valid_596737 = validateParameter(valid_596737, JString, required = false,
                                 default = nil)
  if valid_596737 != nil:
    section.add "X-Amz-Credential", valid_596737
  var valid_596738 = header.getOrDefault("X-Amz-Security-Token")
  valid_596738 = validateParameter(valid_596738, JString, required = false,
                                 default = nil)
  if valid_596738 != nil:
    section.add "X-Amz-Security-Token", valid_596738
  var valid_596739 = header.getOrDefault("X-Amz-Algorithm")
  valid_596739 = validateParameter(valid_596739, JString, required = false,
                                 default = nil)
  if valid_596739 != nil:
    section.add "X-Amz-Algorithm", valid_596739
  var valid_596740 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596740 = validateParameter(valid_596740, JString, required = false,
                                 default = nil)
  if valid_596740 != nil:
    section.add "X-Amz-SignedHeaders", valid_596740
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596742: Call_UpdateThingGroupsForThing_596731; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the groups to which the thing belongs.
  ## 
  let valid = call_596742.validator(path, query, header, formData, body)
  let scheme = call_596742.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596742.url(scheme.get, call_596742.host, call_596742.base,
                         call_596742.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596742, url, valid)

proc call*(call_596743: Call_UpdateThingGroupsForThing_596731; body: JsonNode): Recallable =
  ## updateThingGroupsForThing
  ## Updates the groups to which the thing belongs.
  ##   body: JObject (required)
  var body_596744 = newJObject()
  if body != nil:
    body_596744 = body
  result = call_596743.call(nil, nil, nil, nil, body_596744)

var updateThingGroupsForThing* = Call_UpdateThingGroupsForThing_596731(
    name: "updateThingGroupsForThing", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/updateThingGroupsForThing",
    validator: validate_UpdateThingGroupsForThing_596732, base: "/",
    url: url_UpdateThingGroupsForThing_596733,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ValidateSecurityProfileBehaviors_596745 = ref object of OpenApiRestCall_593389
proc url_ValidateSecurityProfileBehaviors_596747(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ValidateSecurityProfileBehaviors_596746(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validates a Device Defender security profile behaviors specification.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596748 = header.getOrDefault("X-Amz-Signature")
  valid_596748 = validateParameter(valid_596748, JString, required = false,
                                 default = nil)
  if valid_596748 != nil:
    section.add "X-Amz-Signature", valid_596748
  var valid_596749 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596749 = validateParameter(valid_596749, JString, required = false,
                                 default = nil)
  if valid_596749 != nil:
    section.add "X-Amz-Content-Sha256", valid_596749
  var valid_596750 = header.getOrDefault("X-Amz-Date")
  valid_596750 = validateParameter(valid_596750, JString, required = false,
                                 default = nil)
  if valid_596750 != nil:
    section.add "X-Amz-Date", valid_596750
  var valid_596751 = header.getOrDefault("X-Amz-Credential")
  valid_596751 = validateParameter(valid_596751, JString, required = false,
                                 default = nil)
  if valid_596751 != nil:
    section.add "X-Amz-Credential", valid_596751
  var valid_596752 = header.getOrDefault("X-Amz-Security-Token")
  valid_596752 = validateParameter(valid_596752, JString, required = false,
                                 default = nil)
  if valid_596752 != nil:
    section.add "X-Amz-Security-Token", valid_596752
  var valid_596753 = header.getOrDefault("X-Amz-Algorithm")
  valid_596753 = validateParameter(valid_596753, JString, required = false,
                                 default = nil)
  if valid_596753 != nil:
    section.add "X-Amz-Algorithm", valid_596753
  var valid_596754 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596754 = validateParameter(valid_596754, JString, required = false,
                                 default = nil)
  if valid_596754 != nil:
    section.add "X-Amz-SignedHeaders", valid_596754
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_596756: Call_ValidateSecurityProfileBehaviors_596745;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Validates a Device Defender security profile behaviors specification.
  ## 
  let valid = call_596756.validator(path, query, header, formData, body)
  let scheme = call_596756.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596756.url(scheme.get, call_596756.host, call_596756.base,
                         call_596756.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596756, url, valid)

proc call*(call_596757: Call_ValidateSecurityProfileBehaviors_596745;
          body: JsonNode): Recallable =
  ## validateSecurityProfileBehaviors
  ## Validates a Device Defender security profile behaviors specification.
  ##   body: JObject (required)
  var body_596758 = newJObject()
  if body != nil:
    body_596758 = body
  result = call_596757.call(nil, nil, nil, nil, body_596758)

var validateSecurityProfileBehaviors* = Call_ValidateSecurityProfileBehaviors_596745(
    name: "validateSecurityProfileBehaviors", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/security-profile-behaviors/validate",
    validator: validate_ValidateSecurityProfileBehaviors_596746, base: "/",
    url: url_ValidateSecurityProfileBehaviors_596747,
    schemes: {Scheme.Https, Scheme.Http})
export
  rest

proc sign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", "")
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", "")
    region = os.getEnv("AWS_REGION", "")
  assert secret != "", "need secret key in env"
  assert access != "", "need access key in env"
  assert region != "", "need region in env"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  recall.headers.del "Host"
  recall.url = $url

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  let headers = massageHeaders(input.getOrDefault("header"))
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
  result.sign(input.getOrDefault("query"), SHA256)
