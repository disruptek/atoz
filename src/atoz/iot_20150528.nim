
import
  json, options, hashes, uri, strutils, tables, rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: AWS IoT
## version: 2015-05-28
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>AWS IoT</fullname> <p>AWS IoT provides secure, bi-directional communication between Internet-connected devices (such as sensors, actuators, embedded devices, or smart appliances) and the AWS cloud. You can discover your custom IoT-Data endpoint to communicate with, configure rules for data processing and integration with other services, organize resources associated with each device (Registry), configure logging, and create and manage policies and credentials to authenticate devices.</p> <p>For more information about how AWS IoT works, see the <a href="https://docs.aws.amazon.com/iot/latest/developerguide/aws-iot-how-it-works.html">Developer Guide</a>.</p> <p>For information about how to use the credentials provider for AWS IoT, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorizing-direct-aws.html">Authorizing Direct Calls to AWS Services</a>.</p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/iot/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_612658 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_612658](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_612658): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "iot.ap-northeast-1.amazonaws.com", "ap-southeast-1": "iot.ap-southeast-1.amazonaws.com",
                           "us-west-2": "iot.us-west-2.amazonaws.com",
                           "eu-west-2": "iot.eu-west-2.amazonaws.com", "ap-northeast-3": "iot.ap-northeast-3.amazonaws.com",
                           "eu-central-1": "iot.eu-central-1.amazonaws.com",
                           "us-east-2": "iot.us-east-2.amazonaws.com",
                           "us-east-1": "iot.us-east-1.amazonaws.com", "cn-northwest-1": "iot.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "iot.ap-south-1.amazonaws.com",
                           "eu-north-1": "iot.eu-north-1.amazonaws.com", "ap-northeast-2": "iot.ap-northeast-2.amazonaws.com",
                           "us-west-1": "iot.us-west-1.amazonaws.com",
                           "us-gov-east-1": "iot.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "iot.eu-west-3.amazonaws.com",
                           "cn-north-1": "iot.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "iot.sa-east-1.amazonaws.com",
                           "eu-west-1": "iot.eu-west-1.amazonaws.com",
                           "us-gov-west-1": "iot.us-gov-west-1.amazonaws.com", "ap-southeast-2": "iot.ap-southeast-2.amazonaws.com",
                           "ca-central-1": "iot.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "iot.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "iot.ap-southeast-1.amazonaws.com",
      "us-west-2": "iot.us-west-2.amazonaws.com",
      "eu-west-2": "iot.eu-west-2.amazonaws.com",
      "ap-northeast-3": "iot.ap-northeast-3.amazonaws.com",
      "eu-central-1": "iot.eu-central-1.amazonaws.com",
      "us-east-2": "iot.us-east-2.amazonaws.com",
      "us-east-1": "iot.us-east-1.amazonaws.com",
      "cn-northwest-1": "iot.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "iot.ap-south-1.amazonaws.com",
      "eu-north-1": "iot.eu-north-1.amazonaws.com",
      "ap-northeast-2": "iot.ap-northeast-2.amazonaws.com",
      "us-west-1": "iot.us-west-1.amazonaws.com",
      "us-gov-east-1": "iot.us-gov-east-1.amazonaws.com",
      "eu-west-3": "iot.eu-west-3.amazonaws.com",
      "cn-north-1": "iot.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "iot.sa-east-1.amazonaws.com",
      "eu-west-1": "iot.eu-west-1.amazonaws.com",
      "us-gov-west-1": "iot.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "iot.ap-southeast-2.amazonaws.com",
      "ca-central-1": "iot.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "iot"
method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_AcceptCertificateTransfer_612996 = ref object of OpenApiRestCall_612658
proc url_AcceptCertificateTransfer_612998(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/accept-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AcceptCertificateTransfer_612997(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_613124 = path.getOrDefault("certificateId")
  valid_613124 = validateParameter(valid_613124, JString, required = true,
                                 default = nil)
  if valid_613124 != nil:
    section.add "certificateId", valid_613124
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_613125 = query.getOrDefault("setAsActive")
  valid_613125 = validateParameter(valid_613125, JBool, required = false, default = nil)
  if valid_613125 != nil:
    section.add "setAsActive", valid_613125
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613126 = header.getOrDefault("X-Amz-Signature")
  valid_613126 = validateParameter(valid_613126, JString, required = false,
                                 default = nil)
  if valid_613126 != nil:
    section.add "X-Amz-Signature", valid_613126
  var valid_613127 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613127 = validateParameter(valid_613127, JString, required = false,
                                 default = nil)
  if valid_613127 != nil:
    section.add "X-Amz-Content-Sha256", valid_613127
  var valid_613128 = header.getOrDefault("X-Amz-Date")
  valid_613128 = validateParameter(valid_613128, JString, required = false,
                                 default = nil)
  if valid_613128 != nil:
    section.add "X-Amz-Date", valid_613128
  var valid_613129 = header.getOrDefault("X-Amz-Credential")
  valid_613129 = validateParameter(valid_613129, JString, required = false,
                                 default = nil)
  if valid_613129 != nil:
    section.add "X-Amz-Credential", valid_613129
  var valid_613130 = header.getOrDefault("X-Amz-Security-Token")
  valid_613130 = validateParameter(valid_613130, JString, required = false,
                                 default = nil)
  if valid_613130 != nil:
    section.add "X-Amz-Security-Token", valid_613130
  var valid_613131 = header.getOrDefault("X-Amz-Algorithm")
  valid_613131 = validateParameter(valid_613131, JString, required = false,
                                 default = nil)
  if valid_613131 != nil:
    section.add "X-Amz-Algorithm", valid_613131
  var valid_613132 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613132 = validateParameter(valid_613132, JString, required = false,
                                 default = nil)
  if valid_613132 != nil:
    section.add "X-Amz-SignedHeaders", valid_613132
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613155: Call_AcceptCertificateTransfer_612996; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ## 
  let valid = call_613155.validator(path, query, header, formData, body)
  let scheme = call_613155.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613155.url(scheme.get, call_613155.host, call_613155.base,
                         call_613155.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613155, url, valid)

proc call*(call_613226: Call_AcceptCertificateTransfer_612996;
          certificateId: string; setAsActive: bool = false): Recallable =
  ## acceptCertificateTransfer
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_613227 = newJObject()
  var query_613229 = newJObject()
  add(query_613229, "setAsActive", newJBool(setAsActive))
  add(path_613227, "certificateId", newJString(certificateId))
  result = call_613226.call(path_613227, query_613229, nil, nil, nil)

var acceptCertificateTransfer* = Call_AcceptCertificateTransfer_612996(
    name: "acceptCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/accept-certificate-transfer/{certificateId}",
    validator: validate_AcceptCertificateTransfer_612997, base: "/",
    url: url_AcceptCertificateTransfer_612998,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_AddThingToBillingGroup_613268 = ref object of OpenApiRestCall_612658
proc url_AddThingToBillingGroup_613270(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_AddThingToBillingGroup_613269(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a thing to a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613271 = header.getOrDefault("X-Amz-Signature")
  valid_613271 = validateParameter(valid_613271, JString, required = false,
                                 default = nil)
  if valid_613271 != nil:
    section.add "X-Amz-Signature", valid_613271
  var valid_613272 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613272 = validateParameter(valid_613272, JString, required = false,
                                 default = nil)
  if valid_613272 != nil:
    section.add "X-Amz-Content-Sha256", valid_613272
  var valid_613273 = header.getOrDefault("X-Amz-Date")
  valid_613273 = validateParameter(valid_613273, JString, required = false,
                                 default = nil)
  if valid_613273 != nil:
    section.add "X-Amz-Date", valid_613273
  var valid_613274 = header.getOrDefault("X-Amz-Credential")
  valid_613274 = validateParameter(valid_613274, JString, required = false,
                                 default = nil)
  if valid_613274 != nil:
    section.add "X-Amz-Credential", valid_613274
  var valid_613275 = header.getOrDefault("X-Amz-Security-Token")
  valid_613275 = validateParameter(valid_613275, JString, required = false,
                                 default = nil)
  if valid_613275 != nil:
    section.add "X-Amz-Security-Token", valid_613275
  var valid_613276 = header.getOrDefault("X-Amz-Algorithm")
  valid_613276 = validateParameter(valid_613276, JString, required = false,
                                 default = nil)
  if valid_613276 != nil:
    section.add "X-Amz-Algorithm", valid_613276
  var valid_613277 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613277 = validateParameter(valid_613277, JString, required = false,
                                 default = nil)
  if valid_613277 != nil:
    section.add "X-Amz-SignedHeaders", valid_613277
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613279: Call_AddThingToBillingGroup_613268; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a thing to a billing group.
  ## 
  let valid = call_613279.validator(path, query, header, formData, body)
  let scheme = call_613279.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613279.url(scheme.get, call_613279.host, call_613279.base,
                         call_613279.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613279, url, valid)

proc call*(call_613280: Call_AddThingToBillingGroup_613268; body: JsonNode): Recallable =
  ## addThingToBillingGroup
  ## Adds a thing to a billing group.
  ##   body: JObject (required)
  var body_613281 = newJObject()
  if body != nil:
    body_613281 = body
  result = call_613280.call(nil, nil, nil, nil, body_613281)

var addThingToBillingGroup* = Call_AddThingToBillingGroup_613268(
    name: "addThingToBillingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/billing-groups/addThingToBillingGroup",
    validator: validate_AddThingToBillingGroup_613269, base: "/",
    url: url_AddThingToBillingGroup_613270, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AddThingToThingGroup_613282 = ref object of OpenApiRestCall_612658
proc url_AddThingToThingGroup_613284(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_AddThingToThingGroup_613283(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a thing to a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613285 = header.getOrDefault("X-Amz-Signature")
  valid_613285 = validateParameter(valid_613285, JString, required = false,
                                 default = nil)
  if valid_613285 != nil:
    section.add "X-Amz-Signature", valid_613285
  var valid_613286 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613286 = validateParameter(valid_613286, JString, required = false,
                                 default = nil)
  if valid_613286 != nil:
    section.add "X-Amz-Content-Sha256", valid_613286
  var valid_613287 = header.getOrDefault("X-Amz-Date")
  valid_613287 = validateParameter(valid_613287, JString, required = false,
                                 default = nil)
  if valid_613287 != nil:
    section.add "X-Amz-Date", valid_613287
  var valid_613288 = header.getOrDefault("X-Amz-Credential")
  valid_613288 = validateParameter(valid_613288, JString, required = false,
                                 default = nil)
  if valid_613288 != nil:
    section.add "X-Amz-Credential", valid_613288
  var valid_613289 = header.getOrDefault("X-Amz-Security-Token")
  valid_613289 = validateParameter(valid_613289, JString, required = false,
                                 default = nil)
  if valid_613289 != nil:
    section.add "X-Amz-Security-Token", valid_613289
  var valid_613290 = header.getOrDefault("X-Amz-Algorithm")
  valid_613290 = validateParameter(valid_613290, JString, required = false,
                                 default = nil)
  if valid_613290 != nil:
    section.add "X-Amz-Algorithm", valid_613290
  var valid_613291 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613291 = validateParameter(valid_613291, JString, required = false,
                                 default = nil)
  if valid_613291 != nil:
    section.add "X-Amz-SignedHeaders", valid_613291
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613293: Call_AddThingToThingGroup_613282; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a thing to a thing group.
  ## 
  let valid = call_613293.validator(path, query, header, formData, body)
  let scheme = call_613293.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613293.url(scheme.get, call_613293.host, call_613293.base,
                         call_613293.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613293, url, valid)

proc call*(call_613294: Call_AddThingToThingGroup_613282; body: JsonNode): Recallable =
  ## addThingToThingGroup
  ## Adds a thing to a thing group.
  ##   body: JObject (required)
  var body_613295 = newJObject()
  if body != nil:
    body_613295 = body
  result = call_613294.call(nil, nil, nil, nil, body_613295)

var addThingToThingGroup* = Call_AddThingToThingGroup_613282(
    name: "addThingToThingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/addThingToThingGroup",
    validator: validate_AddThingToThingGroup_613283, base: "/",
    url: url_AddThingToThingGroup_613284, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AssociateTargetsWithJob_613296 = ref object of OpenApiRestCall_612658
proc url_AssociateTargetsWithJob_613298(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/targets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AssociateTargetsWithJob_613297(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_613299 = path.getOrDefault("jobId")
  valid_613299 = validateParameter(valid_613299, JString, required = true,
                                 default = nil)
  if valid_613299 != nil:
    section.add "jobId", valid_613299
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613300 = header.getOrDefault("X-Amz-Signature")
  valid_613300 = validateParameter(valid_613300, JString, required = false,
                                 default = nil)
  if valid_613300 != nil:
    section.add "X-Amz-Signature", valid_613300
  var valid_613301 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613301 = validateParameter(valid_613301, JString, required = false,
                                 default = nil)
  if valid_613301 != nil:
    section.add "X-Amz-Content-Sha256", valid_613301
  var valid_613302 = header.getOrDefault("X-Amz-Date")
  valid_613302 = validateParameter(valid_613302, JString, required = false,
                                 default = nil)
  if valid_613302 != nil:
    section.add "X-Amz-Date", valid_613302
  var valid_613303 = header.getOrDefault("X-Amz-Credential")
  valid_613303 = validateParameter(valid_613303, JString, required = false,
                                 default = nil)
  if valid_613303 != nil:
    section.add "X-Amz-Credential", valid_613303
  var valid_613304 = header.getOrDefault("X-Amz-Security-Token")
  valid_613304 = validateParameter(valid_613304, JString, required = false,
                                 default = nil)
  if valid_613304 != nil:
    section.add "X-Amz-Security-Token", valid_613304
  var valid_613305 = header.getOrDefault("X-Amz-Algorithm")
  valid_613305 = validateParameter(valid_613305, JString, required = false,
                                 default = nil)
  if valid_613305 != nil:
    section.add "X-Amz-Algorithm", valid_613305
  var valid_613306 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613306 = validateParameter(valid_613306, JString, required = false,
                                 default = nil)
  if valid_613306 != nil:
    section.add "X-Amz-SignedHeaders", valid_613306
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613308: Call_AssociateTargetsWithJob_613296; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ## 
  let valid = call_613308.validator(path, query, header, formData, body)
  let scheme = call_613308.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613308.url(scheme.get, call_613308.host, call_613308.base,
                         call_613308.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613308, url, valid)

proc call*(call_613309: Call_AssociateTargetsWithJob_613296; jobId: string;
          body: JsonNode): Recallable =
  ## associateTargetsWithJob
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   body: JObject (required)
  var path_613310 = newJObject()
  var body_613311 = newJObject()
  add(path_613310, "jobId", newJString(jobId))
  if body != nil:
    body_613311 = body
  result = call_613309.call(path_613310, nil, nil, nil, body_613311)

var associateTargetsWithJob* = Call_AssociateTargetsWithJob_613296(
    name: "associateTargetsWithJob", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/jobs/{jobId}/targets",
    validator: validate_AssociateTargetsWithJob_613297, base: "/",
    url: url_AssociateTargetsWithJob_613298, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachPolicy_613312 = ref object of OpenApiRestCall_612658
proc url_AttachPolicy_613314(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/target-policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachPolicy_613313(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Attaches a policy to the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to attach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_613315 = path.getOrDefault("policyName")
  valid_613315 = validateParameter(valid_613315, JString, required = true,
                                 default = nil)
  if valid_613315 != nil:
    section.add "policyName", valid_613315
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613316 = header.getOrDefault("X-Amz-Signature")
  valid_613316 = validateParameter(valid_613316, JString, required = false,
                                 default = nil)
  if valid_613316 != nil:
    section.add "X-Amz-Signature", valid_613316
  var valid_613317 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613317 = validateParameter(valid_613317, JString, required = false,
                                 default = nil)
  if valid_613317 != nil:
    section.add "X-Amz-Content-Sha256", valid_613317
  var valid_613318 = header.getOrDefault("X-Amz-Date")
  valid_613318 = validateParameter(valid_613318, JString, required = false,
                                 default = nil)
  if valid_613318 != nil:
    section.add "X-Amz-Date", valid_613318
  var valid_613319 = header.getOrDefault("X-Amz-Credential")
  valid_613319 = validateParameter(valid_613319, JString, required = false,
                                 default = nil)
  if valid_613319 != nil:
    section.add "X-Amz-Credential", valid_613319
  var valid_613320 = header.getOrDefault("X-Amz-Security-Token")
  valid_613320 = validateParameter(valid_613320, JString, required = false,
                                 default = nil)
  if valid_613320 != nil:
    section.add "X-Amz-Security-Token", valid_613320
  var valid_613321 = header.getOrDefault("X-Amz-Algorithm")
  valid_613321 = validateParameter(valid_613321, JString, required = false,
                                 default = nil)
  if valid_613321 != nil:
    section.add "X-Amz-Algorithm", valid_613321
  var valid_613322 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613322 = validateParameter(valid_613322, JString, required = false,
                                 default = nil)
  if valid_613322 != nil:
    section.add "X-Amz-SignedHeaders", valid_613322
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613324: Call_AttachPolicy_613312; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Attaches a policy to the specified target.
  ## 
  let valid = call_613324.validator(path, query, header, formData, body)
  let scheme = call_613324.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613324.url(scheme.get, call_613324.host, call_613324.base,
                         call_613324.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613324, url, valid)

proc call*(call_613325: Call_AttachPolicy_613312; policyName: string; body: JsonNode): Recallable =
  ## attachPolicy
  ## Attaches a policy to the specified target.
  ##   policyName: string (required)
  ##             : The name of the policy to attach.
  ##   body: JObject (required)
  var path_613326 = newJObject()
  var body_613327 = newJObject()
  add(path_613326, "policyName", newJString(policyName))
  if body != nil:
    body_613327 = body
  result = call_613325.call(path_613326, nil, nil, nil, body_613327)

var attachPolicy* = Call_AttachPolicy_613312(name: "attachPolicy",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/target-policies/{policyName}", validator: validate_AttachPolicy_613313,
    base: "/", url: url_AttachPolicy_613314, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachPolicy_613328 = ref object of OpenApiRestCall_612658
proc url_DetachPolicy_613330(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/target-policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachPolicy_613329(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Detaches a policy from the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy to detach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_613331 = path.getOrDefault("policyName")
  valid_613331 = validateParameter(valid_613331, JString, required = true,
                                 default = nil)
  if valid_613331 != nil:
    section.add "policyName", valid_613331
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613332 = header.getOrDefault("X-Amz-Signature")
  valid_613332 = validateParameter(valid_613332, JString, required = false,
                                 default = nil)
  if valid_613332 != nil:
    section.add "X-Amz-Signature", valid_613332
  var valid_613333 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613333 = validateParameter(valid_613333, JString, required = false,
                                 default = nil)
  if valid_613333 != nil:
    section.add "X-Amz-Content-Sha256", valid_613333
  var valid_613334 = header.getOrDefault("X-Amz-Date")
  valid_613334 = validateParameter(valid_613334, JString, required = false,
                                 default = nil)
  if valid_613334 != nil:
    section.add "X-Amz-Date", valid_613334
  var valid_613335 = header.getOrDefault("X-Amz-Credential")
  valid_613335 = validateParameter(valid_613335, JString, required = false,
                                 default = nil)
  if valid_613335 != nil:
    section.add "X-Amz-Credential", valid_613335
  var valid_613336 = header.getOrDefault("X-Amz-Security-Token")
  valid_613336 = validateParameter(valid_613336, JString, required = false,
                                 default = nil)
  if valid_613336 != nil:
    section.add "X-Amz-Security-Token", valid_613336
  var valid_613337 = header.getOrDefault("X-Amz-Algorithm")
  valid_613337 = validateParameter(valid_613337, JString, required = false,
                                 default = nil)
  if valid_613337 != nil:
    section.add "X-Amz-Algorithm", valid_613337
  var valid_613338 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613338 = validateParameter(valid_613338, JString, required = false,
                                 default = nil)
  if valid_613338 != nil:
    section.add "X-Amz-SignedHeaders", valid_613338
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613340: Call_DetachPolicy_613328; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Detaches a policy from the specified target.
  ## 
  let valid = call_613340.validator(path, query, header, formData, body)
  let scheme = call_613340.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613340.url(scheme.get, call_613340.host, call_613340.base,
                         call_613340.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613340, url, valid)

proc call*(call_613341: Call_DetachPolicy_613328; policyName: string; body: JsonNode): Recallable =
  ## detachPolicy
  ## Detaches a policy from the specified target.
  ##   policyName: string (required)
  ##             : The policy to detach.
  ##   body: JObject (required)
  var path_613342 = newJObject()
  var body_613343 = newJObject()
  add(path_613342, "policyName", newJString(policyName))
  if body != nil:
    body_613343 = body
  result = call_613341.call(path_613342, nil, nil, nil, body_613343)

var detachPolicy* = Call_DetachPolicy_613328(name: "detachPolicy",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/target-policies/{policyName}", validator: validate_DetachPolicy_613329,
    base: "/", url: url_DetachPolicy_613330, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachPrincipalPolicy_613344 = ref object of OpenApiRestCall_612658
proc url_AttachPrincipalPolicy_613346(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/principal-policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "#x-amzn-iot-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachPrincipalPolicy_613345(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_613347 = path.getOrDefault("policyName")
  valid_613347 = validateParameter(valid_613347, JString, required = true,
                                 default = nil)
  if valid_613347 != nil:
    section.add "policyName", valid_613347
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613348 = header.getOrDefault("X-Amz-Signature")
  valid_613348 = validateParameter(valid_613348, JString, required = false,
                                 default = nil)
  if valid_613348 != nil:
    section.add "X-Amz-Signature", valid_613348
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_613349 = header.getOrDefault("x-amzn-iot-principal")
  valid_613349 = validateParameter(valid_613349, JString, required = true,
                                 default = nil)
  if valid_613349 != nil:
    section.add "x-amzn-iot-principal", valid_613349
  var valid_613350 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613350 = validateParameter(valid_613350, JString, required = false,
                                 default = nil)
  if valid_613350 != nil:
    section.add "X-Amz-Content-Sha256", valid_613350
  var valid_613351 = header.getOrDefault("X-Amz-Date")
  valid_613351 = validateParameter(valid_613351, JString, required = false,
                                 default = nil)
  if valid_613351 != nil:
    section.add "X-Amz-Date", valid_613351
  var valid_613352 = header.getOrDefault("X-Amz-Credential")
  valid_613352 = validateParameter(valid_613352, JString, required = false,
                                 default = nil)
  if valid_613352 != nil:
    section.add "X-Amz-Credential", valid_613352
  var valid_613353 = header.getOrDefault("X-Amz-Security-Token")
  valid_613353 = validateParameter(valid_613353, JString, required = false,
                                 default = nil)
  if valid_613353 != nil:
    section.add "X-Amz-Security-Token", valid_613353
  var valid_613354 = header.getOrDefault("X-Amz-Algorithm")
  valid_613354 = validateParameter(valid_613354, JString, required = false,
                                 default = nil)
  if valid_613354 != nil:
    section.add "X-Amz-Algorithm", valid_613354
  var valid_613355 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613355 = validateParameter(valid_613355, JString, required = false,
                                 default = nil)
  if valid_613355 != nil:
    section.add "X-Amz-SignedHeaders", valid_613355
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613356: Call_AttachPrincipalPolicy_613344; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ## 
  let valid = call_613356.validator(path, query, header, formData, body)
  let scheme = call_613356.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613356.url(scheme.get, call_613356.host, call_613356.base,
                         call_613356.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613356, url, valid)

proc call*(call_613357: Call_AttachPrincipalPolicy_613344; policyName: string): Recallable =
  ## attachPrincipalPolicy
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ##   policyName: string (required)
  ##             : The policy name.
  var path_613358 = newJObject()
  add(path_613358, "policyName", newJString(policyName))
  result = call_613357.call(path_613358, nil, nil, nil, nil)

var attachPrincipalPolicy* = Call_AttachPrincipalPolicy_613344(
    name: "attachPrincipalPolicy", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/principal-policies/{policyName}#x-amzn-iot-principal",
    validator: validate_AttachPrincipalPolicy_613345, base: "/",
    url: url_AttachPrincipalPolicy_613346, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachPrincipalPolicy_613359 = ref object of OpenApiRestCall_612658
proc url_DetachPrincipalPolicy_613361(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/principal-policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "#x-amzn-iot-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachPrincipalPolicy_613360(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to detach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_613362 = path.getOrDefault("policyName")
  valid_613362 = validateParameter(valid_613362, JString, required = true,
                                 default = nil)
  if valid_613362 != nil:
    section.add "policyName", valid_613362
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : <p>The principal.</p> <p>If the principal is a certificate, specify the certificate ARN. If the principal is an Amazon Cognito identity, specify the identity ID.</p>
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613363 = header.getOrDefault("X-Amz-Signature")
  valid_613363 = validateParameter(valid_613363, JString, required = false,
                                 default = nil)
  if valid_613363 != nil:
    section.add "X-Amz-Signature", valid_613363
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_613364 = header.getOrDefault("x-amzn-iot-principal")
  valid_613364 = validateParameter(valid_613364, JString, required = true,
                                 default = nil)
  if valid_613364 != nil:
    section.add "x-amzn-iot-principal", valid_613364
  var valid_613365 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613365 = validateParameter(valid_613365, JString, required = false,
                                 default = nil)
  if valid_613365 != nil:
    section.add "X-Amz-Content-Sha256", valid_613365
  var valid_613366 = header.getOrDefault("X-Amz-Date")
  valid_613366 = validateParameter(valid_613366, JString, required = false,
                                 default = nil)
  if valid_613366 != nil:
    section.add "X-Amz-Date", valid_613366
  var valid_613367 = header.getOrDefault("X-Amz-Credential")
  valid_613367 = validateParameter(valid_613367, JString, required = false,
                                 default = nil)
  if valid_613367 != nil:
    section.add "X-Amz-Credential", valid_613367
  var valid_613368 = header.getOrDefault("X-Amz-Security-Token")
  valid_613368 = validateParameter(valid_613368, JString, required = false,
                                 default = nil)
  if valid_613368 != nil:
    section.add "X-Amz-Security-Token", valid_613368
  var valid_613369 = header.getOrDefault("X-Amz-Algorithm")
  valid_613369 = validateParameter(valid_613369, JString, required = false,
                                 default = nil)
  if valid_613369 != nil:
    section.add "X-Amz-Algorithm", valid_613369
  var valid_613370 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613370 = validateParameter(valid_613370, JString, required = false,
                                 default = nil)
  if valid_613370 != nil:
    section.add "X-Amz-SignedHeaders", valid_613370
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613371: Call_DetachPrincipalPolicy_613359; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ## 
  let valid = call_613371.validator(path, query, header, formData, body)
  let scheme = call_613371.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613371.url(scheme.get, call_613371.host, call_613371.base,
                         call_613371.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613371, url, valid)

proc call*(call_613372: Call_DetachPrincipalPolicy_613359; policyName: string): Recallable =
  ## detachPrincipalPolicy
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ##   policyName: string (required)
  ##             : The name of the policy to detach.
  var path_613373 = newJObject()
  add(path_613373, "policyName", newJString(policyName))
  result = call_613372.call(path_613373, nil, nil, nil, nil)

var detachPrincipalPolicy* = Call_DetachPrincipalPolicy_613359(
    name: "detachPrincipalPolicy", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/principal-policies/{policyName}#x-amzn-iot-principal",
    validator: validate_DetachPrincipalPolicy_613360, base: "/",
    url: url_DetachPrincipalPolicy_613361, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachSecurityProfile_613374 = ref object of OpenApiRestCall_612658
proc url_AttachSecurityProfile_613376(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"), (
        kind: ConstantSegment, value: "/targets#securityProfileTargetArn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachSecurityProfile_613375(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile that is attached.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_613377 = path.getOrDefault("securityProfileName")
  valid_613377 = validateParameter(valid_613377, JString, required = true,
                                 default = nil)
  if valid_613377 != nil:
    section.add "securityProfileName", valid_613377
  result.add "path", section
  ## parameters in `query` object:
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the target (thing group) to which the security profile is attached.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_613378 = query.getOrDefault("securityProfileTargetArn")
  valid_613378 = validateParameter(valid_613378, JString, required = true,
                                 default = nil)
  if valid_613378 != nil:
    section.add "securityProfileTargetArn", valid_613378
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613379 = header.getOrDefault("X-Amz-Signature")
  valid_613379 = validateParameter(valid_613379, JString, required = false,
                                 default = nil)
  if valid_613379 != nil:
    section.add "X-Amz-Signature", valid_613379
  var valid_613380 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613380 = validateParameter(valid_613380, JString, required = false,
                                 default = nil)
  if valid_613380 != nil:
    section.add "X-Amz-Content-Sha256", valid_613380
  var valid_613381 = header.getOrDefault("X-Amz-Date")
  valid_613381 = validateParameter(valid_613381, JString, required = false,
                                 default = nil)
  if valid_613381 != nil:
    section.add "X-Amz-Date", valid_613381
  var valid_613382 = header.getOrDefault("X-Amz-Credential")
  valid_613382 = validateParameter(valid_613382, JString, required = false,
                                 default = nil)
  if valid_613382 != nil:
    section.add "X-Amz-Credential", valid_613382
  var valid_613383 = header.getOrDefault("X-Amz-Security-Token")
  valid_613383 = validateParameter(valid_613383, JString, required = false,
                                 default = nil)
  if valid_613383 != nil:
    section.add "X-Amz-Security-Token", valid_613383
  var valid_613384 = header.getOrDefault("X-Amz-Algorithm")
  valid_613384 = validateParameter(valid_613384, JString, required = false,
                                 default = nil)
  if valid_613384 != nil:
    section.add "X-Amz-Algorithm", valid_613384
  var valid_613385 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613385 = validateParameter(valid_613385, JString, required = false,
                                 default = nil)
  if valid_613385 != nil:
    section.add "X-Amz-SignedHeaders", valid_613385
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613386: Call_AttachSecurityProfile_613374; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ## 
  let valid = call_613386.validator(path, query, header, formData, body)
  let scheme = call_613386.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613386.url(scheme.get, call_613386.host, call_613386.base,
                         call_613386.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613386, url, valid)

proc call*(call_613387: Call_AttachSecurityProfile_613374;
          securityProfileTargetArn: string; securityProfileName: string): Recallable =
  ## attachSecurityProfile
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the target (thing group) to which the security profile is attached.
  ##   securityProfileName: string (required)
  ##                      : The security profile that is attached.
  var path_613388 = newJObject()
  var query_613389 = newJObject()
  add(query_613389, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(path_613388, "securityProfileName", newJString(securityProfileName))
  result = call_613387.call(path_613388, query_613389, nil, nil, nil)

var attachSecurityProfile* = Call_AttachSecurityProfile_613374(
    name: "attachSecurityProfile", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}/targets#securityProfileTargetArn",
    validator: validate_AttachSecurityProfile_613375, base: "/",
    url: url_AttachSecurityProfile_613376, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachSecurityProfile_613390 = ref object of OpenApiRestCall_612658
proc url_DetachSecurityProfile_613392(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"), (
        kind: ConstantSegment, value: "/targets#securityProfileTargetArn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachSecurityProfile_613391(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile that is detached.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_613393 = path.getOrDefault("securityProfileName")
  valid_613393 = validateParameter(valid_613393, JString, required = true,
                                 default = nil)
  if valid_613393 != nil:
    section.add "securityProfileName", valid_613393
  result.add "path", section
  ## parameters in `query` object:
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the thing group from which the security profile is detached.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_613394 = query.getOrDefault("securityProfileTargetArn")
  valid_613394 = validateParameter(valid_613394, JString, required = true,
                                 default = nil)
  if valid_613394 != nil:
    section.add "securityProfileTargetArn", valid_613394
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613395 = header.getOrDefault("X-Amz-Signature")
  valid_613395 = validateParameter(valid_613395, JString, required = false,
                                 default = nil)
  if valid_613395 != nil:
    section.add "X-Amz-Signature", valid_613395
  var valid_613396 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613396 = validateParameter(valid_613396, JString, required = false,
                                 default = nil)
  if valid_613396 != nil:
    section.add "X-Amz-Content-Sha256", valid_613396
  var valid_613397 = header.getOrDefault("X-Amz-Date")
  valid_613397 = validateParameter(valid_613397, JString, required = false,
                                 default = nil)
  if valid_613397 != nil:
    section.add "X-Amz-Date", valid_613397
  var valid_613398 = header.getOrDefault("X-Amz-Credential")
  valid_613398 = validateParameter(valid_613398, JString, required = false,
                                 default = nil)
  if valid_613398 != nil:
    section.add "X-Amz-Credential", valid_613398
  var valid_613399 = header.getOrDefault("X-Amz-Security-Token")
  valid_613399 = validateParameter(valid_613399, JString, required = false,
                                 default = nil)
  if valid_613399 != nil:
    section.add "X-Amz-Security-Token", valid_613399
  var valid_613400 = header.getOrDefault("X-Amz-Algorithm")
  valid_613400 = validateParameter(valid_613400, JString, required = false,
                                 default = nil)
  if valid_613400 != nil:
    section.add "X-Amz-Algorithm", valid_613400
  var valid_613401 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613401 = validateParameter(valid_613401, JString, required = false,
                                 default = nil)
  if valid_613401 != nil:
    section.add "X-Amz-SignedHeaders", valid_613401
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613402: Call_DetachSecurityProfile_613390; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ## 
  let valid = call_613402.validator(path, query, header, formData, body)
  let scheme = call_613402.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613402.url(scheme.get, call_613402.host, call_613402.base,
                         call_613402.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613402, url, valid)

proc call*(call_613403: Call_DetachSecurityProfile_613390;
          securityProfileTargetArn: string; securityProfileName: string): Recallable =
  ## detachSecurityProfile
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the thing group from which the security profile is detached.
  ##   securityProfileName: string (required)
  ##                      : The security profile that is detached.
  var path_613404 = newJObject()
  var query_613405 = newJObject()
  add(query_613405, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(path_613404, "securityProfileName", newJString(securityProfileName))
  result = call_613403.call(path_613404, query_613405, nil, nil, nil)

var detachSecurityProfile* = Call_DetachSecurityProfile_613390(
    name: "detachSecurityProfile", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}/targets#securityProfileTargetArn",
    validator: validate_DetachSecurityProfile_613391, base: "/",
    url: url_DetachSecurityProfile_613392, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachThingPrincipal_613406 = ref object of OpenApiRestCall_612658
proc url_AttachThingPrincipal_613408(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals#x-amzn-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachThingPrincipal_613407(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_613409 = path.getOrDefault("thingName")
  valid_613409 = validateParameter(valid_613409, JString, required = true,
                                 default = nil)
  if valid_613409 != nil:
    section.add "thingName", valid_613409
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613410 = header.getOrDefault("X-Amz-Signature")
  valid_613410 = validateParameter(valid_613410, JString, required = false,
                                 default = nil)
  if valid_613410 != nil:
    section.add "X-Amz-Signature", valid_613410
  var valid_613411 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613411 = validateParameter(valid_613411, JString, required = false,
                                 default = nil)
  if valid_613411 != nil:
    section.add "X-Amz-Content-Sha256", valid_613411
  var valid_613412 = header.getOrDefault("X-Amz-Date")
  valid_613412 = validateParameter(valid_613412, JString, required = false,
                                 default = nil)
  if valid_613412 != nil:
    section.add "X-Amz-Date", valid_613412
  var valid_613413 = header.getOrDefault("X-Amz-Credential")
  valid_613413 = validateParameter(valid_613413, JString, required = false,
                                 default = nil)
  if valid_613413 != nil:
    section.add "X-Amz-Credential", valid_613413
  var valid_613414 = header.getOrDefault("X-Amz-Security-Token")
  valid_613414 = validateParameter(valid_613414, JString, required = false,
                                 default = nil)
  if valid_613414 != nil:
    section.add "X-Amz-Security-Token", valid_613414
  var valid_613415 = header.getOrDefault("X-Amz-Algorithm")
  valid_613415 = validateParameter(valid_613415, JString, required = false,
                                 default = nil)
  if valid_613415 != nil:
    section.add "X-Amz-Algorithm", valid_613415
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_613416 = header.getOrDefault("x-amzn-principal")
  valid_613416 = validateParameter(valid_613416, JString, required = true,
                                 default = nil)
  if valid_613416 != nil:
    section.add "x-amzn-principal", valid_613416
  var valid_613417 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613417 = validateParameter(valid_613417, JString, required = false,
                                 default = nil)
  if valid_613417 != nil:
    section.add "X-Amz-SignedHeaders", valid_613417
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613418: Call_AttachThingPrincipal_613406; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  let valid = call_613418.validator(path, query, header, formData, body)
  let scheme = call_613418.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613418.url(scheme.get, call_613418.host, call_613418.base,
                         call_613418.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613418, url, valid)

proc call*(call_613419: Call_AttachThingPrincipal_613406; thingName: string): Recallable =
  ## attachThingPrincipal
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_613420 = newJObject()
  add(path_613420, "thingName", newJString(thingName))
  result = call_613419.call(path_613420, nil, nil, nil, nil)

var attachThingPrincipal* = Call_AttachThingPrincipal_613406(
    name: "attachThingPrincipal", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/things/{thingName}/principals#x-amzn-principal",
    validator: validate_AttachThingPrincipal_613407, base: "/",
    url: url_AttachThingPrincipal_613408, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachThingPrincipal_613421 = ref object of OpenApiRestCall_612658
proc url_DetachThingPrincipal_613423(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals#x-amzn-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachThingPrincipal_613422(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_613424 = path.getOrDefault("thingName")
  valid_613424 = validateParameter(valid_613424, JString, required = true,
                                 default = nil)
  if valid_613424 != nil:
    section.add "thingName", valid_613424
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613425 = header.getOrDefault("X-Amz-Signature")
  valid_613425 = validateParameter(valid_613425, JString, required = false,
                                 default = nil)
  if valid_613425 != nil:
    section.add "X-Amz-Signature", valid_613425
  var valid_613426 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613426 = validateParameter(valid_613426, JString, required = false,
                                 default = nil)
  if valid_613426 != nil:
    section.add "X-Amz-Content-Sha256", valid_613426
  var valid_613427 = header.getOrDefault("X-Amz-Date")
  valid_613427 = validateParameter(valid_613427, JString, required = false,
                                 default = nil)
  if valid_613427 != nil:
    section.add "X-Amz-Date", valid_613427
  var valid_613428 = header.getOrDefault("X-Amz-Credential")
  valid_613428 = validateParameter(valid_613428, JString, required = false,
                                 default = nil)
  if valid_613428 != nil:
    section.add "X-Amz-Credential", valid_613428
  var valid_613429 = header.getOrDefault("X-Amz-Security-Token")
  valid_613429 = validateParameter(valid_613429, JString, required = false,
                                 default = nil)
  if valid_613429 != nil:
    section.add "X-Amz-Security-Token", valid_613429
  var valid_613430 = header.getOrDefault("X-Amz-Algorithm")
  valid_613430 = validateParameter(valid_613430, JString, required = false,
                                 default = nil)
  if valid_613430 != nil:
    section.add "X-Amz-Algorithm", valid_613430
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_613431 = header.getOrDefault("x-amzn-principal")
  valid_613431 = validateParameter(valid_613431, JString, required = true,
                                 default = nil)
  if valid_613431 != nil:
    section.add "x-amzn-principal", valid_613431
  var valid_613432 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613432 = validateParameter(valid_613432, JString, required = false,
                                 default = nil)
  if valid_613432 != nil:
    section.add "X-Amz-SignedHeaders", valid_613432
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613433: Call_DetachThingPrincipal_613421; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ## 
  let valid = call_613433.validator(path, query, header, formData, body)
  let scheme = call_613433.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613433.url(scheme.get, call_613433.host, call_613433.base,
                         call_613433.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613433, url, valid)

proc call*(call_613434: Call_DetachThingPrincipal_613421; thingName: string): Recallable =
  ## detachThingPrincipal
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_613435 = newJObject()
  add(path_613435, "thingName", newJString(thingName))
  result = call_613434.call(path_613435, nil, nil, nil, nil)

var detachThingPrincipal* = Call_DetachThingPrincipal_613421(
    name: "detachThingPrincipal", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/things/{thingName}/principals#x-amzn-principal",
    validator: validate_DetachThingPrincipal_613422, base: "/",
    url: url_DetachThingPrincipal_613423, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelAuditMitigationActionsTask_613436 = ref object of OpenApiRestCall_612658
proc url_CancelAuditMitigationActionsTask_613438(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelAuditMitigationActionsTask_613437(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The unique identifier for the task that you want to cancel. 
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_613439 = path.getOrDefault("taskId")
  valid_613439 = validateParameter(valid_613439, JString, required = true,
                                 default = nil)
  if valid_613439 != nil:
    section.add "taskId", valid_613439
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613440 = header.getOrDefault("X-Amz-Signature")
  valid_613440 = validateParameter(valid_613440, JString, required = false,
                                 default = nil)
  if valid_613440 != nil:
    section.add "X-Amz-Signature", valid_613440
  var valid_613441 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613441 = validateParameter(valid_613441, JString, required = false,
                                 default = nil)
  if valid_613441 != nil:
    section.add "X-Amz-Content-Sha256", valid_613441
  var valid_613442 = header.getOrDefault("X-Amz-Date")
  valid_613442 = validateParameter(valid_613442, JString, required = false,
                                 default = nil)
  if valid_613442 != nil:
    section.add "X-Amz-Date", valid_613442
  var valid_613443 = header.getOrDefault("X-Amz-Credential")
  valid_613443 = validateParameter(valid_613443, JString, required = false,
                                 default = nil)
  if valid_613443 != nil:
    section.add "X-Amz-Credential", valid_613443
  var valid_613444 = header.getOrDefault("X-Amz-Security-Token")
  valid_613444 = validateParameter(valid_613444, JString, required = false,
                                 default = nil)
  if valid_613444 != nil:
    section.add "X-Amz-Security-Token", valid_613444
  var valid_613445 = header.getOrDefault("X-Amz-Algorithm")
  valid_613445 = validateParameter(valid_613445, JString, required = false,
                                 default = nil)
  if valid_613445 != nil:
    section.add "X-Amz-Algorithm", valid_613445
  var valid_613446 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613446 = validateParameter(valid_613446, JString, required = false,
                                 default = nil)
  if valid_613446 != nil:
    section.add "X-Amz-SignedHeaders", valid_613446
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613447: Call_CancelAuditMitigationActionsTask_613436;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ## 
  let valid = call_613447.validator(path, query, header, formData, body)
  let scheme = call_613447.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613447.url(scheme.get, call_613447.host, call_613447.base,
                         call_613447.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613447, url, valid)

proc call*(call_613448: Call_CancelAuditMitigationActionsTask_613436;
          taskId: string): Recallable =
  ## cancelAuditMitigationActionsTask
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ##   taskId: string (required)
  ##         : The unique identifier for the task that you want to cancel. 
  var path_613449 = newJObject()
  add(path_613449, "taskId", newJString(taskId))
  result = call_613448.call(path_613449, nil, nil, nil, nil)

var cancelAuditMitigationActionsTask* = Call_CancelAuditMitigationActionsTask_613436(
    name: "cancelAuditMitigationActionsTask", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/tasks/{taskId}/cancel",
    validator: validate_CancelAuditMitigationActionsTask_613437, base: "/",
    url: url_CancelAuditMitigationActionsTask_613438,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelAuditTask_613450 = ref object of OpenApiRestCall_612658
proc url_CancelAuditTask_613452(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelAuditTask_613451(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_613453 = path.getOrDefault("taskId")
  valid_613453 = validateParameter(valid_613453, JString, required = true,
                                 default = nil)
  if valid_613453 != nil:
    section.add "taskId", valid_613453
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613454 = header.getOrDefault("X-Amz-Signature")
  valid_613454 = validateParameter(valid_613454, JString, required = false,
                                 default = nil)
  if valid_613454 != nil:
    section.add "X-Amz-Signature", valid_613454
  var valid_613455 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613455 = validateParameter(valid_613455, JString, required = false,
                                 default = nil)
  if valid_613455 != nil:
    section.add "X-Amz-Content-Sha256", valid_613455
  var valid_613456 = header.getOrDefault("X-Amz-Date")
  valid_613456 = validateParameter(valid_613456, JString, required = false,
                                 default = nil)
  if valid_613456 != nil:
    section.add "X-Amz-Date", valid_613456
  var valid_613457 = header.getOrDefault("X-Amz-Credential")
  valid_613457 = validateParameter(valid_613457, JString, required = false,
                                 default = nil)
  if valid_613457 != nil:
    section.add "X-Amz-Credential", valid_613457
  var valid_613458 = header.getOrDefault("X-Amz-Security-Token")
  valid_613458 = validateParameter(valid_613458, JString, required = false,
                                 default = nil)
  if valid_613458 != nil:
    section.add "X-Amz-Security-Token", valid_613458
  var valid_613459 = header.getOrDefault("X-Amz-Algorithm")
  valid_613459 = validateParameter(valid_613459, JString, required = false,
                                 default = nil)
  if valid_613459 != nil:
    section.add "X-Amz-Algorithm", valid_613459
  var valid_613460 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613460 = validateParameter(valid_613460, JString, required = false,
                                 default = nil)
  if valid_613460 != nil:
    section.add "X-Amz-SignedHeaders", valid_613460
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613461: Call_CancelAuditTask_613450; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ## 
  let valid = call_613461.validator(path, query, header, formData, body)
  let scheme = call_613461.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613461.url(scheme.get, call_613461.host, call_613461.base,
                         call_613461.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613461, url, valid)

proc call*(call_613462: Call_CancelAuditTask_613450; taskId: string): Recallable =
  ## cancelAuditTask
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ##   taskId: string (required)
  ##         : The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
  var path_613463 = newJObject()
  add(path_613463, "taskId", newJString(taskId))
  result = call_613462.call(path_613463, nil, nil, nil, nil)

var cancelAuditTask* = Call_CancelAuditTask_613450(name: "cancelAuditTask",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/audit/tasks/{taskId}/cancel", validator: validate_CancelAuditTask_613451,
    base: "/", url: url_CancelAuditTask_613452, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelCertificateTransfer_613464 = ref object of OpenApiRestCall_612658
proc url_CancelCertificateTransfer_613466(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cancel-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelCertificateTransfer_613465(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_613467 = path.getOrDefault("certificateId")
  valid_613467 = validateParameter(valid_613467, JString, required = true,
                                 default = nil)
  if valid_613467 != nil:
    section.add "certificateId", valid_613467
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613468 = header.getOrDefault("X-Amz-Signature")
  valid_613468 = validateParameter(valid_613468, JString, required = false,
                                 default = nil)
  if valid_613468 != nil:
    section.add "X-Amz-Signature", valid_613468
  var valid_613469 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613469 = validateParameter(valid_613469, JString, required = false,
                                 default = nil)
  if valid_613469 != nil:
    section.add "X-Amz-Content-Sha256", valid_613469
  var valid_613470 = header.getOrDefault("X-Amz-Date")
  valid_613470 = validateParameter(valid_613470, JString, required = false,
                                 default = nil)
  if valid_613470 != nil:
    section.add "X-Amz-Date", valid_613470
  var valid_613471 = header.getOrDefault("X-Amz-Credential")
  valid_613471 = validateParameter(valid_613471, JString, required = false,
                                 default = nil)
  if valid_613471 != nil:
    section.add "X-Amz-Credential", valid_613471
  var valid_613472 = header.getOrDefault("X-Amz-Security-Token")
  valid_613472 = validateParameter(valid_613472, JString, required = false,
                                 default = nil)
  if valid_613472 != nil:
    section.add "X-Amz-Security-Token", valid_613472
  var valid_613473 = header.getOrDefault("X-Amz-Algorithm")
  valid_613473 = validateParameter(valid_613473, JString, required = false,
                                 default = nil)
  if valid_613473 != nil:
    section.add "X-Amz-Algorithm", valid_613473
  var valid_613474 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613474 = validateParameter(valid_613474, JString, required = false,
                                 default = nil)
  if valid_613474 != nil:
    section.add "X-Amz-SignedHeaders", valid_613474
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613475: Call_CancelCertificateTransfer_613464; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ## 
  let valid = call_613475.validator(path, query, header, formData, body)
  let scheme = call_613475.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613475.url(scheme.get, call_613475.host, call_613475.base,
                         call_613475.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613475, url, valid)

proc call*(call_613476: Call_CancelCertificateTransfer_613464;
          certificateId: string): Recallable =
  ## cancelCertificateTransfer
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_613477 = newJObject()
  add(path_613477, "certificateId", newJString(certificateId))
  result = call_613476.call(path_613477, nil, nil, nil, nil)

var cancelCertificateTransfer* = Call_CancelCertificateTransfer_613464(
    name: "cancelCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/cancel-certificate-transfer/{certificateId}",
    validator: validate_CancelCertificateTransfer_613465, base: "/",
    url: url_CancelCertificateTransfer_613466,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelJob_613478 = ref object of OpenApiRestCall_612658
proc url_CancelJob_613480(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelJob_613479(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_613481 = path.getOrDefault("jobId")
  valid_613481 = validateParameter(valid_613481, JString, required = true,
                                 default = nil)
  if valid_613481 != nil:
    section.add "jobId", valid_613481
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
  section = newJObject()
  var valid_613482 = query.getOrDefault("force")
  valid_613482 = validateParameter(valid_613482, JBool, required = false, default = nil)
  if valid_613482 != nil:
    section.add "force", valid_613482
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613483 = header.getOrDefault("X-Amz-Signature")
  valid_613483 = validateParameter(valid_613483, JString, required = false,
                                 default = nil)
  if valid_613483 != nil:
    section.add "X-Amz-Signature", valid_613483
  var valid_613484 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613484 = validateParameter(valid_613484, JString, required = false,
                                 default = nil)
  if valid_613484 != nil:
    section.add "X-Amz-Content-Sha256", valid_613484
  var valid_613485 = header.getOrDefault("X-Amz-Date")
  valid_613485 = validateParameter(valid_613485, JString, required = false,
                                 default = nil)
  if valid_613485 != nil:
    section.add "X-Amz-Date", valid_613485
  var valid_613486 = header.getOrDefault("X-Amz-Credential")
  valid_613486 = validateParameter(valid_613486, JString, required = false,
                                 default = nil)
  if valid_613486 != nil:
    section.add "X-Amz-Credential", valid_613486
  var valid_613487 = header.getOrDefault("X-Amz-Security-Token")
  valid_613487 = validateParameter(valid_613487, JString, required = false,
                                 default = nil)
  if valid_613487 != nil:
    section.add "X-Amz-Security-Token", valid_613487
  var valid_613488 = header.getOrDefault("X-Amz-Algorithm")
  valid_613488 = validateParameter(valid_613488, JString, required = false,
                                 default = nil)
  if valid_613488 != nil:
    section.add "X-Amz-Algorithm", valid_613488
  var valid_613489 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613489 = validateParameter(valid_613489, JString, required = false,
                                 default = nil)
  if valid_613489 != nil:
    section.add "X-Amz-SignedHeaders", valid_613489
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613491: Call_CancelJob_613478; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a job.
  ## 
  let valid = call_613491.validator(path, query, header, formData, body)
  let scheme = call_613491.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613491.url(scheme.get, call_613491.host, call_613491.base,
                         call_613491.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613491, url, valid)

proc call*(call_613492: Call_CancelJob_613478; jobId: string; body: JsonNode;
          force: bool = false): Recallable =
  ## cancelJob
  ## Cancels a job.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   force: bool
  ##        : <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
  ##   body: JObject (required)
  var path_613493 = newJObject()
  var query_613494 = newJObject()
  var body_613495 = newJObject()
  add(path_613493, "jobId", newJString(jobId))
  add(query_613494, "force", newJBool(force))
  if body != nil:
    body_613495 = body
  result = call_613492.call(path_613493, query_613494, nil, nil, body_613495)

var cancelJob* = Call_CancelJob_613478(name: "cancelJob", meth: HttpMethod.HttpPut,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}/cancel",
                                    validator: validate_CancelJob_613479,
                                    base: "/", url: url_CancelJob_613480,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelJobExecution_613496 = ref object of OpenApiRestCall_612658
proc url_CancelJobExecution_613498(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelJobExecution_613497(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Cancels the execution of a job for a given thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The ID of the job to be canceled.
  ##   thingName: JString (required)
  ##            : The name of the thing whose execution of the job will be canceled.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_613499 = path.getOrDefault("jobId")
  valid_613499 = validateParameter(valid_613499, JString, required = true,
                                 default = nil)
  if valid_613499 != nil:
    section.add "jobId", valid_613499
  var valid_613500 = path.getOrDefault("thingName")
  valid_613500 = validateParameter(valid_613500, JString, required = true,
                                 default = nil)
  if valid_613500 != nil:
    section.add "thingName", valid_613500
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
  section = newJObject()
  var valid_613501 = query.getOrDefault("force")
  valid_613501 = validateParameter(valid_613501, JBool, required = false, default = nil)
  if valid_613501 != nil:
    section.add "force", valid_613501
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613502 = header.getOrDefault("X-Amz-Signature")
  valid_613502 = validateParameter(valid_613502, JString, required = false,
                                 default = nil)
  if valid_613502 != nil:
    section.add "X-Amz-Signature", valid_613502
  var valid_613503 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613503 = validateParameter(valid_613503, JString, required = false,
                                 default = nil)
  if valid_613503 != nil:
    section.add "X-Amz-Content-Sha256", valid_613503
  var valid_613504 = header.getOrDefault("X-Amz-Date")
  valid_613504 = validateParameter(valid_613504, JString, required = false,
                                 default = nil)
  if valid_613504 != nil:
    section.add "X-Amz-Date", valid_613504
  var valid_613505 = header.getOrDefault("X-Amz-Credential")
  valid_613505 = validateParameter(valid_613505, JString, required = false,
                                 default = nil)
  if valid_613505 != nil:
    section.add "X-Amz-Credential", valid_613505
  var valid_613506 = header.getOrDefault("X-Amz-Security-Token")
  valid_613506 = validateParameter(valid_613506, JString, required = false,
                                 default = nil)
  if valid_613506 != nil:
    section.add "X-Amz-Security-Token", valid_613506
  var valid_613507 = header.getOrDefault("X-Amz-Algorithm")
  valid_613507 = validateParameter(valid_613507, JString, required = false,
                                 default = nil)
  if valid_613507 != nil:
    section.add "X-Amz-Algorithm", valid_613507
  var valid_613508 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613508 = validateParameter(valid_613508, JString, required = false,
                                 default = nil)
  if valid_613508 != nil:
    section.add "X-Amz-SignedHeaders", valid_613508
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613510: Call_CancelJobExecution_613496; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels the execution of a job for a given thing.
  ## 
  let valid = call_613510.validator(path, query, header, formData, body)
  let scheme = call_613510.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613510.url(scheme.get, call_613510.host, call_613510.base,
                         call_613510.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613510, url, valid)

proc call*(call_613511: Call_CancelJobExecution_613496; jobId: string;
          thingName: string; body: JsonNode; force: bool = false): Recallable =
  ## cancelJobExecution
  ## Cancels the execution of a job for a given thing.
  ##   jobId: string (required)
  ##        : The ID of the job to be canceled.
  ##   thingName: string (required)
  ##            : The name of the thing whose execution of the job will be canceled.
  ##   force: bool
  ##        : <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
  ##   body: JObject (required)
  var path_613512 = newJObject()
  var query_613513 = newJObject()
  var body_613514 = newJObject()
  add(path_613512, "jobId", newJString(jobId))
  add(path_613512, "thingName", newJString(thingName))
  add(query_613513, "force", newJBool(force))
  if body != nil:
    body_613514 = body
  result = call_613511.call(path_613512, query_613513, nil, nil, body_613514)

var cancelJobExecution* = Call_CancelJobExecution_613496(
    name: "cancelJobExecution", meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/things/{thingName}/jobs/{jobId}/cancel",
    validator: validate_CancelJobExecution_613497, base: "/",
    url: url_CancelJobExecution_613498, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetDefaultAuthorizer_613527 = ref object of OpenApiRestCall_612658
proc url_SetDefaultAuthorizer_613529(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetDefaultAuthorizer_613528(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613530 = header.getOrDefault("X-Amz-Signature")
  valid_613530 = validateParameter(valid_613530, JString, required = false,
                                 default = nil)
  if valid_613530 != nil:
    section.add "X-Amz-Signature", valid_613530
  var valid_613531 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613531 = validateParameter(valid_613531, JString, required = false,
                                 default = nil)
  if valid_613531 != nil:
    section.add "X-Amz-Content-Sha256", valid_613531
  var valid_613532 = header.getOrDefault("X-Amz-Date")
  valid_613532 = validateParameter(valid_613532, JString, required = false,
                                 default = nil)
  if valid_613532 != nil:
    section.add "X-Amz-Date", valid_613532
  var valid_613533 = header.getOrDefault("X-Amz-Credential")
  valid_613533 = validateParameter(valid_613533, JString, required = false,
                                 default = nil)
  if valid_613533 != nil:
    section.add "X-Amz-Credential", valid_613533
  var valid_613534 = header.getOrDefault("X-Amz-Security-Token")
  valid_613534 = validateParameter(valid_613534, JString, required = false,
                                 default = nil)
  if valid_613534 != nil:
    section.add "X-Amz-Security-Token", valid_613534
  var valid_613535 = header.getOrDefault("X-Amz-Algorithm")
  valid_613535 = validateParameter(valid_613535, JString, required = false,
                                 default = nil)
  if valid_613535 != nil:
    section.add "X-Amz-Algorithm", valid_613535
  var valid_613536 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613536 = validateParameter(valid_613536, JString, required = false,
                                 default = nil)
  if valid_613536 != nil:
    section.add "X-Amz-SignedHeaders", valid_613536
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613538: Call_SetDefaultAuthorizer_613527; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ## 
  let valid = call_613538.validator(path, query, header, formData, body)
  let scheme = call_613538.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613538.url(scheme.get, call_613538.host, call_613538.base,
                         call_613538.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613538, url, valid)

proc call*(call_613539: Call_SetDefaultAuthorizer_613527; body: JsonNode): Recallable =
  ## setDefaultAuthorizer
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ##   body: JObject (required)
  var body_613540 = newJObject()
  if body != nil:
    body_613540 = body
  result = call_613539.call(nil, nil, nil, nil, body_613540)

var setDefaultAuthorizer* = Call_SetDefaultAuthorizer_613527(
    name: "setDefaultAuthorizer", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_SetDefaultAuthorizer_613528, base: "/",
    url: url_SetDefaultAuthorizer_613529, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeDefaultAuthorizer_613515 = ref object of OpenApiRestCall_612658
proc url_DescribeDefaultAuthorizer_613517(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeDefaultAuthorizer_613516(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes the default authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613518 = header.getOrDefault("X-Amz-Signature")
  valid_613518 = validateParameter(valid_613518, JString, required = false,
                                 default = nil)
  if valid_613518 != nil:
    section.add "X-Amz-Signature", valid_613518
  var valid_613519 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613519 = validateParameter(valid_613519, JString, required = false,
                                 default = nil)
  if valid_613519 != nil:
    section.add "X-Amz-Content-Sha256", valid_613519
  var valid_613520 = header.getOrDefault("X-Amz-Date")
  valid_613520 = validateParameter(valid_613520, JString, required = false,
                                 default = nil)
  if valid_613520 != nil:
    section.add "X-Amz-Date", valid_613520
  var valid_613521 = header.getOrDefault("X-Amz-Credential")
  valid_613521 = validateParameter(valid_613521, JString, required = false,
                                 default = nil)
  if valid_613521 != nil:
    section.add "X-Amz-Credential", valid_613521
  var valid_613522 = header.getOrDefault("X-Amz-Security-Token")
  valid_613522 = validateParameter(valid_613522, JString, required = false,
                                 default = nil)
  if valid_613522 != nil:
    section.add "X-Amz-Security-Token", valid_613522
  var valid_613523 = header.getOrDefault("X-Amz-Algorithm")
  valid_613523 = validateParameter(valid_613523, JString, required = false,
                                 default = nil)
  if valid_613523 != nil:
    section.add "X-Amz-Algorithm", valid_613523
  var valid_613524 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613524 = validateParameter(valid_613524, JString, required = false,
                                 default = nil)
  if valid_613524 != nil:
    section.add "X-Amz-SignedHeaders", valid_613524
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613525: Call_DescribeDefaultAuthorizer_613515; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes the default authorizer.
  ## 
  let valid = call_613525.validator(path, query, header, formData, body)
  let scheme = call_613525.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613525.url(scheme.get, call_613525.host, call_613525.base,
                         call_613525.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613525, url, valid)

proc call*(call_613526: Call_DescribeDefaultAuthorizer_613515): Recallable =
  ## describeDefaultAuthorizer
  ## Describes the default authorizer.
  result = call_613526.call(nil, nil, nil, nil, nil)

var describeDefaultAuthorizer* = Call_DescribeDefaultAuthorizer_613515(
    name: "describeDefaultAuthorizer", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_DescribeDefaultAuthorizer_613516, base: "/",
    url: url_DescribeDefaultAuthorizer_613517,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ClearDefaultAuthorizer_613541 = ref object of OpenApiRestCall_612658
proc url_ClearDefaultAuthorizer_613543(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ClearDefaultAuthorizer_613542(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Clears the default authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613544 = header.getOrDefault("X-Amz-Signature")
  valid_613544 = validateParameter(valid_613544, JString, required = false,
                                 default = nil)
  if valid_613544 != nil:
    section.add "X-Amz-Signature", valid_613544
  var valid_613545 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613545 = validateParameter(valid_613545, JString, required = false,
                                 default = nil)
  if valid_613545 != nil:
    section.add "X-Amz-Content-Sha256", valid_613545
  var valid_613546 = header.getOrDefault("X-Amz-Date")
  valid_613546 = validateParameter(valid_613546, JString, required = false,
                                 default = nil)
  if valid_613546 != nil:
    section.add "X-Amz-Date", valid_613546
  var valid_613547 = header.getOrDefault("X-Amz-Credential")
  valid_613547 = validateParameter(valid_613547, JString, required = false,
                                 default = nil)
  if valid_613547 != nil:
    section.add "X-Amz-Credential", valid_613547
  var valid_613548 = header.getOrDefault("X-Amz-Security-Token")
  valid_613548 = validateParameter(valid_613548, JString, required = false,
                                 default = nil)
  if valid_613548 != nil:
    section.add "X-Amz-Security-Token", valid_613548
  var valid_613549 = header.getOrDefault("X-Amz-Algorithm")
  valid_613549 = validateParameter(valid_613549, JString, required = false,
                                 default = nil)
  if valid_613549 != nil:
    section.add "X-Amz-Algorithm", valid_613549
  var valid_613550 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613550 = validateParameter(valid_613550, JString, required = false,
                                 default = nil)
  if valid_613550 != nil:
    section.add "X-Amz-SignedHeaders", valid_613550
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613551: Call_ClearDefaultAuthorizer_613541; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Clears the default authorizer.
  ## 
  let valid = call_613551.validator(path, query, header, formData, body)
  let scheme = call_613551.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613551.url(scheme.get, call_613551.host, call_613551.base,
                         call_613551.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613551, url, valid)

proc call*(call_613552: Call_ClearDefaultAuthorizer_613541): Recallable =
  ## clearDefaultAuthorizer
  ## Clears the default authorizer.
  result = call_613552.call(nil, nil, nil, nil, nil)

var clearDefaultAuthorizer* = Call_ClearDefaultAuthorizer_613541(
    name: "clearDefaultAuthorizer", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_ClearDefaultAuthorizer_613542, base: "/",
    url: url_ClearDefaultAuthorizer_613543, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ConfirmTopicRuleDestination_613553 = ref object of OpenApiRestCall_612658
proc url_ConfirmTopicRuleDestination_613555(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "confirmationToken" in path,
        "`confirmationToken` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/confirmdestination/"),
               (kind: VariableSegment, value: "confirmationToken")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ConfirmTopicRuleDestination_613554(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Confirms a topic rule destination. When you create a rule requiring a destination, AWS IoT sends a confirmation message to the endpoint or base address you specify. The message includes a token which you pass back when calling <code>ConfirmTopicRuleDestination</code> to confirm that you own or have access to the endpoint.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   confirmationToken: JString (required)
  ##                    : The token used to confirm ownership or access to the topic rule confirmation URL.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `confirmationToken` field"
  var valid_613556 = path.getOrDefault("confirmationToken")
  valid_613556 = validateParameter(valid_613556, JString, required = true,
                                 default = nil)
  if valid_613556 != nil:
    section.add "confirmationToken", valid_613556
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613557 = header.getOrDefault("X-Amz-Signature")
  valid_613557 = validateParameter(valid_613557, JString, required = false,
                                 default = nil)
  if valid_613557 != nil:
    section.add "X-Amz-Signature", valid_613557
  var valid_613558 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613558 = validateParameter(valid_613558, JString, required = false,
                                 default = nil)
  if valid_613558 != nil:
    section.add "X-Amz-Content-Sha256", valid_613558
  var valid_613559 = header.getOrDefault("X-Amz-Date")
  valid_613559 = validateParameter(valid_613559, JString, required = false,
                                 default = nil)
  if valid_613559 != nil:
    section.add "X-Amz-Date", valid_613559
  var valid_613560 = header.getOrDefault("X-Amz-Credential")
  valid_613560 = validateParameter(valid_613560, JString, required = false,
                                 default = nil)
  if valid_613560 != nil:
    section.add "X-Amz-Credential", valid_613560
  var valid_613561 = header.getOrDefault("X-Amz-Security-Token")
  valid_613561 = validateParameter(valid_613561, JString, required = false,
                                 default = nil)
  if valid_613561 != nil:
    section.add "X-Amz-Security-Token", valid_613561
  var valid_613562 = header.getOrDefault("X-Amz-Algorithm")
  valid_613562 = validateParameter(valid_613562, JString, required = false,
                                 default = nil)
  if valid_613562 != nil:
    section.add "X-Amz-Algorithm", valid_613562
  var valid_613563 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613563 = validateParameter(valid_613563, JString, required = false,
                                 default = nil)
  if valid_613563 != nil:
    section.add "X-Amz-SignedHeaders", valid_613563
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613564: Call_ConfirmTopicRuleDestination_613553; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Confirms a topic rule destination. When you create a rule requiring a destination, AWS IoT sends a confirmation message to the endpoint or base address you specify. The message includes a token which you pass back when calling <code>ConfirmTopicRuleDestination</code> to confirm that you own or have access to the endpoint.
  ## 
  let valid = call_613564.validator(path, query, header, formData, body)
  let scheme = call_613564.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613564.url(scheme.get, call_613564.host, call_613564.base,
                         call_613564.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613564, url, valid)

proc call*(call_613565: Call_ConfirmTopicRuleDestination_613553;
          confirmationToken: string): Recallable =
  ## confirmTopicRuleDestination
  ## Confirms a topic rule destination. When you create a rule requiring a destination, AWS IoT sends a confirmation message to the endpoint or base address you specify. The message includes a token which you pass back when calling <code>ConfirmTopicRuleDestination</code> to confirm that you own or have access to the endpoint.
  ##   confirmationToken: string (required)
  ##                    : The token used to confirm ownership or access to the topic rule confirmation URL.
  var path_613566 = newJObject()
  add(path_613566, "confirmationToken", newJString(confirmationToken))
  result = call_613565.call(path_613566, nil, nil, nil, nil)

var confirmTopicRuleDestination* = Call_ConfirmTopicRuleDestination_613553(
    name: "confirmTopicRuleDestination", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/confirmdestination/{confirmationToken}",
    validator: validate_ConfirmTopicRuleDestination_613554, base: "/",
    url: url_ConfirmTopicRuleDestination_613555,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateAuthorizer_613581 = ref object of OpenApiRestCall_612658
proc url_UpdateAuthorizer_613583(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateAuthorizer_613582(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Updates an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_613584 = path.getOrDefault("authorizerName")
  valid_613584 = validateParameter(valid_613584, JString, required = true,
                                 default = nil)
  if valid_613584 != nil:
    section.add "authorizerName", valid_613584
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613585 = header.getOrDefault("X-Amz-Signature")
  valid_613585 = validateParameter(valid_613585, JString, required = false,
                                 default = nil)
  if valid_613585 != nil:
    section.add "X-Amz-Signature", valid_613585
  var valid_613586 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613586 = validateParameter(valid_613586, JString, required = false,
                                 default = nil)
  if valid_613586 != nil:
    section.add "X-Amz-Content-Sha256", valid_613586
  var valid_613587 = header.getOrDefault("X-Amz-Date")
  valid_613587 = validateParameter(valid_613587, JString, required = false,
                                 default = nil)
  if valid_613587 != nil:
    section.add "X-Amz-Date", valid_613587
  var valid_613588 = header.getOrDefault("X-Amz-Credential")
  valid_613588 = validateParameter(valid_613588, JString, required = false,
                                 default = nil)
  if valid_613588 != nil:
    section.add "X-Amz-Credential", valid_613588
  var valid_613589 = header.getOrDefault("X-Amz-Security-Token")
  valid_613589 = validateParameter(valid_613589, JString, required = false,
                                 default = nil)
  if valid_613589 != nil:
    section.add "X-Amz-Security-Token", valid_613589
  var valid_613590 = header.getOrDefault("X-Amz-Algorithm")
  valid_613590 = validateParameter(valid_613590, JString, required = false,
                                 default = nil)
  if valid_613590 != nil:
    section.add "X-Amz-Algorithm", valid_613590
  var valid_613591 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613591 = validateParameter(valid_613591, JString, required = false,
                                 default = nil)
  if valid_613591 != nil:
    section.add "X-Amz-SignedHeaders", valid_613591
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613593: Call_UpdateAuthorizer_613581; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an authorizer.
  ## 
  let valid = call_613593.validator(path, query, header, formData, body)
  let scheme = call_613593.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613593.url(scheme.get, call_613593.host, call_613593.base,
                         call_613593.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613593, url, valid)

proc call*(call_613594: Call_UpdateAuthorizer_613581; authorizerName: string;
          body: JsonNode): Recallable =
  ## updateAuthorizer
  ## Updates an authorizer.
  ##   authorizerName: string (required)
  ##                 : The authorizer name.
  ##   body: JObject (required)
  var path_613595 = newJObject()
  var body_613596 = newJObject()
  add(path_613595, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_613596 = body
  result = call_613594.call(path_613595, nil, nil, nil, body_613596)

var updateAuthorizer* = Call_UpdateAuthorizer_613581(name: "updateAuthorizer",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_UpdateAuthorizer_613582,
    base: "/", url: url_UpdateAuthorizer_613583,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateAuthorizer_613597 = ref object of OpenApiRestCall_612658
proc url_CreateAuthorizer_613599(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateAuthorizer_613598(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Creates an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_613600 = path.getOrDefault("authorizerName")
  valid_613600 = validateParameter(valid_613600, JString, required = true,
                                 default = nil)
  if valid_613600 != nil:
    section.add "authorizerName", valid_613600
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613601 = header.getOrDefault("X-Amz-Signature")
  valid_613601 = validateParameter(valid_613601, JString, required = false,
                                 default = nil)
  if valid_613601 != nil:
    section.add "X-Amz-Signature", valid_613601
  var valid_613602 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613602 = validateParameter(valid_613602, JString, required = false,
                                 default = nil)
  if valid_613602 != nil:
    section.add "X-Amz-Content-Sha256", valid_613602
  var valid_613603 = header.getOrDefault("X-Amz-Date")
  valid_613603 = validateParameter(valid_613603, JString, required = false,
                                 default = nil)
  if valid_613603 != nil:
    section.add "X-Amz-Date", valid_613603
  var valid_613604 = header.getOrDefault("X-Amz-Credential")
  valid_613604 = validateParameter(valid_613604, JString, required = false,
                                 default = nil)
  if valid_613604 != nil:
    section.add "X-Amz-Credential", valid_613604
  var valid_613605 = header.getOrDefault("X-Amz-Security-Token")
  valid_613605 = validateParameter(valid_613605, JString, required = false,
                                 default = nil)
  if valid_613605 != nil:
    section.add "X-Amz-Security-Token", valid_613605
  var valid_613606 = header.getOrDefault("X-Amz-Algorithm")
  valid_613606 = validateParameter(valid_613606, JString, required = false,
                                 default = nil)
  if valid_613606 != nil:
    section.add "X-Amz-Algorithm", valid_613606
  var valid_613607 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613607 = validateParameter(valid_613607, JString, required = false,
                                 default = nil)
  if valid_613607 != nil:
    section.add "X-Amz-SignedHeaders", valid_613607
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613609: Call_CreateAuthorizer_613597; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates an authorizer.
  ## 
  let valid = call_613609.validator(path, query, header, formData, body)
  let scheme = call_613609.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613609.url(scheme.get, call_613609.host, call_613609.base,
                         call_613609.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613609, url, valid)

proc call*(call_613610: Call_CreateAuthorizer_613597; authorizerName: string;
          body: JsonNode): Recallable =
  ## createAuthorizer
  ## Creates an authorizer.
  ##   authorizerName: string (required)
  ##                 : The authorizer name.
  ##   body: JObject (required)
  var path_613611 = newJObject()
  var body_613612 = newJObject()
  add(path_613611, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_613612 = body
  result = call_613610.call(path_613611, nil, nil, nil, body_613612)

var createAuthorizer* = Call_CreateAuthorizer_613597(name: "createAuthorizer",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_CreateAuthorizer_613598,
    base: "/", url: url_CreateAuthorizer_613599,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuthorizer_613567 = ref object of OpenApiRestCall_612658
proc url_DescribeAuthorizer_613569(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuthorizer_613568(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Describes an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The name of the authorizer to describe.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_613570 = path.getOrDefault("authorizerName")
  valid_613570 = validateParameter(valid_613570, JString, required = true,
                                 default = nil)
  if valid_613570 != nil:
    section.add "authorizerName", valid_613570
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613571 = header.getOrDefault("X-Amz-Signature")
  valid_613571 = validateParameter(valid_613571, JString, required = false,
                                 default = nil)
  if valid_613571 != nil:
    section.add "X-Amz-Signature", valid_613571
  var valid_613572 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613572 = validateParameter(valid_613572, JString, required = false,
                                 default = nil)
  if valid_613572 != nil:
    section.add "X-Amz-Content-Sha256", valid_613572
  var valid_613573 = header.getOrDefault("X-Amz-Date")
  valid_613573 = validateParameter(valid_613573, JString, required = false,
                                 default = nil)
  if valid_613573 != nil:
    section.add "X-Amz-Date", valid_613573
  var valid_613574 = header.getOrDefault("X-Amz-Credential")
  valid_613574 = validateParameter(valid_613574, JString, required = false,
                                 default = nil)
  if valid_613574 != nil:
    section.add "X-Amz-Credential", valid_613574
  var valid_613575 = header.getOrDefault("X-Amz-Security-Token")
  valid_613575 = validateParameter(valid_613575, JString, required = false,
                                 default = nil)
  if valid_613575 != nil:
    section.add "X-Amz-Security-Token", valid_613575
  var valid_613576 = header.getOrDefault("X-Amz-Algorithm")
  valid_613576 = validateParameter(valid_613576, JString, required = false,
                                 default = nil)
  if valid_613576 != nil:
    section.add "X-Amz-Algorithm", valid_613576
  var valid_613577 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613577 = validateParameter(valid_613577, JString, required = false,
                                 default = nil)
  if valid_613577 != nil:
    section.add "X-Amz-SignedHeaders", valid_613577
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613578: Call_DescribeAuthorizer_613567; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes an authorizer.
  ## 
  let valid = call_613578.validator(path, query, header, formData, body)
  let scheme = call_613578.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613578.url(scheme.get, call_613578.host, call_613578.base,
                         call_613578.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613578, url, valid)

proc call*(call_613579: Call_DescribeAuthorizer_613567; authorizerName: string): Recallable =
  ## describeAuthorizer
  ## Describes an authorizer.
  ##   authorizerName: string (required)
  ##                 : The name of the authorizer to describe.
  var path_613580 = newJObject()
  add(path_613580, "authorizerName", newJString(authorizerName))
  result = call_613579.call(path_613580, nil, nil, nil, nil)

var describeAuthorizer* = Call_DescribeAuthorizer_613567(
    name: "describeAuthorizer", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_DescribeAuthorizer_613568,
    base: "/", url: url_DescribeAuthorizer_613569,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteAuthorizer_613613 = ref object of OpenApiRestCall_612658
proc url_DeleteAuthorizer_613615(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteAuthorizer_613614(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Deletes an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The name of the authorizer to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_613616 = path.getOrDefault("authorizerName")
  valid_613616 = validateParameter(valid_613616, JString, required = true,
                                 default = nil)
  if valid_613616 != nil:
    section.add "authorizerName", valid_613616
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613617 = header.getOrDefault("X-Amz-Signature")
  valid_613617 = validateParameter(valid_613617, JString, required = false,
                                 default = nil)
  if valid_613617 != nil:
    section.add "X-Amz-Signature", valid_613617
  var valid_613618 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613618 = validateParameter(valid_613618, JString, required = false,
                                 default = nil)
  if valid_613618 != nil:
    section.add "X-Amz-Content-Sha256", valid_613618
  var valid_613619 = header.getOrDefault("X-Amz-Date")
  valid_613619 = validateParameter(valid_613619, JString, required = false,
                                 default = nil)
  if valid_613619 != nil:
    section.add "X-Amz-Date", valid_613619
  var valid_613620 = header.getOrDefault("X-Amz-Credential")
  valid_613620 = validateParameter(valid_613620, JString, required = false,
                                 default = nil)
  if valid_613620 != nil:
    section.add "X-Amz-Credential", valid_613620
  var valid_613621 = header.getOrDefault("X-Amz-Security-Token")
  valid_613621 = validateParameter(valid_613621, JString, required = false,
                                 default = nil)
  if valid_613621 != nil:
    section.add "X-Amz-Security-Token", valid_613621
  var valid_613622 = header.getOrDefault("X-Amz-Algorithm")
  valid_613622 = validateParameter(valid_613622, JString, required = false,
                                 default = nil)
  if valid_613622 != nil:
    section.add "X-Amz-Algorithm", valid_613622
  var valid_613623 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613623 = validateParameter(valid_613623, JString, required = false,
                                 default = nil)
  if valid_613623 != nil:
    section.add "X-Amz-SignedHeaders", valid_613623
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613624: Call_DeleteAuthorizer_613613; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an authorizer.
  ## 
  let valid = call_613624.validator(path, query, header, formData, body)
  let scheme = call_613624.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613624.url(scheme.get, call_613624.host, call_613624.base,
                         call_613624.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613624, url, valid)

proc call*(call_613625: Call_DeleteAuthorizer_613613; authorizerName: string): Recallable =
  ## deleteAuthorizer
  ## Deletes an authorizer.
  ##   authorizerName: string (required)
  ##                 : The name of the authorizer to delete.
  var path_613626 = newJObject()
  add(path_613626, "authorizerName", newJString(authorizerName))
  result = call_613625.call(path_613626, nil, nil, nil, nil)

var deleteAuthorizer* = Call_DeleteAuthorizer_613613(name: "deleteAuthorizer",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_DeleteAuthorizer_613614,
    base: "/", url: url_DeleteAuthorizer_613615,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateBillingGroup_613641 = ref object of OpenApiRestCall_612658
proc url_CreateBillingGroup_613643(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateBillingGroup_613642(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Creates a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name you wish to give to the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_613644 = path.getOrDefault("billingGroupName")
  valid_613644 = validateParameter(valid_613644, JString, required = true,
                                 default = nil)
  if valid_613644 != nil:
    section.add "billingGroupName", valid_613644
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613645 = header.getOrDefault("X-Amz-Signature")
  valid_613645 = validateParameter(valid_613645, JString, required = false,
                                 default = nil)
  if valid_613645 != nil:
    section.add "X-Amz-Signature", valid_613645
  var valid_613646 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613646 = validateParameter(valid_613646, JString, required = false,
                                 default = nil)
  if valid_613646 != nil:
    section.add "X-Amz-Content-Sha256", valid_613646
  var valid_613647 = header.getOrDefault("X-Amz-Date")
  valid_613647 = validateParameter(valid_613647, JString, required = false,
                                 default = nil)
  if valid_613647 != nil:
    section.add "X-Amz-Date", valid_613647
  var valid_613648 = header.getOrDefault("X-Amz-Credential")
  valid_613648 = validateParameter(valid_613648, JString, required = false,
                                 default = nil)
  if valid_613648 != nil:
    section.add "X-Amz-Credential", valid_613648
  var valid_613649 = header.getOrDefault("X-Amz-Security-Token")
  valid_613649 = validateParameter(valid_613649, JString, required = false,
                                 default = nil)
  if valid_613649 != nil:
    section.add "X-Amz-Security-Token", valid_613649
  var valid_613650 = header.getOrDefault("X-Amz-Algorithm")
  valid_613650 = validateParameter(valid_613650, JString, required = false,
                                 default = nil)
  if valid_613650 != nil:
    section.add "X-Amz-Algorithm", valid_613650
  var valid_613651 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613651 = validateParameter(valid_613651, JString, required = false,
                                 default = nil)
  if valid_613651 != nil:
    section.add "X-Amz-SignedHeaders", valid_613651
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613653: Call_CreateBillingGroup_613641; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a billing group.
  ## 
  let valid = call_613653.validator(path, query, header, formData, body)
  let scheme = call_613653.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613653.url(scheme.get, call_613653.host, call_613653.base,
                         call_613653.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613653, url, valid)

proc call*(call_613654: Call_CreateBillingGroup_613641; body: JsonNode;
          billingGroupName: string): Recallable =
  ## createBillingGroup
  ## Creates a billing group.
  ##   body: JObject (required)
  ##   billingGroupName: string (required)
  ##                   : The name you wish to give to the billing group.
  var path_613655 = newJObject()
  var body_613656 = newJObject()
  if body != nil:
    body_613656 = body
  add(path_613655, "billingGroupName", newJString(billingGroupName))
  result = call_613654.call(path_613655, nil, nil, nil, body_613656)

var createBillingGroup* = Call_CreateBillingGroup_613641(
    name: "createBillingGroup", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_CreateBillingGroup_613642, base: "/",
    url: url_CreateBillingGroup_613643, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeBillingGroup_613627 = ref object of OpenApiRestCall_612658
proc url_DescribeBillingGroup_613629(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeBillingGroup_613628(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_613630 = path.getOrDefault("billingGroupName")
  valid_613630 = validateParameter(valid_613630, JString, required = true,
                                 default = nil)
  if valid_613630 != nil:
    section.add "billingGroupName", valid_613630
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613631 = header.getOrDefault("X-Amz-Signature")
  valid_613631 = validateParameter(valid_613631, JString, required = false,
                                 default = nil)
  if valid_613631 != nil:
    section.add "X-Amz-Signature", valid_613631
  var valid_613632 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613632 = validateParameter(valid_613632, JString, required = false,
                                 default = nil)
  if valid_613632 != nil:
    section.add "X-Amz-Content-Sha256", valid_613632
  var valid_613633 = header.getOrDefault("X-Amz-Date")
  valid_613633 = validateParameter(valid_613633, JString, required = false,
                                 default = nil)
  if valid_613633 != nil:
    section.add "X-Amz-Date", valid_613633
  var valid_613634 = header.getOrDefault("X-Amz-Credential")
  valid_613634 = validateParameter(valid_613634, JString, required = false,
                                 default = nil)
  if valid_613634 != nil:
    section.add "X-Amz-Credential", valid_613634
  var valid_613635 = header.getOrDefault("X-Amz-Security-Token")
  valid_613635 = validateParameter(valid_613635, JString, required = false,
                                 default = nil)
  if valid_613635 != nil:
    section.add "X-Amz-Security-Token", valid_613635
  var valid_613636 = header.getOrDefault("X-Amz-Algorithm")
  valid_613636 = validateParameter(valid_613636, JString, required = false,
                                 default = nil)
  if valid_613636 != nil:
    section.add "X-Amz-Algorithm", valid_613636
  var valid_613637 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613637 = validateParameter(valid_613637, JString, required = false,
                                 default = nil)
  if valid_613637 != nil:
    section.add "X-Amz-SignedHeaders", valid_613637
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613638: Call_DescribeBillingGroup_613627; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about a billing group.
  ## 
  let valid = call_613638.validator(path, query, header, formData, body)
  let scheme = call_613638.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613638.url(scheme.get, call_613638.host, call_613638.base,
                         call_613638.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613638, url, valid)

proc call*(call_613639: Call_DescribeBillingGroup_613627; billingGroupName: string): Recallable =
  ## describeBillingGroup
  ## Returns information about a billing group.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_613640 = newJObject()
  add(path_613640, "billingGroupName", newJString(billingGroupName))
  result = call_613639.call(path_613640, nil, nil, nil, nil)

var describeBillingGroup* = Call_DescribeBillingGroup_613627(
    name: "describeBillingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_DescribeBillingGroup_613628, base: "/",
    url: url_DescribeBillingGroup_613629, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateBillingGroup_613673 = ref object of OpenApiRestCall_612658
proc url_UpdateBillingGroup_613675(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateBillingGroup_613674(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Updates information about the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_613676 = path.getOrDefault("billingGroupName")
  valid_613676 = validateParameter(valid_613676, JString, required = true,
                                 default = nil)
  if valid_613676 != nil:
    section.add "billingGroupName", valid_613676
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613677 = header.getOrDefault("X-Amz-Signature")
  valid_613677 = validateParameter(valid_613677, JString, required = false,
                                 default = nil)
  if valid_613677 != nil:
    section.add "X-Amz-Signature", valid_613677
  var valid_613678 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613678 = validateParameter(valid_613678, JString, required = false,
                                 default = nil)
  if valid_613678 != nil:
    section.add "X-Amz-Content-Sha256", valid_613678
  var valid_613679 = header.getOrDefault("X-Amz-Date")
  valid_613679 = validateParameter(valid_613679, JString, required = false,
                                 default = nil)
  if valid_613679 != nil:
    section.add "X-Amz-Date", valid_613679
  var valid_613680 = header.getOrDefault("X-Amz-Credential")
  valid_613680 = validateParameter(valid_613680, JString, required = false,
                                 default = nil)
  if valid_613680 != nil:
    section.add "X-Amz-Credential", valid_613680
  var valid_613681 = header.getOrDefault("X-Amz-Security-Token")
  valid_613681 = validateParameter(valid_613681, JString, required = false,
                                 default = nil)
  if valid_613681 != nil:
    section.add "X-Amz-Security-Token", valid_613681
  var valid_613682 = header.getOrDefault("X-Amz-Algorithm")
  valid_613682 = validateParameter(valid_613682, JString, required = false,
                                 default = nil)
  if valid_613682 != nil:
    section.add "X-Amz-Algorithm", valid_613682
  var valid_613683 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613683 = validateParameter(valid_613683, JString, required = false,
                                 default = nil)
  if valid_613683 != nil:
    section.add "X-Amz-SignedHeaders", valid_613683
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613685: Call_UpdateBillingGroup_613673; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates information about the billing group.
  ## 
  let valid = call_613685.validator(path, query, header, formData, body)
  let scheme = call_613685.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613685.url(scheme.get, call_613685.host, call_613685.base,
                         call_613685.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613685, url, valid)

proc call*(call_613686: Call_UpdateBillingGroup_613673; body: JsonNode;
          billingGroupName: string): Recallable =
  ## updateBillingGroup
  ## Updates information about the billing group.
  ##   body: JObject (required)
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_613687 = newJObject()
  var body_613688 = newJObject()
  if body != nil:
    body_613688 = body
  add(path_613687, "billingGroupName", newJString(billingGroupName))
  result = call_613686.call(path_613687, nil, nil, nil, body_613688)

var updateBillingGroup* = Call_UpdateBillingGroup_613673(
    name: "updateBillingGroup", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_UpdateBillingGroup_613674, base: "/",
    url: url_UpdateBillingGroup_613675, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteBillingGroup_613657 = ref object of OpenApiRestCall_612658
proc url_DeleteBillingGroup_613659(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteBillingGroup_613658(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deletes the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_613660 = path.getOrDefault("billingGroupName")
  valid_613660 = validateParameter(valid_613660, JString, required = true,
                                 default = nil)
  if valid_613660 != nil:
    section.add "billingGroupName", valid_613660
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.
  section = newJObject()
  var valid_613661 = query.getOrDefault("expectedVersion")
  valid_613661 = validateParameter(valid_613661, JInt, required = false, default = nil)
  if valid_613661 != nil:
    section.add "expectedVersion", valid_613661
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613662 = header.getOrDefault("X-Amz-Signature")
  valid_613662 = validateParameter(valid_613662, JString, required = false,
                                 default = nil)
  if valid_613662 != nil:
    section.add "X-Amz-Signature", valid_613662
  var valid_613663 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613663 = validateParameter(valid_613663, JString, required = false,
                                 default = nil)
  if valid_613663 != nil:
    section.add "X-Amz-Content-Sha256", valid_613663
  var valid_613664 = header.getOrDefault("X-Amz-Date")
  valid_613664 = validateParameter(valid_613664, JString, required = false,
                                 default = nil)
  if valid_613664 != nil:
    section.add "X-Amz-Date", valid_613664
  var valid_613665 = header.getOrDefault("X-Amz-Credential")
  valid_613665 = validateParameter(valid_613665, JString, required = false,
                                 default = nil)
  if valid_613665 != nil:
    section.add "X-Amz-Credential", valid_613665
  var valid_613666 = header.getOrDefault("X-Amz-Security-Token")
  valid_613666 = validateParameter(valid_613666, JString, required = false,
                                 default = nil)
  if valid_613666 != nil:
    section.add "X-Amz-Security-Token", valid_613666
  var valid_613667 = header.getOrDefault("X-Amz-Algorithm")
  valid_613667 = validateParameter(valid_613667, JString, required = false,
                                 default = nil)
  if valid_613667 != nil:
    section.add "X-Amz-Algorithm", valid_613667
  var valid_613668 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613668 = validateParameter(valid_613668, JString, required = false,
                                 default = nil)
  if valid_613668 != nil:
    section.add "X-Amz-SignedHeaders", valid_613668
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613669: Call_DeleteBillingGroup_613657; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the billing group.
  ## 
  let valid = call_613669.validator(path, query, header, formData, body)
  let scheme = call_613669.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613669.url(scheme.get, call_613669.host, call_613669.base,
                         call_613669.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613669, url, valid)

proc call*(call_613670: Call_DeleteBillingGroup_613657; billingGroupName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteBillingGroup
  ## Deletes the billing group.
  ##   expectedVersion: int
  ##                  : The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_613671 = newJObject()
  var query_613672 = newJObject()
  add(query_613672, "expectedVersion", newJInt(expectedVersion))
  add(path_613671, "billingGroupName", newJString(billingGroupName))
  result = call_613670.call(path_613671, query_613672, nil, nil, nil)

var deleteBillingGroup* = Call_DeleteBillingGroup_613657(
    name: "deleteBillingGroup", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_DeleteBillingGroup_613658, base: "/",
    url: url_DeleteBillingGroup_613659, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateCertificateFromCsr_613705 = ref object of OpenApiRestCall_612658
proc url_CreateCertificateFromCsr_613707(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateCertificateFromCsr_613706(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_613708 = query.getOrDefault("setAsActive")
  valid_613708 = validateParameter(valid_613708, JBool, required = false, default = nil)
  if valid_613708 != nil:
    section.add "setAsActive", valid_613708
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613709 = header.getOrDefault("X-Amz-Signature")
  valid_613709 = validateParameter(valid_613709, JString, required = false,
                                 default = nil)
  if valid_613709 != nil:
    section.add "X-Amz-Signature", valid_613709
  var valid_613710 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613710 = validateParameter(valid_613710, JString, required = false,
                                 default = nil)
  if valid_613710 != nil:
    section.add "X-Amz-Content-Sha256", valid_613710
  var valid_613711 = header.getOrDefault("X-Amz-Date")
  valid_613711 = validateParameter(valid_613711, JString, required = false,
                                 default = nil)
  if valid_613711 != nil:
    section.add "X-Amz-Date", valid_613711
  var valid_613712 = header.getOrDefault("X-Amz-Credential")
  valid_613712 = validateParameter(valid_613712, JString, required = false,
                                 default = nil)
  if valid_613712 != nil:
    section.add "X-Amz-Credential", valid_613712
  var valid_613713 = header.getOrDefault("X-Amz-Security-Token")
  valid_613713 = validateParameter(valid_613713, JString, required = false,
                                 default = nil)
  if valid_613713 != nil:
    section.add "X-Amz-Security-Token", valid_613713
  var valid_613714 = header.getOrDefault("X-Amz-Algorithm")
  valid_613714 = validateParameter(valid_613714, JString, required = false,
                                 default = nil)
  if valid_613714 != nil:
    section.add "X-Amz-Algorithm", valid_613714
  var valid_613715 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613715 = validateParameter(valid_613715, JString, required = false,
                                 default = nil)
  if valid_613715 != nil:
    section.add "X-Amz-SignedHeaders", valid_613715
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613717: Call_CreateCertificateFromCsr_613705; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ## 
  let valid = call_613717.validator(path, query, header, formData, body)
  let scheme = call_613717.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613717.url(scheme.get, call_613717.host, call_613717.base,
                         call_613717.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613717, url, valid)

proc call*(call_613718: Call_CreateCertificateFromCsr_613705; body: JsonNode;
          setAsActive: bool = false): Recallable =
  ## createCertificateFromCsr
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  ##   body: JObject (required)
  var query_613719 = newJObject()
  var body_613720 = newJObject()
  add(query_613719, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_613720 = body
  result = call_613718.call(nil, query_613719, nil, nil, body_613720)

var createCertificateFromCsr* = Call_CreateCertificateFromCsr_613705(
    name: "createCertificateFromCsr", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/certificates",
    validator: validate_CreateCertificateFromCsr_613706, base: "/",
    url: url_CreateCertificateFromCsr_613707, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCertificates_613689 = ref object of OpenApiRestCall_612658
proc url_ListCertificates_613691(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListCertificates_613690(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_613692 = query.getOrDefault("isAscendingOrder")
  valid_613692 = validateParameter(valid_613692, JBool, required = false, default = nil)
  if valid_613692 != nil:
    section.add "isAscendingOrder", valid_613692
  var valid_613693 = query.getOrDefault("pageSize")
  valid_613693 = validateParameter(valid_613693, JInt, required = false, default = nil)
  if valid_613693 != nil:
    section.add "pageSize", valid_613693
  var valid_613694 = query.getOrDefault("marker")
  valid_613694 = validateParameter(valid_613694, JString, required = false,
                                 default = nil)
  if valid_613694 != nil:
    section.add "marker", valid_613694
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613695 = header.getOrDefault("X-Amz-Signature")
  valid_613695 = validateParameter(valid_613695, JString, required = false,
                                 default = nil)
  if valid_613695 != nil:
    section.add "X-Amz-Signature", valid_613695
  var valid_613696 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613696 = validateParameter(valid_613696, JString, required = false,
                                 default = nil)
  if valid_613696 != nil:
    section.add "X-Amz-Content-Sha256", valid_613696
  var valid_613697 = header.getOrDefault("X-Amz-Date")
  valid_613697 = validateParameter(valid_613697, JString, required = false,
                                 default = nil)
  if valid_613697 != nil:
    section.add "X-Amz-Date", valid_613697
  var valid_613698 = header.getOrDefault("X-Amz-Credential")
  valid_613698 = validateParameter(valid_613698, JString, required = false,
                                 default = nil)
  if valid_613698 != nil:
    section.add "X-Amz-Credential", valid_613698
  var valid_613699 = header.getOrDefault("X-Amz-Security-Token")
  valid_613699 = validateParameter(valid_613699, JString, required = false,
                                 default = nil)
  if valid_613699 != nil:
    section.add "X-Amz-Security-Token", valid_613699
  var valid_613700 = header.getOrDefault("X-Amz-Algorithm")
  valid_613700 = validateParameter(valid_613700, JString, required = false,
                                 default = nil)
  if valid_613700 != nil:
    section.add "X-Amz-Algorithm", valid_613700
  var valid_613701 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613701 = validateParameter(valid_613701, JString, required = false,
                                 default = nil)
  if valid_613701 != nil:
    section.add "X-Amz-SignedHeaders", valid_613701
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613702: Call_ListCertificates_613689; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  let valid = call_613702.validator(path, query, header, formData, body)
  let scheme = call_613702.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613702.url(scheme.get, call_613702.host, call_613702.base,
                         call_613702.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613702, url, valid)

proc call*(call_613703: Call_ListCertificates_613689;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listCertificates
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_613704 = newJObject()
  add(query_613704, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_613704, "pageSize", newJInt(pageSize))
  add(query_613704, "marker", newJString(marker))
  result = call_613703.call(nil, query_613704, nil, nil, nil)

var listCertificates* = Call_ListCertificates_613689(name: "listCertificates",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/certificates",
    validator: validate_ListCertificates_613690, base: "/",
    url: url_ListCertificates_613691, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateDomainConfiguration_613735 = ref object of OpenApiRestCall_612658
proc url_UpdateDomainConfiguration_613737(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "domainConfigurationName" in path,
        "`domainConfigurationName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/domainConfigurations/"),
               (kind: VariableSegment, value: "domainConfigurationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateDomainConfiguration_613736(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Updates values stored in the domain configuration. Domain configurations for default endpoints can't be updated.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   domainConfigurationName: JString (required)
  ##                          : The name of the domain configuration to be updated.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `domainConfigurationName` field"
  var valid_613738 = path.getOrDefault("domainConfigurationName")
  valid_613738 = validateParameter(valid_613738, JString, required = true,
                                 default = nil)
  if valid_613738 != nil:
    section.add "domainConfigurationName", valid_613738
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613739 = header.getOrDefault("X-Amz-Signature")
  valid_613739 = validateParameter(valid_613739, JString, required = false,
                                 default = nil)
  if valid_613739 != nil:
    section.add "X-Amz-Signature", valid_613739
  var valid_613740 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613740 = validateParameter(valid_613740, JString, required = false,
                                 default = nil)
  if valid_613740 != nil:
    section.add "X-Amz-Content-Sha256", valid_613740
  var valid_613741 = header.getOrDefault("X-Amz-Date")
  valid_613741 = validateParameter(valid_613741, JString, required = false,
                                 default = nil)
  if valid_613741 != nil:
    section.add "X-Amz-Date", valid_613741
  var valid_613742 = header.getOrDefault("X-Amz-Credential")
  valid_613742 = validateParameter(valid_613742, JString, required = false,
                                 default = nil)
  if valid_613742 != nil:
    section.add "X-Amz-Credential", valid_613742
  var valid_613743 = header.getOrDefault("X-Amz-Security-Token")
  valid_613743 = validateParameter(valid_613743, JString, required = false,
                                 default = nil)
  if valid_613743 != nil:
    section.add "X-Amz-Security-Token", valid_613743
  var valid_613744 = header.getOrDefault("X-Amz-Algorithm")
  valid_613744 = validateParameter(valid_613744, JString, required = false,
                                 default = nil)
  if valid_613744 != nil:
    section.add "X-Amz-Algorithm", valid_613744
  var valid_613745 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613745 = validateParameter(valid_613745, JString, required = false,
                                 default = nil)
  if valid_613745 != nil:
    section.add "X-Amz-SignedHeaders", valid_613745
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613747: Call_UpdateDomainConfiguration_613735; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Updates values stored in the domain configuration. Domain configurations for default endpoints can't be updated.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_613747.validator(path, query, header, formData, body)
  let scheme = call_613747.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613747.url(scheme.get, call_613747.host, call_613747.base,
                         call_613747.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613747, url, valid)

proc call*(call_613748: Call_UpdateDomainConfiguration_613735; body: JsonNode;
          domainConfigurationName: string): Recallable =
  ## updateDomainConfiguration
  ## <p>Updates values stored in the domain configuration. Domain configurations for default endpoints can't be updated.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   body: JObject (required)
  ##   domainConfigurationName: string (required)
  ##                          : The name of the domain configuration to be updated.
  var path_613749 = newJObject()
  var body_613750 = newJObject()
  if body != nil:
    body_613750 = body
  add(path_613749, "domainConfigurationName", newJString(domainConfigurationName))
  result = call_613748.call(path_613749, nil, nil, nil, body_613750)

var updateDomainConfiguration* = Call_UpdateDomainConfiguration_613735(
    name: "updateDomainConfiguration", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/domainConfigurations/{domainConfigurationName}",
    validator: validate_UpdateDomainConfiguration_613736, base: "/",
    url: url_UpdateDomainConfiguration_613737,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateDomainConfiguration_613751 = ref object of OpenApiRestCall_612658
proc url_CreateDomainConfiguration_613753(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "domainConfigurationName" in path,
        "`domainConfigurationName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/domainConfigurations/"),
               (kind: VariableSegment, value: "domainConfigurationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateDomainConfiguration_613752(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   domainConfigurationName: JString (required)
  ##                          : The name of the domain configuration. This value must be unique to a region.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `domainConfigurationName` field"
  var valid_613754 = path.getOrDefault("domainConfigurationName")
  valid_613754 = validateParameter(valid_613754, JString, required = true,
                                 default = nil)
  if valid_613754 != nil:
    section.add "domainConfigurationName", valid_613754
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613755 = header.getOrDefault("X-Amz-Signature")
  valid_613755 = validateParameter(valid_613755, JString, required = false,
                                 default = nil)
  if valid_613755 != nil:
    section.add "X-Amz-Signature", valid_613755
  var valid_613756 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613756 = validateParameter(valid_613756, JString, required = false,
                                 default = nil)
  if valid_613756 != nil:
    section.add "X-Amz-Content-Sha256", valid_613756
  var valid_613757 = header.getOrDefault("X-Amz-Date")
  valid_613757 = validateParameter(valid_613757, JString, required = false,
                                 default = nil)
  if valid_613757 != nil:
    section.add "X-Amz-Date", valid_613757
  var valid_613758 = header.getOrDefault("X-Amz-Credential")
  valid_613758 = validateParameter(valid_613758, JString, required = false,
                                 default = nil)
  if valid_613758 != nil:
    section.add "X-Amz-Credential", valid_613758
  var valid_613759 = header.getOrDefault("X-Amz-Security-Token")
  valid_613759 = validateParameter(valid_613759, JString, required = false,
                                 default = nil)
  if valid_613759 != nil:
    section.add "X-Amz-Security-Token", valid_613759
  var valid_613760 = header.getOrDefault("X-Amz-Algorithm")
  valid_613760 = validateParameter(valid_613760, JString, required = false,
                                 default = nil)
  if valid_613760 != nil:
    section.add "X-Amz-Algorithm", valid_613760
  var valid_613761 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613761 = validateParameter(valid_613761, JString, required = false,
                                 default = nil)
  if valid_613761 != nil:
    section.add "X-Amz-SignedHeaders", valid_613761
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613763: Call_CreateDomainConfiguration_613751; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_613763.validator(path, query, header, formData, body)
  let scheme = call_613763.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613763.url(scheme.get, call_613763.host, call_613763.base,
                         call_613763.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613763, url, valid)

proc call*(call_613764: Call_CreateDomainConfiguration_613751; body: JsonNode;
          domainConfigurationName: string): Recallable =
  ## createDomainConfiguration
  ## <p>Creates a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   body: JObject (required)
  ##   domainConfigurationName: string (required)
  ##                          : The name of the domain configuration. This value must be unique to a region.
  var path_613765 = newJObject()
  var body_613766 = newJObject()
  if body != nil:
    body_613766 = body
  add(path_613765, "domainConfigurationName", newJString(domainConfigurationName))
  result = call_613764.call(path_613765, nil, nil, nil, body_613766)

var createDomainConfiguration* = Call_CreateDomainConfiguration_613751(
    name: "createDomainConfiguration", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/domainConfigurations/{domainConfigurationName}",
    validator: validate_CreateDomainConfiguration_613752, base: "/",
    url: url_CreateDomainConfiguration_613753,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeDomainConfiguration_613721 = ref object of OpenApiRestCall_612658
proc url_DescribeDomainConfiguration_613723(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "domainConfigurationName" in path,
        "`domainConfigurationName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/domainConfigurations/"),
               (kind: VariableSegment, value: "domainConfigurationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeDomainConfiguration_613722(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Gets summary information about a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   domainConfigurationName: JString (required)
  ##                          : The name of the domain configuration.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `domainConfigurationName` field"
  var valid_613724 = path.getOrDefault("domainConfigurationName")
  valid_613724 = validateParameter(valid_613724, JString, required = true,
                                 default = nil)
  if valid_613724 != nil:
    section.add "domainConfigurationName", valid_613724
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613725 = header.getOrDefault("X-Amz-Signature")
  valid_613725 = validateParameter(valid_613725, JString, required = false,
                                 default = nil)
  if valid_613725 != nil:
    section.add "X-Amz-Signature", valid_613725
  var valid_613726 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613726 = validateParameter(valid_613726, JString, required = false,
                                 default = nil)
  if valid_613726 != nil:
    section.add "X-Amz-Content-Sha256", valid_613726
  var valid_613727 = header.getOrDefault("X-Amz-Date")
  valid_613727 = validateParameter(valid_613727, JString, required = false,
                                 default = nil)
  if valid_613727 != nil:
    section.add "X-Amz-Date", valid_613727
  var valid_613728 = header.getOrDefault("X-Amz-Credential")
  valid_613728 = validateParameter(valid_613728, JString, required = false,
                                 default = nil)
  if valid_613728 != nil:
    section.add "X-Amz-Credential", valid_613728
  var valid_613729 = header.getOrDefault("X-Amz-Security-Token")
  valid_613729 = validateParameter(valid_613729, JString, required = false,
                                 default = nil)
  if valid_613729 != nil:
    section.add "X-Amz-Security-Token", valid_613729
  var valid_613730 = header.getOrDefault("X-Amz-Algorithm")
  valid_613730 = validateParameter(valid_613730, JString, required = false,
                                 default = nil)
  if valid_613730 != nil:
    section.add "X-Amz-Algorithm", valid_613730
  var valid_613731 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613731 = validateParameter(valid_613731, JString, required = false,
                                 default = nil)
  if valid_613731 != nil:
    section.add "X-Amz-SignedHeaders", valid_613731
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613732: Call_DescribeDomainConfiguration_613721; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Gets summary information about a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_613732.validator(path, query, header, formData, body)
  let scheme = call_613732.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613732.url(scheme.get, call_613732.host, call_613732.base,
                         call_613732.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613732, url, valid)

proc call*(call_613733: Call_DescribeDomainConfiguration_613721;
          domainConfigurationName: string): Recallable =
  ## describeDomainConfiguration
  ## <p>Gets summary information about a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   domainConfigurationName: string (required)
  ##                          : The name of the domain configuration.
  var path_613734 = newJObject()
  add(path_613734, "domainConfigurationName", newJString(domainConfigurationName))
  result = call_613733.call(path_613734, nil, nil, nil, nil)

var describeDomainConfiguration* = Call_DescribeDomainConfiguration_613721(
    name: "describeDomainConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/domainConfigurations/{domainConfigurationName}",
    validator: validate_DescribeDomainConfiguration_613722, base: "/",
    url: url_DescribeDomainConfiguration_613723,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteDomainConfiguration_613767 = ref object of OpenApiRestCall_612658
proc url_DeleteDomainConfiguration_613769(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "domainConfigurationName" in path,
        "`domainConfigurationName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/domainConfigurations/"),
               (kind: VariableSegment, value: "domainConfigurationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteDomainConfiguration_613768(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   domainConfigurationName: JString (required)
  ##                          : The name of the domain configuration to be deleted.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `domainConfigurationName` field"
  var valid_613770 = path.getOrDefault("domainConfigurationName")
  valid_613770 = validateParameter(valid_613770, JString, required = true,
                                 default = nil)
  if valid_613770 != nil:
    section.add "domainConfigurationName", valid_613770
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613771 = header.getOrDefault("X-Amz-Signature")
  valid_613771 = validateParameter(valid_613771, JString, required = false,
                                 default = nil)
  if valid_613771 != nil:
    section.add "X-Amz-Signature", valid_613771
  var valid_613772 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613772 = validateParameter(valid_613772, JString, required = false,
                                 default = nil)
  if valid_613772 != nil:
    section.add "X-Amz-Content-Sha256", valid_613772
  var valid_613773 = header.getOrDefault("X-Amz-Date")
  valid_613773 = validateParameter(valid_613773, JString, required = false,
                                 default = nil)
  if valid_613773 != nil:
    section.add "X-Amz-Date", valid_613773
  var valid_613774 = header.getOrDefault("X-Amz-Credential")
  valid_613774 = validateParameter(valid_613774, JString, required = false,
                                 default = nil)
  if valid_613774 != nil:
    section.add "X-Amz-Credential", valid_613774
  var valid_613775 = header.getOrDefault("X-Amz-Security-Token")
  valid_613775 = validateParameter(valid_613775, JString, required = false,
                                 default = nil)
  if valid_613775 != nil:
    section.add "X-Amz-Security-Token", valid_613775
  var valid_613776 = header.getOrDefault("X-Amz-Algorithm")
  valid_613776 = validateParameter(valid_613776, JString, required = false,
                                 default = nil)
  if valid_613776 != nil:
    section.add "X-Amz-Algorithm", valid_613776
  var valid_613777 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613777 = validateParameter(valid_613777, JString, required = false,
                                 default = nil)
  if valid_613777 != nil:
    section.add "X-Amz-SignedHeaders", valid_613777
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613778: Call_DeleteDomainConfiguration_613767; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_613778.validator(path, query, header, formData, body)
  let scheme = call_613778.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613778.url(scheme.get, call_613778.host, call_613778.base,
                         call_613778.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613778, url, valid)

proc call*(call_613779: Call_DeleteDomainConfiguration_613767;
          domainConfigurationName: string): Recallable =
  ## deleteDomainConfiguration
  ## <p>Deletes the specified domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   domainConfigurationName: string (required)
  ##                          : The name of the domain configuration to be deleted.
  var path_613780 = newJObject()
  add(path_613780, "domainConfigurationName", newJString(domainConfigurationName))
  result = call_613779.call(path_613780, nil, nil, nil, nil)

var deleteDomainConfiguration* = Call_DeleteDomainConfiguration_613767(
    name: "deleteDomainConfiguration", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/domainConfigurations/{domainConfigurationName}",
    validator: validate_DeleteDomainConfiguration_613768, base: "/",
    url: url_DeleteDomainConfiguration_613769,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateDynamicThingGroup_613781 = ref object of OpenApiRestCall_612658
proc url_CreateDynamicThingGroup_613783(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateDynamicThingGroup_613782(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The dynamic thing group name to create.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_613784 = path.getOrDefault("thingGroupName")
  valid_613784 = validateParameter(valid_613784, JString, required = true,
                                 default = nil)
  if valid_613784 != nil:
    section.add "thingGroupName", valid_613784
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613785 = header.getOrDefault("X-Amz-Signature")
  valid_613785 = validateParameter(valid_613785, JString, required = false,
                                 default = nil)
  if valid_613785 != nil:
    section.add "X-Amz-Signature", valid_613785
  var valid_613786 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613786 = validateParameter(valid_613786, JString, required = false,
                                 default = nil)
  if valid_613786 != nil:
    section.add "X-Amz-Content-Sha256", valid_613786
  var valid_613787 = header.getOrDefault("X-Amz-Date")
  valid_613787 = validateParameter(valid_613787, JString, required = false,
                                 default = nil)
  if valid_613787 != nil:
    section.add "X-Amz-Date", valid_613787
  var valid_613788 = header.getOrDefault("X-Amz-Credential")
  valid_613788 = validateParameter(valid_613788, JString, required = false,
                                 default = nil)
  if valid_613788 != nil:
    section.add "X-Amz-Credential", valid_613788
  var valid_613789 = header.getOrDefault("X-Amz-Security-Token")
  valid_613789 = validateParameter(valid_613789, JString, required = false,
                                 default = nil)
  if valid_613789 != nil:
    section.add "X-Amz-Security-Token", valid_613789
  var valid_613790 = header.getOrDefault("X-Amz-Algorithm")
  valid_613790 = validateParameter(valid_613790, JString, required = false,
                                 default = nil)
  if valid_613790 != nil:
    section.add "X-Amz-Algorithm", valid_613790
  var valid_613791 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613791 = validateParameter(valid_613791, JString, required = false,
                                 default = nil)
  if valid_613791 != nil:
    section.add "X-Amz-SignedHeaders", valid_613791
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613793: Call_CreateDynamicThingGroup_613781; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a dynamic thing group.
  ## 
  let valid = call_613793.validator(path, query, header, formData, body)
  let scheme = call_613793.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613793.url(scheme.get, call_613793.host, call_613793.base,
                         call_613793.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613793, url, valid)

proc call*(call_613794: Call_CreateDynamicThingGroup_613781;
          thingGroupName: string; body: JsonNode): Recallable =
  ## createDynamicThingGroup
  ## Creates a dynamic thing group.
  ##   thingGroupName: string (required)
  ##                 : The dynamic thing group name to create.
  ##   body: JObject (required)
  var path_613795 = newJObject()
  var body_613796 = newJObject()
  add(path_613795, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_613796 = body
  result = call_613794.call(path_613795, nil, nil, nil, body_613796)

var createDynamicThingGroup* = Call_CreateDynamicThingGroup_613781(
    name: "createDynamicThingGroup", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_CreateDynamicThingGroup_613782, base: "/",
    url: url_CreateDynamicThingGroup_613783, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateDynamicThingGroup_613813 = ref object of OpenApiRestCall_612658
proc url_UpdateDynamicThingGroup_613815(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateDynamicThingGroup_613814(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the dynamic thing group to update.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_613816 = path.getOrDefault("thingGroupName")
  valid_613816 = validateParameter(valid_613816, JString, required = true,
                                 default = nil)
  if valid_613816 != nil:
    section.add "thingGroupName", valid_613816
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613817 = header.getOrDefault("X-Amz-Signature")
  valid_613817 = validateParameter(valid_613817, JString, required = false,
                                 default = nil)
  if valid_613817 != nil:
    section.add "X-Amz-Signature", valid_613817
  var valid_613818 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613818 = validateParameter(valid_613818, JString, required = false,
                                 default = nil)
  if valid_613818 != nil:
    section.add "X-Amz-Content-Sha256", valid_613818
  var valid_613819 = header.getOrDefault("X-Amz-Date")
  valid_613819 = validateParameter(valid_613819, JString, required = false,
                                 default = nil)
  if valid_613819 != nil:
    section.add "X-Amz-Date", valid_613819
  var valid_613820 = header.getOrDefault("X-Amz-Credential")
  valid_613820 = validateParameter(valid_613820, JString, required = false,
                                 default = nil)
  if valid_613820 != nil:
    section.add "X-Amz-Credential", valid_613820
  var valid_613821 = header.getOrDefault("X-Amz-Security-Token")
  valid_613821 = validateParameter(valid_613821, JString, required = false,
                                 default = nil)
  if valid_613821 != nil:
    section.add "X-Amz-Security-Token", valid_613821
  var valid_613822 = header.getOrDefault("X-Amz-Algorithm")
  valid_613822 = validateParameter(valid_613822, JString, required = false,
                                 default = nil)
  if valid_613822 != nil:
    section.add "X-Amz-Algorithm", valid_613822
  var valid_613823 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613823 = validateParameter(valid_613823, JString, required = false,
                                 default = nil)
  if valid_613823 != nil:
    section.add "X-Amz-SignedHeaders", valid_613823
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613825: Call_UpdateDynamicThingGroup_613813; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a dynamic thing group.
  ## 
  let valid = call_613825.validator(path, query, header, formData, body)
  let scheme = call_613825.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613825.url(scheme.get, call_613825.host, call_613825.base,
                         call_613825.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613825, url, valid)

proc call*(call_613826: Call_UpdateDynamicThingGroup_613813;
          thingGroupName: string; body: JsonNode): Recallable =
  ## updateDynamicThingGroup
  ## Updates a dynamic thing group.
  ##   thingGroupName: string (required)
  ##                 : The name of the dynamic thing group to update.
  ##   body: JObject (required)
  var path_613827 = newJObject()
  var body_613828 = newJObject()
  add(path_613827, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_613828 = body
  result = call_613826.call(path_613827, nil, nil, nil, body_613828)

var updateDynamicThingGroup* = Call_UpdateDynamicThingGroup_613813(
    name: "updateDynamicThingGroup", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_UpdateDynamicThingGroup_613814, base: "/",
    url: url_UpdateDynamicThingGroup_613815, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteDynamicThingGroup_613797 = ref object of OpenApiRestCall_612658
proc url_DeleteDynamicThingGroup_613799(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteDynamicThingGroup_613798(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the dynamic thing group to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_613800 = path.getOrDefault("thingGroupName")
  valid_613800 = validateParameter(valid_613800, JString, required = true,
                                 default = nil)
  if valid_613800 != nil:
    section.add "thingGroupName", valid_613800
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the dynamic thing group to delete.
  section = newJObject()
  var valid_613801 = query.getOrDefault("expectedVersion")
  valid_613801 = validateParameter(valid_613801, JInt, required = false, default = nil)
  if valid_613801 != nil:
    section.add "expectedVersion", valid_613801
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613802 = header.getOrDefault("X-Amz-Signature")
  valid_613802 = validateParameter(valid_613802, JString, required = false,
                                 default = nil)
  if valid_613802 != nil:
    section.add "X-Amz-Signature", valid_613802
  var valid_613803 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613803 = validateParameter(valid_613803, JString, required = false,
                                 default = nil)
  if valid_613803 != nil:
    section.add "X-Amz-Content-Sha256", valid_613803
  var valid_613804 = header.getOrDefault("X-Amz-Date")
  valid_613804 = validateParameter(valid_613804, JString, required = false,
                                 default = nil)
  if valid_613804 != nil:
    section.add "X-Amz-Date", valid_613804
  var valid_613805 = header.getOrDefault("X-Amz-Credential")
  valid_613805 = validateParameter(valid_613805, JString, required = false,
                                 default = nil)
  if valid_613805 != nil:
    section.add "X-Amz-Credential", valid_613805
  var valid_613806 = header.getOrDefault("X-Amz-Security-Token")
  valid_613806 = validateParameter(valid_613806, JString, required = false,
                                 default = nil)
  if valid_613806 != nil:
    section.add "X-Amz-Security-Token", valid_613806
  var valid_613807 = header.getOrDefault("X-Amz-Algorithm")
  valid_613807 = validateParameter(valid_613807, JString, required = false,
                                 default = nil)
  if valid_613807 != nil:
    section.add "X-Amz-Algorithm", valid_613807
  var valid_613808 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613808 = validateParameter(valid_613808, JString, required = false,
                                 default = nil)
  if valid_613808 != nil:
    section.add "X-Amz-SignedHeaders", valid_613808
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613809: Call_DeleteDynamicThingGroup_613797; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a dynamic thing group.
  ## 
  let valid = call_613809.validator(path, query, header, formData, body)
  let scheme = call_613809.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613809.url(scheme.get, call_613809.host, call_613809.base,
                         call_613809.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613809, url, valid)

proc call*(call_613810: Call_DeleteDynamicThingGroup_613797;
          thingGroupName: string; expectedVersion: int = 0): Recallable =
  ## deleteDynamicThingGroup
  ## Deletes a dynamic thing group.
  ##   expectedVersion: int
  ##                  : The expected version of the dynamic thing group to delete.
  ##   thingGroupName: string (required)
  ##                 : The name of the dynamic thing group to delete.
  var path_613811 = newJObject()
  var query_613812 = newJObject()
  add(query_613812, "expectedVersion", newJInt(expectedVersion))
  add(path_613811, "thingGroupName", newJString(thingGroupName))
  result = call_613810.call(path_613811, query_613812, nil, nil, nil)

var deleteDynamicThingGroup* = Call_DeleteDynamicThingGroup_613797(
    name: "deleteDynamicThingGroup", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_DeleteDynamicThingGroup_613798, base: "/",
    url: url_DeleteDynamicThingGroup_613799, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateJob_613843 = ref object of OpenApiRestCall_612658
proc url_CreateJob_613845(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateJob_613844(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_613846 = path.getOrDefault("jobId")
  valid_613846 = validateParameter(valid_613846, JString, required = true,
                                 default = nil)
  if valid_613846 != nil:
    section.add "jobId", valid_613846
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613847 = header.getOrDefault("X-Amz-Signature")
  valid_613847 = validateParameter(valid_613847, JString, required = false,
                                 default = nil)
  if valid_613847 != nil:
    section.add "X-Amz-Signature", valid_613847
  var valid_613848 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613848 = validateParameter(valid_613848, JString, required = false,
                                 default = nil)
  if valid_613848 != nil:
    section.add "X-Amz-Content-Sha256", valid_613848
  var valid_613849 = header.getOrDefault("X-Amz-Date")
  valid_613849 = validateParameter(valid_613849, JString, required = false,
                                 default = nil)
  if valid_613849 != nil:
    section.add "X-Amz-Date", valid_613849
  var valid_613850 = header.getOrDefault("X-Amz-Credential")
  valid_613850 = validateParameter(valid_613850, JString, required = false,
                                 default = nil)
  if valid_613850 != nil:
    section.add "X-Amz-Credential", valid_613850
  var valid_613851 = header.getOrDefault("X-Amz-Security-Token")
  valid_613851 = validateParameter(valid_613851, JString, required = false,
                                 default = nil)
  if valid_613851 != nil:
    section.add "X-Amz-Security-Token", valid_613851
  var valid_613852 = header.getOrDefault("X-Amz-Algorithm")
  valid_613852 = validateParameter(valid_613852, JString, required = false,
                                 default = nil)
  if valid_613852 != nil:
    section.add "X-Amz-Algorithm", valid_613852
  var valid_613853 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613853 = validateParameter(valid_613853, JString, required = false,
                                 default = nil)
  if valid_613853 != nil:
    section.add "X-Amz-SignedHeaders", valid_613853
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613855: Call_CreateJob_613843; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a job.
  ## 
  let valid = call_613855.validator(path, query, header, formData, body)
  let scheme = call_613855.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613855.url(scheme.get, call_613855.host, call_613855.base,
                         call_613855.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613855, url, valid)

proc call*(call_613856: Call_CreateJob_613843; jobId: string; body: JsonNode): Recallable =
  ## createJob
  ## Creates a job.
  ##   jobId: string (required)
  ##        : A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
  ##   body: JObject (required)
  var path_613857 = newJObject()
  var body_613858 = newJObject()
  add(path_613857, "jobId", newJString(jobId))
  if body != nil:
    body_613858 = body
  result = call_613856.call(path_613857, nil, nil, nil, body_613858)

var createJob* = Call_CreateJob_613843(name: "createJob", meth: HttpMethod.HttpPut,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_CreateJob_613844,
                                    base: "/", url: url_CreateJob_613845,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeJob_613829 = ref object of OpenApiRestCall_612658
proc url_DescribeJob_613831(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeJob_613830(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_613832 = path.getOrDefault("jobId")
  valid_613832 = validateParameter(valid_613832, JString, required = true,
                                 default = nil)
  if valid_613832 != nil:
    section.add "jobId", valid_613832
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613833 = header.getOrDefault("X-Amz-Signature")
  valid_613833 = validateParameter(valid_613833, JString, required = false,
                                 default = nil)
  if valid_613833 != nil:
    section.add "X-Amz-Signature", valid_613833
  var valid_613834 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613834 = validateParameter(valid_613834, JString, required = false,
                                 default = nil)
  if valid_613834 != nil:
    section.add "X-Amz-Content-Sha256", valid_613834
  var valid_613835 = header.getOrDefault("X-Amz-Date")
  valid_613835 = validateParameter(valid_613835, JString, required = false,
                                 default = nil)
  if valid_613835 != nil:
    section.add "X-Amz-Date", valid_613835
  var valid_613836 = header.getOrDefault("X-Amz-Credential")
  valid_613836 = validateParameter(valid_613836, JString, required = false,
                                 default = nil)
  if valid_613836 != nil:
    section.add "X-Amz-Credential", valid_613836
  var valid_613837 = header.getOrDefault("X-Amz-Security-Token")
  valid_613837 = validateParameter(valid_613837, JString, required = false,
                                 default = nil)
  if valid_613837 != nil:
    section.add "X-Amz-Security-Token", valid_613837
  var valid_613838 = header.getOrDefault("X-Amz-Algorithm")
  valid_613838 = validateParameter(valid_613838, JString, required = false,
                                 default = nil)
  if valid_613838 != nil:
    section.add "X-Amz-Algorithm", valid_613838
  var valid_613839 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613839 = validateParameter(valid_613839, JString, required = false,
                                 default = nil)
  if valid_613839 != nil:
    section.add "X-Amz-SignedHeaders", valid_613839
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613840: Call_DescribeJob_613829; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a job.
  ## 
  let valid = call_613840.validator(path, query, header, formData, body)
  let scheme = call_613840.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613840.url(scheme.get, call_613840.host, call_613840.base,
                         call_613840.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613840, url, valid)

proc call*(call_613841: Call_DescribeJob_613829; jobId: string): Recallable =
  ## describeJob
  ## Describes a job.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  var path_613842 = newJObject()
  add(path_613842, "jobId", newJString(jobId))
  result = call_613841.call(path_613842, nil, nil, nil, nil)

var describeJob* = Call_DescribeJob_613829(name: "describeJob",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/jobs/{jobId}",
                                        validator: validate_DescribeJob_613830,
                                        base: "/", url: url_DescribeJob_613831,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateJob_613875 = ref object of OpenApiRestCall_612658
proc url_UpdateJob_613877(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateJob_613876(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates supported fields of the specified job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The ID of the job to be updated.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_613878 = path.getOrDefault("jobId")
  valid_613878 = validateParameter(valid_613878, JString, required = true,
                                 default = nil)
  if valid_613878 != nil:
    section.add "jobId", valid_613878
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613879 = header.getOrDefault("X-Amz-Signature")
  valid_613879 = validateParameter(valid_613879, JString, required = false,
                                 default = nil)
  if valid_613879 != nil:
    section.add "X-Amz-Signature", valid_613879
  var valid_613880 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613880 = validateParameter(valid_613880, JString, required = false,
                                 default = nil)
  if valid_613880 != nil:
    section.add "X-Amz-Content-Sha256", valid_613880
  var valid_613881 = header.getOrDefault("X-Amz-Date")
  valid_613881 = validateParameter(valid_613881, JString, required = false,
                                 default = nil)
  if valid_613881 != nil:
    section.add "X-Amz-Date", valid_613881
  var valid_613882 = header.getOrDefault("X-Amz-Credential")
  valid_613882 = validateParameter(valid_613882, JString, required = false,
                                 default = nil)
  if valid_613882 != nil:
    section.add "X-Amz-Credential", valid_613882
  var valid_613883 = header.getOrDefault("X-Amz-Security-Token")
  valid_613883 = validateParameter(valid_613883, JString, required = false,
                                 default = nil)
  if valid_613883 != nil:
    section.add "X-Amz-Security-Token", valid_613883
  var valid_613884 = header.getOrDefault("X-Amz-Algorithm")
  valid_613884 = validateParameter(valid_613884, JString, required = false,
                                 default = nil)
  if valid_613884 != nil:
    section.add "X-Amz-Algorithm", valid_613884
  var valid_613885 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613885 = validateParameter(valid_613885, JString, required = false,
                                 default = nil)
  if valid_613885 != nil:
    section.add "X-Amz-SignedHeaders", valid_613885
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613887: Call_UpdateJob_613875; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates supported fields of the specified job.
  ## 
  let valid = call_613887.validator(path, query, header, formData, body)
  let scheme = call_613887.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613887.url(scheme.get, call_613887.host, call_613887.base,
                         call_613887.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613887, url, valid)

proc call*(call_613888: Call_UpdateJob_613875; jobId: string; body: JsonNode): Recallable =
  ## updateJob
  ## Updates supported fields of the specified job.
  ##   jobId: string (required)
  ##        : The ID of the job to be updated.
  ##   body: JObject (required)
  var path_613889 = newJObject()
  var body_613890 = newJObject()
  add(path_613889, "jobId", newJString(jobId))
  if body != nil:
    body_613890 = body
  result = call_613888.call(path_613889, nil, nil, nil, body_613890)

var updateJob* = Call_UpdateJob_613875(name: "updateJob", meth: HttpMethod.HttpPatch,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_UpdateJob_613876,
                                    base: "/", url: url_UpdateJob_613877,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteJob_613859 = ref object of OpenApiRestCall_612658
proc url_DeleteJob_613861(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteJob_613860(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_613862 = path.getOrDefault("jobId")
  valid_613862 = validateParameter(valid_613862, JString, required = true,
                                 default = nil)
  if valid_613862 != nil:
    section.add "jobId", valid_613862
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
  section = newJObject()
  var valid_613863 = query.getOrDefault("force")
  valid_613863 = validateParameter(valid_613863, JBool, required = false, default = nil)
  if valid_613863 != nil:
    section.add "force", valid_613863
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613864 = header.getOrDefault("X-Amz-Signature")
  valid_613864 = validateParameter(valid_613864, JString, required = false,
                                 default = nil)
  if valid_613864 != nil:
    section.add "X-Amz-Signature", valid_613864
  var valid_613865 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613865 = validateParameter(valid_613865, JString, required = false,
                                 default = nil)
  if valid_613865 != nil:
    section.add "X-Amz-Content-Sha256", valid_613865
  var valid_613866 = header.getOrDefault("X-Amz-Date")
  valid_613866 = validateParameter(valid_613866, JString, required = false,
                                 default = nil)
  if valid_613866 != nil:
    section.add "X-Amz-Date", valid_613866
  var valid_613867 = header.getOrDefault("X-Amz-Credential")
  valid_613867 = validateParameter(valid_613867, JString, required = false,
                                 default = nil)
  if valid_613867 != nil:
    section.add "X-Amz-Credential", valid_613867
  var valid_613868 = header.getOrDefault("X-Amz-Security-Token")
  valid_613868 = validateParameter(valid_613868, JString, required = false,
                                 default = nil)
  if valid_613868 != nil:
    section.add "X-Amz-Security-Token", valid_613868
  var valid_613869 = header.getOrDefault("X-Amz-Algorithm")
  valid_613869 = validateParameter(valid_613869, JString, required = false,
                                 default = nil)
  if valid_613869 != nil:
    section.add "X-Amz-Algorithm", valid_613869
  var valid_613870 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613870 = validateParameter(valid_613870, JString, required = false,
                                 default = nil)
  if valid_613870 != nil:
    section.add "X-Amz-SignedHeaders", valid_613870
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613871: Call_DeleteJob_613859; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ## 
  let valid = call_613871.validator(path, query, header, formData, body)
  let scheme = call_613871.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613871.url(scheme.get, call_613871.host, call_613871.base,
                         call_613871.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613871, url, valid)

proc call*(call_613872: Call_DeleteJob_613859; jobId: string; force: bool = false): Recallable =
  ## deleteJob
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ##   jobId: string (required)
  ##        : <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
  ##   force: bool
  ##        : <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
  var path_613873 = newJObject()
  var query_613874 = newJObject()
  add(path_613873, "jobId", newJString(jobId))
  add(query_613874, "force", newJBool(force))
  result = call_613872.call(path_613873, query_613874, nil, nil, nil)

var deleteJob* = Call_DeleteJob_613859(name: "deleteJob",
                                    meth: HttpMethod.HttpDelete,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_DeleteJob_613860,
                                    base: "/", url: url_DeleteJob_613861,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateKeysAndCertificate_613891 = ref object of OpenApiRestCall_612658
proc url_CreateKeysAndCertificate_613893(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateKeysAndCertificate_613892(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key. You can also call <code>CreateKeysAndCertificate</code> over MQTT from a device, for more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-wo-cert.html#provision-mqtt-api">Provisioning MQTT API</a>.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_613894 = query.getOrDefault("setAsActive")
  valid_613894 = validateParameter(valid_613894, JBool, required = false, default = nil)
  if valid_613894 != nil:
    section.add "setAsActive", valid_613894
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613895 = header.getOrDefault("X-Amz-Signature")
  valid_613895 = validateParameter(valid_613895, JString, required = false,
                                 default = nil)
  if valid_613895 != nil:
    section.add "X-Amz-Signature", valid_613895
  var valid_613896 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613896 = validateParameter(valid_613896, JString, required = false,
                                 default = nil)
  if valid_613896 != nil:
    section.add "X-Amz-Content-Sha256", valid_613896
  var valid_613897 = header.getOrDefault("X-Amz-Date")
  valid_613897 = validateParameter(valid_613897, JString, required = false,
                                 default = nil)
  if valid_613897 != nil:
    section.add "X-Amz-Date", valid_613897
  var valid_613898 = header.getOrDefault("X-Amz-Credential")
  valid_613898 = validateParameter(valid_613898, JString, required = false,
                                 default = nil)
  if valid_613898 != nil:
    section.add "X-Amz-Credential", valid_613898
  var valid_613899 = header.getOrDefault("X-Amz-Security-Token")
  valid_613899 = validateParameter(valid_613899, JString, required = false,
                                 default = nil)
  if valid_613899 != nil:
    section.add "X-Amz-Security-Token", valid_613899
  var valid_613900 = header.getOrDefault("X-Amz-Algorithm")
  valid_613900 = validateParameter(valid_613900, JString, required = false,
                                 default = nil)
  if valid_613900 != nil:
    section.add "X-Amz-Algorithm", valid_613900
  var valid_613901 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613901 = validateParameter(valid_613901, JString, required = false,
                                 default = nil)
  if valid_613901 != nil:
    section.add "X-Amz-SignedHeaders", valid_613901
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613902: Call_CreateKeysAndCertificate_613891; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key. You can also call <code>CreateKeysAndCertificate</code> over MQTT from a device, for more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-wo-cert.html#provision-mqtt-api">Provisioning MQTT API</a>.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ## 
  let valid = call_613902.validator(path, query, header, formData, body)
  let scheme = call_613902.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613902.url(scheme.get, call_613902.host, call_613902.base,
                         call_613902.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613902, url, valid)

proc call*(call_613903: Call_CreateKeysAndCertificate_613891;
          setAsActive: bool = false): Recallable =
  ## createKeysAndCertificate
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key. You can also call <code>CreateKeysAndCertificate</code> over MQTT from a device, for more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-wo-cert.html#provision-mqtt-api">Provisioning MQTT API</a>.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  var query_613904 = newJObject()
  add(query_613904, "setAsActive", newJBool(setAsActive))
  result = call_613903.call(nil, query_613904, nil, nil, nil)

var createKeysAndCertificate* = Call_CreateKeysAndCertificate_613891(
    name: "createKeysAndCertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/keys-and-certificate",
    validator: validate_CreateKeysAndCertificate_613892, base: "/",
    url: url_CreateKeysAndCertificate_613893, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateMitigationAction_613919 = ref object of OpenApiRestCall_612658
proc url_CreateMitigationAction_613921(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateMitigationAction_613920(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_613922 = path.getOrDefault("actionName")
  valid_613922 = validateParameter(valid_613922, JString, required = true,
                                 default = nil)
  if valid_613922 != nil:
    section.add "actionName", valid_613922
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613923 = header.getOrDefault("X-Amz-Signature")
  valid_613923 = validateParameter(valid_613923, JString, required = false,
                                 default = nil)
  if valid_613923 != nil:
    section.add "X-Amz-Signature", valid_613923
  var valid_613924 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613924 = validateParameter(valid_613924, JString, required = false,
                                 default = nil)
  if valid_613924 != nil:
    section.add "X-Amz-Content-Sha256", valid_613924
  var valid_613925 = header.getOrDefault("X-Amz-Date")
  valid_613925 = validateParameter(valid_613925, JString, required = false,
                                 default = nil)
  if valid_613925 != nil:
    section.add "X-Amz-Date", valid_613925
  var valid_613926 = header.getOrDefault("X-Amz-Credential")
  valid_613926 = validateParameter(valid_613926, JString, required = false,
                                 default = nil)
  if valid_613926 != nil:
    section.add "X-Amz-Credential", valid_613926
  var valid_613927 = header.getOrDefault("X-Amz-Security-Token")
  valid_613927 = validateParameter(valid_613927, JString, required = false,
                                 default = nil)
  if valid_613927 != nil:
    section.add "X-Amz-Security-Token", valid_613927
  var valid_613928 = header.getOrDefault("X-Amz-Algorithm")
  valid_613928 = validateParameter(valid_613928, JString, required = false,
                                 default = nil)
  if valid_613928 != nil:
    section.add "X-Amz-Algorithm", valid_613928
  var valid_613929 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613929 = validateParameter(valid_613929, JString, required = false,
                                 default = nil)
  if valid_613929 != nil:
    section.add "X-Amz-SignedHeaders", valid_613929
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613931: Call_CreateMitigationAction_613919; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ## 
  let valid = call_613931.validator(path, query, header, formData, body)
  let scheme = call_613931.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613931.url(scheme.get, call_613931.host, call_613931.base,
                         call_613931.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613931, url, valid)

proc call*(call_613932: Call_CreateMitigationAction_613919; actionName: string;
          body: JsonNode): Recallable =
  ## createMitigationAction
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ##   actionName: string (required)
  ##             : A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).
  ##   body: JObject (required)
  var path_613933 = newJObject()
  var body_613934 = newJObject()
  add(path_613933, "actionName", newJString(actionName))
  if body != nil:
    body_613934 = body
  result = call_613932.call(path_613933, nil, nil, nil, body_613934)

var createMitigationAction* = Call_CreateMitigationAction_613919(
    name: "createMitigationAction", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_CreateMitigationAction_613920, base: "/",
    url: url_CreateMitigationAction_613921, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeMitigationAction_613905 = ref object of OpenApiRestCall_612658
proc url_DescribeMitigationAction_613907(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeMitigationAction_613906(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a mitigation action.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The friendly name that uniquely identifies the mitigation action.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_613908 = path.getOrDefault("actionName")
  valid_613908 = validateParameter(valid_613908, JString, required = true,
                                 default = nil)
  if valid_613908 != nil:
    section.add "actionName", valid_613908
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613909 = header.getOrDefault("X-Amz-Signature")
  valid_613909 = validateParameter(valid_613909, JString, required = false,
                                 default = nil)
  if valid_613909 != nil:
    section.add "X-Amz-Signature", valid_613909
  var valid_613910 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613910 = validateParameter(valid_613910, JString, required = false,
                                 default = nil)
  if valid_613910 != nil:
    section.add "X-Amz-Content-Sha256", valid_613910
  var valid_613911 = header.getOrDefault("X-Amz-Date")
  valid_613911 = validateParameter(valid_613911, JString, required = false,
                                 default = nil)
  if valid_613911 != nil:
    section.add "X-Amz-Date", valid_613911
  var valid_613912 = header.getOrDefault("X-Amz-Credential")
  valid_613912 = validateParameter(valid_613912, JString, required = false,
                                 default = nil)
  if valid_613912 != nil:
    section.add "X-Amz-Credential", valid_613912
  var valid_613913 = header.getOrDefault("X-Amz-Security-Token")
  valid_613913 = validateParameter(valid_613913, JString, required = false,
                                 default = nil)
  if valid_613913 != nil:
    section.add "X-Amz-Security-Token", valid_613913
  var valid_613914 = header.getOrDefault("X-Amz-Algorithm")
  valid_613914 = validateParameter(valid_613914, JString, required = false,
                                 default = nil)
  if valid_613914 != nil:
    section.add "X-Amz-Algorithm", valid_613914
  var valid_613915 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613915 = validateParameter(valid_613915, JString, required = false,
                                 default = nil)
  if valid_613915 != nil:
    section.add "X-Amz-SignedHeaders", valid_613915
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613916: Call_DescribeMitigationAction_613905; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a mitigation action.
  ## 
  let valid = call_613916.validator(path, query, header, formData, body)
  let scheme = call_613916.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613916.url(scheme.get, call_613916.host, call_613916.base,
                         call_613916.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613916, url, valid)

proc call*(call_613917: Call_DescribeMitigationAction_613905; actionName: string): Recallable =
  ## describeMitigationAction
  ## Gets information about a mitigation action.
  ##   actionName: string (required)
  ##             : The friendly name that uniquely identifies the mitigation action.
  var path_613918 = newJObject()
  add(path_613918, "actionName", newJString(actionName))
  result = call_613917.call(path_613918, nil, nil, nil, nil)

var describeMitigationAction* = Call_DescribeMitigationAction_613905(
    name: "describeMitigationAction", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_DescribeMitigationAction_613906, base: "/",
    url: url_DescribeMitigationAction_613907, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateMitigationAction_613949 = ref object of OpenApiRestCall_612658
proc url_UpdateMitigationAction_613951(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateMitigationAction_613950(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the definition for the specified mitigation action.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_613952 = path.getOrDefault("actionName")
  valid_613952 = validateParameter(valid_613952, JString, required = true,
                                 default = nil)
  if valid_613952 != nil:
    section.add "actionName", valid_613952
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613953 = header.getOrDefault("X-Amz-Signature")
  valid_613953 = validateParameter(valid_613953, JString, required = false,
                                 default = nil)
  if valid_613953 != nil:
    section.add "X-Amz-Signature", valid_613953
  var valid_613954 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613954 = validateParameter(valid_613954, JString, required = false,
                                 default = nil)
  if valid_613954 != nil:
    section.add "X-Amz-Content-Sha256", valid_613954
  var valid_613955 = header.getOrDefault("X-Amz-Date")
  valid_613955 = validateParameter(valid_613955, JString, required = false,
                                 default = nil)
  if valid_613955 != nil:
    section.add "X-Amz-Date", valid_613955
  var valid_613956 = header.getOrDefault("X-Amz-Credential")
  valid_613956 = validateParameter(valid_613956, JString, required = false,
                                 default = nil)
  if valid_613956 != nil:
    section.add "X-Amz-Credential", valid_613956
  var valid_613957 = header.getOrDefault("X-Amz-Security-Token")
  valid_613957 = validateParameter(valid_613957, JString, required = false,
                                 default = nil)
  if valid_613957 != nil:
    section.add "X-Amz-Security-Token", valid_613957
  var valid_613958 = header.getOrDefault("X-Amz-Algorithm")
  valid_613958 = validateParameter(valid_613958, JString, required = false,
                                 default = nil)
  if valid_613958 != nil:
    section.add "X-Amz-Algorithm", valid_613958
  var valid_613959 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613959 = validateParameter(valid_613959, JString, required = false,
                                 default = nil)
  if valid_613959 != nil:
    section.add "X-Amz-SignedHeaders", valid_613959
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613961: Call_UpdateMitigationAction_613949; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the definition for the specified mitigation action.
  ## 
  let valid = call_613961.validator(path, query, header, formData, body)
  let scheme = call_613961.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613961.url(scheme.get, call_613961.host, call_613961.base,
                         call_613961.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613961, url, valid)

proc call*(call_613962: Call_UpdateMitigationAction_613949; actionName: string;
          body: JsonNode): Recallable =
  ## updateMitigationAction
  ## Updates the definition for the specified mitigation action.
  ##   actionName: string (required)
  ##             : The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.
  ##   body: JObject (required)
  var path_613963 = newJObject()
  var body_613964 = newJObject()
  add(path_613963, "actionName", newJString(actionName))
  if body != nil:
    body_613964 = body
  result = call_613962.call(path_613963, nil, nil, nil, body_613964)

var updateMitigationAction* = Call_UpdateMitigationAction_613949(
    name: "updateMitigationAction", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_UpdateMitigationAction_613950, base: "/",
    url: url_UpdateMitigationAction_613951, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteMitigationAction_613935 = ref object of OpenApiRestCall_612658
proc url_DeleteMitigationAction_613937(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteMitigationAction_613936(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a defined mitigation action from your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The name of the mitigation action that you want to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_613938 = path.getOrDefault("actionName")
  valid_613938 = validateParameter(valid_613938, JString, required = true,
                                 default = nil)
  if valid_613938 != nil:
    section.add "actionName", valid_613938
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613939 = header.getOrDefault("X-Amz-Signature")
  valid_613939 = validateParameter(valid_613939, JString, required = false,
                                 default = nil)
  if valid_613939 != nil:
    section.add "X-Amz-Signature", valid_613939
  var valid_613940 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613940 = validateParameter(valid_613940, JString, required = false,
                                 default = nil)
  if valid_613940 != nil:
    section.add "X-Amz-Content-Sha256", valid_613940
  var valid_613941 = header.getOrDefault("X-Amz-Date")
  valid_613941 = validateParameter(valid_613941, JString, required = false,
                                 default = nil)
  if valid_613941 != nil:
    section.add "X-Amz-Date", valid_613941
  var valid_613942 = header.getOrDefault("X-Amz-Credential")
  valid_613942 = validateParameter(valid_613942, JString, required = false,
                                 default = nil)
  if valid_613942 != nil:
    section.add "X-Amz-Credential", valid_613942
  var valid_613943 = header.getOrDefault("X-Amz-Security-Token")
  valid_613943 = validateParameter(valid_613943, JString, required = false,
                                 default = nil)
  if valid_613943 != nil:
    section.add "X-Amz-Security-Token", valid_613943
  var valid_613944 = header.getOrDefault("X-Amz-Algorithm")
  valid_613944 = validateParameter(valid_613944, JString, required = false,
                                 default = nil)
  if valid_613944 != nil:
    section.add "X-Amz-Algorithm", valid_613944
  var valid_613945 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613945 = validateParameter(valid_613945, JString, required = false,
                                 default = nil)
  if valid_613945 != nil:
    section.add "X-Amz-SignedHeaders", valid_613945
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613946: Call_DeleteMitigationAction_613935; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a defined mitigation action from your AWS account.
  ## 
  let valid = call_613946.validator(path, query, header, formData, body)
  let scheme = call_613946.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613946.url(scheme.get, call_613946.host, call_613946.base,
                         call_613946.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613946, url, valid)

proc call*(call_613947: Call_DeleteMitigationAction_613935; actionName: string): Recallable =
  ## deleteMitigationAction
  ## Deletes a defined mitigation action from your AWS account.
  ##   actionName: string (required)
  ##             : The name of the mitigation action that you want to delete.
  var path_613948 = newJObject()
  add(path_613948, "actionName", newJString(actionName))
  result = call_613947.call(path_613948, nil, nil, nil, nil)

var deleteMitigationAction* = Call_DeleteMitigationAction_613935(
    name: "deleteMitigationAction", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_DeleteMitigationAction_613936, base: "/",
    url: url_DeleteMitigationAction_613937, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateOTAUpdate_613979 = ref object of OpenApiRestCall_612658
proc url_CreateOTAUpdate_613981(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateOTAUpdate_613980(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The ID of the OTA update to be created.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_613982 = path.getOrDefault("otaUpdateId")
  valid_613982 = validateParameter(valid_613982, JString, required = true,
                                 default = nil)
  if valid_613982 != nil:
    section.add "otaUpdateId", valid_613982
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613983 = header.getOrDefault("X-Amz-Signature")
  valid_613983 = validateParameter(valid_613983, JString, required = false,
                                 default = nil)
  if valid_613983 != nil:
    section.add "X-Amz-Signature", valid_613983
  var valid_613984 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613984 = validateParameter(valid_613984, JString, required = false,
                                 default = nil)
  if valid_613984 != nil:
    section.add "X-Amz-Content-Sha256", valid_613984
  var valid_613985 = header.getOrDefault("X-Amz-Date")
  valid_613985 = validateParameter(valid_613985, JString, required = false,
                                 default = nil)
  if valid_613985 != nil:
    section.add "X-Amz-Date", valid_613985
  var valid_613986 = header.getOrDefault("X-Amz-Credential")
  valid_613986 = validateParameter(valid_613986, JString, required = false,
                                 default = nil)
  if valid_613986 != nil:
    section.add "X-Amz-Credential", valid_613986
  var valid_613987 = header.getOrDefault("X-Amz-Security-Token")
  valid_613987 = validateParameter(valid_613987, JString, required = false,
                                 default = nil)
  if valid_613987 != nil:
    section.add "X-Amz-Security-Token", valid_613987
  var valid_613988 = header.getOrDefault("X-Amz-Algorithm")
  valid_613988 = validateParameter(valid_613988, JString, required = false,
                                 default = nil)
  if valid_613988 != nil:
    section.add "X-Amz-Algorithm", valid_613988
  var valid_613989 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613989 = validateParameter(valid_613989, JString, required = false,
                                 default = nil)
  if valid_613989 != nil:
    section.add "X-Amz-SignedHeaders", valid_613989
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613991: Call_CreateOTAUpdate_613979; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ## 
  let valid = call_613991.validator(path, query, header, formData, body)
  let scheme = call_613991.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613991.url(scheme.get, call_613991.host, call_613991.base,
                         call_613991.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613991, url, valid)

proc call*(call_613992: Call_CreateOTAUpdate_613979; body: JsonNode;
          otaUpdateId: string): Recallable =
  ## createOTAUpdate
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ##   body: JObject (required)
  ##   otaUpdateId: string (required)
  ##              : The ID of the OTA update to be created.
  var path_613993 = newJObject()
  var body_613994 = newJObject()
  if body != nil:
    body_613994 = body
  add(path_613993, "otaUpdateId", newJString(otaUpdateId))
  result = call_613992.call(path_613993, nil, nil, nil, body_613994)

var createOTAUpdate* = Call_CreateOTAUpdate_613979(name: "createOTAUpdate",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_CreateOTAUpdate_613980,
    base: "/", url: url_CreateOTAUpdate_613981, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetOTAUpdate_613965 = ref object of OpenApiRestCall_612658
proc url_GetOTAUpdate_613967(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOTAUpdate_613966(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets an OTA update.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The OTA update ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_613968 = path.getOrDefault("otaUpdateId")
  valid_613968 = validateParameter(valid_613968, JString, required = true,
                                 default = nil)
  if valid_613968 != nil:
    section.add "otaUpdateId", valid_613968
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613969 = header.getOrDefault("X-Amz-Signature")
  valid_613969 = validateParameter(valid_613969, JString, required = false,
                                 default = nil)
  if valid_613969 != nil:
    section.add "X-Amz-Signature", valid_613969
  var valid_613970 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613970 = validateParameter(valid_613970, JString, required = false,
                                 default = nil)
  if valid_613970 != nil:
    section.add "X-Amz-Content-Sha256", valid_613970
  var valid_613971 = header.getOrDefault("X-Amz-Date")
  valid_613971 = validateParameter(valid_613971, JString, required = false,
                                 default = nil)
  if valid_613971 != nil:
    section.add "X-Amz-Date", valid_613971
  var valid_613972 = header.getOrDefault("X-Amz-Credential")
  valid_613972 = validateParameter(valid_613972, JString, required = false,
                                 default = nil)
  if valid_613972 != nil:
    section.add "X-Amz-Credential", valid_613972
  var valid_613973 = header.getOrDefault("X-Amz-Security-Token")
  valid_613973 = validateParameter(valid_613973, JString, required = false,
                                 default = nil)
  if valid_613973 != nil:
    section.add "X-Amz-Security-Token", valid_613973
  var valid_613974 = header.getOrDefault("X-Amz-Algorithm")
  valid_613974 = validateParameter(valid_613974, JString, required = false,
                                 default = nil)
  if valid_613974 != nil:
    section.add "X-Amz-Algorithm", valid_613974
  var valid_613975 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613975 = validateParameter(valid_613975, JString, required = false,
                                 default = nil)
  if valid_613975 != nil:
    section.add "X-Amz-SignedHeaders", valid_613975
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613976: Call_GetOTAUpdate_613965; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets an OTA update.
  ## 
  let valid = call_613976.validator(path, query, header, formData, body)
  let scheme = call_613976.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613976.url(scheme.get, call_613976.host, call_613976.base,
                         call_613976.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613976, url, valid)

proc call*(call_613977: Call_GetOTAUpdate_613965; otaUpdateId: string): Recallable =
  ## getOTAUpdate
  ## Gets an OTA update.
  ##   otaUpdateId: string (required)
  ##              : The OTA update ID.
  var path_613978 = newJObject()
  add(path_613978, "otaUpdateId", newJString(otaUpdateId))
  result = call_613977.call(path_613978, nil, nil, nil, nil)

var getOTAUpdate* = Call_GetOTAUpdate_613965(name: "getOTAUpdate",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_GetOTAUpdate_613966,
    base: "/", url: url_GetOTAUpdate_613967, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteOTAUpdate_613995 = ref object of OpenApiRestCall_612658
proc url_DeleteOTAUpdate_613997(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOTAUpdate_613996(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Delete an OTA update.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The OTA update ID to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_613998 = path.getOrDefault("otaUpdateId")
  valid_613998 = validateParameter(valid_613998, JString, required = true,
                                 default = nil)
  if valid_613998 != nil:
    section.add "otaUpdateId", valid_613998
  result.add "path", section
  ## parameters in `query` object:
  ##   deleteStream: JBool
  ##               : Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.
  ##   forceDeleteAWSJob: JBool
  ##                    : Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.
  section = newJObject()
  var valid_613999 = query.getOrDefault("deleteStream")
  valid_613999 = validateParameter(valid_613999, JBool, required = false, default = nil)
  if valid_613999 != nil:
    section.add "deleteStream", valid_613999
  var valid_614000 = query.getOrDefault("forceDeleteAWSJob")
  valid_614000 = validateParameter(valid_614000, JBool, required = false, default = nil)
  if valid_614000 != nil:
    section.add "forceDeleteAWSJob", valid_614000
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614001 = header.getOrDefault("X-Amz-Signature")
  valid_614001 = validateParameter(valid_614001, JString, required = false,
                                 default = nil)
  if valid_614001 != nil:
    section.add "X-Amz-Signature", valid_614001
  var valid_614002 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614002 = validateParameter(valid_614002, JString, required = false,
                                 default = nil)
  if valid_614002 != nil:
    section.add "X-Amz-Content-Sha256", valid_614002
  var valid_614003 = header.getOrDefault("X-Amz-Date")
  valid_614003 = validateParameter(valid_614003, JString, required = false,
                                 default = nil)
  if valid_614003 != nil:
    section.add "X-Amz-Date", valid_614003
  var valid_614004 = header.getOrDefault("X-Amz-Credential")
  valid_614004 = validateParameter(valid_614004, JString, required = false,
                                 default = nil)
  if valid_614004 != nil:
    section.add "X-Amz-Credential", valid_614004
  var valid_614005 = header.getOrDefault("X-Amz-Security-Token")
  valid_614005 = validateParameter(valid_614005, JString, required = false,
                                 default = nil)
  if valid_614005 != nil:
    section.add "X-Amz-Security-Token", valid_614005
  var valid_614006 = header.getOrDefault("X-Amz-Algorithm")
  valid_614006 = validateParameter(valid_614006, JString, required = false,
                                 default = nil)
  if valid_614006 != nil:
    section.add "X-Amz-Algorithm", valid_614006
  var valid_614007 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614007 = validateParameter(valid_614007, JString, required = false,
                                 default = nil)
  if valid_614007 != nil:
    section.add "X-Amz-SignedHeaders", valid_614007
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614008: Call_DeleteOTAUpdate_613995; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete an OTA update.
  ## 
  let valid = call_614008.validator(path, query, header, formData, body)
  let scheme = call_614008.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614008.url(scheme.get, call_614008.host, call_614008.base,
                         call_614008.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614008, url, valid)

proc call*(call_614009: Call_DeleteOTAUpdate_613995; otaUpdateId: string;
          deleteStream: bool = false; forceDeleteAWSJob: bool = false): Recallable =
  ## deleteOTAUpdate
  ## Delete an OTA update.
  ##   deleteStream: bool
  ##               : Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.
  ##   otaUpdateId: string (required)
  ##              : The OTA update ID to delete.
  ##   forceDeleteAWSJob: bool
  ##                    : Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.
  var path_614010 = newJObject()
  var query_614011 = newJObject()
  add(query_614011, "deleteStream", newJBool(deleteStream))
  add(path_614010, "otaUpdateId", newJString(otaUpdateId))
  add(query_614011, "forceDeleteAWSJob", newJBool(forceDeleteAWSJob))
  result = call_614009.call(path_614010, query_614011, nil, nil, nil)

var deleteOTAUpdate* = Call_DeleteOTAUpdate_613995(name: "deleteOTAUpdate",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_DeleteOTAUpdate_613996,
    base: "/", url: url_DeleteOTAUpdate_613997, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreatePolicy_614026 = ref object of OpenApiRestCall_612658
proc url_CreatePolicy_614028(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreatePolicy_614027(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_614029 = path.getOrDefault("policyName")
  valid_614029 = validateParameter(valid_614029, JString, required = true,
                                 default = nil)
  if valid_614029 != nil:
    section.add "policyName", valid_614029
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614030 = header.getOrDefault("X-Amz-Signature")
  valid_614030 = validateParameter(valid_614030, JString, required = false,
                                 default = nil)
  if valid_614030 != nil:
    section.add "X-Amz-Signature", valid_614030
  var valid_614031 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614031 = validateParameter(valid_614031, JString, required = false,
                                 default = nil)
  if valid_614031 != nil:
    section.add "X-Amz-Content-Sha256", valid_614031
  var valid_614032 = header.getOrDefault("X-Amz-Date")
  valid_614032 = validateParameter(valid_614032, JString, required = false,
                                 default = nil)
  if valid_614032 != nil:
    section.add "X-Amz-Date", valid_614032
  var valid_614033 = header.getOrDefault("X-Amz-Credential")
  valid_614033 = validateParameter(valid_614033, JString, required = false,
                                 default = nil)
  if valid_614033 != nil:
    section.add "X-Amz-Credential", valid_614033
  var valid_614034 = header.getOrDefault("X-Amz-Security-Token")
  valid_614034 = validateParameter(valid_614034, JString, required = false,
                                 default = nil)
  if valid_614034 != nil:
    section.add "X-Amz-Security-Token", valid_614034
  var valid_614035 = header.getOrDefault("X-Amz-Algorithm")
  valid_614035 = validateParameter(valid_614035, JString, required = false,
                                 default = nil)
  if valid_614035 != nil:
    section.add "X-Amz-Algorithm", valid_614035
  var valid_614036 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614036 = validateParameter(valid_614036, JString, required = false,
                                 default = nil)
  if valid_614036 != nil:
    section.add "X-Amz-SignedHeaders", valid_614036
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614038: Call_CreatePolicy_614026; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ## 
  let valid = call_614038.validator(path, query, header, formData, body)
  let scheme = call_614038.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614038.url(scheme.get, call_614038.host, call_614038.base,
                         call_614038.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614038, url, valid)

proc call*(call_614039: Call_CreatePolicy_614026; policyName: string; body: JsonNode): Recallable =
  ## createPolicy
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ##   policyName: string (required)
  ##             : The policy name.
  ##   body: JObject (required)
  var path_614040 = newJObject()
  var body_614041 = newJObject()
  add(path_614040, "policyName", newJString(policyName))
  if body != nil:
    body_614041 = body
  result = call_614039.call(path_614040, nil, nil, nil, body_614041)

var createPolicy* = Call_CreatePolicy_614026(name: "createPolicy",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/policies/{policyName}", validator: validate_CreatePolicy_614027,
    base: "/", url: url_CreatePolicy_614028, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPolicy_614012 = ref object of OpenApiRestCall_612658
proc url_GetPolicy_614014(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetPolicy_614013(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the specified policy with the policy document of the default version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_614015 = path.getOrDefault("policyName")
  valid_614015 = validateParameter(valid_614015, JString, required = true,
                                 default = nil)
  if valid_614015 != nil:
    section.add "policyName", valid_614015
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614016 = header.getOrDefault("X-Amz-Signature")
  valid_614016 = validateParameter(valid_614016, JString, required = false,
                                 default = nil)
  if valid_614016 != nil:
    section.add "X-Amz-Signature", valid_614016
  var valid_614017 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614017 = validateParameter(valid_614017, JString, required = false,
                                 default = nil)
  if valid_614017 != nil:
    section.add "X-Amz-Content-Sha256", valid_614017
  var valid_614018 = header.getOrDefault("X-Amz-Date")
  valid_614018 = validateParameter(valid_614018, JString, required = false,
                                 default = nil)
  if valid_614018 != nil:
    section.add "X-Amz-Date", valid_614018
  var valid_614019 = header.getOrDefault("X-Amz-Credential")
  valid_614019 = validateParameter(valid_614019, JString, required = false,
                                 default = nil)
  if valid_614019 != nil:
    section.add "X-Amz-Credential", valid_614019
  var valid_614020 = header.getOrDefault("X-Amz-Security-Token")
  valid_614020 = validateParameter(valid_614020, JString, required = false,
                                 default = nil)
  if valid_614020 != nil:
    section.add "X-Amz-Security-Token", valid_614020
  var valid_614021 = header.getOrDefault("X-Amz-Algorithm")
  valid_614021 = validateParameter(valid_614021, JString, required = false,
                                 default = nil)
  if valid_614021 != nil:
    section.add "X-Amz-Algorithm", valid_614021
  var valid_614022 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614022 = validateParameter(valid_614022, JString, required = false,
                                 default = nil)
  if valid_614022 != nil:
    section.add "X-Amz-SignedHeaders", valid_614022
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614023: Call_GetPolicy_614012; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified policy with the policy document of the default version.
  ## 
  let valid = call_614023.validator(path, query, header, formData, body)
  let scheme = call_614023.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614023.url(scheme.get, call_614023.host, call_614023.base,
                         call_614023.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614023, url, valid)

proc call*(call_614024: Call_GetPolicy_614012; policyName: string): Recallable =
  ## getPolicy
  ## Gets information about the specified policy with the policy document of the default version.
  ##   policyName: string (required)
  ##             : The name of the policy.
  var path_614025 = newJObject()
  add(path_614025, "policyName", newJString(policyName))
  result = call_614024.call(path_614025, nil, nil, nil, nil)

var getPolicy* = Call_GetPolicy_614012(name: "getPolicy", meth: HttpMethod.HttpGet,
                                    host: "iot.amazonaws.com",
                                    route: "/policies/{policyName}",
                                    validator: validate_GetPolicy_614013,
                                    base: "/", url: url_GetPolicy_614014,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeletePolicy_614042 = ref object of OpenApiRestCall_612658
proc url_DeletePolicy_614044(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeletePolicy_614043(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_614045 = path.getOrDefault("policyName")
  valid_614045 = validateParameter(valid_614045, JString, required = true,
                                 default = nil)
  if valid_614045 != nil:
    section.add "policyName", valid_614045
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614046 = header.getOrDefault("X-Amz-Signature")
  valid_614046 = validateParameter(valid_614046, JString, required = false,
                                 default = nil)
  if valid_614046 != nil:
    section.add "X-Amz-Signature", valid_614046
  var valid_614047 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614047 = validateParameter(valid_614047, JString, required = false,
                                 default = nil)
  if valid_614047 != nil:
    section.add "X-Amz-Content-Sha256", valid_614047
  var valid_614048 = header.getOrDefault("X-Amz-Date")
  valid_614048 = validateParameter(valid_614048, JString, required = false,
                                 default = nil)
  if valid_614048 != nil:
    section.add "X-Amz-Date", valid_614048
  var valid_614049 = header.getOrDefault("X-Amz-Credential")
  valid_614049 = validateParameter(valid_614049, JString, required = false,
                                 default = nil)
  if valid_614049 != nil:
    section.add "X-Amz-Credential", valid_614049
  var valid_614050 = header.getOrDefault("X-Amz-Security-Token")
  valid_614050 = validateParameter(valid_614050, JString, required = false,
                                 default = nil)
  if valid_614050 != nil:
    section.add "X-Amz-Security-Token", valid_614050
  var valid_614051 = header.getOrDefault("X-Amz-Algorithm")
  valid_614051 = validateParameter(valid_614051, JString, required = false,
                                 default = nil)
  if valid_614051 != nil:
    section.add "X-Amz-Algorithm", valid_614051
  var valid_614052 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614052 = validateParameter(valid_614052, JString, required = false,
                                 default = nil)
  if valid_614052 != nil:
    section.add "X-Amz-SignedHeaders", valid_614052
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614053: Call_DeletePolicy_614042; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ## 
  let valid = call_614053.validator(path, query, header, formData, body)
  let scheme = call_614053.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614053.url(scheme.get, call_614053.host, call_614053.base,
                         call_614053.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614053, url, valid)

proc call*(call_614054: Call_DeletePolicy_614042; policyName: string): Recallable =
  ## deletePolicy
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ##   policyName: string (required)
  ##             : The name of the policy to delete.
  var path_614055 = newJObject()
  add(path_614055, "policyName", newJString(policyName))
  result = call_614054.call(path_614055, nil, nil, nil, nil)

var deletePolicy* = Call_DeletePolicy_614042(name: "deletePolicy",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/policies/{policyName}", validator: validate_DeletePolicy_614043,
    base: "/", url: url_DeletePolicy_614044, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreatePolicyVersion_614070 = ref object of OpenApiRestCall_612658
proc url_CreatePolicyVersion_614072(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreatePolicyVersion_614071(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_614073 = path.getOrDefault("policyName")
  valid_614073 = validateParameter(valid_614073, JString, required = true,
                                 default = nil)
  if valid_614073 != nil:
    section.add "policyName", valid_614073
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsDefault: JBool
  ##               : Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
  section = newJObject()
  var valid_614074 = query.getOrDefault("setAsDefault")
  valid_614074 = validateParameter(valid_614074, JBool, required = false, default = nil)
  if valid_614074 != nil:
    section.add "setAsDefault", valid_614074
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614075 = header.getOrDefault("X-Amz-Signature")
  valid_614075 = validateParameter(valid_614075, JString, required = false,
                                 default = nil)
  if valid_614075 != nil:
    section.add "X-Amz-Signature", valid_614075
  var valid_614076 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614076 = validateParameter(valid_614076, JString, required = false,
                                 default = nil)
  if valid_614076 != nil:
    section.add "X-Amz-Content-Sha256", valid_614076
  var valid_614077 = header.getOrDefault("X-Amz-Date")
  valid_614077 = validateParameter(valid_614077, JString, required = false,
                                 default = nil)
  if valid_614077 != nil:
    section.add "X-Amz-Date", valid_614077
  var valid_614078 = header.getOrDefault("X-Amz-Credential")
  valid_614078 = validateParameter(valid_614078, JString, required = false,
                                 default = nil)
  if valid_614078 != nil:
    section.add "X-Amz-Credential", valid_614078
  var valid_614079 = header.getOrDefault("X-Amz-Security-Token")
  valid_614079 = validateParameter(valid_614079, JString, required = false,
                                 default = nil)
  if valid_614079 != nil:
    section.add "X-Amz-Security-Token", valid_614079
  var valid_614080 = header.getOrDefault("X-Amz-Algorithm")
  valid_614080 = validateParameter(valid_614080, JString, required = false,
                                 default = nil)
  if valid_614080 != nil:
    section.add "X-Amz-Algorithm", valid_614080
  var valid_614081 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614081 = validateParameter(valid_614081, JString, required = false,
                                 default = nil)
  if valid_614081 != nil:
    section.add "X-Amz-SignedHeaders", valid_614081
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614083: Call_CreatePolicyVersion_614070; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ## 
  let valid = call_614083.validator(path, query, header, formData, body)
  let scheme = call_614083.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614083.url(scheme.get, call_614083.host, call_614083.base,
                         call_614083.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614083, url, valid)

proc call*(call_614084: Call_CreatePolicyVersion_614070; policyName: string;
          body: JsonNode; setAsDefault: bool = false): Recallable =
  ## createPolicyVersion
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ##   policyName: string (required)
  ##             : The policy name.
  ##   setAsDefault: bool
  ##               : Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
  ##   body: JObject (required)
  var path_614085 = newJObject()
  var query_614086 = newJObject()
  var body_614087 = newJObject()
  add(path_614085, "policyName", newJString(policyName))
  add(query_614086, "setAsDefault", newJBool(setAsDefault))
  if body != nil:
    body_614087 = body
  result = call_614084.call(path_614085, query_614086, nil, nil, body_614087)

var createPolicyVersion* = Call_CreatePolicyVersion_614070(
    name: "createPolicyVersion", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/policies/{policyName}/version",
    validator: validate_CreatePolicyVersion_614071, base: "/",
    url: url_CreatePolicyVersion_614072, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicyVersions_614056 = ref object of OpenApiRestCall_612658
proc url_ListPolicyVersions_614058(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListPolicyVersions_614057(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Lists the versions of the specified policy and identifies the default version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_614059 = path.getOrDefault("policyName")
  valid_614059 = validateParameter(valid_614059, JString, required = true,
                                 default = nil)
  if valid_614059 != nil:
    section.add "policyName", valid_614059
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614060 = header.getOrDefault("X-Amz-Signature")
  valid_614060 = validateParameter(valid_614060, JString, required = false,
                                 default = nil)
  if valid_614060 != nil:
    section.add "X-Amz-Signature", valid_614060
  var valid_614061 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614061 = validateParameter(valid_614061, JString, required = false,
                                 default = nil)
  if valid_614061 != nil:
    section.add "X-Amz-Content-Sha256", valid_614061
  var valid_614062 = header.getOrDefault("X-Amz-Date")
  valid_614062 = validateParameter(valid_614062, JString, required = false,
                                 default = nil)
  if valid_614062 != nil:
    section.add "X-Amz-Date", valid_614062
  var valid_614063 = header.getOrDefault("X-Amz-Credential")
  valid_614063 = validateParameter(valid_614063, JString, required = false,
                                 default = nil)
  if valid_614063 != nil:
    section.add "X-Amz-Credential", valid_614063
  var valid_614064 = header.getOrDefault("X-Amz-Security-Token")
  valid_614064 = validateParameter(valid_614064, JString, required = false,
                                 default = nil)
  if valid_614064 != nil:
    section.add "X-Amz-Security-Token", valid_614064
  var valid_614065 = header.getOrDefault("X-Amz-Algorithm")
  valid_614065 = validateParameter(valid_614065, JString, required = false,
                                 default = nil)
  if valid_614065 != nil:
    section.add "X-Amz-Algorithm", valid_614065
  var valid_614066 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614066 = validateParameter(valid_614066, JString, required = false,
                                 default = nil)
  if valid_614066 != nil:
    section.add "X-Amz-SignedHeaders", valid_614066
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614067: Call_ListPolicyVersions_614056; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the versions of the specified policy and identifies the default version.
  ## 
  let valid = call_614067.validator(path, query, header, formData, body)
  let scheme = call_614067.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614067.url(scheme.get, call_614067.host, call_614067.base,
                         call_614067.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614067, url, valid)

proc call*(call_614068: Call_ListPolicyVersions_614056; policyName: string): Recallable =
  ## listPolicyVersions
  ## Lists the versions of the specified policy and identifies the default version.
  ##   policyName: string (required)
  ##             : The policy name.
  var path_614069 = newJObject()
  add(path_614069, "policyName", newJString(policyName))
  result = call_614068.call(path_614069, nil, nil, nil, nil)

var listPolicyVersions* = Call_ListPolicyVersions_614056(
    name: "listPolicyVersions", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version",
    validator: validate_ListPolicyVersions_614057, base: "/",
    url: url_ListPolicyVersions_614058, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateProvisioningClaim_614088 = ref object of OpenApiRestCall_612658
proc url_CreateProvisioningClaim_614090(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/provisioning-claim")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateProvisioningClaim_614089(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a provisioning claim.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the provisioning template to use.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_614091 = path.getOrDefault("templateName")
  valid_614091 = validateParameter(valid_614091, JString, required = true,
                                 default = nil)
  if valid_614091 != nil:
    section.add "templateName", valid_614091
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614092 = header.getOrDefault("X-Amz-Signature")
  valid_614092 = validateParameter(valid_614092, JString, required = false,
                                 default = nil)
  if valid_614092 != nil:
    section.add "X-Amz-Signature", valid_614092
  var valid_614093 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614093 = validateParameter(valid_614093, JString, required = false,
                                 default = nil)
  if valid_614093 != nil:
    section.add "X-Amz-Content-Sha256", valid_614093
  var valid_614094 = header.getOrDefault("X-Amz-Date")
  valid_614094 = validateParameter(valid_614094, JString, required = false,
                                 default = nil)
  if valid_614094 != nil:
    section.add "X-Amz-Date", valid_614094
  var valid_614095 = header.getOrDefault("X-Amz-Credential")
  valid_614095 = validateParameter(valid_614095, JString, required = false,
                                 default = nil)
  if valid_614095 != nil:
    section.add "X-Amz-Credential", valid_614095
  var valid_614096 = header.getOrDefault("X-Amz-Security-Token")
  valid_614096 = validateParameter(valid_614096, JString, required = false,
                                 default = nil)
  if valid_614096 != nil:
    section.add "X-Amz-Security-Token", valid_614096
  var valid_614097 = header.getOrDefault("X-Amz-Algorithm")
  valid_614097 = validateParameter(valid_614097, JString, required = false,
                                 default = nil)
  if valid_614097 != nil:
    section.add "X-Amz-Algorithm", valid_614097
  var valid_614098 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614098 = validateParameter(valid_614098, JString, required = false,
                                 default = nil)
  if valid_614098 != nil:
    section.add "X-Amz-SignedHeaders", valid_614098
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614099: Call_CreateProvisioningClaim_614088; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a provisioning claim.
  ## 
  let valid = call_614099.validator(path, query, header, formData, body)
  let scheme = call_614099.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614099.url(scheme.get, call_614099.host, call_614099.base,
                         call_614099.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614099, url, valid)

proc call*(call_614100: Call_CreateProvisioningClaim_614088; templateName: string): Recallable =
  ## createProvisioningClaim
  ## Creates a provisioning claim.
  ##   templateName: string (required)
  ##               : The name of the provisioning template to use.
  var path_614101 = newJObject()
  add(path_614101, "templateName", newJString(templateName))
  result = call_614100.call(path_614101, nil, nil, nil, nil)

var createProvisioningClaim* = Call_CreateProvisioningClaim_614088(
    name: "createProvisioningClaim", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/provisioning-claim",
    validator: validate_CreateProvisioningClaim_614089, base: "/",
    url: url_CreateProvisioningClaim_614090, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateProvisioningTemplate_614117 = ref object of OpenApiRestCall_612658
proc url_CreateProvisioningTemplate_614119(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateProvisioningTemplate_614118(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614120 = header.getOrDefault("X-Amz-Signature")
  valid_614120 = validateParameter(valid_614120, JString, required = false,
                                 default = nil)
  if valid_614120 != nil:
    section.add "X-Amz-Signature", valid_614120
  var valid_614121 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614121 = validateParameter(valid_614121, JString, required = false,
                                 default = nil)
  if valid_614121 != nil:
    section.add "X-Amz-Content-Sha256", valid_614121
  var valid_614122 = header.getOrDefault("X-Amz-Date")
  valid_614122 = validateParameter(valid_614122, JString, required = false,
                                 default = nil)
  if valid_614122 != nil:
    section.add "X-Amz-Date", valid_614122
  var valid_614123 = header.getOrDefault("X-Amz-Credential")
  valid_614123 = validateParameter(valid_614123, JString, required = false,
                                 default = nil)
  if valid_614123 != nil:
    section.add "X-Amz-Credential", valid_614123
  var valid_614124 = header.getOrDefault("X-Amz-Security-Token")
  valid_614124 = validateParameter(valid_614124, JString, required = false,
                                 default = nil)
  if valid_614124 != nil:
    section.add "X-Amz-Security-Token", valid_614124
  var valid_614125 = header.getOrDefault("X-Amz-Algorithm")
  valid_614125 = validateParameter(valid_614125, JString, required = false,
                                 default = nil)
  if valid_614125 != nil:
    section.add "X-Amz-Algorithm", valid_614125
  var valid_614126 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614126 = validateParameter(valid_614126, JString, required = false,
                                 default = nil)
  if valid_614126 != nil:
    section.add "X-Amz-SignedHeaders", valid_614126
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614128: Call_CreateProvisioningTemplate_614117; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a fleet provisioning template.
  ## 
  let valid = call_614128.validator(path, query, header, formData, body)
  let scheme = call_614128.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614128.url(scheme.get, call_614128.host, call_614128.base,
                         call_614128.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614128, url, valid)

proc call*(call_614129: Call_CreateProvisioningTemplate_614117; body: JsonNode): Recallable =
  ## createProvisioningTemplate
  ## Creates a fleet provisioning template.
  ##   body: JObject (required)
  var body_614130 = newJObject()
  if body != nil:
    body_614130 = body
  result = call_614129.call(nil, nil, nil, nil, body_614130)

var createProvisioningTemplate* = Call_CreateProvisioningTemplate_614117(
    name: "createProvisioningTemplate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/provisioning-templates",
    validator: validate_CreateProvisioningTemplate_614118, base: "/",
    url: url_CreateProvisioningTemplate_614119,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListProvisioningTemplates_614102 = ref object of OpenApiRestCall_612658
proc url_ListProvisioningTemplates_614104(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListProvisioningTemplates_614103(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the fleet provisioning templates in your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_614105 = query.getOrDefault("nextToken")
  valid_614105 = validateParameter(valid_614105, JString, required = false,
                                 default = nil)
  if valid_614105 != nil:
    section.add "nextToken", valid_614105
  var valid_614106 = query.getOrDefault("maxResults")
  valid_614106 = validateParameter(valid_614106, JInt, required = false, default = nil)
  if valid_614106 != nil:
    section.add "maxResults", valid_614106
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614107 = header.getOrDefault("X-Amz-Signature")
  valid_614107 = validateParameter(valid_614107, JString, required = false,
                                 default = nil)
  if valid_614107 != nil:
    section.add "X-Amz-Signature", valid_614107
  var valid_614108 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614108 = validateParameter(valid_614108, JString, required = false,
                                 default = nil)
  if valid_614108 != nil:
    section.add "X-Amz-Content-Sha256", valid_614108
  var valid_614109 = header.getOrDefault("X-Amz-Date")
  valid_614109 = validateParameter(valid_614109, JString, required = false,
                                 default = nil)
  if valid_614109 != nil:
    section.add "X-Amz-Date", valid_614109
  var valid_614110 = header.getOrDefault("X-Amz-Credential")
  valid_614110 = validateParameter(valid_614110, JString, required = false,
                                 default = nil)
  if valid_614110 != nil:
    section.add "X-Amz-Credential", valid_614110
  var valid_614111 = header.getOrDefault("X-Amz-Security-Token")
  valid_614111 = validateParameter(valid_614111, JString, required = false,
                                 default = nil)
  if valid_614111 != nil:
    section.add "X-Amz-Security-Token", valid_614111
  var valid_614112 = header.getOrDefault("X-Amz-Algorithm")
  valid_614112 = validateParameter(valid_614112, JString, required = false,
                                 default = nil)
  if valid_614112 != nil:
    section.add "X-Amz-Algorithm", valid_614112
  var valid_614113 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614113 = validateParameter(valid_614113, JString, required = false,
                                 default = nil)
  if valid_614113 != nil:
    section.add "X-Amz-SignedHeaders", valid_614113
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614114: Call_ListProvisioningTemplates_614102; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the fleet provisioning templates in your AWS account.
  ## 
  let valid = call_614114.validator(path, query, header, formData, body)
  let scheme = call_614114.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614114.url(scheme.get, call_614114.host, call_614114.base,
                         call_614114.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614114, url, valid)

proc call*(call_614115: Call_ListProvisioningTemplates_614102;
          nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listProvisioningTemplates
  ## Lists the fleet provisioning templates in your AWS account.
  ##   nextToken: string
  ##            : A token to retrieve the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_614116 = newJObject()
  add(query_614116, "nextToken", newJString(nextToken))
  add(query_614116, "maxResults", newJInt(maxResults))
  result = call_614115.call(nil, query_614116, nil, nil, nil)

var listProvisioningTemplates* = Call_ListProvisioningTemplates_614102(
    name: "listProvisioningTemplates", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/provisioning-templates",
    validator: validate_ListProvisioningTemplates_614103, base: "/",
    url: url_ListProvisioningTemplates_614104,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateProvisioningTemplateVersion_614148 = ref object of OpenApiRestCall_612658
proc url_CreateProvisioningTemplateVersion_614150(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/versions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateProvisioningTemplateVersion_614149(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new version of a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_614151 = path.getOrDefault("templateName")
  valid_614151 = validateParameter(valid_614151, JString, required = true,
                                 default = nil)
  if valid_614151 != nil:
    section.add "templateName", valid_614151
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsDefault: JBool
  ##               : Sets a fleet provision template version as the default version.
  section = newJObject()
  var valid_614152 = query.getOrDefault("setAsDefault")
  valid_614152 = validateParameter(valid_614152, JBool, required = false, default = nil)
  if valid_614152 != nil:
    section.add "setAsDefault", valid_614152
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614153 = header.getOrDefault("X-Amz-Signature")
  valid_614153 = validateParameter(valid_614153, JString, required = false,
                                 default = nil)
  if valid_614153 != nil:
    section.add "X-Amz-Signature", valid_614153
  var valid_614154 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614154 = validateParameter(valid_614154, JString, required = false,
                                 default = nil)
  if valid_614154 != nil:
    section.add "X-Amz-Content-Sha256", valid_614154
  var valid_614155 = header.getOrDefault("X-Amz-Date")
  valid_614155 = validateParameter(valid_614155, JString, required = false,
                                 default = nil)
  if valid_614155 != nil:
    section.add "X-Amz-Date", valid_614155
  var valid_614156 = header.getOrDefault("X-Amz-Credential")
  valid_614156 = validateParameter(valid_614156, JString, required = false,
                                 default = nil)
  if valid_614156 != nil:
    section.add "X-Amz-Credential", valid_614156
  var valid_614157 = header.getOrDefault("X-Amz-Security-Token")
  valid_614157 = validateParameter(valid_614157, JString, required = false,
                                 default = nil)
  if valid_614157 != nil:
    section.add "X-Amz-Security-Token", valid_614157
  var valid_614158 = header.getOrDefault("X-Amz-Algorithm")
  valid_614158 = validateParameter(valid_614158, JString, required = false,
                                 default = nil)
  if valid_614158 != nil:
    section.add "X-Amz-Algorithm", valid_614158
  var valid_614159 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614159 = validateParameter(valid_614159, JString, required = false,
                                 default = nil)
  if valid_614159 != nil:
    section.add "X-Amz-SignedHeaders", valid_614159
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614161: Call_CreateProvisioningTemplateVersion_614148;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Creates a new version of a fleet provisioning template.
  ## 
  let valid = call_614161.validator(path, query, header, formData, body)
  let scheme = call_614161.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614161.url(scheme.get, call_614161.host, call_614161.base,
                         call_614161.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614161, url, valid)

proc call*(call_614162: Call_CreateProvisioningTemplateVersion_614148;
          body: JsonNode; templateName: string; setAsDefault: bool = false): Recallable =
  ## createProvisioningTemplateVersion
  ## Creates a new version of a fleet provisioning template.
  ##   setAsDefault: bool
  ##               : Sets a fleet provision template version as the default version.
  ##   body: JObject (required)
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template.
  var path_614163 = newJObject()
  var query_614164 = newJObject()
  var body_614165 = newJObject()
  add(query_614164, "setAsDefault", newJBool(setAsDefault))
  if body != nil:
    body_614165 = body
  add(path_614163, "templateName", newJString(templateName))
  result = call_614162.call(path_614163, query_614164, nil, nil, body_614165)

var createProvisioningTemplateVersion* = Call_CreateProvisioningTemplateVersion_614148(
    name: "createProvisioningTemplateVersion", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/versions",
    validator: validate_CreateProvisioningTemplateVersion_614149, base: "/",
    url: url_CreateProvisioningTemplateVersion_614150,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListProvisioningTemplateVersions_614131 = ref object of OpenApiRestCall_612658
proc url_ListProvisioningTemplateVersions_614133(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/versions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListProvisioningTemplateVersions_614132(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## A list of fleet provisioning template versions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_614134 = path.getOrDefault("templateName")
  valid_614134 = validateParameter(valid_614134, JString, required = true,
                                 default = nil)
  if valid_614134 != nil:
    section.add "templateName", valid_614134
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_614135 = query.getOrDefault("nextToken")
  valid_614135 = validateParameter(valid_614135, JString, required = false,
                                 default = nil)
  if valid_614135 != nil:
    section.add "nextToken", valid_614135
  var valid_614136 = query.getOrDefault("maxResults")
  valid_614136 = validateParameter(valid_614136, JInt, required = false, default = nil)
  if valid_614136 != nil:
    section.add "maxResults", valid_614136
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614137 = header.getOrDefault("X-Amz-Signature")
  valid_614137 = validateParameter(valid_614137, JString, required = false,
                                 default = nil)
  if valid_614137 != nil:
    section.add "X-Amz-Signature", valid_614137
  var valid_614138 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614138 = validateParameter(valid_614138, JString, required = false,
                                 default = nil)
  if valid_614138 != nil:
    section.add "X-Amz-Content-Sha256", valid_614138
  var valid_614139 = header.getOrDefault("X-Amz-Date")
  valid_614139 = validateParameter(valid_614139, JString, required = false,
                                 default = nil)
  if valid_614139 != nil:
    section.add "X-Amz-Date", valid_614139
  var valid_614140 = header.getOrDefault("X-Amz-Credential")
  valid_614140 = validateParameter(valid_614140, JString, required = false,
                                 default = nil)
  if valid_614140 != nil:
    section.add "X-Amz-Credential", valid_614140
  var valid_614141 = header.getOrDefault("X-Amz-Security-Token")
  valid_614141 = validateParameter(valid_614141, JString, required = false,
                                 default = nil)
  if valid_614141 != nil:
    section.add "X-Amz-Security-Token", valid_614141
  var valid_614142 = header.getOrDefault("X-Amz-Algorithm")
  valid_614142 = validateParameter(valid_614142, JString, required = false,
                                 default = nil)
  if valid_614142 != nil:
    section.add "X-Amz-Algorithm", valid_614142
  var valid_614143 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614143 = validateParameter(valid_614143, JString, required = false,
                                 default = nil)
  if valid_614143 != nil:
    section.add "X-Amz-SignedHeaders", valid_614143
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614144: Call_ListProvisioningTemplateVersions_614131;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## A list of fleet provisioning template versions.
  ## 
  let valid = call_614144.validator(path, query, header, formData, body)
  let scheme = call_614144.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614144.url(scheme.get, call_614144.host, call_614144.base,
                         call_614144.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614144, url, valid)

proc call*(call_614145: Call_ListProvisioningTemplateVersions_614131;
          templateName: string; nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listProvisioningTemplateVersions
  ## A list of fleet provisioning template versions.
  ##   nextToken: string
  ##            : A token to retrieve the next set of results.
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_614146 = newJObject()
  var query_614147 = newJObject()
  add(query_614147, "nextToken", newJString(nextToken))
  add(path_614146, "templateName", newJString(templateName))
  add(query_614147, "maxResults", newJInt(maxResults))
  result = call_614145.call(path_614146, query_614147, nil, nil, nil)

var listProvisioningTemplateVersions* = Call_ListProvisioningTemplateVersions_614131(
    name: "listProvisioningTemplateVersions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/versions",
    validator: validate_ListProvisioningTemplateVersions_614132, base: "/",
    url: url_ListProvisioningTemplateVersions_614133,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateRoleAlias_614180 = ref object of OpenApiRestCall_612658
proc url_UpdateRoleAlias_614182(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateRoleAlias_614181(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Updates a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_614183 = path.getOrDefault("roleAlias")
  valid_614183 = validateParameter(valid_614183, JString, required = true,
                                 default = nil)
  if valid_614183 != nil:
    section.add "roleAlias", valid_614183
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614184 = header.getOrDefault("X-Amz-Signature")
  valid_614184 = validateParameter(valid_614184, JString, required = false,
                                 default = nil)
  if valid_614184 != nil:
    section.add "X-Amz-Signature", valid_614184
  var valid_614185 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614185 = validateParameter(valid_614185, JString, required = false,
                                 default = nil)
  if valid_614185 != nil:
    section.add "X-Amz-Content-Sha256", valid_614185
  var valid_614186 = header.getOrDefault("X-Amz-Date")
  valid_614186 = validateParameter(valid_614186, JString, required = false,
                                 default = nil)
  if valid_614186 != nil:
    section.add "X-Amz-Date", valid_614186
  var valid_614187 = header.getOrDefault("X-Amz-Credential")
  valid_614187 = validateParameter(valid_614187, JString, required = false,
                                 default = nil)
  if valid_614187 != nil:
    section.add "X-Amz-Credential", valid_614187
  var valid_614188 = header.getOrDefault("X-Amz-Security-Token")
  valid_614188 = validateParameter(valid_614188, JString, required = false,
                                 default = nil)
  if valid_614188 != nil:
    section.add "X-Amz-Security-Token", valid_614188
  var valid_614189 = header.getOrDefault("X-Amz-Algorithm")
  valid_614189 = validateParameter(valid_614189, JString, required = false,
                                 default = nil)
  if valid_614189 != nil:
    section.add "X-Amz-Algorithm", valid_614189
  var valid_614190 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614190 = validateParameter(valid_614190, JString, required = false,
                                 default = nil)
  if valid_614190 != nil:
    section.add "X-Amz-SignedHeaders", valid_614190
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614192: Call_UpdateRoleAlias_614180; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a role alias.
  ## 
  let valid = call_614192.validator(path, query, header, formData, body)
  let scheme = call_614192.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614192.url(scheme.get, call_614192.host, call_614192.base,
                         call_614192.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614192, url, valid)

proc call*(call_614193: Call_UpdateRoleAlias_614180; roleAlias: string;
          body: JsonNode): Recallable =
  ## updateRoleAlias
  ## Updates a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias to update.
  ##   body: JObject (required)
  var path_614194 = newJObject()
  var body_614195 = newJObject()
  add(path_614194, "roleAlias", newJString(roleAlias))
  if body != nil:
    body_614195 = body
  result = call_614193.call(path_614194, nil, nil, nil, body_614195)

var updateRoleAlias* = Call_UpdateRoleAlias_614180(name: "updateRoleAlias",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_UpdateRoleAlias_614181,
    base: "/", url: url_UpdateRoleAlias_614182, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateRoleAlias_614196 = ref object of OpenApiRestCall_612658
proc url_CreateRoleAlias_614198(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateRoleAlias_614197(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias that points to a role ARN. This allows you to change the role without having to update the device.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_614199 = path.getOrDefault("roleAlias")
  valid_614199 = validateParameter(valid_614199, JString, required = true,
                                 default = nil)
  if valid_614199 != nil:
    section.add "roleAlias", valid_614199
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614200 = header.getOrDefault("X-Amz-Signature")
  valid_614200 = validateParameter(valid_614200, JString, required = false,
                                 default = nil)
  if valid_614200 != nil:
    section.add "X-Amz-Signature", valid_614200
  var valid_614201 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614201 = validateParameter(valid_614201, JString, required = false,
                                 default = nil)
  if valid_614201 != nil:
    section.add "X-Amz-Content-Sha256", valid_614201
  var valid_614202 = header.getOrDefault("X-Amz-Date")
  valid_614202 = validateParameter(valid_614202, JString, required = false,
                                 default = nil)
  if valid_614202 != nil:
    section.add "X-Amz-Date", valid_614202
  var valid_614203 = header.getOrDefault("X-Amz-Credential")
  valid_614203 = validateParameter(valid_614203, JString, required = false,
                                 default = nil)
  if valid_614203 != nil:
    section.add "X-Amz-Credential", valid_614203
  var valid_614204 = header.getOrDefault("X-Amz-Security-Token")
  valid_614204 = validateParameter(valid_614204, JString, required = false,
                                 default = nil)
  if valid_614204 != nil:
    section.add "X-Amz-Security-Token", valid_614204
  var valid_614205 = header.getOrDefault("X-Amz-Algorithm")
  valid_614205 = validateParameter(valid_614205, JString, required = false,
                                 default = nil)
  if valid_614205 != nil:
    section.add "X-Amz-Algorithm", valid_614205
  var valid_614206 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614206 = validateParameter(valid_614206, JString, required = false,
                                 default = nil)
  if valid_614206 != nil:
    section.add "X-Amz-SignedHeaders", valid_614206
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614208: Call_CreateRoleAlias_614196; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a role alias.
  ## 
  let valid = call_614208.validator(path, query, header, formData, body)
  let scheme = call_614208.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614208.url(scheme.get, call_614208.host, call_614208.base,
                         call_614208.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614208, url, valid)

proc call*(call_614209: Call_CreateRoleAlias_614196; roleAlias: string;
          body: JsonNode): Recallable =
  ## createRoleAlias
  ## Creates a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias that points to a role ARN. This allows you to change the role without having to update the device.
  ##   body: JObject (required)
  var path_614210 = newJObject()
  var body_614211 = newJObject()
  add(path_614210, "roleAlias", newJString(roleAlias))
  if body != nil:
    body_614211 = body
  result = call_614209.call(path_614210, nil, nil, nil, body_614211)

var createRoleAlias* = Call_CreateRoleAlias_614196(name: "createRoleAlias",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_CreateRoleAlias_614197,
    base: "/", url: url_CreateRoleAlias_614198, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeRoleAlias_614166 = ref object of OpenApiRestCall_612658
proc url_DescribeRoleAlias_614168(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeRoleAlias_614167(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Describes a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to describe.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_614169 = path.getOrDefault("roleAlias")
  valid_614169 = validateParameter(valid_614169, JString, required = true,
                                 default = nil)
  if valid_614169 != nil:
    section.add "roleAlias", valid_614169
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614170 = header.getOrDefault("X-Amz-Signature")
  valid_614170 = validateParameter(valid_614170, JString, required = false,
                                 default = nil)
  if valid_614170 != nil:
    section.add "X-Amz-Signature", valid_614170
  var valid_614171 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614171 = validateParameter(valid_614171, JString, required = false,
                                 default = nil)
  if valid_614171 != nil:
    section.add "X-Amz-Content-Sha256", valid_614171
  var valid_614172 = header.getOrDefault("X-Amz-Date")
  valid_614172 = validateParameter(valid_614172, JString, required = false,
                                 default = nil)
  if valid_614172 != nil:
    section.add "X-Amz-Date", valid_614172
  var valid_614173 = header.getOrDefault("X-Amz-Credential")
  valid_614173 = validateParameter(valid_614173, JString, required = false,
                                 default = nil)
  if valid_614173 != nil:
    section.add "X-Amz-Credential", valid_614173
  var valid_614174 = header.getOrDefault("X-Amz-Security-Token")
  valid_614174 = validateParameter(valid_614174, JString, required = false,
                                 default = nil)
  if valid_614174 != nil:
    section.add "X-Amz-Security-Token", valid_614174
  var valid_614175 = header.getOrDefault("X-Amz-Algorithm")
  valid_614175 = validateParameter(valid_614175, JString, required = false,
                                 default = nil)
  if valid_614175 != nil:
    section.add "X-Amz-Algorithm", valid_614175
  var valid_614176 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614176 = validateParameter(valid_614176, JString, required = false,
                                 default = nil)
  if valid_614176 != nil:
    section.add "X-Amz-SignedHeaders", valid_614176
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614177: Call_DescribeRoleAlias_614166; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a role alias.
  ## 
  let valid = call_614177.validator(path, query, header, formData, body)
  let scheme = call_614177.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614177.url(scheme.get, call_614177.host, call_614177.base,
                         call_614177.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614177, url, valid)

proc call*(call_614178: Call_DescribeRoleAlias_614166; roleAlias: string): Recallable =
  ## describeRoleAlias
  ## Describes a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias to describe.
  var path_614179 = newJObject()
  add(path_614179, "roleAlias", newJString(roleAlias))
  result = call_614178.call(path_614179, nil, nil, nil, nil)

var describeRoleAlias* = Call_DescribeRoleAlias_614166(name: "describeRoleAlias",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_DescribeRoleAlias_614167,
    base: "/", url: url_DescribeRoleAlias_614168,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRoleAlias_614212 = ref object of OpenApiRestCall_612658
proc url_DeleteRoleAlias_614214(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteRoleAlias_614213(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes a role alias
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_614215 = path.getOrDefault("roleAlias")
  valid_614215 = validateParameter(valid_614215, JString, required = true,
                                 default = nil)
  if valid_614215 != nil:
    section.add "roleAlias", valid_614215
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614216 = header.getOrDefault("X-Amz-Signature")
  valid_614216 = validateParameter(valid_614216, JString, required = false,
                                 default = nil)
  if valid_614216 != nil:
    section.add "X-Amz-Signature", valid_614216
  var valid_614217 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614217 = validateParameter(valid_614217, JString, required = false,
                                 default = nil)
  if valid_614217 != nil:
    section.add "X-Amz-Content-Sha256", valid_614217
  var valid_614218 = header.getOrDefault("X-Amz-Date")
  valid_614218 = validateParameter(valid_614218, JString, required = false,
                                 default = nil)
  if valid_614218 != nil:
    section.add "X-Amz-Date", valid_614218
  var valid_614219 = header.getOrDefault("X-Amz-Credential")
  valid_614219 = validateParameter(valid_614219, JString, required = false,
                                 default = nil)
  if valid_614219 != nil:
    section.add "X-Amz-Credential", valid_614219
  var valid_614220 = header.getOrDefault("X-Amz-Security-Token")
  valid_614220 = validateParameter(valid_614220, JString, required = false,
                                 default = nil)
  if valid_614220 != nil:
    section.add "X-Amz-Security-Token", valid_614220
  var valid_614221 = header.getOrDefault("X-Amz-Algorithm")
  valid_614221 = validateParameter(valid_614221, JString, required = false,
                                 default = nil)
  if valid_614221 != nil:
    section.add "X-Amz-Algorithm", valid_614221
  var valid_614222 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614222 = validateParameter(valid_614222, JString, required = false,
                                 default = nil)
  if valid_614222 != nil:
    section.add "X-Amz-SignedHeaders", valid_614222
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614223: Call_DeleteRoleAlias_614212; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a role alias
  ## 
  let valid = call_614223.validator(path, query, header, formData, body)
  let scheme = call_614223.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614223.url(scheme.get, call_614223.host, call_614223.base,
                         call_614223.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614223, url, valid)

proc call*(call_614224: Call_DeleteRoleAlias_614212; roleAlias: string): Recallable =
  ## deleteRoleAlias
  ## Deletes a role alias
  ##   roleAlias: string (required)
  ##            : The role alias to delete.
  var path_614225 = newJObject()
  add(path_614225, "roleAlias", newJString(roleAlias))
  result = call_614224.call(path_614225, nil, nil, nil, nil)

var deleteRoleAlias* = Call_DeleteRoleAlias_614212(name: "deleteRoleAlias",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_DeleteRoleAlias_614213,
    base: "/", url: url_DeleteRoleAlias_614214, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateScheduledAudit_614240 = ref object of OpenApiRestCall_612658
proc url_CreateScheduledAudit_614242(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateScheduledAudit_614241(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled audit that is run at a specified time interval.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name you want to give to the scheduled audit. (Max. 128 chars)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_614243 = path.getOrDefault("scheduledAuditName")
  valid_614243 = validateParameter(valid_614243, JString, required = true,
                                 default = nil)
  if valid_614243 != nil:
    section.add "scheduledAuditName", valid_614243
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614244 = header.getOrDefault("X-Amz-Signature")
  valid_614244 = validateParameter(valid_614244, JString, required = false,
                                 default = nil)
  if valid_614244 != nil:
    section.add "X-Amz-Signature", valid_614244
  var valid_614245 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614245 = validateParameter(valid_614245, JString, required = false,
                                 default = nil)
  if valid_614245 != nil:
    section.add "X-Amz-Content-Sha256", valid_614245
  var valid_614246 = header.getOrDefault("X-Amz-Date")
  valid_614246 = validateParameter(valid_614246, JString, required = false,
                                 default = nil)
  if valid_614246 != nil:
    section.add "X-Amz-Date", valid_614246
  var valid_614247 = header.getOrDefault("X-Amz-Credential")
  valid_614247 = validateParameter(valid_614247, JString, required = false,
                                 default = nil)
  if valid_614247 != nil:
    section.add "X-Amz-Credential", valid_614247
  var valid_614248 = header.getOrDefault("X-Amz-Security-Token")
  valid_614248 = validateParameter(valid_614248, JString, required = false,
                                 default = nil)
  if valid_614248 != nil:
    section.add "X-Amz-Security-Token", valid_614248
  var valid_614249 = header.getOrDefault("X-Amz-Algorithm")
  valid_614249 = validateParameter(valid_614249, JString, required = false,
                                 default = nil)
  if valid_614249 != nil:
    section.add "X-Amz-Algorithm", valid_614249
  var valid_614250 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614250 = validateParameter(valid_614250, JString, required = false,
                                 default = nil)
  if valid_614250 != nil:
    section.add "X-Amz-SignedHeaders", valid_614250
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614252: Call_CreateScheduledAudit_614240; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled audit that is run at a specified time interval.
  ## 
  let valid = call_614252.validator(path, query, header, formData, body)
  let scheme = call_614252.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614252.url(scheme.get, call_614252.host, call_614252.base,
                         call_614252.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614252, url, valid)

proc call*(call_614253: Call_CreateScheduledAudit_614240;
          scheduledAuditName: string; body: JsonNode): Recallable =
  ## createScheduledAudit
  ## Creates a scheduled audit that is run at a specified time interval.
  ##   scheduledAuditName: string (required)
  ##                     : The name you want to give to the scheduled audit. (Max. 128 chars)
  ##   body: JObject (required)
  var path_614254 = newJObject()
  var body_614255 = newJObject()
  add(path_614254, "scheduledAuditName", newJString(scheduledAuditName))
  if body != nil:
    body_614255 = body
  result = call_614253.call(path_614254, nil, nil, nil, body_614255)

var createScheduledAudit* = Call_CreateScheduledAudit_614240(
    name: "createScheduledAudit", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_CreateScheduledAudit_614241, base: "/",
    url: url_CreateScheduledAudit_614242, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeScheduledAudit_614226 = ref object of OpenApiRestCall_612658
proc url_DescribeScheduledAudit_614228(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeScheduledAudit_614227(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a scheduled audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit whose information you want to get.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_614229 = path.getOrDefault("scheduledAuditName")
  valid_614229 = validateParameter(valid_614229, JString, required = true,
                                 default = nil)
  if valid_614229 != nil:
    section.add "scheduledAuditName", valid_614229
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614230 = header.getOrDefault("X-Amz-Signature")
  valid_614230 = validateParameter(valid_614230, JString, required = false,
                                 default = nil)
  if valid_614230 != nil:
    section.add "X-Amz-Signature", valid_614230
  var valid_614231 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614231 = validateParameter(valid_614231, JString, required = false,
                                 default = nil)
  if valid_614231 != nil:
    section.add "X-Amz-Content-Sha256", valid_614231
  var valid_614232 = header.getOrDefault("X-Amz-Date")
  valid_614232 = validateParameter(valid_614232, JString, required = false,
                                 default = nil)
  if valid_614232 != nil:
    section.add "X-Amz-Date", valid_614232
  var valid_614233 = header.getOrDefault("X-Amz-Credential")
  valid_614233 = validateParameter(valid_614233, JString, required = false,
                                 default = nil)
  if valid_614233 != nil:
    section.add "X-Amz-Credential", valid_614233
  var valid_614234 = header.getOrDefault("X-Amz-Security-Token")
  valid_614234 = validateParameter(valid_614234, JString, required = false,
                                 default = nil)
  if valid_614234 != nil:
    section.add "X-Amz-Security-Token", valid_614234
  var valid_614235 = header.getOrDefault("X-Amz-Algorithm")
  valid_614235 = validateParameter(valid_614235, JString, required = false,
                                 default = nil)
  if valid_614235 != nil:
    section.add "X-Amz-Algorithm", valid_614235
  var valid_614236 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614236 = validateParameter(valid_614236, JString, required = false,
                                 default = nil)
  if valid_614236 != nil:
    section.add "X-Amz-SignedHeaders", valid_614236
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614237: Call_DescribeScheduledAudit_614226; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a scheduled audit.
  ## 
  let valid = call_614237.validator(path, query, header, formData, body)
  let scheme = call_614237.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614237.url(scheme.get, call_614237.host, call_614237.base,
                         call_614237.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614237, url, valid)

proc call*(call_614238: Call_DescribeScheduledAudit_614226;
          scheduledAuditName: string): Recallable =
  ## describeScheduledAudit
  ## Gets information about a scheduled audit.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit whose information you want to get.
  var path_614239 = newJObject()
  add(path_614239, "scheduledAuditName", newJString(scheduledAuditName))
  result = call_614238.call(path_614239, nil, nil, nil, nil)

var describeScheduledAudit* = Call_DescribeScheduledAudit_614226(
    name: "describeScheduledAudit", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_DescribeScheduledAudit_614227, base: "/",
    url: url_DescribeScheduledAudit_614228, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateScheduledAudit_614270 = ref object of OpenApiRestCall_612658
proc url_UpdateScheduledAudit_614272(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateScheduledAudit_614271(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit. (Max. 128 chars)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_614273 = path.getOrDefault("scheduledAuditName")
  valid_614273 = validateParameter(valid_614273, JString, required = true,
                                 default = nil)
  if valid_614273 != nil:
    section.add "scheduledAuditName", valid_614273
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614274 = header.getOrDefault("X-Amz-Signature")
  valid_614274 = validateParameter(valid_614274, JString, required = false,
                                 default = nil)
  if valid_614274 != nil:
    section.add "X-Amz-Signature", valid_614274
  var valid_614275 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614275 = validateParameter(valid_614275, JString, required = false,
                                 default = nil)
  if valid_614275 != nil:
    section.add "X-Amz-Content-Sha256", valid_614275
  var valid_614276 = header.getOrDefault("X-Amz-Date")
  valid_614276 = validateParameter(valid_614276, JString, required = false,
                                 default = nil)
  if valid_614276 != nil:
    section.add "X-Amz-Date", valid_614276
  var valid_614277 = header.getOrDefault("X-Amz-Credential")
  valid_614277 = validateParameter(valid_614277, JString, required = false,
                                 default = nil)
  if valid_614277 != nil:
    section.add "X-Amz-Credential", valid_614277
  var valid_614278 = header.getOrDefault("X-Amz-Security-Token")
  valid_614278 = validateParameter(valid_614278, JString, required = false,
                                 default = nil)
  if valid_614278 != nil:
    section.add "X-Amz-Security-Token", valid_614278
  var valid_614279 = header.getOrDefault("X-Amz-Algorithm")
  valid_614279 = validateParameter(valid_614279, JString, required = false,
                                 default = nil)
  if valid_614279 != nil:
    section.add "X-Amz-Algorithm", valid_614279
  var valid_614280 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614280 = validateParameter(valid_614280, JString, required = false,
                                 default = nil)
  if valid_614280 != nil:
    section.add "X-Amz-SignedHeaders", valid_614280
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614282: Call_UpdateScheduledAudit_614270; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ## 
  let valid = call_614282.validator(path, query, header, formData, body)
  let scheme = call_614282.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614282.url(scheme.get, call_614282.host, call_614282.base,
                         call_614282.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614282, url, valid)

proc call*(call_614283: Call_UpdateScheduledAudit_614270;
          scheduledAuditName: string; body: JsonNode): Recallable =
  ## updateScheduledAudit
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit. (Max. 128 chars)
  ##   body: JObject (required)
  var path_614284 = newJObject()
  var body_614285 = newJObject()
  add(path_614284, "scheduledAuditName", newJString(scheduledAuditName))
  if body != nil:
    body_614285 = body
  result = call_614283.call(path_614284, nil, nil, nil, body_614285)

var updateScheduledAudit* = Call_UpdateScheduledAudit_614270(
    name: "updateScheduledAudit", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_UpdateScheduledAudit_614271, base: "/",
    url: url_UpdateScheduledAudit_614272, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteScheduledAudit_614256 = ref object of OpenApiRestCall_612658
proc url_DeleteScheduledAudit_614258(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteScheduledAudit_614257(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit you want to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_614259 = path.getOrDefault("scheduledAuditName")
  valid_614259 = validateParameter(valid_614259, JString, required = true,
                                 default = nil)
  if valid_614259 != nil:
    section.add "scheduledAuditName", valid_614259
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614260 = header.getOrDefault("X-Amz-Signature")
  valid_614260 = validateParameter(valid_614260, JString, required = false,
                                 default = nil)
  if valid_614260 != nil:
    section.add "X-Amz-Signature", valid_614260
  var valid_614261 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614261 = validateParameter(valid_614261, JString, required = false,
                                 default = nil)
  if valid_614261 != nil:
    section.add "X-Amz-Content-Sha256", valid_614261
  var valid_614262 = header.getOrDefault("X-Amz-Date")
  valid_614262 = validateParameter(valid_614262, JString, required = false,
                                 default = nil)
  if valid_614262 != nil:
    section.add "X-Amz-Date", valid_614262
  var valid_614263 = header.getOrDefault("X-Amz-Credential")
  valid_614263 = validateParameter(valid_614263, JString, required = false,
                                 default = nil)
  if valid_614263 != nil:
    section.add "X-Amz-Credential", valid_614263
  var valid_614264 = header.getOrDefault("X-Amz-Security-Token")
  valid_614264 = validateParameter(valid_614264, JString, required = false,
                                 default = nil)
  if valid_614264 != nil:
    section.add "X-Amz-Security-Token", valid_614264
  var valid_614265 = header.getOrDefault("X-Amz-Algorithm")
  valid_614265 = validateParameter(valid_614265, JString, required = false,
                                 default = nil)
  if valid_614265 != nil:
    section.add "X-Amz-Algorithm", valid_614265
  var valid_614266 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614266 = validateParameter(valid_614266, JString, required = false,
                                 default = nil)
  if valid_614266 != nil:
    section.add "X-Amz-SignedHeaders", valid_614266
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614267: Call_DeleteScheduledAudit_614256; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled audit.
  ## 
  let valid = call_614267.validator(path, query, header, formData, body)
  let scheme = call_614267.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614267.url(scheme.get, call_614267.host, call_614267.base,
                         call_614267.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614267, url, valid)

proc call*(call_614268: Call_DeleteScheduledAudit_614256;
          scheduledAuditName: string): Recallable =
  ## deleteScheduledAudit
  ## Deletes a scheduled audit.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit you want to delete.
  var path_614269 = newJObject()
  add(path_614269, "scheduledAuditName", newJString(scheduledAuditName))
  result = call_614268.call(path_614269, nil, nil, nil, nil)

var deleteScheduledAudit* = Call_DeleteScheduledAudit_614256(
    name: "deleteScheduledAudit", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_DeleteScheduledAudit_614257, base: "/",
    url: url_DeleteScheduledAudit_614258, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateSecurityProfile_614300 = ref object of OpenApiRestCall_612658
proc url_CreateSecurityProfile_614302(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateSecurityProfile_614301(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name you are giving to the security profile.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_614303 = path.getOrDefault("securityProfileName")
  valid_614303 = validateParameter(valid_614303, JString, required = true,
                                 default = nil)
  if valid_614303 != nil:
    section.add "securityProfileName", valid_614303
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614304 = header.getOrDefault("X-Amz-Signature")
  valid_614304 = validateParameter(valid_614304, JString, required = false,
                                 default = nil)
  if valid_614304 != nil:
    section.add "X-Amz-Signature", valid_614304
  var valid_614305 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614305 = validateParameter(valid_614305, JString, required = false,
                                 default = nil)
  if valid_614305 != nil:
    section.add "X-Amz-Content-Sha256", valid_614305
  var valid_614306 = header.getOrDefault("X-Amz-Date")
  valid_614306 = validateParameter(valid_614306, JString, required = false,
                                 default = nil)
  if valid_614306 != nil:
    section.add "X-Amz-Date", valid_614306
  var valid_614307 = header.getOrDefault("X-Amz-Credential")
  valid_614307 = validateParameter(valid_614307, JString, required = false,
                                 default = nil)
  if valid_614307 != nil:
    section.add "X-Amz-Credential", valid_614307
  var valid_614308 = header.getOrDefault("X-Amz-Security-Token")
  valid_614308 = validateParameter(valid_614308, JString, required = false,
                                 default = nil)
  if valid_614308 != nil:
    section.add "X-Amz-Security-Token", valid_614308
  var valid_614309 = header.getOrDefault("X-Amz-Algorithm")
  valid_614309 = validateParameter(valid_614309, JString, required = false,
                                 default = nil)
  if valid_614309 != nil:
    section.add "X-Amz-Algorithm", valid_614309
  var valid_614310 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614310 = validateParameter(valid_614310, JString, required = false,
                                 default = nil)
  if valid_614310 != nil:
    section.add "X-Amz-SignedHeaders", valid_614310
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614312: Call_CreateSecurityProfile_614300; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Device Defender security profile.
  ## 
  let valid = call_614312.validator(path, query, header, formData, body)
  let scheme = call_614312.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614312.url(scheme.get, call_614312.host, call_614312.base,
                         call_614312.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614312, url, valid)

proc call*(call_614313: Call_CreateSecurityProfile_614300; body: JsonNode;
          securityProfileName: string): Recallable =
  ## createSecurityProfile
  ## Creates a Device Defender security profile.
  ##   body: JObject (required)
  ##   securityProfileName: string (required)
  ##                      : The name you are giving to the security profile.
  var path_614314 = newJObject()
  var body_614315 = newJObject()
  if body != nil:
    body_614315 = body
  add(path_614314, "securityProfileName", newJString(securityProfileName))
  result = call_614313.call(path_614314, nil, nil, nil, body_614315)

var createSecurityProfile* = Call_CreateSecurityProfile_614300(
    name: "createSecurityProfile", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_CreateSecurityProfile_614301, base: "/",
    url: url_CreateSecurityProfile_614302, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeSecurityProfile_614286 = ref object of OpenApiRestCall_612658
proc url_DescribeSecurityProfile_614288(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeSecurityProfile_614287(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile whose information you want to get.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_614289 = path.getOrDefault("securityProfileName")
  valid_614289 = validateParameter(valid_614289, JString, required = true,
                                 default = nil)
  if valid_614289 != nil:
    section.add "securityProfileName", valid_614289
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614290 = header.getOrDefault("X-Amz-Signature")
  valid_614290 = validateParameter(valid_614290, JString, required = false,
                                 default = nil)
  if valid_614290 != nil:
    section.add "X-Amz-Signature", valid_614290
  var valid_614291 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614291 = validateParameter(valid_614291, JString, required = false,
                                 default = nil)
  if valid_614291 != nil:
    section.add "X-Amz-Content-Sha256", valid_614291
  var valid_614292 = header.getOrDefault("X-Amz-Date")
  valid_614292 = validateParameter(valid_614292, JString, required = false,
                                 default = nil)
  if valid_614292 != nil:
    section.add "X-Amz-Date", valid_614292
  var valid_614293 = header.getOrDefault("X-Amz-Credential")
  valid_614293 = validateParameter(valid_614293, JString, required = false,
                                 default = nil)
  if valid_614293 != nil:
    section.add "X-Amz-Credential", valid_614293
  var valid_614294 = header.getOrDefault("X-Amz-Security-Token")
  valid_614294 = validateParameter(valid_614294, JString, required = false,
                                 default = nil)
  if valid_614294 != nil:
    section.add "X-Amz-Security-Token", valid_614294
  var valid_614295 = header.getOrDefault("X-Amz-Algorithm")
  valid_614295 = validateParameter(valid_614295, JString, required = false,
                                 default = nil)
  if valid_614295 != nil:
    section.add "X-Amz-Algorithm", valid_614295
  var valid_614296 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614296 = validateParameter(valid_614296, JString, required = false,
                                 default = nil)
  if valid_614296 != nil:
    section.add "X-Amz-SignedHeaders", valid_614296
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614297: Call_DescribeSecurityProfile_614286; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a Device Defender security profile.
  ## 
  let valid = call_614297.validator(path, query, header, formData, body)
  let scheme = call_614297.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614297.url(scheme.get, call_614297.host, call_614297.base,
                         call_614297.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614297, url, valid)

proc call*(call_614298: Call_DescribeSecurityProfile_614286;
          securityProfileName: string): Recallable =
  ## describeSecurityProfile
  ## Gets information about a Device Defender security profile.
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile whose information you want to get.
  var path_614299 = newJObject()
  add(path_614299, "securityProfileName", newJString(securityProfileName))
  result = call_614298.call(path_614299, nil, nil, nil, nil)

var describeSecurityProfile* = Call_DescribeSecurityProfile_614286(
    name: "describeSecurityProfile", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_DescribeSecurityProfile_614287, base: "/",
    url: url_DescribeSecurityProfile_614288, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateSecurityProfile_614332 = ref object of OpenApiRestCall_612658
proc url_UpdateSecurityProfile_614334(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateSecurityProfile_614333(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile you want to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_614335 = path.getOrDefault("securityProfileName")
  valid_614335 = validateParameter(valid_614335, JString, required = true,
                                 default = nil)
  if valid_614335 != nil:
    section.add "securityProfileName", valid_614335
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  section = newJObject()
  var valid_614336 = query.getOrDefault("expectedVersion")
  valid_614336 = validateParameter(valid_614336, JInt, required = false, default = nil)
  if valid_614336 != nil:
    section.add "expectedVersion", valid_614336
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614337 = header.getOrDefault("X-Amz-Signature")
  valid_614337 = validateParameter(valid_614337, JString, required = false,
                                 default = nil)
  if valid_614337 != nil:
    section.add "X-Amz-Signature", valid_614337
  var valid_614338 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614338 = validateParameter(valid_614338, JString, required = false,
                                 default = nil)
  if valid_614338 != nil:
    section.add "X-Amz-Content-Sha256", valid_614338
  var valid_614339 = header.getOrDefault("X-Amz-Date")
  valid_614339 = validateParameter(valid_614339, JString, required = false,
                                 default = nil)
  if valid_614339 != nil:
    section.add "X-Amz-Date", valid_614339
  var valid_614340 = header.getOrDefault("X-Amz-Credential")
  valid_614340 = validateParameter(valid_614340, JString, required = false,
                                 default = nil)
  if valid_614340 != nil:
    section.add "X-Amz-Credential", valid_614340
  var valid_614341 = header.getOrDefault("X-Amz-Security-Token")
  valid_614341 = validateParameter(valid_614341, JString, required = false,
                                 default = nil)
  if valid_614341 != nil:
    section.add "X-Amz-Security-Token", valid_614341
  var valid_614342 = header.getOrDefault("X-Amz-Algorithm")
  valid_614342 = validateParameter(valid_614342, JString, required = false,
                                 default = nil)
  if valid_614342 != nil:
    section.add "X-Amz-Algorithm", valid_614342
  var valid_614343 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614343 = validateParameter(valid_614343, JString, required = false,
                                 default = nil)
  if valid_614343 != nil:
    section.add "X-Amz-SignedHeaders", valid_614343
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614345: Call_UpdateSecurityProfile_614332; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a Device Defender security profile.
  ## 
  let valid = call_614345.validator(path, query, header, formData, body)
  let scheme = call_614345.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614345.url(scheme.get, call_614345.host, call_614345.base,
                         call_614345.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614345, url, valid)

proc call*(call_614346: Call_UpdateSecurityProfile_614332; body: JsonNode;
          securityProfileName: string; expectedVersion: int = 0): Recallable =
  ## updateSecurityProfile
  ## Updates a Device Defender security profile.
  ##   expectedVersion: int
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  ##   body: JObject (required)
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile you want to update.
  var path_614347 = newJObject()
  var query_614348 = newJObject()
  var body_614349 = newJObject()
  add(query_614348, "expectedVersion", newJInt(expectedVersion))
  if body != nil:
    body_614349 = body
  add(path_614347, "securityProfileName", newJString(securityProfileName))
  result = call_614346.call(path_614347, query_614348, nil, nil, body_614349)

var updateSecurityProfile* = Call_UpdateSecurityProfile_614332(
    name: "updateSecurityProfile", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_UpdateSecurityProfile_614333, base: "/",
    url: url_UpdateSecurityProfile_614334, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteSecurityProfile_614316 = ref object of OpenApiRestCall_612658
proc url_DeleteSecurityProfile_614318(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteSecurityProfile_614317(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile to be deleted.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_614319 = path.getOrDefault("securityProfileName")
  valid_614319 = validateParameter(valid_614319, JString, required = true,
                                 default = nil)
  if valid_614319 != nil:
    section.add "securityProfileName", valid_614319
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  section = newJObject()
  var valid_614320 = query.getOrDefault("expectedVersion")
  valid_614320 = validateParameter(valid_614320, JInt, required = false, default = nil)
  if valid_614320 != nil:
    section.add "expectedVersion", valid_614320
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614321 = header.getOrDefault("X-Amz-Signature")
  valid_614321 = validateParameter(valid_614321, JString, required = false,
                                 default = nil)
  if valid_614321 != nil:
    section.add "X-Amz-Signature", valid_614321
  var valid_614322 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614322 = validateParameter(valid_614322, JString, required = false,
                                 default = nil)
  if valid_614322 != nil:
    section.add "X-Amz-Content-Sha256", valid_614322
  var valid_614323 = header.getOrDefault("X-Amz-Date")
  valid_614323 = validateParameter(valid_614323, JString, required = false,
                                 default = nil)
  if valid_614323 != nil:
    section.add "X-Amz-Date", valid_614323
  var valid_614324 = header.getOrDefault("X-Amz-Credential")
  valid_614324 = validateParameter(valid_614324, JString, required = false,
                                 default = nil)
  if valid_614324 != nil:
    section.add "X-Amz-Credential", valid_614324
  var valid_614325 = header.getOrDefault("X-Amz-Security-Token")
  valid_614325 = validateParameter(valid_614325, JString, required = false,
                                 default = nil)
  if valid_614325 != nil:
    section.add "X-Amz-Security-Token", valid_614325
  var valid_614326 = header.getOrDefault("X-Amz-Algorithm")
  valid_614326 = validateParameter(valid_614326, JString, required = false,
                                 default = nil)
  if valid_614326 != nil:
    section.add "X-Amz-Algorithm", valid_614326
  var valid_614327 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614327 = validateParameter(valid_614327, JString, required = false,
                                 default = nil)
  if valid_614327 != nil:
    section.add "X-Amz-SignedHeaders", valid_614327
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614328: Call_DeleteSecurityProfile_614316; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a Device Defender security profile.
  ## 
  let valid = call_614328.validator(path, query, header, formData, body)
  let scheme = call_614328.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614328.url(scheme.get, call_614328.host, call_614328.base,
                         call_614328.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614328, url, valid)

proc call*(call_614329: Call_DeleteSecurityProfile_614316;
          securityProfileName: string; expectedVersion: int = 0): Recallable =
  ## deleteSecurityProfile
  ## Deletes a Device Defender security profile.
  ##   expectedVersion: int
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile to be deleted.
  var path_614330 = newJObject()
  var query_614331 = newJObject()
  add(query_614331, "expectedVersion", newJInt(expectedVersion))
  add(path_614330, "securityProfileName", newJString(securityProfileName))
  result = call_614329.call(path_614330, query_614331, nil, nil, nil)

var deleteSecurityProfile* = Call_DeleteSecurityProfile_614316(
    name: "deleteSecurityProfile", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_DeleteSecurityProfile_614317, base: "/",
    url: url_DeleteSecurityProfile_614318, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateStream_614364 = ref object of OpenApiRestCall_612658
proc url_UpdateStream_614366(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateStream_614365(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing stream. The stream version will be incremented by one.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_614367 = path.getOrDefault("streamId")
  valid_614367 = validateParameter(valid_614367, JString, required = true,
                                 default = nil)
  if valid_614367 != nil:
    section.add "streamId", valid_614367
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614368 = header.getOrDefault("X-Amz-Signature")
  valid_614368 = validateParameter(valid_614368, JString, required = false,
                                 default = nil)
  if valid_614368 != nil:
    section.add "X-Amz-Signature", valid_614368
  var valid_614369 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614369 = validateParameter(valid_614369, JString, required = false,
                                 default = nil)
  if valid_614369 != nil:
    section.add "X-Amz-Content-Sha256", valid_614369
  var valid_614370 = header.getOrDefault("X-Amz-Date")
  valid_614370 = validateParameter(valid_614370, JString, required = false,
                                 default = nil)
  if valid_614370 != nil:
    section.add "X-Amz-Date", valid_614370
  var valid_614371 = header.getOrDefault("X-Amz-Credential")
  valid_614371 = validateParameter(valid_614371, JString, required = false,
                                 default = nil)
  if valid_614371 != nil:
    section.add "X-Amz-Credential", valid_614371
  var valid_614372 = header.getOrDefault("X-Amz-Security-Token")
  valid_614372 = validateParameter(valid_614372, JString, required = false,
                                 default = nil)
  if valid_614372 != nil:
    section.add "X-Amz-Security-Token", valid_614372
  var valid_614373 = header.getOrDefault("X-Amz-Algorithm")
  valid_614373 = validateParameter(valid_614373, JString, required = false,
                                 default = nil)
  if valid_614373 != nil:
    section.add "X-Amz-Algorithm", valid_614373
  var valid_614374 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614374 = validateParameter(valid_614374, JString, required = false,
                                 default = nil)
  if valid_614374 != nil:
    section.add "X-Amz-SignedHeaders", valid_614374
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614376: Call_UpdateStream_614364; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing stream. The stream version will be incremented by one.
  ## 
  let valid = call_614376.validator(path, query, header, formData, body)
  let scheme = call_614376.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614376.url(scheme.get, call_614376.host, call_614376.base,
                         call_614376.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614376, url, valid)

proc call*(call_614377: Call_UpdateStream_614364; streamId: string; body: JsonNode): Recallable =
  ## updateStream
  ## Updates an existing stream. The stream version will be incremented by one.
  ##   streamId: string (required)
  ##           : The stream ID.
  ##   body: JObject (required)
  var path_614378 = newJObject()
  var body_614379 = newJObject()
  add(path_614378, "streamId", newJString(streamId))
  if body != nil:
    body_614379 = body
  result = call_614377.call(path_614378, nil, nil, nil, body_614379)

var updateStream* = Call_UpdateStream_614364(name: "updateStream",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_UpdateStream_614365,
    base: "/", url: url_UpdateStream_614366, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateStream_614380 = ref object of OpenApiRestCall_612658
proc url_CreateStream_614382(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateStream_614381(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_614383 = path.getOrDefault("streamId")
  valid_614383 = validateParameter(valid_614383, JString, required = true,
                                 default = nil)
  if valid_614383 != nil:
    section.add "streamId", valid_614383
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614384 = header.getOrDefault("X-Amz-Signature")
  valid_614384 = validateParameter(valid_614384, JString, required = false,
                                 default = nil)
  if valid_614384 != nil:
    section.add "X-Amz-Signature", valid_614384
  var valid_614385 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614385 = validateParameter(valid_614385, JString, required = false,
                                 default = nil)
  if valid_614385 != nil:
    section.add "X-Amz-Content-Sha256", valid_614385
  var valid_614386 = header.getOrDefault("X-Amz-Date")
  valid_614386 = validateParameter(valid_614386, JString, required = false,
                                 default = nil)
  if valid_614386 != nil:
    section.add "X-Amz-Date", valid_614386
  var valid_614387 = header.getOrDefault("X-Amz-Credential")
  valid_614387 = validateParameter(valid_614387, JString, required = false,
                                 default = nil)
  if valid_614387 != nil:
    section.add "X-Amz-Credential", valid_614387
  var valid_614388 = header.getOrDefault("X-Amz-Security-Token")
  valid_614388 = validateParameter(valid_614388, JString, required = false,
                                 default = nil)
  if valid_614388 != nil:
    section.add "X-Amz-Security-Token", valid_614388
  var valid_614389 = header.getOrDefault("X-Amz-Algorithm")
  valid_614389 = validateParameter(valid_614389, JString, required = false,
                                 default = nil)
  if valid_614389 != nil:
    section.add "X-Amz-Algorithm", valid_614389
  var valid_614390 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614390 = validateParameter(valid_614390, JString, required = false,
                                 default = nil)
  if valid_614390 != nil:
    section.add "X-Amz-SignedHeaders", valid_614390
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614392: Call_CreateStream_614380; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.
  ## 
  let valid = call_614392.validator(path, query, header, formData, body)
  let scheme = call_614392.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614392.url(scheme.get, call_614392.host, call_614392.base,
                         call_614392.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614392, url, valid)

proc call*(call_614393: Call_CreateStream_614380; streamId: string; body: JsonNode): Recallable =
  ## createStream
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  ##   body: JObject (required)
  var path_614394 = newJObject()
  var body_614395 = newJObject()
  add(path_614394, "streamId", newJString(streamId))
  if body != nil:
    body_614395 = body
  result = call_614393.call(path_614394, nil, nil, nil, body_614395)

var createStream* = Call_CreateStream_614380(name: "createStream",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_CreateStream_614381,
    base: "/", url: url_CreateStream_614382, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeStream_614350 = ref object of OpenApiRestCall_612658
proc url_DescribeStream_614352(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeStream_614351(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets information about a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_614353 = path.getOrDefault("streamId")
  valid_614353 = validateParameter(valid_614353, JString, required = true,
                                 default = nil)
  if valid_614353 != nil:
    section.add "streamId", valid_614353
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614354 = header.getOrDefault("X-Amz-Signature")
  valid_614354 = validateParameter(valid_614354, JString, required = false,
                                 default = nil)
  if valid_614354 != nil:
    section.add "X-Amz-Signature", valid_614354
  var valid_614355 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614355 = validateParameter(valid_614355, JString, required = false,
                                 default = nil)
  if valid_614355 != nil:
    section.add "X-Amz-Content-Sha256", valid_614355
  var valid_614356 = header.getOrDefault("X-Amz-Date")
  valid_614356 = validateParameter(valid_614356, JString, required = false,
                                 default = nil)
  if valid_614356 != nil:
    section.add "X-Amz-Date", valid_614356
  var valid_614357 = header.getOrDefault("X-Amz-Credential")
  valid_614357 = validateParameter(valid_614357, JString, required = false,
                                 default = nil)
  if valid_614357 != nil:
    section.add "X-Amz-Credential", valid_614357
  var valid_614358 = header.getOrDefault("X-Amz-Security-Token")
  valid_614358 = validateParameter(valid_614358, JString, required = false,
                                 default = nil)
  if valid_614358 != nil:
    section.add "X-Amz-Security-Token", valid_614358
  var valid_614359 = header.getOrDefault("X-Amz-Algorithm")
  valid_614359 = validateParameter(valid_614359, JString, required = false,
                                 default = nil)
  if valid_614359 != nil:
    section.add "X-Amz-Algorithm", valid_614359
  var valid_614360 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614360 = validateParameter(valid_614360, JString, required = false,
                                 default = nil)
  if valid_614360 != nil:
    section.add "X-Amz-SignedHeaders", valid_614360
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614361: Call_DescribeStream_614350; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a stream.
  ## 
  let valid = call_614361.validator(path, query, header, formData, body)
  let scheme = call_614361.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614361.url(scheme.get, call_614361.host, call_614361.base,
                         call_614361.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614361, url, valid)

proc call*(call_614362: Call_DescribeStream_614350; streamId: string): Recallable =
  ## describeStream
  ## Gets information about a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_614363 = newJObject()
  add(path_614363, "streamId", newJString(streamId))
  result = call_614362.call(path_614363, nil, nil, nil, nil)

var describeStream* = Call_DescribeStream_614350(name: "describeStream",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_DescribeStream_614351,
    base: "/", url: url_DescribeStream_614352, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteStream_614396 = ref object of OpenApiRestCall_612658
proc url_DeleteStream_614398(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteStream_614397(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_614399 = path.getOrDefault("streamId")
  valid_614399 = validateParameter(valid_614399, JString, required = true,
                                 default = nil)
  if valid_614399 != nil:
    section.add "streamId", valid_614399
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614400 = header.getOrDefault("X-Amz-Signature")
  valid_614400 = validateParameter(valid_614400, JString, required = false,
                                 default = nil)
  if valid_614400 != nil:
    section.add "X-Amz-Signature", valid_614400
  var valid_614401 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614401 = validateParameter(valid_614401, JString, required = false,
                                 default = nil)
  if valid_614401 != nil:
    section.add "X-Amz-Content-Sha256", valid_614401
  var valid_614402 = header.getOrDefault("X-Amz-Date")
  valid_614402 = validateParameter(valid_614402, JString, required = false,
                                 default = nil)
  if valid_614402 != nil:
    section.add "X-Amz-Date", valid_614402
  var valid_614403 = header.getOrDefault("X-Amz-Credential")
  valid_614403 = validateParameter(valid_614403, JString, required = false,
                                 default = nil)
  if valid_614403 != nil:
    section.add "X-Amz-Credential", valid_614403
  var valid_614404 = header.getOrDefault("X-Amz-Security-Token")
  valid_614404 = validateParameter(valid_614404, JString, required = false,
                                 default = nil)
  if valid_614404 != nil:
    section.add "X-Amz-Security-Token", valid_614404
  var valid_614405 = header.getOrDefault("X-Amz-Algorithm")
  valid_614405 = validateParameter(valid_614405, JString, required = false,
                                 default = nil)
  if valid_614405 != nil:
    section.add "X-Amz-Algorithm", valid_614405
  var valid_614406 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614406 = validateParameter(valid_614406, JString, required = false,
                                 default = nil)
  if valid_614406 != nil:
    section.add "X-Amz-SignedHeaders", valid_614406
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614407: Call_DeleteStream_614396; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a stream.
  ## 
  let valid = call_614407.validator(path, query, header, formData, body)
  let scheme = call_614407.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614407.url(scheme.get, call_614407.host, call_614407.base,
                         call_614407.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614407, url, valid)

proc call*(call_614408: Call_DeleteStream_614396; streamId: string): Recallable =
  ## deleteStream
  ## Deletes a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_614409 = newJObject()
  add(path_614409, "streamId", newJString(streamId))
  result = call_614408.call(path_614409, nil, nil, nil, nil)

var deleteStream* = Call_DeleteStream_614396(name: "deleteStream",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_DeleteStream_614397,
    base: "/", url: url_DeleteStream_614398, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThing_614424 = ref object of OpenApiRestCall_612658
proc url_CreateThing_614426(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateThing_614425(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to create.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_614427 = path.getOrDefault("thingName")
  valid_614427 = validateParameter(valid_614427, JString, required = true,
                                 default = nil)
  if valid_614427 != nil:
    section.add "thingName", valid_614427
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614428 = header.getOrDefault("X-Amz-Signature")
  valid_614428 = validateParameter(valid_614428, JString, required = false,
                                 default = nil)
  if valid_614428 != nil:
    section.add "X-Amz-Signature", valid_614428
  var valid_614429 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614429 = validateParameter(valid_614429, JString, required = false,
                                 default = nil)
  if valid_614429 != nil:
    section.add "X-Amz-Content-Sha256", valid_614429
  var valid_614430 = header.getOrDefault("X-Amz-Date")
  valid_614430 = validateParameter(valid_614430, JString, required = false,
                                 default = nil)
  if valid_614430 != nil:
    section.add "X-Amz-Date", valid_614430
  var valid_614431 = header.getOrDefault("X-Amz-Credential")
  valid_614431 = validateParameter(valid_614431, JString, required = false,
                                 default = nil)
  if valid_614431 != nil:
    section.add "X-Amz-Credential", valid_614431
  var valid_614432 = header.getOrDefault("X-Amz-Security-Token")
  valid_614432 = validateParameter(valid_614432, JString, required = false,
                                 default = nil)
  if valid_614432 != nil:
    section.add "X-Amz-Security-Token", valid_614432
  var valid_614433 = header.getOrDefault("X-Amz-Algorithm")
  valid_614433 = validateParameter(valid_614433, JString, required = false,
                                 default = nil)
  if valid_614433 != nil:
    section.add "X-Amz-Algorithm", valid_614433
  var valid_614434 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614434 = validateParameter(valid_614434, JString, required = false,
                                 default = nil)
  if valid_614434 != nil:
    section.add "X-Amz-SignedHeaders", valid_614434
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614436: Call_CreateThing_614424; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  let valid = call_614436.validator(path, query, header, formData, body)
  let scheme = call_614436.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614436.url(scheme.get, call_614436.host, call_614436.base,
                         call_614436.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614436, url, valid)

proc call*(call_614437: Call_CreateThing_614424; thingName: string; body: JsonNode): Recallable =
  ## createThing
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing to create.
  ##   body: JObject (required)
  var path_614438 = newJObject()
  var body_614439 = newJObject()
  add(path_614438, "thingName", newJString(thingName))
  if body != nil:
    body_614439 = body
  result = call_614437.call(path_614438, nil, nil, nil, body_614439)

var createThing* = Call_CreateThing_614424(name: "createThing",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_CreateThing_614425,
                                        base: "/", url: url_CreateThing_614426,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThing_614410 = ref object of OpenApiRestCall_612658
proc url_DescribeThing_614412(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThing_614411(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the specified thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_614413 = path.getOrDefault("thingName")
  valid_614413 = validateParameter(valid_614413, JString, required = true,
                                 default = nil)
  if valid_614413 != nil:
    section.add "thingName", valid_614413
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614414 = header.getOrDefault("X-Amz-Signature")
  valid_614414 = validateParameter(valid_614414, JString, required = false,
                                 default = nil)
  if valid_614414 != nil:
    section.add "X-Amz-Signature", valid_614414
  var valid_614415 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614415 = validateParameter(valid_614415, JString, required = false,
                                 default = nil)
  if valid_614415 != nil:
    section.add "X-Amz-Content-Sha256", valid_614415
  var valid_614416 = header.getOrDefault("X-Amz-Date")
  valid_614416 = validateParameter(valid_614416, JString, required = false,
                                 default = nil)
  if valid_614416 != nil:
    section.add "X-Amz-Date", valid_614416
  var valid_614417 = header.getOrDefault("X-Amz-Credential")
  valid_614417 = validateParameter(valid_614417, JString, required = false,
                                 default = nil)
  if valid_614417 != nil:
    section.add "X-Amz-Credential", valid_614417
  var valid_614418 = header.getOrDefault("X-Amz-Security-Token")
  valid_614418 = validateParameter(valid_614418, JString, required = false,
                                 default = nil)
  if valid_614418 != nil:
    section.add "X-Amz-Security-Token", valid_614418
  var valid_614419 = header.getOrDefault("X-Amz-Algorithm")
  valid_614419 = validateParameter(valid_614419, JString, required = false,
                                 default = nil)
  if valid_614419 != nil:
    section.add "X-Amz-Algorithm", valid_614419
  var valid_614420 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614420 = validateParameter(valid_614420, JString, required = false,
                                 default = nil)
  if valid_614420 != nil:
    section.add "X-Amz-SignedHeaders", valid_614420
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614421: Call_DescribeThing_614410; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified thing.
  ## 
  let valid = call_614421.validator(path, query, header, formData, body)
  let scheme = call_614421.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614421.url(scheme.get, call_614421.host, call_614421.base,
                         call_614421.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614421, url, valid)

proc call*(call_614422: Call_DescribeThing_614410; thingName: string): Recallable =
  ## describeThing
  ## Gets information about the specified thing.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_614423 = newJObject()
  add(path_614423, "thingName", newJString(thingName))
  result = call_614422.call(path_614423, nil, nil, nil, nil)

var describeThing* = Call_DescribeThing_614410(name: "describeThing",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/things/{thingName}", validator: validate_DescribeThing_614411,
    base: "/", url: url_DescribeThing_614412, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThing_614456 = ref object of OpenApiRestCall_612658
proc url_UpdateThing_614458(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateThing_614457(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the data for a thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_614459 = path.getOrDefault("thingName")
  valid_614459 = validateParameter(valid_614459, JString, required = true,
                                 default = nil)
  if valid_614459 != nil:
    section.add "thingName", valid_614459
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614460 = header.getOrDefault("X-Amz-Signature")
  valid_614460 = validateParameter(valid_614460, JString, required = false,
                                 default = nil)
  if valid_614460 != nil:
    section.add "X-Amz-Signature", valid_614460
  var valid_614461 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614461 = validateParameter(valid_614461, JString, required = false,
                                 default = nil)
  if valid_614461 != nil:
    section.add "X-Amz-Content-Sha256", valid_614461
  var valid_614462 = header.getOrDefault("X-Amz-Date")
  valid_614462 = validateParameter(valid_614462, JString, required = false,
                                 default = nil)
  if valid_614462 != nil:
    section.add "X-Amz-Date", valid_614462
  var valid_614463 = header.getOrDefault("X-Amz-Credential")
  valid_614463 = validateParameter(valid_614463, JString, required = false,
                                 default = nil)
  if valid_614463 != nil:
    section.add "X-Amz-Credential", valid_614463
  var valid_614464 = header.getOrDefault("X-Amz-Security-Token")
  valid_614464 = validateParameter(valid_614464, JString, required = false,
                                 default = nil)
  if valid_614464 != nil:
    section.add "X-Amz-Security-Token", valid_614464
  var valid_614465 = header.getOrDefault("X-Amz-Algorithm")
  valid_614465 = validateParameter(valid_614465, JString, required = false,
                                 default = nil)
  if valid_614465 != nil:
    section.add "X-Amz-Algorithm", valid_614465
  var valid_614466 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614466 = validateParameter(valid_614466, JString, required = false,
                                 default = nil)
  if valid_614466 != nil:
    section.add "X-Amz-SignedHeaders", valid_614466
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614468: Call_UpdateThing_614456; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the data for a thing.
  ## 
  let valid = call_614468.validator(path, query, header, formData, body)
  let scheme = call_614468.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614468.url(scheme.get, call_614468.host, call_614468.base,
                         call_614468.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614468, url, valid)

proc call*(call_614469: Call_UpdateThing_614456; thingName: string; body: JsonNode): Recallable =
  ## updateThing
  ## Updates the data for a thing.
  ##   thingName: string (required)
  ##            : The name of the thing to update.
  ##   body: JObject (required)
  var path_614470 = newJObject()
  var body_614471 = newJObject()
  add(path_614470, "thingName", newJString(thingName))
  if body != nil:
    body_614471 = body
  result = call_614469.call(path_614470, nil, nil, nil, body_614471)

var updateThing* = Call_UpdateThing_614456(name: "updateThing",
                                        meth: HttpMethod.HttpPatch,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_UpdateThing_614457,
                                        base: "/", url: url_UpdateThing_614458,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThing_614440 = ref object of OpenApiRestCall_612658
proc url_DeleteThing_614442(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteThing_614441(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_614443 = path.getOrDefault("thingName")
  valid_614443 = validateParameter(valid_614443, JString, required = true,
                                 default = nil)
  if valid_614443 != nil:
    section.add "thingName", valid_614443
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.
  section = newJObject()
  var valid_614444 = query.getOrDefault("expectedVersion")
  valid_614444 = validateParameter(valid_614444, JInt, required = false, default = nil)
  if valid_614444 != nil:
    section.add "expectedVersion", valid_614444
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614445 = header.getOrDefault("X-Amz-Signature")
  valid_614445 = validateParameter(valid_614445, JString, required = false,
                                 default = nil)
  if valid_614445 != nil:
    section.add "X-Amz-Signature", valid_614445
  var valid_614446 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614446 = validateParameter(valid_614446, JString, required = false,
                                 default = nil)
  if valid_614446 != nil:
    section.add "X-Amz-Content-Sha256", valid_614446
  var valid_614447 = header.getOrDefault("X-Amz-Date")
  valid_614447 = validateParameter(valid_614447, JString, required = false,
                                 default = nil)
  if valid_614447 != nil:
    section.add "X-Amz-Date", valid_614447
  var valid_614448 = header.getOrDefault("X-Amz-Credential")
  valid_614448 = validateParameter(valid_614448, JString, required = false,
                                 default = nil)
  if valid_614448 != nil:
    section.add "X-Amz-Credential", valid_614448
  var valid_614449 = header.getOrDefault("X-Amz-Security-Token")
  valid_614449 = validateParameter(valid_614449, JString, required = false,
                                 default = nil)
  if valid_614449 != nil:
    section.add "X-Amz-Security-Token", valid_614449
  var valid_614450 = header.getOrDefault("X-Amz-Algorithm")
  valid_614450 = validateParameter(valid_614450, JString, required = false,
                                 default = nil)
  if valid_614450 != nil:
    section.add "X-Amz-Algorithm", valid_614450
  var valid_614451 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614451 = validateParameter(valid_614451, JString, required = false,
                                 default = nil)
  if valid_614451 != nil:
    section.add "X-Amz-SignedHeaders", valid_614451
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614452: Call_DeleteThing_614440; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ## 
  let valid = call_614452.validator(path, query, header, formData, body)
  let scheme = call_614452.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614452.url(scheme.get, call_614452.host, call_614452.base,
                         call_614452.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614452, url, valid)

proc call*(call_614453: Call_DeleteThing_614440; thingName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteThing
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ##   expectedVersion: int
  ##                  : The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.
  ##   thingName: string (required)
  ##            : The name of the thing to delete.
  var path_614454 = newJObject()
  var query_614455 = newJObject()
  add(query_614455, "expectedVersion", newJInt(expectedVersion))
  add(path_614454, "thingName", newJString(thingName))
  result = call_614453.call(path_614454, query_614455, nil, nil, nil)

var deleteThing* = Call_DeleteThing_614440(name: "deleteThing",
                                        meth: HttpMethod.HttpDelete,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_DeleteThing_614441,
                                        base: "/", url: url_DeleteThing_614442,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThingGroup_614486 = ref object of OpenApiRestCall_612658
proc url_CreateThingGroup_614488(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateThingGroup_614487(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group name to create.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_614489 = path.getOrDefault("thingGroupName")
  valid_614489 = validateParameter(valid_614489, JString, required = true,
                                 default = nil)
  if valid_614489 != nil:
    section.add "thingGroupName", valid_614489
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614490 = header.getOrDefault("X-Amz-Signature")
  valid_614490 = validateParameter(valid_614490, JString, required = false,
                                 default = nil)
  if valid_614490 != nil:
    section.add "X-Amz-Signature", valid_614490
  var valid_614491 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614491 = validateParameter(valid_614491, JString, required = false,
                                 default = nil)
  if valid_614491 != nil:
    section.add "X-Amz-Content-Sha256", valid_614491
  var valid_614492 = header.getOrDefault("X-Amz-Date")
  valid_614492 = validateParameter(valid_614492, JString, required = false,
                                 default = nil)
  if valid_614492 != nil:
    section.add "X-Amz-Date", valid_614492
  var valid_614493 = header.getOrDefault("X-Amz-Credential")
  valid_614493 = validateParameter(valid_614493, JString, required = false,
                                 default = nil)
  if valid_614493 != nil:
    section.add "X-Amz-Credential", valid_614493
  var valid_614494 = header.getOrDefault("X-Amz-Security-Token")
  valid_614494 = validateParameter(valid_614494, JString, required = false,
                                 default = nil)
  if valid_614494 != nil:
    section.add "X-Amz-Security-Token", valid_614494
  var valid_614495 = header.getOrDefault("X-Amz-Algorithm")
  valid_614495 = validateParameter(valid_614495, JString, required = false,
                                 default = nil)
  if valid_614495 != nil:
    section.add "X-Amz-Algorithm", valid_614495
  var valid_614496 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614496 = validateParameter(valid_614496, JString, required = false,
                                 default = nil)
  if valid_614496 != nil:
    section.add "X-Amz-SignedHeaders", valid_614496
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614498: Call_CreateThingGroup_614486; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  let valid = call_614498.validator(path, query, header, formData, body)
  let scheme = call_614498.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614498.url(scheme.get, call_614498.host, call_614498.base,
                         call_614498.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614498, url, valid)

proc call*(call_614499: Call_CreateThingGroup_614486; thingGroupName: string;
          body: JsonNode): Recallable =
  ## createThingGroup
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ##   thingGroupName: string (required)
  ##                 : The thing group name to create.
  ##   body: JObject (required)
  var path_614500 = newJObject()
  var body_614501 = newJObject()
  add(path_614500, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_614501 = body
  result = call_614499.call(path_614500, nil, nil, nil, body_614501)

var createThingGroup* = Call_CreateThingGroup_614486(name: "createThingGroup",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_CreateThingGroup_614487,
    base: "/", url: url_CreateThingGroup_614488,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingGroup_614472 = ref object of OpenApiRestCall_612658
proc url_DescribeThingGroup_614474(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThingGroup_614473(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Describe a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the thing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_614475 = path.getOrDefault("thingGroupName")
  valid_614475 = validateParameter(valid_614475, JString, required = true,
                                 default = nil)
  if valid_614475 != nil:
    section.add "thingGroupName", valid_614475
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614476 = header.getOrDefault("X-Amz-Signature")
  valid_614476 = validateParameter(valid_614476, JString, required = false,
                                 default = nil)
  if valid_614476 != nil:
    section.add "X-Amz-Signature", valid_614476
  var valid_614477 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614477 = validateParameter(valid_614477, JString, required = false,
                                 default = nil)
  if valid_614477 != nil:
    section.add "X-Amz-Content-Sha256", valid_614477
  var valid_614478 = header.getOrDefault("X-Amz-Date")
  valid_614478 = validateParameter(valid_614478, JString, required = false,
                                 default = nil)
  if valid_614478 != nil:
    section.add "X-Amz-Date", valid_614478
  var valid_614479 = header.getOrDefault("X-Amz-Credential")
  valid_614479 = validateParameter(valid_614479, JString, required = false,
                                 default = nil)
  if valid_614479 != nil:
    section.add "X-Amz-Credential", valid_614479
  var valid_614480 = header.getOrDefault("X-Amz-Security-Token")
  valid_614480 = validateParameter(valid_614480, JString, required = false,
                                 default = nil)
  if valid_614480 != nil:
    section.add "X-Amz-Security-Token", valid_614480
  var valid_614481 = header.getOrDefault("X-Amz-Algorithm")
  valid_614481 = validateParameter(valid_614481, JString, required = false,
                                 default = nil)
  if valid_614481 != nil:
    section.add "X-Amz-Algorithm", valid_614481
  var valid_614482 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614482 = validateParameter(valid_614482, JString, required = false,
                                 default = nil)
  if valid_614482 != nil:
    section.add "X-Amz-SignedHeaders", valid_614482
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614483: Call_DescribeThingGroup_614472; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describe a thing group.
  ## 
  let valid = call_614483.validator(path, query, header, formData, body)
  let scheme = call_614483.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614483.url(scheme.get, call_614483.host, call_614483.base,
                         call_614483.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614483, url, valid)

proc call*(call_614484: Call_DescribeThingGroup_614472; thingGroupName: string): Recallable =
  ## describeThingGroup
  ## Describe a thing group.
  ##   thingGroupName: string (required)
  ##                 : The name of the thing group.
  var path_614485 = newJObject()
  add(path_614485, "thingGroupName", newJString(thingGroupName))
  result = call_614484.call(path_614485, nil, nil, nil, nil)

var describeThingGroup* = Call_DescribeThingGroup_614472(
    name: "describeThingGroup", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}",
    validator: validate_DescribeThingGroup_614473, base: "/",
    url: url_DescribeThingGroup_614474, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThingGroup_614518 = ref object of OpenApiRestCall_612658
proc url_UpdateThingGroup_614520(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateThingGroup_614519(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Update a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group to update.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_614521 = path.getOrDefault("thingGroupName")
  valid_614521 = validateParameter(valid_614521, JString, required = true,
                                 default = nil)
  if valid_614521 != nil:
    section.add "thingGroupName", valid_614521
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614522 = header.getOrDefault("X-Amz-Signature")
  valid_614522 = validateParameter(valid_614522, JString, required = false,
                                 default = nil)
  if valid_614522 != nil:
    section.add "X-Amz-Signature", valid_614522
  var valid_614523 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614523 = validateParameter(valid_614523, JString, required = false,
                                 default = nil)
  if valid_614523 != nil:
    section.add "X-Amz-Content-Sha256", valid_614523
  var valid_614524 = header.getOrDefault("X-Amz-Date")
  valid_614524 = validateParameter(valid_614524, JString, required = false,
                                 default = nil)
  if valid_614524 != nil:
    section.add "X-Amz-Date", valid_614524
  var valid_614525 = header.getOrDefault("X-Amz-Credential")
  valid_614525 = validateParameter(valid_614525, JString, required = false,
                                 default = nil)
  if valid_614525 != nil:
    section.add "X-Amz-Credential", valid_614525
  var valid_614526 = header.getOrDefault("X-Amz-Security-Token")
  valid_614526 = validateParameter(valid_614526, JString, required = false,
                                 default = nil)
  if valid_614526 != nil:
    section.add "X-Amz-Security-Token", valid_614526
  var valid_614527 = header.getOrDefault("X-Amz-Algorithm")
  valid_614527 = validateParameter(valid_614527, JString, required = false,
                                 default = nil)
  if valid_614527 != nil:
    section.add "X-Amz-Algorithm", valid_614527
  var valid_614528 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614528 = validateParameter(valid_614528, JString, required = false,
                                 default = nil)
  if valid_614528 != nil:
    section.add "X-Amz-SignedHeaders", valid_614528
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614530: Call_UpdateThingGroup_614518; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update a thing group.
  ## 
  let valid = call_614530.validator(path, query, header, formData, body)
  let scheme = call_614530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614530.url(scheme.get, call_614530.host, call_614530.base,
                         call_614530.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614530, url, valid)

proc call*(call_614531: Call_UpdateThingGroup_614518; thingGroupName: string;
          body: JsonNode): Recallable =
  ## updateThingGroup
  ## Update a thing group.
  ##   thingGroupName: string (required)
  ##                 : The thing group to update.
  ##   body: JObject (required)
  var path_614532 = newJObject()
  var body_614533 = newJObject()
  add(path_614532, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_614533 = body
  result = call_614531.call(path_614532, nil, nil, nil, body_614533)

var updateThingGroup* = Call_UpdateThingGroup_614518(name: "updateThingGroup",
    meth: HttpMethod.HttpPatch, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_UpdateThingGroup_614519,
    base: "/", url: url_UpdateThingGroup_614520,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThingGroup_614502 = ref object of OpenApiRestCall_612658
proc url_DeleteThingGroup_614504(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteThingGroup_614503(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Deletes a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the thing group to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_614505 = path.getOrDefault("thingGroupName")
  valid_614505 = validateParameter(valid_614505, JString, required = true,
                                 default = nil)
  if valid_614505 != nil:
    section.add "thingGroupName", valid_614505
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the thing group to delete.
  section = newJObject()
  var valid_614506 = query.getOrDefault("expectedVersion")
  valid_614506 = validateParameter(valid_614506, JInt, required = false, default = nil)
  if valid_614506 != nil:
    section.add "expectedVersion", valid_614506
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614507 = header.getOrDefault("X-Amz-Signature")
  valid_614507 = validateParameter(valid_614507, JString, required = false,
                                 default = nil)
  if valid_614507 != nil:
    section.add "X-Amz-Signature", valid_614507
  var valid_614508 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614508 = validateParameter(valid_614508, JString, required = false,
                                 default = nil)
  if valid_614508 != nil:
    section.add "X-Amz-Content-Sha256", valid_614508
  var valid_614509 = header.getOrDefault("X-Amz-Date")
  valid_614509 = validateParameter(valid_614509, JString, required = false,
                                 default = nil)
  if valid_614509 != nil:
    section.add "X-Amz-Date", valid_614509
  var valid_614510 = header.getOrDefault("X-Amz-Credential")
  valid_614510 = validateParameter(valid_614510, JString, required = false,
                                 default = nil)
  if valid_614510 != nil:
    section.add "X-Amz-Credential", valid_614510
  var valid_614511 = header.getOrDefault("X-Amz-Security-Token")
  valid_614511 = validateParameter(valid_614511, JString, required = false,
                                 default = nil)
  if valid_614511 != nil:
    section.add "X-Amz-Security-Token", valid_614511
  var valid_614512 = header.getOrDefault("X-Amz-Algorithm")
  valid_614512 = validateParameter(valid_614512, JString, required = false,
                                 default = nil)
  if valid_614512 != nil:
    section.add "X-Amz-Algorithm", valid_614512
  var valid_614513 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614513 = validateParameter(valid_614513, JString, required = false,
                                 default = nil)
  if valid_614513 != nil:
    section.add "X-Amz-SignedHeaders", valid_614513
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614514: Call_DeleteThingGroup_614502; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a thing group.
  ## 
  let valid = call_614514.validator(path, query, header, formData, body)
  let scheme = call_614514.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614514.url(scheme.get, call_614514.host, call_614514.base,
                         call_614514.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614514, url, valid)

proc call*(call_614515: Call_DeleteThingGroup_614502; thingGroupName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteThingGroup
  ## Deletes a thing group.
  ##   expectedVersion: int
  ##                  : The expected version of the thing group to delete.
  ##   thingGroupName: string (required)
  ##                 : The name of the thing group to delete.
  var path_614516 = newJObject()
  var query_614517 = newJObject()
  add(query_614517, "expectedVersion", newJInt(expectedVersion))
  add(path_614516, "thingGroupName", newJString(thingGroupName))
  result = call_614515.call(path_614516, query_614517, nil, nil, nil)

var deleteThingGroup* = Call_DeleteThingGroup_614502(name: "deleteThingGroup",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_DeleteThingGroup_614503,
    base: "/", url: url_DeleteThingGroup_614504,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThingType_614548 = ref object of OpenApiRestCall_612658
proc url_CreateThingType_614550(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateThingType_614549(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a new thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_614551 = path.getOrDefault("thingTypeName")
  valid_614551 = validateParameter(valid_614551, JString, required = true,
                                 default = nil)
  if valid_614551 != nil:
    section.add "thingTypeName", valid_614551
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614552 = header.getOrDefault("X-Amz-Signature")
  valid_614552 = validateParameter(valid_614552, JString, required = false,
                                 default = nil)
  if valid_614552 != nil:
    section.add "X-Amz-Signature", valid_614552
  var valid_614553 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614553 = validateParameter(valid_614553, JString, required = false,
                                 default = nil)
  if valid_614553 != nil:
    section.add "X-Amz-Content-Sha256", valid_614553
  var valid_614554 = header.getOrDefault("X-Amz-Date")
  valid_614554 = validateParameter(valid_614554, JString, required = false,
                                 default = nil)
  if valid_614554 != nil:
    section.add "X-Amz-Date", valid_614554
  var valid_614555 = header.getOrDefault("X-Amz-Credential")
  valid_614555 = validateParameter(valid_614555, JString, required = false,
                                 default = nil)
  if valid_614555 != nil:
    section.add "X-Amz-Credential", valid_614555
  var valid_614556 = header.getOrDefault("X-Amz-Security-Token")
  valid_614556 = validateParameter(valid_614556, JString, required = false,
                                 default = nil)
  if valid_614556 != nil:
    section.add "X-Amz-Security-Token", valid_614556
  var valid_614557 = header.getOrDefault("X-Amz-Algorithm")
  valid_614557 = validateParameter(valid_614557, JString, required = false,
                                 default = nil)
  if valid_614557 != nil:
    section.add "X-Amz-Algorithm", valid_614557
  var valid_614558 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614558 = validateParameter(valid_614558, JString, required = false,
                                 default = nil)
  if valid_614558 != nil:
    section.add "X-Amz-SignedHeaders", valid_614558
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614560: Call_CreateThingType_614548; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new thing type.
  ## 
  let valid = call_614560.validator(path, query, header, formData, body)
  let scheme = call_614560.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614560.url(scheme.get, call_614560.host, call_614560.base,
                         call_614560.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614560, url, valid)

proc call*(call_614561: Call_CreateThingType_614548; thingTypeName: string;
          body: JsonNode): Recallable =
  ## createThingType
  ## Creates a new thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  ##   body: JObject (required)
  var path_614562 = newJObject()
  var body_614563 = newJObject()
  add(path_614562, "thingTypeName", newJString(thingTypeName))
  if body != nil:
    body_614563 = body
  result = call_614561.call(path_614562, nil, nil, nil, body_614563)

var createThingType* = Call_CreateThingType_614548(name: "createThingType",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_CreateThingType_614549,
    base: "/", url: url_CreateThingType_614550, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingType_614534 = ref object of OpenApiRestCall_612658
proc url_DescribeThingType_614536(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThingType_614535(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Gets information about the specified thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_614537 = path.getOrDefault("thingTypeName")
  valid_614537 = validateParameter(valid_614537, JString, required = true,
                                 default = nil)
  if valid_614537 != nil:
    section.add "thingTypeName", valid_614537
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614538 = header.getOrDefault("X-Amz-Signature")
  valid_614538 = validateParameter(valid_614538, JString, required = false,
                                 default = nil)
  if valid_614538 != nil:
    section.add "X-Amz-Signature", valid_614538
  var valid_614539 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614539 = validateParameter(valid_614539, JString, required = false,
                                 default = nil)
  if valid_614539 != nil:
    section.add "X-Amz-Content-Sha256", valid_614539
  var valid_614540 = header.getOrDefault("X-Amz-Date")
  valid_614540 = validateParameter(valid_614540, JString, required = false,
                                 default = nil)
  if valid_614540 != nil:
    section.add "X-Amz-Date", valid_614540
  var valid_614541 = header.getOrDefault("X-Amz-Credential")
  valid_614541 = validateParameter(valid_614541, JString, required = false,
                                 default = nil)
  if valid_614541 != nil:
    section.add "X-Amz-Credential", valid_614541
  var valid_614542 = header.getOrDefault("X-Amz-Security-Token")
  valid_614542 = validateParameter(valid_614542, JString, required = false,
                                 default = nil)
  if valid_614542 != nil:
    section.add "X-Amz-Security-Token", valid_614542
  var valid_614543 = header.getOrDefault("X-Amz-Algorithm")
  valid_614543 = validateParameter(valid_614543, JString, required = false,
                                 default = nil)
  if valid_614543 != nil:
    section.add "X-Amz-Algorithm", valid_614543
  var valid_614544 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614544 = validateParameter(valid_614544, JString, required = false,
                                 default = nil)
  if valid_614544 != nil:
    section.add "X-Amz-SignedHeaders", valid_614544
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614545: Call_DescribeThingType_614534; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified thing type.
  ## 
  let valid = call_614545.validator(path, query, header, formData, body)
  let scheme = call_614545.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614545.url(scheme.get, call_614545.host, call_614545.base,
                         call_614545.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614545, url, valid)

proc call*(call_614546: Call_DescribeThingType_614534; thingTypeName: string): Recallable =
  ## describeThingType
  ## Gets information about the specified thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_614547 = newJObject()
  add(path_614547, "thingTypeName", newJString(thingTypeName))
  result = call_614546.call(path_614547, nil, nil, nil, nil)

var describeThingType* = Call_DescribeThingType_614534(name: "describeThingType",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_DescribeThingType_614535,
    base: "/", url: url_DescribeThingType_614536,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThingType_614564 = ref object of OpenApiRestCall_612658
proc url_DeleteThingType_614566(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteThingType_614565(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_614567 = path.getOrDefault("thingTypeName")
  valid_614567 = validateParameter(valid_614567, JString, required = true,
                                 default = nil)
  if valid_614567 != nil:
    section.add "thingTypeName", valid_614567
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614568 = header.getOrDefault("X-Amz-Signature")
  valid_614568 = validateParameter(valid_614568, JString, required = false,
                                 default = nil)
  if valid_614568 != nil:
    section.add "X-Amz-Signature", valid_614568
  var valid_614569 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614569 = validateParameter(valid_614569, JString, required = false,
                                 default = nil)
  if valid_614569 != nil:
    section.add "X-Amz-Content-Sha256", valid_614569
  var valid_614570 = header.getOrDefault("X-Amz-Date")
  valid_614570 = validateParameter(valid_614570, JString, required = false,
                                 default = nil)
  if valid_614570 != nil:
    section.add "X-Amz-Date", valid_614570
  var valid_614571 = header.getOrDefault("X-Amz-Credential")
  valid_614571 = validateParameter(valid_614571, JString, required = false,
                                 default = nil)
  if valid_614571 != nil:
    section.add "X-Amz-Credential", valid_614571
  var valid_614572 = header.getOrDefault("X-Amz-Security-Token")
  valid_614572 = validateParameter(valid_614572, JString, required = false,
                                 default = nil)
  if valid_614572 != nil:
    section.add "X-Amz-Security-Token", valid_614572
  var valid_614573 = header.getOrDefault("X-Amz-Algorithm")
  valid_614573 = validateParameter(valid_614573, JString, required = false,
                                 default = nil)
  if valid_614573 != nil:
    section.add "X-Amz-Algorithm", valid_614573
  var valid_614574 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614574 = validateParameter(valid_614574, JString, required = false,
                                 default = nil)
  if valid_614574 != nil:
    section.add "X-Amz-SignedHeaders", valid_614574
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614575: Call_DeleteThingType_614564; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ## 
  let valid = call_614575.validator(path, query, header, formData, body)
  let scheme = call_614575.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614575.url(scheme.get, call_614575.host, call_614575.base,
                         call_614575.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614575, url, valid)

proc call*(call_614576: Call_DeleteThingType_614564; thingTypeName: string): Recallable =
  ## deleteThingType
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_614577 = newJObject()
  add(path_614577, "thingTypeName", newJString(thingTypeName))
  result = call_614576.call(path_614577, nil, nil, nil, nil)

var deleteThingType* = Call_DeleteThingType_614564(name: "deleteThingType",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_DeleteThingType_614565,
    base: "/", url: url_DeleteThingType_614566, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateTopicRule_614592 = ref object of OpenApiRestCall_612658
proc url_CreateTopicRule_614594(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateTopicRule_614593(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_614595 = path.getOrDefault("ruleName")
  valid_614595 = validateParameter(valid_614595, JString, required = true,
                                 default = nil)
  if valid_614595 != nil:
    section.add "ruleName", valid_614595
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   x-amz-tagging: JString
  ##                : <p>Metadata which can be used to manage the topic rule.</p> <note> <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p> <p>For the CLI command-line parameter use format: --tags "key1=value1&amp;key2=value2..."</p> <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p> </note>
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614596 = header.getOrDefault("x-amz-tagging")
  valid_614596 = validateParameter(valid_614596, JString, required = false,
                                 default = nil)
  if valid_614596 != nil:
    section.add "x-amz-tagging", valid_614596
  var valid_614597 = header.getOrDefault("X-Amz-Signature")
  valid_614597 = validateParameter(valid_614597, JString, required = false,
                                 default = nil)
  if valid_614597 != nil:
    section.add "X-Amz-Signature", valid_614597
  var valid_614598 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614598 = validateParameter(valid_614598, JString, required = false,
                                 default = nil)
  if valid_614598 != nil:
    section.add "X-Amz-Content-Sha256", valid_614598
  var valid_614599 = header.getOrDefault("X-Amz-Date")
  valid_614599 = validateParameter(valid_614599, JString, required = false,
                                 default = nil)
  if valid_614599 != nil:
    section.add "X-Amz-Date", valid_614599
  var valid_614600 = header.getOrDefault("X-Amz-Credential")
  valid_614600 = validateParameter(valid_614600, JString, required = false,
                                 default = nil)
  if valid_614600 != nil:
    section.add "X-Amz-Credential", valid_614600
  var valid_614601 = header.getOrDefault("X-Amz-Security-Token")
  valid_614601 = validateParameter(valid_614601, JString, required = false,
                                 default = nil)
  if valid_614601 != nil:
    section.add "X-Amz-Security-Token", valid_614601
  var valid_614602 = header.getOrDefault("X-Amz-Algorithm")
  valid_614602 = validateParameter(valid_614602, JString, required = false,
                                 default = nil)
  if valid_614602 != nil:
    section.add "X-Amz-Algorithm", valid_614602
  var valid_614603 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614603 = validateParameter(valid_614603, JString, required = false,
                                 default = nil)
  if valid_614603 != nil:
    section.add "X-Amz-SignedHeaders", valid_614603
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614605: Call_CreateTopicRule_614592; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  let valid = call_614605.validator(path, query, header, formData, body)
  let scheme = call_614605.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614605.url(scheme.get, call_614605.host, call_614605.base,
                         call_614605.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614605, url, valid)

proc call*(call_614606: Call_CreateTopicRule_614592; ruleName: string; body: JsonNode): Recallable =
  ## createTopicRule
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  ##   body: JObject (required)
  var path_614607 = newJObject()
  var body_614608 = newJObject()
  add(path_614607, "ruleName", newJString(ruleName))
  if body != nil:
    body_614608 = body
  result = call_614606.call(path_614607, nil, nil, nil, body_614608)

var createTopicRule* = Call_CreateTopicRule_614592(name: "createTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_CreateTopicRule_614593,
    base: "/", url: url_CreateTopicRule_614594, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetTopicRule_614578 = ref object of OpenApiRestCall_612658
proc url_GetTopicRule_614580(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTopicRule_614579(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_614581 = path.getOrDefault("ruleName")
  valid_614581 = validateParameter(valid_614581, JString, required = true,
                                 default = nil)
  if valid_614581 != nil:
    section.add "ruleName", valid_614581
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614582 = header.getOrDefault("X-Amz-Signature")
  valid_614582 = validateParameter(valid_614582, JString, required = false,
                                 default = nil)
  if valid_614582 != nil:
    section.add "X-Amz-Signature", valid_614582
  var valid_614583 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614583 = validateParameter(valid_614583, JString, required = false,
                                 default = nil)
  if valid_614583 != nil:
    section.add "X-Amz-Content-Sha256", valid_614583
  var valid_614584 = header.getOrDefault("X-Amz-Date")
  valid_614584 = validateParameter(valid_614584, JString, required = false,
                                 default = nil)
  if valid_614584 != nil:
    section.add "X-Amz-Date", valid_614584
  var valid_614585 = header.getOrDefault("X-Amz-Credential")
  valid_614585 = validateParameter(valid_614585, JString, required = false,
                                 default = nil)
  if valid_614585 != nil:
    section.add "X-Amz-Credential", valid_614585
  var valid_614586 = header.getOrDefault("X-Amz-Security-Token")
  valid_614586 = validateParameter(valid_614586, JString, required = false,
                                 default = nil)
  if valid_614586 != nil:
    section.add "X-Amz-Security-Token", valid_614586
  var valid_614587 = header.getOrDefault("X-Amz-Algorithm")
  valid_614587 = validateParameter(valid_614587, JString, required = false,
                                 default = nil)
  if valid_614587 != nil:
    section.add "X-Amz-Algorithm", valid_614587
  var valid_614588 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614588 = validateParameter(valid_614588, JString, required = false,
                                 default = nil)
  if valid_614588 != nil:
    section.add "X-Amz-SignedHeaders", valid_614588
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614589: Call_GetTopicRule_614578; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the rule.
  ## 
  let valid = call_614589.validator(path, query, header, formData, body)
  let scheme = call_614589.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614589.url(scheme.get, call_614589.host, call_614589.base,
                         call_614589.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614589, url, valid)

proc call*(call_614590: Call_GetTopicRule_614578; ruleName: string): Recallable =
  ## getTopicRule
  ## Gets information about the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  var path_614591 = newJObject()
  add(path_614591, "ruleName", newJString(ruleName))
  result = call_614590.call(path_614591, nil, nil, nil, nil)

var getTopicRule* = Call_GetTopicRule_614578(name: "getTopicRule",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/rules/{ruleName}",
    validator: validate_GetTopicRule_614579, base: "/", url: url_GetTopicRule_614580,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReplaceTopicRule_614623 = ref object of OpenApiRestCall_612658
proc url_ReplaceTopicRule_614625(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ReplaceTopicRule_614624(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_614626 = path.getOrDefault("ruleName")
  valid_614626 = validateParameter(valid_614626, JString, required = true,
                                 default = nil)
  if valid_614626 != nil:
    section.add "ruleName", valid_614626
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614627 = header.getOrDefault("X-Amz-Signature")
  valid_614627 = validateParameter(valid_614627, JString, required = false,
                                 default = nil)
  if valid_614627 != nil:
    section.add "X-Amz-Signature", valid_614627
  var valid_614628 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614628 = validateParameter(valid_614628, JString, required = false,
                                 default = nil)
  if valid_614628 != nil:
    section.add "X-Amz-Content-Sha256", valid_614628
  var valid_614629 = header.getOrDefault("X-Amz-Date")
  valid_614629 = validateParameter(valid_614629, JString, required = false,
                                 default = nil)
  if valid_614629 != nil:
    section.add "X-Amz-Date", valid_614629
  var valid_614630 = header.getOrDefault("X-Amz-Credential")
  valid_614630 = validateParameter(valid_614630, JString, required = false,
                                 default = nil)
  if valid_614630 != nil:
    section.add "X-Amz-Credential", valid_614630
  var valid_614631 = header.getOrDefault("X-Amz-Security-Token")
  valid_614631 = validateParameter(valid_614631, JString, required = false,
                                 default = nil)
  if valid_614631 != nil:
    section.add "X-Amz-Security-Token", valid_614631
  var valid_614632 = header.getOrDefault("X-Amz-Algorithm")
  valid_614632 = validateParameter(valid_614632, JString, required = false,
                                 default = nil)
  if valid_614632 != nil:
    section.add "X-Amz-Algorithm", valid_614632
  var valid_614633 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614633 = validateParameter(valid_614633, JString, required = false,
                                 default = nil)
  if valid_614633 != nil:
    section.add "X-Amz-SignedHeaders", valid_614633
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614635: Call_ReplaceTopicRule_614623; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  let valid = call_614635.validator(path, query, header, formData, body)
  let scheme = call_614635.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614635.url(scheme.get, call_614635.host, call_614635.base,
                         call_614635.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614635, url, valid)

proc call*(call_614636: Call_ReplaceTopicRule_614623; ruleName: string;
          body: JsonNode): Recallable =
  ## replaceTopicRule
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  ##   body: JObject (required)
  var path_614637 = newJObject()
  var body_614638 = newJObject()
  add(path_614637, "ruleName", newJString(ruleName))
  if body != nil:
    body_614638 = body
  result = call_614636.call(path_614637, nil, nil, nil, body_614638)

var replaceTopicRule* = Call_ReplaceTopicRule_614623(name: "replaceTopicRule",
    meth: HttpMethod.HttpPatch, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_ReplaceTopicRule_614624,
    base: "/", url: url_ReplaceTopicRule_614625,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteTopicRule_614609 = ref object of OpenApiRestCall_612658
proc url_DeleteTopicRule_614611(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTopicRule_614610(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_614612 = path.getOrDefault("ruleName")
  valid_614612 = validateParameter(valid_614612, JString, required = true,
                                 default = nil)
  if valid_614612 != nil:
    section.add "ruleName", valid_614612
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614613 = header.getOrDefault("X-Amz-Signature")
  valid_614613 = validateParameter(valid_614613, JString, required = false,
                                 default = nil)
  if valid_614613 != nil:
    section.add "X-Amz-Signature", valid_614613
  var valid_614614 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614614 = validateParameter(valid_614614, JString, required = false,
                                 default = nil)
  if valid_614614 != nil:
    section.add "X-Amz-Content-Sha256", valid_614614
  var valid_614615 = header.getOrDefault("X-Amz-Date")
  valid_614615 = validateParameter(valid_614615, JString, required = false,
                                 default = nil)
  if valid_614615 != nil:
    section.add "X-Amz-Date", valid_614615
  var valid_614616 = header.getOrDefault("X-Amz-Credential")
  valid_614616 = validateParameter(valid_614616, JString, required = false,
                                 default = nil)
  if valid_614616 != nil:
    section.add "X-Amz-Credential", valid_614616
  var valid_614617 = header.getOrDefault("X-Amz-Security-Token")
  valid_614617 = validateParameter(valid_614617, JString, required = false,
                                 default = nil)
  if valid_614617 != nil:
    section.add "X-Amz-Security-Token", valid_614617
  var valid_614618 = header.getOrDefault("X-Amz-Algorithm")
  valid_614618 = validateParameter(valid_614618, JString, required = false,
                                 default = nil)
  if valid_614618 != nil:
    section.add "X-Amz-Algorithm", valid_614618
  var valid_614619 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614619 = validateParameter(valid_614619, JString, required = false,
                                 default = nil)
  if valid_614619 != nil:
    section.add "X-Amz-SignedHeaders", valid_614619
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614620: Call_DeleteTopicRule_614609; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the rule.
  ## 
  let valid = call_614620.validator(path, query, header, formData, body)
  let scheme = call_614620.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614620.url(scheme.get, call_614620.host, call_614620.base,
                         call_614620.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614620, url, valid)

proc call*(call_614621: Call_DeleteTopicRule_614609; ruleName: string): Recallable =
  ## deleteTopicRule
  ## Deletes the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  var path_614622 = newJObject()
  add(path_614622, "ruleName", newJString(ruleName))
  result = call_614621.call(path_614622, nil, nil, nil, nil)

var deleteTopicRule* = Call_DeleteTopicRule_614609(name: "deleteTopicRule",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_DeleteTopicRule_614610,
    base: "/", url: url_DeleteTopicRule_614611, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateTopicRuleDestination_614654 = ref object of OpenApiRestCall_612658
proc url_CreateTopicRuleDestination_614656(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateTopicRuleDestination_614655(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a topic rule destination. The destination must be confirmed prior to use.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614657 = header.getOrDefault("X-Amz-Signature")
  valid_614657 = validateParameter(valid_614657, JString, required = false,
                                 default = nil)
  if valid_614657 != nil:
    section.add "X-Amz-Signature", valid_614657
  var valid_614658 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614658 = validateParameter(valid_614658, JString, required = false,
                                 default = nil)
  if valid_614658 != nil:
    section.add "X-Amz-Content-Sha256", valid_614658
  var valid_614659 = header.getOrDefault("X-Amz-Date")
  valid_614659 = validateParameter(valid_614659, JString, required = false,
                                 default = nil)
  if valid_614659 != nil:
    section.add "X-Amz-Date", valid_614659
  var valid_614660 = header.getOrDefault("X-Amz-Credential")
  valid_614660 = validateParameter(valid_614660, JString, required = false,
                                 default = nil)
  if valid_614660 != nil:
    section.add "X-Amz-Credential", valid_614660
  var valid_614661 = header.getOrDefault("X-Amz-Security-Token")
  valid_614661 = validateParameter(valid_614661, JString, required = false,
                                 default = nil)
  if valid_614661 != nil:
    section.add "X-Amz-Security-Token", valid_614661
  var valid_614662 = header.getOrDefault("X-Amz-Algorithm")
  valid_614662 = validateParameter(valid_614662, JString, required = false,
                                 default = nil)
  if valid_614662 != nil:
    section.add "X-Amz-Algorithm", valid_614662
  var valid_614663 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614663 = validateParameter(valid_614663, JString, required = false,
                                 default = nil)
  if valid_614663 != nil:
    section.add "X-Amz-SignedHeaders", valid_614663
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614665: Call_CreateTopicRuleDestination_614654; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a topic rule destination. The destination must be confirmed prior to use.
  ## 
  let valid = call_614665.validator(path, query, header, formData, body)
  let scheme = call_614665.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614665.url(scheme.get, call_614665.host, call_614665.base,
                         call_614665.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614665, url, valid)

proc call*(call_614666: Call_CreateTopicRuleDestination_614654; body: JsonNode): Recallable =
  ## createTopicRuleDestination
  ## Creates a topic rule destination. The destination must be confirmed prior to use.
  ##   body: JObject (required)
  var body_614667 = newJObject()
  if body != nil:
    body_614667 = body
  result = call_614666.call(nil, nil, nil, nil, body_614667)

var createTopicRuleDestination* = Call_CreateTopicRuleDestination_614654(
    name: "createTopicRuleDestination", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/destinations",
    validator: validate_CreateTopicRuleDestination_614655, base: "/",
    url: url_CreateTopicRuleDestination_614656,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTopicRuleDestinations_614639 = ref object of OpenApiRestCall_612658
proc url_ListTopicRuleDestinations_614641(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListTopicRuleDestinations_614640(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all the topic rule destinations in your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_614642 = query.getOrDefault("nextToken")
  valid_614642 = validateParameter(valid_614642, JString, required = false,
                                 default = nil)
  if valid_614642 != nil:
    section.add "nextToken", valid_614642
  var valid_614643 = query.getOrDefault("maxResults")
  valid_614643 = validateParameter(valid_614643, JInt, required = false, default = nil)
  if valid_614643 != nil:
    section.add "maxResults", valid_614643
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614644 = header.getOrDefault("X-Amz-Signature")
  valid_614644 = validateParameter(valid_614644, JString, required = false,
                                 default = nil)
  if valid_614644 != nil:
    section.add "X-Amz-Signature", valid_614644
  var valid_614645 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614645 = validateParameter(valid_614645, JString, required = false,
                                 default = nil)
  if valid_614645 != nil:
    section.add "X-Amz-Content-Sha256", valid_614645
  var valid_614646 = header.getOrDefault("X-Amz-Date")
  valid_614646 = validateParameter(valid_614646, JString, required = false,
                                 default = nil)
  if valid_614646 != nil:
    section.add "X-Amz-Date", valid_614646
  var valid_614647 = header.getOrDefault("X-Amz-Credential")
  valid_614647 = validateParameter(valid_614647, JString, required = false,
                                 default = nil)
  if valid_614647 != nil:
    section.add "X-Amz-Credential", valid_614647
  var valid_614648 = header.getOrDefault("X-Amz-Security-Token")
  valid_614648 = validateParameter(valid_614648, JString, required = false,
                                 default = nil)
  if valid_614648 != nil:
    section.add "X-Amz-Security-Token", valid_614648
  var valid_614649 = header.getOrDefault("X-Amz-Algorithm")
  valid_614649 = validateParameter(valid_614649, JString, required = false,
                                 default = nil)
  if valid_614649 != nil:
    section.add "X-Amz-Algorithm", valid_614649
  var valid_614650 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614650 = validateParameter(valid_614650, JString, required = false,
                                 default = nil)
  if valid_614650 != nil:
    section.add "X-Amz-SignedHeaders", valid_614650
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614651: Call_ListTopicRuleDestinations_614639; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all the topic rule destinations in your AWS account.
  ## 
  let valid = call_614651.validator(path, query, header, formData, body)
  let scheme = call_614651.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614651.url(scheme.get, call_614651.host, call_614651.base,
                         call_614651.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614651, url, valid)

proc call*(call_614652: Call_ListTopicRuleDestinations_614639;
          nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listTopicRuleDestinations
  ## Lists all the topic rule destinations in your AWS account.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_614653 = newJObject()
  add(query_614653, "nextToken", newJString(nextToken))
  add(query_614653, "maxResults", newJInt(maxResults))
  result = call_614652.call(nil, query_614653, nil, nil, nil)

var listTopicRuleDestinations* = Call_ListTopicRuleDestinations_614639(
    name: "listTopicRuleDestinations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/destinations",
    validator: validate_ListTopicRuleDestinations_614640, base: "/",
    url: url_ListTopicRuleDestinations_614641,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateTopicRuleDestination_614668 = ref object of OpenApiRestCall_612658
proc url_UpdateTopicRuleDestination_614670(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateTopicRuleDestination_614669(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a topic rule destination. You use this to change the status, endpoint URL, or confirmation URL of the destination.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614671 = header.getOrDefault("X-Amz-Signature")
  valid_614671 = validateParameter(valid_614671, JString, required = false,
                                 default = nil)
  if valid_614671 != nil:
    section.add "X-Amz-Signature", valid_614671
  var valid_614672 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614672 = validateParameter(valid_614672, JString, required = false,
                                 default = nil)
  if valid_614672 != nil:
    section.add "X-Amz-Content-Sha256", valid_614672
  var valid_614673 = header.getOrDefault("X-Amz-Date")
  valid_614673 = validateParameter(valid_614673, JString, required = false,
                                 default = nil)
  if valid_614673 != nil:
    section.add "X-Amz-Date", valid_614673
  var valid_614674 = header.getOrDefault("X-Amz-Credential")
  valid_614674 = validateParameter(valid_614674, JString, required = false,
                                 default = nil)
  if valid_614674 != nil:
    section.add "X-Amz-Credential", valid_614674
  var valid_614675 = header.getOrDefault("X-Amz-Security-Token")
  valid_614675 = validateParameter(valid_614675, JString, required = false,
                                 default = nil)
  if valid_614675 != nil:
    section.add "X-Amz-Security-Token", valid_614675
  var valid_614676 = header.getOrDefault("X-Amz-Algorithm")
  valid_614676 = validateParameter(valid_614676, JString, required = false,
                                 default = nil)
  if valid_614676 != nil:
    section.add "X-Amz-Algorithm", valid_614676
  var valid_614677 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614677 = validateParameter(valid_614677, JString, required = false,
                                 default = nil)
  if valid_614677 != nil:
    section.add "X-Amz-SignedHeaders", valid_614677
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614679: Call_UpdateTopicRuleDestination_614668; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a topic rule destination. You use this to change the status, endpoint URL, or confirmation URL of the destination.
  ## 
  let valid = call_614679.validator(path, query, header, formData, body)
  let scheme = call_614679.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614679.url(scheme.get, call_614679.host, call_614679.base,
                         call_614679.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614679, url, valid)

proc call*(call_614680: Call_UpdateTopicRuleDestination_614668; body: JsonNode): Recallable =
  ## updateTopicRuleDestination
  ## Updates a topic rule destination. You use this to change the status, endpoint URL, or confirmation URL of the destination.
  ##   body: JObject (required)
  var body_614681 = newJObject()
  if body != nil:
    body_614681 = body
  result = call_614680.call(nil, nil, nil, nil, body_614681)

var updateTopicRuleDestination* = Call_UpdateTopicRuleDestination_614668(
    name: "updateTopicRuleDestination", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/destinations",
    validator: validate_UpdateTopicRuleDestination_614669, base: "/",
    url: url_UpdateTopicRuleDestination_614670,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAccountAuditConfiguration_614682 = ref object of OpenApiRestCall_612658
proc url_DescribeAccountAuditConfiguration_614684(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeAccountAuditConfiguration_614683(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614685 = header.getOrDefault("X-Amz-Signature")
  valid_614685 = validateParameter(valid_614685, JString, required = false,
                                 default = nil)
  if valid_614685 != nil:
    section.add "X-Amz-Signature", valid_614685
  var valid_614686 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614686 = validateParameter(valid_614686, JString, required = false,
                                 default = nil)
  if valid_614686 != nil:
    section.add "X-Amz-Content-Sha256", valid_614686
  var valid_614687 = header.getOrDefault("X-Amz-Date")
  valid_614687 = validateParameter(valid_614687, JString, required = false,
                                 default = nil)
  if valid_614687 != nil:
    section.add "X-Amz-Date", valid_614687
  var valid_614688 = header.getOrDefault("X-Amz-Credential")
  valid_614688 = validateParameter(valid_614688, JString, required = false,
                                 default = nil)
  if valid_614688 != nil:
    section.add "X-Amz-Credential", valid_614688
  var valid_614689 = header.getOrDefault("X-Amz-Security-Token")
  valid_614689 = validateParameter(valid_614689, JString, required = false,
                                 default = nil)
  if valid_614689 != nil:
    section.add "X-Amz-Security-Token", valid_614689
  var valid_614690 = header.getOrDefault("X-Amz-Algorithm")
  valid_614690 = validateParameter(valid_614690, JString, required = false,
                                 default = nil)
  if valid_614690 != nil:
    section.add "X-Amz-Algorithm", valid_614690
  var valid_614691 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614691 = validateParameter(valid_614691, JString, required = false,
                                 default = nil)
  if valid_614691 != nil:
    section.add "X-Amz-SignedHeaders", valid_614691
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614692: Call_DescribeAccountAuditConfiguration_614682;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  let valid = call_614692.validator(path, query, header, formData, body)
  let scheme = call_614692.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614692.url(scheme.get, call_614692.host, call_614692.base,
                         call_614692.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614692, url, valid)

proc call*(call_614693: Call_DescribeAccountAuditConfiguration_614682): Recallable =
  ## describeAccountAuditConfiguration
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  result = call_614693.call(nil, nil, nil, nil, nil)

var describeAccountAuditConfiguration* = Call_DescribeAccountAuditConfiguration_614682(
    name: "describeAccountAuditConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_DescribeAccountAuditConfiguration_614683, base: "/",
    url: url_DescribeAccountAuditConfiguration_614684,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateAccountAuditConfiguration_614708 = ref object of OpenApiRestCall_612658
proc url_UpdateAccountAuditConfiguration_614710(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateAccountAuditConfiguration_614709(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614711 = header.getOrDefault("X-Amz-Signature")
  valid_614711 = validateParameter(valid_614711, JString, required = false,
                                 default = nil)
  if valid_614711 != nil:
    section.add "X-Amz-Signature", valid_614711
  var valid_614712 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614712 = validateParameter(valid_614712, JString, required = false,
                                 default = nil)
  if valid_614712 != nil:
    section.add "X-Amz-Content-Sha256", valid_614712
  var valid_614713 = header.getOrDefault("X-Amz-Date")
  valid_614713 = validateParameter(valid_614713, JString, required = false,
                                 default = nil)
  if valid_614713 != nil:
    section.add "X-Amz-Date", valid_614713
  var valid_614714 = header.getOrDefault("X-Amz-Credential")
  valid_614714 = validateParameter(valid_614714, JString, required = false,
                                 default = nil)
  if valid_614714 != nil:
    section.add "X-Amz-Credential", valid_614714
  var valid_614715 = header.getOrDefault("X-Amz-Security-Token")
  valid_614715 = validateParameter(valid_614715, JString, required = false,
                                 default = nil)
  if valid_614715 != nil:
    section.add "X-Amz-Security-Token", valid_614715
  var valid_614716 = header.getOrDefault("X-Amz-Algorithm")
  valid_614716 = validateParameter(valid_614716, JString, required = false,
                                 default = nil)
  if valid_614716 != nil:
    section.add "X-Amz-Algorithm", valid_614716
  var valid_614717 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614717 = validateParameter(valid_614717, JString, required = false,
                                 default = nil)
  if valid_614717 != nil:
    section.add "X-Amz-SignedHeaders", valid_614717
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614719: Call_UpdateAccountAuditConfiguration_614708;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  let valid = call_614719.validator(path, query, header, formData, body)
  let scheme = call_614719.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614719.url(scheme.get, call_614719.host, call_614719.base,
                         call_614719.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614719, url, valid)

proc call*(call_614720: Call_UpdateAccountAuditConfiguration_614708; body: JsonNode): Recallable =
  ## updateAccountAuditConfiguration
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ##   body: JObject (required)
  var body_614721 = newJObject()
  if body != nil:
    body_614721 = body
  result = call_614720.call(nil, nil, nil, nil, body_614721)

var updateAccountAuditConfiguration* = Call_UpdateAccountAuditConfiguration_614708(
    name: "updateAccountAuditConfiguration", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_UpdateAccountAuditConfiguration_614709, base: "/",
    url: url_UpdateAccountAuditConfiguration_614710,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteAccountAuditConfiguration_614694 = ref object of OpenApiRestCall_612658
proc url_DeleteAccountAuditConfiguration_614696(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteAccountAuditConfiguration_614695(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   deleteScheduledAudits: JBool
  ##                        : If true, all scheduled audits are deleted.
  section = newJObject()
  var valid_614697 = query.getOrDefault("deleteScheduledAudits")
  valid_614697 = validateParameter(valid_614697, JBool, required = false, default = nil)
  if valid_614697 != nil:
    section.add "deleteScheduledAudits", valid_614697
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614698 = header.getOrDefault("X-Amz-Signature")
  valid_614698 = validateParameter(valid_614698, JString, required = false,
                                 default = nil)
  if valid_614698 != nil:
    section.add "X-Amz-Signature", valid_614698
  var valid_614699 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614699 = validateParameter(valid_614699, JString, required = false,
                                 default = nil)
  if valid_614699 != nil:
    section.add "X-Amz-Content-Sha256", valid_614699
  var valid_614700 = header.getOrDefault("X-Amz-Date")
  valid_614700 = validateParameter(valid_614700, JString, required = false,
                                 default = nil)
  if valid_614700 != nil:
    section.add "X-Amz-Date", valid_614700
  var valid_614701 = header.getOrDefault("X-Amz-Credential")
  valid_614701 = validateParameter(valid_614701, JString, required = false,
                                 default = nil)
  if valid_614701 != nil:
    section.add "X-Amz-Credential", valid_614701
  var valid_614702 = header.getOrDefault("X-Amz-Security-Token")
  valid_614702 = validateParameter(valid_614702, JString, required = false,
                                 default = nil)
  if valid_614702 != nil:
    section.add "X-Amz-Security-Token", valid_614702
  var valid_614703 = header.getOrDefault("X-Amz-Algorithm")
  valid_614703 = validateParameter(valid_614703, JString, required = false,
                                 default = nil)
  if valid_614703 != nil:
    section.add "X-Amz-Algorithm", valid_614703
  var valid_614704 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614704 = validateParameter(valid_614704, JString, required = false,
                                 default = nil)
  if valid_614704 != nil:
    section.add "X-Amz-SignedHeaders", valid_614704
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614705: Call_DeleteAccountAuditConfiguration_614694;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ## 
  let valid = call_614705.validator(path, query, header, formData, body)
  let scheme = call_614705.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614705.url(scheme.get, call_614705.host, call_614705.base,
                         call_614705.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614705, url, valid)

proc call*(call_614706: Call_DeleteAccountAuditConfiguration_614694;
          deleteScheduledAudits: bool = false): Recallable =
  ## deleteAccountAuditConfiguration
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ##   deleteScheduledAudits: bool
  ##                        : If true, all scheduled audits are deleted.
  var query_614707 = newJObject()
  add(query_614707, "deleteScheduledAudits", newJBool(deleteScheduledAudits))
  result = call_614706.call(nil, query_614707, nil, nil, nil)

var deleteAccountAuditConfiguration* = Call_DeleteAccountAuditConfiguration_614694(
    name: "deleteAccountAuditConfiguration", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_DeleteAccountAuditConfiguration_614695, base: "/",
    url: url_DeleteAccountAuditConfiguration_614696,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateCACertificate_614736 = ref object of OpenApiRestCall_612658
proc url_UpdateCACertificate_614738(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateCACertificate_614737(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Updates a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The CA certificate identifier.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_614739 = path.getOrDefault("caCertificateId")
  valid_614739 = validateParameter(valid_614739, JString, required = true,
                                 default = nil)
  if valid_614739 != nil:
    section.add "caCertificateId", valid_614739
  result.add "path", section
  ## parameters in `query` object:
  ##   newAutoRegistrationStatus: JString
  ##                            : The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
  ##   newStatus: JString
  ##            : <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  section = newJObject()
  var valid_614753 = query.getOrDefault("newAutoRegistrationStatus")
  valid_614753 = validateParameter(valid_614753, JString, required = false,
                                 default = newJString("ENABLE"))
  if valid_614753 != nil:
    section.add "newAutoRegistrationStatus", valid_614753
  var valid_614754 = query.getOrDefault("newStatus")
  valid_614754 = validateParameter(valid_614754, JString, required = false,
                                 default = newJString("ACTIVE"))
  if valid_614754 != nil:
    section.add "newStatus", valid_614754
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614755 = header.getOrDefault("X-Amz-Signature")
  valid_614755 = validateParameter(valid_614755, JString, required = false,
                                 default = nil)
  if valid_614755 != nil:
    section.add "X-Amz-Signature", valid_614755
  var valid_614756 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614756 = validateParameter(valid_614756, JString, required = false,
                                 default = nil)
  if valid_614756 != nil:
    section.add "X-Amz-Content-Sha256", valid_614756
  var valid_614757 = header.getOrDefault("X-Amz-Date")
  valid_614757 = validateParameter(valid_614757, JString, required = false,
                                 default = nil)
  if valid_614757 != nil:
    section.add "X-Amz-Date", valid_614757
  var valid_614758 = header.getOrDefault("X-Amz-Credential")
  valid_614758 = validateParameter(valid_614758, JString, required = false,
                                 default = nil)
  if valid_614758 != nil:
    section.add "X-Amz-Credential", valid_614758
  var valid_614759 = header.getOrDefault("X-Amz-Security-Token")
  valid_614759 = validateParameter(valid_614759, JString, required = false,
                                 default = nil)
  if valid_614759 != nil:
    section.add "X-Amz-Security-Token", valid_614759
  var valid_614760 = header.getOrDefault("X-Amz-Algorithm")
  valid_614760 = validateParameter(valid_614760, JString, required = false,
                                 default = nil)
  if valid_614760 != nil:
    section.add "X-Amz-Algorithm", valid_614760
  var valid_614761 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614761 = validateParameter(valid_614761, JString, required = false,
                                 default = nil)
  if valid_614761 != nil:
    section.add "X-Amz-SignedHeaders", valid_614761
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614763: Call_UpdateCACertificate_614736; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a registered CA certificate.
  ## 
  let valid = call_614763.validator(path, query, header, formData, body)
  let scheme = call_614763.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614763.url(scheme.get, call_614763.host, call_614763.base,
                         call_614763.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614763, url, valid)

proc call*(call_614764: Call_UpdateCACertificate_614736; caCertificateId: string;
          body: JsonNode; newAutoRegistrationStatus: string = "ENABLE";
          newStatus: string = "ACTIVE"): Recallable =
  ## updateCACertificate
  ## Updates a registered CA certificate.
  ##   newAutoRegistrationStatus: string
  ##                            : The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
  ##   caCertificateId: string (required)
  ##                  : The CA certificate identifier.
  ##   newStatus: string
  ##            : <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  ##   body: JObject (required)
  var path_614765 = newJObject()
  var query_614766 = newJObject()
  var body_614767 = newJObject()
  add(query_614766, "newAutoRegistrationStatus",
      newJString(newAutoRegistrationStatus))
  add(path_614765, "caCertificateId", newJString(caCertificateId))
  add(query_614766, "newStatus", newJString(newStatus))
  if body != nil:
    body_614767 = body
  result = call_614764.call(path_614765, query_614766, nil, nil, body_614767)

var updateCACertificate* = Call_UpdateCACertificate_614736(
    name: "updateCACertificate", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_UpdateCACertificate_614737, base: "/",
    url: url_UpdateCACertificate_614738, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeCACertificate_614722 = ref object of OpenApiRestCall_612658
proc url_DescribeCACertificate_614724(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeCACertificate_614723(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The CA certificate identifier.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_614725 = path.getOrDefault("caCertificateId")
  valid_614725 = validateParameter(valid_614725, JString, required = true,
                                 default = nil)
  if valid_614725 != nil:
    section.add "caCertificateId", valid_614725
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614726 = header.getOrDefault("X-Amz-Signature")
  valid_614726 = validateParameter(valid_614726, JString, required = false,
                                 default = nil)
  if valid_614726 != nil:
    section.add "X-Amz-Signature", valid_614726
  var valid_614727 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614727 = validateParameter(valid_614727, JString, required = false,
                                 default = nil)
  if valid_614727 != nil:
    section.add "X-Amz-Content-Sha256", valid_614727
  var valid_614728 = header.getOrDefault("X-Amz-Date")
  valid_614728 = validateParameter(valid_614728, JString, required = false,
                                 default = nil)
  if valid_614728 != nil:
    section.add "X-Amz-Date", valid_614728
  var valid_614729 = header.getOrDefault("X-Amz-Credential")
  valid_614729 = validateParameter(valid_614729, JString, required = false,
                                 default = nil)
  if valid_614729 != nil:
    section.add "X-Amz-Credential", valid_614729
  var valid_614730 = header.getOrDefault("X-Amz-Security-Token")
  valid_614730 = validateParameter(valid_614730, JString, required = false,
                                 default = nil)
  if valid_614730 != nil:
    section.add "X-Amz-Security-Token", valid_614730
  var valid_614731 = header.getOrDefault("X-Amz-Algorithm")
  valid_614731 = validateParameter(valid_614731, JString, required = false,
                                 default = nil)
  if valid_614731 != nil:
    section.add "X-Amz-Algorithm", valid_614731
  var valid_614732 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614732 = validateParameter(valid_614732, JString, required = false,
                                 default = nil)
  if valid_614732 != nil:
    section.add "X-Amz-SignedHeaders", valid_614732
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614733: Call_DescribeCACertificate_614722; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a registered CA certificate.
  ## 
  let valid = call_614733.validator(path, query, header, formData, body)
  let scheme = call_614733.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614733.url(scheme.get, call_614733.host, call_614733.base,
                         call_614733.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614733, url, valid)

proc call*(call_614734: Call_DescribeCACertificate_614722; caCertificateId: string): Recallable =
  ## describeCACertificate
  ## Describes a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The CA certificate identifier.
  var path_614735 = newJObject()
  add(path_614735, "caCertificateId", newJString(caCertificateId))
  result = call_614734.call(path_614735, nil, nil, nil, nil)

var describeCACertificate* = Call_DescribeCACertificate_614722(
    name: "describeCACertificate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_DescribeCACertificate_614723, base: "/",
    url: url_DescribeCACertificate_614724, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteCACertificate_614768 = ref object of OpenApiRestCall_612658
proc url_DeleteCACertificate_614770(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteCACertificate_614769(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Deletes a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_614771 = path.getOrDefault("caCertificateId")
  valid_614771 = validateParameter(valid_614771, JString, required = true,
                                 default = nil)
  if valid_614771 != nil:
    section.add "caCertificateId", valid_614771
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614772 = header.getOrDefault("X-Amz-Signature")
  valid_614772 = validateParameter(valid_614772, JString, required = false,
                                 default = nil)
  if valid_614772 != nil:
    section.add "X-Amz-Signature", valid_614772
  var valid_614773 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614773 = validateParameter(valid_614773, JString, required = false,
                                 default = nil)
  if valid_614773 != nil:
    section.add "X-Amz-Content-Sha256", valid_614773
  var valid_614774 = header.getOrDefault("X-Amz-Date")
  valid_614774 = validateParameter(valid_614774, JString, required = false,
                                 default = nil)
  if valid_614774 != nil:
    section.add "X-Amz-Date", valid_614774
  var valid_614775 = header.getOrDefault("X-Amz-Credential")
  valid_614775 = validateParameter(valid_614775, JString, required = false,
                                 default = nil)
  if valid_614775 != nil:
    section.add "X-Amz-Credential", valid_614775
  var valid_614776 = header.getOrDefault("X-Amz-Security-Token")
  valid_614776 = validateParameter(valid_614776, JString, required = false,
                                 default = nil)
  if valid_614776 != nil:
    section.add "X-Amz-Security-Token", valid_614776
  var valid_614777 = header.getOrDefault("X-Amz-Algorithm")
  valid_614777 = validateParameter(valid_614777, JString, required = false,
                                 default = nil)
  if valid_614777 != nil:
    section.add "X-Amz-Algorithm", valid_614777
  var valid_614778 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614778 = validateParameter(valid_614778, JString, required = false,
                                 default = nil)
  if valid_614778 != nil:
    section.add "X-Amz-SignedHeaders", valid_614778
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614779: Call_DeleteCACertificate_614768; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a registered CA certificate.
  ## 
  let valid = call_614779.validator(path, query, header, formData, body)
  let scheme = call_614779.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614779.url(scheme.get, call_614779.host, call_614779.base,
                         call_614779.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614779, url, valid)

proc call*(call_614780: Call_DeleteCACertificate_614768; caCertificateId: string): Recallable =
  ## deleteCACertificate
  ## Deletes a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
  var path_614781 = newJObject()
  add(path_614781, "caCertificateId", newJString(caCertificateId))
  result = call_614780.call(path_614781, nil, nil, nil, nil)

var deleteCACertificate* = Call_DeleteCACertificate_614768(
    name: "deleteCACertificate", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_DeleteCACertificate_614769, base: "/",
    url: url_DeleteCACertificate_614770, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeCertificate_614782 = ref object of OpenApiRestCall_612658
proc url_DescribeCertificate_614784(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeCertificate_614783(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets information about the specified certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_614785 = path.getOrDefault("certificateId")
  valid_614785 = validateParameter(valid_614785, JString, required = true,
                                 default = nil)
  if valid_614785 != nil:
    section.add "certificateId", valid_614785
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614786 = header.getOrDefault("X-Amz-Signature")
  valid_614786 = validateParameter(valid_614786, JString, required = false,
                                 default = nil)
  if valid_614786 != nil:
    section.add "X-Amz-Signature", valid_614786
  var valid_614787 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614787 = validateParameter(valid_614787, JString, required = false,
                                 default = nil)
  if valid_614787 != nil:
    section.add "X-Amz-Content-Sha256", valid_614787
  var valid_614788 = header.getOrDefault("X-Amz-Date")
  valid_614788 = validateParameter(valid_614788, JString, required = false,
                                 default = nil)
  if valid_614788 != nil:
    section.add "X-Amz-Date", valid_614788
  var valid_614789 = header.getOrDefault("X-Amz-Credential")
  valid_614789 = validateParameter(valid_614789, JString, required = false,
                                 default = nil)
  if valid_614789 != nil:
    section.add "X-Amz-Credential", valid_614789
  var valid_614790 = header.getOrDefault("X-Amz-Security-Token")
  valid_614790 = validateParameter(valid_614790, JString, required = false,
                                 default = nil)
  if valid_614790 != nil:
    section.add "X-Amz-Security-Token", valid_614790
  var valid_614791 = header.getOrDefault("X-Amz-Algorithm")
  valid_614791 = validateParameter(valid_614791, JString, required = false,
                                 default = nil)
  if valid_614791 != nil:
    section.add "X-Amz-Algorithm", valid_614791
  var valid_614792 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614792 = validateParameter(valid_614792, JString, required = false,
                                 default = nil)
  if valid_614792 != nil:
    section.add "X-Amz-SignedHeaders", valid_614792
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614793: Call_DescribeCertificate_614782; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified certificate.
  ## 
  let valid = call_614793.validator(path, query, header, formData, body)
  let scheme = call_614793.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614793.url(scheme.get, call_614793.host, call_614793.base,
                         call_614793.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614793, url, valid)

proc call*(call_614794: Call_DescribeCertificate_614782; certificateId: string): Recallable =
  ## describeCertificate
  ## Gets information about the specified certificate.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_614795 = newJObject()
  add(path_614795, "certificateId", newJString(certificateId))
  result = call_614794.call(path_614795, nil, nil, nil, nil)

var describeCertificate* = Call_DescribeCertificate_614782(
    name: "describeCertificate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates/{certificateId}",
    validator: validate_DescribeCertificate_614783, base: "/",
    url: url_DescribeCertificate_614784, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteCertificate_614796 = ref object of OpenApiRestCall_612658
proc url_DeleteCertificate_614798(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteCertificate_614797(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_614799 = path.getOrDefault("certificateId")
  valid_614799 = validateParameter(valid_614799, JString, required = true,
                                 default = nil)
  if valid_614799 != nil:
    section.add "certificateId", valid_614799
  result.add "path", section
  ## parameters in `query` object:
  ##   forceDelete: JBool
  ##              : Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
  section = newJObject()
  var valid_614800 = query.getOrDefault("forceDelete")
  valid_614800 = validateParameter(valid_614800, JBool, required = false, default = nil)
  if valid_614800 != nil:
    section.add "forceDelete", valid_614800
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614801 = header.getOrDefault("X-Amz-Signature")
  valid_614801 = validateParameter(valid_614801, JString, required = false,
                                 default = nil)
  if valid_614801 != nil:
    section.add "X-Amz-Signature", valid_614801
  var valid_614802 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614802 = validateParameter(valid_614802, JString, required = false,
                                 default = nil)
  if valid_614802 != nil:
    section.add "X-Amz-Content-Sha256", valid_614802
  var valid_614803 = header.getOrDefault("X-Amz-Date")
  valid_614803 = validateParameter(valid_614803, JString, required = false,
                                 default = nil)
  if valid_614803 != nil:
    section.add "X-Amz-Date", valid_614803
  var valid_614804 = header.getOrDefault("X-Amz-Credential")
  valid_614804 = validateParameter(valid_614804, JString, required = false,
                                 default = nil)
  if valid_614804 != nil:
    section.add "X-Amz-Credential", valid_614804
  var valid_614805 = header.getOrDefault("X-Amz-Security-Token")
  valid_614805 = validateParameter(valid_614805, JString, required = false,
                                 default = nil)
  if valid_614805 != nil:
    section.add "X-Amz-Security-Token", valid_614805
  var valid_614806 = header.getOrDefault("X-Amz-Algorithm")
  valid_614806 = validateParameter(valid_614806, JString, required = false,
                                 default = nil)
  if valid_614806 != nil:
    section.add "X-Amz-Algorithm", valid_614806
  var valid_614807 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614807 = validateParameter(valid_614807, JString, required = false,
                                 default = nil)
  if valid_614807 != nil:
    section.add "X-Amz-SignedHeaders", valid_614807
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614808: Call_DeleteCertificate_614796; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ## 
  let valid = call_614808.validator(path, query, header, formData, body)
  let scheme = call_614808.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614808.url(scheme.get, call_614808.host, call_614808.base,
                         call_614808.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614808, url, valid)

proc call*(call_614809: Call_DeleteCertificate_614796; certificateId: string;
          forceDelete: bool = false): Recallable =
  ## deleteCertificate
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ##   forceDelete: bool
  ##              : Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_614810 = newJObject()
  var query_614811 = newJObject()
  add(query_614811, "forceDelete", newJBool(forceDelete))
  add(path_614810, "certificateId", newJString(certificateId))
  result = call_614809.call(path_614810, query_614811, nil, nil, nil)

var deleteCertificate* = Call_DeleteCertificate_614796(name: "deleteCertificate",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/certificates/{certificateId}", validator: validate_DeleteCertificate_614797,
    base: "/", url: url_DeleteCertificate_614798,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteJobExecution_614812 = ref object of OpenApiRestCall_612658
proc url_DeleteJobExecution_614814(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  assert "executionNumber" in path, "`executionNumber` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/executionNumber/"),
               (kind: VariableSegment, value: "executionNumber")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteJobExecution_614813(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deletes a job execution.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   executionNumber: JInt (required)
  ##                  : <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
  ##   jobId: JString (required)
  ##        : The ID of the job whose execution on a particular device will be deleted.
  ##   thingName: JString (required)
  ##            : The name of the thing whose job execution will be deleted.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `executionNumber` field"
  var valid_614815 = path.getOrDefault("executionNumber")
  valid_614815 = validateParameter(valid_614815, JInt, required = true, default = nil)
  if valid_614815 != nil:
    section.add "executionNumber", valid_614815
  var valid_614816 = path.getOrDefault("jobId")
  valid_614816 = validateParameter(valid_614816, JString, required = true,
                                 default = nil)
  if valid_614816 != nil:
    section.add "jobId", valid_614816
  var valid_614817 = path.getOrDefault("thingName")
  valid_614817 = validateParameter(valid_614817, JString, required = true,
                                 default = nil)
  if valid_614817 != nil:
    section.add "thingName", valid_614817
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
  section = newJObject()
  var valid_614818 = query.getOrDefault("force")
  valid_614818 = validateParameter(valid_614818, JBool, required = false, default = nil)
  if valid_614818 != nil:
    section.add "force", valid_614818
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614819 = header.getOrDefault("X-Amz-Signature")
  valid_614819 = validateParameter(valid_614819, JString, required = false,
                                 default = nil)
  if valid_614819 != nil:
    section.add "X-Amz-Signature", valid_614819
  var valid_614820 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614820 = validateParameter(valid_614820, JString, required = false,
                                 default = nil)
  if valid_614820 != nil:
    section.add "X-Amz-Content-Sha256", valid_614820
  var valid_614821 = header.getOrDefault("X-Amz-Date")
  valid_614821 = validateParameter(valid_614821, JString, required = false,
                                 default = nil)
  if valid_614821 != nil:
    section.add "X-Amz-Date", valid_614821
  var valid_614822 = header.getOrDefault("X-Amz-Credential")
  valid_614822 = validateParameter(valid_614822, JString, required = false,
                                 default = nil)
  if valid_614822 != nil:
    section.add "X-Amz-Credential", valid_614822
  var valid_614823 = header.getOrDefault("X-Amz-Security-Token")
  valid_614823 = validateParameter(valid_614823, JString, required = false,
                                 default = nil)
  if valid_614823 != nil:
    section.add "X-Amz-Security-Token", valid_614823
  var valid_614824 = header.getOrDefault("X-Amz-Algorithm")
  valid_614824 = validateParameter(valid_614824, JString, required = false,
                                 default = nil)
  if valid_614824 != nil:
    section.add "X-Amz-Algorithm", valid_614824
  var valid_614825 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614825 = validateParameter(valid_614825, JString, required = false,
                                 default = nil)
  if valid_614825 != nil:
    section.add "X-Amz-SignedHeaders", valid_614825
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614826: Call_DeleteJobExecution_614812; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a job execution.
  ## 
  let valid = call_614826.validator(path, query, header, formData, body)
  let scheme = call_614826.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614826.url(scheme.get, call_614826.host, call_614826.base,
                         call_614826.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614826, url, valid)

proc call*(call_614827: Call_DeleteJobExecution_614812; executionNumber: int;
          jobId: string; thingName: string; force: bool = false): Recallable =
  ## deleteJobExecution
  ## Deletes a job execution.
  ##   executionNumber: int (required)
  ##                  : <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
  ##   jobId: string (required)
  ##        : The ID of the job whose execution on a particular device will be deleted.
  ##   thingName: string (required)
  ##            : The name of the thing whose job execution will be deleted.
  ##   force: bool
  ##        : <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
  var path_614828 = newJObject()
  var query_614829 = newJObject()
  add(path_614828, "executionNumber", newJInt(executionNumber))
  add(path_614828, "jobId", newJString(jobId))
  add(path_614828, "thingName", newJString(thingName))
  add(query_614829, "force", newJBool(force))
  result = call_614827.call(path_614828, query_614829, nil, nil, nil)

var deleteJobExecution* = Call_DeleteJobExecution_614812(
    name: "deleteJobExecution", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}",
    validator: validate_DeleteJobExecution_614813, base: "/",
    url: url_DeleteJobExecution_614814, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPolicyVersion_614830 = ref object of OpenApiRestCall_612658
proc url_GetPolicyVersion_614832(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetPolicyVersion_614831(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets information about the specified policy version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_614833 = path.getOrDefault("policyName")
  valid_614833 = validateParameter(valid_614833, JString, required = true,
                                 default = nil)
  if valid_614833 != nil:
    section.add "policyName", valid_614833
  var valid_614834 = path.getOrDefault("policyVersionId")
  valid_614834 = validateParameter(valid_614834, JString, required = true,
                                 default = nil)
  if valid_614834 != nil:
    section.add "policyVersionId", valid_614834
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614835 = header.getOrDefault("X-Amz-Signature")
  valid_614835 = validateParameter(valid_614835, JString, required = false,
                                 default = nil)
  if valid_614835 != nil:
    section.add "X-Amz-Signature", valid_614835
  var valid_614836 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614836 = validateParameter(valid_614836, JString, required = false,
                                 default = nil)
  if valid_614836 != nil:
    section.add "X-Amz-Content-Sha256", valid_614836
  var valid_614837 = header.getOrDefault("X-Amz-Date")
  valid_614837 = validateParameter(valid_614837, JString, required = false,
                                 default = nil)
  if valid_614837 != nil:
    section.add "X-Amz-Date", valid_614837
  var valid_614838 = header.getOrDefault("X-Amz-Credential")
  valid_614838 = validateParameter(valid_614838, JString, required = false,
                                 default = nil)
  if valid_614838 != nil:
    section.add "X-Amz-Credential", valid_614838
  var valid_614839 = header.getOrDefault("X-Amz-Security-Token")
  valid_614839 = validateParameter(valid_614839, JString, required = false,
                                 default = nil)
  if valid_614839 != nil:
    section.add "X-Amz-Security-Token", valid_614839
  var valid_614840 = header.getOrDefault("X-Amz-Algorithm")
  valid_614840 = validateParameter(valid_614840, JString, required = false,
                                 default = nil)
  if valid_614840 != nil:
    section.add "X-Amz-Algorithm", valid_614840
  var valid_614841 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614841 = validateParameter(valid_614841, JString, required = false,
                                 default = nil)
  if valid_614841 != nil:
    section.add "X-Amz-SignedHeaders", valid_614841
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614842: Call_GetPolicyVersion_614830; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified policy version.
  ## 
  let valid = call_614842.validator(path, query, header, formData, body)
  let scheme = call_614842.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614842.url(scheme.get, call_614842.host, call_614842.base,
                         call_614842.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614842, url, valid)

proc call*(call_614843: Call_GetPolicyVersion_614830; policyName: string;
          policyVersionId: string): Recallable =
  ## getPolicyVersion
  ## Gets information about the specified policy version.
  ##   policyName: string (required)
  ##             : The name of the policy.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_614844 = newJObject()
  add(path_614844, "policyName", newJString(policyName))
  add(path_614844, "policyVersionId", newJString(policyVersionId))
  result = call_614843.call(path_614844, nil, nil, nil, nil)

var getPolicyVersion* = Call_GetPolicyVersion_614830(name: "getPolicyVersion",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_GetPolicyVersion_614831, base: "/",
    url: url_GetPolicyVersion_614832, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetDefaultPolicyVersion_614860 = ref object of OpenApiRestCall_612658
proc url_SetDefaultPolicyVersion_614862(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_SetDefaultPolicyVersion_614861(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_614863 = path.getOrDefault("policyName")
  valid_614863 = validateParameter(valid_614863, JString, required = true,
                                 default = nil)
  if valid_614863 != nil:
    section.add "policyName", valid_614863
  var valid_614864 = path.getOrDefault("policyVersionId")
  valid_614864 = validateParameter(valid_614864, JString, required = true,
                                 default = nil)
  if valid_614864 != nil:
    section.add "policyVersionId", valid_614864
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614865 = header.getOrDefault("X-Amz-Signature")
  valid_614865 = validateParameter(valid_614865, JString, required = false,
                                 default = nil)
  if valid_614865 != nil:
    section.add "X-Amz-Signature", valid_614865
  var valid_614866 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614866 = validateParameter(valid_614866, JString, required = false,
                                 default = nil)
  if valid_614866 != nil:
    section.add "X-Amz-Content-Sha256", valid_614866
  var valid_614867 = header.getOrDefault("X-Amz-Date")
  valid_614867 = validateParameter(valid_614867, JString, required = false,
                                 default = nil)
  if valid_614867 != nil:
    section.add "X-Amz-Date", valid_614867
  var valid_614868 = header.getOrDefault("X-Amz-Credential")
  valid_614868 = validateParameter(valid_614868, JString, required = false,
                                 default = nil)
  if valid_614868 != nil:
    section.add "X-Amz-Credential", valid_614868
  var valid_614869 = header.getOrDefault("X-Amz-Security-Token")
  valid_614869 = validateParameter(valid_614869, JString, required = false,
                                 default = nil)
  if valid_614869 != nil:
    section.add "X-Amz-Security-Token", valid_614869
  var valid_614870 = header.getOrDefault("X-Amz-Algorithm")
  valid_614870 = validateParameter(valid_614870, JString, required = false,
                                 default = nil)
  if valid_614870 != nil:
    section.add "X-Amz-Algorithm", valid_614870
  var valid_614871 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614871 = validateParameter(valid_614871, JString, required = false,
                                 default = nil)
  if valid_614871 != nil:
    section.add "X-Amz-SignedHeaders", valid_614871
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614872: Call_SetDefaultPolicyVersion_614860; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ## 
  let valid = call_614872.validator(path, query, header, formData, body)
  let scheme = call_614872.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614872.url(scheme.get, call_614872.host, call_614872.base,
                         call_614872.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614872, url, valid)

proc call*(call_614873: Call_SetDefaultPolicyVersion_614860; policyName: string;
          policyVersionId: string): Recallable =
  ## setDefaultPolicyVersion
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ##   policyName: string (required)
  ##             : The policy name.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_614874 = newJObject()
  add(path_614874, "policyName", newJString(policyName))
  add(path_614874, "policyVersionId", newJString(policyVersionId))
  result = call_614873.call(path_614874, nil, nil, nil, nil)

var setDefaultPolicyVersion* = Call_SetDefaultPolicyVersion_614860(
    name: "setDefaultPolicyVersion", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_SetDefaultPolicyVersion_614861, base: "/",
    url: url_SetDefaultPolicyVersion_614862, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeletePolicyVersion_614845 = ref object of OpenApiRestCall_612658
proc url_DeletePolicyVersion_614847(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeletePolicyVersion_614846(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_614848 = path.getOrDefault("policyName")
  valid_614848 = validateParameter(valid_614848, JString, required = true,
                                 default = nil)
  if valid_614848 != nil:
    section.add "policyName", valid_614848
  var valid_614849 = path.getOrDefault("policyVersionId")
  valid_614849 = validateParameter(valid_614849, JString, required = true,
                                 default = nil)
  if valid_614849 != nil:
    section.add "policyVersionId", valid_614849
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614850 = header.getOrDefault("X-Amz-Signature")
  valid_614850 = validateParameter(valid_614850, JString, required = false,
                                 default = nil)
  if valid_614850 != nil:
    section.add "X-Amz-Signature", valid_614850
  var valid_614851 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614851 = validateParameter(valid_614851, JString, required = false,
                                 default = nil)
  if valid_614851 != nil:
    section.add "X-Amz-Content-Sha256", valid_614851
  var valid_614852 = header.getOrDefault("X-Amz-Date")
  valid_614852 = validateParameter(valid_614852, JString, required = false,
                                 default = nil)
  if valid_614852 != nil:
    section.add "X-Amz-Date", valid_614852
  var valid_614853 = header.getOrDefault("X-Amz-Credential")
  valid_614853 = validateParameter(valid_614853, JString, required = false,
                                 default = nil)
  if valid_614853 != nil:
    section.add "X-Amz-Credential", valid_614853
  var valid_614854 = header.getOrDefault("X-Amz-Security-Token")
  valid_614854 = validateParameter(valid_614854, JString, required = false,
                                 default = nil)
  if valid_614854 != nil:
    section.add "X-Amz-Security-Token", valid_614854
  var valid_614855 = header.getOrDefault("X-Amz-Algorithm")
  valid_614855 = validateParameter(valid_614855, JString, required = false,
                                 default = nil)
  if valid_614855 != nil:
    section.add "X-Amz-Algorithm", valid_614855
  var valid_614856 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614856 = validateParameter(valid_614856, JString, required = false,
                                 default = nil)
  if valid_614856 != nil:
    section.add "X-Amz-SignedHeaders", valid_614856
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614857: Call_DeletePolicyVersion_614845; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ## 
  let valid = call_614857.validator(path, query, header, formData, body)
  let scheme = call_614857.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614857.url(scheme.get, call_614857.host, call_614857.base,
                         call_614857.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614857, url, valid)

proc call*(call_614858: Call_DeletePolicyVersion_614845; policyName: string;
          policyVersionId: string): Recallable =
  ## deletePolicyVersion
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ##   policyName: string (required)
  ##             : The name of the policy.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_614859 = newJObject()
  add(path_614859, "policyName", newJString(policyName))
  add(path_614859, "policyVersionId", newJString(policyVersionId))
  result = call_614858.call(path_614859, nil, nil, nil, nil)

var deletePolicyVersion* = Call_DeletePolicyVersion_614845(
    name: "deletePolicyVersion", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_DeletePolicyVersion_614846, base: "/",
    url: url_DeletePolicyVersion_614847, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeProvisioningTemplate_614875 = ref object of OpenApiRestCall_612658
proc url_DescribeProvisioningTemplate_614877(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeProvisioningTemplate_614876(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_614878 = path.getOrDefault("templateName")
  valid_614878 = validateParameter(valid_614878, JString, required = true,
                                 default = nil)
  if valid_614878 != nil:
    section.add "templateName", valid_614878
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614879 = header.getOrDefault("X-Amz-Signature")
  valid_614879 = validateParameter(valid_614879, JString, required = false,
                                 default = nil)
  if valid_614879 != nil:
    section.add "X-Amz-Signature", valid_614879
  var valid_614880 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614880 = validateParameter(valid_614880, JString, required = false,
                                 default = nil)
  if valid_614880 != nil:
    section.add "X-Amz-Content-Sha256", valid_614880
  var valid_614881 = header.getOrDefault("X-Amz-Date")
  valid_614881 = validateParameter(valid_614881, JString, required = false,
                                 default = nil)
  if valid_614881 != nil:
    section.add "X-Amz-Date", valid_614881
  var valid_614882 = header.getOrDefault("X-Amz-Credential")
  valid_614882 = validateParameter(valid_614882, JString, required = false,
                                 default = nil)
  if valid_614882 != nil:
    section.add "X-Amz-Credential", valid_614882
  var valid_614883 = header.getOrDefault("X-Amz-Security-Token")
  valid_614883 = validateParameter(valid_614883, JString, required = false,
                                 default = nil)
  if valid_614883 != nil:
    section.add "X-Amz-Security-Token", valid_614883
  var valid_614884 = header.getOrDefault("X-Amz-Algorithm")
  valid_614884 = validateParameter(valid_614884, JString, required = false,
                                 default = nil)
  if valid_614884 != nil:
    section.add "X-Amz-Algorithm", valid_614884
  var valid_614885 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614885 = validateParameter(valid_614885, JString, required = false,
                                 default = nil)
  if valid_614885 != nil:
    section.add "X-Amz-SignedHeaders", valid_614885
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614886: Call_DescribeProvisioningTemplate_614875; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about a fleet provisioning template.
  ## 
  let valid = call_614886.validator(path, query, header, formData, body)
  let scheme = call_614886.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614886.url(scheme.get, call_614886.host, call_614886.base,
                         call_614886.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614886, url, valid)

proc call*(call_614887: Call_DescribeProvisioningTemplate_614875;
          templateName: string): Recallable =
  ## describeProvisioningTemplate
  ## Returns information about a fleet provisioning template.
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template.
  var path_614888 = newJObject()
  add(path_614888, "templateName", newJString(templateName))
  result = call_614887.call(path_614888, nil, nil, nil, nil)

var describeProvisioningTemplate* = Call_DescribeProvisioningTemplate_614875(
    name: "describeProvisioningTemplate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/provisioning-templates/{templateName}",
    validator: validate_DescribeProvisioningTemplate_614876, base: "/",
    url: url_DescribeProvisioningTemplate_614877,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateProvisioningTemplate_614903 = ref object of OpenApiRestCall_612658
proc url_UpdateProvisioningTemplate_614905(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateProvisioningTemplate_614904(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_614906 = path.getOrDefault("templateName")
  valid_614906 = validateParameter(valid_614906, JString, required = true,
                                 default = nil)
  if valid_614906 != nil:
    section.add "templateName", valid_614906
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614907 = header.getOrDefault("X-Amz-Signature")
  valid_614907 = validateParameter(valid_614907, JString, required = false,
                                 default = nil)
  if valid_614907 != nil:
    section.add "X-Amz-Signature", valid_614907
  var valid_614908 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614908 = validateParameter(valid_614908, JString, required = false,
                                 default = nil)
  if valid_614908 != nil:
    section.add "X-Amz-Content-Sha256", valid_614908
  var valid_614909 = header.getOrDefault("X-Amz-Date")
  valid_614909 = validateParameter(valid_614909, JString, required = false,
                                 default = nil)
  if valid_614909 != nil:
    section.add "X-Amz-Date", valid_614909
  var valid_614910 = header.getOrDefault("X-Amz-Credential")
  valid_614910 = validateParameter(valid_614910, JString, required = false,
                                 default = nil)
  if valid_614910 != nil:
    section.add "X-Amz-Credential", valid_614910
  var valid_614911 = header.getOrDefault("X-Amz-Security-Token")
  valid_614911 = validateParameter(valid_614911, JString, required = false,
                                 default = nil)
  if valid_614911 != nil:
    section.add "X-Amz-Security-Token", valid_614911
  var valid_614912 = header.getOrDefault("X-Amz-Algorithm")
  valid_614912 = validateParameter(valid_614912, JString, required = false,
                                 default = nil)
  if valid_614912 != nil:
    section.add "X-Amz-Algorithm", valid_614912
  var valid_614913 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614913 = validateParameter(valid_614913, JString, required = false,
                                 default = nil)
  if valid_614913 != nil:
    section.add "X-Amz-SignedHeaders", valid_614913
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614915: Call_UpdateProvisioningTemplate_614903; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a fleet provisioning template.
  ## 
  let valid = call_614915.validator(path, query, header, formData, body)
  let scheme = call_614915.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614915.url(scheme.get, call_614915.host, call_614915.base,
                         call_614915.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614915, url, valid)

proc call*(call_614916: Call_UpdateProvisioningTemplate_614903; body: JsonNode;
          templateName: string): Recallable =
  ## updateProvisioningTemplate
  ## Updates a fleet provisioning template.
  ##   body: JObject (required)
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template.
  var path_614917 = newJObject()
  var body_614918 = newJObject()
  if body != nil:
    body_614918 = body
  add(path_614917, "templateName", newJString(templateName))
  result = call_614916.call(path_614917, nil, nil, nil, body_614918)

var updateProvisioningTemplate* = Call_UpdateProvisioningTemplate_614903(
    name: "updateProvisioningTemplate", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/provisioning-templates/{templateName}",
    validator: validate_UpdateProvisioningTemplate_614904, base: "/",
    url: url_UpdateProvisioningTemplate_614905,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteProvisioningTemplate_614889 = ref object of OpenApiRestCall_612658
proc url_DeleteProvisioningTemplate_614891(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteProvisioningTemplate_614890(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provision template to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_614892 = path.getOrDefault("templateName")
  valid_614892 = validateParameter(valid_614892, JString, required = true,
                                 default = nil)
  if valid_614892 != nil:
    section.add "templateName", valid_614892
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614893 = header.getOrDefault("X-Amz-Signature")
  valid_614893 = validateParameter(valid_614893, JString, required = false,
                                 default = nil)
  if valid_614893 != nil:
    section.add "X-Amz-Signature", valid_614893
  var valid_614894 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614894 = validateParameter(valid_614894, JString, required = false,
                                 default = nil)
  if valid_614894 != nil:
    section.add "X-Amz-Content-Sha256", valid_614894
  var valid_614895 = header.getOrDefault("X-Amz-Date")
  valid_614895 = validateParameter(valid_614895, JString, required = false,
                                 default = nil)
  if valid_614895 != nil:
    section.add "X-Amz-Date", valid_614895
  var valid_614896 = header.getOrDefault("X-Amz-Credential")
  valid_614896 = validateParameter(valid_614896, JString, required = false,
                                 default = nil)
  if valid_614896 != nil:
    section.add "X-Amz-Credential", valid_614896
  var valid_614897 = header.getOrDefault("X-Amz-Security-Token")
  valid_614897 = validateParameter(valid_614897, JString, required = false,
                                 default = nil)
  if valid_614897 != nil:
    section.add "X-Amz-Security-Token", valid_614897
  var valid_614898 = header.getOrDefault("X-Amz-Algorithm")
  valid_614898 = validateParameter(valid_614898, JString, required = false,
                                 default = nil)
  if valid_614898 != nil:
    section.add "X-Amz-Algorithm", valid_614898
  var valid_614899 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614899 = validateParameter(valid_614899, JString, required = false,
                                 default = nil)
  if valid_614899 != nil:
    section.add "X-Amz-SignedHeaders", valid_614899
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614900: Call_DeleteProvisioningTemplate_614889; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a fleet provisioning template.
  ## 
  let valid = call_614900.validator(path, query, header, formData, body)
  let scheme = call_614900.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614900.url(scheme.get, call_614900.host, call_614900.base,
                         call_614900.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614900, url, valid)

proc call*(call_614901: Call_DeleteProvisioningTemplate_614889;
          templateName: string): Recallable =
  ## deleteProvisioningTemplate
  ## Deletes a fleet provisioning template.
  ##   templateName: string (required)
  ##               : The name of the fleet provision template to delete.
  var path_614902 = newJObject()
  add(path_614902, "templateName", newJString(templateName))
  result = call_614901.call(path_614902, nil, nil, nil, nil)

var deleteProvisioningTemplate* = Call_DeleteProvisioningTemplate_614889(
    name: "deleteProvisioningTemplate", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/provisioning-templates/{templateName}",
    validator: validate_DeleteProvisioningTemplate_614890, base: "/",
    url: url_DeleteProvisioningTemplate_614891,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeProvisioningTemplateVersion_614919 = ref object of OpenApiRestCall_612658
proc url_DescribeProvisioningTemplateVersion_614921(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  assert "versionId" in path, "`versionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/versions/"),
               (kind: VariableSegment, value: "versionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeProvisioningTemplateVersion_614920(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about a fleet provisioning template version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The template name.
  ##   versionId: JInt (required)
  ##            : The fleet provisioning template version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_614922 = path.getOrDefault("templateName")
  valid_614922 = validateParameter(valid_614922, JString, required = true,
                                 default = nil)
  if valid_614922 != nil:
    section.add "templateName", valid_614922
  var valid_614923 = path.getOrDefault("versionId")
  valid_614923 = validateParameter(valid_614923, JInt, required = true, default = nil)
  if valid_614923 != nil:
    section.add "versionId", valid_614923
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614924 = header.getOrDefault("X-Amz-Signature")
  valid_614924 = validateParameter(valid_614924, JString, required = false,
                                 default = nil)
  if valid_614924 != nil:
    section.add "X-Amz-Signature", valid_614924
  var valid_614925 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614925 = validateParameter(valid_614925, JString, required = false,
                                 default = nil)
  if valid_614925 != nil:
    section.add "X-Amz-Content-Sha256", valid_614925
  var valid_614926 = header.getOrDefault("X-Amz-Date")
  valid_614926 = validateParameter(valid_614926, JString, required = false,
                                 default = nil)
  if valid_614926 != nil:
    section.add "X-Amz-Date", valid_614926
  var valid_614927 = header.getOrDefault("X-Amz-Credential")
  valid_614927 = validateParameter(valid_614927, JString, required = false,
                                 default = nil)
  if valid_614927 != nil:
    section.add "X-Amz-Credential", valid_614927
  var valid_614928 = header.getOrDefault("X-Amz-Security-Token")
  valid_614928 = validateParameter(valid_614928, JString, required = false,
                                 default = nil)
  if valid_614928 != nil:
    section.add "X-Amz-Security-Token", valid_614928
  var valid_614929 = header.getOrDefault("X-Amz-Algorithm")
  valid_614929 = validateParameter(valid_614929, JString, required = false,
                                 default = nil)
  if valid_614929 != nil:
    section.add "X-Amz-Algorithm", valid_614929
  var valid_614930 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614930 = validateParameter(valid_614930, JString, required = false,
                                 default = nil)
  if valid_614930 != nil:
    section.add "X-Amz-SignedHeaders", valid_614930
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614931: Call_DescribeProvisioningTemplateVersion_614919;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns information about a fleet provisioning template version.
  ## 
  let valid = call_614931.validator(path, query, header, formData, body)
  let scheme = call_614931.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614931.url(scheme.get, call_614931.host, call_614931.base,
                         call_614931.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614931, url, valid)

proc call*(call_614932: Call_DescribeProvisioningTemplateVersion_614919;
          templateName: string; versionId: int): Recallable =
  ## describeProvisioningTemplateVersion
  ## Returns information about a fleet provisioning template version.
  ##   templateName: string (required)
  ##               : The template name.
  ##   versionId: int (required)
  ##            : The fleet provisioning template version ID.
  var path_614933 = newJObject()
  add(path_614933, "templateName", newJString(templateName))
  add(path_614933, "versionId", newJInt(versionId))
  result = call_614932.call(path_614933, nil, nil, nil, nil)

var describeProvisioningTemplateVersion* = Call_DescribeProvisioningTemplateVersion_614919(
    name: "describeProvisioningTemplateVersion", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/versions/{versionId}",
    validator: validate_DescribeProvisioningTemplateVersion_614920, base: "/",
    url: url_DescribeProvisioningTemplateVersion_614921,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteProvisioningTemplateVersion_614934 = ref object of OpenApiRestCall_612658
proc url_DeleteProvisioningTemplateVersion_614936(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  assert "versionId" in path, "`versionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/versions/"),
               (kind: VariableSegment, value: "versionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteProvisioningTemplateVersion_614935(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a fleet provisioning template version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template version to delete.
  ##   versionId: JInt (required)
  ##            : The fleet provisioning template version ID to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_614937 = path.getOrDefault("templateName")
  valid_614937 = validateParameter(valid_614937, JString, required = true,
                                 default = nil)
  if valid_614937 != nil:
    section.add "templateName", valid_614937
  var valid_614938 = path.getOrDefault("versionId")
  valid_614938 = validateParameter(valid_614938, JInt, required = true, default = nil)
  if valid_614938 != nil:
    section.add "versionId", valid_614938
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614939 = header.getOrDefault("X-Amz-Signature")
  valid_614939 = validateParameter(valid_614939, JString, required = false,
                                 default = nil)
  if valid_614939 != nil:
    section.add "X-Amz-Signature", valid_614939
  var valid_614940 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614940 = validateParameter(valid_614940, JString, required = false,
                                 default = nil)
  if valid_614940 != nil:
    section.add "X-Amz-Content-Sha256", valid_614940
  var valid_614941 = header.getOrDefault("X-Amz-Date")
  valid_614941 = validateParameter(valid_614941, JString, required = false,
                                 default = nil)
  if valid_614941 != nil:
    section.add "X-Amz-Date", valid_614941
  var valid_614942 = header.getOrDefault("X-Amz-Credential")
  valid_614942 = validateParameter(valid_614942, JString, required = false,
                                 default = nil)
  if valid_614942 != nil:
    section.add "X-Amz-Credential", valid_614942
  var valid_614943 = header.getOrDefault("X-Amz-Security-Token")
  valid_614943 = validateParameter(valid_614943, JString, required = false,
                                 default = nil)
  if valid_614943 != nil:
    section.add "X-Amz-Security-Token", valid_614943
  var valid_614944 = header.getOrDefault("X-Amz-Algorithm")
  valid_614944 = validateParameter(valid_614944, JString, required = false,
                                 default = nil)
  if valid_614944 != nil:
    section.add "X-Amz-Algorithm", valid_614944
  var valid_614945 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614945 = validateParameter(valid_614945, JString, required = false,
                                 default = nil)
  if valid_614945 != nil:
    section.add "X-Amz-SignedHeaders", valid_614945
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614946: Call_DeleteProvisioningTemplateVersion_614934;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes a fleet provisioning template version.
  ## 
  let valid = call_614946.validator(path, query, header, formData, body)
  let scheme = call_614946.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614946.url(scheme.get, call_614946.host, call_614946.base,
                         call_614946.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614946, url, valid)

proc call*(call_614947: Call_DeleteProvisioningTemplateVersion_614934;
          templateName: string; versionId: int): Recallable =
  ## deleteProvisioningTemplateVersion
  ## Deletes a fleet provisioning template version.
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template version to delete.
  ##   versionId: int (required)
  ##            : The fleet provisioning template version ID to delete.
  var path_614948 = newJObject()
  add(path_614948, "templateName", newJString(templateName))
  add(path_614948, "versionId", newJInt(versionId))
  result = call_614947.call(path_614948, nil, nil, nil, nil)

var deleteProvisioningTemplateVersion* = Call_DeleteProvisioningTemplateVersion_614934(
    name: "deleteProvisioningTemplateVersion", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/versions/{versionId}",
    validator: validate_DeleteProvisioningTemplateVersion_614935, base: "/",
    url: url_DeleteProvisioningTemplateVersion_614936,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRegistrationCode_614949 = ref object of OpenApiRestCall_612658
proc url_GetRegistrationCode_614951(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRegistrationCode_614950(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614952 = header.getOrDefault("X-Amz-Signature")
  valid_614952 = validateParameter(valid_614952, JString, required = false,
                                 default = nil)
  if valid_614952 != nil:
    section.add "X-Amz-Signature", valid_614952
  var valid_614953 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614953 = validateParameter(valid_614953, JString, required = false,
                                 default = nil)
  if valid_614953 != nil:
    section.add "X-Amz-Content-Sha256", valid_614953
  var valid_614954 = header.getOrDefault("X-Amz-Date")
  valid_614954 = validateParameter(valid_614954, JString, required = false,
                                 default = nil)
  if valid_614954 != nil:
    section.add "X-Amz-Date", valid_614954
  var valid_614955 = header.getOrDefault("X-Amz-Credential")
  valid_614955 = validateParameter(valid_614955, JString, required = false,
                                 default = nil)
  if valid_614955 != nil:
    section.add "X-Amz-Credential", valid_614955
  var valid_614956 = header.getOrDefault("X-Amz-Security-Token")
  valid_614956 = validateParameter(valid_614956, JString, required = false,
                                 default = nil)
  if valid_614956 != nil:
    section.add "X-Amz-Security-Token", valid_614956
  var valid_614957 = header.getOrDefault("X-Amz-Algorithm")
  valid_614957 = validateParameter(valid_614957, JString, required = false,
                                 default = nil)
  if valid_614957 != nil:
    section.add "X-Amz-Algorithm", valid_614957
  var valid_614958 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614958 = validateParameter(valid_614958, JString, required = false,
                                 default = nil)
  if valid_614958 != nil:
    section.add "X-Amz-SignedHeaders", valid_614958
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614959: Call_GetRegistrationCode_614949; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  ## 
  let valid = call_614959.validator(path, query, header, formData, body)
  let scheme = call_614959.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614959.url(scheme.get, call_614959.host, call_614959.base,
                         call_614959.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614959, url, valid)

proc call*(call_614960: Call_GetRegistrationCode_614949): Recallable =
  ## getRegistrationCode
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  result = call_614960.call(nil, nil, nil, nil, nil)

var getRegistrationCode* = Call_GetRegistrationCode_614949(
    name: "getRegistrationCode", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/registrationcode",
    validator: validate_GetRegistrationCode_614950, base: "/",
    url: url_GetRegistrationCode_614951, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRegistrationCode_614961 = ref object of OpenApiRestCall_612658
proc url_DeleteRegistrationCode_614963(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteRegistrationCode_614962(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a CA certificate registration code.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614964 = header.getOrDefault("X-Amz-Signature")
  valid_614964 = validateParameter(valid_614964, JString, required = false,
                                 default = nil)
  if valid_614964 != nil:
    section.add "X-Amz-Signature", valid_614964
  var valid_614965 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614965 = validateParameter(valid_614965, JString, required = false,
                                 default = nil)
  if valid_614965 != nil:
    section.add "X-Amz-Content-Sha256", valid_614965
  var valid_614966 = header.getOrDefault("X-Amz-Date")
  valid_614966 = validateParameter(valid_614966, JString, required = false,
                                 default = nil)
  if valid_614966 != nil:
    section.add "X-Amz-Date", valid_614966
  var valid_614967 = header.getOrDefault("X-Amz-Credential")
  valid_614967 = validateParameter(valid_614967, JString, required = false,
                                 default = nil)
  if valid_614967 != nil:
    section.add "X-Amz-Credential", valid_614967
  var valid_614968 = header.getOrDefault("X-Amz-Security-Token")
  valid_614968 = validateParameter(valid_614968, JString, required = false,
                                 default = nil)
  if valid_614968 != nil:
    section.add "X-Amz-Security-Token", valid_614968
  var valid_614969 = header.getOrDefault("X-Amz-Algorithm")
  valid_614969 = validateParameter(valid_614969, JString, required = false,
                                 default = nil)
  if valid_614969 != nil:
    section.add "X-Amz-Algorithm", valid_614969
  var valid_614970 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614970 = validateParameter(valid_614970, JString, required = false,
                                 default = nil)
  if valid_614970 != nil:
    section.add "X-Amz-SignedHeaders", valid_614970
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614971: Call_DeleteRegistrationCode_614961; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a CA certificate registration code.
  ## 
  let valid = call_614971.validator(path, query, header, formData, body)
  let scheme = call_614971.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614971.url(scheme.get, call_614971.host, call_614971.base,
                         call_614971.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614971, url, valid)

proc call*(call_614972: Call_DeleteRegistrationCode_614961): Recallable =
  ## deleteRegistrationCode
  ## Deletes a CA certificate registration code.
  result = call_614972.call(nil, nil, nil, nil, nil)

var deleteRegistrationCode* = Call_DeleteRegistrationCode_614961(
    name: "deleteRegistrationCode", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/registrationcode",
    validator: validate_DeleteRegistrationCode_614962, base: "/",
    url: url_DeleteRegistrationCode_614963, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetTopicRuleDestination_614973 = ref object of OpenApiRestCall_612658
proc url_GetTopicRuleDestination_614975(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "arn" in path, "`arn` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/destinations/"),
               (kind: VariableSegment, value: "arn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTopicRuleDestination_614974(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a topic rule destination.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   arn: JString (required)
  ##      : The ARN of the topic rule destination.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `arn` field"
  var valid_614976 = path.getOrDefault("arn")
  valid_614976 = validateParameter(valid_614976, JString, required = true,
                                 default = nil)
  if valid_614976 != nil:
    section.add "arn", valid_614976
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614977 = header.getOrDefault("X-Amz-Signature")
  valid_614977 = validateParameter(valid_614977, JString, required = false,
                                 default = nil)
  if valid_614977 != nil:
    section.add "X-Amz-Signature", valid_614977
  var valid_614978 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614978 = validateParameter(valid_614978, JString, required = false,
                                 default = nil)
  if valid_614978 != nil:
    section.add "X-Amz-Content-Sha256", valid_614978
  var valid_614979 = header.getOrDefault("X-Amz-Date")
  valid_614979 = validateParameter(valid_614979, JString, required = false,
                                 default = nil)
  if valid_614979 != nil:
    section.add "X-Amz-Date", valid_614979
  var valid_614980 = header.getOrDefault("X-Amz-Credential")
  valid_614980 = validateParameter(valid_614980, JString, required = false,
                                 default = nil)
  if valid_614980 != nil:
    section.add "X-Amz-Credential", valid_614980
  var valid_614981 = header.getOrDefault("X-Amz-Security-Token")
  valid_614981 = validateParameter(valid_614981, JString, required = false,
                                 default = nil)
  if valid_614981 != nil:
    section.add "X-Amz-Security-Token", valid_614981
  var valid_614982 = header.getOrDefault("X-Amz-Algorithm")
  valid_614982 = validateParameter(valid_614982, JString, required = false,
                                 default = nil)
  if valid_614982 != nil:
    section.add "X-Amz-Algorithm", valid_614982
  var valid_614983 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614983 = validateParameter(valid_614983, JString, required = false,
                                 default = nil)
  if valid_614983 != nil:
    section.add "X-Amz-SignedHeaders", valid_614983
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614984: Call_GetTopicRuleDestination_614973; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a topic rule destination.
  ## 
  let valid = call_614984.validator(path, query, header, formData, body)
  let scheme = call_614984.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614984.url(scheme.get, call_614984.host, call_614984.base,
                         call_614984.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614984, url, valid)

proc call*(call_614985: Call_GetTopicRuleDestination_614973; arn: string): Recallable =
  ## getTopicRuleDestination
  ## Gets information about a topic rule destination.
  ##   arn: string (required)
  ##      : The ARN of the topic rule destination.
  var path_614986 = newJObject()
  add(path_614986, "arn", newJString(arn))
  result = call_614985.call(path_614986, nil, nil, nil, nil)

var getTopicRuleDestination* = Call_GetTopicRuleDestination_614973(
    name: "getTopicRuleDestination", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/destinations/{arn}",
    validator: validate_GetTopicRuleDestination_614974, base: "/",
    url: url_GetTopicRuleDestination_614975, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteTopicRuleDestination_614987 = ref object of OpenApiRestCall_612658
proc url_DeleteTopicRuleDestination_614989(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "arn" in path, "`arn` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/destinations/"),
               (kind: VariableSegment, value: "arn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTopicRuleDestination_614988(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a topic rule destination.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   arn: JString (required)
  ##      : The ARN of the topic rule destination to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `arn` field"
  var valid_614990 = path.getOrDefault("arn")
  valid_614990 = validateParameter(valid_614990, JString, required = true,
                                 default = nil)
  if valid_614990 != nil:
    section.add "arn", valid_614990
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614991 = header.getOrDefault("X-Amz-Signature")
  valid_614991 = validateParameter(valid_614991, JString, required = false,
                                 default = nil)
  if valid_614991 != nil:
    section.add "X-Amz-Signature", valid_614991
  var valid_614992 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614992 = validateParameter(valid_614992, JString, required = false,
                                 default = nil)
  if valid_614992 != nil:
    section.add "X-Amz-Content-Sha256", valid_614992
  var valid_614993 = header.getOrDefault("X-Amz-Date")
  valid_614993 = validateParameter(valid_614993, JString, required = false,
                                 default = nil)
  if valid_614993 != nil:
    section.add "X-Amz-Date", valid_614993
  var valid_614994 = header.getOrDefault("X-Amz-Credential")
  valid_614994 = validateParameter(valid_614994, JString, required = false,
                                 default = nil)
  if valid_614994 != nil:
    section.add "X-Amz-Credential", valid_614994
  var valid_614995 = header.getOrDefault("X-Amz-Security-Token")
  valid_614995 = validateParameter(valid_614995, JString, required = false,
                                 default = nil)
  if valid_614995 != nil:
    section.add "X-Amz-Security-Token", valid_614995
  var valid_614996 = header.getOrDefault("X-Amz-Algorithm")
  valid_614996 = validateParameter(valid_614996, JString, required = false,
                                 default = nil)
  if valid_614996 != nil:
    section.add "X-Amz-Algorithm", valid_614996
  var valid_614997 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614997 = validateParameter(valid_614997, JString, required = false,
                                 default = nil)
  if valid_614997 != nil:
    section.add "X-Amz-SignedHeaders", valid_614997
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614998: Call_DeleteTopicRuleDestination_614987; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a topic rule destination.
  ## 
  let valid = call_614998.validator(path, query, header, formData, body)
  let scheme = call_614998.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614998.url(scheme.get, call_614998.host, call_614998.base,
                         call_614998.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614998, url, valid)

proc call*(call_614999: Call_DeleteTopicRuleDestination_614987; arn: string): Recallable =
  ## deleteTopicRuleDestination
  ## Deletes a topic rule destination.
  ##   arn: string (required)
  ##      : The ARN of the topic rule destination to delete.
  var path_615000 = newJObject()
  add(path_615000, "arn", newJString(arn))
  result = call_614999.call(path_615000, nil, nil, nil, nil)

var deleteTopicRuleDestination* = Call_DeleteTopicRuleDestination_614987(
    name: "deleteTopicRuleDestination", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/destinations/{arn}",
    validator: validate_DeleteTopicRuleDestination_614988, base: "/",
    url: url_DeleteTopicRuleDestination_614989,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteV2LoggingLevel_615001 = ref object of OpenApiRestCall_612658
proc url_DeleteV2LoggingLevel_615003(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteV2LoggingLevel_615002(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a logging level.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   targetName: JString (required)
  ##             : The name of the resource for which you are configuring logging.
  ##   targetType: JString (required)
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `targetName` field"
  var valid_615004 = query.getOrDefault("targetName")
  valid_615004 = validateParameter(valid_615004, JString, required = true,
                                 default = nil)
  if valid_615004 != nil:
    section.add "targetName", valid_615004
  var valid_615005 = query.getOrDefault("targetType")
  valid_615005 = validateParameter(valid_615005, JString, required = true,
                                 default = newJString("DEFAULT"))
  if valid_615005 != nil:
    section.add "targetType", valid_615005
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615006 = header.getOrDefault("X-Amz-Signature")
  valid_615006 = validateParameter(valid_615006, JString, required = false,
                                 default = nil)
  if valid_615006 != nil:
    section.add "X-Amz-Signature", valid_615006
  var valid_615007 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615007 = validateParameter(valid_615007, JString, required = false,
                                 default = nil)
  if valid_615007 != nil:
    section.add "X-Amz-Content-Sha256", valid_615007
  var valid_615008 = header.getOrDefault("X-Amz-Date")
  valid_615008 = validateParameter(valid_615008, JString, required = false,
                                 default = nil)
  if valid_615008 != nil:
    section.add "X-Amz-Date", valid_615008
  var valid_615009 = header.getOrDefault("X-Amz-Credential")
  valid_615009 = validateParameter(valid_615009, JString, required = false,
                                 default = nil)
  if valid_615009 != nil:
    section.add "X-Amz-Credential", valid_615009
  var valid_615010 = header.getOrDefault("X-Amz-Security-Token")
  valid_615010 = validateParameter(valid_615010, JString, required = false,
                                 default = nil)
  if valid_615010 != nil:
    section.add "X-Amz-Security-Token", valid_615010
  var valid_615011 = header.getOrDefault("X-Amz-Algorithm")
  valid_615011 = validateParameter(valid_615011, JString, required = false,
                                 default = nil)
  if valid_615011 != nil:
    section.add "X-Amz-Algorithm", valid_615011
  var valid_615012 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615012 = validateParameter(valid_615012, JString, required = false,
                                 default = nil)
  if valid_615012 != nil:
    section.add "X-Amz-SignedHeaders", valid_615012
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615013: Call_DeleteV2LoggingLevel_615001; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a logging level.
  ## 
  let valid = call_615013.validator(path, query, header, formData, body)
  let scheme = call_615013.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615013.url(scheme.get, call_615013.host, call_615013.base,
                         call_615013.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615013, url, valid)

proc call*(call_615014: Call_DeleteV2LoggingLevel_615001; targetName: string;
          targetType: string = "DEFAULT"): Recallable =
  ## deleteV2LoggingLevel
  ## Deletes a logging level.
  ##   targetName: string (required)
  ##             : The name of the resource for which you are configuring logging.
  ##   targetType: string (required)
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  var query_615015 = newJObject()
  add(query_615015, "targetName", newJString(targetName))
  add(query_615015, "targetType", newJString(targetType))
  result = call_615014.call(nil, query_615015, nil, nil, nil)

var deleteV2LoggingLevel* = Call_DeleteV2LoggingLevel_615001(
    name: "deleteV2LoggingLevel", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/v2LoggingLevel#targetType&targetName",
    validator: validate_DeleteV2LoggingLevel_615002, base: "/",
    url: url_DeleteV2LoggingLevel_615003, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeprecateThingType_615016 = ref object of OpenApiRestCall_612658
proc url_DeprecateThingType_615018(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName"),
               (kind: ConstantSegment, value: "/deprecate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeprecateThingType_615017(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type to deprecate.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_615019 = path.getOrDefault("thingTypeName")
  valid_615019 = validateParameter(valid_615019, JString, required = true,
                                 default = nil)
  if valid_615019 != nil:
    section.add "thingTypeName", valid_615019
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615020 = header.getOrDefault("X-Amz-Signature")
  valid_615020 = validateParameter(valid_615020, JString, required = false,
                                 default = nil)
  if valid_615020 != nil:
    section.add "X-Amz-Signature", valid_615020
  var valid_615021 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615021 = validateParameter(valid_615021, JString, required = false,
                                 default = nil)
  if valid_615021 != nil:
    section.add "X-Amz-Content-Sha256", valid_615021
  var valid_615022 = header.getOrDefault("X-Amz-Date")
  valid_615022 = validateParameter(valid_615022, JString, required = false,
                                 default = nil)
  if valid_615022 != nil:
    section.add "X-Amz-Date", valid_615022
  var valid_615023 = header.getOrDefault("X-Amz-Credential")
  valid_615023 = validateParameter(valid_615023, JString, required = false,
                                 default = nil)
  if valid_615023 != nil:
    section.add "X-Amz-Credential", valid_615023
  var valid_615024 = header.getOrDefault("X-Amz-Security-Token")
  valid_615024 = validateParameter(valid_615024, JString, required = false,
                                 default = nil)
  if valid_615024 != nil:
    section.add "X-Amz-Security-Token", valid_615024
  var valid_615025 = header.getOrDefault("X-Amz-Algorithm")
  valid_615025 = validateParameter(valid_615025, JString, required = false,
                                 default = nil)
  if valid_615025 != nil:
    section.add "X-Amz-Algorithm", valid_615025
  var valid_615026 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615026 = validateParameter(valid_615026, JString, required = false,
                                 default = nil)
  if valid_615026 != nil:
    section.add "X-Amz-SignedHeaders", valid_615026
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_615028: Call_DeprecateThingType_615016; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ## 
  let valid = call_615028.validator(path, query, header, formData, body)
  let scheme = call_615028.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615028.url(scheme.get, call_615028.host, call_615028.base,
                         call_615028.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615028, url, valid)

proc call*(call_615029: Call_DeprecateThingType_615016; thingTypeName: string;
          body: JsonNode): Recallable =
  ## deprecateThingType
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type to deprecate.
  ##   body: JObject (required)
  var path_615030 = newJObject()
  var body_615031 = newJObject()
  add(path_615030, "thingTypeName", newJString(thingTypeName))
  if body != nil:
    body_615031 = body
  result = call_615029.call(path_615030, nil, nil, nil, body_615031)

var deprecateThingType* = Call_DeprecateThingType_615016(
    name: "deprecateThingType", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/thing-types/{thingTypeName}/deprecate",
    validator: validate_DeprecateThingType_615017, base: "/",
    url: url_DeprecateThingType_615018, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditFinding_615032 = ref object of OpenApiRestCall_612658
proc url_DescribeAuditFinding_615034(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "findingId" in path, "`findingId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/findings/"),
               (kind: VariableSegment, value: "findingId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuditFinding_615033(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   findingId: JString (required)
  ##            : A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `findingId` field"
  var valid_615035 = path.getOrDefault("findingId")
  valid_615035 = validateParameter(valid_615035, JString, required = true,
                                 default = nil)
  if valid_615035 != nil:
    section.add "findingId", valid_615035
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615036 = header.getOrDefault("X-Amz-Signature")
  valid_615036 = validateParameter(valid_615036, JString, required = false,
                                 default = nil)
  if valid_615036 != nil:
    section.add "X-Amz-Signature", valid_615036
  var valid_615037 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615037 = validateParameter(valid_615037, JString, required = false,
                                 default = nil)
  if valid_615037 != nil:
    section.add "X-Amz-Content-Sha256", valid_615037
  var valid_615038 = header.getOrDefault("X-Amz-Date")
  valid_615038 = validateParameter(valid_615038, JString, required = false,
                                 default = nil)
  if valid_615038 != nil:
    section.add "X-Amz-Date", valid_615038
  var valid_615039 = header.getOrDefault("X-Amz-Credential")
  valid_615039 = validateParameter(valid_615039, JString, required = false,
                                 default = nil)
  if valid_615039 != nil:
    section.add "X-Amz-Credential", valid_615039
  var valid_615040 = header.getOrDefault("X-Amz-Security-Token")
  valid_615040 = validateParameter(valid_615040, JString, required = false,
                                 default = nil)
  if valid_615040 != nil:
    section.add "X-Amz-Security-Token", valid_615040
  var valid_615041 = header.getOrDefault("X-Amz-Algorithm")
  valid_615041 = validateParameter(valid_615041, JString, required = false,
                                 default = nil)
  if valid_615041 != nil:
    section.add "X-Amz-Algorithm", valid_615041
  var valid_615042 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615042 = validateParameter(valid_615042, JString, required = false,
                                 default = nil)
  if valid_615042 != nil:
    section.add "X-Amz-SignedHeaders", valid_615042
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615043: Call_DescribeAuditFinding_615032; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ## 
  let valid = call_615043.validator(path, query, header, formData, body)
  let scheme = call_615043.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615043.url(scheme.get, call_615043.host, call_615043.base,
                         call_615043.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615043, url, valid)

proc call*(call_615044: Call_DescribeAuditFinding_615032; findingId: string): Recallable =
  ## describeAuditFinding
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ##   findingId: string (required)
  ##            : A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
  var path_615045 = newJObject()
  add(path_615045, "findingId", newJString(findingId))
  result = call_615044.call(path_615045, nil, nil, nil, nil)

var describeAuditFinding* = Call_DescribeAuditFinding_615032(
    name: "describeAuditFinding", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/findings/{findingId}",
    validator: validate_DescribeAuditFinding_615033, base: "/",
    url: url_DescribeAuditFinding_615034, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartAuditMitigationActionsTask_615060 = ref object of OpenApiRestCall_612658
proc url_StartAuditMitigationActionsTask_615062(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_StartAuditMitigationActionsTask_615061(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_615063 = path.getOrDefault("taskId")
  valid_615063 = validateParameter(valid_615063, JString, required = true,
                                 default = nil)
  if valid_615063 != nil:
    section.add "taskId", valid_615063
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615064 = header.getOrDefault("X-Amz-Signature")
  valid_615064 = validateParameter(valid_615064, JString, required = false,
                                 default = nil)
  if valid_615064 != nil:
    section.add "X-Amz-Signature", valid_615064
  var valid_615065 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615065 = validateParameter(valid_615065, JString, required = false,
                                 default = nil)
  if valid_615065 != nil:
    section.add "X-Amz-Content-Sha256", valid_615065
  var valid_615066 = header.getOrDefault("X-Amz-Date")
  valid_615066 = validateParameter(valid_615066, JString, required = false,
                                 default = nil)
  if valid_615066 != nil:
    section.add "X-Amz-Date", valid_615066
  var valid_615067 = header.getOrDefault("X-Amz-Credential")
  valid_615067 = validateParameter(valid_615067, JString, required = false,
                                 default = nil)
  if valid_615067 != nil:
    section.add "X-Amz-Credential", valid_615067
  var valid_615068 = header.getOrDefault("X-Amz-Security-Token")
  valid_615068 = validateParameter(valid_615068, JString, required = false,
                                 default = nil)
  if valid_615068 != nil:
    section.add "X-Amz-Security-Token", valid_615068
  var valid_615069 = header.getOrDefault("X-Amz-Algorithm")
  valid_615069 = validateParameter(valid_615069, JString, required = false,
                                 default = nil)
  if valid_615069 != nil:
    section.add "X-Amz-Algorithm", valid_615069
  var valid_615070 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615070 = validateParameter(valid_615070, JString, required = false,
                                 default = nil)
  if valid_615070 != nil:
    section.add "X-Amz-SignedHeaders", valid_615070
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_615072: Call_StartAuditMitigationActionsTask_615060;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ## 
  let valid = call_615072.validator(path, query, header, formData, body)
  let scheme = call_615072.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615072.url(scheme.get, call_615072.host, call_615072.base,
                         call_615072.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615072, url, valid)

proc call*(call_615073: Call_StartAuditMitigationActionsTask_615060;
          body: JsonNode; taskId: string): Recallable =
  ## startAuditMitigationActionsTask
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ##   body: JObject (required)
  ##   taskId: string (required)
  ##         : A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
  var path_615074 = newJObject()
  var body_615075 = newJObject()
  if body != nil:
    body_615075 = body
  add(path_615074, "taskId", newJString(taskId))
  result = call_615073.call(path_615074, nil, nil, nil, body_615075)

var startAuditMitigationActionsTask* = Call_StartAuditMitigationActionsTask_615060(
    name: "startAuditMitigationActionsTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/audit/mitigationactions/tasks/{taskId}",
    validator: validate_StartAuditMitigationActionsTask_615061, base: "/",
    url: url_StartAuditMitigationActionsTask_615062,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditMitigationActionsTask_615046 = ref object of OpenApiRestCall_612658
proc url_DescribeAuditMitigationActionsTask_615048(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuditMitigationActionsTask_615047(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The unique identifier for the audit mitigation task.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_615049 = path.getOrDefault("taskId")
  valid_615049 = validateParameter(valid_615049, JString, required = true,
                                 default = nil)
  if valid_615049 != nil:
    section.add "taskId", valid_615049
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615050 = header.getOrDefault("X-Amz-Signature")
  valid_615050 = validateParameter(valid_615050, JString, required = false,
                                 default = nil)
  if valid_615050 != nil:
    section.add "X-Amz-Signature", valid_615050
  var valid_615051 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615051 = validateParameter(valid_615051, JString, required = false,
                                 default = nil)
  if valid_615051 != nil:
    section.add "X-Amz-Content-Sha256", valid_615051
  var valid_615052 = header.getOrDefault("X-Amz-Date")
  valid_615052 = validateParameter(valid_615052, JString, required = false,
                                 default = nil)
  if valid_615052 != nil:
    section.add "X-Amz-Date", valid_615052
  var valid_615053 = header.getOrDefault("X-Amz-Credential")
  valid_615053 = validateParameter(valid_615053, JString, required = false,
                                 default = nil)
  if valid_615053 != nil:
    section.add "X-Amz-Credential", valid_615053
  var valid_615054 = header.getOrDefault("X-Amz-Security-Token")
  valid_615054 = validateParameter(valid_615054, JString, required = false,
                                 default = nil)
  if valid_615054 != nil:
    section.add "X-Amz-Security-Token", valid_615054
  var valid_615055 = header.getOrDefault("X-Amz-Algorithm")
  valid_615055 = validateParameter(valid_615055, JString, required = false,
                                 default = nil)
  if valid_615055 != nil:
    section.add "X-Amz-Algorithm", valid_615055
  var valid_615056 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615056 = validateParameter(valid_615056, JString, required = false,
                                 default = nil)
  if valid_615056 != nil:
    section.add "X-Amz-SignedHeaders", valid_615056
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615057: Call_DescribeAuditMitigationActionsTask_615046;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ## 
  let valid = call_615057.validator(path, query, header, formData, body)
  let scheme = call_615057.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615057.url(scheme.get, call_615057.host, call_615057.base,
                         call_615057.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615057, url, valid)

proc call*(call_615058: Call_DescribeAuditMitigationActionsTask_615046;
          taskId: string): Recallable =
  ## describeAuditMitigationActionsTask
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ##   taskId: string (required)
  ##         : The unique identifier for the audit mitigation task.
  var path_615059 = newJObject()
  add(path_615059, "taskId", newJString(taskId))
  result = call_615058.call(path_615059, nil, nil, nil, nil)

var describeAuditMitigationActionsTask* = Call_DescribeAuditMitigationActionsTask_615046(
    name: "describeAuditMitigationActionsTask", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/mitigationactions/tasks/{taskId}",
    validator: validate_DescribeAuditMitigationActionsTask_615047, base: "/",
    url: url_DescribeAuditMitigationActionsTask_615048,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditTask_615076 = ref object of OpenApiRestCall_612658
proc url_DescribeAuditTask_615078(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuditTask_615077(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Gets information about a Device Defender audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The ID of the audit whose information you want to get.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_615079 = path.getOrDefault("taskId")
  valid_615079 = validateParameter(valid_615079, JString, required = true,
                                 default = nil)
  if valid_615079 != nil:
    section.add "taskId", valid_615079
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615080 = header.getOrDefault("X-Amz-Signature")
  valid_615080 = validateParameter(valid_615080, JString, required = false,
                                 default = nil)
  if valid_615080 != nil:
    section.add "X-Amz-Signature", valid_615080
  var valid_615081 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615081 = validateParameter(valid_615081, JString, required = false,
                                 default = nil)
  if valid_615081 != nil:
    section.add "X-Amz-Content-Sha256", valid_615081
  var valid_615082 = header.getOrDefault("X-Amz-Date")
  valid_615082 = validateParameter(valid_615082, JString, required = false,
                                 default = nil)
  if valid_615082 != nil:
    section.add "X-Amz-Date", valid_615082
  var valid_615083 = header.getOrDefault("X-Amz-Credential")
  valid_615083 = validateParameter(valid_615083, JString, required = false,
                                 default = nil)
  if valid_615083 != nil:
    section.add "X-Amz-Credential", valid_615083
  var valid_615084 = header.getOrDefault("X-Amz-Security-Token")
  valid_615084 = validateParameter(valid_615084, JString, required = false,
                                 default = nil)
  if valid_615084 != nil:
    section.add "X-Amz-Security-Token", valid_615084
  var valid_615085 = header.getOrDefault("X-Amz-Algorithm")
  valid_615085 = validateParameter(valid_615085, JString, required = false,
                                 default = nil)
  if valid_615085 != nil:
    section.add "X-Amz-Algorithm", valid_615085
  var valid_615086 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615086 = validateParameter(valid_615086, JString, required = false,
                                 default = nil)
  if valid_615086 != nil:
    section.add "X-Amz-SignedHeaders", valid_615086
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615087: Call_DescribeAuditTask_615076; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a Device Defender audit.
  ## 
  let valid = call_615087.validator(path, query, header, formData, body)
  let scheme = call_615087.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615087.url(scheme.get, call_615087.host, call_615087.base,
                         call_615087.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615087, url, valid)

proc call*(call_615088: Call_DescribeAuditTask_615076; taskId: string): Recallable =
  ## describeAuditTask
  ## Gets information about a Device Defender audit.
  ##   taskId: string (required)
  ##         : The ID of the audit whose information you want to get.
  var path_615089 = newJObject()
  add(path_615089, "taskId", newJString(taskId))
  result = call_615088.call(path_615089, nil, nil, nil, nil)

var describeAuditTask* = Call_DescribeAuditTask_615076(name: "describeAuditTask",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/audit/tasks/{taskId}", validator: validate_DescribeAuditTask_615077,
    base: "/", url: url_DescribeAuditTask_615078,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeEndpoint_615090 = ref object of OpenApiRestCall_612658
proc url_DescribeEndpoint_615092(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeEndpoint_615091(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Returns a unique endpoint specific to the AWS account making the call.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endpointType: JString
  ##               : <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
  section = newJObject()
  var valid_615093 = query.getOrDefault("endpointType")
  valid_615093 = validateParameter(valid_615093, JString, required = false,
                                 default = nil)
  if valid_615093 != nil:
    section.add "endpointType", valid_615093
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615094 = header.getOrDefault("X-Amz-Signature")
  valid_615094 = validateParameter(valid_615094, JString, required = false,
                                 default = nil)
  if valid_615094 != nil:
    section.add "X-Amz-Signature", valid_615094
  var valid_615095 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615095 = validateParameter(valid_615095, JString, required = false,
                                 default = nil)
  if valid_615095 != nil:
    section.add "X-Amz-Content-Sha256", valid_615095
  var valid_615096 = header.getOrDefault("X-Amz-Date")
  valid_615096 = validateParameter(valid_615096, JString, required = false,
                                 default = nil)
  if valid_615096 != nil:
    section.add "X-Amz-Date", valid_615096
  var valid_615097 = header.getOrDefault("X-Amz-Credential")
  valid_615097 = validateParameter(valid_615097, JString, required = false,
                                 default = nil)
  if valid_615097 != nil:
    section.add "X-Amz-Credential", valid_615097
  var valid_615098 = header.getOrDefault("X-Amz-Security-Token")
  valid_615098 = validateParameter(valid_615098, JString, required = false,
                                 default = nil)
  if valid_615098 != nil:
    section.add "X-Amz-Security-Token", valid_615098
  var valid_615099 = header.getOrDefault("X-Amz-Algorithm")
  valid_615099 = validateParameter(valid_615099, JString, required = false,
                                 default = nil)
  if valid_615099 != nil:
    section.add "X-Amz-Algorithm", valid_615099
  var valid_615100 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615100 = validateParameter(valid_615100, JString, required = false,
                                 default = nil)
  if valid_615100 != nil:
    section.add "X-Amz-SignedHeaders", valid_615100
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615101: Call_DescribeEndpoint_615090; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a unique endpoint specific to the AWS account making the call.
  ## 
  let valid = call_615101.validator(path, query, header, formData, body)
  let scheme = call_615101.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615101.url(scheme.get, call_615101.host, call_615101.base,
                         call_615101.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615101, url, valid)

proc call*(call_615102: Call_DescribeEndpoint_615090; endpointType: string = ""): Recallable =
  ## describeEndpoint
  ## Returns a unique endpoint specific to the AWS account making the call.
  ##   endpointType: string
  ##               : <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
  var query_615103 = newJObject()
  add(query_615103, "endpointType", newJString(endpointType))
  result = call_615102.call(nil, query_615103, nil, nil, nil)

var describeEndpoint* = Call_DescribeEndpoint_615090(name: "describeEndpoint",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/endpoint",
    validator: validate_DescribeEndpoint_615091, base: "/",
    url: url_DescribeEndpoint_615092, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeEventConfigurations_615104 = ref object of OpenApiRestCall_612658
proc url_DescribeEventConfigurations_615106(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeEventConfigurations_615105(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes event configurations.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615107 = header.getOrDefault("X-Amz-Signature")
  valid_615107 = validateParameter(valid_615107, JString, required = false,
                                 default = nil)
  if valid_615107 != nil:
    section.add "X-Amz-Signature", valid_615107
  var valid_615108 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615108 = validateParameter(valid_615108, JString, required = false,
                                 default = nil)
  if valid_615108 != nil:
    section.add "X-Amz-Content-Sha256", valid_615108
  var valid_615109 = header.getOrDefault("X-Amz-Date")
  valid_615109 = validateParameter(valid_615109, JString, required = false,
                                 default = nil)
  if valid_615109 != nil:
    section.add "X-Amz-Date", valid_615109
  var valid_615110 = header.getOrDefault("X-Amz-Credential")
  valid_615110 = validateParameter(valid_615110, JString, required = false,
                                 default = nil)
  if valid_615110 != nil:
    section.add "X-Amz-Credential", valid_615110
  var valid_615111 = header.getOrDefault("X-Amz-Security-Token")
  valid_615111 = validateParameter(valid_615111, JString, required = false,
                                 default = nil)
  if valid_615111 != nil:
    section.add "X-Amz-Security-Token", valid_615111
  var valid_615112 = header.getOrDefault("X-Amz-Algorithm")
  valid_615112 = validateParameter(valid_615112, JString, required = false,
                                 default = nil)
  if valid_615112 != nil:
    section.add "X-Amz-Algorithm", valid_615112
  var valid_615113 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615113 = validateParameter(valid_615113, JString, required = false,
                                 default = nil)
  if valid_615113 != nil:
    section.add "X-Amz-SignedHeaders", valid_615113
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615114: Call_DescribeEventConfigurations_615104; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes event configurations.
  ## 
  let valid = call_615114.validator(path, query, header, formData, body)
  let scheme = call_615114.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615114.url(scheme.get, call_615114.host, call_615114.base,
                         call_615114.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615114, url, valid)

proc call*(call_615115: Call_DescribeEventConfigurations_615104): Recallable =
  ## describeEventConfigurations
  ## Describes event configurations.
  result = call_615115.call(nil, nil, nil, nil, nil)

var describeEventConfigurations* = Call_DescribeEventConfigurations_615104(
    name: "describeEventConfigurations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/event-configurations",
    validator: validate_DescribeEventConfigurations_615105, base: "/",
    url: url_DescribeEventConfigurations_615106,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateEventConfigurations_615116 = ref object of OpenApiRestCall_612658
proc url_UpdateEventConfigurations_615118(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateEventConfigurations_615117(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the event configurations.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615119 = header.getOrDefault("X-Amz-Signature")
  valid_615119 = validateParameter(valid_615119, JString, required = false,
                                 default = nil)
  if valid_615119 != nil:
    section.add "X-Amz-Signature", valid_615119
  var valid_615120 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615120 = validateParameter(valid_615120, JString, required = false,
                                 default = nil)
  if valid_615120 != nil:
    section.add "X-Amz-Content-Sha256", valid_615120
  var valid_615121 = header.getOrDefault("X-Amz-Date")
  valid_615121 = validateParameter(valid_615121, JString, required = false,
                                 default = nil)
  if valid_615121 != nil:
    section.add "X-Amz-Date", valid_615121
  var valid_615122 = header.getOrDefault("X-Amz-Credential")
  valid_615122 = validateParameter(valid_615122, JString, required = false,
                                 default = nil)
  if valid_615122 != nil:
    section.add "X-Amz-Credential", valid_615122
  var valid_615123 = header.getOrDefault("X-Amz-Security-Token")
  valid_615123 = validateParameter(valid_615123, JString, required = false,
                                 default = nil)
  if valid_615123 != nil:
    section.add "X-Amz-Security-Token", valid_615123
  var valid_615124 = header.getOrDefault("X-Amz-Algorithm")
  valid_615124 = validateParameter(valid_615124, JString, required = false,
                                 default = nil)
  if valid_615124 != nil:
    section.add "X-Amz-Algorithm", valid_615124
  var valid_615125 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615125 = validateParameter(valid_615125, JString, required = false,
                                 default = nil)
  if valid_615125 != nil:
    section.add "X-Amz-SignedHeaders", valid_615125
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_615127: Call_UpdateEventConfigurations_615116; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the event configurations.
  ## 
  let valid = call_615127.validator(path, query, header, formData, body)
  let scheme = call_615127.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615127.url(scheme.get, call_615127.host, call_615127.base,
                         call_615127.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615127, url, valid)

proc call*(call_615128: Call_UpdateEventConfigurations_615116; body: JsonNode): Recallable =
  ## updateEventConfigurations
  ## Updates the event configurations.
  ##   body: JObject (required)
  var body_615129 = newJObject()
  if body != nil:
    body_615129 = body
  result = call_615128.call(nil, nil, nil, nil, body_615129)

var updateEventConfigurations* = Call_UpdateEventConfigurations_615116(
    name: "updateEventConfigurations", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/event-configurations",
    validator: validate_UpdateEventConfigurations_615117, base: "/",
    url: url_UpdateEventConfigurations_615118,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeIndex_615130 = ref object of OpenApiRestCall_612658
proc url_DescribeIndex_615132(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "indexName" in path, "`indexName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/indices/"),
               (kind: VariableSegment, value: "indexName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeIndex_615131(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a search index.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   indexName: JString (required)
  ##            : The index name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `indexName` field"
  var valid_615133 = path.getOrDefault("indexName")
  valid_615133 = validateParameter(valid_615133, JString, required = true,
                                 default = nil)
  if valid_615133 != nil:
    section.add "indexName", valid_615133
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615134 = header.getOrDefault("X-Amz-Signature")
  valid_615134 = validateParameter(valid_615134, JString, required = false,
                                 default = nil)
  if valid_615134 != nil:
    section.add "X-Amz-Signature", valid_615134
  var valid_615135 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615135 = validateParameter(valid_615135, JString, required = false,
                                 default = nil)
  if valid_615135 != nil:
    section.add "X-Amz-Content-Sha256", valid_615135
  var valid_615136 = header.getOrDefault("X-Amz-Date")
  valid_615136 = validateParameter(valid_615136, JString, required = false,
                                 default = nil)
  if valid_615136 != nil:
    section.add "X-Amz-Date", valid_615136
  var valid_615137 = header.getOrDefault("X-Amz-Credential")
  valid_615137 = validateParameter(valid_615137, JString, required = false,
                                 default = nil)
  if valid_615137 != nil:
    section.add "X-Amz-Credential", valid_615137
  var valid_615138 = header.getOrDefault("X-Amz-Security-Token")
  valid_615138 = validateParameter(valid_615138, JString, required = false,
                                 default = nil)
  if valid_615138 != nil:
    section.add "X-Amz-Security-Token", valid_615138
  var valid_615139 = header.getOrDefault("X-Amz-Algorithm")
  valid_615139 = validateParameter(valid_615139, JString, required = false,
                                 default = nil)
  if valid_615139 != nil:
    section.add "X-Amz-Algorithm", valid_615139
  var valid_615140 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615140 = validateParameter(valid_615140, JString, required = false,
                                 default = nil)
  if valid_615140 != nil:
    section.add "X-Amz-SignedHeaders", valid_615140
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615141: Call_DescribeIndex_615130; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a search index.
  ## 
  let valid = call_615141.validator(path, query, header, formData, body)
  let scheme = call_615141.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615141.url(scheme.get, call_615141.host, call_615141.base,
                         call_615141.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615141, url, valid)

proc call*(call_615142: Call_DescribeIndex_615130; indexName: string): Recallable =
  ## describeIndex
  ## Describes a search index.
  ##   indexName: string (required)
  ##            : The index name.
  var path_615143 = newJObject()
  add(path_615143, "indexName", newJString(indexName))
  result = call_615142.call(path_615143, nil, nil, nil, nil)

var describeIndex* = Call_DescribeIndex_615130(name: "describeIndex",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/indices/{indexName}", validator: validate_DescribeIndex_615131,
    base: "/", url: url_DescribeIndex_615132, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeJobExecution_615144 = ref object of OpenApiRestCall_612658
proc url_DescribeJobExecution_615146(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeJobExecution_615145(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a job execution.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   thingName: JString (required)
  ##            : The name of the thing on which the job execution is running.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_615147 = path.getOrDefault("jobId")
  valid_615147 = validateParameter(valid_615147, JString, required = true,
                                 default = nil)
  if valid_615147 != nil:
    section.add "jobId", valid_615147
  var valid_615148 = path.getOrDefault("thingName")
  valid_615148 = validateParameter(valid_615148, JString, required = true,
                                 default = nil)
  if valid_615148 != nil:
    section.add "thingName", valid_615148
  result.add "path", section
  ## parameters in `query` object:
  ##   executionNumber: JInt
  ##                  : A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
  section = newJObject()
  var valid_615149 = query.getOrDefault("executionNumber")
  valid_615149 = validateParameter(valid_615149, JInt, required = false, default = nil)
  if valid_615149 != nil:
    section.add "executionNumber", valid_615149
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615150 = header.getOrDefault("X-Amz-Signature")
  valid_615150 = validateParameter(valid_615150, JString, required = false,
                                 default = nil)
  if valid_615150 != nil:
    section.add "X-Amz-Signature", valid_615150
  var valid_615151 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615151 = validateParameter(valid_615151, JString, required = false,
                                 default = nil)
  if valid_615151 != nil:
    section.add "X-Amz-Content-Sha256", valid_615151
  var valid_615152 = header.getOrDefault("X-Amz-Date")
  valid_615152 = validateParameter(valid_615152, JString, required = false,
                                 default = nil)
  if valid_615152 != nil:
    section.add "X-Amz-Date", valid_615152
  var valid_615153 = header.getOrDefault("X-Amz-Credential")
  valid_615153 = validateParameter(valid_615153, JString, required = false,
                                 default = nil)
  if valid_615153 != nil:
    section.add "X-Amz-Credential", valid_615153
  var valid_615154 = header.getOrDefault("X-Amz-Security-Token")
  valid_615154 = validateParameter(valid_615154, JString, required = false,
                                 default = nil)
  if valid_615154 != nil:
    section.add "X-Amz-Security-Token", valid_615154
  var valid_615155 = header.getOrDefault("X-Amz-Algorithm")
  valid_615155 = validateParameter(valid_615155, JString, required = false,
                                 default = nil)
  if valid_615155 != nil:
    section.add "X-Amz-Algorithm", valid_615155
  var valid_615156 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615156 = validateParameter(valid_615156, JString, required = false,
                                 default = nil)
  if valid_615156 != nil:
    section.add "X-Amz-SignedHeaders", valid_615156
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615157: Call_DescribeJobExecution_615144; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a job execution.
  ## 
  let valid = call_615157.validator(path, query, header, formData, body)
  let scheme = call_615157.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615157.url(scheme.get, call_615157.host, call_615157.base,
                         call_615157.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615157, url, valid)

proc call*(call_615158: Call_DescribeJobExecution_615144; jobId: string;
          thingName: string; executionNumber: int = 0): Recallable =
  ## describeJobExecution
  ## Describes a job execution.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   executionNumber: int
  ##                  : A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
  ##   thingName: string (required)
  ##            : The name of the thing on which the job execution is running.
  var path_615159 = newJObject()
  var query_615160 = newJObject()
  add(path_615159, "jobId", newJString(jobId))
  add(query_615160, "executionNumber", newJInt(executionNumber))
  add(path_615159, "thingName", newJString(thingName))
  result = call_615158.call(path_615159, query_615160, nil, nil, nil)

var describeJobExecution* = Call_DescribeJobExecution_615144(
    name: "describeJobExecution", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs/{jobId}",
    validator: validate_DescribeJobExecution_615145, base: "/",
    url: url_DescribeJobExecution_615146, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingRegistrationTask_615161 = ref object of OpenApiRestCall_612658
proc url_DescribeThingRegistrationTask_615163(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThingRegistrationTask_615162(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The task ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_615164 = path.getOrDefault("taskId")
  valid_615164 = validateParameter(valid_615164, JString, required = true,
                                 default = nil)
  if valid_615164 != nil:
    section.add "taskId", valid_615164
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615165 = header.getOrDefault("X-Amz-Signature")
  valid_615165 = validateParameter(valid_615165, JString, required = false,
                                 default = nil)
  if valid_615165 != nil:
    section.add "X-Amz-Signature", valid_615165
  var valid_615166 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615166 = validateParameter(valid_615166, JString, required = false,
                                 default = nil)
  if valid_615166 != nil:
    section.add "X-Amz-Content-Sha256", valid_615166
  var valid_615167 = header.getOrDefault("X-Amz-Date")
  valid_615167 = validateParameter(valid_615167, JString, required = false,
                                 default = nil)
  if valid_615167 != nil:
    section.add "X-Amz-Date", valid_615167
  var valid_615168 = header.getOrDefault("X-Amz-Credential")
  valid_615168 = validateParameter(valid_615168, JString, required = false,
                                 default = nil)
  if valid_615168 != nil:
    section.add "X-Amz-Credential", valid_615168
  var valid_615169 = header.getOrDefault("X-Amz-Security-Token")
  valid_615169 = validateParameter(valid_615169, JString, required = false,
                                 default = nil)
  if valid_615169 != nil:
    section.add "X-Amz-Security-Token", valid_615169
  var valid_615170 = header.getOrDefault("X-Amz-Algorithm")
  valid_615170 = validateParameter(valid_615170, JString, required = false,
                                 default = nil)
  if valid_615170 != nil:
    section.add "X-Amz-Algorithm", valid_615170
  var valid_615171 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615171 = validateParameter(valid_615171, JString, required = false,
                                 default = nil)
  if valid_615171 != nil:
    section.add "X-Amz-SignedHeaders", valid_615171
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615172: Call_DescribeThingRegistrationTask_615161; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a bulk thing provisioning task.
  ## 
  let valid = call_615172.validator(path, query, header, formData, body)
  let scheme = call_615172.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615172.url(scheme.get, call_615172.host, call_615172.base,
                         call_615172.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615172, url, valid)

proc call*(call_615173: Call_DescribeThingRegistrationTask_615161; taskId: string): Recallable =
  ## describeThingRegistrationTask
  ## Describes a bulk thing provisioning task.
  ##   taskId: string (required)
  ##         : The task ID.
  var path_615174 = newJObject()
  add(path_615174, "taskId", newJString(taskId))
  result = call_615173.call(path_615174, nil, nil, nil, nil)

var describeThingRegistrationTask* = Call_DescribeThingRegistrationTask_615161(
    name: "describeThingRegistrationTask", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks/{taskId}",
    validator: validate_DescribeThingRegistrationTask_615162, base: "/",
    url: url_DescribeThingRegistrationTask_615163,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DisableTopicRule_615175 = ref object of OpenApiRestCall_612658
proc url_DisableTopicRule_615177(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName"),
               (kind: ConstantSegment, value: "/disable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DisableTopicRule_615176(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Disables the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule to disable.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_615178 = path.getOrDefault("ruleName")
  valid_615178 = validateParameter(valid_615178, JString, required = true,
                                 default = nil)
  if valid_615178 != nil:
    section.add "ruleName", valid_615178
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615179 = header.getOrDefault("X-Amz-Signature")
  valid_615179 = validateParameter(valid_615179, JString, required = false,
                                 default = nil)
  if valid_615179 != nil:
    section.add "X-Amz-Signature", valid_615179
  var valid_615180 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615180 = validateParameter(valid_615180, JString, required = false,
                                 default = nil)
  if valid_615180 != nil:
    section.add "X-Amz-Content-Sha256", valid_615180
  var valid_615181 = header.getOrDefault("X-Amz-Date")
  valid_615181 = validateParameter(valid_615181, JString, required = false,
                                 default = nil)
  if valid_615181 != nil:
    section.add "X-Amz-Date", valid_615181
  var valid_615182 = header.getOrDefault("X-Amz-Credential")
  valid_615182 = validateParameter(valid_615182, JString, required = false,
                                 default = nil)
  if valid_615182 != nil:
    section.add "X-Amz-Credential", valid_615182
  var valid_615183 = header.getOrDefault("X-Amz-Security-Token")
  valid_615183 = validateParameter(valid_615183, JString, required = false,
                                 default = nil)
  if valid_615183 != nil:
    section.add "X-Amz-Security-Token", valid_615183
  var valid_615184 = header.getOrDefault("X-Amz-Algorithm")
  valid_615184 = validateParameter(valid_615184, JString, required = false,
                                 default = nil)
  if valid_615184 != nil:
    section.add "X-Amz-Algorithm", valid_615184
  var valid_615185 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615185 = validateParameter(valid_615185, JString, required = false,
                                 default = nil)
  if valid_615185 != nil:
    section.add "X-Amz-SignedHeaders", valid_615185
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615186: Call_DisableTopicRule_615175; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Disables the rule.
  ## 
  let valid = call_615186.validator(path, query, header, formData, body)
  let scheme = call_615186.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615186.url(scheme.get, call_615186.host, call_615186.base,
                         call_615186.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615186, url, valid)

proc call*(call_615187: Call_DisableTopicRule_615175; ruleName: string): Recallable =
  ## disableTopicRule
  ## Disables the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule to disable.
  var path_615188 = newJObject()
  add(path_615188, "ruleName", newJString(ruleName))
  result = call_615187.call(path_615188, nil, nil, nil, nil)

var disableTopicRule* = Call_DisableTopicRule_615175(name: "disableTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}/disable", validator: validate_DisableTopicRule_615176,
    base: "/", url: url_DisableTopicRule_615177,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_EnableTopicRule_615189 = ref object of OpenApiRestCall_612658
proc url_EnableTopicRule_615191(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName"),
               (kind: ConstantSegment, value: "/enable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_EnableTopicRule_615190(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Enables the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the topic rule to enable.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_615192 = path.getOrDefault("ruleName")
  valid_615192 = validateParameter(valid_615192, JString, required = true,
                                 default = nil)
  if valid_615192 != nil:
    section.add "ruleName", valid_615192
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615193 = header.getOrDefault("X-Amz-Signature")
  valid_615193 = validateParameter(valid_615193, JString, required = false,
                                 default = nil)
  if valid_615193 != nil:
    section.add "X-Amz-Signature", valid_615193
  var valid_615194 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615194 = validateParameter(valid_615194, JString, required = false,
                                 default = nil)
  if valid_615194 != nil:
    section.add "X-Amz-Content-Sha256", valid_615194
  var valid_615195 = header.getOrDefault("X-Amz-Date")
  valid_615195 = validateParameter(valid_615195, JString, required = false,
                                 default = nil)
  if valid_615195 != nil:
    section.add "X-Amz-Date", valid_615195
  var valid_615196 = header.getOrDefault("X-Amz-Credential")
  valid_615196 = validateParameter(valid_615196, JString, required = false,
                                 default = nil)
  if valid_615196 != nil:
    section.add "X-Amz-Credential", valid_615196
  var valid_615197 = header.getOrDefault("X-Amz-Security-Token")
  valid_615197 = validateParameter(valid_615197, JString, required = false,
                                 default = nil)
  if valid_615197 != nil:
    section.add "X-Amz-Security-Token", valid_615197
  var valid_615198 = header.getOrDefault("X-Amz-Algorithm")
  valid_615198 = validateParameter(valid_615198, JString, required = false,
                                 default = nil)
  if valid_615198 != nil:
    section.add "X-Amz-Algorithm", valid_615198
  var valid_615199 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615199 = validateParameter(valid_615199, JString, required = false,
                                 default = nil)
  if valid_615199 != nil:
    section.add "X-Amz-SignedHeaders", valid_615199
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615200: Call_EnableTopicRule_615189; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the rule.
  ## 
  let valid = call_615200.validator(path, query, header, formData, body)
  let scheme = call_615200.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615200.url(scheme.get, call_615200.host, call_615200.base,
                         call_615200.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615200, url, valid)

proc call*(call_615201: Call_EnableTopicRule_615189; ruleName: string): Recallable =
  ## enableTopicRule
  ## Enables the rule.
  ##   ruleName: string (required)
  ##           : The name of the topic rule to enable.
  var path_615202 = newJObject()
  add(path_615202, "ruleName", newJString(ruleName))
  result = call_615201.call(path_615202, nil, nil, nil, nil)

var enableTopicRule* = Call_EnableTopicRule_615189(name: "enableTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}/enable", validator: validate_EnableTopicRule_615190,
    base: "/", url: url_EnableTopicRule_615191, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCardinality_615203 = ref object of OpenApiRestCall_612658
proc url_GetCardinality_615205(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCardinality_615204(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Returns the approximate count of unique values that match the query.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615206 = header.getOrDefault("X-Amz-Signature")
  valid_615206 = validateParameter(valid_615206, JString, required = false,
                                 default = nil)
  if valid_615206 != nil:
    section.add "X-Amz-Signature", valid_615206
  var valid_615207 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615207 = validateParameter(valid_615207, JString, required = false,
                                 default = nil)
  if valid_615207 != nil:
    section.add "X-Amz-Content-Sha256", valid_615207
  var valid_615208 = header.getOrDefault("X-Amz-Date")
  valid_615208 = validateParameter(valid_615208, JString, required = false,
                                 default = nil)
  if valid_615208 != nil:
    section.add "X-Amz-Date", valid_615208
  var valid_615209 = header.getOrDefault("X-Amz-Credential")
  valid_615209 = validateParameter(valid_615209, JString, required = false,
                                 default = nil)
  if valid_615209 != nil:
    section.add "X-Amz-Credential", valid_615209
  var valid_615210 = header.getOrDefault("X-Amz-Security-Token")
  valid_615210 = validateParameter(valid_615210, JString, required = false,
                                 default = nil)
  if valid_615210 != nil:
    section.add "X-Amz-Security-Token", valid_615210
  var valid_615211 = header.getOrDefault("X-Amz-Algorithm")
  valid_615211 = validateParameter(valid_615211, JString, required = false,
                                 default = nil)
  if valid_615211 != nil:
    section.add "X-Amz-Algorithm", valid_615211
  var valid_615212 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615212 = validateParameter(valid_615212, JString, required = false,
                                 default = nil)
  if valid_615212 != nil:
    section.add "X-Amz-SignedHeaders", valid_615212
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_615214: Call_GetCardinality_615203; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the approximate count of unique values that match the query.
  ## 
  let valid = call_615214.validator(path, query, header, formData, body)
  let scheme = call_615214.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615214.url(scheme.get, call_615214.host, call_615214.base,
                         call_615214.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615214, url, valid)

proc call*(call_615215: Call_GetCardinality_615203; body: JsonNode): Recallable =
  ## getCardinality
  ## Returns the approximate count of unique values that match the query.
  ##   body: JObject (required)
  var body_615216 = newJObject()
  if body != nil:
    body_615216 = body
  result = call_615215.call(nil, nil, nil, nil, body_615216)

var getCardinality* = Call_GetCardinality_615203(name: "getCardinality",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/cardinality", validator: validate_GetCardinality_615204,
    base: "/", url: url_GetCardinality_615205, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEffectivePolicies_615217 = ref object of OpenApiRestCall_612658
proc url_GetEffectivePolicies_615219(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEffectivePolicies_615218(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingName: JString
  ##            : The thing name.
  section = newJObject()
  var valid_615220 = query.getOrDefault("thingName")
  valid_615220 = validateParameter(valid_615220, JString, required = false,
                                 default = nil)
  if valid_615220 != nil:
    section.add "thingName", valid_615220
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615221 = header.getOrDefault("X-Amz-Signature")
  valid_615221 = validateParameter(valid_615221, JString, required = false,
                                 default = nil)
  if valid_615221 != nil:
    section.add "X-Amz-Signature", valid_615221
  var valid_615222 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615222 = validateParameter(valid_615222, JString, required = false,
                                 default = nil)
  if valid_615222 != nil:
    section.add "X-Amz-Content-Sha256", valid_615222
  var valid_615223 = header.getOrDefault("X-Amz-Date")
  valid_615223 = validateParameter(valid_615223, JString, required = false,
                                 default = nil)
  if valid_615223 != nil:
    section.add "X-Amz-Date", valid_615223
  var valid_615224 = header.getOrDefault("X-Amz-Credential")
  valid_615224 = validateParameter(valid_615224, JString, required = false,
                                 default = nil)
  if valid_615224 != nil:
    section.add "X-Amz-Credential", valid_615224
  var valid_615225 = header.getOrDefault("X-Amz-Security-Token")
  valid_615225 = validateParameter(valid_615225, JString, required = false,
                                 default = nil)
  if valid_615225 != nil:
    section.add "X-Amz-Security-Token", valid_615225
  var valid_615226 = header.getOrDefault("X-Amz-Algorithm")
  valid_615226 = validateParameter(valid_615226, JString, required = false,
                                 default = nil)
  if valid_615226 != nil:
    section.add "X-Amz-Algorithm", valid_615226
  var valid_615227 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615227 = validateParameter(valid_615227, JString, required = false,
                                 default = nil)
  if valid_615227 != nil:
    section.add "X-Amz-SignedHeaders", valid_615227
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_615229: Call_GetEffectivePolicies_615217; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ## 
  let valid = call_615229.validator(path, query, header, formData, body)
  let scheme = call_615229.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615229.url(scheme.get, call_615229.host, call_615229.base,
                         call_615229.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615229, url, valid)

proc call*(call_615230: Call_GetEffectivePolicies_615217; body: JsonNode;
          thingName: string = ""): Recallable =
  ## getEffectivePolicies
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ##   thingName: string
  ##            : The thing name.
  ##   body: JObject (required)
  var query_615231 = newJObject()
  var body_615232 = newJObject()
  add(query_615231, "thingName", newJString(thingName))
  if body != nil:
    body_615232 = body
  result = call_615230.call(nil, query_615231, nil, nil, body_615232)

var getEffectivePolicies* = Call_GetEffectivePolicies_615217(
    name: "getEffectivePolicies", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/effective-policies",
    validator: validate_GetEffectivePolicies_615218, base: "/",
    url: url_GetEffectivePolicies_615219, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateIndexingConfiguration_615245 = ref object of OpenApiRestCall_612658
proc url_UpdateIndexingConfiguration_615247(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateIndexingConfiguration_615246(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the search configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615248 = header.getOrDefault("X-Amz-Signature")
  valid_615248 = validateParameter(valid_615248, JString, required = false,
                                 default = nil)
  if valid_615248 != nil:
    section.add "X-Amz-Signature", valid_615248
  var valid_615249 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615249 = validateParameter(valid_615249, JString, required = false,
                                 default = nil)
  if valid_615249 != nil:
    section.add "X-Amz-Content-Sha256", valid_615249
  var valid_615250 = header.getOrDefault("X-Amz-Date")
  valid_615250 = validateParameter(valid_615250, JString, required = false,
                                 default = nil)
  if valid_615250 != nil:
    section.add "X-Amz-Date", valid_615250
  var valid_615251 = header.getOrDefault("X-Amz-Credential")
  valid_615251 = validateParameter(valid_615251, JString, required = false,
                                 default = nil)
  if valid_615251 != nil:
    section.add "X-Amz-Credential", valid_615251
  var valid_615252 = header.getOrDefault("X-Amz-Security-Token")
  valid_615252 = validateParameter(valid_615252, JString, required = false,
                                 default = nil)
  if valid_615252 != nil:
    section.add "X-Amz-Security-Token", valid_615252
  var valid_615253 = header.getOrDefault("X-Amz-Algorithm")
  valid_615253 = validateParameter(valid_615253, JString, required = false,
                                 default = nil)
  if valid_615253 != nil:
    section.add "X-Amz-Algorithm", valid_615253
  var valid_615254 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615254 = validateParameter(valid_615254, JString, required = false,
                                 default = nil)
  if valid_615254 != nil:
    section.add "X-Amz-SignedHeaders", valid_615254
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_615256: Call_UpdateIndexingConfiguration_615245; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the search configuration.
  ## 
  let valid = call_615256.validator(path, query, header, formData, body)
  let scheme = call_615256.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615256.url(scheme.get, call_615256.host, call_615256.base,
                         call_615256.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615256, url, valid)

proc call*(call_615257: Call_UpdateIndexingConfiguration_615245; body: JsonNode): Recallable =
  ## updateIndexingConfiguration
  ## Updates the search configuration.
  ##   body: JObject (required)
  var body_615258 = newJObject()
  if body != nil:
    body_615258 = body
  result = call_615257.call(nil, nil, nil, nil, body_615258)

var updateIndexingConfiguration* = Call_UpdateIndexingConfiguration_615245(
    name: "updateIndexingConfiguration", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/indexing/config",
    validator: validate_UpdateIndexingConfiguration_615246, base: "/",
    url: url_UpdateIndexingConfiguration_615247,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetIndexingConfiguration_615233 = ref object of OpenApiRestCall_612658
proc url_GetIndexingConfiguration_615235(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetIndexingConfiguration_615234(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the indexing configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615236 = header.getOrDefault("X-Amz-Signature")
  valid_615236 = validateParameter(valid_615236, JString, required = false,
                                 default = nil)
  if valid_615236 != nil:
    section.add "X-Amz-Signature", valid_615236
  var valid_615237 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615237 = validateParameter(valid_615237, JString, required = false,
                                 default = nil)
  if valid_615237 != nil:
    section.add "X-Amz-Content-Sha256", valid_615237
  var valid_615238 = header.getOrDefault("X-Amz-Date")
  valid_615238 = validateParameter(valid_615238, JString, required = false,
                                 default = nil)
  if valid_615238 != nil:
    section.add "X-Amz-Date", valid_615238
  var valid_615239 = header.getOrDefault("X-Amz-Credential")
  valid_615239 = validateParameter(valid_615239, JString, required = false,
                                 default = nil)
  if valid_615239 != nil:
    section.add "X-Amz-Credential", valid_615239
  var valid_615240 = header.getOrDefault("X-Amz-Security-Token")
  valid_615240 = validateParameter(valid_615240, JString, required = false,
                                 default = nil)
  if valid_615240 != nil:
    section.add "X-Amz-Security-Token", valid_615240
  var valid_615241 = header.getOrDefault("X-Amz-Algorithm")
  valid_615241 = validateParameter(valid_615241, JString, required = false,
                                 default = nil)
  if valid_615241 != nil:
    section.add "X-Amz-Algorithm", valid_615241
  var valid_615242 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615242 = validateParameter(valid_615242, JString, required = false,
                                 default = nil)
  if valid_615242 != nil:
    section.add "X-Amz-SignedHeaders", valid_615242
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615243: Call_GetIndexingConfiguration_615233; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the indexing configuration.
  ## 
  let valid = call_615243.validator(path, query, header, formData, body)
  let scheme = call_615243.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615243.url(scheme.get, call_615243.host, call_615243.base,
                         call_615243.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615243, url, valid)

proc call*(call_615244: Call_GetIndexingConfiguration_615233): Recallable =
  ## getIndexingConfiguration
  ## Gets the indexing configuration.
  result = call_615244.call(nil, nil, nil, nil, nil)

var getIndexingConfiguration* = Call_GetIndexingConfiguration_615233(
    name: "getIndexingConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/indexing/config",
    validator: validate_GetIndexingConfiguration_615234, base: "/",
    url: url_GetIndexingConfiguration_615235, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetJobDocument_615259 = ref object of OpenApiRestCall_612658
proc url_GetJobDocument_615261(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/job-document")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetJobDocument_615260(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets a job document.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_615262 = path.getOrDefault("jobId")
  valid_615262 = validateParameter(valid_615262, JString, required = true,
                                 default = nil)
  if valid_615262 != nil:
    section.add "jobId", valid_615262
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615263 = header.getOrDefault("X-Amz-Signature")
  valid_615263 = validateParameter(valid_615263, JString, required = false,
                                 default = nil)
  if valid_615263 != nil:
    section.add "X-Amz-Signature", valid_615263
  var valid_615264 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615264 = validateParameter(valid_615264, JString, required = false,
                                 default = nil)
  if valid_615264 != nil:
    section.add "X-Amz-Content-Sha256", valid_615264
  var valid_615265 = header.getOrDefault("X-Amz-Date")
  valid_615265 = validateParameter(valid_615265, JString, required = false,
                                 default = nil)
  if valid_615265 != nil:
    section.add "X-Amz-Date", valid_615265
  var valid_615266 = header.getOrDefault("X-Amz-Credential")
  valid_615266 = validateParameter(valid_615266, JString, required = false,
                                 default = nil)
  if valid_615266 != nil:
    section.add "X-Amz-Credential", valid_615266
  var valid_615267 = header.getOrDefault("X-Amz-Security-Token")
  valid_615267 = validateParameter(valid_615267, JString, required = false,
                                 default = nil)
  if valid_615267 != nil:
    section.add "X-Amz-Security-Token", valid_615267
  var valid_615268 = header.getOrDefault("X-Amz-Algorithm")
  valid_615268 = validateParameter(valid_615268, JString, required = false,
                                 default = nil)
  if valid_615268 != nil:
    section.add "X-Amz-Algorithm", valid_615268
  var valid_615269 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615269 = validateParameter(valid_615269, JString, required = false,
                                 default = nil)
  if valid_615269 != nil:
    section.add "X-Amz-SignedHeaders", valid_615269
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615270: Call_GetJobDocument_615259; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a job document.
  ## 
  let valid = call_615270.validator(path, query, header, formData, body)
  let scheme = call_615270.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615270.url(scheme.get, call_615270.host, call_615270.base,
                         call_615270.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615270, url, valid)

proc call*(call_615271: Call_GetJobDocument_615259; jobId: string): Recallable =
  ## getJobDocument
  ## Gets a job document.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  var path_615272 = newJObject()
  add(path_615272, "jobId", newJString(jobId))
  result = call_615271.call(path_615272, nil, nil, nil, nil)

var getJobDocument* = Call_GetJobDocument_615259(name: "getJobDocument",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/jobs/{jobId}/job-document", validator: validate_GetJobDocument_615260,
    base: "/", url: url_GetJobDocument_615261, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetLoggingOptions_615285 = ref object of OpenApiRestCall_612658
proc url_SetLoggingOptions_615287(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetLoggingOptions_615286(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615288 = header.getOrDefault("X-Amz-Signature")
  valid_615288 = validateParameter(valid_615288, JString, required = false,
                                 default = nil)
  if valid_615288 != nil:
    section.add "X-Amz-Signature", valid_615288
  var valid_615289 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615289 = validateParameter(valid_615289, JString, required = false,
                                 default = nil)
  if valid_615289 != nil:
    section.add "X-Amz-Content-Sha256", valid_615289
  var valid_615290 = header.getOrDefault("X-Amz-Date")
  valid_615290 = validateParameter(valid_615290, JString, required = false,
                                 default = nil)
  if valid_615290 != nil:
    section.add "X-Amz-Date", valid_615290
  var valid_615291 = header.getOrDefault("X-Amz-Credential")
  valid_615291 = validateParameter(valid_615291, JString, required = false,
                                 default = nil)
  if valid_615291 != nil:
    section.add "X-Amz-Credential", valid_615291
  var valid_615292 = header.getOrDefault("X-Amz-Security-Token")
  valid_615292 = validateParameter(valid_615292, JString, required = false,
                                 default = nil)
  if valid_615292 != nil:
    section.add "X-Amz-Security-Token", valid_615292
  var valid_615293 = header.getOrDefault("X-Amz-Algorithm")
  valid_615293 = validateParameter(valid_615293, JString, required = false,
                                 default = nil)
  if valid_615293 != nil:
    section.add "X-Amz-Algorithm", valid_615293
  var valid_615294 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615294 = validateParameter(valid_615294, JString, required = false,
                                 default = nil)
  if valid_615294 != nil:
    section.add "X-Amz-SignedHeaders", valid_615294
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_615296: Call_SetLoggingOptions_615285; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ## 
  let valid = call_615296.validator(path, query, header, formData, body)
  let scheme = call_615296.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615296.url(scheme.get, call_615296.host, call_615296.base,
                         call_615296.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615296, url, valid)

proc call*(call_615297: Call_SetLoggingOptions_615285; body: JsonNode): Recallable =
  ## setLoggingOptions
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ##   body: JObject (required)
  var body_615298 = newJObject()
  if body != nil:
    body_615298 = body
  result = call_615297.call(nil, nil, nil, nil, body_615298)

var setLoggingOptions* = Call_SetLoggingOptions_615285(name: "setLoggingOptions",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/loggingOptions",
    validator: validate_SetLoggingOptions_615286, base: "/",
    url: url_SetLoggingOptions_615287, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetLoggingOptions_615273 = ref object of OpenApiRestCall_612658
proc url_GetLoggingOptions_615275(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetLoggingOptions_615274(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615276 = header.getOrDefault("X-Amz-Signature")
  valid_615276 = validateParameter(valid_615276, JString, required = false,
                                 default = nil)
  if valid_615276 != nil:
    section.add "X-Amz-Signature", valid_615276
  var valid_615277 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615277 = validateParameter(valid_615277, JString, required = false,
                                 default = nil)
  if valid_615277 != nil:
    section.add "X-Amz-Content-Sha256", valid_615277
  var valid_615278 = header.getOrDefault("X-Amz-Date")
  valid_615278 = validateParameter(valid_615278, JString, required = false,
                                 default = nil)
  if valid_615278 != nil:
    section.add "X-Amz-Date", valid_615278
  var valid_615279 = header.getOrDefault("X-Amz-Credential")
  valid_615279 = validateParameter(valid_615279, JString, required = false,
                                 default = nil)
  if valid_615279 != nil:
    section.add "X-Amz-Credential", valid_615279
  var valid_615280 = header.getOrDefault("X-Amz-Security-Token")
  valid_615280 = validateParameter(valid_615280, JString, required = false,
                                 default = nil)
  if valid_615280 != nil:
    section.add "X-Amz-Security-Token", valid_615280
  var valid_615281 = header.getOrDefault("X-Amz-Algorithm")
  valid_615281 = validateParameter(valid_615281, JString, required = false,
                                 default = nil)
  if valid_615281 != nil:
    section.add "X-Amz-Algorithm", valid_615281
  var valid_615282 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615282 = validateParameter(valid_615282, JString, required = false,
                                 default = nil)
  if valid_615282 != nil:
    section.add "X-Amz-SignedHeaders", valid_615282
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615283: Call_GetLoggingOptions_615273; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  ## 
  let valid = call_615283.validator(path, query, header, formData, body)
  let scheme = call_615283.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615283.url(scheme.get, call_615283.host, call_615283.base,
                         call_615283.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615283, url, valid)

proc call*(call_615284: Call_GetLoggingOptions_615273): Recallable =
  ## getLoggingOptions
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  result = call_615284.call(nil, nil, nil, nil, nil)

var getLoggingOptions* = Call_GetLoggingOptions_615273(name: "getLoggingOptions",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/loggingOptions",
    validator: validate_GetLoggingOptions_615274, base: "/",
    url: url_GetLoggingOptions_615275, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPercentiles_615299 = ref object of OpenApiRestCall_612658
proc url_GetPercentiles_615301(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetPercentiles_615300(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Groups the aggregated values that match the query into percentile groupings. The default percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own when you call <code>GetPercentiles</code>. This function returns a value for each percentile group specified (or the default percentile groupings). The percentile group "1" contains the aggregated field value that occurs in approximately one percent of the values that match the query. The percentile group "5" contains the aggregated field value that occurs in approximately five percent of the values that match the query, and so on. The result is an approximation, the more values that match the query, the more accurate the percentile values.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615302 = header.getOrDefault("X-Amz-Signature")
  valid_615302 = validateParameter(valid_615302, JString, required = false,
                                 default = nil)
  if valid_615302 != nil:
    section.add "X-Amz-Signature", valid_615302
  var valid_615303 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615303 = validateParameter(valid_615303, JString, required = false,
                                 default = nil)
  if valid_615303 != nil:
    section.add "X-Amz-Content-Sha256", valid_615303
  var valid_615304 = header.getOrDefault("X-Amz-Date")
  valid_615304 = validateParameter(valid_615304, JString, required = false,
                                 default = nil)
  if valid_615304 != nil:
    section.add "X-Amz-Date", valid_615304
  var valid_615305 = header.getOrDefault("X-Amz-Credential")
  valid_615305 = validateParameter(valid_615305, JString, required = false,
                                 default = nil)
  if valid_615305 != nil:
    section.add "X-Amz-Credential", valid_615305
  var valid_615306 = header.getOrDefault("X-Amz-Security-Token")
  valid_615306 = validateParameter(valid_615306, JString, required = false,
                                 default = nil)
  if valid_615306 != nil:
    section.add "X-Amz-Security-Token", valid_615306
  var valid_615307 = header.getOrDefault("X-Amz-Algorithm")
  valid_615307 = validateParameter(valid_615307, JString, required = false,
                                 default = nil)
  if valid_615307 != nil:
    section.add "X-Amz-Algorithm", valid_615307
  var valid_615308 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615308 = validateParameter(valid_615308, JString, required = false,
                                 default = nil)
  if valid_615308 != nil:
    section.add "X-Amz-SignedHeaders", valid_615308
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_615310: Call_GetPercentiles_615299; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Groups the aggregated values that match the query into percentile groupings. The default percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own when you call <code>GetPercentiles</code>. This function returns a value for each percentile group specified (or the default percentile groupings). The percentile group "1" contains the aggregated field value that occurs in approximately one percent of the values that match the query. The percentile group "5" contains the aggregated field value that occurs in approximately five percent of the values that match the query, and so on. The result is an approximation, the more values that match the query, the more accurate the percentile values.
  ## 
  let valid = call_615310.validator(path, query, header, formData, body)
  let scheme = call_615310.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615310.url(scheme.get, call_615310.host, call_615310.base,
                         call_615310.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615310, url, valid)

proc call*(call_615311: Call_GetPercentiles_615299; body: JsonNode): Recallable =
  ## getPercentiles
  ## Groups the aggregated values that match the query into percentile groupings. The default percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own when you call <code>GetPercentiles</code>. This function returns a value for each percentile group specified (or the default percentile groupings). The percentile group "1" contains the aggregated field value that occurs in approximately one percent of the values that match the query. The percentile group "5" contains the aggregated field value that occurs in approximately five percent of the values that match the query, and so on. The result is an approximation, the more values that match the query, the more accurate the percentile values.
  ##   body: JObject (required)
  var body_615312 = newJObject()
  if body != nil:
    body_615312 = body
  result = call_615311.call(nil, nil, nil, nil, body_615312)

var getPercentiles* = Call_GetPercentiles_615299(name: "getPercentiles",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/percentiles", validator: validate_GetPercentiles_615300,
    base: "/", url: url_GetPercentiles_615301, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetStatistics_615313 = ref object of OpenApiRestCall_612658
proc url_GetStatistics_615315(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetStatistics_615314(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the count, average, sum, minimum, maximum, sum of squares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type <code>String</code>, only the count statistic is returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615316 = header.getOrDefault("X-Amz-Signature")
  valid_615316 = validateParameter(valid_615316, JString, required = false,
                                 default = nil)
  if valid_615316 != nil:
    section.add "X-Amz-Signature", valid_615316
  var valid_615317 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615317 = validateParameter(valid_615317, JString, required = false,
                                 default = nil)
  if valid_615317 != nil:
    section.add "X-Amz-Content-Sha256", valid_615317
  var valid_615318 = header.getOrDefault("X-Amz-Date")
  valid_615318 = validateParameter(valid_615318, JString, required = false,
                                 default = nil)
  if valid_615318 != nil:
    section.add "X-Amz-Date", valid_615318
  var valid_615319 = header.getOrDefault("X-Amz-Credential")
  valid_615319 = validateParameter(valid_615319, JString, required = false,
                                 default = nil)
  if valid_615319 != nil:
    section.add "X-Amz-Credential", valid_615319
  var valid_615320 = header.getOrDefault("X-Amz-Security-Token")
  valid_615320 = validateParameter(valid_615320, JString, required = false,
                                 default = nil)
  if valid_615320 != nil:
    section.add "X-Amz-Security-Token", valid_615320
  var valid_615321 = header.getOrDefault("X-Amz-Algorithm")
  valid_615321 = validateParameter(valid_615321, JString, required = false,
                                 default = nil)
  if valid_615321 != nil:
    section.add "X-Amz-Algorithm", valid_615321
  var valid_615322 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615322 = validateParameter(valid_615322, JString, required = false,
                                 default = nil)
  if valid_615322 != nil:
    section.add "X-Amz-SignedHeaders", valid_615322
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_615324: Call_GetStatistics_615313; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the count, average, sum, minimum, maximum, sum of squares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type <code>String</code>, only the count statistic is returned.
  ## 
  let valid = call_615324.validator(path, query, header, formData, body)
  let scheme = call_615324.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615324.url(scheme.get, call_615324.host, call_615324.base,
                         call_615324.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615324, url, valid)

proc call*(call_615325: Call_GetStatistics_615313; body: JsonNode): Recallable =
  ## getStatistics
  ## Returns the count, average, sum, minimum, maximum, sum of squares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type <code>String</code>, only the count statistic is returned.
  ##   body: JObject (required)
  var body_615326 = newJObject()
  if body != nil:
    body_615326 = body
  result = call_615325.call(nil, nil, nil, nil, body_615326)

var getStatistics* = Call_GetStatistics_615313(name: "getStatistics",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/statistics", validator: validate_GetStatistics_615314,
    base: "/", url: url_GetStatistics_615315, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetV2LoggingOptions_615339 = ref object of OpenApiRestCall_612658
proc url_SetV2LoggingOptions_615341(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetV2LoggingOptions_615340(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Sets the logging options for the V2 logging service.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615342 = header.getOrDefault("X-Amz-Signature")
  valid_615342 = validateParameter(valid_615342, JString, required = false,
                                 default = nil)
  if valid_615342 != nil:
    section.add "X-Amz-Signature", valid_615342
  var valid_615343 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615343 = validateParameter(valid_615343, JString, required = false,
                                 default = nil)
  if valid_615343 != nil:
    section.add "X-Amz-Content-Sha256", valid_615343
  var valid_615344 = header.getOrDefault("X-Amz-Date")
  valid_615344 = validateParameter(valid_615344, JString, required = false,
                                 default = nil)
  if valid_615344 != nil:
    section.add "X-Amz-Date", valid_615344
  var valid_615345 = header.getOrDefault("X-Amz-Credential")
  valid_615345 = validateParameter(valid_615345, JString, required = false,
                                 default = nil)
  if valid_615345 != nil:
    section.add "X-Amz-Credential", valid_615345
  var valid_615346 = header.getOrDefault("X-Amz-Security-Token")
  valid_615346 = validateParameter(valid_615346, JString, required = false,
                                 default = nil)
  if valid_615346 != nil:
    section.add "X-Amz-Security-Token", valid_615346
  var valid_615347 = header.getOrDefault("X-Amz-Algorithm")
  valid_615347 = validateParameter(valid_615347, JString, required = false,
                                 default = nil)
  if valid_615347 != nil:
    section.add "X-Amz-Algorithm", valid_615347
  var valid_615348 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615348 = validateParameter(valid_615348, JString, required = false,
                                 default = nil)
  if valid_615348 != nil:
    section.add "X-Amz-SignedHeaders", valid_615348
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_615350: Call_SetV2LoggingOptions_615339; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the logging options for the V2 logging service.
  ## 
  let valid = call_615350.validator(path, query, header, formData, body)
  let scheme = call_615350.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615350.url(scheme.get, call_615350.host, call_615350.base,
                         call_615350.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615350, url, valid)

proc call*(call_615351: Call_SetV2LoggingOptions_615339; body: JsonNode): Recallable =
  ## setV2LoggingOptions
  ## Sets the logging options for the V2 logging service.
  ##   body: JObject (required)
  var body_615352 = newJObject()
  if body != nil:
    body_615352 = body
  result = call_615351.call(nil, nil, nil, nil, body_615352)

var setV2LoggingOptions* = Call_SetV2LoggingOptions_615339(
    name: "setV2LoggingOptions", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/v2LoggingOptions",
    validator: validate_SetV2LoggingOptions_615340, base: "/",
    url: url_SetV2LoggingOptions_615341, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetV2LoggingOptions_615327 = ref object of OpenApiRestCall_612658
proc url_GetV2LoggingOptions_615329(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV2LoggingOptions_615328(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets the fine grained logging options.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615330 = header.getOrDefault("X-Amz-Signature")
  valid_615330 = validateParameter(valid_615330, JString, required = false,
                                 default = nil)
  if valid_615330 != nil:
    section.add "X-Amz-Signature", valid_615330
  var valid_615331 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615331 = validateParameter(valid_615331, JString, required = false,
                                 default = nil)
  if valid_615331 != nil:
    section.add "X-Amz-Content-Sha256", valid_615331
  var valid_615332 = header.getOrDefault("X-Amz-Date")
  valid_615332 = validateParameter(valid_615332, JString, required = false,
                                 default = nil)
  if valid_615332 != nil:
    section.add "X-Amz-Date", valid_615332
  var valid_615333 = header.getOrDefault("X-Amz-Credential")
  valid_615333 = validateParameter(valid_615333, JString, required = false,
                                 default = nil)
  if valid_615333 != nil:
    section.add "X-Amz-Credential", valid_615333
  var valid_615334 = header.getOrDefault("X-Amz-Security-Token")
  valid_615334 = validateParameter(valid_615334, JString, required = false,
                                 default = nil)
  if valid_615334 != nil:
    section.add "X-Amz-Security-Token", valid_615334
  var valid_615335 = header.getOrDefault("X-Amz-Algorithm")
  valid_615335 = validateParameter(valid_615335, JString, required = false,
                                 default = nil)
  if valid_615335 != nil:
    section.add "X-Amz-Algorithm", valid_615335
  var valid_615336 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615336 = validateParameter(valid_615336, JString, required = false,
                                 default = nil)
  if valid_615336 != nil:
    section.add "X-Amz-SignedHeaders", valid_615336
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615337: Call_GetV2LoggingOptions_615327; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the fine grained logging options.
  ## 
  let valid = call_615337.validator(path, query, header, formData, body)
  let scheme = call_615337.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615337.url(scheme.get, call_615337.host, call_615337.base,
                         call_615337.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615337, url, valid)

proc call*(call_615338: Call_GetV2LoggingOptions_615327): Recallable =
  ## getV2LoggingOptions
  ## Gets the fine grained logging options.
  result = call_615338.call(nil, nil, nil, nil, nil)

var getV2LoggingOptions* = Call_GetV2LoggingOptions_615327(
    name: "getV2LoggingOptions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/v2LoggingOptions",
    validator: validate_GetV2LoggingOptions_615328, base: "/",
    url: url_GetV2LoggingOptions_615329, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListActiveViolations_615353 = ref object of OpenApiRestCall_612658
proc url_ListActiveViolations_615355(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListActiveViolations_615354(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the active violations for a given Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   securityProfileName: JString
  ##                      : The name of the Device Defender security profile for which violations are listed.
  ##   thingName: JString
  ##            : The name of the thing whose active violations are listed.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_615356 = query.getOrDefault("nextToken")
  valid_615356 = validateParameter(valid_615356, JString, required = false,
                                 default = nil)
  if valid_615356 != nil:
    section.add "nextToken", valid_615356
  var valid_615357 = query.getOrDefault("securityProfileName")
  valid_615357 = validateParameter(valid_615357, JString, required = false,
                                 default = nil)
  if valid_615357 != nil:
    section.add "securityProfileName", valid_615357
  var valid_615358 = query.getOrDefault("thingName")
  valid_615358 = validateParameter(valid_615358, JString, required = false,
                                 default = nil)
  if valid_615358 != nil:
    section.add "thingName", valid_615358
  var valid_615359 = query.getOrDefault("maxResults")
  valid_615359 = validateParameter(valid_615359, JInt, required = false, default = nil)
  if valid_615359 != nil:
    section.add "maxResults", valid_615359
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615360 = header.getOrDefault("X-Amz-Signature")
  valid_615360 = validateParameter(valid_615360, JString, required = false,
                                 default = nil)
  if valid_615360 != nil:
    section.add "X-Amz-Signature", valid_615360
  var valid_615361 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615361 = validateParameter(valid_615361, JString, required = false,
                                 default = nil)
  if valid_615361 != nil:
    section.add "X-Amz-Content-Sha256", valid_615361
  var valid_615362 = header.getOrDefault("X-Amz-Date")
  valid_615362 = validateParameter(valid_615362, JString, required = false,
                                 default = nil)
  if valid_615362 != nil:
    section.add "X-Amz-Date", valid_615362
  var valid_615363 = header.getOrDefault("X-Amz-Credential")
  valid_615363 = validateParameter(valid_615363, JString, required = false,
                                 default = nil)
  if valid_615363 != nil:
    section.add "X-Amz-Credential", valid_615363
  var valid_615364 = header.getOrDefault("X-Amz-Security-Token")
  valid_615364 = validateParameter(valid_615364, JString, required = false,
                                 default = nil)
  if valid_615364 != nil:
    section.add "X-Amz-Security-Token", valid_615364
  var valid_615365 = header.getOrDefault("X-Amz-Algorithm")
  valid_615365 = validateParameter(valid_615365, JString, required = false,
                                 default = nil)
  if valid_615365 != nil:
    section.add "X-Amz-Algorithm", valid_615365
  var valid_615366 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615366 = validateParameter(valid_615366, JString, required = false,
                                 default = nil)
  if valid_615366 != nil:
    section.add "X-Amz-SignedHeaders", valid_615366
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615367: Call_ListActiveViolations_615353; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the active violations for a given Device Defender security profile.
  ## 
  let valid = call_615367.validator(path, query, header, formData, body)
  let scheme = call_615367.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615367.url(scheme.get, call_615367.host, call_615367.base,
                         call_615367.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615367, url, valid)

proc call*(call_615368: Call_ListActiveViolations_615353; nextToken: string = "";
          securityProfileName: string = ""; thingName: string = ""; maxResults: int = 0): Recallable =
  ## listActiveViolations
  ## Lists the active violations for a given Device Defender security profile.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string
  ##                      : The name of the Device Defender security profile for which violations are listed.
  ##   thingName: string
  ##            : The name of the thing whose active violations are listed.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_615369 = newJObject()
  add(query_615369, "nextToken", newJString(nextToken))
  add(query_615369, "securityProfileName", newJString(securityProfileName))
  add(query_615369, "thingName", newJString(thingName))
  add(query_615369, "maxResults", newJInt(maxResults))
  result = call_615368.call(nil, query_615369, nil, nil, nil)

var listActiveViolations* = Call_ListActiveViolations_615353(
    name: "listActiveViolations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/active-violations",
    validator: validate_ListActiveViolations_615354, base: "/",
    url: url_ListActiveViolations_615355, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAttachedPolicies_615370 = ref object of OpenApiRestCall_612658
proc url_ListAttachedPolicies_615372(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "target" in path, "`target` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/attached-policies/"),
               (kind: VariableSegment, value: "target")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListAttachedPolicies_615371(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the policies attached to the specified thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   target: JString (required)
  ##         : The group or principal for which the policies will be listed.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `target` field"
  var valid_615373 = path.getOrDefault("target")
  valid_615373 = validateParameter(valid_615373, JString, required = true,
                                 default = nil)
  if valid_615373 != nil:
    section.add "target", valid_615373
  result.add "path", section
  ## parameters in `query` object:
  ##   pageSize: JInt
  ##           : The maximum number of results to be returned per request.
  ##   recursive: JBool
  ##            : When true, recursively list attached policies.
  ##   marker: JString
  ##         : The token to retrieve the next set of results.
  section = newJObject()
  var valid_615374 = query.getOrDefault("pageSize")
  valid_615374 = validateParameter(valid_615374, JInt, required = false, default = nil)
  if valid_615374 != nil:
    section.add "pageSize", valid_615374
  var valid_615375 = query.getOrDefault("recursive")
  valid_615375 = validateParameter(valid_615375, JBool, required = false, default = nil)
  if valid_615375 != nil:
    section.add "recursive", valid_615375
  var valid_615376 = query.getOrDefault("marker")
  valid_615376 = validateParameter(valid_615376, JString, required = false,
                                 default = nil)
  if valid_615376 != nil:
    section.add "marker", valid_615376
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615377 = header.getOrDefault("X-Amz-Signature")
  valid_615377 = validateParameter(valid_615377, JString, required = false,
                                 default = nil)
  if valid_615377 != nil:
    section.add "X-Amz-Signature", valid_615377
  var valid_615378 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615378 = validateParameter(valid_615378, JString, required = false,
                                 default = nil)
  if valid_615378 != nil:
    section.add "X-Amz-Content-Sha256", valid_615378
  var valid_615379 = header.getOrDefault("X-Amz-Date")
  valid_615379 = validateParameter(valid_615379, JString, required = false,
                                 default = nil)
  if valid_615379 != nil:
    section.add "X-Amz-Date", valid_615379
  var valid_615380 = header.getOrDefault("X-Amz-Credential")
  valid_615380 = validateParameter(valid_615380, JString, required = false,
                                 default = nil)
  if valid_615380 != nil:
    section.add "X-Amz-Credential", valid_615380
  var valid_615381 = header.getOrDefault("X-Amz-Security-Token")
  valid_615381 = validateParameter(valid_615381, JString, required = false,
                                 default = nil)
  if valid_615381 != nil:
    section.add "X-Amz-Security-Token", valid_615381
  var valid_615382 = header.getOrDefault("X-Amz-Algorithm")
  valid_615382 = validateParameter(valid_615382, JString, required = false,
                                 default = nil)
  if valid_615382 != nil:
    section.add "X-Amz-Algorithm", valid_615382
  var valid_615383 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615383 = validateParameter(valid_615383, JString, required = false,
                                 default = nil)
  if valid_615383 != nil:
    section.add "X-Amz-SignedHeaders", valid_615383
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615384: Call_ListAttachedPolicies_615370; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the policies attached to the specified thing group.
  ## 
  let valid = call_615384.validator(path, query, header, formData, body)
  let scheme = call_615384.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615384.url(scheme.get, call_615384.host, call_615384.base,
                         call_615384.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615384, url, valid)

proc call*(call_615385: Call_ListAttachedPolicies_615370; target: string;
          pageSize: int = 0; recursive: bool = false; marker: string = ""): Recallable =
  ## listAttachedPolicies
  ## Lists the policies attached to the specified thing group.
  ##   pageSize: int
  ##           : The maximum number of results to be returned per request.
  ##   recursive: bool
  ##            : When true, recursively list attached policies.
  ##   target: string (required)
  ##         : The group or principal for which the policies will be listed.
  ##   marker: string
  ##         : The token to retrieve the next set of results.
  var path_615386 = newJObject()
  var query_615387 = newJObject()
  add(query_615387, "pageSize", newJInt(pageSize))
  add(query_615387, "recursive", newJBool(recursive))
  add(path_615386, "target", newJString(target))
  add(query_615387, "marker", newJString(marker))
  result = call_615385.call(path_615386, query_615387, nil, nil, nil)

var listAttachedPolicies* = Call_ListAttachedPolicies_615370(
    name: "listAttachedPolicies", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/attached-policies/{target}",
    validator: validate_ListAttachedPolicies_615371, base: "/",
    url: url_ListAttachedPolicies_615372, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditFindings_615388 = ref object of OpenApiRestCall_612658
proc url_ListAuditFindings_615390(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditFindings_615389(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615391 = header.getOrDefault("X-Amz-Signature")
  valid_615391 = validateParameter(valid_615391, JString, required = false,
                                 default = nil)
  if valid_615391 != nil:
    section.add "X-Amz-Signature", valid_615391
  var valid_615392 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615392 = validateParameter(valid_615392, JString, required = false,
                                 default = nil)
  if valid_615392 != nil:
    section.add "X-Amz-Content-Sha256", valid_615392
  var valid_615393 = header.getOrDefault("X-Amz-Date")
  valid_615393 = validateParameter(valid_615393, JString, required = false,
                                 default = nil)
  if valid_615393 != nil:
    section.add "X-Amz-Date", valid_615393
  var valid_615394 = header.getOrDefault("X-Amz-Credential")
  valid_615394 = validateParameter(valid_615394, JString, required = false,
                                 default = nil)
  if valid_615394 != nil:
    section.add "X-Amz-Credential", valid_615394
  var valid_615395 = header.getOrDefault("X-Amz-Security-Token")
  valid_615395 = validateParameter(valid_615395, JString, required = false,
                                 default = nil)
  if valid_615395 != nil:
    section.add "X-Amz-Security-Token", valid_615395
  var valid_615396 = header.getOrDefault("X-Amz-Algorithm")
  valid_615396 = validateParameter(valid_615396, JString, required = false,
                                 default = nil)
  if valid_615396 != nil:
    section.add "X-Amz-Algorithm", valid_615396
  var valid_615397 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615397 = validateParameter(valid_615397, JString, required = false,
                                 default = nil)
  if valid_615397 != nil:
    section.add "X-Amz-SignedHeaders", valid_615397
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_615399: Call_ListAuditFindings_615388; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ## 
  let valid = call_615399.validator(path, query, header, formData, body)
  let scheme = call_615399.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615399.url(scheme.get, call_615399.host, call_615399.base,
                         call_615399.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615399, url, valid)

proc call*(call_615400: Call_ListAuditFindings_615388; body: JsonNode): Recallable =
  ## listAuditFindings
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ##   body: JObject (required)
  var body_615401 = newJObject()
  if body != nil:
    body_615401 = body
  result = call_615400.call(nil, nil, nil, nil, body_615401)

var listAuditFindings* = Call_ListAuditFindings_615388(name: "listAuditFindings",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/audit/findings",
    validator: validate_ListAuditFindings_615389, base: "/",
    url: url_ListAuditFindings_615390, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditMitigationActionsExecutions_615402 = ref object of OpenApiRestCall_612658
proc url_ListAuditMitigationActionsExecutions_615404(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditMitigationActionsExecutions_615403(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the status of audit mitigation action tasks that were executed.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   actionStatus: JString
  ##               : Specify this filter to limit results to those with a specific status.
  ##   taskId: JString (required)
  ##         : Specify this filter to limit results to actions for a specific audit mitigation actions task.
  ##   findingId: JString (required)
  ##            : Specify this filter to limit results to those that were applied to a specific audit finding.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  var valid_615405 = query.getOrDefault("nextToken")
  valid_615405 = validateParameter(valid_615405, JString, required = false,
                                 default = nil)
  if valid_615405 != nil:
    section.add "nextToken", valid_615405
  var valid_615406 = query.getOrDefault("actionStatus")
  valid_615406 = validateParameter(valid_615406, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_615406 != nil:
    section.add "actionStatus", valid_615406
  assert query != nil, "query argument is necessary due to required `taskId` field"
  var valid_615407 = query.getOrDefault("taskId")
  valid_615407 = validateParameter(valid_615407, JString, required = true,
                                 default = nil)
  if valid_615407 != nil:
    section.add "taskId", valid_615407
  var valid_615408 = query.getOrDefault("findingId")
  valid_615408 = validateParameter(valid_615408, JString, required = true,
                                 default = nil)
  if valid_615408 != nil:
    section.add "findingId", valid_615408
  var valid_615409 = query.getOrDefault("maxResults")
  valid_615409 = validateParameter(valid_615409, JInt, required = false, default = nil)
  if valid_615409 != nil:
    section.add "maxResults", valid_615409
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615410 = header.getOrDefault("X-Amz-Signature")
  valid_615410 = validateParameter(valid_615410, JString, required = false,
                                 default = nil)
  if valid_615410 != nil:
    section.add "X-Amz-Signature", valid_615410
  var valid_615411 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615411 = validateParameter(valid_615411, JString, required = false,
                                 default = nil)
  if valid_615411 != nil:
    section.add "X-Amz-Content-Sha256", valid_615411
  var valid_615412 = header.getOrDefault("X-Amz-Date")
  valid_615412 = validateParameter(valid_615412, JString, required = false,
                                 default = nil)
  if valid_615412 != nil:
    section.add "X-Amz-Date", valid_615412
  var valid_615413 = header.getOrDefault("X-Amz-Credential")
  valid_615413 = validateParameter(valid_615413, JString, required = false,
                                 default = nil)
  if valid_615413 != nil:
    section.add "X-Amz-Credential", valid_615413
  var valid_615414 = header.getOrDefault("X-Amz-Security-Token")
  valid_615414 = validateParameter(valid_615414, JString, required = false,
                                 default = nil)
  if valid_615414 != nil:
    section.add "X-Amz-Security-Token", valid_615414
  var valid_615415 = header.getOrDefault("X-Amz-Algorithm")
  valid_615415 = validateParameter(valid_615415, JString, required = false,
                                 default = nil)
  if valid_615415 != nil:
    section.add "X-Amz-Algorithm", valid_615415
  var valid_615416 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615416 = validateParameter(valid_615416, JString, required = false,
                                 default = nil)
  if valid_615416 != nil:
    section.add "X-Amz-SignedHeaders", valid_615416
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615417: Call_ListAuditMitigationActionsExecutions_615402;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the status of audit mitigation action tasks that were executed.
  ## 
  let valid = call_615417.validator(path, query, header, formData, body)
  let scheme = call_615417.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615417.url(scheme.get, call_615417.host, call_615417.base,
                         call_615417.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615417, url, valid)

proc call*(call_615418: Call_ListAuditMitigationActionsExecutions_615402;
          taskId: string; findingId: string; nextToken: string = "";
          actionStatus: string = "IN_PROGRESS"; maxResults: int = 0): Recallable =
  ## listAuditMitigationActionsExecutions
  ## Gets the status of audit mitigation action tasks that were executed.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   actionStatus: string
  ##               : Specify this filter to limit results to those with a specific status.
  ##   taskId: string (required)
  ##         : Specify this filter to limit results to actions for a specific audit mitigation actions task.
  ##   findingId: string (required)
  ##            : Specify this filter to limit results to those that were applied to a specific audit finding.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_615419 = newJObject()
  add(query_615419, "nextToken", newJString(nextToken))
  add(query_615419, "actionStatus", newJString(actionStatus))
  add(query_615419, "taskId", newJString(taskId))
  add(query_615419, "findingId", newJString(findingId))
  add(query_615419, "maxResults", newJInt(maxResults))
  result = call_615418.call(nil, query_615419, nil, nil, nil)

var listAuditMitigationActionsExecutions* = Call_ListAuditMitigationActionsExecutions_615402(
    name: "listAuditMitigationActionsExecutions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/executions#taskId&findingId",
    validator: validate_ListAuditMitigationActionsExecutions_615403, base: "/",
    url: url_ListAuditMitigationActionsExecutions_615404,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditMitigationActionsTasks_615420 = ref object of OpenApiRestCall_612658
proc url_ListAuditMitigationActionsTasks_615422(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditMitigationActionsTasks_615421(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endTime: JString (required)
  ##          : Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : Specify this filter to limit results to tasks that began on or after a specific date and time.
  ##   findingId: JString
  ##            : Specify this filter to limit results to tasks that were applied to a specific audit finding.
  ##   taskStatus: JString
  ##             : Specify this filter to limit results to tasks that are in a specific state.
  ##   auditTaskId: JString
  ##              : Specify this filter to limit results to tasks that were applied to results for a specific audit.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_615423 = query.getOrDefault("endTime")
  valid_615423 = validateParameter(valid_615423, JString, required = true,
                                 default = nil)
  if valid_615423 != nil:
    section.add "endTime", valid_615423
  var valid_615424 = query.getOrDefault("nextToken")
  valid_615424 = validateParameter(valid_615424, JString, required = false,
                                 default = nil)
  if valid_615424 != nil:
    section.add "nextToken", valid_615424
  var valid_615425 = query.getOrDefault("startTime")
  valid_615425 = validateParameter(valid_615425, JString, required = true,
                                 default = nil)
  if valid_615425 != nil:
    section.add "startTime", valid_615425
  var valid_615426 = query.getOrDefault("findingId")
  valid_615426 = validateParameter(valid_615426, JString, required = false,
                                 default = nil)
  if valid_615426 != nil:
    section.add "findingId", valid_615426
  var valid_615427 = query.getOrDefault("taskStatus")
  valid_615427 = validateParameter(valid_615427, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_615427 != nil:
    section.add "taskStatus", valid_615427
  var valid_615428 = query.getOrDefault("auditTaskId")
  valid_615428 = validateParameter(valid_615428, JString, required = false,
                                 default = nil)
  if valid_615428 != nil:
    section.add "auditTaskId", valid_615428
  var valid_615429 = query.getOrDefault("maxResults")
  valid_615429 = validateParameter(valid_615429, JInt, required = false, default = nil)
  if valid_615429 != nil:
    section.add "maxResults", valid_615429
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615430 = header.getOrDefault("X-Amz-Signature")
  valid_615430 = validateParameter(valid_615430, JString, required = false,
                                 default = nil)
  if valid_615430 != nil:
    section.add "X-Amz-Signature", valid_615430
  var valid_615431 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615431 = validateParameter(valid_615431, JString, required = false,
                                 default = nil)
  if valid_615431 != nil:
    section.add "X-Amz-Content-Sha256", valid_615431
  var valid_615432 = header.getOrDefault("X-Amz-Date")
  valid_615432 = validateParameter(valid_615432, JString, required = false,
                                 default = nil)
  if valid_615432 != nil:
    section.add "X-Amz-Date", valid_615432
  var valid_615433 = header.getOrDefault("X-Amz-Credential")
  valid_615433 = validateParameter(valid_615433, JString, required = false,
                                 default = nil)
  if valid_615433 != nil:
    section.add "X-Amz-Credential", valid_615433
  var valid_615434 = header.getOrDefault("X-Amz-Security-Token")
  valid_615434 = validateParameter(valid_615434, JString, required = false,
                                 default = nil)
  if valid_615434 != nil:
    section.add "X-Amz-Security-Token", valid_615434
  var valid_615435 = header.getOrDefault("X-Amz-Algorithm")
  valid_615435 = validateParameter(valid_615435, JString, required = false,
                                 default = nil)
  if valid_615435 != nil:
    section.add "X-Amz-Algorithm", valid_615435
  var valid_615436 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615436 = validateParameter(valid_615436, JString, required = false,
                                 default = nil)
  if valid_615436 != nil:
    section.add "X-Amz-SignedHeaders", valid_615436
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615437: Call_ListAuditMitigationActionsTasks_615420;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ## 
  let valid = call_615437.validator(path, query, header, formData, body)
  let scheme = call_615437.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615437.url(scheme.get, call_615437.host, call_615437.base,
                         call_615437.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615437, url, valid)

proc call*(call_615438: Call_ListAuditMitigationActionsTasks_615420;
          endTime: string; startTime: string; nextToken: string = "";
          findingId: string = ""; taskStatus: string = "IN_PROGRESS";
          auditTaskId: string = ""; maxResults: int = 0): Recallable =
  ## listAuditMitigationActionsTasks
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ##   endTime: string (required)
  ##          : Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : Specify this filter to limit results to tasks that began on or after a specific date and time.
  ##   findingId: string
  ##            : Specify this filter to limit results to tasks that were applied to a specific audit finding.
  ##   taskStatus: string
  ##             : Specify this filter to limit results to tasks that are in a specific state.
  ##   auditTaskId: string
  ##              : Specify this filter to limit results to tasks that were applied to results for a specific audit.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_615439 = newJObject()
  add(query_615439, "endTime", newJString(endTime))
  add(query_615439, "nextToken", newJString(nextToken))
  add(query_615439, "startTime", newJString(startTime))
  add(query_615439, "findingId", newJString(findingId))
  add(query_615439, "taskStatus", newJString(taskStatus))
  add(query_615439, "auditTaskId", newJString(auditTaskId))
  add(query_615439, "maxResults", newJInt(maxResults))
  result = call_615438.call(nil, query_615439, nil, nil, nil)

var listAuditMitigationActionsTasks* = Call_ListAuditMitigationActionsTasks_615420(
    name: "listAuditMitigationActionsTasks", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/tasks#startTime&endTime",
    validator: validate_ListAuditMitigationActionsTasks_615421, base: "/",
    url: url_ListAuditMitigationActionsTasks_615422,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditTasks_615440 = ref object of OpenApiRestCall_612658
proc url_ListAuditTasks_615442(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditTasks_615441(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the Device Defender audits that have been performed during a given time period.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endTime: JString (required)
  ##          : The end of the time period.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
  ##   taskStatus: JString
  ##             : A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
  ##   taskType: JString
  ##           : A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_615443 = query.getOrDefault("endTime")
  valid_615443 = validateParameter(valid_615443, JString, required = true,
                                 default = nil)
  if valid_615443 != nil:
    section.add "endTime", valid_615443
  var valid_615444 = query.getOrDefault("nextToken")
  valid_615444 = validateParameter(valid_615444, JString, required = false,
                                 default = nil)
  if valid_615444 != nil:
    section.add "nextToken", valid_615444
  var valid_615445 = query.getOrDefault("startTime")
  valid_615445 = validateParameter(valid_615445, JString, required = true,
                                 default = nil)
  if valid_615445 != nil:
    section.add "startTime", valid_615445
  var valid_615446 = query.getOrDefault("taskStatus")
  valid_615446 = validateParameter(valid_615446, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_615446 != nil:
    section.add "taskStatus", valid_615446
  var valid_615447 = query.getOrDefault("taskType")
  valid_615447 = validateParameter(valid_615447, JString, required = false,
                                 default = newJString("ON_DEMAND_AUDIT_TASK"))
  if valid_615447 != nil:
    section.add "taskType", valid_615447
  var valid_615448 = query.getOrDefault("maxResults")
  valid_615448 = validateParameter(valid_615448, JInt, required = false, default = nil)
  if valid_615448 != nil:
    section.add "maxResults", valid_615448
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615449 = header.getOrDefault("X-Amz-Signature")
  valid_615449 = validateParameter(valid_615449, JString, required = false,
                                 default = nil)
  if valid_615449 != nil:
    section.add "X-Amz-Signature", valid_615449
  var valid_615450 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615450 = validateParameter(valid_615450, JString, required = false,
                                 default = nil)
  if valid_615450 != nil:
    section.add "X-Amz-Content-Sha256", valid_615450
  var valid_615451 = header.getOrDefault("X-Amz-Date")
  valid_615451 = validateParameter(valid_615451, JString, required = false,
                                 default = nil)
  if valid_615451 != nil:
    section.add "X-Amz-Date", valid_615451
  var valid_615452 = header.getOrDefault("X-Amz-Credential")
  valid_615452 = validateParameter(valid_615452, JString, required = false,
                                 default = nil)
  if valid_615452 != nil:
    section.add "X-Amz-Credential", valid_615452
  var valid_615453 = header.getOrDefault("X-Amz-Security-Token")
  valid_615453 = validateParameter(valid_615453, JString, required = false,
                                 default = nil)
  if valid_615453 != nil:
    section.add "X-Amz-Security-Token", valid_615453
  var valid_615454 = header.getOrDefault("X-Amz-Algorithm")
  valid_615454 = validateParameter(valid_615454, JString, required = false,
                                 default = nil)
  if valid_615454 != nil:
    section.add "X-Amz-Algorithm", valid_615454
  var valid_615455 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615455 = validateParameter(valid_615455, JString, required = false,
                                 default = nil)
  if valid_615455 != nil:
    section.add "X-Amz-SignedHeaders", valid_615455
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615456: Call_ListAuditTasks_615440; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender audits that have been performed during a given time period.
  ## 
  let valid = call_615456.validator(path, query, header, formData, body)
  let scheme = call_615456.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615456.url(scheme.get, call_615456.host, call_615456.base,
                         call_615456.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615456, url, valid)

proc call*(call_615457: Call_ListAuditTasks_615440; endTime: string;
          startTime: string; nextToken: string = "";
          taskStatus: string = "IN_PROGRESS";
          taskType: string = "ON_DEMAND_AUDIT_TASK"; maxResults: int = 0): Recallable =
  ## listAuditTasks
  ## Lists the Device Defender audits that have been performed during a given time period.
  ##   endTime: string (required)
  ##          : The end of the time period.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
  ##   taskStatus: string
  ##             : A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
  ##   taskType: string
  ##           : A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_615458 = newJObject()
  add(query_615458, "endTime", newJString(endTime))
  add(query_615458, "nextToken", newJString(nextToken))
  add(query_615458, "startTime", newJString(startTime))
  add(query_615458, "taskStatus", newJString(taskStatus))
  add(query_615458, "taskType", newJString(taskType))
  add(query_615458, "maxResults", newJInt(maxResults))
  result = call_615457.call(nil, query_615458, nil, nil, nil)

var listAuditTasks* = Call_ListAuditTasks_615440(name: "listAuditTasks",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/audit/tasks#startTime&endTime", validator: validate_ListAuditTasks_615441,
    base: "/", url: url_ListAuditTasks_615442, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuthorizers_615459 = ref object of OpenApiRestCall_612658
proc url_ListAuthorizers_615461(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuthorizers_615460(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Lists the authorizers registered in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Return the list of authorizers in ascending alphabetical order.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   status: JString
  ##         : The status of the list authorizers request.
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  section = newJObject()
  var valid_615462 = query.getOrDefault("isAscendingOrder")
  valid_615462 = validateParameter(valid_615462, JBool, required = false, default = nil)
  if valid_615462 != nil:
    section.add "isAscendingOrder", valid_615462
  var valid_615463 = query.getOrDefault("pageSize")
  valid_615463 = validateParameter(valid_615463, JInt, required = false, default = nil)
  if valid_615463 != nil:
    section.add "pageSize", valid_615463
  var valid_615464 = query.getOrDefault("status")
  valid_615464 = validateParameter(valid_615464, JString, required = false,
                                 default = newJString("ACTIVE"))
  if valid_615464 != nil:
    section.add "status", valid_615464
  var valid_615465 = query.getOrDefault("marker")
  valid_615465 = validateParameter(valid_615465, JString, required = false,
                                 default = nil)
  if valid_615465 != nil:
    section.add "marker", valid_615465
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615466 = header.getOrDefault("X-Amz-Signature")
  valid_615466 = validateParameter(valid_615466, JString, required = false,
                                 default = nil)
  if valid_615466 != nil:
    section.add "X-Amz-Signature", valid_615466
  var valid_615467 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615467 = validateParameter(valid_615467, JString, required = false,
                                 default = nil)
  if valid_615467 != nil:
    section.add "X-Amz-Content-Sha256", valid_615467
  var valid_615468 = header.getOrDefault("X-Amz-Date")
  valid_615468 = validateParameter(valid_615468, JString, required = false,
                                 default = nil)
  if valid_615468 != nil:
    section.add "X-Amz-Date", valid_615468
  var valid_615469 = header.getOrDefault("X-Amz-Credential")
  valid_615469 = validateParameter(valid_615469, JString, required = false,
                                 default = nil)
  if valid_615469 != nil:
    section.add "X-Amz-Credential", valid_615469
  var valid_615470 = header.getOrDefault("X-Amz-Security-Token")
  valid_615470 = validateParameter(valid_615470, JString, required = false,
                                 default = nil)
  if valid_615470 != nil:
    section.add "X-Amz-Security-Token", valid_615470
  var valid_615471 = header.getOrDefault("X-Amz-Algorithm")
  valid_615471 = validateParameter(valid_615471, JString, required = false,
                                 default = nil)
  if valid_615471 != nil:
    section.add "X-Amz-Algorithm", valid_615471
  var valid_615472 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615472 = validateParameter(valid_615472, JString, required = false,
                                 default = nil)
  if valid_615472 != nil:
    section.add "X-Amz-SignedHeaders", valid_615472
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615473: Call_ListAuthorizers_615459; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the authorizers registered in your account.
  ## 
  let valid = call_615473.validator(path, query, header, formData, body)
  let scheme = call_615473.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615473.url(scheme.get, call_615473.host, call_615473.base,
                         call_615473.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615473, url, valid)

proc call*(call_615474: Call_ListAuthorizers_615459;
          isAscendingOrder: bool = false; pageSize: int = 0; status: string = "ACTIVE";
          marker: string = ""): Recallable =
  ## listAuthorizers
  ## Lists the authorizers registered in your account.
  ##   isAscendingOrder: bool
  ##                   : Return the list of authorizers in ascending alphabetical order.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   status: string
  ##         : The status of the list authorizers request.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  var query_615475 = newJObject()
  add(query_615475, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_615475, "pageSize", newJInt(pageSize))
  add(query_615475, "status", newJString(status))
  add(query_615475, "marker", newJString(marker))
  result = call_615474.call(nil, query_615475, nil, nil, nil)

var listAuthorizers* = Call_ListAuthorizers_615459(name: "listAuthorizers",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/authorizers/",
    validator: validate_ListAuthorizers_615460, base: "/", url: url_ListAuthorizers_615461,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListBillingGroups_615476 = ref object of OpenApiRestCall_612658
proc url_ListBillingGroups_615478(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListBillingGroups_615477(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Lists the billing groups you have created.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   namePrefixFilter: JString
  ##                   : Limit the results to billing groups whose names have the given prefix.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_615479 = query.getOrDefault("nextToken")
  valid_615479 = validateParameter(valid_615479, JString, required = false,
                                 default = nil)
  if valid_615479 != nil:
    section.add "nextToken", valid_615479
  var valid_615480 = query.getOrDefault("namePrefixFilter")
  valid_615480 = validateParameter(valid_615480, JString, required = false,
                                 default = nil)
  if valid_615480 != nil:
    section.add "namePrefixFilter", valid_615480
  var valid_615481 = query.getOrDefault("maxResults")
  valid_615481 = validateParameter(valid_615481, JInt, required = false, default = nil)
  if valid_615481 != nil:
    section.add "maxResults", valid_615481
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615482 = header.getOrDefault("X-Amz-Signature")
  valid_615482 = validateParameter(valid_615482, JString, required = false,
                                 default = nil)
  if valid_615482 != nil:
    section.add "X-Amz-Signature", valid_615482
  var valid_615483 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615483 = validateParameter(valid_615483, JString, required = false,
                                 default = nil)
  if valid_615483 != nil:
    section.add "X-Amz-Content-Sha256", valid_615483
  var valid_615484 = header.getOrDefault("X-Amz-Date")
  valid_615484 = validateParameter(valid_615484, JString, required = false,
                                 default = nil)
  if valid_615484 != nil:
    section.add "X-Amz-Date", valid_615484
  var valid_615485 = header.getOrDefault("X-Amz-Credential")
  valid_615485 = validateParameter(valid_615485, JString, required = false,
                                 default = nil)
  if valid_615485 != nil:
    section.add "X-Amz-Credential", valid_615485
  var valid_615486 = header.getOrDefault("X-Amz-Security-Token")
  valid_615486 = validateParameter(valid_615486, JString, required = false,
                                 default = nil)
  if valid_615486 != nil:
    section.add "X-Amz-Security-Token", valid_615486
  var valid_615487 = header.getOrDefault("X-Amz-Algorithm")
  valid_615487 = validateParameter(valid_615487, JString, required = false,
                                 default = nil)
  if valid_615487 != nil:
    section.add "X-Amz-Algorithm", valid_615487
  var valid_615488 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615488 = validateParameter(valid_615488, JString, required = false,
                                 default = nil)
  if valid_615488 != nil:
    section.add "X-Amz-SignedHeaders", valid_615488
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615489: Call_ListBillingGroups_615476; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the billing groups you have created.
  ## 
  let valid = call_615489.validator(path, query, header, formData, body)
  let scheme = call_615489.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615489.url(scheme.get, call_615489.host, call_615489.base,
                         call_615489.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615489, url, valid)

proc call*(call_615490: Call_ListBillingGroups_615476; nextToken: string = "";
          namePrefixFilter: string = ""; maxResults: int = 0): Recallable =
  ## listBillingGroups
  ## Lists the billing groups you have created.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   namePrefixFilter: string
  ##                   : Limit the results to billing groups whose names have the given prefix.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var query_615491 = newJObject()
  add(query_615491, "nextToken", newJString(nextToken))
  add(query_615491, "namePrefixFilter", newJString(namePrefixFilter))
  add(query_615491, "maxResults", newJInt(maxResults))
  result = call_615490.call(nil, query_615491, nil, nil, nil)

var listBillingGroups* = Call_ListBillingGroups_615476(name: "listBillingGroups",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/billing-groups",
    validator: validate_ListBillingGroups_615477, base: "/",
    url: url_ListBillingGroups_615478, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCACertificates_615492 = ref object of OpenApiRestCall_612658
proc url_ListCACertificates_615494(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListCACertificates_615493(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Determines the order of the results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_615495 = query.getOrDefault("isAscendingOrder")
  valid_615495 = validateParameter(valid_615495, JBool, required = false, default = nil)
  if valid_615495 != nil:
    section.add "isAscendingOrder", valid_615495
  var valid_615496 = query.getOrDefault("pageSize")
  valid_615496 = validateParameter(valid_615496, JInt, required = false, default = nil)
  if valid_615496 != nil:
    section.add "pageSize", valid_615496
  var valid_615497 = query.getOrDefault("marker")
  valid_615497 = validateParameter(valid_615497, JString, required = false,
                                 default = nil)
  if valid_615497 != nil:
    section.add "marker", valid_615497
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615498 = header.getOrDefault("X-Amz-Signature")
  valid_615498 = validateParameter(valid_615498, JString, required = false,
                                 default = nil)
  if valid_615498 != nil:
    section.add "X-Amz-Signature", valid_615498
  var valid_615499 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615499 = validateParameter(valid_615499, JString, required = false,
                                 default = nil)
  if valid_615499 != nil:
    section.add "X-Amz-Content-Sha256", valid_615499
  var valid_615500 = header.getOrDefault("X-Amz-Date")
  valid_615500 = validateParameter(valid_615500, JString, required = false,
                                 default = nil)
  if valid_615500 != nil:
    section.add "X-Amz-Date", valid_615500
  var valid_615501 = header.getOrDefault("X-Amz-Credential")
  valid_615501 = validateParameter(valid_615501, JString, required = false,
                                 default = nil)
  if valid_615501 != nil:
    section.add "X-Amz-Credential", valid_615501
  var valid_615502 = header.getOrDefault("X-Amz-Security-Token")
  valid_615502 = validateParameter(valid_615502, JString, required = false,
                                 default = nil)
  if valid_615502 != nil:
    section.add "X-Amz-Security-Token", valid_615502
  var valid_615503 = header.getOrDefault("X-Amz-Algorithm")
  valid_615503 = validateParameter(valid_615503, JString, required = false,
                                 default = nil)
  if valid_615503 != nil:
    section.add "X-Amz-Algorithm", valid_615503
  var valid_615504 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615504 = validateParameter(valid_615504, JString, required = false,
                                 default = nil)
  if valid_615504 != nil:
    section.add "X-Amz-SignedHeaders", valid_615504
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615505: Call_ListCACertificates_615492; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  let valid = call_615505.validator(path, query, header, formData, body)
  let scheme = call_615505.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615505.url(scheme.get, call_615505.host, call_615505.base,
                         call_615505.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615505, url, valid)

proc call*(call_615506: Call_ListCACertificates_615492;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listCACertificates
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ##   isAscendingOrder: bool
  ##                   : Determines the order of the results.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_615507 = newJObject()
  add(query_615507, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_615507, "pageSize", newJInt(pageSize))
  add(query_615507, "marker", newJString(marker))
  result = call_615506.call(nil, query_615507, nil, nil, nil)

var listCACertificates* = Call_ListCACertificates_615492(
    name: "listCACertificates", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/cacertificates", validator: validate_ListCACertificates_615493,
    base: "/", url: url_ListCACertificates_615494,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCertificatesByCA_615508 = ref object of OpenApiRestCall_612658
proc url_ListCertificatesByCA_615510(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates-by-ca/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListCertificatesByCA_615509(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List the device certificates signed by the specified CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_615511 = path.getOrDefault("caCertificateId")
  valid_615511 = validateParameter(valid_615511, JString, required = true,
                                 default = nil)
  if valid_615511 != nil:
    section.add "caCertificateId", valid_615511
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_615512 = query.getOrDefault("isAscendingOrder")
  valid_615512 = validateParameter(valid_615512, JBool, required = false, default = nil)
  if valid_615512 != nil:
    section.add "isAscendingOrder", valid_615512
  var valid_615513 = query.getOrDefault("pageSize")
  valid_615513 = validateParameter(valid_615513, JInt, required = false, default = nil)
  if valid_615513 != nil:
    section.add "pageSize", valid_615513
  var valid_615514 = query.getOrDefault("marker")
  valid_615514 = validateParameter(valid_615514, JString, required = false,
                                 default = nil)
  if valid_615514 != nil:
    section.add "marker", valid_615514
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615515 = header.getOrDefault("X-Amz-Signature")
  valid_615515 = validateParameter(valid_615515, JString, required = false,
                                 default = nil)
  if valid_615515 != nil:
    section.add "X-Amz-Signature", valid_615515
  var valid_615516 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615516 = validateParameter(valid_615516, JString, required = false,
                                 default = nil)
  if valid_615516 != nil:
    section.add "X-Amz-Content-Sha256", valid_615516
  var valid_615517 = header.getOrDefault("X-Amz-Date")
  valid_615517 = validateParameter(valid_615517, JString, required = false,
                                 default = nil)
  if valid_615517 != nil:
    section.add "X-Amz-Date", valid_615517
  var valid_615518 = header.getOrDefault("X-Amz-Credential")
  valid_615518 = validateParameter(valid_615518, JString, required = false,
                                 default = nil)
  if valid_615518 != nil:
    section.add "X-Amz-Credential", valid_615518
  var valid_615519 = header.getOrDefault("X-Amz-Security-Token")
  valid_615519 = validateParameter(valid_615519, JString, required = false,
                                 default = nil)
  if valid_615519 != nil:
    section.add "X-Amz-Security-Token", valid_615519
  var valid_615520 = header.getOrDefault("X-Amz-Algorithm")
  valid_615520 = validateParameter(valid_615520, JString, required = false,
                                 default = nil)
  if valid_615520 != nil:
    section.add "X-Amz-Algorithm", valid_615520
  var valid_615521 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615521 = validateParameter(valid_615521, JString, required = false,
                                 default = nil)
  if valid_615521 != nil:
    section.add "X-Amz-SignedHeaders", valid_615521
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615522: Call_ListCertificatesByCA_615508; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the device certificates signed by the specified CA certificate.
  ## 
  let valid = call_615522.validator(path, query, header, formData, body)
  let scheme = call_615522.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615522.url(scheme.get, call_615522.host, call_615522.base,
                         call_615522.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615522, url, valid)

proc call*(call_615523: Call_ListCertificatesByCA_615508; caCertificateId: string;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listCertificatesByCA
  ## List the device certificates signed by the specified CA certificate.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: int
  ##           : The result page size.
  ##   caCertificateId: string (required)
  ##                  : The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
  ##   marker: string
  ##         : The marker for the next set of results.
  var path_615524 = newJObject()
  var query_615525 = newJObject()
  add(query_615525, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_615525, "pageSize", newJInt(pageSize))
  add(path_615524, "caCertificateId", newJString(caCertificateId))
  add(query_615525, "marker", newJString(marker))
  result = call_615523.call(path_615524, query_615525, nil, nil, nil)

var listCertificatesByCA* = Call_ListCertificatesByCA_615508(
    name: "listCertificatesByCA", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates-by-ca/{caCertificateId}",
    validator: validate_ListCertificatesByCA_615509, base: "/",
    url: url_ListCertificatesByCA_615510, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListDomainConfigurations_615526 = ref object of OpenApiRestCall_612658
proc url_ListDomainConfigurations_615528(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListDomainConfigurations_615527(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   pageSize: JInt
  ##           : The result page size.
  ##   serviceType: JString
  ##              : The type of service delivered by the endpoint.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_615529 = query.getOrDefault("pageSize")
  valid_615529 = validateParameter(valid_615529, JInt, required = false, default = nil)
  if valid_615529 != nil:
    section.add "pageSize", valid_615529
  var valid_615530 = query.getOrDefault("serviceType")
  valid_615530 = validateParameter(valid_615530, JString, required = false,
                                 default = newJString("DATA"))
  if valid_615530 != nil:
    section.add "serviceType", valid_615530
  var valid_615531 = query.getOrDefault("marker")
  valid_615531 = validateParameter(valid_615531, JString, required = false,
                                 default = nil)
  if valid_615531 != nil:
    section.add "marker", valid_615531
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615532 = header.getOrDefault("X-Amz-Signature")
  valid_615532 = validateParameter(valid_615532, JString, required = false,
                                 default = nil)
  if valid_615532 != nil:
    section.add "X-Amz-Signature", valid_615532
  var valid_615533 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615533 = validateParameter(valid_615533, JString, required = false,
                                 default = nil)
  if valid_615533 != nil:
    section.add "X-Amz-Content-Sha256", valid_615533
  var valid_615534 = header.getOrDefault("X-Amz-Date")
  valid_615534 = validateParameter(valid_615534, JString, required = false,
                                 default = nil)
  if valid_615534 != nil:
    section.add "X-Amz-Date", valid_615534
  var valid_615535 = header.getOrDefault("X-Amz-Credential")
  valid_615535 = validateParameter(valid_615535, JString, required = false,
                                 default = nil)
  if valid_615535 != nil:
    section.add "X-Amz-Credential", valid_615535
  var valid_615536 = header.getOrDefault("X-Amz-Security-Token")
  valid_615536 = validateParameter(valid_615536, JString, required = false,
                                 default = nil)
  if valid_615536 != nil:
    section.add "X-Amz-Security-Token", valid_615536
  var valid_615537 = header.getOrDefault("X-Amz-Algorithm")
  valid_615537 = validateParameter(valid_615537, JString, required = false,
                                 default = nil)
  if valid_615537 != nil:
    section.add "X-Amz-Algorithm", valid_615537
  var valid_615538 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615538 = validateParameter(valid_615538, JString, required = false,
                                 default = nil)
  if valid_615538 != nil:
    section.add "X-Amz-SignedHeaders", valid_615538
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615539: Call_ListDomainConfigurations_615526; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_615539.validator(path, query, header, formData, body)
  let scheme = call_615539.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615539.url(scheme.get, call_615539.host, call_615539.base,
                         call_615539.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615539, url, valid)

proc call*(call_615540: Call_ListDomainConfigurations_615526; pageSize: int = 0;
          serviceType: string = "DATA"; marker: string = ""): Recallable =
  ## listDomainConfigurations
  ## <p>Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   pageSize: int
  ##           : The result page size.
  ##   serviceType: string
  ##              : The type of service delivered by the endpoint.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_615541 = newJObject()
  add(query_615541, "pageSize", newJInt(pageSize))
  add(query_615541, "serviceType", newJString(serviceType))
  add(query_615541, "marker", newJString(marker))
  result = call_615540.call(nil, query_615541, nil, nil, nil)

var listDomainConfigurations* = Call_ListDomainConfigurations_615526(
    name: "listDomainConfigurations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/domainConfigurations",
    validator: validate_ListDomainConfigurations_615527, base: "/",
    url: url_ListDomainConfigurations_615528, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListIndices_615542 = ref object of OpenApiRestCall_612658
proc url_ListIndices_615544(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListIndices_615543(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the search indices.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token used to get the next set of results, or <code>null</code> if there are no additional results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_615545 = query.getOrDefault("nextToken")
  valid_615545 = validateParameter(valid_615545, JString, required = false,
                                 default = nil)
  if valid_615545 != nil:
    section.add "nextToken", valid_615545
  var valid_615546 = query.getOrDefault("maxResults")
  valid_615546 = validateParameter(valid_615546, JInt, required = false, default = nil)
  if valid_615546 != nil:
    section.add "maxResults", valid_615546
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615547 = header.getOrDefault("X-Amz-Signature")
  valid_615547 = validateParameter(valid_615547, JString, required = false,
                                 default = nil)
  if valid_615547 != nil:
    section.add "X-Amz-Signature", valid_615547
  var valid_615548 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615548 = validateParameter(valid_615548, JString, required = false,
                                 default = nil)
  if valid_615548 != nil:
    section.add "X-Amz-Content-Sha256", valid_615548
  var valid_615549 = header.getOrDefault("X-Amz-Date")
  valid_615549 = validateParameter(valid_615549, JString, required = false,
                                 default = nil)
  if valid_615549 != nil:
    section.add "X-Amz-Date", valid_615549
  var valid_615550 = header.getOrDefault("X-Amz-Credential")
  valid_615550 = validateParameter(valid_615550, JString, required = false,
                                 default = nil)
  if valid_615550 != nil:
    section.add "X-Amz-Credential", valid_615550
  var valid_615551 = header.getOrDefault("X-Amz-Security-Token")
  valid_615551 = validateParameter(valid_615551, JString, required = false,
                                 default = nil)
  if valid_615551 != nil:
    section.add "X-Amz-Security-Token", valid_615551
  var valid_615552 = header.getOrDefault("X-Amz-Algorithm")
  valid_615552 = validateParameter(valid_615552, JString, required = false,
                                 default = nil)
  if valid_615552 != nil:
    section.add "X-Amz-Algorithm", valid_615552
  var valid_615553 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615553 = validateParameter(valid_615553, JString, required = false,
                                 default = nil)
  if valid_615553 != nil:
    section.add "X-Amz-SignedHeaders", valid_615553
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615554: Call_ListIndices_615542; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the search indices.
  ## 
  let valid = call_615554.validator(path, query, header, formData, body)
  let scheme = call_615554.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615554.url(scheme.get, call_615554.host, call_615554.base,
                         call_615554.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615554, url, valid)

proc call*(call_615555: Call_ListIndices_615542; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listIndices
  ## Lists the search indices.
  ##   nextToken: string
  ##            : The token used to get the next set of results, or <code>null</code> if there are no additional results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_615556 = newJObject()
  add(query_615556, "nextToken", newJString(nextToken))
  add(query_615556, "maxResults", newJInt(maxResults))
  result = call_615555.call(nil, query_615556, nil, nil, nil)

var listIndices* = Call_ListIndices_615542(name: "listIndices",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/indices",
                                        validator: validate_ListIndices_615543,
                                        base: "/", url: url_ListIndices_615544,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobExecutionsForJob_615557 = ref object of OpenApiRestCall_612658
proc url_ListJobExecutionsForJob_615559(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListJobExecutionsForJob_615558(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the job executions for a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_615560 = path.getOrDefault("jobId")
  valid_615560 = validateParameter(valid_615560, JString, required = true,
                                 default = nil)
  if valid_615560 != nil:
    section.add "jobId", valid_615560
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : The status of the job.
  ##   maxResults: JInt
  ##             : The maximum number of results to be returned per request.
  section = newJObject()
  var valid_615561 = query.getOrDefault("nextToken")
  valid_615561 = validateParameter(valid_615561, JString, required = false,
                                 default = nil)
  if valid_615561 != nil:
    section.add "nextToken", valid_615561
  var valid_615562 = query.getOrDefault("status")
  valid_615562 = validateParameter(valid_615562, JString, required = false,
                                 default = newJString("QUEUED"))
  if valid_615562 != nil:
    section.add "status", valid_615562
  var valid_615563 = query.getOrDefault("maxResults")
  valid_615563 = validateParameter(valid_615563, JInt, required = false, default = nil)
  if valid_615563 != nil:
    section.add "maxResults", valid_615563
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615564 = header.getOrDefault("X-Amz-Signature")
  valid_615564 = validateParameter(valid_615564, JString, required = false,
                                 default = nil)
  if valid_615564 != nil:
    section.add "X-Amz-Signature", valid_615564
  var valid_615565 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615565 = validateParameter(valid_615565, JString, required = false,
                                 default = nil)
  if valid_615565 != nil:
    section.add "X-Amz-Content-Sha256", valid_615565
  var valid_615566 = header.getOrDefault("X-Amz-Date")
  valid_615566 = validateParameter(valid_615566, JString, required = false,
                                 default = nil)
  if valid_615566 != nil:
    section.add "X-Amz-Date", valid_615566
  var valid_615567 = header.getOrDefault("X-Amz-Credential")
  valid_615567 = validateParameter(valid_615567, JString, required = false,
                                 default = nil)
  if valid_615567 != nil:
    section.add "X-Amz-Credential", valid_615567
  var valid_615568 = header.getOrDefault("X-Amz-Security-Token")
  valid_615568 = validateParameter(valid_615568, JString, required = false,
                                 default = nil)
  if valid_615568 != nil:
    section.add "X-Amz-Security-Token", valid_615568
  var valid_615569 = header.getOrDefault("X-Amz-Algorithm")
  valid_615569 = validateParameter(valid_615569, JString, required = false,
                                 default = nil)
  if valid_615569 != nil:
    section.add "X-Amz-Algorithm", valid_615569
  var valid_615570 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615570 = validateParameter(valid_615570, JString, required = false,
                                 default = nil)
  if valid_615570 != nil:
    section.add "X-Amz-SignedHeaders", valid_615570
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615571: Call_ListJobExecutionsForJob_615557; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the job executions for a job.
  ## 
  let valid = call_615571.validator(path, query, header, formData, body)
  let scheme = call_615571.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615571.url(scheme.get, call_615571.host, call_615571.base,
                         call_615571.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615571, url, valid)

proc call*(call_615572: Call_ListJobExecutionsForJob_615557; jobId: string;
          nextToken: string = ""; status: string = "QUEUED"; maxResults: int = 0): Recallable =
  ## listJobExecutionsForJob
  ## Lists the job executions for a job.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   status: string
  ##         : The status of the job.
  ##   maxResults: int
  ##             : The maximum number of results to be returned per request.
  var path_615573 = newJObject()
  var query_615574 = newJObject()
  add(query_615574, "nextToken", newJString(nextToken))
  add(path_615573, "jobId", newJString(jobId))
  add(query_615574, "status", newJString(status))
  add(query_615574, "maxResults", newJInt(maxResults))
  result = call_615572.call(path_615573, query_615574, nil, nil, nil)

var listJobExecutionsForJob* = Call_ListJobExecutionsForJob_615557(
    name: "listJobExecutionsForJob", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/jobs/{jobId}/things",
    validator: validate_ListJobExecutionsForJob_615558, base: "/",
    url: url_ListJobExecutionsForJob_615559, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobExecutionsForThing_615575 = ref object of OpenApiRestCall_612658
proc url_ListJobExecutionsForThing_615577(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListJobExecutionsForThing_615576(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the job executions for the specified thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The thing name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_615578 = path.getOrDefault("thingName")
  valid_615578 = validateParameter(valid_615578, JString, required = true,
                                 default = nil)
  if valid_615578 != nil:
    section.add "thingName", valid_615578
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: JInt
  ##             : The maximum number of results to be returned per request.
  section = newJObject()
  var valid_615579 = query.getOrDefault("nextToken")
  valid_615579 = validateParameter(valid_615579, JString, required = false,
                                 default = nil)
  if valid_615579 != nil:
    section.add "nextToken", valid_615579
  var valid_615580 = query.getOrDefault("status")
  valid_615580 = validateParameter(valid_615580, JString, required = false,
                                 default = newJString("QUEUED"))
  if valid_615580 != nil:
    section.add "status", valid_615580
  var valid_615581 = query.getOrDefault("maxResults")
  valid_615581 = validateParameter(valid_615581, JInt, required = false, default = nil)
  if valid_615581 != nil:
    section.add "maxResults", valid_615581
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615582 = header.getOrDefault("X-Amz-Signature")
  valid_615582 = validateParameter(valid_615582, JString, required = false,
                                 default = nil)
  if valid_615582 != nil:
    section.add "X-Amz-Signature", valid_615582
  var valid_615583 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615583 = validateParameter(valid_615583, JString, required = false,
                                 default = nil)
  if valid_615583 != nil:
    section.add "X-Amz-Content-Sha256", valid_615583
  var valid_615584 = header.getOrDefault("X-Amz-Date")
  valid_615584 = validateParameter(valid_615584, JString, required = false,
                                 default = nil)
  if valid_615584 != nil:
    section.add "X-Amz-Date", valid_615584
  var valid_615585 = header.getOrDefault("X-Amz-Credential")
  valid_615585 = validateParameter(valid_615585, JString, required = false,
                                 default = nil)
  if valid_615585 != nil:
    section.add "X-Amz-Credential", valid_615585
  var valid_615586 = header.getOrDefault("X-Amz-Security-Token")
  valid_615586 = validateParameter(valid_615586, JString, required = false,
                                 default = nil)
  if valid_615586 != nil:
    section.add "X-Amz-Security-Token", valid_615586
  var valid_615587 = header.getOrDefault("X-Amz-Algorithm")
  valid_615587 = validateParameter(valid_615587, JString, required = false,
                                 default = nil)
  if valid_615587 != nil:
    section.add "X-Amz-Algorithm", valid_615587
  var valid_615588 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615588 = validateParameter(valid_615588, JString, required = false,
                                 default = nil)
  if valid_615588 != nil:
    section.add "X-Amz-SignedHeaders", valid_615588
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615589: Call_ListJobExecutionsForThing_615575; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the job executions for the specified thing.
  ## 
  let valid = call_615589.validator(path, query, header, formData, body)
  let scheme = call_615589.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615589.url(scheme.get, call_615589.host, call_615589.base,
                         call_615589.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615589, url, valid)

proc call*(call_615590: Call_ListJobExecutionsForThing_615575; thingName: string;
          nextToken: string = ""; status: string = "QUEUED"; maxResults: int = 0): Recallable =
  ## listJobExecutionsForThing
  ## Lists the job executions for the specified thing.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingName: string (required)
  ##            : The thing name.
  ##   status: string
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: int
  ##             : The maximum number of results to be returned per request.
  var path_615591 = newJObject()
  var query_615592 = newJObject()
  add(query_615592, "nextToken", newJString(nextToken))
  add(path_615591, "thingName", newJString(thingName))
  add(query_615592, "status", newJString(status))
  add(query_615592, "maxResults", newJInt(maxResults))
  result = call_615590.call(path_615591, query_615592, nil, nil, nil)

var listJobExecutionsForThing* = Call_ListJobExecutionsForThing_615575(
    name: "listJobExecutionsForThing", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs",
    validator: validate_ListJobExecutionsForThing_615576, base: "/",
    url: url_ListJobExecutionsForThing_615577,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobs_615593 = ref object of OpenApiRestCall_612658
proc url_ListJobs_615595(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListJobs_615594(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists jobs.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: JString
  ##                 : A filter that limits the returned jobs to those for the specified group.
  ##   targetSelection: JString
  ##                  : Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. 
  ##   thingGroupId: JString
  ##               : A filter that limits the returned jobs to those for the specified group.
  ##   status: JString
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_615596 = query.getOrDefault("nextToken")
  valid_615596 = validateParameter(valid_615596, JString, required = false,
                                 default = nil)
  if valid_615596 != nil:
    section.add "nextToken", valid_615596
  var valid_615597 = query.getOrDefault("thingGroupName")
  valid_615597 = validateParameter(valid_615597, JString, required = false,
                                 default = nil)
  if valid_615597 != nil:
    section.add "thingGroupName", valid_615597
  var valid_615598 = query.getOrDefault("targetSelection")
  valid_615598 = validateParameter(valid_615598, JString, required = false,
                                 default = newJString("CONTINUOUS"))
  if valid_615598 != nil:
    section.add "targetSelection", valid_615598
  var valid_615599 = query.getOrDefault("thingGroupId")
  valid_615599 = validateParameter(valid_615599, JString, required = false,
                                 default = nil)
  if valid_615599 != nil:
    section.add "thingGroupId", valid_615599
  var valid_615600 = query.getOrDefault("status")
  valid_615600 = validateParameter(valid_615600, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_615600 != nil:
    section.add "status", valid_615600
  var valid_615601 = query.getOrDefault("maxResults")
  valid_615601 = validateParameter(valid_615601, JInt, required = false, default = nil)
  if valid_615601 != nil:
    section.add "maxResults", valid_615601
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615602 = header.getOrDefault("X-Amz-Signature")
  valid_615602 = validateParameter(valid_615602, JString, required = false,
                                 default = nil)
  if valid_615602 != nil:
    section.add "X-Amz-Signature", valid_615602
  var valid_615603 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615603 = validateParameter(valid_615603, JString, required = false,
                                 default = nil)
  if valid_615603 != nil:
    section.add "X-Amz-Content-Sha256", valid_615603
  var valid_615604 = header.getOrDefault("X-Amz-Date")
  valid_615604 = validateParameter(valid_615604, JString, required = false,
                                 default = nil)
  if valid_615604 != nil:
    section.add "X-Amz-Date", valid_615604
  var valid_615605 = header.getOrDefault("X-Amz-Credential")
  valid_615605 = validateParameter(valid_615605, JString, required = false,
                                 default = nil)
  if valid_615605 != nil:
    section.add "X-Amz-Credential", valid_615605
  var valid_615606 = header.getOrDefault("X-Amz-Security-Token")
  valid_615606 = validateParameter(valid_615606, JString, required = false,
                                 default = nil)
  if valid_615606 != nil:
    section.add "X-Amz-Security-Token", valid_615606
  var valid_615607 = header.getOrDefault("X-Amz-Algorithm")
  valid_615607 = validateParameter(valid_615607, JString, required = false,
                                 default = nil)
  if valid_615607 != nil:
    section.add "X-Amz-Algorithm", valid_615607
  var valid_615608 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615608 = validateParameter(valid_615608, JString, required = false,
                                 default = nil)
  if valid_615608 != nil:
    section.add "X-Amz-SignedHeaders", valid_615608
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615609: Call_ListJobs_615593; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists jobs.
  ## 
  let valid = call_615609.validator(path, query, header, formData, body)
  let scheme = call_615609.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615609.url(scheme.get, call_615609.host, call_615609.base,
                         call_615609.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615609, url, valid)

proc call*(call_615610: Call_ListJobs_615593; nextToken: string = "";
          thingGroupName: string = ""; targetSelection: string = "CONTINUOUS";
          thingGroupId: string = ""; status: string = "IN_PROGRESS"; maxResults: int = 0): Recallable =
  ## listJobs
  ## Lists jobs.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: string
  ##                 : A filter that limits the returned jobs to those for the specified group.
  ##   targetSelection: string
  ##                  : Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. 
  ##   thingGroupId: string
  ##               : A filter that limits the returned jobs to those for the specified group.
  ##   status: string
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var query_615611 = newJObject()
  add(query_615611, "nextToken", newJString(nextToken))
  add(query_615611, "thingGroupName", newJString(thingGroupName))
  add(query_615611, "targetSelection", newJString(targetSelection))
  add(query_615611, "thingGroupId", newJString(thingGroupId))
  add(query_615611, "status", newJString(status))
  add(query_615611, "maxResults", newJInt(maxResults))
  result = call_615610.call(nil, query_615611, nil, nil, nil)

var listJobs* = Call_ListJobs_615593(name: "listJobs", meth: HttpMethod.HttpGet,
                                  host: "iot.amazonaws.com", route: "/jobs",
                                  validator: validate_ListJobs_615594, base: "/",
                                  url: url_ListJobs_615595,
                                  schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListMitigationActions_615612 = ref object of OpenApiRestCall_612658
proc url_ListMitigationActions_615614(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListMitigationActions_615613(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   actionType: JString
  ##             : Specify a value to limit the result to mitigation actions with a specific action type.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  var valid_615615 = query.getOrDefault("nextToken")
  valid_615615 = validateParameter(valid_615615, JString, required = false,
                                 default = nil)
  if valid_615615 != nil:
    section.add "nextToken", valid_615615
  var valid_615616 = query.getOrDefault("actionType")
  valid_615616 = validateParameter(valid_615616, JString, required = false, default = newJString(
      "UPDATE_DEVICE_CERTIFICATE"))
  if valid_615616 != nil:
    section.add "actionType", valid_615616
  var valid_615617 = query.getOrDefault("maxResults")
  valid_615617 = validateParameter(valid_615617, JInt, required = false, default = nil)
  if valid_615617 != nil:
    section.add "maxResults", valid_615617
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615618 = header.getOrDefault("X-Amz-Signature")
  valid_615618 = validateParameter(valid_615618, JString, required = false,
                                 default = nil)
  if valid_615618 != nil:
    section.add "X-Amz-Signature", valid_615618
  var valid_615619 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615619 = validateParameter(valid_615619, JString, required = false,
                                 default = nil)
  if valid_615619 != nil:
    section.add "X-Amz-Content-Sha256", valid_615619
  var valid_615620 = header.getOrDefault("X-Amz-Date")
  valid_615620 = validateParameter(valid_615620, JString, required = false,
                                 default = nil)
  if valid_615620 != nil:
    section.add "X-Amz-Date", valid_615620
  var valid_615621 = header.getOrDefault("X-Amz-Credential")
  valid_615621 = validateParameter(valid_615621, JString, required = false,
                                 default = nil)
  if valid_615621 != nil:
    section.add "X-Amz-Credential", valid_615621
  var valid_615622 = header.getOrDefault("X-Amz-Security-Token")
  valid_615622 = validateParameter(valid_615622, JString, required = false,
                                 default = nil)
  if valid_615622 != nil:
    section.add "X-Amz-Security-Token", valid_615622
  var valid_615623 = header.getOrDefault("X-Amz-Algorithm")
  valid_615623 = validateParameter(valid_615623, JString, required = false,
                                 default = nil)
  if valid_615623 != nil:
    section.add "X-Amz-Algorithm", valid_615623
  var valid_615624 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615624 = validateParameter(valid_615624, JString, required = false,
                                 default = nil)
  if valid_615624 != nil:
    section.add "X-Amz-SignedHeaders", valid_615624
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615625: Call_ListMitigationActions_615612; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ## 
  let valid = call_615625.validator(path, query, header, formData, body)
  let scheme = call_615625.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615625.url(scheme.get, call_615625.host, call_615625.base,
                         call_615625.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615625, url, valid)

proc call*(call_615626: Call_ListMitigationActions_615612; nextToken: string = "";
          actionType: string = "UPDATE_DEVICE_CERTIFICATE"; maxResults: int = 0): Recallable =
  ## listMitigationActions
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   actionType: string
  ##             : Specify a value to limit the result to mitigation actions with a specific action type.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_615627 = newJObject()
  add(query_615627, "nextToken", newJString(nextToken))
  add(query_615627, "actionType", newJString(actionType))
  add(query_615627, "maxResults", newJInt(maxResults))
  result = call_615626.call(nil, query_615627, nil, nil, nil)

var listMitigationActions* = Call_ListMitigationActions_615612(
    name: "listMitigationActions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions",
    validator: validate_ListMitigationActions_615613, base: "/",
    url: url_ListMitigationActions_615614, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListOTAUpdates_615628 = ref object of OpenApiRestCall_612658
proc url_ListOTAUpdates_615630(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListOTAUpdates_615629(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists OTA updates.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token used to retrieve the next set of results.
  ##   otaUpdateStatus: JString
  ##                  : The OTA update job status.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_615631 = query.getOrDefault("nextToken")
  valid_615631 = validateParameter(valid_615631, JString, required = false,
                                 default = nil)
  if valid_615631 != nil:
    section.add "nextToken", valid_615631
  var valid_615632 = query.getOrDefault("otaUpdateStatus")
  valid_615632 = validateParameter(valid_615632, JString, required = false,
                                 default = newJString("CREATE_PENDING"))
  if valid_615632 != nil:
    section.add "otaUpdateStatus", valid_615632
  var valid_615633 = query.getOrDefault("maxResults")
  valid_615633 = validateParameter(valid_615633, JInt, required = false, default = nil)
  if valid_615633 != nil:
    section.add "maxResults", valid_615633
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615634 = header.getOrDefault("X-Amz-Signature")
  valid_615634 = validateParameter(valid_615634, JString, required = false,
                                 default = nil)
  if valid_615634 != nil:
    section.add "X-Amz-Signature", valid_615634
  var valid_615635 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615635 = validateParameter(valid_615635, JString, required = false,
                                 default = nil)
  if valid_615635 != nil:
    section.add "X-Amz-Content-Sha256", valid_615635
  var valid_615636 = header.getOrDefault("X-Amz-Date")
  valid_615636 = validateParameter(valid_615636, JString, required = false,
                                 default = nil)
  if valid_615636 != nil:
    section.add "X-Amz-Date", valid_615636
  var valid_615637 = header.getOrDefault("X-Amz-Credential")
  valid_615637 = validateParameter(valid_615637, JString, required = false,
                                 default = nil)
  if valid_615637 != nil:
    section.add "X-Amz-Credential", valid_615637
  var valid_615638 = header.getOrDefault("X-Amz-Security-Token")
  valid_615638 = validateParameter(valid_615638, JString, required = false,
                                 default = nil)
  if valid_615638 != nil:
    section.add "X-Amz-Security-Token", valid_615638
  var valid_615639 = header.getOrDefault("X-Amz-Algorithm")
  valid_615639 = validateParameter(valid_615639, JString, required = false,
                                 default = nil)
  if valid_615639 != nil:
    section.add "X-Amz-Algorithm", valid_615639
  var valid_615640 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615640 = validateParameter(valid_615640, JString, required = false,
                                 default = nil)
  if valid_615640 != nil:
    section.add "X-Amz-SignedHeaders", valid_615640
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615641: Call_ListOTAUpdates_615628; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists OTA updates.
  ## 
  let valid = call_615641.validator(path, query, header, formData, body)
  let scheme = call_615641.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615641.url(scheme.get, call_615641.host, call_615641.base,
                         call_615641.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615641, url, valid)

proc call*(call_615642: Call_ListOTAUpdates_615628; nextToken: string = "";
          otaUpdateStatus: string = "CREATE_PENDING"; maxResults: int = 0): Recallable =
  ## listOTAUpdates
  ## Lists OTA updates.
  ##   nextToken: string
  ##            : A token used to retrieve the next set of results.
  ##   otaUpdateStatus: string
  ##                  : The OTA update job status.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_615643 = newJObject()
  add(query_615643, "nextToken", newJString(nextToken))
  add(query_615643, "otaUpdateStatus", newJString(otaUpdateStatus))
  add(query_615643, "maxResults", newJInt(maxResults))
  result = call_615642.call(nil, query_615643, nil, nil, nil)

var listOTAUpdates* = Call_ListOTAUpdates_615628(name: "listOTAUpdates",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/otaUpdates",
    validator: validate_ListOTAUpdates_615629, base: "/", url: url_ListOTAUpdates_615630,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListOutgoingCertificates_615644 = ref object of OpenApiRestCall_612658
proc url_ListOutgoingCertificates_615646(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListOutgoingCertificates_615645(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists certificates that are being transferred but not yet accepted.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_615647 = query.getOrDefault("isAscendingOrder")
  valid_615647 = validateParameter(valid_615647, JBool, required = false, default = nil)
  if valid_615647 != nil:
    section.add "isAscendingOrder", valid_615647
  var valid_615648 = query.getOrDefault("pageSize")
  valid_615648 = validateParameter(valid_615648, JInt, required = false, default = nil)
  if valid_615648 != nil:
    section.add "pageSize", valid_615648
  var valid_615649 = query.getOrDefault("marker")
  valid_615649 = validateParameter(valid_615649, JString, required = false,
                                 default = nil)
  if valid_615649 != nil:
    section.add "marker", valid_615649
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615650 = header.getOrDefault("X-Amz-Signature")
  valid_615650 = validateParameter(valid_615650, JString, required = false,
                                 default = nil)
  if valid_615650 != nil:
    section.add "X-Amz-Signature", valid_615650
  var valid_615651 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615651 = validateParameter(valid_615651, JString, required = false,
                                 default = nil)
  if valid_615651 != nil:
    section.add "X-Amz-Content-Sha256", valid_615651
  var valid_615652 = header.getOrDefault("X-Amz-Date")
  valid_615652 = validateParameter(valid_615652, JString, required = false,
                                 default = nil)
  if valid_615652 != nil:
    section.add "X-Amz-Date", valid_615652
  var valid_615653 = header.getOrDefault("X-Amz-Credential")
  valid_615653 = validateParameter(valid_615653, JString, required = false,
                                 default = nil)
  if valid_615653 != nil:
    section.add "X-Amz-Credential", valid_615653
  var valid_615654 = header.getOrDefault("X-Amz-Security-Token")
  valid_615654 = validateParameter(valid_615654, JString, required = false,
                                 default = nil)
  if valid_615654 != nil:
    section.add "X-Amz-Security-Token", valid_615654
  var valid_615655 = header.getOrDefault("X-Amz-Algorithm")
  valid_615655 = validateParameter(valid_615655, JString, required = false,
                                 default = nil)
  if valid_615655 != nil:
    section.add "X-Amz-Algorithm", valid_615655
  var valid_615656 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615656 = validateParameter(valid_615656, JString, required = false,
                                 default = nil)
  if valid_615656 != nil:
    section.add "X-Amz-SignedHeaders", valid_615656
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615657: Call_ListOutgoingCertificates_615644; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists certificates that are being transferred but not yet accepted.
  ## 
  let valid = call_615657.validator(path, query, header, formData, body)
  let scheme = call_615657.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615657.url(scheme.get, call_615657.host, call_615657.base,
                         call_615657.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615657, url, valid)

proc call*(call_615658: Call_ListOutgoingCertificates_615644;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listOutgoingCertificates
  ## Lists certificates that are being transferred but not yet accepted.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_615659 = newJObject()
  add(query_615659, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_615659, "pageSize", newJInt(pageSize))
  add(query_615659, "marker", newJString(marker))
  result = call_615658.call(nil, query_615659, nil, nil, nil)

var listOutgoingCertificates* = Call_ListOutgoingCertificates_615644(
    name: "listOutgoingCertificates", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates-out-going",
    validator: validate_ListOutgoingCertificates_615645, base: "/",
    url: url_ListOutgoingCertificates_615646, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicies_615660 = ref object of OpenApiRestCall_612658
proc url_ListPolicies_615662(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPolicies_615661(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists your policies.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_615663 = query.getOrDefault("isAscendingOrder")
  valid_615663 = validateParameter(valid_615663, JBool, required = false, default = nil)
  if valid_615663 != nil:
    section.add "isAscendingOrder", valid_615663
  var valid_615664 = query.getOrDefault("pageSize")
  valid_615664 = validateParameter(valid_615664, JInt, required = false, default = nil)
  if valid_615664 != nil:
    section.add "pageSize", valid_615664
  var valid_615665 = query.getOrDefault("marker")
  valid_615665 = validateParameter(valid_615665, JString, required = false,
                                 default = nil)
  if valid_615665 != nil:
    section.add "marker", valid_615665
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615666 = header.getOrDefault("X-Amz-Signature")
  valid_615666 = validateParameter(valid_615666, JString, required = false,
                                 default = nil)
  if valid_615666 != nil:
    section.add "X-Amz-Signature", valid_615666
  var valid_615667 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615667 = validateParameter(valid_615667, JString, required = false,
                                 default = nil)
  if valid_615667 != nil:
    section.add "X-Amz-Content-Sha256", valid_615667
  var valid_615668 = header.getOrDefault("X-Amz-Date")
  valid_615668 = validateParameter(valid_615668, JString, required = false,
                                 default = nil)
  if valid_615668 != nil:
    section.add "X-Amz-Date", valid_615668
  var valid_615669 = header.getOrDefault("X-Amz-Credential")
  valid_615669 = validateParameter(valid_615669, JString, required = false,
                                 default = nil)
  if valid_615669 != nil:
    section.add "X-Amz-Credential", valid_615669
  var valid_615670 = header.getOrDefault("X-Amz-Security-Token")
  valid_615670 = validateParameter(valid_615670, JString, required = false,
                                 default = nil)
  if valid_615670 != nil:
    section.add "X-Amz-Security-Token", valid_615670
  var valid_615671 = header.getOrDefault("X-Amz-Algorithm")
  valid_615671 = validateParameter(valid_615671, JString, required = false,
                                 default = nil)
  if valid_615671 != nil:
    section.add "X-Amz-Algorithm", valid_615671
  var valid_615672 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615672 = validateParameter(valid_615672, JString, required = false,
                                 default = nil)
  if valid_615672 != nil:
    section.add "X-Amz-SignedHeaders", valid_615672
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615673: Call_ListPolicies_615660; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists your policies.
  ## 
  let valid = call_615673.validator(path, query, header, formData, body)
  let scheme = call_615673.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615673.url(scheme.get, call_615673.host, call_615673.base,
                         call_615673.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615673, url, valid)

proc call*(call_615674: Call_ListPolicies_615660; isAscendingOrder: bool = false;
          pageSize: int = 0; marker: string = ""): Recallable =
  ## listPolicies
  ## Lists your policies.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_615675 = newJObject()
  add(query_615675, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_615675, "pageSize", newJInt(pageSize))
  add(query_615675, "marker", newJString(marker))
  result = call_615674.call(nil, query_615675, nil, nil, nil)

var listPolicies* = Call_ListPolicies_615660(name: "listPolicies",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/policies",
    validator: validate_ListPolicies_615661, base: "/", url: url_ListPolicies_615662,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicyPrincipals_615676 = ref object of OpenApiRestCall_612658
proc url_ListPolicyPrincipals_615678(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPolicyPrincipals_615677(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_615679 = query.getOrDefault("isAscendingOrder")
  valid_615679 = validateParameter(valid_615679, JBool, required = false, default = nil)
  if valid_615679 != nil:
    section.add "isAscendingOrder", valid_615679
  var valid_615680 = query.getOrDefault("pageSize")
  valid_615680 = validateParameter(valid_615680, JInt, required = false, default = nil)
  if valid_615680 != nil:
    section.add "pageSize", valid_615680
  var valid_615681 = query.getOrDefault("marker")
  valid_615681 = validateParameter(valid_615681, JString, required = false,
                                 default = nil)
  if valid_615681 != nil:
    section.add "marker", valid_615681
  result.add "query", section
  ## parameters in `header` object:
  ##   x-amzn-iot-policy: JString (required)
  ##                    : The policy name.
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-policy` field"
  var valid_615682 = header.getOrDefault("x-amzn-iot-policy")
  valid_615682 = validateParameter(valid_615682, JString, required = true,
                                 default = nil)
  if valid_615682 != nil:
    section.add "x-amzn-iot-policy", valid_615682
  var valid_615683 = header.getOrDefault("X-Amz-Signature")
  valid_615683 = validateParameter(valid_615683, JString, required = false,
                                 default = nil)
  if valid_615683 != nil:
    section.add "X-Amz-Signature", valid_615683
  var valid_615684 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615684 = validateParameter(valid_615684, JString, required = false,
                                 default = nil)
  if valid_615684 != nil:
    section.add "X-Amz-Content-Sha256", valid_615684
  var valid_615685 = header.getOrDefault("X-Amz-Date")
  valid_615685 = validateParameter(valid_615685, JString, required = false,
                                 default = nil)
  if valid_615685 != nil:
    section.add "X-Amz-Date", valid_615685
  var valid_615686 = header.getOrDefault("X-Amz-Credential")
  valid_615686 = validateParameter(valid_615686, JString, required = false,
                                 default = nil)
  if valid_615686 != nil:
    section.add "X-Amz-Credential", valid_615686
  var valid_615687 = header.getOrDefault("X-Amz-Security-Token")
  valid_615687 = validateParameter(valid_615687, JString, required = false,
                                 default = nil)
  if valid_615687 != nil:
    section.add "X-Amz-Security-Token", valid_615687
  var valid_615688 = header.getOrDefault("X-Amz-Algorithm")
  valid_615688 = validateParameter(valid_615688, JString, required = false,
                                 default = nil)
  if valid_615688 != nil:
    section.add "X-Amz-Algorithm", valid_615688
  var valid_615689 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615689 = validateParameter(valid_615689, JString, required = false,
                                 default = nil)
  if valid_615689 != nil:
    section.add "X-Amz-SignedHeaders", valid_615689
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615690: Call_ListPolicyPrincipals_615676; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ## 
  let valid = call_615690.validator(path, query, header, formData, body)
  let scheme = call_615690.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615690.url(scheme.get, call_615690.host, call_615690.base,
                         call_615690.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615690, url, valid)

proc call*(call_615691: Call_ListPolicyPrincipals_615676;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listPolicyPrincipals
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_615692 = newJObject()
  add(query_615692, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_615692, "pageSize", newJInt(pageSize))
  add(query_615692, "marker", newJString(marker))
  result = call_615691.call(nil, query_615692, nil, nil, nil)

var listPolicyPrincipals* = Call_ListPolicyPrincipals_615676(
    name: "listPolicyPrincipals", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/policy-principals#x-amzn-iot-policy",
    validator: validate_ListPolicyPrincipals_615677, base: "/",
    url: url_ListPolicyPrincipals_615678, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPrincipalPolicies_615693 = ref object of OpenApiRestCall_612658
proc url_ListPrincipalPolicies_615695(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPrincipalPolicies_615694(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, results are returned in ascending creation order.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_615696 = query.getOrDefault("isAscendingOrder")
  valid_615696 = validateParameter(valid_615696, JBool, required = false, default = nil)
  if valid_615696 != nil:
    section.add "isAscendingOrder", valid_615696
  var valid_615697 = query.getOrDefault("pageSize")
  valid_615697 = validateParameter(valid_615697, JInt, required = false, default = nil)
  if valid_615697 != nil:
    section.add "pageSize", valid_615697
  var valid_615698 = query.getOrDefault("marker")
  valid_615698 = validateParameter(valid_615698, JString, required = false,
                                 default = nil)
  if valid_615698 != nil:
    section.add "marker", valid_615698
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : The principal.
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615699 = header.getOrDefault("X-Amz-Signature")
  valid_615699 = validateParameter(valid_615699, JString, required = false,
                                 default = nil)
  if valid_615699 != nil:
    section.add "X-Amz-Signature", valid_615699
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_615700 = header.getOrDefault("x-amzn-iot-principal")
  valid_615700 = validateParameter(valid_615700, JString, required = true,
                                 default = nil)
  if valid_615700 != nil:
    section.add "x-amzn-iot-principal", valid_615700
  var valid_615701 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615701 = validateParameter(valid_615701, JString, required = false,
                                 default = nil)
  if valid_615701 != nil:
    section.add "X-Amz-Content-Sha256", valid_615701
  var valid_615702 = header.getOrDefault("X-Amz-Date")
  valid_615702 = validateParameter(valid_615702, JString, required = false,
                                 default = nil)
  if valid_615702 != nil:
    section.add "X-Amz-Date", valid_615702
  var valid_615703 = header.getOrDefault("X-Amz-Credential")
  valid_615703 = validateParameter(valid_615703, JString, required = false,
                                 default = nil)
  if valid_615703 != nil:
    section.add "X-Amz-Credential", valid_615703
  var valid_615704 = header.getOrDefault("X-Amz-Security-Token")
  valid_615704 = validateParameter(valid_615704, JString, required = false,
                                 default = nil)
  if valid_615704 != nil:
    section.add "X-Amz-Security-Token", valid_615704
  var valid_615705 = header.getOrDefault("X-Amz-Algorithm")
  valid_615705 = validateParameter(valid_615705, JString, required = false,
                                 default = nil)
  if valid_615705 != nil:
    section.add "X-Amz-Algorithm", valid_615705
  var valid_615706 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615706 = validateParameter(valid_615706, JString, required = false,
                                 default = nil)
  if valid_615706 != nil:
    section.add "X-Amz-SignedHeaders", valid_615706
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615707: Call_ListPrincipalPolicies_615693; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ## 
  let valid = call_615707.validator(path, query, header, formData, body)
  let scheme = call_615707.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615707.url(scheme.get, call_615707.host, call_615707.base,
                         call_615707.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615707, url, valid)

proc call*(call_615708: Call_ListPrincipalPolicies_615693;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listPrincipalPolicies
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, results are returned in ascending creation order.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_615709 = newJObject()
  add(query_615709, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_615709, "pageSize", newJInt(pageSize))
  add(query_615709, "marker", newJString(marker))
  result = call_615708.call(nil, query_615709, nil, nil, nil)

var listPrincipalPolicies* = Call_ListPrincipalPolicies_615693(
    name: "listPrincipalPolicies", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/principal-policies#x-amzn-iot-principal",
    validator: validate_ListPrincipalPolicies_615694, base: "/",
    url: url_ListPrincipalPolicies_615695, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPrincipalThings_615710 = ref object of OpenApiRestCall_612658
proc url_ListPrincipalThings_615712(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPrincipalThings_615711(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  section = newJObject()
  var valid_615713 = query.getOrDefault("nextToken")
  valid_615713 = validateParameter(valid_615713, JString, required = false,
                                 default = nil)
  if valid_615713 != nil:
    section.add "nextToken", valid_615713
  var valid_615714 = query.getOrDefault("maxResults")
  valid_615714 = validateParameter(valid_615714, JInt, required = false, default = nil)
  if valid_615714 != nil:
    section.add "maxResults", valid_615714
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : The principal.
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615715 = header.getOrDefault("X-Amz-Signature")
  valid_615715 = validateParameter(valid_615715, JString, required = false,
                                 default = nil)
  if valid_615715 != nil:
    section.add "X-Amz-Signature", valid_615715
  var valid_615716 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615716 = validateParameter(valid_615716, JString, required = false,
                                 default = nil)
  if valid_615716 != nil:
    section.add "X-Amz-Content-Sha256", valid_615716
  var valid_615717 = header.getOrDefault("X-Amz-Date")
  valid_615717 = validateParameter(valid_615717, JString, required = false,
                                 default = nil)
  if valid_615717 != nil:
    section.add "X-Amz-Date", valid_615717
  var valid_615718 = header.getOrDefault("X-Amz-Credential")
  valid_615718 = validateParameter(valid_615718, JString, required = false,
                                 default = nil)
  if valid_615718 != nil:
    section.add "X-Amz-Credential", valid_615718
  var valid_615719 = header.getOrDefault("X-Amz-Security-Token")
  valid_615719 = validateParameter(valid_615719, JString, required = false,
                                 default = nil)
  if valid_615719 != nil:
    section.add "X-Amz-Security-Token", valid_615719
  var valid_615720 = header.getOrDefault("X-Amz-Algorithm")
  valid_615720 = validateParameter(valid_615720, JString, required = false,
                                 default = nil)
  if valid_615720 != nil:
    section.add "X-Amz-Algorithm", valid_615720
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_615721 = header.getOrDefault("x-amzn-principal")
  valid_615721 = validateParameter(valid_615721, JString, required = true,
                                 default = nil)
  if valid_615721 != nil:
    section.add "x-amzn-principal", valid_615721
  var valid_615722 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615722 = validateParameter(valid_615722, JString, required = false,
                                 default = nil)
  if valid_615722 != nil:
    section.add "X-Amz-SignedHeaders", valid_615722
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615723: Call_ListPrincipalThings_615710; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ## 
  let valid = call_615723.validator(path, query, header, formData, body)
  let scheme = call_615723.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615723.url(scheme.get, call_615723.host, call_615723.base,
                         call_615723.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615723, url, valid)

proc call*(call_615724: Call_ListPrincipalThings_615710; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listPrincipalThings
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  var query_615725 = newJObject()
  add(query_615725, "nextToken", newJString(nextToken))
  add(query_615725, "maxResults", newJInt(maxResults))
  result = call_615724.call(nil, query_615725, nil, nil, nil)

var listPrincipalThings* = Call_ListPrincipalThings_615710(
    name: "listPrincipalThings", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/principals/things#x-amzn-principal",
    validator: validate_ListPrincipalThings_615711, base: "/",
    url: url_ListPrincipalThings_615712, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListRoleAliases_615726 = ref object of OpenApiRestCall_612658
proc url_ListRoleAliases_615728(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListRoleAliases_615727(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Lists the role aliases registered in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Return the list of role aliases in ascending alphabetical order.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  section = newJObject()
  var valid_615729 = query.getOrDefault("isAscendingOrder")
  valid_615729 = validateParameter(valid_615729, JBool, required = false, default = nil)
  if valid_615729 != nil:
    section.add "isAscendingOrder", valid_615729
  var valid_615730 = query.getOrDefault("pageSize")
  valid_615730 = validateParameter(valid_615730, JInt, required = false, default = nil)
  if valid_615730 != nil:
    section.add "pageSize", valid_615730
  var valid_615731 = query.getOrDefault("marker")
  valid_615731 = validateParameter(valid_615731, JString, required = false,
                                 default = nil)
  if valid_615731 != nil:
    section.add "marker", valid_615731
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615732 = header.getOrDefault("X-Amz-Signature")
  valid_615732 = validateParameter(valid_615732, JString, required = false,
                                 default = nil)
  if valid_615732 != nil:
    section.add "X-Amz-Signature", valid_615732
  var valid_615733 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615733 = validateParameter(valid_615733, JString, required = false,
                                 default = nil)
  if valid_615733 != nil:
    section.add "X-Amz-Content-Sha256", valid_615733
  var valid_615734 = header.getOrDefault("X-Amz-Date")
  valid_615734 = validateParameter(valid_615734, JString, required = false,
                                 default = nil)
  if valid_615734 != nil:
    section.add "X-Amz-Date", valid_615734
  var valid_615735 = header.getOrDefault("X-Amz-Credential")
  valid_615735 = validateParameter(valid_615735, JString, required = false,
                                 default = nil)
  if valid_615735 != nil:
    section.add "X-Amz-Credential", valid_615735
  var valid_615736 = header.getOrDefault("X-Amz-Security-Token")
  valid_615736 = validateParameter(valid_615736, JString, required = false,
                                 default = nil)
  if valid_615736 != nil:
    section.add "X-Amz-Security-Token", valid_615736
  var valid_615737 = header.getOrDefault("X-Amz-Algorithm")
  valid_615737 = validateParameter(valid_615737, JString, required = false,
                                 default = nil)
  if valid_615737 != nil:
    section.add "X-Amz-Algorithm", valid_615737
  var valid_615738 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615738 = validateParameter(valid_615738, JString, required = false,
                                 default = nil)
  if valid_615738 != nil:
    section.add "X-Amz-SignedHeaders", valid_615738
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615739: Call_ListRoleAliases_615726; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the role aliases registered in your account.
  ## 
  let valid = call_615739.validator(path, query, header, formData, body)
  let scheme = call_615739.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615739.url(scheme.get, call_615739.host, call_615739.base,
                         call_615739.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615739, url, valid)

proc call*(call_615740: Call_ListRoleAliases_615726;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listRoleAliases
  ## Lists the role aliases registered in your account.
  ##   isAscendingOrder: bool
  ##                   : Return the list of role aliases in ascending alphabetical order.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  var query_615741 = newJObject()
  add(query_615741, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_615741, "pageSize", newJInt(pageSize))
  add(query_615741, "marker", newJString(marker))
  result = call_615740.call(nil, query_615741, nil, nil, nil)

var listRoleAliases* = Call_ListRoleAliases_615726(name: "listRoleAliases",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/role-aliases",
    validator: validate_ListRoleAliases_615727, base: "/", url: url_ListRoleAliases_615728,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListScheduledAudits_615742 = ref object of OpenApiRestCall_612658
proc url_ListScheduledAudits_615744(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListScheduledAudits_615743(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists all of your scheduled audits.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  var valid_615745 = query.getOrDefault("nextToken")
  valid_615745 = validateParameter(valid_615745, JString, required = false,
                                 default = nil)
  if valid_615745 != nil:
    section.add "nextToken", valid_615745
  var valid_615746 = query.getOrDefault("maxResults")
  valid_615746 = validateParameter(valid_615746, JInt, required = false, default = nil)
  if valid_615746 != nil:
    section.add "maxResults", valid_615746
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615747 = header.getOrDefault("X-Amz-Signature")
  valid_615747 = validateParameter(valid_615747, JString, required = false,
                                 default = nil)
  if valid_615747 != nil:
    section.add "X-Amz-Signature", valid_615747
  var valid_615748 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615748 = validateParameter(valid_615748, JString, required = false,
                                 default = nil)
  if valid_615748 != nil:
    section.add "X-Amz-Content-Sha256", valid_615748
  var valid_615749 = header.getOrDefault("X-Amz-Date")
  valid_615749 = validateParameter(valid_615749, JString, required = false,
                                 default = nil)
  if valid_615749 != nil:
    section.add "X-Amz-Date", valid_615749
  var valid_615750 = header.getOrDefault("X-Amz-Credential")
  valid_615750 = validateParameter(valid_615750, JString, required = false,
                                 default = nil)
  if valid_615750 != nil:
    section.add "X-Amz-Credential", valid_615750
  var valid_615751 = header.getOrDefault("X-Amz-Security-Token")
  valid_615751 = validateParameter(valid_615751, JString, required = false,
                                 default = nil)
  if valid_615751 != nil:
    section.add "X-Amz-Security-Token", valid_615751
  var valid_615752 = header.getOrDefault("X-Amz-Algorithm")
  valid_615752 = validateParameter(valid_615752, JString, required = false,
                                 default = nil)
  if valid_615752 != nil:
    section.add "X-Amz-Algorithm", valid_615752
  var valid_615753 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615753 = validateParameter(valid_615753, JString, required = false,
                                 default = nil)
  if valid_615753 != nil:
    section.add "X-Amz-SignedHeaders", valid_615753
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615754: Call_ListScheduledAudits_615742; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all of your scheduled audits.
  ## 
  let valid = call_615754.validator(path, query, header, formData, body)
  let scheme = call_615754.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615754.url(scheme.get, call_615754.host, call_615754.base,
                         call_615754.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615754, url, valid)

proc call*(call_615755: Call_ListScheduledAudits_615742; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listScheduledAudits
  ## Lists all of your scheduled audits.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_615756 = newJObject()
  add(query_615756, "nextToken", newJString(nextToken))
  add(query_615756, "maxResults", newJInt(maxResults))
  result = call_615755.call(nil, query_615756, nil, nil, nil)

var listScheduledAudits* = Call_ListScheduledAudits_615742(
    name: "listScheduledAudits", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/scheduledaudits",
    validator: validate_ListScheduledAudits_615743, base: "/",
    url: url_ListScheduledAudits_615744, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListSecurityProfiles_615757 = ref object of OpenApiRestCall_612658
proc url_ListSecurityProfiles_615759(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListSecurityProfiles_615758(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_615760 = query.getOrDefault("nextToken")
  valid_615760 = validateParameter(valid_615760, JString, required = false,
                                 default = nil)
  if valid_615760 != nil:
    section.add "nextToken", valid_615760
  var valid_615761 = query.getOrDefault("maxResults")
  valid_615761 = validateParameter(valid_615761, JInt, required = false, default = nil)
  if valid_615761 != nil:
    section.add "maxResults", valid_615761
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615762 = header.getOrDefault("X-Amz-Signature")
  valid_615762 = validateParameter(valid_615762, JString, required = false,
                                 default = nil)
  if valid_615762 != nil:
    section.add "X-Amz-Signature", valid_615762
  var valid_615763 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615763 = validateParameter(valid_615763, JString, required = false,
                                 default = nil)
  if valid_615763 != nil:
    section.add "X-Amz-Content-Sha256", valid_615763
  var valid_615764 = header.getOrDefault("X-Amz-Date")
  valid_615764 = validateParameter(valid_615764, JString, required = false,
                                 default = nil)
  if valid_615764 != nil:
    section.add "X-Amz-Date", valid_615764
  var valid_615765 = header.getOrDefault("X-Amz-Credential")
  valid_615765 = validateParameter(valid_615765, JString, required = false,
                                 default = nil)
  if valid_615765 != nil:
    section.add "X-Amz-Credential", valid_615765
  var valid_615766 = header.getOrDefault("X-Amz-Security-Token")
  valid_615766 = validateParameter(valid_615766, JString, required = false,
                                 default = nil)
  if valid_615766 != nil:
    section.add "X-Amz-Security-Token", valid_615766
  var valid_615767 = header.getOrDefault("X-Amz-Algorithm")
  valid_615767 = validateParameter(valid_615767, JString, required = false,
                                 default = nil)
  if valid_615767 != nil:
    section.add "X-Amz-Algorithm", valid_615767
  var valid_615768 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615768 = validateParameter(valid_615768, JString, required = false,
                                 default = nil)
  if valid_615768 != nil:
    section.add "X-Amz-SignedHeaders", valid_615768
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615769: Call_ListSecurityProfiles_615757; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ## 
  let valid = call_615769.validator(path, query, header, formData, body)
  let scheme = call_615769.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615769.url(scheme.get, call_615769.host, call_615769.base,
                         call_615769.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615769, url, valid)

proc call*(call_615770: Call_ListSecurityProfiles_615757; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listSecurityProfiles
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_615771 = newJObject()
  add(query_615771, "nextToken", newJString(nextToken))
  add(query_615771, "maxResults", newJInt(maxResults))
  result = call_615770.call(nil, query_615771, nil, nil, nil)

var listSecurityProfiles* = Call_ListSecurityProfiles_615757(
    name: "listSecurityProfiles", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/security-profiles",
    validator: validate_ListSecurityProfiles_615758, base: "/",
    url: url_ListSecurityProfiles_615759, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListSecurityProfilesForTarget_615772 = ref object of OpenApiRestCall_612658
proc url_ListSecurityProfilesForTarget_615774(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListSecurityProfilesForTarget_615773(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   recursive: JBool
  ##            : If true, return child groups too.
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the target (thing group) whose attached security profiles you want to get.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_615775 = query.getOrDefault("nextToken")
  valid_615775 = validateParameter(valid_615775, JString, required = false,
                                 default = nil)
  if valid_615775 != nil:
    section.add "nextToken", valid_615775
  var valid_615776 = query.getOrDefault("recursive")
  valid_615776 = validateParameter(valid_615776, JBool, required = false, default = nil)
  if valid_615776 != nil:
    section.add "recursive", valid_615776
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_615777 = query.getOrDefault("securityProfileTargetArn")
  valid_615777 = validateParameter(valid_615777, JString, required = true,
                                 default = nil)
  if valid_615777 != nil:
    section.add "securityProfileTargetArn", valid_615777
  var valid_615778 = query.getOrDefault("maxResults")
  valid_615778 = validateParameter(valid_615778, JInt, required = false, default = nil)
  if valid_615778 != nil:
    section.add "maxResults", valid_615778
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615779 = header.getOrDefault("X-Amz-Signature")
  valid_615779 = validateParameter(valid_615779, JString, required = false,
                                 default = nil)
  if valid_615779 != nil:
    section.add "X-Amz-Signature", valid_615779
  var valid_615780 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615780 = validateParameter(valid_615780, JString, required = false,
                                 default = nil)
  if valid_615780 != nil:
    section.add "X-Amz-Content-Sha256", valid_615780
  var valid_615781 = header.getOrDefault("X-Amz-Date")
  valid_615781 = validateParameter(valid_615781, JString, required = false,
                                 default = nil)
  if valid_615781 != nil:
    section.add "X-Amz-Date", valid_615781
  var valid_615782 = header.getOrDefault("X-Amz-Credential")
  valid_615782 = validateParameter(valid_615782, JString, required = false,
                                 default = nil)
  if valid_615782 != nil:
    section.add "X-Amz-Credential", valid_615782
  var valid_615783 = header.getOrDefault("X-Amz-Security-Token")
  valid_615783 = validateParameter(valid_615783, JString, required = false,
                                 default = nil)
  if valid_615783 != nil:
    section.add "X-Amz-Security-Token", valid_615783
  var valid_615784 = header.getOrDefault("X-Amz-Algorithm")
  valid_615784 = validateParameter(valid_615784, JString, required = false,
                                 default = nil)
  if valid_615784 != nil:
    section.add "X-Amz-Algorithm", valid_615784
  var valid_615785 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615785 = validateParameter(valid_615785, JString, required = false,
                                 default = nil)
  if valid_615785 != nil:
    section.add "X-Amz-SignedHeaders", valid_615785
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615786: Call_ListSecurityProfilesForTarget_615772; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ## 
  let valid = call_615786.validator(path, query, header, formData, body)
  let scheme = call_615786.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615786.url(scheme.get, call_615786.host, call_615786.base,
                         call_615786.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615786, url, valid)

proc call*(call_615787: Call_ListSecurityProfilesForTarget_615772;
          securityProfileTargetArn: string; nextToken: string = "";
          recursive: bool = false; maxResults: int = 0): Recallable =
  ## listSecurityProfilesForTarget
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   recursive: bool
  ##            : If true, return child groups too.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the target (thing group) whose attached security profiles you want to get.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_615788 = newJObject()
  add(query_615788, "nextToken", newJString(nextToken))
  add(query_615788, "recursive", newJBool(recursive))
  add(query_615788, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(query_615788, "maxResults", newJInt(maxResults))
  result = call_615787.call(nil, query_615788, nil, nil, nil)

var listSecurityProfilesForTarget* = Call_ListSecurityProfilesForTarget_615772(
    name: "listSecurityProfilesForTarget", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/security-profiles-for-target#securityProfileTargetArn",
    validator: validate_ListSecurityProfilesForTarget_615773, base: "/",
    url: url_ListSecurityProfilesForTarget_615774,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListStreams_615789 = ref object of OpenApiRestCall_612658
proc url_ListStreams_615791(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListStreams_615790(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all of the streams in your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token used to get the next set of results.
  ##   isAscendingOrder: JBool
  ##                   : Set to true to return the list of streams in ascending order.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at a time.
  section = newJObject()
  var valid_615792 = query.getOrDefault("nextToken")
  valid_615792 = validateParameter(valid_615792, JString, required = false,
                                 default = nil)
  if valid_615792 != nil:
    section.add "nextToken", valid_615792
  var valid_615793 = query.getOrDefault("isAscendingOrder")
  valid_615793 = validateParameter(valid_615793, JBool, required = false, default = nil)
  if valid_615793 != nil:
    section.add "isAscendingOrder", valid_615793
  var valid_615794 = query.getOrDefault("maxResults")
  valid_615794 = validateParameter(valid_615794, JInt, required = false, default = nil)
  if valid_615794 != nil:
    section.add "maxResults", valid_615794
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615795 = header.getOrDefault("X-Amz-Signature")
  valid_615795 = validateParameter(valid_615795, JString, required = false,
                                 default = nil)
  if valid_615795 != nil:
    section.add "X-Amz-Signature", valid_615795
  var valid_615796 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615796 = validateParameter(valid_615796, JString, required = false,
                                 default = nil)
  if valid_615796 != nil:
    section.add "X-Amz-Content-Sha256", valid_615796
  var valid_615797 = header.getOrDefault("X-Amz-Date")
  valid_615797 = validateParameter(valid_615797, JString, required = false,
                                 default = nil)
  if valid_615797 != nil:
    section.add "X-Amz-Date", valid_615797
  var valid_615798 = header.getOrDefault("X-Amz-Credential")
  valid_615798 = validateParameter(valid_615798, JString, required = false,
                                 default = nil)
  if valid_615798 != nil:
    section.add "X-Amz-Credential", valid_615798
  var valid_615799 = header.getOrDefault("X-Amz-Security-Token")
  valid_615799 = validateParameter(valid_615799, JString, required = false,
                                 default = nil)
  if valid_615799 != nil:
    section.add "X-Amz-Security-Token", valid_615799
  var valid_615800 = header.getOrDefault("X-Amz-Algorithm")
  valid_615800 = validateParameter(valid_615800, JString, required = false,
                                 default = nil)
  if valid_615800 != nil:
    section.add "X-Amz-Algorithm", valid_615800
  var valid_615801 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615801 = validateParameter(valid_615801, JString, required = false,
                                 default = nil)
  if valid_615801 != nil:
    section.add "X-Amz-SignedHeaders", valid_615801
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615802: Call_ListStreams_615789; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all of the streams in your AWS account.
  ## 
  let valid = call_615802.validator(path, query, header, formData, body)
  let scheme = call_615802.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615802.url(scheme.get, call_615802.host, call_615802.base,
                         call_615802.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615802, url, valid)

proc call*(call_615803: Call_ListStreams_615789; nextToken: string = "";
          isAscendingOrder: bool = false; maxResults: int = 0): Recallable =
  ## listStreams
  ## Lists all of the streams in your AWS account.
  ##   nextToken: string
  ##            : A token used to get the next set of results.
  ##   isAscendingOrder: bool
  ##                   : Set to true to return the list of streams in ascending order.
  ##   maxResults: int
  ##             : The maximum number of results to return at a time.
  var query_615804 = newJObject()
  add(query_615804, "nextToken", newJString(nextToken))
  add(query_615804, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_615804, "maxResults", newJInt(maxResults))
  result = call_615803.call(nil, query_615804, nil, nil, nil)

var listStreams* = Call_ListStreams_615789(name: "listStreams",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/streams",
                                        validator: validate_ListStreams_615790,
                                        base: "/", url: url_ListStreams_615791,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTagsForResource_615805 = ref object of OpenApiRestCall_612658
proc url_ListTagsForResource_615807(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListTagsForResource_615806(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the tags (metadata) you have assigned to the resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   resourceArn: JString (required)
  ##              : The ARN of the resource.
  section = newJObject()
  var valid_615808 = query.getOrDefault("nextToken")
  valid_615808 = validateParameter(valid_615808, JString, required = false,
                                 default = nil)
  if valid_615808 != nil:
    section.add "nextToken", valid_615808
  assert query != nil,
        "query argument is necessary due to required `resourceArn` field"
  var valid_615809 = query.getOrDefault("resourceArn")
  valid_615809 = validateParameter(valid_615809, JString, required = true,
                                 default = nil)
  if valid_615809 != nil:
    section.add "resourceArn", valid_615809
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615810 = header.getOrDefault("X-Amz-Signature")
  valid_615810 = validateParameter(valid_615810, JString, required = false,
                                 default = nil)
  if valid_615810 != nil:
    section.add "X-Amz-Signature", valid_615810
  var valid_615811 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615811 = validateParameter(valid_615811, JString, required = false,
                                 default = nil)
  if valid_615811 != nil:
    section.add "X-Amz-Content-Sha256", valid_615811
  var valid_615812 = header.getOrDefault("X-Amz-Date")
  valid_615812 = validateParameter(valid_615812, JString, required = false,
                                 default = nil)
  if valid_615812 != nil:
    section.add "X-Amz-Date", valid_615812
  var valid_615813 = header.getOrDefault("X-Amz-Credential")
  valid_615813 = validateParameter(valid_615813, JString, required = false,
                                 default = nil)
  if valid_615813 != nil:
    section.add "X-Amz-Credential", valid_615813
  var valid_615814 = header.getOrDefault("X-Amz-Security-Token")
  valid_615814 = validateParameter(valid_615814, JString, required = false,
                                 default = nil)
  if valid_615814 != nil:
    section.add "X-Amz-Security-Token", valid_615814
  var valid_615815 = header.getOrDefault("X-Amz-Algorithm")
  valid_615815 = validateParameter(valid_615815, JString, required = false,
                                 default = nil)
  if valid_615815 != nil:
    section.add "X-Amz-Algorithm", valid_615815
  var valid_615816 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615816 = validateParameter(valid_615816, JString, required = false,
                                 default = nil)
  if valid_615816 != nil:
    section.add "X-Amz-SignedHeaders", valid_615816
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615817: Call_ListTagsForResource_615805; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the tags (metadata) you have assigned to the resource.
  ## 
  let valid = call_615817.validator(path, query, header, formData, body)
  let scheme = call_615817.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615817.url(scheme.get, call_615817.host, call_615817.base,
                         call_615817.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615817, url, valid)

proc call*(call_615818: Call_ListTagsForResource_615805; resourceArn: string;
          nextToken: string = ""): Recallable =
  ## listTagsForResource
  ## Lists the tags (metadata) you have assigned to the resource.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   resourceArn: string (required)
  ##              : The ARN of the resource.
  var query_615819 = newJObject()
  add(query_615819, "nextToken", newJString(nextToken))
  add(query_615819, "resourceArn", newJString(resourceArn))
  result = call_615818.call(nil, query_615819, nil, nil, nil)

var listTagsForResource* = Call_ListTagsForResource_615805(
    name: "listTagsForResource", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/tags#resourceArn",
    validator: validate_ListTagsForResource_615806, base: "/",
    url: url_ListTagsForResource_615807, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTargetsForPolicy_615820 = ref object of OpenApiRestCall_612658
proc url_ListTargetsForPolicy_615822(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policy-targets/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListTargetsForPolicy_615821(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List targets for the specified policy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_615823 = path.getOrDefault("policyName")
  valid_615823 = validateParameter(valid_615823, JString, required = true,
                                 default = nil)
  if valid_615823 != nil:
    section.add "policyName", valid_615823
  result.add "path", section
  ## parameters in `query` object:
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  section = newJObject()
  var valid_615824 = query.getOrDefault("pageSize")
  valid_615824 = validateParameter(valid_615824, JInt, required = false, default = nil)
  if valid_615824 != nil:
    section.add "pageSize", valid_615824
  var valid_615825 = query.getOrDefault("marker")
  valid_615825 = validateParameter(valid_615825, JString, required = false,
                                 default = nil)
  if valid_615825 != nil:
    section.add "marker", valid_615825
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615826 = header.getOrDefault("X-Amz-Signature")
  valid_615826 = validateParameter(valid_615826, JString, required = false,
                                 default = nil)
  if valid_615826 != nil:
    section.add "X-Amz-Signature", valid_615826
  var valid_615827 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615827 = validateParameter(valid_615827, JString, required = false,
                                 default = nil)
  if valid_615827 != nil:
    section.add "X-Amz-Content-Sha256", valid_615827
  var valid_615828 = header.getOrDefault("X-Amz-Date")
  valid_615828 = validateParameter(valid_615828, JString, required = false,
                                 default = nil)
  if valid_615828 != nil:
    section.add "X-Amz-Date", valid_615828
  var valid_615829 = header.getOrDefault("X-Amz-Credential")
  valid_615829 = validateParameter(valid_615829, JString, required = false,
                                 default = nil)
  if valid_615829 != nil:
    section.add "X-Amz-Credential", valid_615829
  var valid_615830 = header.getOrDefault("X-Amz-Security-Token")
  valid_615830 = validateParameter(valid_615830, JString, required = false,
                                 default = nil)
  if valid_615830 != nil:
    section.add "X-Amz-Security-Token", valid_615830
  var valid_615831 = header.getOrDefault("X-Amz-Algorithm")
  valid_615831 = validateParameter(valid_615831, JString, required = false,
                                 default = nil)
  if valid_615831 != nil:
    section.add "X-Amz-Algorithm", valid_615831
  var valid_615832 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615832 = validateParameter(valid_615832, JString, required = false,
                                 default = nil)
  if valid_615832 != nil:
    section.add "X-Amz-SignedHeaders", valid_615832
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615833: Call_ListTargetsForPolicy_615820; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List targets for the specified policy.
  ## 
  let valid = call_615833.validator(path, query, header, formData, body)
  let scheme = call_615833.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615833.url(scheme.get, call_615833.host, call_615833.base,
                         call_615833.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615833, url, valid)

proc call*(call_615834: Call_ListTargetsForPolicy_615820; policyName: string;
          pageSize: int = 0; marker: string = ""): Recallable =
  ## listTargetsForPolicy
  ## List targets for the specified policy.
  ##   policyName: string (required)
  ##             : The policy name.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  var path_615835 = newJObject()
  var query_615836 = newJObject()
  add(path_615835, "policyName", newJString(policyName))
  add(query_615836, "pageSize", newJInt(pageSize))
  add(query_615836, "marker", newJString(marker))
  result = call_615834.call(path_615835, query_615836, nil, nil, nil)

var listTargetsForPolicy* = Call_ListTargetsForPolicy_615820(
    name: "listTargetsForPolicy", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/policy-targets/{policyName}",
    validator: validate_ListTargetsForPolicy_615821, base: "/",
    url: url_ListTargetsForPolicy_615822, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTargetsForSecurityProfile_615837 = ref object of OpenApiRestCall_612658
proc url_ListTargetsForSecurityProfile_615839(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"),
               (kind: ConstantSegment, value: "/targets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListTargetsForSecurityProfile_615838(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_615840 = path.getOrDefault("securityProfileName")
  valid_615840 = validateParameter(valid_615840, JString, required = true,
                                 default = nil)
  if valid_615840 != nil:
    section.add "securityProfileName", valid_615840
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_615841 = query.getOrDefault("nextToken")
  valid_615841 = validateParameter(valid_615841, JString, required = false,
                                 default = nil)
  if valid_615841 != nil:
    section.add "nextToken", valid_615841
  var valid_615842 = query.getOrDefault("maxResults")
  valid_615842 = validateParameter(valid_615842, JInt, required = false, default = nil)
  if valid_615842 != nil:
    section.add "maxResults", valid_615842
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615843 = header.getOrDefault("X-Amz-Signature")
  valid_615843 = validateParameter(valid_615843, JString, required = false,
                                 default = nil)
  if valid_615843 != nil:
    section.add "X-Amz-Signature", valid_615843
  var valid_615844 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615844 = validateParameter(valid_615844, JString, required = false,
                                 default = nil)
  if valid_615844 != nil:
    section.add "X-Amz-Content-Sha256", valid_615844
  var valid_615845 = header.getOrDefault("X-Amz-Date")
  valid_615845 = validateParameter(valid_615845, JString, required = false,
                                 default = nil)
  if valid_615845 != nil:
    section.add "X-Amz-Date", valid_615845
  var valid_615846 = header.getOrDefault("X-Amz-Credential")
  valid_615846 = validateParameter(valid_615846, JString, required = false,
                                 default = nil)
  if valid_615846 != nil:
    section.add "X-Amz-Credential", valid_615846
  var valid_615847 = header.getOrDefault("X-Amz-Security-Token")
  valid_615847 = validateParameter(valid_615847, JString, required = false,
                                 default = nil)
  if valid_615847 != nil:
    section.add "X-Amz-Security-Token", valid_615847
  var valid_615848 = header.getOrDefault("X-Amz-Algorithm")
  valid_615848 = validateParameter(valid_615848, JString, required = false,
                                 default = nil)
  if valid_615848 != nil:
    section.add "X-Amz-Algorithm", valid_615848
  var valid_615849 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615849 = validateParameter(valid_615849, JString, required = false,
                                 default = nil)
  if valid_615849 != nil:
    section.add "X-Amz-SignedHeaders", valid_615849
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615850: Call_ListTargetsForSecurityProfile_615837; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ## 
  let valid = call_615850.validator(path, query, header, formData, body)
  let scheme = call_615850.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615850.url(scheme.get, call_615850.host, call_615850.base,
                         call_615850.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615850, url, valid)

proc call*(call_615851: Call_ListTargetsForSecurityProfile_615837;
          securityProfileName: string; nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listTargetsForSecurityProfile
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string (required)
  ##                      : The security profile.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_615852 = newJObject()
  var query_615853 = newJObject()
  add(query_615853, "nextToken", newJString(nextToken))
  add(path_615852, "securityProfileName", newJString(securityProfileName))
  add(query_615853, "maxResults", newJInt(maxResults))
  result = call_615851.call(path_615852, query_615853, nil, nil, nil)

var listTargetsForSecurityProfile* = Call_ListTargetsForSecurityProfile_615837(
    name: "listTargetsForSecurityProfile", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/security-profiles/{securityProfileName}/targets",
    validator: validate_ListTargetsForSecurityProfile_615838, base: "/",
    url: url_ListTargetsForSecurityProfile_615839,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingGroups_615854 = ref object of OpenApiRestCall_612658
proc url_ListThingGroups_615856(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThingGroups_615855(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List the thing groups in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   recursive: JBool
  ##            : If true, return child groups as well.
  ##   parentGroup: JString
  ##              : A filter that limits the results to those with the specified parent group.
  ##   namePrefixFilter: JString
  ##                   : A filter that limits the results to those with the specified name prefix.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_615857 = query.getOrDefault("nextToken")
  valid_615857 = validateParameter(valid_615857, JString, required = false,
                                 default = nil)
  if valid_615857 != nil:
    section.add "nextToken", valid_615857
  var valid_615858 = query.getOrDefault("recursive")
  valid_615858 = validateParameter(valid_615858, JBool, required = false, default = nil)
  if valid_615858 != nil:
    section.add "recursive", valid_615858
  var valid_615859 = query.getOrDefault("parentGroup")
  valid_615859 = validateParameter(valid_615859, JString, required = false,
                                 default = nil)
  if valid_615859 != nil:
    section.add "parentGroup", valid_615859
  var valid_615860 = query.getOrDefault("namePrefixFilter")
  valid_615860 = validateParameter(valid_615860, JString, required = false,
                                 default = nil)
  if valid_615860 != nil:
    section.add "namePrefixFilter", valid_615860
  var valid_615861 = query.getOrDefault("maxResults")
  valid_615861 = validateParameter(valid_615861, JInt, required = false, default = nil)
  if valid_615861 != nil:
    section.add "maxResults", valid_615861
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615862 = header.getOrDefault("X-Amz-Signature")
  valid_615862 = validateParameter(valid_615862, JString, required = false,
                                 default = nil)
  if valid_615862 != nil:
    section.add "X-Amz-Signature", valid_615862
  var valid_615863 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615863 = validateParameter(valid_615863, JString, required = false,
                                 default = nil)
  if valid_615863 != nil:
    section.add "X-Amz-Content-Sha256", valid_615863
  var valid_615864 = header.getOrDefault("X-Amz-Date")
  valid_615864 = validateParameter(valid_615864, JString, required = false,
                                 default = nil)
  if valid_615864 != nil:
    section.add "X-Amz-Date", valid_615864
  var valid_615865 = header.getOrDefault("X-Amz-Credential")
  valid_615865 = validateParameter(valid_615865, JString, required = false,
                                 default = nil)
  if valid_615865 != nil:
    section.add "X-Amz-Credential", valid_615865
  var valid_615866 = header.getOrDefault("X-Amz-Security-Token")
  valid_615866 = validateParameter(valid_615866, JString, required = false,
                                 default = nil)
  if valid_615866 != nil:
    section.add "X-Amz-Security-Token", valid_615866
  var valid_615867 = header.getOrDefault("X-Amz-Algorithm")
  valid_615867 = validateParameter(valid_615867, JString, required = false,
                                 default = nil)
  if valid_615867 != nil:
    section.add "X-Amz-Algorithm", valid_615867
  var valid_615868 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615868 = validateParameter(valid_615868, JString, required = false,
                                 default = nil)
  if valid_615868 != nil:
    section.add "X-Amz-SignedHeaders", valid_615868
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615869: Call_ListThingGroups_615854; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the thing groups in your account.
  ## 
  let valid = call_615869.validator(path, query, header, formData, body)
  let scheme = call_615869.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615869.url(scheme.get, call_615869.host, call_615869.base,
                         call_615869.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615869, url, valid)

proc call*(call_615870: Call_ListThingGroups_615854; nextToken: string = "";
          recursive: bool = false; parentGroup: string = "";
          namePrefixFilter: string = ""; maxResults: int = 0): Recallable =
  ## listThingGroups
  ## List the thing groups in your account.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   recursive: bool
  ##            : If true, return child groups as well.
  ##   parentGroup: string
  ##              : A filter that limits the results to those with the specified parent group.
  ##   namePrefixFilter: string
  ##                   : A filter that limits the results to those with the specified name prefix.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_615871 = newJObject()
  add(query_615871, "nextToken", newJString(nextToken))
  add(query_615871, "recursive", newJBool(recursive))
  add(query_615871, "parentGroup", newJString(parentGroup))
  add(query_615871, "namePrefixFilter", newJString(namePrefixFilter))
  add(query_615871, "maxResults", newJInt(maxResults))
  result = call_615870.call(nil, query_615871, nil, nil, nil)

var listThingGroups* = Call_ListThingGroups_615854(name: "listThingGroups",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/thing-groups",
    validator: validate_ListThingGroups_615855, base: "/", url: url_ListThingGroups_615856,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingGroupsForThing_615872 = ref object of OpenApiRestCall_612658
proc url_ListThingGroupsForThing_615874(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/thing-groups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingGroupsForThing_615873(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List the thing groups to which the specified thing belongs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The thing name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_615875 = path.getOrDefault("thingName")
  valid_615875 = validateParameter(valid_615875, JString, required = true,
                                 default = nil)
  if valid_615875 != nil:
    section.add "thingName", valid_615875
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_615876 = query.getOrDefault("nextToken")
  valid_615876 = validateParameter(valid_615876, JString, required = false,
                                 default = nil)
  if valid_615876 != nil:
    section.add "nextToken", valid_615876
  var valid_615877 = query.getOrDefault("maxResults")
  valid_615877 = validateParameter(valid_615877, JInt, required = false, default = nil)
  if valid_615877 != nil:
    section.add "maxResults", valid_615877
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615878 = header.getOrDefault("X-Amz-Signature")
  valid_615878 = validateParameter(valid_615878, JString, required = false,
                                 default = nil)
  if valid_615878 != nil:
    section.add "X-Amz-Signature", valid_615878
  var valid_615879 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615879 = validateParameter(valid_615879, JString, required = false,
                                 default = nil)
  if valid_615879 != nil:
    section.add "X-Amz-Content-Sha256", valid_615879
  var valid_615880 = header.getOrDefault("X-Amz-Date")
  valid_615880 = validateParameter(valid_615880, JString, required = false,
                                 default = nil)
  if valid_615880 != nil:
    section.add "X-Amz-Date", valid_615880
  var valid_615881 = header.getOrDefault("X-Amz-Credential")
  valid_615881 = validateParameter(valid_615881, JString, required = false,
                                 default = nil)
  if valid_615881 != nil:
    section.add "X-Amz-Credential", valid_615881
  var valid_615882 = header.getOrDefault("X-Amz-Security-Token")
  valid_615882 = validateParameter(valid_615882, JString, required = false,
                                 default = nil)
  if valid_615882 != nil:
    section.add "X-Amz-Security-Token", valid_615882
  var valid_615883 = header.getOrDefault("X-Amz-Algorithm")
  valid_615883 = validateParameter(valid_615883, JString, required = false,
                                 default = nil)
  if valid_615883 != nil:
    section.add "X-Amz-Algorithm", valid_615883
  var valid_615884 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615884 = validateParameter(valid_615884, JString, required = false,
                                 default = nil)
  if valid_615884 != nil:
    section.add "X-Amz-SignedHeaders", valid_615884
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615885: Call_ListThingGroupsForThing_615872; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the thing groups to which the specified thing belongs.
  ## 
  let valid = call_615885.validator(path, query, header, formData, body)
  let scheme = call_615885.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615885.url(scheme.get, call_615885.host, call_615885.base,
                         call_615885.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615885, url, valid)

proc call*(call_615886: Call_ListThingGroupsForThing_615872; thingName: string;
          nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listThingGroupsForThing
  ## List the thing groups to which the specified thing belongs.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingName: string (required)
  ##            : The thing name.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_615887 = newJObject()
  var query_615888 = newJObject()
  add(query_615888, "nextToken", newJString(nextToken))
  add(path_615887, "thingName", newJString(thingName))
  add(query_615888, "maxResults", newJInt(maxResults))
  result = call_615886.call(path_615887, query_615888, nil, nil, nil)

var listThingGroupsForThing* = Call_ListThingGroupsForThing_615872(
    name: "listThingGroupsForThing", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/thing-groups",
    validator: validate_ListThingGroupsForThing_615873, base: "/",
    url: url_ListThingGroupsForThing_615874, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingPrincipals_615889 = ref object of OpenApiRestCall_612658
proc url_ListThingPrincipals_615891(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingPrincipals_615890(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_615892 = path.getOrDefault("thingName")
  valid_615892 = validateParameter(valid_615892, JString, required = true,
                                 default = nil)
  if valid_615892 != nil:
    section.add "thingName", valid_615892
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615893 = header.getOrDefault("X-Amz-Signature")
  valid_615893 = validateParameter(valid_615893, JString, required = false,
                                 default = nil)
  if valid_615893 != nil:
    section.add "X-Amz-Signature", valid_615893
  var valid_615894 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615894 = validateParameter(valid_615894, JString, required = false,
                                 default = nil)
  if valid_615894 != nil:
    section.add "X-Amz-Content-Sha256", valid_615894
  var valid_615895 = header.getOrDefault("X-Amz-Date")
  valid_615895 = validateParameter(valid_615895, JString, required = false,
                                 default = nil)
  if valid_615895 != nil:
    section.add "X-Amz-Date", valid_615895
  var valid_615896 = header.getOrDefault("X-Amz-Credential")
  valid_615896 = validateParameter(valid_615896, JString, required = false,
                                 default = nil)
  if valid_615896 != nil:
    section.add "X-Amz-Credential", valid_615896
  var valid_615897 = header.getOrDefault("X-Amz-Security-Token")
  valid_615897 = validateParameter(valid_615897, JString, required = false,
                                 default = nil)
  if valid_615897 != nil:
    section.add "X-Amz-Security-Token", valid_615897
  var valid_615898 = header.getOrDefault("X-Amz-Algorithm")
  valid_615898 = validateParameter(valid_615898, JString, required = false,
                                 default = nil)
  if valid_615898 != nil:
    section.add "X-Amz-Algorithm", valid_615898
  var valid_615899 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615899 = validateParameter(valid_615899, JString, required = false,
                                 default = nil)
  if valid_615899 != nil:
    section.add "X-Amz-SignedHeaders", valid_615899
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615900: Call_ListThingPrincipals_615889; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  let valid = call_615900.validator(path, query, header, formData, body)
  let scheme = call_615900.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615900.url(scheme.get, call_615900.host, call_615900.base,
                         call_615900.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615900, url, valid)

proc call*(call_615901: Call_ListThingPrincipals_615889; thingName: string): Recallable =
  ## listThingPrincipals
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_615902 = newJObject()
  add(path_615902, "thingName", newJString(thingName))
  result = call_615901.call(path_615902, nil, nil, nil, nil)

var listThingPrincipals* = Call_ListThingPrincipals_615889(
    name: "listThingPrincipals", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/principals",
    validator: validate_ListThingPrincipals_615890, base: "/",
    url: url_ListThingPrincipals_615891, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingRegistrationTaskReports_615903 = ref object of OpenApiRestCall_612658
proc url_ListThingRegistrationTaskReports_615905(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/reports#reportType")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingRegistrationTaskReports_615904(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Information about the thing registration tasks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The id of the task.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_615906 = path.getOrDefault("taskId")
  valid_615906 = validateParameter(valid_615906, JString, required = true,
                                 default = nil)
  if valid_615906 != nil:
    section.add "taskId", valid_615906
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   reportType: JString (required)
  ##             : The type of task report.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_615907 = query.getOrDefault("nextToken")
  valid_615907 = validateParameter(valid_615907, JString, required = false,
                                 default = nil)
  if valid_615907 != nil:
    section.add "nextToken", valid_615907
  var valid_615908 = query.getOrDefault("reportType")
  valid_615908 = validateParameter(valid_615908, JString, required = true,
                                 default = newJString("ERRORS"))
  if valid_615908 != nil:
    section.add "reportType", valid_615908
  var valid_615909 = query.getOrDefault("maxResults")
  valid_615909 = validateParameter(valid_615909, JInt, required = false, default = nil)
  if valid_615909 != nil:
    section.add "maxResults", valid_615909
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615910 = header.getOrDefault("X-Amz-Signature")
  valid_615910 = validateParameter(valid_615910, JString, required = false,
                                 default = nil)
  if valid_615910 != nil:
    section.add "X-Amz-Signature", valid_615910
  var valid_615911 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615911 = validateParameter(valid_615911, JString, required = false,
                                 default = nil)
  if valid_615911 != nil:
    section.add "X-Amz-Content-Sha256", valid_615911
  var valid_615912 = header.getOrDefault("X-Amz-Date")
  valid_615912 = validateParameter(valid_615912, JString, required = false,
                                 default = nil)
  if valid_615912 != nil:
    section.add "X-Amz-Date", valid_615912
  var valid_615913 = header.getOrDefault("X-Amz-Credential")
  valid_615913 = validateParameter(valid_615913, JString, required = false,
                                 default = nil)
  if valid_615913 != nil:
    section.add "X-Amz-Credential", valid_615913
  var valid_615914 = header.getOrDefault("X-Amz-Security-Token")
  valid_615914 = validateParameter(valid_615914, JString, required = false,
                                 default = nil)
  if valid_615914 != nil:
    section.add "X-Amz-Security-Token", valid_615914
  var valid_615915 = header.getOrDefault("X-Amz-Algorithm")
  valid_615915 = validateParameter(valid_615915, JString, required = false,
                                 default = nil)
  if valid_615915 != nil:
    section.add "X-Amz-Algorithm", valid_615915
  var valid_615916 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615916 = validateParameter(valid_615916, JString, required = false,
                                 default = nil)
  if valid_615916 != nil:
    section.add "X-Amz-SignedHeaders", valid_615916
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615917: Call_ListThingRegistrationTaskReports_615903;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Information about the thing registration tasks.
  ## 
  let valid = call_615917.validator(path, query, header, formData, body)
  let scheme = call_615917.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615917.url(scheme.get, call_615917.host, call_615917.base,
                         call_615917.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615917, url, valid)

proc call*(call_615918: Call_ListThingRegistrationTaskReports_615903;
          taskId: string; nextToken: string = ""; reportType: string = "ERRORS";
          maxResults: int = 0): Recallable =
  ## listThingRegistrationTaskReports
  ## Information about the thing registration tasks.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   taskId: string (required)
  ##         : The id of the task.
  ##   reportType: string (required)
  ##             : The type of task report.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var path_615919 = newJObject()
  var query_615920 = newJObject()
  add(query_615920, "nextToken", newJString(nextToken))
  add(path_615919, "taskId", newJString(taskId))
  add(query_615920, "reportType", newJString(reportType))
  add(query_615920, "maxResults", newJInt(maxResults))
  result = call_615918.call(path_615919, query_615920, nil, nil, nil)

var listThingRegistrationTaskReports* = Call_ListThingRegistrationTaskReports_615903(
    name: "listThingRegistrationTaskReports", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/thing-registration-tasks/{taskId}/reports#reportType",
    validator: validate_ListThingRegistrationTaskReports_615904, base: "/",
    url: url_ListThingRegistrationTaskReports_615905,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartThingRegistrationTask_615937 = ref object of OpenApiRestCall_612658
proc url_StartThingRegistrationTask_615939(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_StartThingRegistrationTask_615938(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615940 = header.getOrDefault("X-Amz-Signature")
  valid_615940 = validateParameter(valid_615940, JString, required = false,
                                 default = nil)
  if valid_615940 != nil:
    section.add "X-Amz-Signature", valid_615940
  var valid_615941 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615941 = validateParameter(valid_615941, JString, required = false,
                                 default = nil)
  if valid_615941 != nil:
    section.add "X-Amz-Content-Sha256", valid_615941
  var valid_615942 = header.getOrDefault("X-Amz-Date")
  valid_615942 = validateParameter(valid_615942, JString, required = false,
                                 default = nil)
  if valid_615942 != nil:
    section.add "X-Amz-Date", valid_615942
  var valid_615943 = header.getOrDefault("X-Amz-Credential")
  valid_615943 = validateParameter(valid_615943, JString, required = false,
                                 default = nil)
  if valid_615943 != nil:
    section.add "X-Amz-Credential", valid_615943
  var valid_615944 = header.getOrDefault("X-Amz-Security-Token")
  valid_615944 = validateParameter(valid_615944, JString, required = false,
                                 default = nil)
  if valid_615944 != nil:
    section.add "X-Amz-Security-Token", valid_615944
  var valid_615945 = header.getOrDefault("X-Amz-Algorithm")
  valid_615945 = validateParameter(valid_615945, JString, required = false,
                                 default = nil)
  if valid_615945 != nil:
    section.add "X-Amz-Algorithm", valid_615945
  var valid_615946 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615946 = validateParameter(valid_615946, JString, required = false,
                                 default = nil)
  if valid_615946 != nil:
    section.add "X-Amz-SignedHeaders", valid_615946
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_615948: Call_StartThingRegistrationTask_615937; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a bulk thing provisioning task.
  ## 
  let valid = call_615948.validator(path, query, header, formData, body)
  let scheme = call_615948.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615948.url(scheme.get, call_615948.host, call_615948.base,
                         call_615948.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615948, url, valid)

proc call*(call_615949: Call_StartThingRegistrationTask_615937; body: JsonNode): Recallable =
  ## startThingRegistrationTask
  ## Creates a bulk thing provisioning task.
  ##   body: JObject (required)
  var body_615950 = newJObject()
  if body != nil:
    body_615950 = body
  result = call_615949.call(nil, nil, nil, nil, body_615950)

var startThingRegistrationTask* = Call_StartThingRegistrationTask_615937(
    name: "startThingRegistrationTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks",
    validator: validate_StartThingRegistrationTask_615938, base: "/",
    url: url_StartThingRegistrationTask_615939,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingRegistrationTasks_615921 = ref object of OpenApiRestCall_612658
proc url_ListThingRegistrationTasks_615923(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThingRegistrationTasks_615922(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List bulk thing provisioning tasks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : The status of the bulk thing provisioning task.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_615924 = query.getOrDefault("nextToken")
  valid_615924 = validateParameter(valid_615924, JString, required = false,
                                 default = nil)
  if valid_615924 != nil:
    section.add "nextToken", valid_615924
  var valid_615925 = query.getOrDefault("status")
  valid_615925 = validateParameter(valid_615925, JString, required = false,
                                 default = newJString("InProgress"))
  if valid_615925 != nil:
    section.add "status", valid_615925
  var valid_615926 = query.getOrDefault("maxResults")
  valid_615926 = validateParameter(valid_615926, JInt, required = false, default = nil)
  if valid_615926 != nil:
    section.add "maxResults", valid_615926
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615927 = header.getOrDefault("X-Amz-Signature")
  valid_615927 = validateParameter(valid_615927, JString, required = false,
                                 default = nil)
  if valid_615927 != nil:
    section.add "X-Amz-Signature", valid_615927
  var valid_615928 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615928 = validateParameter(valid_615928, JString, required = false,
                                 default = nil)
  if valid_615928 != nil:
    section.add "X-Amz-Content-Sha256", valid_615928
  var valid_615929 = header.getOrDefault("X-Amz-Date")
  valid_615929 = validateParameter(valid_615929, JString, required = false,
                                 default = nil)
  if valid_615929 != nil:
    section.add "X-Amz-Date", valid_615929
  var valid_615930 = header.getOrDefault("X-Amz-Credential")
  valid_615930 = validateParameter(valid_615930, JString, required = false,
                                 default = nil)
  if valid_615930 != nil:
    section.add "X-Amz-Credential", valid_615930
  var valid_615931 = header.getOrDefault("X-Amz-Security-Token")
  valid_615931 = validateParameter(valid_615931, JString, required = false,
                                 default = nil)
  if valid_615931 != nil:
    section.add "X-Amz-Security-Token", valid_615931
  var valid_615932 = header.getOrDefault("X-Amz-Algorithm")
  valid_615932 = validateParameter(valid_615932, JString, required = false,
                                 default = nil)
  if valid_615932 != nil:
    section.add "X-Amz-Algorithm", valid_615932
  var valid_615933 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615933 = validateParameter(valid_615933, JString, required = false,
                                 default = nil)
  if valid_615933 != nil:
    section.add "X-Amz-SignedHeaders", valid_615933
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615934: Call_ListThingRegistrationTasks_615921; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List bulk thing provisioning tasks.
  ## 
  let valid = call_615934.validator(path, query, header, formData, body)
  let scheme = call_615934.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615934.url(scheme.get, call_615934.host, call_615934.base,
                         call_615934.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615934, url, valid)

proc call*(call_615935: Call_ListThingRegistrationTasks_615921;
          nextToken: string = ""; status: string = "InProgress"; maxResults: int = 0): Recallable =
  ## listThingRegistrationTasks
  ## List bulk thing provisioning tasks.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : The status of the bulk thing provisioning task.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_615936 = newJObject()
  add(query_615936, "nextToken", newJString(nextToken))
  add(query_615936, "status", newJString(status))
  add(query_615936, "maxResults", newJInt(maxResults))
  result = call_615935.call(nil, query_615936, nil, nil, nil)

var listThingRegistrationTasks* = Call_ListThingRegistrationTasks_615921(
    name: "listThingRegistrationTasks", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks",
    validator: validate_ListThingRegistrationTasks_615922, base: "/",
    url: url_ListThingRegistrationTasks_615923,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingTypes_615951 = ref object of OpenApiRestCall_612658
proc url_ListThingTypes_615953(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThingTypes_615952(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the existing thing types.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   thingTypeName: JString
  ##                : The name of the thing type.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  section = newJObject()
  var valid_615954 = query.getOrDefault("nextToken")
  valid_615954 = validateParameter(valid_615954, JString, required = false,
                                 default = nil)
  if valid_615954 != nil:
    section.add "nextToken", valid_615954
  var valid_615955 = query.getOrDefault("thingTypeName")
  valid_615955 = validateParameter(valid_615955, JString, required = false,
                                 default = nil)
  if valid_615955 != nil:
    section.add "thingTypeName", valid_615955
  var valid_615956 = query.getOrDefault("maxResults")
  valid_615956 = validateParameter(valid_615956, JInt, required = false, default = nil)
  if valid_615956 != nil:
    section.add "maxResults", valid_615956
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615957 = header.getOrDefault("X-Amz-Signature")
  valid_615957 = validateParameter(valid_615957, JString, required = false,
                                 default = nil)
  if valid_615957 != nil:
    section.add "X-Amz-Signature", valid_615957
  var valid_615958 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615958 = validateParameter(valid_615958, JString, required = false,
                                 default = nil)
  if valid_615958 != nil:
    section.add "X-Amz-Content-Sha256", valid_615958
  var valid_615959 = header.getOrDefault("X-Amz-Date")
  valid_615959 = validateParameter(valid_615959, JString, required = false,
                                 default = nil)
  if valid_615959 != nil:
    section.add "X-Amz-Date", valid_615959
  var valid_615960 = header.getOrDefault("X-Amz-Credential")
  valid_615960 = validateParameter(valid_615960, JString, required = false,
                                 default = nil)
  if valid_615960 != nil:
    section.add "X-Amz-Credential", valid_615960
  var valid_615961 = header.getOrDefault("X-Amz-Security-Token")
  valid_615961 = validateParameter(valid_615961, JString, required = false,
                                 default = nil)
  if valid_615961 != nil:
    section.add "X-Amz-Security-Token", valid_615961
  var valid_615962 = header.getOrDefault("X-Amz-Algorithm")
  valid_615962 = validateParameter(valid_615962, JString, required = false,
                                 default = nil)
  if valid_615962 != nil:
    section.add "X-Amz-Algorithm", valid_615962
  var valid_615963 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615963 = validateParameter(valid_615963, JString, required = false,
                                 default = nil)
  if valid_615963 != nil:
    section.add "X-Amz-SignedHeaders", valid_615963
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615964: Call_ListThingTypes_615951; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the existing thing types.
  ## 
  let valid = call_615964.validator(path, query, header, formData, body)
  let scheme = call_615964.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615964.url(scheme.get, call_615964.host, call_615964.base,
                         call_615964.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615964, url, valid)

proc call*(call_615965: Call_ListThingTypes_615951; nextToken: string = "";
          thingTypeName: string = ""; maxResults: int = 0): Recallable =
  ## listThingTypes
  ## Lists the existing thing types.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingTypeName: string
  ##                : The name of the thing type.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  var query_615966 = newJObject()
  add(query_615966, "nextToken", newJString(nextToken))
  add(query_615966, "thingTypeName", newJString(thingTypeName))
  add(query_615966, "maxResults", newJInt(maxResults))
  result = call_615965.call(nil, query_615966, nil, nil, nil)

var listThingTypes* = Call_ListThingTypes_615951(name: "listThingTypes",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/thing-types",
    validator: validate_ListThingTypes_615952, base: "/", url: url_ListThingTypes_615953,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterThing_615985 = ref object of OpenApiRestCall_612658
proc url_RegisterThing_615987(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RegisterThing_615986(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615988 = header.getOrDefault("X-Amz-Signature")
  valid_615988 = validateParameter(valid_615988, JString, required = false,
                                 default = nil)
  if valid_615988 != nil:
    section.add "X-Amz-Signature", valid_615988
  var valid_615989 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615989 = validateParameter(valid_615989, JString, required = false,
                                 default = nil)
  if valid_615989 != nil:
    section.add "X-Amz-Content-Sha256", valid_615989
  var valid_615990 = header.getOrDefault("X-Amz-Date")
  valid_615990 = validateParameter(valid_615990, JString, required = false,
                                 default = nil)
  if valid_615990 != nil:
    section.add "X-Amz-Date", valid_615990
  var valid_615991 = header.getOrDefault("X-Amz-Credential")
  valid_615991 = validateParameter(valid_615991, JString, required = false,
                                 default = nil)
  if valid_615991 != nil:
    section.add "X-Amz-Credential", valid_615991
  var valid_615992 = header.getOrDefault("X-Amz-Security-Token")
  valid_615992 = validateParameter(valid_615992, JString, required = false,
                                 default = nil)
  if valid_615992 != nil:
    section.add "X-Amz-Security-Token", valid_615992
  var valid_615993 = header.getOrDefault("X-Amz-Algorithm")
  valid_615993 = validateParameter(valid_615993, JString, required = false,
                                 default = nil)
  if valid_615993 != nil:
    section.add "X-Amz-Algorithm", valid_615993
  var valid_615994 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615994 = validateParameter(valid_615994, JString, required = false,
                                 default = nil)
  if valid_615994 != nil:
    section.add "X-Amz-SignedHeaders", valid_615994
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_615996: Call_RegisterThing_615985; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.
  ## 
  let valid = call_615996.validator(path, query, header, formData, body)
  let scheme = call_615996.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615996.url(scheme.get, call_615996.host, call_615996.base,
                         call_615996.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615996, url, valid)

proc call*(call_615997: Call_RegisterThing_615985; body: JsonNode): Recallable =
  ## registerThing
  ## Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.
  ##   body: JObject (required)
  var body_615998 = newJObject()
  if body != nil:
    body_615998 = body
  result = call_615997.call(nil, nil, nil, nil, body_615998)

var registerThing* = Call_RegisterThing_615985(name: "registerThing",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/things",
    validator: validate_RegisterThing_615986, base: "/", url: url_RegisterThing_615987,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThings_615967 = ref object of OpenApiRestCall_612658
proc url_ListThings_615969(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThings_615968(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   attributeName: JString
  ##                : The attribute name used to search for things.
  ##   thingTypeName: JString
  ##                : The name of the thing type used to search for things.
  ##   attributeValue: JString
  ##                 : The attribute value used to search for things.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  section = newJObject()
  var valid_615970 = query.getOrDefault("nextToken")
  valid_615970 = validateParameter(valid_615970, JString, required = false,
                                 default = nil)
  if valid_615970 != nil:
    section.add "nextToken", valid_615970
  var valid_615971 = query.getOrDefault("attributeName")
  valid_615971 = validateParameter(valid_615971, JString, required = false,
                                 default = nil)
  if valid_615971 != nil:
    section.add "attributeName", valid_615971
  var valid_615972 = query.getOrDefault("thingTypeName")
  valid_615972 = validateParameter(valid_615972, JString, required = false,
                                 default = nil)
  if valid_615972 != nil:
    section.add "thingTypeName", valid_615972
  var valid_615973 = query.getOrDefault("attributeValue")
  valid_615973 = validateParameter(valid_615973, JString, required = false,
                                 default = nil)
  if valid_615973 != nil:
    section.add "attributeValue", valid_615973
  var valid_615974 = query.getOrDefault("maxResults")
  valid_615974 = validateParameter(valid_615974, JInt, required = false, default = nil)
  if valid_615974 != nil:
    section.add "maxResults", valid_615974
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_615975 = header.getOrDefault("X-Amz-Signature")
  valid_615975 = validateParameter(valid_615975, JString, required = false,
                                 default = nil)
  if valid_615975 != nil:
    section.add "X-Amz-Signature", valid_615975
  var valid_615976 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_615976 = validateParameter(valid_615976, JString, required = false,
                                 default = nil)
  if valid_615976 != nil:
    section.add "X-Amz-Content-Sha256", valid_615976
  var valid_615977 = header.getOrDefault("X-Amz-Date")
  valid_615977 = validateParameter(valid_615977, JString, required = false,
                                 default = nil)
  if valid_615977 != nil:
    section.add "X-Amz-Date", valid_615977
  var valid_615978 = header.getOrDefault("X-Amz-Credential")
  valid_615978 = validateParameter(valid_615978, JString, required = false,
                                 default = nil)
  if valid_615978 != nil:
    section.add "X-Amz-Credential", valid_615978
  var valid_615979 = header.getOrDefault("X-Amz-Security-Token")
  valid_615979 = validateParameter(valid_615979, JString, required = false,
                                 default = nil)
  if valid_615979 != nil:
    section.add "X-Amz-Security-Token", valid_615979
  var valid_615980 = header.getOrDefault("X-Amz-Algorithm")
  valid_615980 = validateParameter(valid_615980, JString, required = false,
                                 default = nil)
  if valid_615980 != nil:
    section.add "X-Amz-Algorithm", valid_615980
  var valid_615981 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_615981 = validateParameter(valid_615981, JString, required = false,
                                 default = nil)
  if valid_615981 != nil:
    section.add "X-Amz-SignedHeaders", valid_615981
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_615982: Call_ListThings_615967; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ## 
  let valid = call_615982.validator(path, query, header, formData, body)
  let scheme = call_615982.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_615982.url(scheme.get, call_615982.host, call_615982.base,
                         call_615982.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_615982, url, valid)

proc call*(call_615983: Call_ListThings_615967; nextToken: string = "";
          attributeName: string = ""; thingTypeName: string = "";
          attributeValue: string = ""; maxResults: int = 0): Recallable =
  ## listThings
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   attributeName: string
  ##                : The attribute name used to search for things.
  ##   thingTypeName: string
  ##                : The name of the thing type used to search for things.
  ##   attributeValue: string
  ##                 : The attribute value used to search for things.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  var query_615984 = newJObject()
  add(query_615984, "nextToken", newJString(nextToken))
  add(query_615984, "attributeName", newJString(attributeName))
  add(query_615984, "thingTypeName", newJString(thingTypeName))
  add(query_615984, "attributeValue", newJString(attributeValue))
  add(query_615984, "maxResults", newJInt(maxResults))
  result = call_615983.call(nil, query_615984, nil, nil, nil)

var listThings* = Call_ListThings_615967(name: "listThings",
                                      meth: HttpMethod.HttpGet,
                                      host: "iot.amazonaws.com", route: "/things",
                                      validator: validate_ListThings_615968,
                                      base: "/", url: url_ListThings_615969,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingsInBillingGroup_615999 = ref object of OpenApiRestCall_612658
proc url_ListThingsInBillingGroup_616001(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingsInBillingGroup_616000(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the things you have added to the given billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_616002 = path.getOrDefault("billingGroupName")
  valid_616002 = validateParameter(valid_616002, JString, required = true,
                                 default = nil)
  if valid_616002 != nil:
    section.add "billingGroupName", valid_616002
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_616003 = query.getOrDefault("nextToken")
  valid_616003 = validateParameter(valid_616003, JString, required = false,
                                 default = nil)
  if valid_616003 != nil:
    section.add "nextToken", valid_616003
  var valid_616004 = query.getOrDefault("maxResults")
  valid_616004 = validateParameter(valid_616004, JInt, required = false, default = nil)
  if valid_616004 != nil:
    section.add "maxResults", valid_616004
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616005 = header.getOrDefault("X-Amz-Signature")
  valid_616005 = validateParameter(valid_616005, JString, required = false,
                                 default = nil)
  if valid_616005 != nil:
    section.add "X-Amz-Signature", valid_616005
  var valid_616006 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616006 = validateParameter(valid_616006, JString, required = false,
                                 default = nil)
  if valid_616006 != nil:
    section.add "X-Amz-Content-Sha256", valid_616006
  var valid_616007 = header.getOrDefault("X-Amz-Date")
  valid_616007 = validateParameter(valid_616007, JString, required = false,
                                 default = nil)
  if valid_616007 != nil:
    section.add "X-Amz-Date", valid_616007
  var valid_616008 = header.getOrDefault("X-Amz-Credential")
  valid_616008 = validateParameter(valid_616008, JString, required = false,
                                 default = nil)
  if valid_616008 != nil:
    section.add "X-Amz-Credential", valid_616008
  var valid_616009 = header.getOrDefault("X-Amz-Security-Token")
  valid_616009 = validateParameter(valid_616009, JString, required = false,
                                 default = nil)
  if valid_616009 != nil:
    section.add "X-Amz-Security-Token", valid_616009
  var valid_616010 = header.getOrDefault("X-Amz-Algorithm")
  valid_616010 = validateParameter(valid_616010, JString, required = false,
                                 default = nil)
  if valid_616010 != nil:
    section.add "X-Amz-Algorithm", valid_616010
  var valid_616011 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616011 = validateParameter(valid_616011, JString, required = false,
                                 default = nil)
  if valid_616011 != nil:
    section.add "X-Amz-SignedHeaders", valid_616011
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616012: Call_ListThingsInBillingGroup_615999; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things you have added to the given billing group.
  ## 
  let valid = call_616012.validator(path, query, header, formData, body)
  let scheme = call_616012.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616012.url(scheme.get, call_616012.host, call_616012.base,
                         call_616012.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616012, url, valid)

proc call*(call_616013: Call_ListThingsInBillingGroup_615999;
          billingGroupName: string; nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listThingsInBillingGroup
  ## Lists the things you have added to the given billing group.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var path_616014 = newJObject()
  var query_616015 = newJObject()
  add(query_616015, "nextToken", newJString(nextToken))
  add(path_616014, "billingGroupName", newJString(billingGroupName))
  add(query_616015, "maxResults", newJInt(maxResults))
  result = call_616013.call(path_616014, query_616015, nil, nil, nil)

var listThingsInBillingGroup* = Call_ListThingsInBillingGroup_615999(
    name: "listThingsInBillingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}/things",
    validator: validate_ListThingsInBillingGroup_616000, base: "/",
    url: url_ListThingsInBillingGroup_616001, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingsInThingGroup_616016 = ref object of OpenApiRestCall_612658
proc url_ListThingsInThingGroup_616018(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingsInThingGroup_616017(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the things in the specified group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_616019 = path.getOrDefault("thingGroupName")
  valid_616019 = validateParameter(valid_616019, JString, required = true,
                                 default = nil)
  if valid_616019 != nil:
    section.add "thingGroupName", valid_616019
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   recursive: JBool
  ##            : When true, list things in this thing group and in all child groups as well.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_616020 = query.getOrDefault("nextToken")
  valid_616020 = validateParameter(valid_616020, JString, required = false,
                                 default = nil)
  if valid_616020 != nil:
    section.add "nextToken", valid_616020
  var valid_616021 = query.getOrDefault("recursive")
  valid_616021 = validateParameter(valid_616021, JBool, required = false, default = nil)
  if valid_616021 != nil:
    section.add "recursive", valid_616021
  var valid_616022 = query.getOrDefault("maxResults")
  valid_616022 = validateParameter(valid_616022, JInt, required = false, default = nil)
  if valid_616022 != nil:
    section.add "maxResults", valid_616022
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616023 = header.getOrDefault("X-Amz-Signature")
  valid_616023 = validateParameter(valid_616023, JString, required = false,
                                 default = nil)
  if valid_616023 != nil:
    section.add "X-Amz-Signature", valid_616023
  var valid_616024 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616024 = validateParameter(valid_616024, JString, required = false,
                                 default = nil)
  if valid_616024 != nil:
    section.add "X-Amz-Content-Sha256", valid_616024
  var valid_616025 = header.getOrDefault("X-Amz-Date")
  valid_616025 = validateParameter(valid_616025, JString, required = false,
                                 default = nil)
  if valid_616025 != nil:
    section.add "X-Amz-Date", valid_616025
  var valid_616026 = header.getOrDefault("X-Amz-Credential")
  valid_616026 = validateParameter(valid_616026, JString, required = false,
                                 default = nil)
  if valid_616026 != nil:
    section.add "X-Amz-Credential", valid_616026
  var valid_616027 = header.getOrDefault("X-Amz-Security-Token")
  valid_616027 = validateParameter(valid_616027, JString, required = false,
                                 default = nil)
  if valid_616027 != nil:
    section.add "X-Amz-Security-Token", valid_616027
  var valid_616028 = header.getOrDefault("X-Amz-Algorithm")
  valid_616028 = validateParameter(valid_616028, JString, required = false,
                                 default = nil)
  if valid_616028 != nil:
    section.add "X-Amz-Algorithm", valid_616028
  var valid_616029 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616029 = validateParameter(valid_616029, JString, required = false,
                                 default = nil)
  if valid_616029 != nil:
    section.add "X-Amz-SignedHeaders", valid_616029
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616030: Call_ListThingsInThingGroup_616016; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things in the specified group.
  ## 
  let valid = call_616030.validator(path, query, header, formData, body)
  let scheme = call_616030.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616030.url(scheme.get, call_616030.host, call_616030.base,
                         call_616030.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616030, url, valid)

proc call*(call_616031: Call_ListThingsInThingGroup_616016; thingGroupName: string;
          nextToken: string = ""; recursive: bool = false; maxResults: int = 0): Recallable =
  ## listThingsInThingGroup
  ## Lists the things in the specified group.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: string (required)
  ##                 : The thing group name.
  ##   recursive: bool
  ##            : When true, list things in this thing group and in all child groups as well.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_616032 = newJObject()
  var query_616033 = newJObject()
  add(query_616033, "nextToken", newJString(nextToken))
  add(path_616032, "thingGroupName", newJString(thingGroupName))
  add(query_616033, "recursive", newJBool(recursive))
  add(query_616033, "maxResults", newJInt(maxResults))
  result = call_616031.call(path_616032, query_616033, nil, nil, nil)

var listThingsInThingGroup* = Call_ListThingsInThingGroup_616016(
    name: "listThingsInThingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-groups/{thingGroupName}/things",
    validator: validate_ListThingsInThingGroup_616017, base: "/",
    url: url_ListThingsInThingGroup_616018, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTopicRules_616034 = ref object of OpenApiRestCall_612658
proc url_ListTopicRules_616036(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListTopicRules_616035(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the rules for the specific topic.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token used to retrieve the next value.
  ##   topic: JString
  ##        : The topic.
  ##   ruleDisabled: JBool
  ##               : Specifies whether the rule is disabled.
  ##   maxResults: JInt
  ##             : The maximum number of results to return.
  section = newJObject()
  var valid_616037 = query.getOrDefault("nextToken")
  valid_616037 = validateParameter(valid_616037, JString, required = false,
                                 default = nil)
  if valid_616037 != nil:
    section.add "nextToken", valid_616037
  var valid_616038 = query.getOrDefault("topic")
  valid_616038 = validateParameter(valid_616038, JString, required = false,
                                 default = nil)
  if valid_616038 != nil:
    section.add "topic", valid_616038
  var valid_616039 = query.getOrDefault("ruleDisabled")
  valid_616039 = validateParameter(valid_616039, JBool, required = false, default = nil)
  if valid_616039 != nil:
    section.add "ruleDisabled", valid_616039
  var valid_616040 = query.getOrDefault("maxResults")
  valid_616040 = validateParameter(valid_616040, JInt, required = false, default = nil)
  if valid_616040 != nil:
    section.add "maxResults", valid_616040
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616041 = header.getOrDefault("X-Amz-Signature")
  valid_616041 = validateParameter(valid_616041, JString, required = false,
                                 default = nil)
  if valid_616041 != nil:
    section.add "X-Amz-Signature", valid_616041
  var valid_616042 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616042 = validateParameter(valid_616042, JString, required = false,
                                 default = nil)
  if valid_616042 != nil:
    section.add "X-Amz-Content-Sha256", valid_616042
  var valid_616043 = header.getOrDefault("X-Amz-Date")
  valid_616043 = validateParameter(valid_616043, JString, required = false,
                                 default = nil)
  if valid_616043 != nil:
    section.add "X-Amz-Date", valid_616043
  var valid_616044 = header.getOrDefault("X-Amz-Credential")
  valid_616044 = validateParameter(valid_616044, JString, required = false,
                                 default = nil)
  if valid_616044 != nil:
    section.add "X-Amz-Credential", valid_616044
  var valid_616045 = header.getOrDefault("X-Amz-Security-Token")
  valid_616045 = validateParameter(valid_616045, JString, required = false,
                                 default = nil)
  if valid_616045 != nil:
    section.add "X-Amz-Security-Token", valid_616045
  var valid_616046 = header.getOrDefault("X-Amz-Algorithm")
  valid_616046 = validateParameter(valid_616046, JString, required = false,
                                 default = nil)
  if valid_616046 != nil:
    section.add "X-Amz-Algorithm", valid_616046
  var valid_616047 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616047 = validateParameter(valid_616047, JString, required = false,
                                 default = nil)
  if valid_616047 != nil:
    section.add "X-Amz-SignedHeaders", valid_616047
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616048: Call_ListTopicRules_616034; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the rules for the specific topic.
  ## 
  let valid = call_616048.validator(path, query, header, formData, body)
  let scheme = call_616048.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616048.url(scheme.get, call_616048.host, call_616048.base,
                         call_616048.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616048, url, valid)

proc call*(call_616049: Call_ListTopicRules_616034; nextToken: string = "";
          topic: string = ""; ruleDisabled: bool = false; maxResults: int = 0): Recallable =
  ## listTopicRules
  ## Lists the rules for the specific topic.
  ##   nextToken: string
  ##            : A token used to retrieve the next value.
  ##   topic: string
  ##        : The topic.
  ##   ruleDisabled: bool
  ##               : Specifies whether the rule is disabled.
  ##   maxResults: int
  ##             : The maximum number of results to return.
  var query_616050 = newJObject()
  add(query_616050, "nextToken", newJString(nextToken))
  add(query_616050, "topic", newJString(topic))
  add(query_616050, "ruleDisabled", newJBool(ruleDisabled))
  add(query_616050, "maxResults", newJInt(maxResults))
  result = call_616049.call(nil, query_616050, nil, nil, nil)

var listTopicRules* = Call_ListTopicRules_616034(name: "listTopicRules",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/rules",
    validator: validate_ListTopicRules_616035, base: "/", url: url_ListTopicRules_616036,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetV2LoggingLevel_616067 = ref object of OpenApiRestCall_612658
proc url_SetV2LoggingLevel_616069(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetV2LoggingLevel_616068(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Sets the logging level.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616070 = header.getOrDefault("X-Amz-Signature")
  valid_616070 = validateParameter(valid_616070, JString, required = false,
                                 default = nil)
  if valid_616070 != nil:
    section.add "X-Amz-Signature", valid_616070
  var valid_616071 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616071 = validateParameter(valid_616071, JString, required = false,
                                 default = nil)
  if valid_616071 != nil:
    section.add "X-Amz-Content-Sha256", valid_616071
  var valid_616072 = header.getOrDefault("X-Amz-Date")
  valid_616072 = validateParameter(valid_616072, JString, required = false,
                                 default = nil)
  if valid_616072 != nil:
    section.add "X-Amz-Date", valid_616072
  var valid_616073 = header.getOrDefault("X-Amz-Credential")
  valid_616073 = validateParameter(valid_616073, JString, required = false,
                                 default = nil)
  if valid_616073 != nil:
    section.add "X-Amz-Credential", valid_616073
  var valid_616074 = header.getOrDefault("X-Amz-Security-Token")
  valid_616074 = validateParameter(valid_616074, JString, required = false,
                                 default = nil)
  if valid_616074 != nil:
    section.add "X-Amz-Security-Token", valid_616074
  var valid_616075 = header.getOrDefault("X-Amz-Algorithm")
  valid_616075 = validateParameter(valid_616075, JString, required = false,
                                 default = nil)
  if valid_616075 != nil:
    section.add "X-Amz-Algorithm", valid_616075
  var valid_616076 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616076 = validateParameter(valid_616076, JString, required = false,
                                 default = nil)
  if valid_616076 != nil:
    section.add "X-Amz-SignedHeaders", valid_616076
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_616078: Call_SetV2LoggingLevel_616067; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the logging level.
  ## 
  let valid = call_616078.validator(path, query, header, formData, body)
  let scheme = call_616078.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616078.url(scheme.get, call_616078.host, call_616078.base,
                         call_616078.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616078, url, valid)

proc call*(call_616079: Call_SetV2LoggingLevel_616067; body: JsonNode): Recallable =
  ## setV2LoggingLevel
  ## Sets the logging level.
  ##   body: JObject (required)
  var body_616080 = newJObject()
  if body != nil:
    body_616080 = body
  result = call_616079.call(nil, nil, nil, nil, body_616080)

var setV2LoggingLevel* = Call_SetV2LoggingLevel_616067(name: "setV2LoggingLevel",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/v2LoggingLevel",
    validator: validate_SetV2LoggingLevel_616068, base: "/",
    url: url_SetV2LoggingLevel_616069, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListV2LoggingLevels_616051 = ref object of OpenApiRestCall_612658
proc url_ListV2LoggingLevels_616053(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListV2LoggingLevels_616052(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists logging levels.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token used to get the next set of results, or <b>null</b> if there are no additional results.
  ##   targetType: JString
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_616054 = query.getOrDefault("nextToken")
  valid_616054 = validateParameter(valid_616054, JString, required = false,
                                 default = nil)
  if valid_616054 != nil:
    section.add "nextToken", valid_616054
  var valid_616055 = query.getOrDefault("targetType")
  valid_616055 = validateParameter(valid_616055, JString, required = false,
                                 default = newJString("DEFAULT"))
  if valid_616055 != nil:
    section.add "targetType", valid_616055
  var valid_616056 = query.getOrDefault("maxResults")
  valid_616056 = validateParameter(valid_616056, JInt, required = false, default = nil)
  if valid_616056 != nil:
    section.add "maxResults", valid_616056
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616057 = header.getOrDefault("X-Amz-Signature")
  valid_616057 = validateParameter(valid_616057, JString, required = false,
                                 default = nil)
  if valid_616057 != nil:
    section.add "X-Amz-Signature", valid_616057
  var valid_616058 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616058 = validateParameter(valid_616058, JString, required = false,
                                 default = nil)
  if valid_616058 != nil:
    section.add "X-Amz-Content-Sha256", valid_616058
  var valid_616059 = header.getOrDefault("X-Amz-Date")
  valid_616059 = validateParameter(valid_616059, JString, required = false,
                                 default = nil)
  if valid_616059 != nil:
    section.add "X-Amz-Date", valid_616059
  var valid_616060 = header.getOrDefault("X-Amz-Credential")
  valid_616060 = validateParameter(valid_616060, JString, required = false,
                                 default = nil)
  if valid_616060 != nil:
    section.add "X-Amz-Credential", valid_616060
  var valid_616061 = header.getOrDefault("X-Amz-Security-Token")
  valid_616061 = validateParameter(valid_616061, JString, required = false,
                                 default = nil)
  if valid_616061 != nil:
    section.add "X-Amz-Security-Token", valid_616061
  var valid_616062 = header.getOrDefault("X-Amz-Algorithm")
  valid_616062 = validateParameter(valid_616062, JString, required = false,
                                 default = nil)
  if valid_616062 != nil:
    section.add "X-Amz-Algorithm", valid_616062
  var valid_616063 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616063 = validateParameter(valid_616063, JString, required = false,
                                 default = nil)
  if valid_616063 != nil:
    section.add "X-Amz-SignedHeaders", valid_616063
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616064: Call_ListV2LoggingLevels_616051; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists logging levels.
  ## 
  let valid = call_616064.validator(path, query, header, formData, body)
  let scheme = call_616064.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616064.url(scheme.get, call_616064.host, call_616064.base,
                         call_616064.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616064, url, valid)

proc call*(call_616065: Call_ListV2LoggingLevels_616051; nextToken: string = "";
          targetType: string = "DEFAULT"; maxResults: int = 0): Recallable =
  ## listV2LoggingLevels
  ## Lists logging levels.
  ##   nextToken: string
  ##            : The token used to get the next set of results, or <b>null</b> if there are no additional results.
  ##   targetType: string
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_616066 = newJObject()
  add(query_616066, "nextToken", newJString(nextToken))
  add(query_616066, "targetType", newJString(targetType))
  add(query_616066, "maxResults", newJInt(maxResults))
  result = call_616065.call(nil, query_616066, nil, nil, nil)

var listV2LoggingLevels* = Call_ListV2LoggingLevels_616051(
    name: "listV2LoggingLevels", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/v2LoggingLevel",
    validator: validate_ListV2LoggingLevels_616052, base: "/",
    url: url_ListV2LoggingLevels_616053, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListViolationEvents_616081 = ref object of OpenApiRestCall_612658
proc url_ListViolationEvents_616083(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListViolationEvents_616082(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endTime: JString (required)
  ##          : The end time for the alerts to be listed.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : The start time for the alerts to be listed.
  ##   securityProfileName: JString
  ##                      : A filter to limit results to those alerts generated by the specified security profile.
  ##   thingName: JString
  ##            : A filter to limit results to those alerts caused by the specified thing.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_616084 = query.getOrDefault("endTime")
  valid_616084 = validateParameter(valid_616084, JString, required = true,
                                 default = nil)
  if valid_616084 != nil:
    section.add "endTime", valid_616084
  var valid_616085 = query.getOrDefault("nextToken")
  valid_616085 = validateParameter(valid_616085, JString, required = false,
                                 default = nil)
  if valid_616085 != nil:
    section.add "nextToken", valid_616085
  var valid_616086 = query.getOrDefault("startTime")
  valid_616086 = validateParameter(valid_616086, JString, required = true,
                                 default = nil)
  if valid_616086 != nil:
    section.add "startTime", valid_616086
  var valid_616087 = query.getOrDefault("securityProfileName")
  valid_616087 = validateParameter(valid_616087, JString, required = false,
                                 default = nil)
  if valid_616087 != nil:
    section.add "securityProfileName", valid_616087
  var valid_616088 = query.getOrDefault("thingName")
  valid_616088 = validateParameter(valid_616088, JString, required = false,
                                 default = nil)
  if valid_616088 != nil:
    section.add "thingName", valid_616088
  var valid_616089 = query.getOrDefault("maxResults")
  valid_616089 = validateParameter(valid_616089, JInt, required = false, default = nil)
  if valid_616089 != nil:
    section.add "maxResults", valid_616089
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616090 = header.getOrDefault("X-Amz-Signature")
  valid_616090 = validateParameter(valid_616090, JString, required = false,
                                 default = nil)
  if valid_616090 != nil:
    section.add "X-Amz-Signature", valid_616090
  var valid_616091 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616091 = validateParameter(valid_616091, JString, required = false,
                                 default = nil)
  if valid_616091 != nil:
    section.add "X-Amz-Content-Sha256", valid_616091
  var valid_616092 = header.getOrDefault("X-Amz-Date")
  valid_616092 = validateParameter(valid_616092, JString, required = false,
                                 default = nil)
  if valid_616092 != nil:
    section.add "X-Amz-Date", valid_616092
  var valid_616093 = header.getOrDefault("X-Amz-Credential")
  valid_616093 = validateParameter(valid_616093, JString, required = false,
                                 default = nil)
  if valid_616093 != nil:
    section.add "X-Amz-Credential", valid_616093
  var valid_616094 = header.getOrDefault("X-Amz-Security-Token")
  valid_616094 = validateParameter(valid_616094, JString, required = false,
                                 default = nil)
  if valid_616094 != nil:
    section.add "X-Amz-Security-Token", valid_616094
  var valid_616095 = header.getOrDefault("X-Amz-Algorithm")
  valid_616095 = validateParameter(valid_616095, JString, required = false,
                                 default = nil)
  if valid_616095 != nil:
    section.add "X-Amz-Algorithm", valid_616095
  var valid_616096 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616096 = validateParameter(valid_616096, JString, required = false,
                                 default = nil)
  if valid_616096 != nil:
    section.add "X-Amz-SignedHeaders", valid_616096
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616097: Call_ListViolationEvents_616081; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ## 
  let valid = call_616097.validator(path, query, header, formData, body)
  let scheme = call_616097.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616097.url(scheme.get, call_616097.host, call_616097.base,
                         call_616097.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616097, url, valid)

proc call*(call_616098: Call_ListViolationEvents_616081; endTime: string;
          startTime: string; nextToken: string = ""; securityProfileName: string = "";
          thingName: string = ""; maxResults: int = 0): Recallable =
  ## listViolationEvents
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ##   endTime: string (required)
  ##          : The end time for the alerts to be listed.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : The start time for the alerts to be listed.
  ##   securityProfileName: string
  ##                      : A filter to limit results to those alerts generated by the specified security profile.
  ##   thingName: string
  ##            : A filter to limit results to those alerts caused by the specified thing.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_616099 = newJObject()
  add(query_616099, "endTime", newJString(endTime))
  add(query_616099, "nextToken", newJString(nextToken))
  add(query_616099, "startTime", newJString(startTime))
  add(query_616099, "securityProfileName", newJString(securityProfileName))
  add(query_616099, "thingName", newJString(thingName))
  add(query_616099, "maxResults", newJInt(maxResults))
  result = call_616098.call(nil, query_616099, nil, nil, nil)

var listViolationEvents* = Call_ListViolationEvents_616081(
    name: "listViolationEvents", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/violation-events#startTime&endTime",
    validator: validate_ListViolationEvents_616082, base: "/",
    url: url_ListViolationEvents_616083, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterCACertificate_616100 = ref object of OpenApiRestCall_612658
proc url_RegisterCACertificate_616102(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RegisterCACertificate_616101(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   allowAutoRegistration: JBool
  ##                        : Allows this CA certificate to be used for auto registration of device certificates.
  ##   setAsActive: JBool
  ##              : A boolean value that specifies if the CA certificate is set to active.
  section = newJObject()
  var valid_616103 = query.getOrDefault("allowAutoRegistration")
  valid_616103 = validateParameter(valid_616103, JBool, required = false, default = nil)
  if valid_616103 != nil:
    section.add "allowAutoRegistration", valid_616103
  var valid_616104 = query.getOrDefault("setAsActive")
  valid_616104 = validateParameter(valid_616104, JBool, required = false, default = nil)
  if valid_616104 != nil:
    section.add "setAsActive", valid_616104
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616105 = header.getOrDefault("X-Amz-Signature")
  valid_616105 = validateParameter(valid_616105, JString, required = false,
                                 default = nil)
  if valid_616105 != nil:
    section.add "X-Amz-Signature", valid_616105
  var valid_616106 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616106 = validateParameter(valid_616106, JString, required = false,
                                 default = nil)
  if valid_616106 != nil:
    section.add "X-Amz-Content-Sha256", valid_616106
  var valid_616107 = header.getOrDefault("X-Amz-Date")
  valid_616107 = validateParameter(valid_616107, JString, required = false,
                                 default = nil)
  if valid_616107 != nil:
    section.add "X-Amz-Date", valid_616107
  var valid_616108 = header.getOrDefault("X-Amz-Credential")
  valid_616108 = validateParameter(valid_616108, JString, required = false,
                                 default = nil)
  if valid_616108 != nil:
    section.add "X-Amz-Credential", valid_616108
  var valid_616109 = header.getOrDefault("X-Amz-Security-Token")
  valid_616109 = validateParameter(valid_616109, JString, required = false,
                                 default = nil)
  if valid_616109 != nil:
    section.add "X-Amz-Security-Token", valid_616109
  var valid_616110 = header.getOrDefault("X-Amz-Algorithm")
  valid_616110 = validateParameter(valid_616110, JString, required = false,
                                 default = nil)
  if valid_616110 != nil:
    section.add "X-Amz-Algorithm", valid_616110
  var valid_616111 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616111 = validateParameter(valid_616111, JString, required = false,
                                 default = nil)
  if valid_616111 != nil:
    section.add "X-Amz-SignedHeaders", valid_616111
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_616113: Call_RegisterCACertificate_616100; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ## 
  let valid = call_616113.validator(path, query, header, formData, body)
  let scheme = call_616113.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616113.url(scheme.get, call_616113.host, call_616113.base,
                         call_616113.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616113, url, valid)

proc call*(call_616114: Call_RegisterCACertificate_616100; body: JsonNode;
          allowAutoRegistration: bool = false; setAsActive: bool = false): Recallable =
  ## registerCACertificate
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ##   allowAutoRegistration: bool
  ##                        : Allows this CA certificate to be used for auto registration of device certificates.
  ##   setAsActive: bool
  ##              : A boolean value that specifies if the CA certificate is set to active.
  ##   body: JObject (required)
  var query_616115 = newJObject()
  var body_616116 = newJObject()
  add(query_616115, "allowAutoRegistration", newJBool(allowAutoRegistration))
  add(query_616115, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_616116 = body
  result = call_616114.call(nil, query_616115, nil, nil, body_616116)

var registerCACertificate* = Call_RegisterCACertificate_616100(
    name: "registerCACertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/cacertificate",
    validator: validate_RegisterCACertificate_616101, base: "/",
    url: url_RegisterCACertificate_616102, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterCertificate_616117 = ref object of OpenApiRestCall_612658
proc url_RegisterCertificate_616119(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RegisterCertificate_616118(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : A boolean value that specifies if the certificate is set to active.
  section = newJObject()
  var valid_616120 = query.getOrDefault("setAsActive")
  valid_616120 = validateParameter(valid_616120, JBool, required = false, default = nil)
  if valid_616120 != nil:
    section.add "setAsActive", valid_616120
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616121 = header.getOrDefault("X-Amz-Signature")
  valid_616121 = validateParameter(valid_616121, JString, required = false,
                                 default = nil)
  if valid_616121 != nil:
    section.add "X-Amz-Signature", valid_616121
  var valid_616122 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616122 = validateParameter(valid_616122, JString, required = false,
                                 default = nil)
  if valid_616122 != nil:
    section.add "X-Amz-Content-Sha256", valid_616122
  var valid_616123 = header.getOrDefault("X-Amz-Date")
  valid_616123 = validateParameter(valid_616123, JString, required = false,
                                 default = nil)
  if valid_616123 != nil:
    section.add "X-Amz-Date", valid_616123
  var valid_616124 = header.getOrDefault("X-Amz-Credential")
  valid_616124 = validateParameter(valid_616124, JString, required = false,
                                 default = nil)
  if valid_616124 != nil:
    section.add "X-Amz-Credential", valid_616124
  var valid_616125 = header.getOrDefault("X-Amz-Security-Token")
  valid_616125 = validateParameter(valid_616125, JString, required = false,
                                 default = nil)
  if valid_616125 != nil:
    section.add "X-Amz-Security-Token", valid_616125
  var valid_616126 = header.getOrDefault("X-Amz-Algorithm")
  valid_616126 = validateParameter(valid_616126, JString, required = false,
                                 default = nil)
  if valid_616126 != nil:
    section.add "X-Amz-Algorithm", valid_616126
  var valid_616127 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616127 = validateParameter(valid_616127, JString, required = false,
                                 default = nil)
  if valid_616127 != nil:
    section.add "X-Amz-SignedHeaders", valid_616127
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_616129: Call_RegisterCertificate_616117; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ## 
  let valid = call_616129.validator(path, query, header, formData, body)
  let scheme = call_616129.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616129.url(scheme.get, call_616129.host, call_616129.base,
                         call_616129.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616129, url, valid)

proc call*(call_616130: Call_RegisterCertificate_616117; body: JsonNode;
          setAsActive: bool = false): Recallable =
  ## registerCertificate
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ##   setAsActive: bool
  ##              : A boolean value that specifies if the certificate is set to active.
  ##   body: JObject (required)
  var query_616131 = newJObject()
  var body_616132 = newJObject()
  add(query_616131, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_616132 = body
  result = call_616130.call(nil, query_616131, nil, nil, body_616132)

var registerCertificate* = Call_RegisterCertificate_616117(
    name: "registerCertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/certificate/register",
    validator: validate_RegisterCertificate_616118, base: "/",
    url: url_RegisterCertificate_616119, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RejectCertificateTransfer_616133 = ref object of OpenApiRestCall_612658
proc url_RejectCertificateTransfer_616135(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/reject-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_RejectCertificateTransfer_616134(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_616136 = path.getOrDefault("certificateId")
  valid_616136 = validateParameter(valid_616136, JString, required = true,
                                 default = nil)
  if valid_616136 != nil:
    section.add "certificateId", valid_616136
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616137 = header.getOrDefault("X-Amz-Signature")
  valid_616137 = validateParameter(valid_616137, JString, required = false,
                                 default = nil)
  if valid_616137 != nil:
    section.add "X-Amz-Signature", valid_616137
  var valid_616138 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616138 = validateParameter(valid_616138, JString, required = false,
                                 default = nil)
  if valid_616138 != nil:
    section.add "X-Amz-Content-Sha256", valid_616138
  var valid_616139 = header.getOrDefault("X-Amz-Date")
  valid_616139 = validateParameter(valid_616139, JString, required = false,
                                 default = nil)
  if valid_616139 != nil:
    section.add "X-Amz-Date", valid_616139
  var valid_616140 = header.getOrDefault("X-Amz-Credential")
  valid_616140 = validateParameter(valid_616140, JString, required = false,
                                 default = nil)
  if valid_616140 != nil:
    section.add "X-Amz-Credential", valid_616140
  var valid_616141 = header.getOrDefault("X-Amz-Security-Token")
  valid_616141 = validateParameter(valid_616141, JString, required = false,
                                 default = nil)
  if valid_616141 != nil:
    section.add "X-Amz-Security-Token", valid_616141
  var valid_616142 = header.getOrDefault("X-Amz-Algorithm")
  valid_616142 = validateParameter(valid_616142, JString, required = false,
                                 default = nil)
  if valid_616142 != nil:
    section.add "X-Amz-Algorithm", valid_616142
  var valid_616143 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616143 = validateParameter(valid_616143, JString, required = false,
                                 default = nil)
  if valid_616143 != nil:
    section.add "X-Amz-SignedHeaders", valid_616143
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_616145: Call_RejectCertificateTransfer_616133; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ## 
  let valid = call_616145.validator(path, query, header, formData, body)
  let scheme = call_616145.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616145.url(scheme.get, call_616145.host, call_616145.base,
                         call_616145.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616145, url, valid)

proc call*(call_616146: Call_RejectCertificateTransfer_616133; body: JsonNode;
          certificateId: string): Recallable =
  ## rejectCertificateTransfer
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ##   body: JObject (required)
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_616147 = newJObject()
  var body_616148 = newJObject()
  if body != nil:
    body_616148 = body
  add(path_616147, "certificateId", newJString(certificateId))
  result = call_616146.call(path_616147, nil, nil, nil, body_616148)

var rejectCertificateTransfer* = Call_RejectCertificateTransfer_616133(
    name: "rejectCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/reject-certificate-transfer/{certificateId}",
    validator: validate_RejectCertificateTransfer_616134, base: "/",
    url: url_RejectCertificateTransfer_616135,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveThingFromBillingGroup_616149 = ref object of OpenApiRestCall_612658
proc url_RemoveThingFromBillingGroup_616151(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RemoveThingFromBillingGroup_616150(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes the given thing from the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616152 = header.getOrDefault("X-Amz-Signature")
  valid_616152 = validateParameter(valid_616152, JString, required = false,
                                 default = nil)
  if valid_616152 != nil:
    section.add "X-Amz-Signature", valid_616152
  var valid_616153 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616153 = validateParameter(valid_616153, JString, required = false,
                                 default = nil)
  if valid_616153 != nil:
    section.add "X-Amz-Content-Sha256", valid_616153
  var valid_616154 = header.getOrDefault("X-Amz-Date")
  valid_616154 = validateParameter(valid_616154, JString, required = false,
                                 default = nil)
  if valid_616154 != nil:
    section.add "X-Amz-Date", valid_616154
  var valid_616155 = header.getOrDefault("X-Amz-Credential")
  valid_616155 = validateParameter(valid_616155, JString, required = false,
                                 default = nil)
  if valid_616155 != nil:
    section.add "X-Amz-Credential", valid_616155
  var valid_616156 = header.getOrDefault("X-Amz-Security-Token")
  valid_616156 = validateParameter(valid_616156, JString, required = false,
                                 default = nil)
  if valid_616156 != nil:
    section.add "X-Amz-Security-Token", valid_616156
  var valid_616157 = header.getOrDefault("X-Amz-Algorithm")
  valid_616157 = validateParameter(valid_616157, JString, required = false,
                                 default = nil)
  if valid_616157 != nil:
    section.add "X-Amz-Algorithm", valid_616157
  var valid_616158 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616158 = validateParameter(valid_616158, JString, required = false,
                                 default = nil)
  if valid_616158 != nil:
    section.add "X-Amz-SignedHeaders", valid_616158
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_616160: Call_RemoveThingFromBillingGroup_616149; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes the given thing from the billing group.
  ## 
  let valid = call_616160.validator(path, query, header, formData, body)
  let scheme = call_616160.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616160.url(scheme.get, call_616160.host, call_616160.base,
                         call_616160.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616160, url, valid)

proc call*(call_616161: Call_RemoveThingFromBillingGroup_616149; body: JsonNode): Recallable =
  ## removeThingFromBillingGroup
  ## Removes the given thing from the billing group.
  ##   body: JObject (required)
  var body_616162 = newJObject()
  if body != nil:
    body_616162 = body
  result = call_616161.call(nil, nil, nil, nil, body_616162)

var removeThingFromBillingGroup* = Call_RemoveThingFromBillingGroup_616149(
    name: "removeThingFromBillingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/billing-groups/removeThingFromBillingGroup",
    validator: validate_RemoveThingFromBillingGroup_616150, base: "/",
    url: url_RemoveThingFromBillingGroup_616151,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveThingFromThingGroup_616163 = ref object of OpenApiRestCall_612658
proc url_RemoveThingFromThingGroup_616165(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RemoveThingFromThingGroup_616164(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove the specified thing from the specified group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616166 = header.getOrDefault("X-Amz-Signature")
  valid_616166 = validateParameter(valid_616166, JString, required = false,
                                 default = nil)
  if valid_616166 != nil:
    section.add "X-Amz-Signature", valid_616166
  var valid_616167 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616167 = validateParameter(valid_616167, JString, required = false,
                                 default = nil)
  if valid_616167 != nil:
    section.add "X-Amz-Content-Sha256", valid_616167
  var valid_616168 = header.getOrDefault("X-Amz-Date")
  valid_616168 = validateParameter(valid_616168, JString, required = false,
                                 default = nil)
  if valid_616168 != nil:
    section.add "X-Amz-Date", valid_616168
  var valid_616169 = header.getOrDefault("X-Amz-Credential")
  valid_616169 = validateParameter(valid_616169, JString, required = false,
                                 default = nil)
  if valid_616169 != nil:
    section.add "X-Amz-Credential", valid_616169
  var valid_616170 = header.getOrDefault("X-Amz-Security-Token")
  valid_616170 = validateParameter(valid_616170, JString, required = false,
                                 default = nil)
  if valid_616170 != nil:
    section.add "X-Amz-Security-Token", valid_616170
  var valid_616171 = header.getOrDefault("X-Amz-Algorithm")
  valid_616171 = validateParameter(valid_616171, JString, required = false,
                                 default = nil)
  if valid_616171 != nil:
    section.add "X-Amz-Algorithm", valid_616171
  var valid_616172 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616172 = validateParameter(valid_616172, JString, required = false,
                                 default = nil)
  if valid_616172 != nil:
    section.add "X-Amz-SignedHeaders", valid_616172
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_616174: Call_RemoveThingFromThingGroup_616163; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Remove the specified thing from the specified group.
  ## 
  let valid = call_616174.validator(path, query, header, formData, body)
  let scheme = call_616174.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616174.url(scheme.get, call_616174.host, call_616174.base,
                         call_616174.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616174, url, valid)

proc call*(call_616175: Call_RemoveThingFromThingGroup_616163; body: JsonNode): Recallable =
  ## removeThingFromThingGroup
  ## Remove the specified thing from the specified group.
  ##   body: JObject (required)
  var body_616176 = newJObject()
  if body != nil:
    body_616176 = body
  result = call_616175.call(nil, nil, nil, nil, body_616176)

var removeThingFromThingGroup* = Call_RemoveThingFromThingGroup_616163(
    name: "removeThingFromThingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/removeThingFromThingGroup",
    validator: validate_RemoveThingFromThingGroup_616164, base: "/",
    url: url_RemoveThingFromThingGroup_616165,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_SearchIndex_616177 = ref object of OpenApiRestCall_612658
proc url_SearchIndex_616179(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SearchIndex_616178(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## The query search index.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616180 = header.getOrDefault("X-Amz-Signature")
  valid_616180 = validateParameter(valid_616180, JString, required = false,
                                 default = nil)
  if valid_616180 != nil:
    section.add "X-Amz-Signature", valid_616180
  var valid_616181 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616181 = validateParameter(valid_616181, JString, required = false,
                                 default = nil)
  if valid_616181 != nil:
    section.add "X-Amz-Content-Sha256", valid_616181
  var valid_616182 = header.getOrDefault("X-Amz-Date")
  valid_616182 = validateParameter(valid_616182, JString, required = false,
                                 default = nil)
  if valid_616182 != nil:
    section.add "X-Amz-Date", valid_616182
  var valid_616183 = header.getOrDefault("X-Amz-Credential")
  valid_616183 = validateParameter(valid_616183, JString, required = false,
                                 default = nil)
  if valid_616183 != nil:
    section.add "X-Amz-Credential", valid_616183
  var valid_616184 = header.getOrDefault("X-Amz-Security-Token")
  valid_616184 = validateParameter(valid_616184, JString, required = false,
                                 default = nil)
  if valid_616184 != nil:
    section.add "X-Amz-Security-Token", valid_616184
  var valid_616185 = header.getOrDefault("X-Amz-Algorithm")
  valid_616185 = validateParameter(valid_616185, JString, required = false,
                                 default = nil)
  if valid_616185 != nil:
    section.add "X-Amz-Algorithm", valid_616185
  var valid_616186 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616186 = validateParameter(valid_616186, JString, required = false,
                                 default = nil)
  if valid_616186 != nil:
    section.add "X-Amz-SignedHeaders", valid_616186
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_616188: Call_SearchIndex_616177; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The query search index.
  ## 
  let valid = call_616188.validator(path, query, header, formData, body)
  let scheme = call_616188.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616188.url(scheme.get, call_616188.host, call_616188.base,
                         call_616188.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616188, url, valid)

proc call*(call_616189: Call_SearchIndex_616177; body: JsonNode): Recallable =
  ## searchIndex
  ## The query search index.
  ##   body: JObject (required)
  var body_616190 = newJObject()
  if body != nil:
    body_616190 = body
  result = call_616189.call(nil, nil, nil, nil, body_616190)

var searchIndex* = Call_SearchIndex_616177(name: "searchIndex",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com",
                                        route: "/indices/search",
                                        validator: validate_SearchIndex_616178,
                                        base: "/", url: url_SearchIndex_616179,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartOnDemandAuditTask_616191 = ref object of OpenApiRestCall_612658
proc url_StartOnDemandAuditTask_616193(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_StartOnDemandAuditTask_616192(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts an on-demand Device Defender audit.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616194 = header.getOrDefault("X-Amz-Signature")
  valid_616194 = validateParameter(valid_616194, JString, required = false,
                                 default = nil)
  if valid_616194 != nil:
    section.add "X-Amz-Signature", valid_616194
  var valid_616195 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616195 = validateParameter(valid_616195, JString, required = false,
                                 default = nil)
  if valid_616195 != nil:
    section.add "X-Amz-Content-Sha256", valid_616195
  var valid_616196 = header.getOrDefault("X-Amz-Date")
  valid_616196 = validateParameter(valid_616196, JString, required = false,
                                 default = nil)
  if valid_616196 != nil:
    section.add "X-Amz-Date", valid_616196
  var valid_616197 = header.getOrDefault("X-Amz-Credential")
  valid_616197 = validateParameter(valid_616197, JString, required = false,
                                 default = nil)
  if valid_616197 != nil:
    section.add "X-Amz-Credential", valid_616197
  var valid_616198 = header.getOrDefault("X-Amz-Security-Token")
  valid_616198 = validateParameter(valid_616198, JString, required = false,
                                 default = nil)
  if valid_616198 != nil:
    section.add "X-Amz-Security-Token", valid_616198
  var valid_616199 = header.getOrDefault("X-Amz-Algorithm")
  valid_616199 = validateParameter(valid_616199, JString, required = false,
                                 default = nil)
  if valid_616199 != nil:
    section.add "X-Amz-Algorithm", valid_616199
  var valid_616200 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616200 = validateParameter(valid_616200, JString, required = false,
                                 default = nil)
  if valid_616200 != nil:
    section.add "X-Amz-SignedHeaders", valid_616200
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_616202: Call_StartOnDemandAuditTask_616191; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts an on-demand Device Defender audit.
  ## 
  let valid = call_616202.validator(path, query, header, formData, body)
  let scheme = call_616202.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616202.url(scheme.get, call_616202.host, call_616202.base,
                         call_616202.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616202, url, valid)

proc call*(call_616203: Call_StartOnDemandAuditTask_616191; body: JsonNode): Recallable =
  ## startOnDemandAuditTask
  ## Starts an on-demand Device Defender audit.
  ##   body: JObject (required)
  var body_616204 = newJObject()
  if body != nil:
    body_616204 = body
  result = call_616203.call(nil, nil, nil, nil, body_616204)

var startOnDemandAuditTask* = Call_StartOnDemandAuditTask_616191(
    name: "startOnDemandAuditTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/audit/tasks",
    validator: validate_StartOnDemandAuditTask_616192, base: "/",
    url: url_StartOnDemandAuditTask_616193, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StopThingRegistrationTask_616205 = ref object of OpenApiRestCall_612658
proc url_StopThingRegistrationTask_616207(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_StopThingRegistrationTask_616206(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The bulk thing provisioning task ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_616208 = path.getOrDefault("taskId")
  valid_616208 = validateParameter(valid_616208, JString, required = true,
                                 default = nil)
  if valid_616208 != nil:
    section.add "taskId", valid_616208
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616209 = header.getOrDefault("X-Amz-Signature")
  valid_616209 = validateParameter(valid_616209, JString, required = false,
                                 default = nil)
  if valid_616209 != nil:
    section.add "X-Amz-Signature", valid_616209
  var valid_616210 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616210 = validateParameter(valid_616210, JString, required = false,
                                 default = nil)
  if valid_616210 != nil:
    section.add "X-Amz-Content-Sha256", valid_616210
  var valid_616211 = header.getOrDefault("X-Amz-Date")
  valid_616211 = validateParameter(valid_616211, JString, required = false,
                                 default = nil)
  if valid_616211 != nil:
    section.add "X-Amz-Date", valid_616211
  var valid_616212 = header.getOrDefault("X-Amz-Credential")
  valid_616212 = validateParameter(valid_616212, JString, required = false,
                                 default = nil)
  if valid_616212 != nil:
    section.add "X-Amz-Credential", valid_616212
  var valid_616213 = header.getOrDefault("X-Amz-Security-Token")
  valid_616213 = validateParameter(valid_616213, JString, required = false,
                                 default = nil)
  if valid_616213 != nil:
    section.add "X-Amz-Security-Token", valid_616213
  var valid_616214 = header.getOrDefault("X-Amz-Algorithm")
  valid_616214 = validateParameter(valid_616214, JString, required = false,
                                 default = nil)
  if valid_616214 != nil:
    section.add "X-Amz-Algorithm", valid_616214
  var valid_616215 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616215 = validateParameter(valid_616215, JString, required = false,
                                 default = nil)
  if valid_616215 != nil:
    section.add "X-Amz-SignedHeaders", valid_616215
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616216: Call_StopThingRegistrationTask_616205; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a bulk thing provisioning task.
  ## 
  let valid = call_616216.validator(path, query, header, formData, body)
  let scheme = call_616216.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616216.url(scheme.get, call_616216.host, call_616216.base,
                         call_616216.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616216, url, valid)

proc call*(call_616217: Call_StopThingRegistrationTask_616205; taskId: string): Recallable =
  ## stopThingRegistrationTask
  ## Cancels a bulk thing provisioning task.
  ##   taskId: string (required)
  ##         : The bulk thing provisioning task ID.
  var path_616218 = newJObject()
  add(path_616218, "taskId", newJString(taskId))
  result = call_616217.call(path_616218, nil, nil, nil, nil)

var stopThingRegistrationTask* = Call_StopThingRegistrationTask_616205(
    name: "stopThingRegistrationTask", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks/{taskId}/cancel",
    validator: validate_StopThingRegistrationTask_616206, base: "/",
    url: url_StopThingRegistrationTask_616207,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_TagResource_616219 = ref object of OpenApiRestCall_612658
proc url_TagResource_616221(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_TagResource_616220(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616222 = header.getOrDefault("X-Amz-Signature")
  valid_616222 = validateParameter(valid_616222, JString, required = false,
                                 default = nil)
  if valid_616222 != nil:
    section.add "X-Amz-Signature", valid_616222
  var valid_616223 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616223 = validateParameter(valid_616223, JString, required = false,
                                 default = nil)
  if valid_616223 != nil:
    section.add "X-Amz-Content-Sha256", valid_616223
  var valid_616224 = header.getOrDefault("X-Amz-Date")
  valid_616224 = validateParameter(valid_616224, JString, required = false,
                                 default = nil)
  if valid_616224 != nil:
    section.add "X-Amz-Date", valid_616224
  var valid_616225 = header.getOrDefault("X-Amz-Credential")
  valid_616225 = validateParameter(valid_616225, JString, required = false,
                                 default = nil)
  if valid_616225 != nil:
    section.add "X-Amz-Credential", valid_616225
  var valid_616226 = header.getOrDefault("X-Amz-Security-Token")
  valid_616226 = validateParameter(valid_616226, JString, required = false,
                                 default = nil)
  if valid_616226 != nil:
    section.add "X-Amz-Security-Token", valid_616226
  var valid_616227 = header.getOrDefault("X-Amz-Algorithm")
  valid_616227 = validateParameter(valid_616227, JString, required = false,
                                 default = nil)
  if valid_616227 != nil:
    section.add "X-Amz-Algorithm", valid_616227
  var valid_616228 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616228 = validateParameter(valid_616228, JString, required = false,
                                 default = nil)
  if valid_616228 != nil:
    section.add "X-Amz-SignedHeaders", valid_616228
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_616230: Call_TagResource_616219; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ## 
  let valid = call_616230.validator(path, query, header, formData, body)
  let scheme = call_616230.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616230.url(scheme.get, call_616230.host, call_616230.base,
                         call_616230.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616230, url, valid)

proc call*(call_616231: Call_TagResource_616219; body: JsonNode): Recallable =
  ## tagResource
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ##   body: JObject (required)
  var body_616232 = newJObject()
  if body != nil:
    body_616232 = body
  result = call_616231.call(nil, nil, nil, nil, body_616232)

var tagResource* = Call_TagResource_616219(name: "tagResource",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com", route: "/tags",
                                        validator: validate_TagResource_616220,
                                        base: "/", url: url_TagResource_616221,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_TestAuthorization_616233 = ref object of OpenApiRestCall_612658
proc url_TestAuthorization_616235(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_TestAuthorization_616234(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   clientId: JString
  ##           : The MQTT client ID.
  section = newJObject()
  var valid_616236 = query.getOrDefault("clientId")
  valid_616236 = validateParameter(valid_616236, JString, required = false,
                                 default = nil)
  if valid_616236 != nil:
    section.add "clientId", valid_616236
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616237 = header.getOrDefault("X-Amz-Signature")
  valid_616237 = validateParameter(valid_616237, JString, required = false,
                                 default = nil)
  if valid_616237 != nil:
    section.add "X-Amz-Signature", valid_616237
  var valid_616238 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616238 = validateParameter(valid_616238, JString, required = false,
                                 default = nil)
  if valid_616238 != nil:
    section.add "X-Amz-Content-Sha256", valid_616238
  var valid_616239 = header.getOrDefault("X-Amz-Date")
  valid_616239 = validateParameter(valid_616239, JString, required = false,
                                 default = nil)
  if valid_616239 != nil:
    section.add "X-Amz-Date", valid_616239
  var valid_616240 = header.getOrDefault("X-Amz-Credential")
  valid_616240 = validateParameter(valid_616240, JString, required = false,
                                 default = nil)
  if valid_616240 != nil:
    section.add "X-Amz-Credential", valid_616240
  var valid_616241 = header.getOrDefault("X-Amz-Security-Token")
  valid_616241 = validateParameter(valid_616241, JString, required = false,
                                 default = nil)
  if valid_616241 != nil:
    section.add "X-Amz-Security-Token", valid_616241
  var valid_616242 = header.getOrDefault("X-Amz-Algorithm")
  valid_616242 = validateParameter(valid_616242, JString, required = false,
                                 default = nil)
  if valid_616242 != nil:
    section.add "X-Amz-Algorithm", valid_616242
  var valid_616243 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616243 = validateParameter(valid_616243, JString, required = false,
                                 default = nil)
  if valid_616243 != nil:
    section.add "X-Amz-SignedHeaders", valid_616243
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_616245: Call_TestAuthorization_616233; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  let valid = call_616245.validator(path, query, header, formData, body)
  let scheme = call_616245.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616245.url(scheme.get, call_616245.host, call_616245.base,
                         call_616245.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616245, url, valid)

proc call*(call_616246: Call_TestAuthorization_616233; body: JsonNode;
          clientId: string = ""): Recallable =
  ## testAuthorization
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ##   clientId: string
  ##           : The MQTT client ID.
  ##   body: JObject (required)
  var query_616247 = newJObject()
  var body_616248 = newJObject()
  add(query_616247, "clientId", newJString(clientId))
  if body != nil:
    body_616248 = body
  result = call_616246.call(nil, query_616247, nil, nil, body_616248)

var testAuthorization* = Call_TestAuthorization_616233(name: "testAuthorization",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/test-authorization", validator: validate_TestAuthorization_616234,
    base: "/", url: url_TestAuthorization_616235,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_TestInvokeAuthorizer_616249 = ref object of OpenApiRestCall_612658
proc url_TestInvokeAuthorizer_616251(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName"),
               (kind: ConstantSegment, value: "/test")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_TestInvokeAuthorizer_616250(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The custom authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_616252 = path.getOrDefault("authorizerName")
  valid_616252 = validateParameter(valid_616252, JString, required = true,
                                 default = nil)
  if valid_616252 != nil:
    section.add "authorizerName", valid_616252
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616253 = header.getOrDefault("X-Amz-Signature")
  valid_616253 = validateParameter(valid_616253, JString, required = false,
                                 default = nil)
  if valid_616253 != nil:
    section.add "X-Amz-Signature", valid_616253
  var valid_616254 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616254 = validateParameter(valid_616254, JString, required = false,
                                 default = nil)
  if valid_616254 != nil:
    section.add "X-Amz-Content-Sha256", valid_616254
  var valid_616255 = header.getOrDefault("X-Amz-Date")
  valid_616255 = validateParameter(valid_616255, JString, required = false,
                                 default = nil)
  if valid_616255 != nil:
    section.add "X-Amz-Date", valid_616255
  var valid_616256 = header.getOrDefault("X-Amz-Credential")
  valid_616256 = validateParameter(valid_616256, JString, required = false,
                                 default = nil)
  if valid_616256 != nil:
    section.add "X-Amz-Credential", valid_616256
  var valid_616257 = header.getOrDefault("X-Amz-Security-Token")
  valid_616257 = validateParameter(valid_616257, JString, required = false,
                                 default = nil)
  if valid_616257 != nil:
    section.add "X-Amz-Security-Token", valid_616257
  var valid_616258 = header.getOrDefault("X-Amz-Algorithm")
  valid_616258 = validateParameter(valid_616258, JString, required = false,
                                 default = nil)
  if valid_616258 != nil:
    section.add "X-Amz-Algorithm", valid_616258
  var valid_616259 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616259 = validateParameter(valid_616259, JString, required = false,
                                 default = nil)
  if valid_616259 != nil:
    section.add "X-Amz-SignedHeaders", valid_616259
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_616261: Call_TestInvokeAuthorizer_616249; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  let valid = call_616261.validator(path, query, header, formData, body)
  let scheme = call_616261.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616261.url(scheme.get, call_616261.host, call_616261.base,
                         call_616261.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616261, url, valid)

proc call*(call_616262: Call_TestInvokeAuthorizer_616249; authorizerName: string;
          body: JsonNode): Recallable =
  ## testInvokeAuthorizer
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ##   authorizerName: string (required)
  ##                 : The custom authorizer name.
  ##   body: JObject (required)
  var path_616263 = newJObject()
  var body_616264 = newJObject()
  add(path_616263, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_616264 = body
  result = call_616262.call(path_616263, nil, nil, nil, body_616264)

var testInvokeAuthorizer* = Call_TestInvokeAuthorizer_616249(
    name: "testInvokeAuthorizer", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/authorizer/{authorizerName}/test",
    validator: validate_TestInvokeAuthorizer_616250, base: "/",
    url: url_TestInvokeAuthorizer_616251, schemes: {Scheme.Https, Scheme.Http})
type
  Call_TransferCertificate_616265 = ref object of OpenApiRestCall_612658
proc url_TransferCertificate_616267(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/transfer-certificate/"),
               (kind: VariableSegment, value: "certificateId"),
               (kind: ConstantSegment, value: "#targetAwsAccount")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_TransferCertificate_616266(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_616268 = path.getOrDefault("certificateId")
  valid_616268 = validateParameter(valid_616268, JString, required = true,
                                 default = nil)
  if valid_616268 != nil:
    section.add "certificateId", valid_616268
  result.add "path", section
  ## parameters in `query` object:
  ##   targetAwsAccount: JString (required)
  ##                   : The AWS account.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `targetAwsAccount` field"
  var valid_616269 = query.getOrDefault("targetAwsAccount")
  valid_616269 = validateParameter(valid_616269, JString, required = true,
                                 default = nil)
  if valid_616269 != nil:
    section.add "targetAwsAccount", valid_616269
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616270 = header.getOrDefault("X-Amz-Signature")
  valid_616270 = validateParameter(valid_616270, JString, required = false,
                                 default = nil)
  if valid_616270 != nil:
    section.add "X-Amz-Signature", valid_616270
  var valid_616271 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616271 = validateParameter(valid_616271, JString, required = false,
                                 default = nil)
  if valid_616271 != nil:
    section.add "X-Amz-Content-Sha256", valid_616271
  var valid_616272 = header.getOrDefault("X-Amz-Date")
  valid_616272 = validateParameter(valid_616272, JString, required = false,
                                 default = nil)
  if valid_616272 != nil:
    section.add "X-Amz-Date", valid_616272
  var valid_616273 = header.getOrDefault("X-Amz-Credential")
  valid_616273 = validateParameter(valid_616273, JString, required = false,
                                 default = nil)
  if valid_616273 != nil:
    section.add "X-Amz-Credential", valid_616273
  var valid_616274 = header.getOrDefault("X-Amz-Security-Token")
  valid_616274 = validateParameter(valid_616274, JString, required = false,
                                 default = nil)
  if valid_616274 != nil:
    section.add "X-Amz-Security-Token", valid_616274
  var valid_616275 = header.getOrDefault("X-Amz-Algorithm")
  valid_616275 = validateParameter(valid_616275, JString, required = false,
                                 default = nil)
  if valid_616275 != nil:
    section.add "X-Amz-Algorithm", valid_616275
  var valid_616276 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616276 = validateParameter(valid_616276, JString, required = false,
                                 default = nil)
  if valid_616276 != nil:
    section.add "X-Amz-SignedHeaders", valid_616276
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_616278: Call_TransferCertificate_616265; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ## 
  let valid = call_616278.validator(path, query, header, formData, body)
  let scheme = call_616278.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616278.url(scheme.get, call_616278.host, call_616278.base,
                         call_616278.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616278, url, valid)

proc call*(call_616279: Call_TransferCertificate_616265; body: JsonNode;
          certificateId: string; targetAwsAccount: string): Recallable =
  ## transferCertificate
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ##   body: JObject (required)
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   targetAwsAccount: string (required)
  ##                   : The AWS account.
  var path_616280 = newJObject()
  var query_616281 = newJObject()
  var body_616282 = newJObject()
  if body != nil:
    body_616282 = body
  add(path_616280, "certificateId", newJString(certificateId))
  add(query_616281, "targetAwsAccount", newJString(targetAwsAccount))
  result = call_616279.call(path_616280, query_616281, nil, nil, body_616282)

var transferCertificate* = Call_TransferCertificate_616265(
    name: "transferCertificate", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/transfer-certificate/{certificateId}#targetAwsAccount",
    validator: validate_TransferCertificate_616266, base: "/",
    url: url_TransferCertificate_616267, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UntagResource_616283 = ref object of OpenApiRestCall_612658
proc url_UntagResource_616285(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UntagResource_616284(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes the given tags (metadata) from the resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616286 = header.getOrDefault("X-Amz-Signature")
  valid_616286 = validateParameter(valid_616286, JString, required = false,
                                 default = nil)
  if valid_616286 != nil:
    section.add "X-Amz-Signature", valid_616286
  var valid_616287 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616287 = validateParameter(valid_616287, JString, required = false,
                                 default = nil)
  if valid_616287 != nil:
    section.add "X-Amz-Content-Sha256", valid_616287
  var valid_616288 = header.getOrDefault("X-Amz-Date")
  valid_616288 = validateParameter(valid_616288, JString, required = false,
                                 default = nil)
  if valid_616288 != nil:
    section.add "X-Amz-Date", valid_616288
  var valid_616289 = header.getOrDefault("X-Amz-Credential")
  valid_616289 = validateParameter(valid_616289, JString, required = false,
                                 default = nil)
  if valid_616289 != nil:
    section.add "X-Amz-Credential", valid_616289
  var valid_616290 = header.getOrDefault("X-Amz-Security-Token")
  valid_616290 = validateParameter(valid_616290, JString, required = false,
                                 default = nil)
  if valid_616290 != nil:
    section.add "X-Amz-Security-Token", valid_616290
  var valid_616291 = header.getOrDefault("X-Amz-Algorithm")
  valid_616291 = validateParameter(valid_616291, JString, required = false,
                                 default = nil)
  if valid_616291 != nil:
    section.add "X-Amz-Algorithm", valid_616291
  var valid_616292 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616292 = validateParameter(valid_616292, JString, required = false,
                                 default = nil)
  if valid_616292 != nil:
    section.add "X-Amz-SignedHeaders", valid_616292
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_616294: Call_UntagResource_616283; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes the given tags (metadata) from the resource.
  ## 
  let valid = call_616294.validator(path, query, header, formData, body)
  let scheme = call_616294.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616294.url(scheme.get, call_616294.host, call_616294.base,
                         call_616294.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616294, url, valid)

proc call*(call_616295: Call_UntagResource_616283; body: JsonNode): Recallable =
  ## untagResource
  ## Removes the given tags (metadata) from the resource.
  ##   body: JObject (required)
  var body_616296 = newJObject()
  if body != nil:
    body_616296 = body
  result = call_616295.call(nil, nil, nil, nil, body_616296)

var untagResource* = Call_UntagResource_616283(name: "untagResource",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/untag",
    validator: validate_UntagResource_616284, base: "/", url: url_UntagResource_616285,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateCertificate_616297 = ref object of OpenApiRestCall_612658
proc url_UpdateCertificate_616299(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId"),
               (kind: ConstantSegment, value: "#newStatus")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateCertificate_616298(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_616300 = path.getOrDefault("certificateId")
  valid_616300 = validateParameter(valid_616300, JString, required = true,
                                 default = nil)
  if valid_616300 != nil:
    section.add "certificateId", valid_616300
  result.add "path", section
  ## parameters in `query` object:
  ##   newStatus: JString (required)
  ##            : <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  section = newJObject()
  var valid_616301 = query.getOrDefault("newStatus")
  valid_616301 = validateParameter(valid_616301, JString, required = true,
                                 default = newJString("ACTIVE"))
  if valid_616301 != nil:
    section.add "newStatus", valid_616301
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616302 = header.getOrDefault("X-Amz-Signature")
  valid_616302 = validateParameter(valid_616302, JString, required = false,
                                 default = nil)
  if valid_616302 != nil:
    section.add "X-Amz-Signature", valid_616302
  var valid_616303 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616303 = validateParameter(valid_616303, JString, required = false,
                                 default = nil)
  if valid_616303 != nil:
    section.add "X-Amz-Content-Sha256", valid_616303
  var valid_616304 = header.getOrDefault("X-Amz-Date")
  valid_616304 = validateParameter(valid_616304, JString, required = false,
                                 default = nil)
  if valid_616304 != nil:
    section.add "X-Amz-Date", valid_616304
  var valid_616305 = header.getOrDefault("X-Amz-Credential")
  valid_616305 = validateParameter(valid_616305, JString, required = false,
                                 default = nil)
  if valid_616305 != nil:
    section.add "X-Amz-Credential", valid_616305
  var valid_616306 = header.getOrDefault("X-Amz-Security-Token")
  valid_616306 = validateParameter(valid_616306, JString, required = false,
                                 default = nil)
  if valid_616306 != nil:
    section.add "X-Amz-Security-Token", valid_616306
  var valid_616307 = header.getOrDefault("X-Amz-Algorithm")
  valid_616307 = validateParameter(valid_616307, JString, required = false,
                                 default = nil)
  if valid_616307 != nil:
    section.add "X-Amz-Algorithm", valid_616307
  var valid_616308 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616308 = validateParameter(valid_616308, JString, required = false,
                                 default = nil)
  if valid_616308 != nil:
    section.add "X-Amz-SignedHeaders", valid_616308
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_616309: Call_UpdateCertificate_616297; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ## 
  let valid = call_616309.validator(path, query, header, formData, body)
  let scheme = call_616309.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616309.url(scheme.get, call_616309.host, call_616309.base,
                         call_616309.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616309, url, valid)

proc call*(call_616310: Call_UpdateCertificate_616297; certificateId: string;
          newStatus: string = "ACTIVE"): Recallable =
  ## updateCertificate
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ##   newStatus: string (required)
  ##            : <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_616311 = newJObject()
  var query_616312 = newJObject()
  add(query_616312, "newStatus", newJString(newStatus))
  add(path_616311, "certificateId", newJString(certificateId))
  result = call_616310.call(path_616311, query_616312, nil, nil, nil)

var updateCertificate* = Call_UpdateCertificate_616297(name: "updateCertificate",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/certificates/{certificateId}#newStatus",
    validator: validate_UpdateCertificate_616298, base: "/",
    url: url_UpdateCertificate_616299, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThingGroupsForThing_616313 = ref object of OpenApiRestCall_612658
proc url_UpdateThingGroupsForThing_616315(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateThingGroupsForThing_616314(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the groups to which the thing belongs.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616316 = header.getOrDefault("X-Amz-Signature")
  valid_616316 = validateParameter(valid_616316, JString, required = false,
                                 default = nil)
  if valid_616316 != nil:
    section.add "X-Amz-Signature", valid_616316
  var valid_616317 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616317 = validateParameter(valid_616317, JString, required = false,
                                 default = nil)
  if valid_616317 != nil:
    section.add "X-Amz-Content-Sha256", valid_616317
  var valid_616318 = header.getOrDefault("X-Amz-Date")
  valid_616318 = validateParameter(valid_616318, JString, required = false,
                                 default = nil)
  if valid_616318 != nil:
    section.add "X-Amz-Date", valid_616318
  var valid_616319 = header.getOrDefault("X-Amz-Credential")
  valid_616319 = validateParameter(valid_616319, JString, required = false,
                                 default = nil)
  if valid_616319 != nil:
    section.add "X-Amz-Credential", valid_616319
  var valid_616320 = header.getOrDefault("X-Amz-Security-Token")
  valid_616320 = validateParameter(valid_616320, JString, required = false,
                                 default = nil)
  if valid_616320 != nil:
    section.add "X-Amz-Security-Token", valid_616320
  var valid_616321 = header.getOrDefault("X-Amz-Algorithm")
  valid_616321 = validateParameter(valid_616321, JString, required = false,
                                 default = nil)
  if valid_616321 != nil:
    section.add "X-Amz-Algorithm", valid_616321
  var valid_616322 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616322 = validateParameter(valid_616322, JString, required = false,
                                 default = nil)
  if valid_616322 != nil:
    section.add "X-Amz-SignedHeaders", valid_616322
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_616324: Call_UpdateThingGroupsForThing_616313; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the groups to which the thing belongs.
  ## 
  let valid = call_616324.validator(path, query, header, formData, body)
  let scheme = call_616324.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616324.url(scheme.get, call_616324.host, call_616324.base,
                         call_616324.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616324, url, valid)

proc call*(call_616325: Call_UpdateThingGroupsForThing_616313; body: JsonNode): Recallable =
  ## updateThingGroupsForThing
  ## Updates the groups to which the thing belongs.
  ##   body: JObject (required)
  var body_616326 = newJObject()
  if body != nil:
    body_616326 = body
  result = call_616325.call(nil, nil, nil, nil, body_616326)

var updateThingGroupsForThing* = Call_UpdateThingGroupsForThing_616313(
    name: "updateThingGroupsForThing", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/updateThingGroupsForThing",
    validator: validate_UpdateThingGroupsForThing_616314, base: "/",
    url: url_UpdateThingGroupsForThing_616315,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ValidateSecurityProfileBehaviors_616327 = ref object of OpenApiRestCall_612658
proc url_ValidateSecurityProfileBehaviors_616329(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ValidateSecurityProfileBehaviors_616328(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validates a Device Defender security profile behaviors specification.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_616330 = header.getOrDefault("X-Amz-Signature")
  valid_616330 = validateParameter(valid_616330, JString, required = false,
                                 default = nil)
  if valid_616330 != nil:
    section.add "X-Amz-Signature", valid_616330
  var valid_616331 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_616331 = validateParameter(valid_616331, JString, required = false,
                                 default = nil)
  if valid_616331 != nil:
    section.add "X-Amz-Content-Sha256", valid_616331
  var valid_616332 = header.getOrDefault("X-Amz-Date")
  valid_616332 = validateParameter(valid_616332, JString, required = false,
                                 default = nil)
  if valid_616332 != nil:
    section.add "X-Amz-Date", valid_616332
  var valid_616333 = header.getOrDefault("X-Amz-Credential")
  valid_616333 = validateParameter(valid_616333, JString, required = false,
                                 default = nil)
  if valid_616333 != nil:
    section.add "X-Amz-Credential", valid_616333
  var valid_616334 = header.getOrDefault("X-Amz-Security-Token")
  valid_616334 = validateParameter(valid_616334, JString, required = false,
                                 default = nil)
  if valid_616334 != nil:
    section.add "X-Amz-Security-Token", valid_616334
  var valid_616335 = header.getOrDefault("X-Amz-Algorithm")
  valid_616335 = validateParameter(valid_616335, JString, required = false,
                                 default = nil)
  if valid_616335 != nil:
    section.add "X-Amz-Algorithm", valid_616335
  var valid_616336 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_616336 = validateParameter(valid_616336, JString, required = false,
                                 default = nil)
  if valid_616336 != nil:
    section.add "X-Amz-SignedHeaders", valid_616336
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_616338: Call_ValidateSecurityProfileBehaviors_616327;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Validates a Device Defender security profile behaviors specification.
  ## 
  let valid = call_616338.validator(path, query, header, formData, body)
  let scheme = call_616338.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_616338.url(scheme.get, call_616338.host, call_616338.base,
                         call_616338.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_616338, url, valid)

proc call*(call_616339: Call_ValidateSecurityProfileBehaviors_616327;
          body: JsonNode): Recallable =
  ## validateSecurityProfileBehaviors
  ## Validates a Device Defender security profile behaviors specification.
  ##   body: JObject (required)
  var body_616340 = newJObject()
  if body != nil:
    body_616340 = body
  result = call_616339.call(nil, nil, nil, nil, body_616340)

var validateSecurityProfileBehaviors* = Call_ValidateSecurityProfileBehaviors_616327(
    name: "validateSecurityProfileBehaviors", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/security-profile-behaviors/validate",
    validator: validate_ValidateSecurityProfileBehaviors_616328, base: "/",
    url: url_ValidateSecurityProfileBehaviors_616329,
    schemes: {Scheme.Https, Scheme.Http})
export
  rest

type
  EnvKind = enum
    BakeIntoBinary = "Baking $1 into the binary",
    FetchFromEnv = "Fetch $1 from the environment"
template sloppyConst(via: EnvKind; name: untyped): untyped =
  import
    macros

  const
    name {.strdefine.}: string = case via
    of BakeIntoBinary:
      getEnv(astToStr(name), "")
    of FetchFromEnv:
      ""
  static :
    let msg = block:
      if name == "":
        "Missing $1 in the environment"
      else:
        $via
    warning msg % [astToStr(name)]

sloppyConst FetchFromEnv, AWS_ACCESS_KEY_ID
sloppyConst FetchFromEnv, AWS_SECRET_ACCESS_KEY
sloppyConst BakeIntoBinary, AWS_REGION
sloppyConst FetchFromEnv, AWS_ACCOUNT_ID
proc atozSign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", AWS_ACCESS_KEY_ID)
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", AWS_SECRET_ACCESS_KEY)
    region = os.getEnv("AWS_REGION", AWS_REGION)
  assert secret != "", "need $AWS_SECRET_ACCESS_KEY in environment"
  assert access != "", "need $AWS_ACCESS_KEY_ID in environment"
  assert region != "", "need $AWS_REGION in environment"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  recall.headers.del "Host"
  recall.url = $url

method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  ## the hook is a terrible earworm
  var headers = newHttpHeaders(massageHeaders(input.getOrDefault("header")))
  let
    body = input.getOrDefault("body")
    text = if body == nil:
      "" elif body.kind == JString:
      body.getStr else:
      $body
  if body != nil and body.kind != JString:
    if not headers.hasKey("content-type"):
      headers["content-type"] = "application/x-amz-json-1.0"
  const
    XAmzSecurityToken = "X-Amz-Security-Token"
  if not headers.hasKey(XAmzSecurityToken):
    let session = getEnv("AWS_SESSION_TOKEN", "")
    if session != "":
      headers[XAmzSecurityToken] = session
  result = newRecallable(call, url, headers, text)
  result.atozSign(input.getOrDefault("query"), SHA256)
