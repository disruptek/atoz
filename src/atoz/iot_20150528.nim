
import
  json, options, hashes, uri, strutils, tables, rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: AWS IoT
## version: 2015-05-28
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>AWS IoT</fullname> <p>AWS IoT provides secure, bi-directional communication between Internet-connected devices (such as sensors, actuators, embedded devices, or smart appliances) and the AWS cloud. You can discover your custom IoT-Data endpoint to communicate with, configure rules for data processing and integration with other services, organize resources associated with each device (Registry), configure logging, and create and manage policies and credentials to authenticate devices.</p> <p>For more information about how AWS IoT works, see the <a href="https://docs.aws.amazon.com/iot/latest/developerguide/aws-iot-how-it-works.html">Developer Guide</a>.</p> <p>For information about how to use the credentials provider for AWS IoT, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorizing-direct-aws.html">Authorizing Direct Calls to AWS Services</a>.</p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/iot/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_610658 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_610658](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_610658): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low .. Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js == nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result == nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind == kind, $kind & " expected; received " & $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "iot.ap-northeast-1.amazonaws.com", "ap-southeast-1": "iot.ap-southeast-1.amazonaws.com",
                           "us-west-2": "iot.us-west-2.amazonaws.com",
                           "eu-west-2": "iot.eu-west-2.amazonaws.com", "ap-northeast-3": "iot.ap-northeast-3.amazonaws.com",
                           "eu-central-1": "iot.eu-central-1.amazonaws.com",
                           "us-east-2": "iot.us-east-2.amazonaws.com",
                           "us-east-1": "iot.us-east-1.amazonaws.com", "cn-northwest-1": "iot.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "iot.ap-south-1.amazonaws.com",
                           "eu-north-1": "iot.eu-north-1.amazonaws.com", "ap-northeast-2": "iot.ap-northeast-2.amazonaws.com",
                           "us-west-1": "iot.us-west-1.amazonaws.com",
                           "us-gov-east-1": "iot.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "iot.eu-west-3.amazonaws.com",
                           "cn-north-1": "iot.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "iot.sa-east-1.amazonaws.com",
                           "eu-west-1": "iot.eu-west-1.amazonaws.com",
                           "us-gov-west-1": "iot.us-gov-west-1.amazonaws.com", "ap-southeast-2": "iot.ap-southeast-2.amazonaws.com",
                           "ca-central-1": "iot.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "iot.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "iot.ap-southeast-1.amazonaws.com",
      "us-west-2": "iot.us-west-2.amazonaws.com",
      "eu-west-2": "iot.eu-west-2.amazonaws.com",
      "ap-northeast-3": "iot.ap-northeast-3.amazonaws.com",
      "eu-central-1": "iot.eu-central-1.amazonaws.com",
      "us-east-2": "iot.us-east-2.amazonaws.com",
      "us-east-1": "iot.us-east-1.amazonaws.com",
      "cn-northwest-1": "iot.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "iot.ap-south-1.amazonaws.com",
      "eu-north-1": "iot.eu-north-1.amazonaws.com",
      "ap-northeast-2": "iot.ap-northeast-2.amazonaws.com",
      "us-west-1": "iot.us-west-1.amazonaws.com",
      "us-gov-east-1": "iot.us-gov-east-1.amazonaws.com",
      "eu-west-3": "iot.eu-west-3.amazonaws.com",
      "cn-north-1": "iot.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "iot.sa-east-1.amazonaws.com",
      "eu-west-1": "iot.eu-west-1.amazonaws.com",
      "us-gov-west-1": "iot.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "iot.ap-southeast-2.amazonaws.com",
      "ca-central-1": "iot.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "iot"
method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_AcceptCertificateTransfer_610996 = ref object of OpenApiRestCall_610658
proc url_AcceptCertificateTransfer_610998(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/accept-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AcceptCertificateTransfer_610997(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_611124 = path.getOrDefault("certificateId")
  valid_611124 = validateParameter(valid_611124, JString, required = true,
                                 default = nil)
  if valid_611124 != nil:
    section.add "certificateId", valid_611124
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_611125 = query.getOrDefault("setAsActive")
  valid_611125 = validateParameter(valid_611125, JBool, required = false, default = nil)
  if valid_611125 != nil:
    section.add "setAsActive", valid_611125
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611126 = header.getOrDefault("X-Amz-Signature")
  valid_611126 = validateParameter(valid_611126, JString, required = false,
                                 default = nil)
  if valid_611126 != nil:
    section.add "X-Amz-Signature", valid_611126
  var valid_611127 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611127 = validateParameter(valid_611127, JString, required = false,
                                 default = nil)
  if valid_611127 != nil:
    section.add "X-Amz-Content-Sha256", valid_611127
  var valid_611128 = header.getOrDefault("X-Amz-Date")
  valid_611128 = validateParameter(valid_611128, JString, required = false,
                                 default = nil)
  if valid_611128 != nil:
    section.add "X-Amz-Date", valid_611128
  var valid_611129 = header.getOrDefault("X-Amz-Credential")
  valid_611129 = validateParameter(valid_611129, JString, required = false,
                                 default = nil)
  if valid_611129 != nil:
    section.add "X-Amz-Credential", valid_611129
  var valid_611130 = header.getOrDefault("X-Amz-Security-Token")
  valid_611130 = validateParameter(valid_611130, JString, required = false,
                                 default = nil)
  if valid_611130 != nil:
    section.add "X-Amz-Security-Token", valid_611130
  var valid_611131 = header.getOrDefault("X-Amz-Algorithm")
  valid_611131 = validateParameter(valid_611131, JString, required = false,
                                 default = nil)
  if valid_611131 != nil:
    section.add "X-Amz-Algorithm", valid_611131
  var valid_611132 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611132 = validateParameter(valid_611132, JString, required = false,
                                 default = nil)
  if valid_611132 != nil:
    section.add "X-Amz-SignedHeaders", valid_611132
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611155: Call_AcceptCertificateTransfer_610996; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ## 
  let valid = call_611155.validator(path, query, header, formData, body)
  let scheme = call_611155.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611155.url(scheme.get, call_611155.host, call_611155.base,
                         call_611155.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611155, url, valid)

proc call*(call_611226: Call_AcceptCertificateTransfer_610996;
          certificateId: string; setAsActive: bool = false): Recallable =
  ## acceptCertificateTransfer
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_611227 = newJObject()
  var query_611229 = newJObject()
  add(query_611229, "setAsActive", newJBool(setAsActive))
  add(path_611227, "certificateId", newJString(certificateId))
  result = call_611226.call(path_611227, query_611229, nil, nil, nil)

var acceptCertificateTransfer* = Call_AcceptCertificateTransfer_610996(
    name: "acceptCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/accept-certificate-transfer/{certificateId}",
    validator: validate_AcceptCertificateTransfer_610997, base: "/",
    url: url_AcceptCertificateTransfer_610998,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_AddThingToBillingGroup_611268 = ref object of OpenApiRestCall_610658
proc url_AddThingToBillingGroup_611270(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_AddThingToBillingGroup_611269(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a thing to a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611271 = header.getOrDefault("X-Amz-Signature")
  valid_611271 = validateParameter(valid_611271, JString, required = false,
                                 default = nil)
  if valid_611271 != nil:
    section.add "X-Amz-Signature", valid_611271
  var valid_611272 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611272 = validateParameter(valid_611272, JString, required = false,
                                 default = nil)
  if valid_611272 != nil:
    section.add "X-Amz-Content-Sha256", valid_611272
  var valid_611273 = header.getOrDefault("X-Amz-Date")
  valid_611273 = validateParameter(valid_611273, JString, required = false,
                                 default = nil)
  if valid_611273 != nil:
    section.add "X-Amz-Date", valid_611273
  var valid_611274 = header.getOrDefault("X-Amz-Credential")
  valid_611274 = validateParameter(valid_611274, JString, required = false,
                                 default = nil)
  if valid_611274 != nil:
    section.add "X-Amz-Credential", valid_611274
  var valid_611275 = header.getOrDefault("X-Amz-Security-Token")
  valid_611275 = validateParameter(valid_611275, JString, required = false,
                                 default = nil)
  if valid_611275 != nil:
    section.add "X-Amz-Security-Token", valid_611275
  var valid_611276 = header.getOrDefault("X-Amz-Algorithm")
  valid_611276 = validateParameter(valid_611276, JString, required = false,
                                 default = nil)
  if valid_611276 != nil:
    section.add "X-Amz-Algorithm", valid_611276
  var valid_611277 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611277 = validateParameter(valid_611277, JString, required = false,
                                 default = nil)
  if valid_611277 != nil:
    section.add "X-Amz-SignedHeaders", valid_611277
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611279: Call_AddThingToBillingGroup_611268; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a thing to a billing group.
  ## 
  let valid = call_611279.validator(path, query, header, formData, body)
  let scheme = call_611279.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611279.url(scheme.get, call_611279.host, call_611279.base,
                         call_611279.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611279, url, valid)

proc call*(call_611280: Call_AddThingToBillingGroup_611268; body: JsonNode): Recallable =
  ## addThingToBillingGroup
  ## Adds a thing to a billing group.
  ##   body: JObject (required)
  var body_611281 = newJObject()
  if body != nil:
    body_611281 = body
  result = call_611280.call(nil, nil, nil, nil, body_611281)

var addThingToBillingGroup* = Call_AddThingToBillingGroup_611268(
    name: "addThingToBillingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/billing-groups/addThingToBillingGroup",
    validator: validate_AddThingToBillingGroup_611269, base: "/",
    url: url_AddThingToBillingGroup_611270, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AddThingToThingGroup_611282 = ref object of OpenApiRestCall_610658
proc url_AddThingToThingGroup_611284(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_AddThingToThingGroup_611283(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a thing to a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611285 = header.getOrDefault("X-Amz-Signature")
  valid_611285 = validateParameter(valid_611285, JString, required = false,
                                 default = nil)
  if valid_611285 != nil:
    section.add "X-Amz-Signature", valid_611285
  var valid_611286 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611286 = validateParameter(valid_611286, JString, required = false,
                                 default = nil)
  if valid_611286 != nil:
    section.add "X-Amz-Content-Sha256", valid_611286
  var valid_611287 = header.getOrDefault("X-Amz-Date")
  valid_611287 = validateParameter(valid_611287, JString, required = false,
                                 default = nil)
  if valid_611287 != nil:
    section.add "X-Amz-Date", valid_611287
  var valid_611288 = header.getOrDefault("X-Amz-Credential")
  valid_611288 = validateParameter(valid_611288, JString, required = false,
                                 default = nil)
  if valid_611288 != nil:
    section.add "X-Amz-Credential", valid_611288
  var valid_611289 = header.getOrDefault("X-Amz-Security-Token")
  valid_611289 = validateParameter(valid_611289, JString, required = false,
                                 default = nil)
  if valid_611289 != nil:
    section.add "X-Amz-Security-Token", valid_611289
  var valid_611290 = header.getOrDefault("X-Amz-Algorithm")
  valid_611290 = validateParameter(valid_611290, JString, required = false,
                                 default = nil)
  if valid_611290 != nil:
    section.add "X-Amz-Algorithm", valid_611290
  var valid_611291 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611291 = validateParameter(valid_611291, JString, required = false,
                                 default = nil)
  if valid_611291 != nil:
    section.add "X-Amz-SignedHeaders", valid_611291
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611293: Call_AddThingToThingGroup_611282; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a thing to a thing group.
  ## 
  let valid = call_611293.validator(path, query, header, formData, body)
  let scheme = call_611293.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611293.url(scheme.get, call_611293.host, call_611293.base,
                         call_611293.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611293, url, valid)

proc call*(call_611294: Call_AddThingToThingGroup_611282; body: JsonNode): Recallable =
  ## addThingToThingGroup
  ## Adds a thing to a thing group.
  ##   body: JObject (required)
  var body_611295 = newJObject()
  if body != nil:
    body_611295 = body
  result = call_611294.call(nil, nil, nil, nil, body_611295)

var addThingToThingGroup* = Call_AddThingToThingGroup_611282(
    name: "addThingToThingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/addThingToThingGroup",
    validator: validate_AddThingToThingGroup_611283, base: "/",
    url: url_AddThingToThingGroup_611284, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AssociateTargetsWithJob_611296 = ref object of OpenApiRestCall_610658
proc url_AssociateTargetsWithJob_611298(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/targets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AssociateTargetsWithJob_611297(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_611299 = path.getOrDefault("jobId")
  valid_611299 = validateParameter(valid_611299, JString, required = true,
                                 default = nil)
  if valid_611299 != nil:
    section.add "jobId", valid_611299
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611300 = header.getOrDefault("X-Amz-Signature")
  valid_611300 = validateParameter(valid_611300, JString, required = false,
                                 default = nil)
  if valid_611300 != nil:
    section.add "X-Amz-Signature", valid_611300
  var valid_611301 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611301 = validateParameter(valid_611301, JString, required = false,
                                 default = nil)
  if valid_611301 != nil:
    section.add "X-Amz-Content-Sha256", valid_611301
  var valid_611302 = header.getOrDefault("X-Amz-Date")
  valid_611302 = validateParameter(valid_611302, JString, required = false,
                                 default = nil)
  if valid_611302 != nil:
    section.add "X-Amz-Date", valid_611302
  var valid_611303 = header.getOrDefault("X-Amz-Credential")
  valid_611303 = validateParameter(valid_611303, JString, required = false,
                                 default = nil)
  if valid_611303 != nil:
    section.add "X-Amz-Credential", valid_611303
  var valid_611304 = header.getOrDefault("X-Amz-Security-Token")
  valid_611304 = validateParameter(valid_611304, JString, required = false,
                                 default = nil)
  if valid_611304 != nil:
    section.add "X-Amz-Security-Token", valid_611304
  var valid_611305 = header.getOrDefault("X-Amz-Algorithm")
  valid_611305 = validateParameter(valid_611305, JString, required = false,
                                 default = nil)
  if valid_611305 != nil:
    section.add "X-Amz-Algorithm", valid_611305
  var valid_611306 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611306 = validateParameter(valid_611306, JString, required = false,
                                 default = nil)
  if valid_611306 != nil:
    section.add "X-Amz-SignedHeaders", valid_611306
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611308: Call_AssociateTargetsWithJob_611296; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ## 
  let valid = call_611308.validator(path, query, header, formData, body)
  let scheme = call_611308.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611308.url(scheme.get, call_611308.host, call_611308.base,
                         call_611308.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611308, url, valid)

proc call*(call_611309: Call_AssociateTargetsWithJob_611296; jobId: string;
          body: JsonNode): Recallable =
  ## associateTargetsWithJob
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   body: JObject (required)
  var path_611310 = newJObject()
  var body_611311 = newJObject()
  add(path_611310, "jobId", newJString(jobId))
  if body != nil:
    body_611311 = body
  result = call_611309.call(path_611310, nil, nil, nil, body_611311)

var associateTargetsWithJob* = Call_AssociateTargetsWithJob_611296(
    name: "associateTargetsWithJob", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/jobs/{jobId}/targets",
    validator: validate_AssociateTargetsWithJob_611297, base: "/",
    url: url_AssociateTargetsWithJob_611298, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachPolicy_611312 = ref object of OpenApiRestCall_610658
proc url_AttachPolicy_611314(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/target-policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachPolicy_611313(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Attaches a policy to the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to attach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_611315 = path.getOrDefault("policyName")
  valid_611315 = validateParameter(valid_611315, JString, required = true,
                                 default = nil)
  if valid_611315 != nil:
    section.add "policyName", valid_611315
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611316 = header.getOrDefault("X-Amz-Signature")
  valid_611316 = validateParameter(valid_611316, JString, required = false,
                                 default = nil)
  if valid_611316 != nil:
    section.add "X-Amz-Signature", valid_611316
  var valid_611317 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611317 = validateParameter(valid_611317, JString, required = false,
                                 default = nil)
  if valid_611317 != nil:
    section.add "X-Amz-Content-Sha256", valid_611317
  var valid_611318 = header.getOrDefault("X-Amz-Date")
  valid_611318 = validateParameter(valid_611318, JString, required = false,
                                 default = nil)
  if valid_611318 != nil:
    section.add "X-Amz-Date", valid_611318
  var valid_611319 = header.getOrDefault("X-Amz-Credential")
  valid_611319 = validateParameter(valid_611319, JString, required = false,
                                 default = nil)
  if valid_611319 != nil:
    section.add "X-Amz-Credential", valid_611319
  var valid_611320 = header.getOrDefault("X-Amz-Security-Token")
  valid_611320 = validateParameter(valid_611320, JString, required = false,
                                 default = nil)
  if valid_611320 != nil:
    section.add "X-Amz-Security-Token", valid_611320
  var valid_611321 = header.getOrDefault("X-Amz-Algorithm")
  valid_611321 = validateParameter(valid_611321, JString, required = false,
                                 default = nil)
  if valid_611321 != nil:
    section.add "X-Amz-Algorithm", valid_611321
  var valid_611322 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611322 = validateParameter(valid_611322, JString, required = false,
                                 default = nil)
  if valid_611322 != nil:
    section.add "X-Amz-SignedHeaders", valid_611322
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611324: Call_AttachPolicy_611312; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Attaches a policy to the specified target.
  ## 
  let valid = call_611324.validator(path, query, header, formData, body)
  let scheme = call_611324.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611324.url(scheme.get, call_611324.host, call_611324.base,
                         call_611324.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611324, url, valid)

proc call*(call_611325: Call_AttachPolicy_611312; policyName: string; body: JsonNode): Recallable =
  ## attachPolicy
  ## Attaches a policy to the specified target.
  ##   policyName: string (required)
  ##             : The name of the policy to attach.
  ##   body: JObject (required)
  var path_611326 = newJObject()
  var body_611327 = newJObject()
  add(path_611326, "policyName", newJString(policyName))
  if body != nil:
    body_611327 = body
  result = call_611325.call(path_611326, nil, nil, nil, body_611327)

var attachPolicy* = Call_AttachPolicy_611312(name: "attachPolicy",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/target-policies/{policyName}", validator: validate_AttachPolicy_611313,
    base: "/", url: url_AttachPolicy_611314, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachPolicy_611328 = ref object of OpenApiRestCall_610658
proc url_DetachPolicy_611330(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/target-policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachPolicy_611329(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Detaches a policy from the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy to detach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_611331 = path.getOrDefault("policyName")
  valid_611331 = validateParameter(valid_611331, JString, required = true,
                                 default = nil)
  if valid_611331 != nil:
    section.add "policyName", valid_611331
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611332 = header.getOrDefault("X-Amz-Signature")
  valid_611332 = validateParameter(valid_611332, JString, required = false,
                                 default = nil)
  if valid_611332 != nil:
    section.add "X-Amz-Signature", valid_611332
  var valid_611333 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611333 = validateParameter(valid_611333, JString, required = false,
                                 default = nil)
  if valid_611333 != nil:
    section.add "X-Amz-Content-Sha256", valid_611333
  var valid_611334 = header.getOrDefault("X-Amz-Date")
  valid_611334 = validateParameter(valid_611334, JString, required = false,
                                 default = nil)
  if valid_611334 != nil:
    section.add "X-Amz-Date", valid_611334
  var valid_611335 = header.getOrDefault("X-Amz-Credential")
  valid_611335 = validateParameter(valid_611335, JString, required = false,
                                 default = nil)
  if valid_611335 != nil:
    section.add "X-Amz-Credential", valid_611335
  var valid_611336 = header.getOrDefault("X-Amz-Security-Token")
  valid_611336 = validateParameter(valid_611336, JString, required = false,
                                 default = nil)
  if valid_611336 != nil:
    section.add "X-Amz-Security-Token", valid_611336
  var valid_611337 = header.getOrDefault("X-Amz-Algorithm")
  valid_611337 = validateParameter(valid_611337, JString, required = false,
                                 default = nil)
  if valid_611337 != nil:
    section.add "X-Amz-Algorithm", valid_611337
  var valid_611338 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611338 = validateParameter(valid_611338, JString, required = false,
                                 default = nil)
  if valid_611338 != nil:
    section.add "X-Amz-SignedHeaders", valid_611338
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611340: Call_DetachPolicy_611328; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Detaches a policy from the specified target.
  ## 
  let valid = call_611340.validator(path, query, header, formData, body)
  let scheme = call_611340.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611340.url(scheme.get, call_611340.host, call_611340.base,
                         call_611340.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611340, url, valid)

proc call*(call_611341: Call_DetachPolicy_611328; policyName: string; body: JsonNode): Recallable =
  ## detachPolicy
  ## Detaches a policy from the specified target.
  ##   policyName: string (required)
  ##             : The policy to detach.
  ##   body: JObject (required)
  var path_611342 = newJObject()
  var body_611343 = newJObject()
  add(path_611342, "policyName", newJString(policyName))
  if body != nil:
    body_611343 = body
  result = call_611341.call(path_611342, nil, nil, nil, body_611343)

var detachPolicy* = Call_DetachPolicy_611328(name: "detachPolicy",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/target-policies/{policyName}", validator: validate_DetachPolicy_611329,
    base: "/", url: url_DetachPolicy_611330, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachPrincipalPolicy_611344 = ref object of OpenApiRestCall_610658
proc url_AttachPrincipalPolicy_611346(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/principal-policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "#x-amzn-iot-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachPrincipalPolicy_611345(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_611347 = path.getOrDefault("policyName")
  valid_611347 = validateParameter(valid_611347, JString, required = true,
                                 default = nil)
  if valid_611347 != nil:
    section.add "policyName", valid_611347
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611348 = header.getOrDefault("X-Amz-Signature")
  valid_611348 = validateParameter(valid_611348, JString, required = false,
                                 default = nil)
  if valid_611348 != nil:
    section.add "X-Amz-Signature", valid_611348
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_611349 = header.getOrDefault("x-amzn-iot-principal")
  valid_611349 = validateParameter(valid_611349, JString, required = true,
                                 default = nil)
  if valid_611349 != nil:
    section.add "x-amzn-iot-principal", valid_611349
  var valid_611350 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611350 = validateParameter(valid_611350, JString, required = false,
                                 default = nil)
  if valid_611350 != nil:
    section.add "X-Amz-Content-Sha256", valid_611350
  var valid_611351 = header.getOrDefault("X-Amz-Date")
  valid_611351 = validateParameter(valid_611351, JString, required = false,
                                 default = nil)
  if valid_611351 != nil:
    section.add "X-Amz-Date", valid_611351
  var valid_611352 = header.getOrDefault("X-Amz-Credential")
  valid_611352 = validateParameter(valid_611352, JString, required = false,
                                 default = nil)
  if valid_611352 != nil:
    section.add "X-Amz-Credential", valid_611352
  var valid_611353 = header.getOrDefault("X-Amz-Security-Token")
  valid_611353 = validateParameter(valid_611353, JString, required = false,
                                 default = nil)
  if valid_611353 != nil:
    section.add "X-Amz-Security-Token", valid_611353
  var valid_611354 = header.getOrDefault("X-Amz-Algorithm")
  valid_611354 = validateParameter(valid_611354, JString, required = false,
                                 default = nil)
  if valid_611354 != nil:
    section.add "X-Amz-Algorithm", valid_611354
  var valid_611355 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611355 = validateParameter(valid_611355, JString, required = false,
                                 default = nil)
  if valid_611355 != nil:
    section.add "X-Amz-SignedHeaders", valid_611355
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611356: Call_AttachPrincipalPolicy_611344; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ## 
  let valid = call_611356.validator(path, query, header, formData, body)
  let scheme = call_611356.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611356.url(scheme.get, call_611356.host, call_611356.base,
                         call_611356.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611356, url, valid)

proc call*(call_611357: Call_AttachPrincipalPolicy_611344; policyName: string): Recallable =
  ## attachPrincipalPolicy
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ##   policyName: string (required)
  ##             : The policy name.
  var path_611358 = newJObject()
  add(path_611358, "policyName", newJString(policyName))
  result = call_611357.call(path_611358, nil, nil, nil, nil)

var attachPrincipalPolicy* = Call_AttachPrincipalPolicy_611344(
    name: "attachPrincipalPolicy", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/principal-policies/{policyName}#x-amzn-iot-principal",
    validator: validate_AttachPrincipalPolicy_611345, base: "/",
    url: url_AttachPrincipalPolicy_611346, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachPrincipalPolicy_611359 = ref object of OpenApiRestCall_610658
proc url_DetachPrincipalPolicy_611361(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/principal-policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "#x-amzn-iot-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachPrincipalPolicy_611360(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to detach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_611362 = path.getOrDefault("policyName")
  valid_611362 = validateParameter(valid_611362, JString, required = true,
                                 default = nil)
  if valid_611362 != nil:
    section.add "policyName", valid_611362
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : <p>The principal.</p> <p>If the principal is a certificate, specify the certificate ARN. If the principal is an Amazon Cognito identity, specify the identity ID.</p>
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611363 = header.getOrDefault("X-Amz-Signature")
  valid_611363 = validateParameter(valid_611363, JString, required = false,
                                 default = nil)
  if valid_611363 != nil:
    section.add "X-Amz-Signature", valid_611363
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_611364 = header.getOrDefault("x-amzn-iot-principal")
  valid_611364 = validateParameter(valid_611364, JString, required = true,
                                 default = nil)
  if valid_611364 != nil:
    section.add "x-amzn-iot-principal", valid_611364
  var valid_611365 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611365 = validateParameter(valid_611365, JString, required = false,
                                 default = nil)
  if valid_611365 != nil:
    section.add "X-Amz-Content-Sha256", valid_611365
  var valid_611366 = header.getOrDefault("X-Amz-Date")
  valid_611366 = validateParameter(valid_611366, JString, required = false,
                                 default = nil)
  if valid_611366 != nil:
    section.add "X-Amz-Date", valid_611366
  var valid_611367 = header.getOrDefault("X-Amz-Credential")
  valid_611367 = validateParameter(valid_611367, JString, required = false,
                                 default = nil)
  if valid_611367 != nil:
    section.add "X-Amz-Credential", valid_611367
  var valid_611368 = header.getOrDefault("X-Amz-Security-Token")
  valid_611368 = validateParameter(valid_611368, JString, required = false,
                                 default = nil)
  if valid_611368 != nil:
    section.add "X-Amz-Security-Token", valid_611368
  var valid_611369 = header.getOrDefault("X-Amz-Algorithm")
  valid_611369 = validateParameter(valid_611369, JString, required = false,
                                 default = nil)
  if valid_611369 != nil:
    section.add "X-Amz-Algorithm", valid_611369
  var valid_611370 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611370 = validateParameter(valid_611370, JString, required = false,
                                 default = nil)
  if valid_611370 != nil:
    section.add "X-Amz-SignedHeaders", valid_611370
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611371: Call_DetachPrincipalPolicy_611359; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ## 
  let valid = call_611371.validator(path, query, header, formData, body)
  let scheme = call_611371.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611371.url(scheme.get, call_611371.host, call_611371.base,
                         call_611371.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611371, url, valid)

proc call*(call_611372: Call_DetachPrincipalPolicy_611359; policyName: string): Recallable =
  ## detachPrincipalPolicy
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ##   policyName: string (required)
  ##             : The name of the policy to detach.
  var path_611373 = newJObject()
  add(path_611373, "policyName", newJString(policyName))
  result = call_611372.call(path_611373, nil, nil, nil, nil)

var detachPrincipalPolicy* = Call_DetachPrincipalPolicy_611359(
    name: "detachPrincipalPolicy", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/principal-policies/{policyName}#x-amzn-iot-principal",
    validator: validate_DetachPrincipalPolicy_611360, base: "/",
    url: url_DetachPrincipalPolicy_611361, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachSecurityProfile_611374 = ref object of OpenApiRestCall_610658
proc url_AttachSecurityProfile_611376(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"), (
        kind: ConstantSegment, value: "/targets#securityProfileTargetArn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachSecurityProfile_611375(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile that is attached.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_611377 = path.getOrDefault("securityProfileName")
  valid_611377 = validateParameter(valid_611377, JString, required = true,
                                 default = nil)
  if valid_611377 != nil:
    section.add "securityProfileName", valid_611377
  result.add "path", section
  ## parameters in `query` object:
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the target (thing group) to which the security profile is attached.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_611378 = query.getOrDefault("securityProfileTargetArn")
  valid_611378 = validateParameter(valid_611378, JString, required = true,
                                 default = nil)
  if valid_611378 != nil:
    section.add "securityProfileTargetArn", valid_611378
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611379 = header.getOrDefault("X-Amz-Signature")
  valid_611379 = validateParameter(valid_611379, JString, required = false,
                                 default = nil)
  if valid_611379 != nil:
    section.add "X-Amz-Signature", valid_611379
  var valid_611380 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611380 = validateParameter(valid_611380, JString, required = false,
                                 default = nil)
  if valid_611380 != nil:
    section.add "X-Amz-Content-Sha256", valid_611380
  var valid_611381 = header.getOrDefault("X-Amz-Date")
  valid_611381 = validateParameter(valid_611381, JString, required = false,
                                 default = nil)
  if valid_611381 != nil:
    section.add "X-Amz-Date", valid_611381
  var valid_611382 = header.getOrDefault("X-Amz-Credential")
  valid_611382 = validateParameter(valid_611382, JString, required = false,
                                 default = nil)
  if valid_611382 != nil:
    section.add "X-Amz-Credential", valid_611382
  var valid_611383 = header.getOrDefault("X-Amz-Security-Token")
  valid_611383 = validateParameter(valid_611383, JString, required = false,
                                 default = nil)
  if valid_611383 != nil:
    section.add "X-Amz-Security-Token", valid_611383
  var valid_611384 = header.getOrDefault("X-Amz-Algorithm")
  valid_611384 = validateParameter(valid_611384, JString, required = false,
                                 default = nil)
  if valid_611384 != nil:
    section.add "X-Amz-Algorithm", valid_611384
  var valid_611385 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611385 = validateParameter(valid_611385, JString, required = false,
                                 default = nil)
  if valid_611385 != nil:
    section.add "X-Amz-SignedHeaders", valid_611385
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611386: Call_AttachSecurityProfile_611374; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ## 
  let valid = call_611386.validator(path, query, header, formData, body)
  let scheme = call_611386.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611386.url(scheme.get, call_611386.host, call_611386.base,
                         call_611386.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611386, url, valid)

proc call*(call_611387: Call_AttachSecurityProfile_611374;
          securityProfileTargetArn: string; securityProfileName: string): Recallable =
  ## attachSecurityProfile
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the target (thing group) to which the security profile is attached.
  ##   securityProfileName: string (required)
  ##                      : The security profile that is attached.
  var path_611388 = newJObject()
  var query_611389 = newJObject()
  add(query_611389, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(path_611388, "securityProfileName", newJString(securityProfileName))
  result = call_611387.call(path_611388, query_611389, nil, nil, nil)

var attachSecurityProfile* = Call_AttachSecurityProfile_611374(
    name: "attachSecurityProfile", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}/targets#securityProfileTargetArn",
    validator: validate_AttachSecurityProfile_611375, base: "/",
    url: url_AttachSecurityProfile_611376, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachSecurityProfile_611390 = ref object of OpenApiRestCall_610658
proc url_DetachSecurityProfile_611392(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"), (
        kind: ConstantSegment, value: "/targets#securityProfileTargetArn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachSecurityProfile_611391(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile that is detached.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_611393 = path.getOrDefault("securityProfileName")
  valid_611393 = validateParameter(valid_611393, JString, required = true,
                                 default = nil)
  if valid_611393 != nil:
    section.add "securityProfileName", valid_611393
  result.add "path", section
  ## parameters in `query` object:
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the thing group from which the security profile is detached.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_611394 = query.getOrDefault("securityProfileTargetArn")
  valid_611394 = validateParameter(valid_611394, JString, required = true,
                                 default = nil)
  if valid_611394 != nil:
    section.add "securityProfileTargetArn", valid_611394
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611395 = header.getOrDefault("X-Amz-Signature")
  valid_611395 = validateParameter(valid_611395, JString, required = false,
                                 default = nil)
  if valid_611395 != nil:
    section.add "X-Amz-Signature", valid_611395
  var valid_611396 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611396 = validateParameter(valid_611396, JString, required = false,
                                 default = nil)
  if valid_611396 != nil:
    section.add "X-Amz-Content-Sha256", valid_611396
  var valid_611397 = header.getOrDefault("X-Amz-Date")
  valid_611397 = validateParameter(valid_611397, JString, required = false,
                                 default = nil)
  if valid_611397 != nil:
    section.add "X-Amz-Date", valid_611397
  var valid_611398 = header.getOrDefault("X-Amz-Credential")
  valid_611398 = validateParameter(valid_611398, JString, required = false,
                                 default = nil)
  if valid_611398 != nil:
    section.add "X-Amz-Credential", valid_611398
  var valid_611399 = header.getOrDefault("X-Amz-Security-Token")
  valid_611399 = validateParameter(valid_611399, JString, required = false,
                                 default = nil)
  if valid_611399 != nil:
    section.add "X-Amz-Security-Token", valid_611399
  var valid_611400 = header.getOrDefault("X-Amz-Algorithm")
  valid_611400 = validateParameter(valid_611400, JString, required = false,
                                 default = nil)
  if valid_611400 != nil:
    section.add "X-Amz-Algorithm", valid_611400
  var valid_611401 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611401 = validateParameter(valid_611401, JString, required = false,
                                 default = nil)
  if valid_611401 != nil:
    section.add "X-Amz-SignedHeaders", valid_611401
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611402: Call_DetachSecurityProfile_611390; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ## 
  let valid = call_611402.validator(path, query, header, formData, body)
  let scheme = call_611402.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611402.url(scheme.get, call_611402.host, call_611402.base,
                         call_611402.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611402, url, valid)

proc call*(call_611403: Call_DetachSecurityProfile_611390;
          securityProfileTargetArn: string; securityProfileName: string): Recallable =
  ## detachSecurityProfile
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the thing group from which the security profile is detached.
  ##   securityProfileName: string (required)
  ##                      : The security profile that is detached.
  var path_611404 = newJObject()
  var query_611405 = newJObject()
  add(query_611405, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(path_611404, "securityProfileName", newJString(securityProfileName))
  result = call_611403.call(path_611404, query_611405, nil, nil, nil)

var detachSecurityProfile* = Call_DetachSecurityProfile_611390(
    name: "detachSecurityProfile", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}/targets#securityProfileTargetArn",
    validator: validate_DetachSecurityProfile_611391, base: "/",
    url: url_DetachSecurityProfile_611392, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachThingPrincipal_611406 = ref object of OpenApiRestCall_610658
proc url_AttachThingPrincipal_611408(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals#x-amzn-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachThingPrincipal_611407(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_611409 = path.getOrDefault("thingName")
  valid_611409 = validateParameter(valid_611409, JString, required = true,
                                 default = nil)
  if valid_611409 != nil:
    section.add "thingName", valid_611409
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611410 = header.getOrDefault("X-Amz-Signature")
  valid_611410 = validateParameter(valid_611410, JString, required = false,
                                 default = nil)
  if valid_611410 != nil:
    section.add "X-Amz-Signature", valid_611410
  var valid_611411 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611411 = validateParameter(valid_611411, JString, required = false,
                                 default = nil)
  if valid_611411 != nil:
    section.add "X-Amz-Content-Sha256", valid_611411
  var valid_611412 = header.getOrDefault("X-Amz-Date")
  valid_611412 = validateParameter(valid_611412, JString, required = false,
                                 default = nil)
  if valid_611412 != nil:
    section.add "X-Amz-Date", valid_611412
  var valid_611413 = header.getOrDefault("X-Amz-Credential")
  valid_611413 = validateParameter(valid_611413, JString, required = false,
                                 default = nil)
  if valid_611413 != nil:
    section.add "X-Amz-Credential", valid_611413
  var valid_611414 = header.getOrDefault("X-Amz-Security-Token")
  valid_611414 = validateParameter(valid_611414, JString, required = false,
                                 default = nil)
  if valid_611414 != nil:
    section.add "X-Amz-Security-Token", valid_611414
  var valid_611415 = header.getOrDefault("X-Amz-Algorithm")
  valid_611415 = validateParameter(valid_611415, JString, required = false,
                                 default = nil)
  if valid_611415 != nil:
    section.add "X-Amz-Algorithm", valid_611415
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_611416 = header.getOrDefault("x-amzn-principal")
  valid_611416 = validateParameter(valid_611416, JString, required = true,
                                 default = nil)
  if valid_611416 != nil:
    section.add "x-amzn-principal", valid_611416
  var valid_611417 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611417 = validateParameter(valid_611417, JString, required = false,
                                 default = nil)
  if valid_611417 != nil:
    section.add "X-Amz-SignedHeaders", valid_611417
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611418: Call_AttachThingPrincipal_611406; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  let valid = call_611418.validator(path, query, header, formData, body)
  let scheme = call_611418.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611418.url(scheme.get, call_611418.host, call_611418.base,
                         call_611418.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611418, url, valid)

proc call*(call_611419: Call_AttachThingPrincipal_611406; thingName: string): Recallable =
  ## attachThingPrincipal
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_611420 = newJObject()
  add(path_611420, "thingName", newJString(thingName))
  result = call_611419.call(path_611420, nil, nil, nil, nil)

var attachThingPrincipal* = Call_AttachThingPrincipal_611406(
    name: "attachThingPrincipal", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/things/{thingName}/principals#x-amzn-principal",
    validator: validate_AttachThingPrincipal_611407, base: "/",
    url: url_AttachThingPrincipal_611408, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachThingPrincipal_611421 = ref object of OpenApiRestCall_610658
proc url_DetachThingPrincipal_611423(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals#x-amzn-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachThingPrincipal_611422(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_611424 = path.getOrDefault("thingName")
  valid_611424 = validateParameter(valid_611424, JString, required = true,
                                 default = nil)
  if valid_611424 != nil:
    section.add "thingName", valid_611424
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611425 = header.getOrDefault("X-Amz-Signature")
  valid_611425 = validateParameter(valid_611425, JString, required = false,
                                 default = nil)
  if valid_611425 != nil:
    section.add "X-Amz-Signature", valid_611425
  var valid_611426 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611426 = validateParameter(valid_611426, JString, required = false,
                                 default = nil)
  if valid_611426 != nil:
    section.add "X-Amz-Content-Sha256", valid_611426
  var valid_611427 = header.getOrDefault("X-Amz-Date")
  valid_611427 = validateParameter(valid_611427, JString, required = false,
                                 default = nil)
  if valid_611427 != nil:
    section.add "X-Amz-Date", valid_611427
  var valid_611428 = header.getOrDefault("X-Amz-Credential")
  valid_611428 = validateParameter(valid_611428, JString, required = false,
                                 default = nil)
  if valid_611428 != nil:
    section.add "X-Amz-Credential", valid_611428
  var valid_611429 = header.getOrDefault("X-Amz-Security-Token")
  valid_611429 = validateParameter(valid_611429, JString, required = false,
                                 default = nil)
  if valid_611429 != nil:
    section.add "X-Amz-Security-Token", valid_611429
  var valid_611430 = header.getOrDefault("X-Amz-Algorithm")
  valid_611430 = validateParameter(valid_611430, JString, required = false,
                                 default = nil)
  if valid_611430 != nil:
    section.add "X-Amz-Algorithm", valid_611430
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_611431 = header.getOrDefault("x-amzn-principal")
  valid_611431 = validateParameter(valid_611431, JString, required = true,
                                 default = nil)
  if valid_611431 != nil:
    section.add "x-amzn-principal", valid_611431
  var valid_611432 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611432 = validateParameter(valid_611432, JString, required = false,
                                 default = nil)
  if valid_611432 != nil:
    section.add "X-Amz-SignedHeaders", valid_611432
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611433: Call_DetachThingPrincipal_611421; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ## 
  let valid = call_611433.validator(path, query, header, formData, body)
  let scheme = call_611433.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611433.url(scheme.get, call_611433.host, call_611433.base,
                         call_611433.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611433, url, valid)

proc call*(call_611434: Call_DetachThingPrincipal_611421; thingName: string): Recallable =
  ## detachThingPrincipal
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_611435 = newJObject()
  add(path_611435, "thingName", newJString(thingName))
  result = call_611434.call(path_611435, nil, nil, nil, nil)

var detachThingPrincipal* = Call_DetachThingPrincipal_611421(
    name: "detachThingPrincipal", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/things/{thingName}/principals#x-amzn-principal",
    validator: validate_DetachThingPrincipal_611422, base: "/",
    url: url_DetachThingPrincipal_611423, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelAuditMitigationActionsTask_611436 = ref object of OpenApiRestCall_610658
proc url_CancelAuditMitigationActionsTask_611438(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelAuditMitigationActionsTask_611437(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The unique identifier for the task that you want to cancel. 
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_611439 = path.getOrDefault("taskId")
  valid_611439 = validateParameter(valid_611439, JString, required = true,
                                 default = nil)
  if valid_611439 != nil:
    section.add "taskId", valid_611439
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611440 = header.getOrDefault("X-Amz-Signature")
  valid_611440 = validateParameter(valid_611440, JString, required = false,
                                 default = nil)
  if valid_611440 != nil:
    section.add "X-Amz-Signature", valid_611440
  var valid_611441 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611441 = validateParameter(valid_611441, JString, required = false,
                                 default = nil)
  if valid_611441 != nil:
    section.add "X-Amz-Content-Sha256", valid_611441
  var valid_611442 = header.getOrDefault("X-Amz-Date")
  valid_611442 = validateParameter(valid_611442, JString, required = false,
                                 default = nil)
  if valid_611442 != nil:
    section.add "X-Amz-Date", valid_611442
  var valid_611443 = header.getOrDefault("X-Amz-Credential")
  valid_611443 = validateParameter(valid_611443, JString, required = false,
                                 default = nil)
  if valid_611443 != nil:
    section.add "X-Amz-Credential", valid_611443
  var valid_611444 = header.getOrDefault("X-Amz-Security-Token")
  valid_611444 = validateParameter(valid_611444, JString, required = false,
                                 default = nil)
  if valid_611444 != nil:
    section.add "X-Amz-Security-Token", valid_611444
  var valid_611445 = header.getOrDefault("X-Amz-Algorithm")
  valid_611445 = validateParameter(valid_611445, JString, required = false,
                                 default = nil)
  if valid_611445 != nil:
    section.add "X-Amz-Algorithm", valid_611445
  var valid_611446 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611446 = validateParameter(valid_611446, JString, required = false,
                                 default = nil)
  if valid_611446 != nil:
    section.add "X-Amz-SignedHeaders", valid_611446
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611447: Call_CancelAuditMitigationActionsTask_611436;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ## 
  let valid = call_611447.validator(path, query, header, formData, body)
  let scheme = call_611447.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611447.url(scheme.get, call_611447.host, call_611447.base,
                         call_611447.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611447, url, valid)

proc call*(call_611448: Call_CancelAuditMitigationActionsTask_611436;
          taskId: string): Recallable =
  ## cancelAuditMitigationActionsTask
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ##   taskId: string (required)
  ##         : The unique identifier for the task that you want to cancel. 
  var path_611449 = newJObject()
  add(path_611449, "taskId", newJString(taskId))
  result = call_611448.call(path_611449, nil, nil, nil, nil)

var cancelAuditMitigationActionsTask* = Call_CancelAuditMitigationActionsTask_611436(
    name: "cancelAuditMitigationActionsTask", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/tasks/{taskId}/cancel",
    validator: validate_CancelAuditMitigationActionsTask_611437, base: "/",
    url: url_CancelAuditMitigationActionsTask_611438,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelAuditTask_611450 = ref object of OpenApiRestCall_610658
proc url_CancelAuditTask_611452(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelAuditTask_611451(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_611453 = path.getOrDefault("taskId")
  valid_611453 = validateParameter(valid_611453, JString, required = true,
                                 default = nil)
  if valid_611453 != nil:
    section.add "taskId", valid_611453
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611454 = header.getOrDefault("X-Amz-Signature")
  valid_611454 = validateParameter(valid_611454, JString, required = false,
                                 default = nil)
  if valid_611454 != nil:
    section.add "X-Amz-Signature", valid_611454
  var valid_611455 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611455 = validateParameter(valid_611455, JString, required = false,
                                 default = nil)
  if valid_611455 != nil:
    section.add "X-Amz-Content-Sha256", valid_611455
  var valid_611456 = header.getOrDefault("X-Amz-Date")
  valid_611456 = validateParameter(valid_611456, JString, required = false,
                                 default = nil)
  if valid_611456 != nil:
    section.add "X-Amz-Date", valid_611456
  var valid_611457 = header.getOrDefault("X-Amz-Credential")
  valid_611457 = validateParameter(valid_611457, JString, required = false,
                                 default = nil)
  if valid_611457 != nil:
    section.add "X-Amz-Credential", valid_611457
  var valid_611458 = header.getOrDefault("X-Amz-Security-Token")
  valid_611458 = validateParameter(valid_611458, JString, required = false,
                                 default = nil)
  if valid_611458 != nil:
    section.add "X-Amz-Security-Token", valid_611458
  var valid_611459 = header.getOrDefault("X-Amz-Algorithm")
  valid_611459 = validateParameter(valid_611459, JString, required = false,
                                 default = nil)
  if valid_611459 != nil:
    section.add "X-Amz-Algorithm", valid_611459
  var valid_611460 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611460 = validateParameter(valid_611460, JString, required = false,
                                 default = nil)
  if valid_611460 != nil:
    section.add "X-Amz-SignedHeaders", valid_611460
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611461: Call_CancelAuditTask_611450; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ## 
  let valid = call_611461.validator(path, query, header, formData, body)
  let scheme = call_611461.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611461.url(scheme.get, call_611461.host, call_611461.base,
                         call_611461.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611461, url, valid)

proc call*(call_611462: Call_CancelAuditTask_611450; taskId: string): Recallable =
  ## cancelAuditTask
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ##   taskId: string (required)
  ##         : The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
  var path_611463 = newJObject()
  add(path_611463, "taskId", newJString(taskId))
  result = call_611462.call(path_611463, nil, nil, nil, nil)

var cancelAuditTask* = Call_CancelAuditTask_611450(name: "cancelAuditTask",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/audit/tasks/{taskId}/cancel", validator: validate_CancelAuditTask_611451,
    base: "/", url: url_CancelAuditTask_611452, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelCertificateTransfer_611464 = ref object of OpenApiRestCall_610658
proc url_CancelCertificateTransfer_611466(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cancel-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelCertificateTransfer_611465(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_611467 = path.getOrDefault("certificateId")
  valid_611467 = validateParameter(valid_611467, JString, required = true,
                                 default = nil)
  if valid_611467 != nil:
    section.add "certificateId", valid_611467
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611468 = header.getOrDefault("X-Amz-Signature")
  valid_611468 = validateParameter(valid_611468, JString, required = false,
                                 default = nil)
  if valid_611468 != nil:
    section.add "X-Amz-Signature", valid_611468
  var valid_611469 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611469 = validateParameter(valid_611469, JString, required = false,
                                 default = nil)
  if valid_611469 != nil:
    section.add "X-Amz-Content-Sha256", valid_611469
  var valid_611470 = header.getOrDefault("X-Amz-Date")
  valid_611470 = validateParameter(valid_611470, JString, required = false,
                                 default = nil)
  if valid_611470 != nil:
    section.add "X-Amz-Date", valid_611470
  var valid_611471 = header.getOrDefault("X-Amz-Credential")
  valid_611471 = validateParameter(valid_611471, JString, required = false,
                                 default = nil)
  if valid_611471 != nil:
    section.add "X-Amz-Credential", valid_611471
  var valid_611472 = header.getOrDefault("X-Amz-Security-Token")
  valid_611472 = validateParameter(valid_611472, JString, required = false,
                                 default = nil)
  if valid_611472 != nil:
    section.add "X-Amz-Security-Token", valid_611472
  var valid_611473 = header.getOrDefault("X-Amz-Algorithm")
  valid_611473 = validateParameter(valid_611473, JString, required = false,
                                 default = nil)
  if valid_611473 != nil:
    section.add "X-Amz-Algorithm", valid_611473
  var valid_611474 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611474 = validateParameter(valid_611474, JString, required = false,
                                 default = nil)
  if valid_611474 != nil:
    section.add "X-Amz-SignedHeaders", valid_611474
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611475: Call_CancelCertificateTransfer_611464; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ## 
  let valid = call_611475.validator(path, query, header, formData, body)
  let scheme = call_611475.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611475.url(scheme.get, call_611475.host, call_611475.base,
                         call_611475.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611475, url, valid)

proc call*(call_611476: Call_CancelCertificateTransfer_611464;
          certificateId: string): Recallable =
  ## cancelCertificateTransfer
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_611477 = newJObject()
  add(path_611477, "certificateId", newJString(certificateId))
  result = call_611476.call(path_611477, nil, nil, nil, nil)

var cancelCertificateTransfer* = Call_CancelCertificateTransfer_611464(
    name: "cancelCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/cancel-certificate-transfer/{certificateId}",
    validator: validate_CancelCertificateTransfer_611465, base: "/",
    url: url_CancelCertificateTransfer_611466,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelJob_611478 = ref object of OpenApiRestCall_610658
proc url_CancelJob_611480(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelJob_611479(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_611481 = path.getOrDefault("jobId")
  valid_611481 = validateParameter(valid_611481, JString, required = true,
                                 default = nil)
  if valid_611481 != nil:
    section.add "jobId", valid_611481
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
  section = newJObject()
  var valid_611482 = query.getOrDefault("force")
  valid_611482 = validateParameter(valid_611482, JBool, required = false, default = nil)
  if valid_611482 != nil:
    section.add "force", valid_611482
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611483 = header.getOrDefault("X-Amz-Signature")
  valid_611483 = validateParameter(valid_611483, JString, required = false,
                                 default = nil)
  if valid_611483 != nil:
    section.add "X-Amz-Signature", valid_611483
  var valid_611484 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611484 = validateParameter(valid_611484, JString, required = false,
                                 default = nil)
  if valid_611484 != nil:
    section.add "X-Amz-Content-Sha256", valid_611484
  var valid_611485 = header.getOrDefault("X-Amz-Date")
  valid_611485 = validateParameter(valid_611485, JString, required = false,
                                 default = nil)
  if valid_611485 != nil:
    section.add "X-Amz-Date", valid_611485
  var valid_611486 = header.getOrDefault("X-Amz-Credential")
  valid_611486 = validateParameter(valid_611486, JString, required = false,
                                 default = nil)
  if valid_611486 != nil:
    section.add "X-Amz-Credential", valid_611486
  var valid_611487 = header.getOrDefault("X-Amz-Security-Token")
  valid_611487 = validateParameter(valid_611487, JString, required = false,
                                 default = nil)
  if valid_611487 != nil:
    section.add "X-Amz-Security-Token", valid_611487
  var valid_611488 = header.getOrDefault("X-Amz-Algorithm")
  valid_611488 = validateParameter(valid_611488, JString, required = false,
                                 default = nil)
  if valid_611488 != nil:
    section.add "X-Amz-Algorithm", valid_611488
  var valid_611489 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611489 = validateParameter(valid_611489, JString, required = false,
                                 default = nil)
  if valid_611489 != nil:
    section.add "X-Amz-SignedHeaders", valid_611489
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611491: Call_CancelJob_611478; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a job.
  ## 
  let valid = call_611491.validator(path, query, header, formData, body)
  let scheme = call_611491.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611491.url(scheme.get, call_611491.host, call_611491.base,
                         call_611491.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611491, url, valid)

proc call*(call_611492: Call_CancelJob_611478; jobId: string; body: JsonNode;
          force: bool = false): Recallable =
  ## cancelJob
  ## Cancels a job.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   force: bool
  ##        : <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
  ##   body: JObject (required)
  var path_611493 = newJObject()
  var query_611494 = newJObject()
  var body_611495 = newJObject()
  add(path_611493, "jobId", newJString(jobId))
  add(query_611494, "force", newJBool(force))
  if body != nil:
    body_611495 = body
  result = call_611492.call(path_611493, query_611494, nil, nil, body_611495)

var cancelJob* = Call_CancelJob_611478(name: "cancelJob", meth: HttpMethod.HttpPut,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}/cancel",
                                    validator: validate_CancelJob_611479,
                                    base: "/", url: url_CancelJob_611480,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelJobExecution_611496 = ref object of OpenApiRestCall_610658
proc url_CancelJobExecution_611498(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelJobExecution_611497(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Cancels the execution of a job for a given thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The ID of the job to be canceled.
  ##   thingName: JString (required)
  ##            : The name of the thing whose execution of the job will be canceled.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_611499 = path.getOrDefault("jobId")
  valid_611499 = validateParameter(valid_611499, JString, required = true,
                                 default = nil)
  if valid_611499 != nil:
    section.add "jobId", valid_611499
  var valid_611500 = path.getOrDefault("thingName")
  valid_611500 = validateParameter(valid_611500, JString, required = true,
                                 default = nil)
  if valid_611500 != nil:
    section.add "thingName", valid_611500
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
  section = newJObject()
  var valid_611501 = query.getOrDefault("force")
  valid_611501 = validateParameter(valid_611501, JBool, required = false, default = nil)
  if valid_611501 != nil:
    section.add "force", valid_611501
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611502 = header.getOrDefault("X-Amz-Signature")
  valid_611502 = validateParameter(valid_611502, JString, required = false,
                                 default = nil)
  if valid_611502 != nil:
    section.add "X-Amz-Signature", valid_611502
  var valid_611503 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611503 = validateParameter(valid_611503, JString, required = false,
                                 default = nil)
  if valid_611503 != nil:
    section.add "X-Amz-Content-Sha256", valid_611503
  var valid_611504 = header.getOrDefault("X-Amz-Date")
  valid_611504 = validateParameter(valid_611504, JString, required = false,
                                 default = nil)
  if valid_611504 != nil:
    section.add "X-Amz-Date", valid_611504
  var valid_611505 = header.getOrDefault("X-Amz-Credential")
  valid_611505 = validateParameter(valid_611505, JString, required = false,
                                 default = nil)
  if valid_611505 != nil:
    section.add "X-Amz-Credential", valid_611505
  var valid_611506 = header.getOrDefault("X-Amz-Security-Token")
  valid_611506 = validateParameter(valid_611506, JString, required = false,
                                 default = nil)
  if valid_611506 != nil:
    section.add "X-Amz-Security-Token", valid_611506
  var valid_611507 = header.getOrDefault("X-Amz-Algorithm")
  valid_611507 = validateParameter(valid_611507, JString, required = false,
                                 default = nil)
  if valid_611507 != nil:
    section.add "X-Amz-Algorithm", valid_611507
  var valid_611508 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611508 = validateParameter(valid_611508, JString, required = false,
                                 default = nil)
  if valid_611508 != nil:
    section.add "X-Amz-SignedHeaders", valid_611508
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611510: Call_CancelJobExecution_611496; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels the execution of a job for a given thing.
  ## 
  let valid = call_611510.validator(path, query, header, formData, body)
  let scheme = call_611510.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611510.url(scheme.get, call_611510.host, call_611510.base,
                         call_611510.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611510, url, valid)

proc call*(call_611511: Call_CancelJobExecution_611496; jobId: string;
          thingName: string; body: JsonNode; force: bool = false): Recallable =
  ## cancelJobExecution
  ## Cancels the execution of a job for a given thing.
  ##   jobId: string (required)
  ##        : The ID of the job to be canceled.
  ##   thingName: string (required)
  ##            : The name of the thing whose execution of the job will be canceled.
  ##   force: bool
  ##        : <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
  ##   body: JObject (required)
  var path_611512 = newJObject()
  var query_611513 = newJObject()
  var body_611514 = newJObject()
  add(path_611512, "jobId", newJString(jobId))
  add(path_611512, "thingName", newJString(thingName))
  add(query_611513, "force", newJBool(force))
  if body != nil:
    body_611514 = body
  result = call_611511.call(path_611512, query_611513, nil, nil, body_611514)

var cancelJobExecution* = Call_CancelJobExecution_611496(
    name: "cancelJobExecution", meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/things/{thingName}/jobs/{jobId}/cancel",
    validator: validate_CancelJobExecution_611497, base: "/",
    url: url_CancelJobExecution_611498, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetDefaultAuthorizer_611527 = ref object of OpenApiRestCall_610658
proc url_SetDefaultAuthorizer_611529(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetDefaultAuthorizer_611528(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611530 = header.getOrDefault("X-Amz-Signature")
  valid_611530 = validateParameter(valid_611530, JString, required = false,
                                 default = nil)
  if valid_611530 != nil:
    section.add "X-Amz-Signature", valid_611530
  var valid_611531 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611531 = validateParameter(valid_611531, JString, required = false,
                                 default = nil)
  if valid_611531 != nil:
    section.add "X-Amz-Content-Sha256", valid_611531
  var valid_611532 = header.getOrDefault("X-Amz-Date")
  valid_611532 = validateParameter(valid_611532, JString, required = false,
                                 default = nil)
  if valid_611532 != nil:
    section.add "X-Amz-Date", valid_611532
  var valid_611533 = header.getOrDefault("X-Amz-Credential")
  valid_611533 = validateParameter(valid_611533, JString, required = false,
                                 default = nil)
  if valid_611533 != nil:
    section.add "X-Amz-Credential", valid_611533
  var valid_611534 = header.getOrDefault("X-Amz-Security-Token")
  valid_611534 = validateParameter(valid_611534, JString, required = false,
                                 default = nil)
  if valid_611534 != nil:
    section.add "X-Amz-Security-Token", valid_611534
  var valid_611535 = header.getOrDefault("X-Amz-Algorithm")
  valid_611535 = validateParameter(valid_611535, JString, required = false,
                                 default = nil)
  if valid_611535 != nil:
    section.add "X-Amz-Algorithm", valid_611535
  var valid_611536 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611536 = validateParameter(valid_611536, JString, required = false,
                                 default = nil)
  if valid_611536 != nil:
    section.add "X-Amz-SignedHeaders", valid_611536
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611538: Call_SetDefaultAuthorizer_611527; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ## 
  let valid = call_611538.validator(path, query, header, formData, body)
  let scheme = call_611538.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611538.url(scheme.get, call_611538.host, call_611538.base,
                         call_611538.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611538, url, valid)

proc call*(call_611539: Call_SetDefaultAuthorizer_611527; body: JsonNode): Recallable =
  ## setDefaultAuthorizer
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ##   body: JObject (required)
  var body_611540 = newJObject()
  if body != nil:
    body_611540 = body
  result = call_611539.call(nil, nil, nil, nil, body_611540)

var setDefaultAuthorizer* = Call_SetDefaultAuthorizer_611527(
    name: "setDefaultAuthorizer", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_SetDefaultAuthorizer_611528, base: "/",
    url: url_SetDefaultAuthorizer_611529, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeDefaultAuthorizer_611515 = ref object of OpenApiRestCall_610658
proc url_DescribeDefaultAuthorizer_611517(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeDefaultAuthorizer_611516(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes the default authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611518 = header.getOrDefault("X-Amz-Signature")
  valid_611518 = validateParameter(valid_611518, JString, required = false,
                                 default = nil)
  if valid_611518 != nil:
    section.add "X-Amz-Signature", valid_611518
  var valid_611519 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611519 = validateParameter(valid_611519, JString, required = false,
                                 default = nil)
  if valid_611519 != nil:
    section.add "X-Amz-Content-Sha256", valid_611519
  var valid_611520 = header.getOrDefault("X-Amz-Date")
  valid_611520 = validateParameter(valid_611520, JString, required = false,
                                 default = nil)
  if valid_611520 != nil:
    section.add "X-Amz-Date", valid_611520
  var valid_611521 = header.getOrDefault("X-Amz-Credential")
  valid_611521 = validateParameter(valid_611521, JString, required = false,
                                 default = nil)
  if valid_611521 != nil:
    section.add "X-Amz-Credential", valid_611521
  var valid_611522 = header.getOrDefault("X-Amz-Security-Token")
  valid_611522 = validateParameter(valid_611522, JString, required = false,
                                 default = nil)
  if valid_611522 != nil:
    section.add "X-Amz-Security-Token", valid_611522
  var valid_611523 = header.getOrDefault("X-Amz-Algorithm")
  valid_611523 = validateParameter(valid_611523, JString, required = false,
                                 default = nil)
  if valid_611523 != nil:
    section.add "X-Amz-Algorithm", valid_611523
  var valid_611524 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611524 = validateParameter(valid_611524, JString, required = false,
                                 default = nil)
  if valid_611524 != nil:
    section.add "X-Amz-SignedHeaders", valid_611524
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611525: Call_DescribeDefaultAuthorizer_611515; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes the default authorizer.
  ## 
  let valid = call_611525.validator(path, query, header, formData, body)
  let scheme = call_611525.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611525.url(scheme.get, call_611525.host, call_611525.base,
                         call_611525.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611525, url, valid)

proc call*(call_611526: Call_DescribeDefaultAuthorizer_611515): Recallable =
  ## describeDefaultAuthorizer
  ## Describes the default authorizer.
  result = call_611526.call(nil, nil, nil, nil, nil)

var describeDefaultAuthorizer* = Call_DescribeDefaultAuthorizer_611515(
    name: "describeDefaultAuthorizer", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_DescribeDefaultAuthorizer_611516, base: "/",
    url: url_DescribeDefaultAuthorizer_611517,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ClearDefaultAuthorizer_611541 = ref object of OpenApiRestCall_610658
proc url_ClearDefaultAuthorizer_611543(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ClearDefaultAuthorizer_611542(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Clears the default authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611544 = header.getOrDefault("X-Amz-Signature")
  valid_611544 = validateParameter(valid_611544, JString, required = false,
                                 default = nil)
  if valid_611544 != nil:
    section.add "X-Amz-Signature", valid_611544
  var valid_611545 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611545 = validateParameter(valid_611545, JString, required = false,
                                 default = nil)
  if valid_611545 != nil:
    section.add "X-Amz-Content-Sha256", valid_611545
  var valid_611546 = header.getOrDefault("X-Amz-Date")
  valid_611546 = validateParameter(valid_611546, JString, required = false,
                                 default = nil)
  if valid_611546 != nil:
    section.add "X-Amz-Date", valid_611546
  var valid_611547 = header.getOrDefault("X-Amz-Credential")
  valid_611547 = validateParameter(valid_611547, JString, required = false,
                                 default = nil)
  if valid_611547 != nil:
    section.add "X-Amz-Credential", valid_611547
  var valid_611548 = header.getOrDefault("X-Amz-Security-Token")
  valid_611548 = validateParameter(valid_611548, JString, required = false,
                                 default = nil)
  if valid_611548 != nil:
    section.add "X-Amz-Security-Token", valid_611548
  var valid_611549 = header.getOrDefault("X-Amz-Algorithm")
  valid_611549 = validateParameter(valid_611549, JString, required = false,
                                 default = nil)
  if valid_611549 != nil:
    section.add "X-Amz-Algorithm", valid_611549
  var valid_611550 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611550 = validateParameter(valid_611550, JString, required = false,
                                 default = nil)
  if valid_611550 != nil:
    section.add "X-Amz-SignedHeaders", valid_611550
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611551: Call_ClearDefaultAuthorizer_611541; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Clears the default authorizer.
  ## 
  let valid = call_611551.validator(path, query, header, formData, body)
  let scheme = call_611551.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611551.url(scheme.get, call_611551.host, call_611551.base,
                         call_611551.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611551, url, valid)

proc call*(call_611552: Call_ClearDefaultAuthorizer_611541): Recallable =
  ## clearDefaultAuthorizer
  ## Clears the default authorizer.
  result = call_611552.call(nil, nil, nil, nil, nil)

var clearDefaultAuthorizer* = Call_ClearDefaultAuthorizer_611541(
    name: "clearDefaultAuthorizer", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_ClearDefaultAuthorizer_611542, base: "/",
    url: url_ClearDefaultAuthorizer_611543, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ConfirmTopicRuleDestination_611553 = ref object of OpenApiRestCall_610658
proc url_ConfirmTopicRuleDestination_611555(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "confirmationToken" in path,
        "`confirmationToken` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/confirmdestination/"),
               (kind: VariableSegment, value: "confirmationToken")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ConfirmTopicRuleDestination_611554(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Confirms a topic rule destination. When you create a rule requiring a destination, AWS IoT sends a confirmation message to the endpoint or base address you specify. The message includes a token which you pass back when calling <code>ConfirmTopicRuleDestination</code> to confirm that you own or have access to the endpoint.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   confirmationToken: JString (required)
  ##                    : The token used to confirm ownership or access to the topic rule confirmation URL.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `confirmationToken` field"
  var valid_611556 = path.getOrDefault("confirmationToken")
  valid_611556 = validateParameter(valid_611556, JString, required = true,
                                 default = nil)
  if valid_611556 != nil:
    section.add "confirmationToken", valid_611556
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611557 = header.getOrDefault("X-Amz-Signature")
  valid_611557 = validateParameter(valid_611557, JString, required = false,
                                 default = nil)
  if valid_611557 != nil:
    section.add "X-Amz-Signature", valid_611557
  var valid_611558 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611558 = validateParameter(valid_611558, JString, required = false,
                                 default = nil)
  if valid_611558 != nil:
    section.add "X-Amz-Content-Sha256", valid_611558
  var valid_611559 = header.getOrDefault("X-Amz-Date")
  valid_611559 = validateParameter(valid_611559, JString, required = false,
                                 default = nil)
  if valid_611559 != nil:
    section.add "X-Amz-Date", valid_611559
  var valid_611560 = header.getOrDefault("X-Amz-Credential")
  valid_611560 = validateParameter(valid_611560, JString, required = false,
                                 default = nil)
  if valid_611560 != nil:
    section.add "X-Amz-Credential", valid_611560
  var valid_611561 = header.getOrDefault("X-Amz-Security-Token")
  valid_611561 = validateParameter(valid_611561, JString, required = false,
                                 default = nil)
  if valid_611561 != nil:
    section.add "X-Amz-Security-Token", valid_611561
  var valid_611562 = header.getOrDefault("X-Amz-Algorithm")
  valid_611562 = validateParameter(valid_611562, JString, required = false,
                                 default = nil)
  if valid_611562 != nil:
    section.add "X-Amz-Algorithm", valid_611562
  var valid_611563 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611563 = validateParameter(valid_611563, JString, required = false,
                                 default = nil)
  if valid_611563 != nil:
    section.add "X-Amz-SignedHeaders", valid_611563
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611564: Call_ConfirmTopicRuleDestination_611553; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Confirms a topic rule destination. When you create a rule requiring a destination, AWS IoT sends a confirmation message to the endpoint or base address you specify. The message includes a token which you pass back when calling <code>ConfirmTopicRuleDestination</code> to confirm that you own or have access to the endpoint.
  ## 
  let valid = call_611564.validator(path, query, header, formData, body)
  let scheme = call_611564.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611564.url(scheme.get, call_611564.host, call_611564.base,
                         call_611564.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611564, url, valid)

proc call*(call_611565: Call_ConfirmTopicRuleDestination_611553;
          confirmationToken: string): Recallable =
  ## confirmTopicRuleDestination
  ## Confirms a topic rule destination. When you create a rule requiring a destination, AWS IoT sends a confirmation message to the endpoint or base address you specify. The message includes a token which you pass back when calling <code>ConfirmTopicRuleDestination</code> to confirm that you own or have access to the endpoint.
  ##   confirmationToken: string (required)
  ##                    : The token used to confirm ownership or access to the topic rule confirmation URL.
  var path_611566 = newJObject()
  add(path_611566, "confirmationToken", newJString(confirmationToken))
  result = call_611565.call(path_611566, nil, nil, nil, nil)

var confirmTopicRuleDestination* = Call_ConfirmTopicRuleDestination_611553(
    name: "confirmTopicRuleDestination", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/confirmdestination/{confirmationToken}",
    validator: validate_ConfirmTopicRuleDestination_611554, base: "/",
    url: url_ConfirmTopicRuleDestination_611555,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateAuthorizer_611581 = ref object of OpenApiRestCall_610658
proc url_UpdateAuthorizer_611583(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateAuthorizer_611582(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Updates an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_611584 = path.getOrDefault("authorizerName")
  valid_611584 = validateParameter(valid_611584, JString, required = true,
                                 default = nil)
  if valid_611584 != nil:
    section.add "authorizerName", valid_611584
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611585 = header.getOrDefault("X-Amz-Signature")
  valid_611585 = validateParameter(valid_611585, JString, required = false,
                                 default = nil)
  if valid_611585 != nil:
    section.add "X-Amz-Signature", valid_611585
  var valid_611586 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611586 = validateParameter(valid_611586, JString, required = false,
                                 default = nil)
  if valid_611586 != nil:
    section.add "X-Amz-Content-Sha256", valid_611586
  var valid_611587 = header.getOrDefault("X-Amz-Date")
  valid_611587 = validateParameter(valid_611587, JString, required = false,
                                 default = nil)
  if valid_611587 != nil:
    section.add "X-Amz-Date", valid_611587
  var valid_611588 = header.getOrDefault("X-Amz-Credential")
  valid_611588 = validateParameter(valid_611588, JString, required = false,
                                 default = nil)
  if valid_611588 != nil:
    section.add "X-Amz-Credential", valid_611588
  var valid_611589 = header.getOrDefault("X-Amz-Security-Token")
  valid_611589 = validateParameter(valid_611589, JString, required = false,
                                 default = nil)
  if valid_611589 != nil:
    section.add "X-Amz-Security-Token", valid_611589
  var valid_611590 = header.getOrDefault("X-Amz-Algorithm")
  valid_611590 = validateParameter(valid_611590, JString, required = false,
                                 default = nil)
  if valid_611590 != nil:
    section.add "X-Amz-Algorithm", valid_611590
  var valid_611591 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611591 = validateParameter(valid_611591, JString, required = false,
                                 default = nil)
  if valid_611591 != nil:
    section.add "X-Amz-SignedHeaders", valid_611591
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611593: Call_UpdateAuthorizer_611581; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an authorizer.
  ## 
  let valid = call_611593.validator(path, query, header, formData, body)
  let scheme = call_611593.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611593.url(scheme.get, call_611593.host, call_611593.base,
                         call_611593.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611593, url, valid)

proc call*(call_611594: Call_UpdateAuthorizer_611581; authorizerName: string;
          body: JsonNode): Recallable =
  ## updateAuthorizer
  ## Updates an authorizer.
  ##   authorizerName: string (required)
  ##                 : The authorizer name.
  ##   body: JObject (required)
  var path_611595 = newJObject()
  var body_611596 = newJObject()
  add(path_611595, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_611596 = body
  result = call_611594.call(path_611595, nil, nil, nil, body_611596)

var updateAuthorizer* = Call_UpdateAuthorizer_611581(name: "updateAuthorizer",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_UpdateAuthorizer_611582,
    base: "/", url: url_UpdateAuthorizer_611583,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateAuthorizer_611597 = ref object of OpenApiRestCall_610658
proc url_CreateAuthorizer_611599(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateAuthorizer_611598(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Creates an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_611600 = path.getOrDefault("authorizerName")
  valid_611600 = validateParameter(valid_611600, JString, required = true,
                                 default = nil)
  if valid_611600 != nil:
    section.add "authorizerName", valid_611600
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611601 = header.getOrDefault("X-Amz-Signature")
  valid_611601 = validateParameter(valid_611601, JString, required = false,
                                 default = nil)
  if valid_611601 != nil:
    section.add "X-Amz-Signature", valid_611601
  var valid_611602 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611602 = validateParameter(valid_611602, JString, required = false,
                                 default = nil)
  if valid_611602 != nil:
    section.add "X-Amz-Content-Sha256", valid_611602
  var valid_611603 = header.getOrDefault("X-Amz-Date")
  valid_611603 = validateParameter(valid_611603, JString, required = false,
                                 default = nil)
  if valid_611603 != nil:
    section.add "X-Amz-Date", valid_611603
  var valid_611604 = header.getOrDefault("X-Amz-Credential")
  valid_611604 = validateParameter(valid_611604, JString, required = false,
                                 default = nil)
  if valid_611604 != nil:
    section.add "X-Amz-Credential", valid_611604
  var valid_611605 = header.getOrDefault("X-Amz-Security-Token")
  valid_611605 = validateParameter(valid_611605, JString, required = false,
                                 default = nil)
  if valid_611605 != nil:
    section.add "X-Amz-Security-Token", valid_611605
  var valid_611606 = header.getOrDefault("X-Amz-Algorithm")
  valid_611606 = validateParameter(valid_611606, JString, required = false,
                                 default = nil)
  if valid_611606 != nil:
    section.add "X-Amz-Algorithm", valid_611606
  var valid_611607 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611607 = validateParameter(valid_611607, JString, required = false,
                                 default = nil)
  if valid_611607 != nil:
    section.add "X-Amz-SignedHeaders", valid_611607
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611609: Call_CreateAuthorizer_611597; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates an authorizer.
  ## 
  let valid = call_611609.validator(path, query, header, formData, body)
  let scheme = call_611609.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611609.url(scheme.get, call_611609.host, call_611609.base,
                         call_611609.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611609, url, valid)

proc call*(call_611610: Call_CreateAuthorizer_611597; authorizerName: string;
          body: JsonNode): Recallable =
  ## createAuthorizer
  ## Creates an authorizer.
  ##   authorizerName: string (required)
  ##                 : The authorizer name.
  ##   body: JObject (required)
  var path_611611 = newJObject()
  var body_611612 = newJObject()
  add(path_611611, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_611612 = body
  result = call_611610.call(path_611611, nil, nil, nil, body_611612)

var createAuthorizer* = Call_CreateAuthorizer_611597(name: "createAuthorizer",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_CreateAuthorizer_611598,
    base: "/", url: url_CreateAuthorizer_611599,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuthorizer_611567 = ref object of OpenApiRestCall_610658
proc url_DescribeAuthorizer_611569(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuthorizer_611568(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Describes an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The name of the authorizer to describe.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_611570 = path.getOrDefault("authorizerName")
  valid_611570 = validateParameter(valid_611570, JString, required = true,
                                 default = nil)
  if valid_611570 != nil:
    section.add "authorizerName", valid_611570
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611571 = header.getOrDefault("X-Amz-Signature")
  valid_611571 = validateParameter(valid_611571, JString, required = false,
                                 default = nil)
  if valid_611571 != nil:
    section.add "X-Amz-Signature", valid_611571
  var valid_611572 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611572 = validateParameter(valid_611572, JString, required = false,
                                 default = nil)
  if valid_611572 != nil:
    section.add "X-Amz-Content-Sha256", valid_611572
  var valid_611573 = header.getOrDefault("X-Amz-Date")
  valid_611573 = validateParameter(valid_611573, JString, required = false,
                                 default = nil)
  if valid_611573 != nil:
    section.add "X-Amz-Date", valid_611573
  var valid_611574 = header.getOrDefault("X-Amz-Credential")
  valid_611574 = validateParameter(valid_611574, JString, required = false,
                                 default = nil)
  if valid_611574 != nil:
    section.add "X-Amz-Credential", valid_611574
  var valid_611575 = header.getOrDefault("X-Amz-Security-Token")
  valid_611575 = validateParameter(valid_611575, JString, required = false,
                                 default = nil)
  if valid_611575 != nil:
    section.add "X-Amz-Security-Token", valid_611575
  var valid_611576 = header.getOrDefault("X-Amz-Algorithm")
  valid_611576 = validateParameter(valid_611576, JString, required = false,
                                 default = nil)
  if valid_611576 != nil:
    section.add "X-Amz-Algorithm", valid_611576
  var valid_611577 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611577 = validateParameter(valid_611577, JString, required = false,
                                 default = nil)
  if valid_611577 != nil:
    section.add "X-Amz-SignedHeaders", valid_611577
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611578: Call_DescribeAuthorizer_611567; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes an authorizer.
  ## 
  let valid = call_611578.validator(path, query, header, formData, body)
  let scheme = call_611578.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611578.url(scheme.get, call_611578.host, call_611578.base,
                         call_611578.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611578, url, valid)

proc call*(call_611579: Call_DescribeAuthorizer_611567; authorizerName: string): Recallable =
  ## describeAuthorizer
  ## Describes an authorizer.
  ##   authorizerName: string (required)
  ##                 : The name of the authorizer to describe.
  var path_611580 = newJObject()
  add(path_611580, "authorizerName", newJString(authorizerName))
  result = call_611579.call(path_611580, nil, nil, nil, nil)

var describeAuthorizer* = Call_DescribeAuthorizer_611567(
    name: "describeAuthorizer", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_DescribeAuthorizer_611568,
    base: "/", url: url_DescribeAuthorizer_611569,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteAuthorizer_611613 = ref object of OpenApiRestCall_610658
proc url_DeleteAuthorizer_611615(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteAuthorizer_611614(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Deletes an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The name of the authorizer to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_611616 = path.getOrDefault("authorizerName")
  valid_611616 = validateParameter(valid_611616, JString, required = true,
                                 default = nil)
  if valid_611616 != nil:
    section.add "authorizerName", valid_611616
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611617 = header.getOrDefault("X-Amz-Signature")
  valid_611617 = validateParameter(valid_611617, JString, required = false,
                                 default = nil)
  if valid_611617 != nil:
    section.add "X-Amz-Signature", valid_611617
  var valid_611618 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611618 = validateParameter(valid_611618, JString, required = false,
                                 default = nil)
  if valid_611618 != nil:
    section.add "X-Amz-Content-Sha256", valid_611618
  var valid_611619 = header.getOrDefault("X-Amz-Date")
  valid_611619 = validateParameter(valid_611619, JString, required = false,
                                 default = nil)
  if valid_611619 != nil:
    section.add "X-Amz-Date", valid_611619
  var valid_611620 = header.getOrDefault("X-Amz-Credential")
  valid_611620 = validateParameter(valid_611620, JString, required = false,
                                 default = nil)
  if valid_611620 != nil:
    section.add "X-Amz-Credential", valid_611620
  var valid_611621 = header.getOrDefault("X-Amz-Security-Token")
  valid_611621 = validateParameter(valid_611621, JString, required = false,
                                 default = nil)
  if valid_611621 != nil:
    section.add "X-Amz-Security-Token", valid_611621
  var valid_611622 = header.getOrDefault("X-Amz-Algorithm")
  valid_611622 = validateParameter(valid_611622, JString, required = false,
                                 default = nil)
  if valid_611622 != nil:
    section.add "X-Amz-Algorithm", valid_611622
  var valid_611623 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611623 = validateParameter(valid_611623, JString, required = false,
                                 default = nil)
  if valid_611623 != nil:
    section.add "X-Amz-SignedHeaders", valid_611623
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611624: Call_DeleteAuthorizer_611613; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an authorizer.
  ## 
  let valid = call_611624.validator(path, query, header, formData, body)
  let scheme = call_611624.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611624.url(scheme.get, call_611624.host, call_611624.base,
                         call_611624.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611624, url, valid)

proc call*(call_611625: Call_DeleteAuthorizer_611613; authorizerName: string): Recallable =
  ## deleteAuthorizer
  ## Deletes an authorizer.
  ##   authorizerName: string (required)
  ##                 : The name of the authorizer to delete.
  var path_611626 = newJObject()
  add(path_611626, "authorizerName", newJString(authorizerName))
  result = call_611625.call(path_611626, nil, nil, nil, nil)

var deleteAuthorizer* = Call_DeleteAuthorizer_611613(name: "deleteAuthorizer",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_DeleteAuthorizer_611614,
    base: "/", url: url_DeleteAuthorizer_611615,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateBillingGroup_611641 = ref object of OpenApiRestCall_610658
proc url_CreateBillingGroup_611643(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateBillingGroup_611642(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Creates a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name you wish to give to the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_611644 = path.getOrDefault("billingGroupName")
  valid_611644 = validateParameter(valid_611644, JString, required = true,
                                 default = nil)
  if valid_611644 != nil:
    section.add "billingGroupName", valid_611644
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611645 = header.getOrDefault("X-Amz-Signature")
  valid_611645 = validateParameter(valid_611645, JString, required = false,
                                 default = nil)
  if valid_611645 != nil:
    section.add "X-Amz-Signature", valid_611645
  var valid_611646 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611646 = validateParameter(valid_611646, JString, required = false,
                                 default = nil)
  if valid_611646 != nil:
    section.add "X-Amz-Content-Sha256", valid_611646
  var valid_611647 = header.getOrDefault("X-Amz-Date")
  valid_611647 = validateParameter(valid_611647, JString, required = false,
                                 default = nil)
  if valid_611647 != nil:
    section.add "X-Amz-Date", valid_611647
  var valid_611648 = header.getOrDefault("X-Amz-Credential")
  valid_611648 = validateParameter(valid_611648, JString, required = false,
                                 default = nil)
  if valid_611648 != nil:
    section.add "X-Amz-Credential", valid_611648
  var valid_611649 = header.getOrDefault("X-Amz-Security-Token")
  valid_611649 = validateParameter(valid_611649, JString, required = false,
                                 default = nil)
  if valid_611649 != nil:
    section.add "X-Amz-Security-Token", valid_611649
  var valid_611650 = header.getOrDefault("X-Amz-Algorithm")
  valid_611650 = validateParameter(valid_611650, JString, required = false,
                                 default = nil)
  if valid_611650 != nil:
    section.add "X-Amz-Algorithm", valid_611650
  var valid_611651 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611651 = validateParameter(valid_611651, JString, required = false,
                                 default = nil)
  if valid_611651 != nil:
    section.add "X-Amz-SignedHeaders", valid_611651
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611653: Call_CreateBillingGroup_611641; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a billing group.
  ## 
  let valid = call_611653.validator(path, query, header, formData, body)
  let scheme = call_611653.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611653.url(scheme.get, call_611653.host, call_611653.base,
                         call_611653.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611653, url, valid)

proc call*(call_611654: Call_CreateBillingGroup_611641; body: JsonNode;
          billingGroupName: string): Recallable =
  ## createBillingGroup
  ## Creates a billing group.
  ##   body: JObject (required)
  ##   billingGroupName: string (required)
  ##                   : The name you wish to give to the billing group.
  var path_611655 = newJObject()
  var body_611656 = newJObject()
  if body != nil:
    body_611656 = body
  add(path_611655, "billingGroupName", newJString(billingGroupName))
  result = call_611654.call(path_611655, nil, nil, nil, body_611656)

var createBillingGroup* = Call_CreateBillingGroup_611641(
    name: "createBillingGroup", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_CreateBillingGroup_611642, base: "/",
    url: url_CreateBillingGroup_611643, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeBillingGroup_611627 = ref object of OpenApiRestCall_610658
proc url_DescribeBillingGroup_611629(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeBillingGroup_611628(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_611630 = path.getOrDefault("billingGroupName")
  valid_611630 = validateParameter(valid_611630, JString, required = true,
                                 default = nil)
  if valid_611630 != nil:
    section.add "billingGroupName", valid_611630
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611631 = header.getOrDefault("X-Amz-Signature")
  valid_611631 = validateParameter(valid_611631, JString, required = false,
                                 default = nil)
  if valid_611631 != nil:
    section.add "X-Amz-Signature", valid_611631
  var valid_611632 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611632 = validateParameter(valid_611632, JString, required = false,
                                 default = nil)
  if valid_611632 != nil:
    section.add "X-Amz-Content-Sha256", valid_611632
  var valid_611633 = header.getOrDefault("X-Amz-Date")
  valid_611633 = validateParameter(valid_611633, JString, required = false,
                                 default = nil)
  if valid_611633 != nil:
    section.add "X-Amz-Date", valid_611633
  var valid_611634 = header.getOrDefault("X-Amz-Credential")
  valid_611634 = validateParameter(valid_611634, JString, required = false,
                                 default = nil)
  if valid_611634 != nil:
    section.add "X-Amz-Credential", valid_611634
  var valid_611635 = header.getOrDefault("X-Amz-Security-Token")
  valid_611635 = validateParameter(valid_611635, JString, required = false,
                                 default = nil)
  if valid_611635 != nil:
    section.add "X-Amz-Security-Token", valid_611635
  var valid_611636 = header.getOrDefault("X-Amz-Algorithm")
  valid_611636 = validateParameter(valid_611636, JString, required = false,
                                 default = nil)
  if valid_611636 != nil:
    section.add "X-Amz-Algorithm", valid_611636
  var valid_611637 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611637 = validateParameter(valid_611637, JString, required = false,
                                 default = nil)
  if valid_611637 != nil:
    section.add "X-Amz-SignedHeaders", valid_611637
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611638: Call_DescribeBillingGroup_611627; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about a billing group.
  ## 
  let valid = call_611638.validator(path, query, header, formData, body)
  let scheme = call_611638.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611638.url(scheme.get, call_611638.host, call_611638.base,
                         call_611638.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611638, url, valid)

proc call*(call_611639: Call_DescribeBillingGroup_611627; billingGroupName: string): Recallable =
  ## describeBillingGroup
  ## Returns information about a billing group.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_611640 = newJObject()
  add(path_611640, "billingGroupName", newJString(billingGroupName))
  result = call_611639.call(path_611640, nil, nil, nil, nil)

var describeBillingGroup* = Call_DescribeBillingGroup_611627(
    name: "describeBillingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_DescribeBillingGroup_611628, base: "/",
    url: url_DescribeBillingGroup_611629, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateBillingGroup_611673 = ref object of OpenApiRestCall_610658
proc url_UpdateBillingGroup_611675(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateBillingGroup_611674(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Updates information about the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_611676 = path.getOrDefault("billingGroupName")
  valid_611676 = validateParameter(valid_611676, JString, required = true,
                                 default = nil)
  if valid_611676 != nil:
    section.add "billingGroupName", valid_611676
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611677 = header.getOrDefault("X-Amz-Signature")
  valid_611677 = validateParameter(valid_611677, JString, required = false,
                                 default = nil)
  if valid_611677 != nil:
    section.add "X-Amz-Signature", valid_611677
  var valid_611678 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611678 = validateParameter(valid_611678, JString, required = false,
                                 default = nil)
  if valid_611678 != nil:
    section.add "X-Amz-Content-Sha256", valid_611678
  var valid_611679 = header.getOrDefault("X-Amz-Date")
  valid_611679 = validateParameter(valid_611679, JString, required = false,
                                 default = nil)
  if valid_611679 != nil:
    section.add "X-Amz-Date", valid_611679
  var valid_611680 = header.getOrDefault("X-Amz-Credential")
  valid_611680 = validateParameter(valid_611680, JString, required = false,
                                 default = nil)
  if valid_611680 != nil:
    section.add "X-Amz-Credential", valid_611680
  var valid_611681 = header.getOrDefault("X-Amz-Security-Token")
  valid_611681 = validateParameter(valid_611681, JString, required = false,
                                 default = nil)
  if valid_611681 != nil:
    section.add "X-Amz-Security-Token", valid_611681
  var valid_611682 = header.getOrDefault("X-Amz-Algorithm")
  valid_611682 = validateParameter(valid_611682, JString, required = false,
                                 default = nil)
  if valid_611682 != nil:
    section.add "X-Amz-Algorithm", valid_611682
  var valid_611683 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611683 = validateParameter(valid_611683, JString, required = false,
                                 default = nil)
  if valid_611683 != nil:
    section.add "X-Amz-SignedHeaders", valid_611683
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611685: Call_UpdateBillingGroup_611673; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates information about the billing group.
  ## 
  let valid = call_611685.validator(path, query, header, formData, body)
  let scheme = call_611685.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611685.url(scheme.get, call_611685.host, call_611685.base,
                         call_611685.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611685, url, valid)

proc call*(call_611686: Call_UpdateBillingGroup_611673; body: JsonNode;
          billingGroupName: string): Recallable =
  ## updateBillingGroup
  ## Updates information about the billing group.
  ##   body: JObject (required)
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_611687 = newJObject()
  var body_611688 = newJObject()
  if body != nil:
    body_611688 = body
  add(path_611687, "billingGroupName", newJString(billingGroupName))
  result = call_611686.call(path_611687, nil, nil, nil, body_611688)

var updateBillingGroup* = Call_UpdateBillingGroup_611673(
    name: "updateBillingGroup", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_UpdateBillingGroup_611674, base: "/",
    url: url_UpdateBillingGroup_611675, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteBillingGroup_611657 = ref object of OpenApiRestCall_610658
proc url_DeleteBillingGroup_611659(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteBillingGroup_611658(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deletes the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_611660 = path.getOrDefault("billingGroupName")
  valid_611660 = validateParameter(valid_611660, JString, required = true,
                                 default = nil)
  if valid_611660 != nil:
    section.add "billingGroupName", valid_611660
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.
  section = newJObject()
  var valid_611661 = query.getOrDefault("expectedVersion")
  valid_611661 = validateParameter(valid_611661, JInt, required = false, default = nil)
  if valid_611661 != nil:
    section.add "expectedVersion", valid_611661
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611662 = header.getOrDefault("X-Amz-Signature")
  valid_611662 = validateParameter(valid_611662, JString, required = false,
                                 default = nil)
  if valid_611662 != nil:
    section.add "X-Amz-Signature", valid_611662
  var valid_611663 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611663 = validateParameter(valid_611663, JString, required = false,
                                 default = nil)
  if valid_611663 != nil:
    section.add "X-Amz-Content-Sha256", valid_611663
  var valid_611664 = header.getOrDefault("X-Amz-Date")
  valid_611664 = validateParameter(valid_611664, JString, required = false,
                                 default = nil)
  if valid_611664 != nil:
    section.add "X-Amz-Date", valid_611664
  var valid_611665 = header.getOrDefault("X-Amz-Credential")
  valid_611665 = validateParameter(valid_611665, JString, required = false,
                                 default = nil)
  if valid_611665 != nil:
    section.add "X-Amz-Credential", valid_611665
  var valid_611666 = header.getOrDefault("X-Amz-Security-Token")
  valid_611666 = validateParameter(valid_611666, JString, required = false,
                                 default = nil)
  if valid_611666 != nil:
    section.add "X-Amz-Security-Token", valid_611666
  var valid_611667 = header.getOrDefault("X-Amz-Algorithm")
  valid_611667 = validateParameter(valid_611667, JString, required = false,
                                 default = nil)
  if valid_611667 != nil:
    section.add "X-Amz-Algorithm", valid_611667
  var valid_611668 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611668 = validateParameter(valid_611668, JString, required = false,
                                 default = nil)
  if valid_611668 != nil:
    section.add "X-Amz-SignedHeaders", valid_611668
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611669: Call_DeleteBillingGroup_611657; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the billing group.
  ## 
  let valid = call_611669.validator(path, query, header, formData, body)
  let scheme = call_611669.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611669.url(scheme.get, call_611669.host, call_611669.base,
                         call_611669.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611669, url, valid)

proc call*(call_611670: Call_DeleteBillingGroup_611657; billingGroupName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteBillingGroup
  ## Deletes the billing group.
  ##   expectedVersion: int
  ##                  : The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_611671 = newJObject()
  var query_611672 = newJObject()
  add(query_611672, "expectedVersion", newJInt(expectedVersion))
  add(path_611671, "billingGroupName", newJString(billingGroupName))
  result = call_611670.call(path_611671, query_611672, nil, nil, nil)

var deleteBillingGroup* = Call_DeleteBillingGroup_611657(
    name: "deleteBillingGroup", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_DeleteBillingGroup_611658, base: "/",
    url: url_DeleteBillingGroup_611659, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateCertificateFromCsr_611705 = ref object of OpenApiRestCall_610658
proc url_CreateCertificateFromCsr_611707(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateCertificateFromCsr_611706(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_611708 = query.getOrDefault("setAsActive")
  valid_611708 = validateParameter(valid_611708, JBool, required = false, default = nil)
  if valid_611708 != nil:
    section.add "setAsActive", valid_611708
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611709 = header.getOrDefault("X-Amz-Signature")
  valid_611709 = validateParameter(valid_611709, JString, required = false,
                                 default = nil)
  if valid_611709 != nil:
    section.add "X-Amz-Signature", valid_611709
  var valid_611710 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611710 = validateParameter(valid_611710, JString, required = false,
                                 default = nil)
  if valid_611710 != nil:
    section.add "X-Amz-Content-Sha256", valid_611710
  var valid_611711 = header.getOrDefault("X-Amz-Date")
  valid_611711 = validateParameter(valid_611711, JString, required = false,
                                 default = nil)
  if valid_611711 != nil:
    section.add "X-Amz-Date", valid_611711
  var valid_611712 = header.getOrDefault("X-Amz-Credential")
  valid_611712 = validateParameter(valid_611712, JString, required = false,
                                 default = nil)
  if valid_611712 != nil:
    section.add "X-Amz-Credential", valid_611712
  var valid_611713 = header.getOrDefault("X-Amz-Security-Token")
  valid_611713 = validateParameter(valid_611713, JString, required = false,
                                 default = nil)
  if valid_611713 != nil:
    section.add "X-Amz-Security-Token", valid_611713
  var valid_611714 = header.getOrDefault("X-Amz-Algorithm")
  valid_611714 = validateParameter(valid_611714, JString, required = false,
                                 default = nil)
  if valid_611714 != nil:
    section.add "X-Amz-Algorithm", valid_611714
  var valid_611715 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611715 = validateParameter(valid_611715, JString, required = false,
                                 default = nil)
  if valid_611715 != nil:
    section.add "X-Amz-SignedHeaders", valid_611715
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611717: Call_CreateCertificateFromCsr_611705; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ## 
  let valid = call_611717.validator(path, query, header, formData, body)
  let scheme = call_611717.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611717.url(scheme.get, call_611717.host, call_611717.base,
                         call_611717.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611717, url, valid)

proc call*(call_611718: Call_CreateCertificateFromCsr_611705; body: JsonNode;
          setAsActive: bool = false): Recallable =
  ## createCertificateFromCsr
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  ##   body: JObject (required)
  var query_611719 = newJObject()
  var body_611720 = newJObject()
  add(query_611719, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_611720 = body
  result = call_611718.call(nil, query_611719, nil, nil, body_611720)

var createCertificateFromCsr* = Call_CreateCertificateFromCsr_611705(
    name: "createCertificateFromCsr", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/certificates",
    validator: validate_CreateCertificateFromCsr_611706, base: "/",
    url: url_CreateCertificateFromCsr_611707, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCertificates_611689 = ref object of OpenApiRestCall_610658
proc url_ListCertificates_611691(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListCertificates_611690(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_611692 = query.getOrDefault("isAscendingOrder")
  valid_611692 = validateParameter(valid_611692, JBool, required = false, default = nil)
  if valid_611692 != nil:
    section.add "isAscendingOrder", valid_611692
  var valid_611693 = query.getOrDefault("pageSize")
  valid_611693 = validateParameter(valid_611693, JInt, required = false, default = nil)
  if valid_611693 != nil:
    section.add "pageSize", valid_611693
  var valid_611694 = query.getOrDefault("marker")
  valid_611694 = validateParameter(valid_611694, JString, required = false,
                                 default = nil)
  if valid_611694 != nil:
    section.add "marker", valid_611694
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611695 = header.getOrDefault("X-Amz-Signature")
  valid_611695 = validateParameter(valid_611695, JString, required = false,
                                 default = nil)
  if valid_611695 != nil:
    section.add "X-Amz-Signature", valid_611695
  var valid_611696 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611696 = validateParameter(valid_611696, JString, required = false,
                                 default = nil)
  if valid_611696 != nil:
    section.add "X-Amz-Content-Sha256", valid_611696
  var valid_611697 = header.getOrDefault("X-Amz-Date")
  valid_611697 = validateParameter(valid_611697, JString, required = false,
                                 default = nil)
  if valid_611697 != nil:
    section.add "X-Amz-Date", valid_611697
  var valid_611698 = header.getOrDefault("X-Amz-Credential")
  valid_611698 = validateParameter(valid_611698, JString, required = false,
                                 default = nil)
  if valid_611698 != nil:
    section.add "X-Amz-Credential", valid_611698
  var valid_611699 = header.getOrDefault("X-Amz-Security-Token")
  valid_611699 = validateParameter(valid_611699, JString, required = false,
                                 default = nil)
  if valid_611699 != nil:
    section.add "X-Amz-Security-Token", valid_611699
  var valid_611700 = header.getOrDefault("X-Amz-Algorithm")
  valid_611700 = validateParameter(valid_611700, JString, required = false,
                                 default = nil)
  if valid_611700 != nil:
    section.add "X-Amz-Algorithm", valid_611700
  var valid_611701 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611701 = validateParameter(valid_611701, JString, required = false,
                                 default = nil)
  if valid_611701 != nil:
    section.add "X-Amz-SignedHeaders", valid_611701
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611702: Call_ListCertificates_611689; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  let valid = call_611702.validator(path, query, header, formData, body)
  let scheme = call_611702.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611702.url(scheme.get, call_611702.host, call_611702.base,
                         call_611702.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611702, url, valid)

proc call*(call_611703: Call_ListCertificates_611689;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listCertificates
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_611704 = newJObject()
  add(query_611704, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_611704, "pageSize", newJInt(pageSize))
  add(query_611704, "marker", newJString(marker))
  result = call_611703.call(nil, query_611704, nil, nil, nil)

var listCertificates* = Call_ListCertificates_611689(name: "listCertificates",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/certificates",
    validator: validate_ListCertificates_611690, base: "/",
    url: url_ListCertificates_611691, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateDomainConfiguration_611735 = ref object of OpenApiRestCall_610658
proc url_UpdateDomainConfiguration_611737(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "domainConfigurationName" in path,
        "`domainConfigurationName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/domainConfigurations/"),
               (kind: VariableSegment, value: "domainConfigurationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateDomainConfiguration_611736(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Updates values stored in the domain configuration. Domain configurations for default endpoints can't be updated.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   domainConfigurationName: JString (required)
  ##                          : The name of the domain configuration to be updated.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `domainConfigurationName` field"
  var valid_611738 = path.getOrDefault("domainConfigurationName")
  valid_611738 = validateParameter(valid_611738, JString, required = true,
                                 default = nil)
  if valid_611738 != nil:
    section.add "domainConfigurationName", valid_611738
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611739 = header.getOrDefault("X-Amz-Signature")
  valid_611739 = validateParameter(valid_611739, JString, required = false,
                                 default = nil)
  if valid_611739 != nil:
    section.add "X-Amz-Signature", valid_611739
  var valid_611740 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611740 = validateParameter(valid_611740, JString, required = false,
                                 default = nil)
  if valid_611740 != nil:
    section.add "X-Amz-Content-Sha256", valid_611740
  var valid_611741 = header.getOrDefault("X-Amz-Date")
  valid_611741 = validateParameter(valid_611741, JString, required = false,
                                 default = nil)
  if valid_611741 != nil:
    section.add "X-Amz-Date", valid_611741
  var valid_611742 = header.getOrDefault("X-Amz-Credential")
  valid_611742 = validateParameter(valid_611742, JString, required = false,
                                 default = nil)
  if valid_611742 != nil:
    section.add "X-Amz-Credential", valid_611742
  var valid_611743 = header.getOrDefault("X-Amz-Security-Token")
  valid_611743 = validateParameter(valid_611743, JString, required = false,
                                 default = nil)
  if valid_611743 != nil:
    section.add "X-Amz-Security-Token", valid_611743
  var valid_611744 = header.getOrDefault("X-Amz-Algorithm")
  valid_611744 = validateParameter(valid_611744, JString, required = false,
                                 default = nil)
  if valid_611744 != nil:
    section.add "X-Amz-Algorithm", valid_611744
  var valid_611745 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611745 = validateParameter(valid_611745, JString, required = false,
                                 default = nil)
  if valid_611745 != nil:
    section.add "X-Amz-SignedHeaders", valid_611745
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611747: Call_UpdateDomainConfiguration_611735; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Updates values stored in the domain configuration. Domain configurations for default endpoints can't be updated.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_611747.validator(path, query, header, formData, body)
  let scheme = call_611747.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611747.url(scheme.get, call_611747.host, call_611747.base,
                         call_611747.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611747, url, valid)

proc call*(call_611748: Call_UpdateDomainConfiguration_611735; body: JsonNode;
          domainConfigurationName: string): Recallable =
  ## updateDomainConfiguration
  ## <p>Updates values stored in the domain configuration. Domain configurations for default endpoints can't be updated.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   body: JObject (required)
  ##   domainConfigurationName: string (required)
  ##                          : The name of the domain configuration to be updated.
  var path_611749 = newJObject()
  var body_611750 = newJObject()
  if body != nil:
    body_611750 = body
  add(path_611749, "domainConfigurationName", newJString(domainConfigurationName))
  result = call_611748.call(path_611749, nil, nil, nil, body_611750)

var updateDomainConfiguration* = Call_UpdateDomainConfiguration_611735(
    name: "updateDomainConfiguration", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/domainConfigurations/{domainConfigurationName}",
    validator: validate_UpdateDomainConfiguration_611736, base: "/",
    url: url_UpdateDomainConfiguration_611737,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateDomainConfiguration_611751 = ref object of OpenApiRestCall_610658
proc url_CreateDomainConfiguration_611753(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "domainConfigurationName" in path,
        "`domainConfigurationName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/domainConfigurations/"),
               (kind: VariableSegment, value: "domainConfigurationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateDomainConfiguration_611752(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   domainConfigurationName: JString (required)
  ##                          : The name of the domain configuration. This value must be unique to a region.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `domainConfigurationName` field"
  var valid_611754 = path.getOrDefault("domainConfigurationName")
  valid_611754 = validateParameter(valid_611754, JString, required = true,
                                 default = nil)
  if valid_611754 != nil:
    section.add "domainConfigurationName", valid_611754
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611755 = header.getOrDefault("X-Amz-Signature")
  valid_611755 = validateParameter(valid_611755, JString, required = false,
                                 default = nil)
  if valid_611755 != nil:
    section.add "X-Amz-Signature", valid_611755
  var valid_611756 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611756 = validateParameter(valid_611756, JString, required = false,
                                 default = nil)
  if valid_611756 != nil:
    section.add "X-Amz-Content-Sha256", valid_611756
  var valid_611757 = header.getOrDefault("X-Amz-Date")
  valid_611757 = validateParameter(valid_611757, JString, required = false,
                                 default = nil)
  if valid_611757 != nil:
    section.add "X-Amz-Date", valid_611757
  var valid_611758 = header.getOrDefault("X-Amz-Credential")
  valid_611758 = validateParameter(valid_611758, JString, required = false,
                                 default = nil)
  if valid_611758 != nil:
    section.add "X-Amz-Credential", valid_611758
  var valid_611759 = header.getOrDefault("X-Amz-Security-Token")
  valid_611759 = validateParameter(valid_611759, JString, required = false,
                                 default = nil)
  if valid_611759 != nil:
    section.add "X-Amz-Security-Token", valid_611759
  var valid_611760 = header.getOrDefault("X-Amz-Algorithm")
  valid_611760 = validateParameter(valid_611760, JString, required = false,
                                 default = nil)
  if valid_611760 != nil:
    section.add "X-Amz-Algorithm", valid_611760
  var valid_611761 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611761 = validateParameter(valid_611761, JString, required = false,
                                 default = nil)
  if valid_611761 != nil:
    section.add "X-Amz-SignedHeaders", valid_611761
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611763: Call_CreateDomainConfiguration_611751; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_611763.validator(path, query, header, formData, body)
  let scheme = call_611763.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611763.url(scheme.get, call_611763.host, call_611763.base,
                         call_611763.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611763, url, valid)

proc call*(call_611764: Call_CreateDomainConfiguration_611751; body: JsonNode;
          domainConfigurationName: string): Recallable =
  ## createDomainConfiguration
  ## <p>Creates a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   body: JObject (required)
  ##   domainConfigurationName: string (required)
  ##                          : The name of the domain configuration. This value must be unique to a region.
  var path_611765 = newJObject()
  var body_611766 = newJObject()
  if body != nil:
    body_611766 = body
  add(path_611765, "domainConfigurationName", newJString(domainConfigurationName))
  result = call_611764.call(path_611765, nil, nil, nil, body_611766)

var createDomainConfiguration* = Call_CreateDomainConfiguration_611751(
    name: "createDomainConfiguration", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/domainConfigurations/{domainConfigurationName}",
    validator: validate_CreateDomainConfiguration_611752, base: "/",
    url: url_CreateDomainConfiguration_611753,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeDomainConfiguration_611721 = ref object of OpenApiRestCall_610658
proc url_DescribeDomainConfiguration_611723(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "domainConfigurationName" in path,
        "`domainConfigurationName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/domainConfigurations/"),
               (kind: VariableSegment, value: "domainConfigurationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeDomainConfiguration_611722(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Gets summary information about a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   domainConfigurationName: JString (required)
  ##                          : The name of the domain configuration.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `domainConfigurationName` field"
  var valid_611724 = path.getOrDefault("domainConfigurationName")
  valid_611724 = validateParameter(valid_611724, JString, required = true,
                                 default = nil)
  if valid_611724 != nil:
    section.add "domainConfigurationName", valid_611724
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611725 = header.getOrDefault("X-Amz-Signature")
  valid_611725 = validateParameter(valid_611725, JString, required = false,
                                 default = nil)
  if valid_611725 != nil:
    section.add "X-Amz-Signature", valid_611725
  var valid_611726 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611726 = validateParameter(valid_611726, JString, required = false,
                                 default = nil)
  if valid_611726 != nil:
    section.add "X-Amz-Content-Sha256", valid_611726
  var valid_611727 = header.getOrDefault("X-Amz-Date")
  valid_611727 = validateParameter(valid_611727, JString, required = false,
                                 default = nil)
  if valid_611727 != nil:
    section.add "X-Amz-Date", valid_611727
  var valid_611728 = header.getOrDefault("X-Amz-Credential")
  valid_611728 = validateParameter(valid_611728, JString, required = false,
                                 default = nil)
  if valid_611728 != nil:
    section.add "X-Amz-Credential", valid_611728
  var valid_611729 = header.getOrDefault("X-Amz-Security-Token")
  valid_611729 = validateParameter(valid_611729, JString, required = false,
                                 default = nil)
  if valid_611729 != nil:
    section.add "X-Amz-Security-Token", valid_611729
  var valid_611730 = header.getOrDefault("X-Amz-Algorithm")
  valid_611730 = validateParameter(valid_611730, JString, required = false,
                                 default = nil)
  if valid_611730 != nil:
    section.add "X-Amz-Algorithm", valid_611730
  var valid_611731 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611731 = validateParameter(valid_611731, JString, required = false,
                                 default = nil)
  if valid_611731 != nil:
    section.add "X-Amz-SignedHeaders", valid_611731
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611732: Call_DescribeDomainConfiguration_611721; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Gets summary information about a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_611732.validator(path, query, header, formData, body)
  let scheme = call_611732.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611732.url(scheme.get, call_611732.host, call_611732.base,
                         call_611732.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611732, url, valid)

proc call*(call_611733: Call_DescribeDomainConfiguration_611721;
          domainConfigurationName: string): Recallable =
  ## describeDomainConfiguration
  ## <p>Gets summary information about a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   domainConfigurationName: string (required)
  ##                          : The name of the domain configuration.
  var path_611734 = newJObject()
  add(path_611734, "domainConfigurationName", newJString(domainConfigurationName))
  result = call_611733.call(path_611734, nil, nil, nil, nil)

var describeDomainConfiguration* = Call_DescribeDomainConfiguration_611721(
    name: "describeDomainConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/domainConfigurations/{domainConfigurationName}",
    validator: validate_DescribeDomainConfiguration_611722, base: "/",
    url: url_DescribeDomainConfiguration_611723,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteDomainConfiguration_611767 = ref object of OpenApiRestCall_610658
proc url_DeleteDomainConfiguration_611769(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "domainConfigurationName" in path,
        "`domainConfigurationName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/domainConfigurations/"),
               (kind: VariableSegment, value: "domainConfigurationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteDomainConfiguration_611768(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   domainConfigurationName: JString (required)
  ##                          : The name of the domain configuration to be deleted.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `domainConfigurationName` field"
  var valid_611770 = path.getOrDefault("domainConfigurationName")
  valid_611770 = validateParameter(valid_611770, JString, required = true,
                                 default = nil)
  if valid_611770 != nil:
    section.add "domainConfigurationName", valid_611770
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611771 = header.getOrDefault("X-Amz-Signature")
  valid_611771 = validateParameter(valid_611771, JString, required = false,
                                 default = nil)
  if valid_611771 != nil:
    section.add "X-Amz-Signature", valid_611771
  var valid_611772 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611772 = validateParameter(valid_611772, JString, required = false,
                                 default = nil)
  if valid_611772 != nil:
    section.add "X-Amz-Content-Sha256", valid_611772
  var valid_611773 = header.getOrDefault("X-Amz-Date")
  valid_611773 = validateParameter(valid_611773, JString, required = false,
                                 default = nil)
  if valid_611773 != nil:
    section.add "X-Amz-Date", valid_611773
  var valid_611774 = header.getOrDefault("X-Amz-Credential")
  valid_611774 = validateParameter(valid_611774, JString, required = false,
                                 default = nil)
  if valid_611774 != nil:
    section.add "X-Amz-Credential", valid_611774
  var valid_611775 = header.getOrDefault("X-Amz-Security-Token")
  valid_611775 = validateParameter(valid_611775, JString, required = false,
                                 default = nil)
  if valid_611775 != nil:
    section.add "X-Amz-Security-Token", valid_611775
  var valid_611776 = header.getOrDefault("X-Amz-Algorithm")
  valid_611776 = validateParameter(valid_611776, JString, required = false,
                                 default = nil)
  if valid_611776 != nil:
    section.add "X-Amz-Algorithm", valid_611776
  var valid_611777 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611777 = validateParameter(valid_611777, JString, required = false,
                                 default = nil)
  if valid_611777 != nil:
    section.add "X-Amz-SignedHeaders", valid_611777
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611778: Call_DeleteDomainConfiguration_611767; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_611778.validator(path, query, header, formData, body)
  let scheme = call_611778.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611778.url(scheme.get, call_611778.host, call_611778.base,
                         call_611778.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611778, url, valid)

proc call*(call_611779: Call_DeleteDomainConfiguration_611767;
          domainConfigurationName: string): Recallable =
  ## deleteDomainConfiguration
  ## <p>Deletes the specified domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   domainConfigurationName: string (required)
  ##                          : The name of the domain configuration to be deleted.
  var path_611780 = newJObject()
  add(path_611780, "domainConfigurationName", newJString(domainConfigurationName))
  result = call_611779.call(path_611780, nil, nil, nil, nil)

var deleteDomainConfiguration* = Call_DeleteDomainConfiguration_611767(
    name: "deleteDomainConfiguration", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/domainConfigurations/{domainConfigurationName}",
    validator: validate_DeleteDomainConfiguration_611768, base: "/",
    url: url_DeleteDomainConfiguration_611769,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateDynamicThingGroup_611781 = ref object of OpenApiRestCall_610658
proc url_CreateDynamicThingGroup_611783(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateDynamicThingGroup_611782(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The dynamic thing group name to create.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_611784 = path.getOrDefault("thingGroupName")
  valid_611784 = validateParameter(valid_611784, JString, required = true,
                                 default = nil)
  if valid_611784 != nil:
    section.add "thingGroupName", valid_611784
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611785 = header.getOrDefault("X-Amz-Signature")
  valid_611785 = validateParameter(valid_611785, JString, required = false,
                                 default = nil)
  if valid_611785 != nil:
    section.add "X-Amz-Signature", valid_611785
  var valid_611786 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611786 = validateParameter(valid_611786, JString, required = false,
                                 default = nil)
  if valid_611786 != nil:
    section.add "X-Amz-Content-Sha256", valid_611786
  var valid_611787 = header.getOrDefault("X-Amz-Date")
  valid_611787 = validateParameter(valid_611787, JString, required = false,
                                 default = nil)
  if valid_611787 != nil:
    section.add "X-Amz-Date", valid_611787
  var valid_611788 = header.getOrDefault("X-Amz-Credential")
  valid_611788 = validateParameter(valid_611788, JString, required = false,
                                 default = nil)
  if valid_611788 != nil:
    section.add "X-Amz-Credential", valid_611788
  var valid_611789 = header.getOrDefault("X-Amz-Security-Token")
  valid_611789 = validateParameter(valid_611789, JString, required = false,
                                 default = nil)
  if valid_611789 != nil:
    section.add "X-Amz-Security-Token", valid_611789
  var valid_611790 = header.getOrDefault("X-Amz-Algorithm")
  valid_611790 = validateParameter(valid_611790, JString, required = false,
                                 default = nil)
  if valid_611790 != nil:
    section.add "X-Amz-Algorithm", valid_611790
  var valid_611791 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611791 = validateParameter(valid_611791, JString, required = false,
                                 default = nil)
  if valid_611791 != nil:
    section.add "X-Amz-SignedHeaders", valid_611791
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611793: Call_CreateDynamicThingGroup_611781; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a dynamic thing group.
  ## 
  let valid = call_611793.validator(path, query, header, formData, body)
  let scheme = call_611793.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611793.url(scheme.get, call_611793.host, call_611793.base,
                         call_611793.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611793, url, valid)

proc call*(call_611794: Call_CreateDynamicThingGroup_611781;
          thingGroupName: string; body: JsonNode): Recallable =
  ## createDynamicThingGroup
  ## Creates a dynamic thing group.
  ##   thingGroupName: string (required)
  ##                 : The dynamic thing group name to create.
  ##   body: JObject (required)
  var path_611795 = newJObject()
  var body_611796 = newJObject()
  add(path_611795, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_611796 = body
  result = call_611794.call(path_611795, nil, nil, nil, body_611796)

var createDynamicThingGroup* = Call_CreateDynamicThingGroup_611781(
    name: "createDynamicThingGroup", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_CreateDynamicThingGroup_611782, base: "/",
    url: url_CreateDynamicThingGroup_611783, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateDynamicThingGroup_611813 = ref object of OpenApiRestCall_610658
proc url_UpdateDynamicThingGroup_611815(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateDynamicThingGroup_611814(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the dynamic thing group to update.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_611816 = path.getOrDefault("thingGroupName")
  valid_611816 = validateParameter(valid_611816, JString, required = true,
                                 default = nil)
  if valid_611816 != nil:
    section.add "thingGroupName", valid_611816
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611817 = header.getOrDefault("X-Amz-Signature")
  valid_611817 = validateParameter(valid_611817, JString, required = false,
                                 default = nil)
  if valid_611817 != nil:
    section.add "X-Amz-Signature", valid_611817
  var valid_611818 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611818 = validateParameter(valid_611818, JString, required = false,
                                 default = nil)
  if valid_611818 != nil:
    section.add "X-Amz-Content-Sha256", valid_611818
  var valid_611819 = header.getOrDefault("X-Amz-Date")
  valid_611819 = validateParameter(valid_611819, JString, required = false,
                                 default = nil)
  if valid_611819 != nil:
    section.add "X-Amz-Date", valid_611819
  var valid_611820 = header.getOrDefault("X-Amz-Credential")
  valid_611820 = validateParameter(valid_611820, JString, required = false,
                                 default = nil)
  if valid_611820 != nil:
    section.add "X-Amz-Credential", valid_611820
  var valid_611821 = header.getOrDefault("X-Amz-Security-Token")
  valid_611821 = validateParameter(valid_611821, JString, required = false,
                                 default = nil)
  if valid_611821 != nil:
    section.add "X-Amz-Security-Token", valid_611821
  var valid_611822 = header.getOrDefault("X-Amz-Algorithm")
  valid_611822 = validateParameter(valid_611822, JString, required = false,
                                 default = nil)
  if valid_611822 != nil:
    section.add "X-Amz-Algorithm", valid_611822
  var valid_611823 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611823 = validateParameter(valid_611823, JString, required = false,
                                 default = nil)
  if valid_611823 != nil:
    section.add "X-Amz-SignedHeaders", valid_611823
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611825: Call_UpdateDynamicThingGroup_611813; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a dynamic thing group.
  ## 
  let valid = call_611825.validator(path, query, header, formData, body)
  let scheme = call_611825.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611825.url(scheme.get, call_611825.host, call_611825.base,
                         call_611825.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611825, url, valid)

proc call*(call_611826: Call_UpdateDynamicThingGroup_611813;
          thingGroupName: string; body: JsonNode): Recallable =
  ## updateDynamicThingGroup
  ## Updates a dynamic thing group.
  ##   thingGroupName: string (required)
  ##                 : The name of the dynamic thing group to update.
  ##   body: JObject (required)
  var path_611827 = newJObject()
  var body_611828 = newJObject()
  add(path_611827, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_611828 = body
  result = call_611826.call(path_611827, nil, nil, nil, body_611828)

var updateDynamicThingGroup* = Call_UpdateDynamicThingGroup_611813(
    name: "updateDynamicThingGroup", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_UpdateDynamicThingGroup_611814, base: "/",
    url: url_UpdateDynamicThingGroup_611815, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteDynamicThingGroup_611797 = ref object of OpenApiRestCall_610658
proc url_DeleteDynamicThingGroup_611799(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteDynamicThingGroup_611798(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the dynamic thing group to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_611800 = path.getOrDefault("thingGroupName")
  valid_611800 = validateParameter(valid_611800, JString, required = true,
                                 default = nil)
  if valid_611800 != nil:
    section.add "thingGroupName", valid_611800
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the dynamic thing group to delete.
  section = newJObject()
  var valid_611801 = query.getOrDefault("expectedVersion")
  valid_611801 = validateParameter(valid_611801, JInt, required = false, default = nil)
  if valid_611801 != nil:
    section.add "expectedVersion", valid_611801
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611802 = header.getOrDefault("X-Amz-Signature")
  valid_611802 = validateParameter(valid_611802, JString, required = false,
                                 default = nil)
  if valid_611802 != nil:
    section.add "X-Amz-Signature", valid_611802
  var valid_611803 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611803 = validateParameter(valid_611803, JString, required = false,
                                 default = nil)
  if valid_611803 != nil:
    section.add "X-Amz-Content-Sha256", valid_611803
  var valid_611804 = header.getOrDefault("X-Amz-Date")
  valid_611804 = validateParameter(valid_611804, JString, required = false,
                                 default = nil)
  if valid_611804 != nil:
    section.add "X-Amz-Date", valid_611804
  var valid_611805 = header.getOrDefault("X-Amz-Credential")
  valid_611805 = validateParameter(valid_611805, JString, required = false,
                                 default = nil)
  if valid_611805 != nil:
    section.add "X-Amz-Credential", valid_611805
  var valid_611806 = header.getOrDefault("X-Amz-Security-Token")
  valid_611806 = validateParameter(valid_611806, JString, required = false,
                                 default = nil)
  if valid_611806 != nil:
    section.add "X-Amz-Security-Token", valid_611806
  var valid_611807 = header.getOrDefault("X-Amz-Algorithm")
  valid_611807 = validateParameter(valid_611807, JString, required = false,
                                 default = nil)
  if valid_611807 != nil:
    section.add "X-Amz-Algorithm", valid_611807
  var valid_611808 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611808 = validateParameter(valid_611808, JString, required = false,
                                 default = nil)
  if valid_611808 != nil:
    section.add "X-Amz-SignedHeaders", valid_611808
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611809: Call_DeleteDynamicThingGroup_611797; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a dynamic thing group.
  ## 
  let valid = call_611809.validator(path, query, header, formData, body)
  let scheme = call_611809.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611809.url(scheme.get, call_611809.host, call_611809.base,
                         call_611809.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611809, url, valid)

proc call*(call_611810: Call_DeleteDynamicThingGroup_611797;
          thingGroupName: string; expectedVersion: int = 0): Recallable =
  ## deleteDynamicThingGroup
  ## Deletes a dynamic thing group.
  ##   expectedVersion: int
  ##                  : The expected version of the dynamic thing group to delete.
  ##   thingGroupName: string (required)
  ##                 : The name of the dynamic thing group to delete.
  var path_611811 = newJObject()
  var query_611812 = newJObject()
  add(query_611812, "expectedVersion", newJInt(expectedVersion))
  add(path_611811, "thingGroupName", newJString(thingGroupName))
  result = call_611810.call(path_611811, query_611812, nil, nil, nil)

var deleteDynamicThingGroup* = Call_DeleteDynamicThingGroup_611797(
    name: "deleteDynamicThingGroup", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_DeleteDynamicThingGroup_611798, base: "/",
    url: url_DeleteDynamicThingGroup_611799, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateJob_611843 = ref object of OpenApiRestCall_610658
proc url_CreateJob_611845(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateJob_611844(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_611846 = path.getOrDefault("jobId")
  valid_611846 = validateParameter(valid_611846, JString, required = true,
                                 default = nil)
  if valid_611846 != nil:
    section.add "jobId", valid_611846
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611847 = header.getOrDefault("X-Amz-Signature")
  valid_611847 = validateParameter(valid_611847, JString, required = false,
                                 default = nil)
  if valid_611847 != nil:
    section.add "X-Amz-Signature", valid_611847
  var valid_611848 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611848 = validateParameter(valid_611848, JString, required = false,
                                 default = nil)
  if valid_611848 != nil:
    section.add "X-Amz-Content-Sha256", valid_611848
  var valid_611849 = header.getOrDefault("X-Amz-Date")
  valid_611849 = validateParameter(valid_611849, JString, required = false,
                                 default = nil)
  if valid_611849 != nil:
    section.add "X-Amz-Date", valid_611849
  var valid_611850 = header.getOrDefault("X-Amz-Credential")
  valid_611850 = validateParameter(valid_611850, JString, required = false,
                                 default = nil)
  if valid_611850 != nil:
    section.add "X-Amz-Credential", valid_611850
  var valid_611851 = header.getOrDefault("X-Amz-Security-Token")
  valid_611851 = validateParameter(valid_611851, JString, required = false,
                                 default = nil)
  if valid_611851 != nil:
    section.add "X-Amz-Security-Token", valid_611851
  var valid_611852 = header.getOrDefault("X-Amz-Algorithm")
  valid_611852 = validateParameter(valid_611852, JString, required = false,
                                 default = nil)
  if valid_611852 != nil:
    section.add "X-Amz-Algorithm", valid_611852
  var valid_611853 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611853 = validateParameter(valid_611853, JString, required = false,
                                 default = nil)
  if valid_611853 != nil:
    section.add "X-Amz-SignedHeaders", valid_611853
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611855: Call_CreateJob_611843; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a job.
  ## 
  let valid = call_611855.validator(path, query, header, formData, body)
  let scheme = call_611855.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611855.url(scheme.get, call_611855.host, call_611855.base,
                         call_611855.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611855, url, valid)

proc call*(call_611856: Call_CreateJob_611843; jobId: string; body: JsonNode): Recallable =
  ## createJob
  ## Creates a job.
  ##   jobId: string (required)
  ##        : A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
  ##   body: JObject (required)
  var path_611857 = newJObject()
  var body_611858 = newJObject()
  add(path_611857, "jobId", newJString(jobId))
  if body != nil:
    body_611858 = body
  result = call_611856.call(path_611857, nil, nil, nil, body_611858)

var createJob* = Call_CreateJob_611843(name: "createJob", meth: HttpMethod.HttpPut,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_CreateJob_611844,
                                    base: "/", url: url_CreateJob_611845,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeJob_611829 = ref object of OpenApiRestCall_610658
proc url_DescribeJob_611831(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeJob_611830(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_611832 = path.getOrDefault("jobId")
  valid_611832 = validateParameter(valid_611832, JString, required = true,
                                 default = nil)
  if valid_611832 != nil:
    section.add "jobId", valid_611832
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611833 = header.getOrDefault("X-Amz-Signature")
  valid_611833 = validateParameter(valid_611833, JString, required = false,
                                 default = nil)
  if valid_611833 != nil:
    section.add "X-Amz-Signature", valid_611833
  var valid_611834 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611834 = validateParameter(valid_611834, JString, required = false,
                                 default = nil)
  if valid_611834 != nil:
    section.add "X-Amz-Content-Sha256", valid_611834
  var valid_611835 = header.getOrDefault("X-Amz-Date")
  valid_611835 = validateParameter(valid_611835, JString, required = false,
                                 default = nil)
  if valid_611835 != nil:
    section.add "X-Amz-Date", valid_611835
  var valid_611836 = header.getOrDefault("X-Amz-Credential")
  valid_611836 = validateParameter(valid_611836, JString, required = false,
                                 default = nil)
  if valid_611836 != nil:
    section.add "X-Amz-Credential", valid_611836
  var valid_611837 = header.getOrDefault("X-Amz-Security-Token")
  valid_611837 = validateParameter(valid_611837, JString, required = false,
                                 default = nil)
  if valid_611837 != nil:
    section.add "X-Amz-Security-Token", valid_611837
  var valid_611838 = header.getOrDefault("X-Amz-Algorithm")
  valid_611838 = validateParameter(valid_611838, JString, required = false,
                                 default = nil)
  if valid_611838 != nil:
    section.add "X-Amz-Algorithm", valid_611838
  var valid_611839 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611839 = validateParameter(valid_611839, JString, required = false,
                                 default = nil)
  if valid_611839 != nil:
    section.add "X-Amz-SignedHeaders", valid_611839
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611840: Call_DescribeJob_611829; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a job.
  ## 
  let valid = call_611840.validator(path, query, header, formData, body)
  let scheme = call_611840.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611840.url(scheme.get, call_611840.host, call_611840.base,
                         call_611840.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611840, url, valid)

proc call*(call_611841: Call_DescribeJob_611829; jobId: string): Recallable =
  ## describeJob
  ## Describes a job.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  var path_611842 = newJObject()
  add(path_611842, "jobId", newJString(jobId))
  result = call_611841.call(path_611842, nil, nil, nil, nil)

var describeJob* = Call_DescribeJob_611829(name: "describeJob",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/jobs/{jobId}",
                                        validator: validate_DescribeJob_611830,
                                        base: "/", url: url_DescribeJob_611831,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateJob_611875 = ref object of OpenApiRestCall_610658
proc url_UpdateJob_611877(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateJob_611876(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates supported fields of the specified job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The ID of the job to be updated.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_611878 = path.getOrDefault("jobId")
  valid_611878 = validateParameter(valid_611878, JString, required = true,
                                 default = nil)
  if valid_611878 != nil:
    section.add "jobId", valid_611878
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611879 = header.getOrDefault("X-Amz-Signature")
  valid_611879 = validateParameter(valid_611879, JString, required = false,
                                 default = nil)
  if valid_611879 != nil:
    section.add "X-Amz-Signature", valid_611879
  var valid_611880 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611880 = validateParameter(valid_611880, JString, required = false,
                                 default = nil)
  if valid_611880 != nil:
    section.add "X-Amz-Content-Sha256", valid_611880
  var valid_611881 = header.getOrDefault("X-Amz-Date")
  valid_611881 = validateParameter(valid_611881, JString, required = false,
                                 default = nil)
  if valid_611881 != nil:
    section.add "X-Amz-Date", valid_611881
  var valid_611882 = header.getOrDefault("X-Amz-Credential")
  valid_611882 = validateParameter(valid_611882, JString, required = false,
                                 default = nil)
  if valid_611882 != nil:
    section.add "X-Amz-Credential", valid_611882
  var valid_611883 = header.getOrDefault("X-Amz-Security-Token")
  valid_611883 = validateParameter(valid_611883, JString, required = false,
                                 default = nil)
  if valid_611883 != nil:
    section.add "X-Amz-Security-Token", valid_611883
  var valid_611884 = header.getOrDefault("X-Amz-Algorithm")
  valid_611884 = validateParameter(valid_611884, JString, required = false,
                                 default = nil)
  if valid_611884 != nil:
    section.add "X-Amz-Algorithm", valid_611884
  var valid_611885 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611885 = validateParameter(valid_611885, JString, required = false,
                                 default = nil)
  if valid_611885 != nil:
    section.add "X-Amz-SignedHeaders", valid_611885
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611887: Call_UpdateJob_611875; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates supported fields of the specified job.
  ## 
  let valid = call_611887.validator(path, query, header, formData, body)
  let scheme = call_611887.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611887.url(scheme.get, call_611887.host, call_611887.base,
                         call_611887.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611887, url, valid)

proc call*(call_611888: Call_UpdateJob_611875; jobId: string; body: JsonNode): Recallable =
  ## updateJob
  ## Updates supported fields of the specified job.
  ##   jobId: string (required)
  ##        : The ID of the job to be updated.
  ##   body: JObject (required)
  var path_611889 = newJObject()
  var body_611890 = newJObject()
  add(path_611889, "jobId", newJString(jobId))
  if body != nil:
    body_611890 = body
  result = call_611888.call(path_611889, nil, nil, nil, body_611890)

var updateJob* = Call_UpdateJob_611875(name: "updateJob", meth: HttpMethod.HttpPatch,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_UpdateJob_611876,
                                    base: "/", url: url_UpdateJob_611877,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteJob_611859 = ref object of OpenApiRestCall_610658
proc url_DeleteJob_611861(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteJob_611860(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_611862 = path.getOrDefault("jobId")
  valid_611862 = validateParameter(valid_611862, JString, required = true,
                                 default = nil)
  if valid_611862 != nil:
    section.add "jobId", valid_611862
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
  section = newJObject()
  var valid_611863 = query.getOrDefault("force")
  valid_611863 = validateParameter(valid_611863, JBool, required = false, default = nil)
  if valid_611863 != nil:
    section.add "force", valid_611863
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611864 = header.getOrDefault("X-Amz-Signature")
  valid_611864 = validateParameter(valid_611864, JString, required = false,
                                 default = nil)
  if valid_611864 != nil:
    section.add "X-Amz-Signature", valid_611864
  var valid_611865 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611865 = validateParameter(valid_611865, JString, required = false,
                                 default = nil)
  if valid_611865 != nil:
    section.add "X-Amz-Content-Sha256", valid_611865
  var valid_611866 = header.getOrDefault("X-Amz-Date")
  valid_611866 = validateParameter(valid_611866, JString, required = false,
                                 default = nil)
  if valid_611866 != nil:
    section.add "X-Amz-Date", valid_611866
  var valid_611867 = header.getOrDefault("X-Amz-Credential")
  valid_611867 = validateParameter(valid_611867, JString, required = false,
                                 default = nil)
  if valid_611867 != nil:
    section.add "X-Amz-Credential", valid_611867
  var valid_611868 = header.getOrDefault("X-Amz-Security-Token")
  valid_611868 = validateParameter(valid_611868, JString, required = false,
                                 default = nil)
  if valid_611868 != nil:
    section.add "X-Amz-Security-Token", valid_611868
  var valid_611869 = header.getOrDefault("X-Amz-Algorithm")
  valid_611869 = validateParameter(valid_611869, JString, required = false,
                                 default = nil)
  if valid_611869 != nil:
    section.add "X-Amz-Algorithm", valid_611869
  var valid_611870 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611870 = validateParameter(valid_611870, JString, required = false,
                                 default = nil)
  if valid_611870 != nil:
    section.add "X-Amz-SignedHeaders", valid_611870
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611871: Call_DeleteJob_611859; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ## 
  let valid = call_611871.validator(path, query, header, formData, body)
  let scheme = call_611871.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611871.url(scheme.get, call_611871.host, call_611871.base,
                         call_611871.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611871, url, valid)

proc call*(call_611872: Call_DeleteJob_611859; jobId: string; force: bool = false): Recallable =
  ## deleteJob
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ##   jobId: string (required)
  ##        : <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
  ##   force: bool
  ##        : <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
  var path_611873 = newJObject()
  var query_611874 = newJObject()
  add(path_611873, "jobId", newJString(jobId))
  add(query_611874, "force", newJBool(force))
  result = call_611872.call(path_611873, query_611874, nil, nil, nil)

var deleteJob* = Call_DeleteJob_611859(name: "deleteJob",
                                    meth: HttpMethod.HttpDelete,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_DeleteJob_611860,
                                    base: "/", url: url_DeleteJob_611861,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateKeysAndCertificate_611891 = ref object of OpenApiRestCall_610658
proc url_CreateKeysAndCertificate_611893(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateKeysAndCertificate_611892(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key. You can also call <code>CreateKeysAndCertificate</code> over MQTT from a device, for more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-wo-cert.html#provision-mqtt-api">Provisioning MQTT API</a>.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_611894 = query.getOrDefault("setAsActive")
  valid_611894 = validateParameter(valid_611894, JBool, required = false, default = nil)
  if valid_611894 != nil:
    section.add "setAsActive", valid_611894
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611895 = header.getOrDefault("X-Amz-Signature")
  valid_611895 = validateParameter(valid_611895, JString, required = false,
                                 default = nil)
  if valid_611895 != nil:
    section.add "X-Amz-Signature", valid_611895
  var valid_611896 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611896 = validateParameter(valid_611896, JString, required = false,
                                 default = nil)
  if valid_611896 != nil:
    section.add "X-Amz-Content-Sha256", valid_611896
  var valid_611897 = header.getOrDefault("X-Amz-Date")
  valid_611897 = validateParameter(valid_611897, JString, required = false,
                                 default = nil)
  if valid_611897 != nil:
    section.add "X-Amz-Date", valid_611897
  var valid_611898 = header.getOrDefault("X-Amz-Credential")
  valid_611898 = validateParameter(valid_611898, JString, required = false,
                                 default = nil)
  if valid_611898 != nil:
    section.add "X-Amz-Credential", valid_611898
  var valid_611899 = header.getOrDefault("X-Amz-Security-Token")
  valid_611899 = validateParameter(valid_611899, JString, required = false,
                                 default = nil)
  if valid_611899 != nil:
    section.add "X-Amz-Security-Token", valid_611899
  var valid_611900 = header.getOrDefault("X-Amz-Algorithm")
  valid_611900 = validateParameter(valid_611900, JString, required = false,
                                 default = nil)
  if valid_611900 != nil:
    section.add "X-Amz-Algorithm", valid_611900
  var valid_611901 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611901 = validateParameter(valid_611901, JString, required = false,
                                 default = nil)
  if valid_611901 != nil:
    section.add "X-Amz-SignedHeaders", valid_611901
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611902: Call_CreateKeysAndCertificate_611891; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key. You can also call <code>CreateKeysAndCertificate</code> over MQTT from a device, for more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-wo-cert.html#provision-mqtt-api">Provisioning MQTT API</a>.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ## 
  let valid = call_611902.validator(path, query, header, formData, body)
  let scheme = call_611902.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611902.url(scheme.get, call_611902.host, call_611902.base,
                         call_611902.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611902, url, valid)

proc call*(call_611903: Call_CreateKeysAndCertificate_611891;
          setAsActive: bool = false): Recallable =
  ## createKeysAndCertificate
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key. You can also call <code>CreateKeysAndCertificate</code> over MQTT from a device, for more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-wo-cert.html#provision-mqtt-api">Provisioning MQTT API</a>.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  var query_611904 = newJObject()
  add(query_611904, "setAsActive", newJBool(setAsActive))
  result = call_611903.call(nil, query_611904, nil, nil, nil)

var createKeysAndCertificate* = Call_CreateKeysAndCertificate_611891(
    name: "createKeysAndCertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/keys-and-certificate",
    validator: validate_CreateKeysAndCertificate_611892, base: "/",
    url: url_CreateKeysAndCertificate_611893, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateMitigationAction_611919 = ref object of OpenApiRestCall_610658
proc url_CreateMitigationAction_611921(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateMitigationAction_611920(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_611922 = path.getOrDefault("actionName")
  valid_611922 = validateParameter(valid_611922, JString, required = true,
                                 default = nil)
  if valid_611922 != nil:
    section.add "actionName", valid_611922
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611923 = header.getOrDefault("X-Amz-Signature")
  valid_611923 = validateParameter(valid_611923, JString, required = false,
                                 default = nil)
  if valid_611923 != nil:
    section.add "X-Amz-Signature", valid_611923
  var valid_611924 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611924 = validateParameter(valid_611924, JString, required = false,
                                 default = nil)
  if valid_611924 != nil:
    section.add "X-Amz-Content-Sha256", valid_611924
  var valid_611925 = header.getOrDefault("X-Amz-Date")
  valid_611925 = validateParameter(valid_611925, JString, required = false,
                                 default = nil)
  if valid_611925 != nil:
    section.add "X-Amz-Date", valid_611925
  var valid_611926 = header.getOrDefault("X-Amz-Credential")
  valid_611926 = validateParameter(valid_611926, JString, required = false,
                                 default = nil)
  if valid_611926 != nil:
    section.add "X-Amz-Credential", valid_611926
  var valid_611927 = header.getOrDefault("X-Amz-Security-Token")
  valid_611927 = validateParameter(valid_611927, JString, required = false,
                                 default = nil)
  if valid_611927 != nil:
    section.add "X-Amz-Security-Token", valid_611927
  var valid_611928 = header.getOrDefault("X-Amz-Algorithm")
  valid_611928 = validateParameter(valid_611928, JString, required = false,
                                 default = nil)
  if valid_611928 != nil:
    section.add "X-Amz-Algorithm", valid_611928
  var valid_611929 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611929 = validateParameter(valid_611929, JString, required = false,
                                 default = nil)
  if valid_611929 != nil:
    section.add "X-Amz-SignedHeaders", valid_611929
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611931: Call_CreateMitigationAction_611919; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ## 
  let valid = call_611931.validator(path, query, header, formData, body)
  let scheme = call_611931.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611931.url(scheme.get, call_611931.host, call_611931.base,
                         call_611931.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611931, url, valid)

proc call*(call_611932: Call_CreateMitigationAction_611919; actionName: string;
          body: JsonNode): Recallable =
  ## createMitigationAction
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ##   actionName: string (required)
  ##             : A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).
  ##   body: JObject (required)
  var path_611933 = newJObject()
  var body_611934 = newJObject()
  add(path_611933, "actionName", newJString(actionName))
  if body != nil:
    body_611934 = body
  result = call_611932.call(path_611933, nil, nil, nil, body_611934)

var createMitigationAction* = Call_CreateMitigationAction_611919(
    name: "createMitigationAction", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_CreateMitigationAction_611920, base: "/",
    url: url_CreateMitigationAction_611921, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeMitigationAction_611905 = ref object of OpenApiRestCall_610658
proc url_DescribeMitigationAction_611907(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeMitigationAction_611906(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a mitigation action.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The friendly name that uniquely identifies the mitigation action.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_611908 = path.getOrDefault("actionName")
  valid_611908 = validateParameter(valid_611908, JString, required = true,
                                 default = nil)
  if valid_611908 != nil:
    section.add "actionName", valid_611908
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611909 = header.getOrDefault("X-Amz-Signature")
  valid_611909 = validateParameter(valid_611909, JString, required = false,
                                 default = nil)
  if valid_611909 != nil:
    section.add "X-Amz-Signature", valid_611909
  var valid_611910 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611910 = validateParameter(valid_611910, JString, required = false,
                                 default = nil)
  if valid_611910 != nil:
    section.add "X-Amz-Content-Sha256", valid_611910
  var valid_611911 = header.getOrDefault("X-Amz-Date")
  valid_611911 = validateParameter(valid_611911, JString, required = false,
                                 default = nil)
  if valid_611911 != nil:
    section.add "X-Amz-Date", valid_611911
  var valid_611912 = header.getOrDefault("X-Amz-Credential")
  valid_611912 = validateParameter(valid_611912, JString, required = false,
                                 default = nil)
  if valid_611912 != nil:
    section.add "X-Amz-Credential", valid_611912
  var valid_611913 = header.getOrDefault("X-Amz-Security-Token")
  valid_611913 = validateParameter(valid_611913, JString, required = false,
                                 default = nil)
  if valid_611913 != nil:
    section.add "X-Amz-Security-Token", valid_611913
  var valid_611914 = header.getOrDefault("X-Amz-Algorithm")
  valid_611914 = validateParameter(valid_611914, JString, required = false,
                                 default = nil)
  if valid_611914 != nil:
    section.add "X-Amz-Algorithm", valid_611914
  var valid_611915 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611915 = validateParameter(valid_611915, JString, required = false,
                                 default = nil)
  if valid_611915 != nil:
    section.add "X-Amz-SignedHeaders", valid_611915
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611916: Call_DescribeMitigationAction_611905; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a mitigation action.
  ## 
  let valid = call_611916.validator(path, query, header, formData, body)
  let scheme = call_611916.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611916.url(scheme.get, call_611916.host, call_611916.base,
                         call_611916.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611916, url, valid)

proc call*(call_611917: Call_DescribeMitigationAction_611905; actionName: string): Recallable =
  ## describeMitigationAction
  ## Gets information about a mitigation action.
  ##   actionName: string (required)
  ##             : The friendly name that uniquely identifies the mitigation action.
  var path_611918 = newJObject()
  add(path_611918, "actionName", newJString(actionName))
  result = call_611917.call(path_611918, nil, nil, nil, nil)

var describeMitigationAction* = Call_DescribeMitigationAction_611905(
    name: "describeMitigationAction", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_DescribeMitigationAction_611906, base: "/",
    url: url_DescribeMitigationAction_611907, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateMitigationAction_611949 = ref object of OpenApiRestCall_610658
proc url_UpdateMitigationAction_611951(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateMitigationAction_611950(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the definition for the specified mitigation action.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_611952 = path.getOrDefault("actionName")
  valid_611952 = validateParameter(valid_611952, JString, required = true,
                                 default = nil)
  if valid_611952 != nil:
    section.add "actionName", valid_611952
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611953 = header.getOrDefault("X-Amz-Signature")
  valid_611953 = validateParameter(valid_611953, JString, required = false,
                                 default = nil)
  if valid_611953 != nil:
    section.add "X-Amz-Signature", valid_611953
  var valid_611954 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611954 = validateParameter(valid_611954, JString, required = false,
                                 default = nil)
  if valid_611954 != nil:
    section.add "X-Amz-Content-Sha256", valid_611954
  var valid_611955 = header.getOrDefault("X-Amz-Date")
  valid_611955 = validateParameter(valid_611955, JString, required = false,
                                 default = nil)
  if valid_611955 != nil:
    section.add "X-Amz-Date", valid_611955
  var valid_611956 = header.getOrDefault("X-Amz-Credential")
  valid_611956 = validateParameter(valid_611956, JString, required = false,
                                 default = nil)
  if valid_611956 != nil:
    section.add "X-Amz-Credential", valid_611956
  var valid_611957 = header.getOrDefault("X-Amz-Security-Token")
  valid_611957 = validateParameter(valid_611957, JString, required = false,
                                 default = nil)
  if valid_611957 != nil:
    section.add "X-Amz-Security-Token", valid_611957
  var valid_611958 = header.getOrDefault("X-Amz-Algorithm")
  valid_611958 = validateParameter(valid_611958, JString, required = false,
                                 default = nil)
  if valid_611958 != nil:
    section.add "X-Amz-Algorithm", valid_611958
  var valid_611959 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611959 = validateParameter(valid_611959, JString, required = false,
                                 default = nil)
  if valid_611959 != nil:
    section.add "X-Amz-SignedHeaders", valid_611959
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611961: Call_UpdateMitigationAction_611949; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the definition for the specified mitigation action.
  ## 
  let valid = call_611961.validator(path, query, header, formData, body)
  let scheme = call_611961.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611961.url(scheme.get, call_611961.host, call_611961.base,
                         call_611961.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611961, url, valid)

proc call*(call_611962: Call_UpdateMitigationAction_611949; actionName: string;
          body: JsonNode): Recallable =
  ## updateMitigationAction
  ## Updates the definition for the specified mitigation action.
  ##   actionName: string (required)
  ##             : The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.
  ##   body: JObject (required)
  var path_611963 = newJObject()
  var body_611964 = newJObject()
  add(path_611963, "actionName", newJString(actionName))
  if body != nil:
    body_611964 = body
  result = call_611962.call(path_611963, nil, nil, nil, body_611964)

var updateMitigationAction* = Call_UpdateMitigationAction_611949(
    name: "updateMitigationAction", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_UpdateMitigationAction_611950, base: "/",
    url: url_UpdateMitigationAction_611951, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteMitigationAction_611935 = ref object of OpenApiRestCall_610658
proc url_DeleteMitigationAction_611937(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteMitigationAction_611936(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a defined mitigation action from your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The name of the mitigation action that you want to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_611938 = path.getOrDefault("actionName")
  valid_611938 = validateParameter(valid_611938, JString, required = true,
                                 default = nil)
  if valid_611938 != nil:
    section.add "actionName", valid_611938
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611939 = header.getOrDefault("X-Amz-Signature")
  valid_611939 = validateParameter(valid_611939, JString, required = false,
                                 default = nil)
  if valid_611939 != nil:
    section.add "X-Amz-Signature", valid_611939
  var valid_611940 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611940 = validateParameter(valid_611940, JString, required = false,
                                 default = nil)
  if valid_611940 != nil:
    section.add "X-Amz-Content-Sha256", valid_611940
  var valid_611941 = header.getOrDefault("X-Amz-Date")
  valid_611941 = validateParameter(valid_611941, JString, required = false,
                                 default = nil)
  if valid_611941 != nil:
    section.add "X-Amz-Date", valid_611941
  var valid_611942 = header.getOrDefault("X-Amz-Credential")
  valid_611942 = validateParameter(valid_611942, JString, required = false,
                                 default = nil)
  if valid_611942 != nil:
    section.add "X-Amz-Credential", valid_611942
  var valid_611943 = header.getOrDefault("X-Amz-Security-Token")
  valid_611943 = validateParameter(valid_611943, JString, required = false,
                                 default = nil)
  if valid_611943 != nil:
    section.add "X-Amz-Security-Token", valid_611943
  var valid_611944 = header.getOrDefault("X-Amz-Algorithm")
  valid_611944 = validateParameter(valid_611944, JString, required = false,
                                 default = nil)
  if valid_611944 != nil:
    section.add "X-Amz-Algorithm", valid_611944
  var valid_611945 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611945 = validateParameter(valid_611945, JString, required = false,
                                 default = nil)
  if valid_611945 != nil:
    section.add "X-Amz-SignedHeaders", valid_611945
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611946: Call_DeleteMitigationAction_611935; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a defined mitigation action from your AWS account.
  ## 
  let valid = call_611946.validator(path, query, header, formData, body)
  let scheme = call_611946.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611946.url(scheme.get, call_611946.host, call_611946.base,
                         call_611946.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611946, url, valid)

proc call*(call_611947: Call_DeleteMitigationAction_611935; actionName: string): Recallable =
  ## deleteMitigationAction
  ## Deletes a defined mitigation action from your AWS account.
  ##   actionName: string (required)
  ##             : The name of the mitigation action that you want to delete.
  var path_611948 = newJObject()
  add(path_611948, "actionName", newJString(actionName))
  result = call_611947.call(path_611948, nil, nil, nil, nil)

var deleteMitigationAction* = Call_DeleteMitigationAction_611935(
    name: "deleteMitigationAction", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_DeleteMitigationAction_611936, base: "/",
    url: url_DeleteMitigationAction_611937, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateOTAUpdate_611979 = ref object of OpenApiRestCall_610658
proc url_CreateOTAUpdate_611981(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateOTAUpdate_611980(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The ID of the OTA update to be created.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_611982 = path.getOrDefault("otaUpdateId")
  valid_611982 = validateParameter(valid_611982, JString, required = true,
                                 default = nil)
  if valid_611982 != nil:
    section.add "otaUpdateId", valid_611982
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611983 = header.getOrDefault("X-Amz-Signature")
  valid_611983 = validateParameter(valid_611983, JString, required = false,
                                 default = nil)
  if valid_611983 != nil:
    section.add "X-Amz-Signature", valid_611983
  var valid_611984 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611984 = validateParameter(valid_611984, JString, required = false,
                                 default = nil)
  if valid_611984 != nil:
    section.add "X-Amz-Content-Sha256", valid_611984
  var valid_611985 = header.getOrDefault("X-Amz-Date")
  valid_611985 = validateParameter(valid_611985, JString, required = false,
                                 default = nil)
  if valid_611985 != nil:
    section.add "X-Amz-Date", valid_611985
  var valid_611986 = header.getOrDefault("X-Amz-Credential")
  valid_611986 = validateParameter(valid_611986, JString, required = false,
                                 default = nil)
  if valid_611986 != nil:
    section.add "X-Amz-Credential", valid_611986
  var valid_611987 = header.getOrDefault("X-Amz-Security-Token")
  valid_611987 = validateParameter(valid_611987, JString, required = false,
                                 default = nil)
  if valid_611987 != nil:
    section.add "X-Amz-Security-Token", valid_611987
  var valid_611988 = header.getOrDefault("X-Amz-Algorithm")
  valid_611988 = validateParameter(valid_611988, JString, required = false,
                                 default = nil)
  if valid_611988 != nil:
    section.add "X-Amz-Algorithm", valid_611988
  var valid_611989 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611989 = validateParameter(valid_611989, JString, required = false,
                                 default = nil)
  if valid_611989 != nil:
    section.add "X-Amz-SignedHeaders", valid_611989
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_611991: Call_CreateOTAUpdate_611979; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ## 
  let valid = call_611991.validator(path, query, header, formData, body)
  let scheme = call_611991.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611991.url(scheme.get, call_611991.host, call_611991.base,
                         call_611991.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611991, url, valid)

proc call*(call_611992: Call_CreateOTAUpdate_611979; body: JsonNode;
          otaUpdateId: string): Recallable =
  ## createOTAUpdate
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ##   body: JObject (required)
  ##   otaUpdateId: string (required)
  ##              : The ID of the OTA update to be created.
  var path_611993 = newJObject()
  var body_611994 = newJObject()
  if body != nil:
    body_611994 = body
  add(path_611993, "otaUpdateId", newJString(otaUpdateId))
  result = call_611992.call(path_611993, nil, nil, nil, body_611994)

var createOTAUpdate* = Call_CreateOTAUpdate_611979(name: "createOTAUpdate",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_CreateOTAUpdate_611980,
    base: "/", url: url_CreateOTAUpdate_611981, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetOTAUpdate_611965 = ref object of OpenApiRestCall_610658
proc url_GetOTAUpdate_611967(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOTAUpdate_611966(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets an OTA update.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The OTA update ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_611968 = path.getOrDefault("otaUpdateId")
  valid_611968 = validateParameter(valid_611968, JString, required = true,
                                 default = nil)
  if valid_611968 != nil:
    section.add "otaUpdateId", valid_611968
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_611969 = header.getOrDefault("X-Amz-Signature")
  valid_611969 = validateParameter(valid_611969, JString, required = false,
                                 default = nil)
  if valid_611969 != nil:
    section.add "X-Amz-Signature", valid_611969
  var valid_611970 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_611970 = validateParameter(valid_611970, JString, required = false,
                                 default = nil)
  if valid_611970 != nil:
    section.add "X-Amz-Content-Sha256", valid_611970
  var valid_611971 = header.getOrDefault("X-Amz-Date")
  valid_611971 = validateParameter(valid_611971, JString, required = false,
                                 default = nil)
  if valid_611971 != nil:
    section.add "X-Amz-Date", valid_611971
  var valid_611972 = header.getOrDefault("X-Amz-Credential")
  valid_611972 = validateParameter(valid_611972, JString, required = false,
                                 default = nil)
  if valid_611972 != nil:
    section.add "X-Amz-Credential", valid_611972
  var valid_611973 = header.getOrDefault("X-Amz-Security-Token")
  valid_611973 = validateParameter(valid_611973, JString, required = false,
                                 default = nil)
  if valid_611973 != nil:
    section.add "X-Amz-Security-Token", valid_611973
  var valid_611974 = header.getOrDefault("X-Amz-Algorithm")
  valid_611974 = validateParameter(valid_611974, JString, required = false,
                                 default = nil)
  if valid_611974 != nil:
    section.add "X-Amz-Algorithm", valid_611974
  var valid_611975 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_611975 = validateParameter(valid_611975, JString, required = false,
                                 default = nil)
  if valid_611975 != nil:
    section.add "X-Amz-SignedHeaders", valid_611975
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_611976: Call_GetOTAUpdate_611965; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets an OTA update.
  ## 
  let valid = call_611976.validator(path, query, header, formData, body)
  let scheme = call_611976.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_611976.url(scheme.get, call_611976.host, call_611976.base,
                         call_611976.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_611976, url, valid)

proc call*(call_611977: Call_GetOTAUpdate_611965; otaUpdateId: string): Recallable =
  ## getOTAUpdate
  ## Gets an OTA update.
  ##   otaUpdateId: string (required)
  ##              : The OTA update ID.
  var path_611978 = newJObject()
  add(path_611978, "otaUpdateId", newJString(otaUpdateId))
  result = call_611977.call(path_611978, nil, nil, nil, nil)

var getOTAUpdate* = Call_GetOTAUpdate_611965(name: "getOTAUpdate",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_GetOTAUpdate_611966,
    base: "/", url: url_GetOTAUpdate_611967, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteOTAUpdate_611995 = ref object of OpenApiRestCall_610658
proc url_DeleteOTAUpdate_611997(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOTAUpdate_611996(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Delete an OTA update.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The OTA update ID to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_611998 = path.getOrDefault("otaUpdateId")
  valid_611998 = validateParameter(valid_611998, JString, required = true,
                                 default = nil)
  if valid_611998 != nil:
    section.add "otaUpdateId", valid_611998
  result.add "path", section
  ## parameters in `query` object:
  ##   deleteStream: JBool
  ##               : Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.
  ##   forceDeleteAWSJob: JBool
  ##                    : Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.
  section = newJObject()
  var valid_611999 = query.getOrDefault("deleteStream")
  valid_611999 = validateParameter(valid_611999, JBool, required = false, default = nil)
  if valid_611999 != nil:
    section.add "deleteStream", valid_611999
  var valid_612000 = query.getOrDefault("forceDeleteAWSJob")
  valid_612000 = validateParameter(valid_612000, JBool, required = false, default = nil)
  if valid_612000 != nil:
    section.add "forceDeleteAWSJob", valid_612000
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612001 = header.getOrDefault("X-Amz-Signature")
  valid_612001 = validateParameter(valid_612001, JString, required = false,
                                 default = nil)
  if valid_612001 != nil:
    section.add "X-Amz-Signature", valid_612001
  var valid_612002 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612002 = validateParameter(valid_612002, JString, required = false,
                                 default = nil)
  if valid_612002 != nil:
    section.add "X-Amz-Content-Sha256", valid_612002
  var valid_612003 = header.getOrDefault("X-Amz-Date")
  valid_612003 = validateParameter(valid_612003, JString, required = false,
                                 default = nil)
  if valid_612003 != nil:
    section.add "X-Amz-Date", valid_612003
  var valid_612004 = header.getOrDefault("X-Amz-Credential")
  valid_612004 = validateParameter(valid_612004, JString, required = false,
                                 default = nil)
  if valid_612004 != nil:
    section.add "X-Amz-Credential", valid_612004
  var valid_612005 = header.getOrDefault("X-Amz-Security-Token")
  valid_612005 = validateParameter(valid_612005, JString, required = false,
                                 default = nil)
  if valid_612005 != nil:
    section.add "X-Amz-Security-Token", valid_612005
  var valid_612006 = header.getOrDefault("X-Amz-Algorithm")
  valid_612006 = validateParameter(valid_612006, JString, required = false,
                                 default = nil)
  if valid_612006 != nil:
    section.add "X-Amz-Algorithm", valid_612006
  var valid_612007 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612007 = validateParameter(valid_612007, JString, required = false,
                                 default = nil)
  if valid_612007 != nil:
    section.add "X-Amz-SignedHeaders", valid_612007
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612008: Call_DeleteOTAUpdate_611995; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete an OTA update.
  ## 
  let valid = call_612008.validator(path, query, header, formData, body)
  let scheme = call_612008.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612008.url(scheme.get, call_612008.host, call_612008.base,
                         call_612008.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612008, url, valid)

proc call*(call_612009: Call_DeleteOTAUpdate_611995; otaUpdateId: string;
          deleteStream: bool = false; forceDeleteAWSJob: bool = false): Recallable =
  ## deleteOTAUpdate
  ## Delete an OTA update.
  ##   deleteStream: bool
  ##               : Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.
  ##   otaUpdateId: string (required)
  ##              : The OTA update ID to delete.
  ##   forceDeleteAWSJob: bool
  ##                    : Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.
  var path_612010 = newJObject()
  var query_612011 = newJObject()
  add(query_612011, "deleteStream", newJBool(deleteStream))
  add(path_612010, "otaUpdateId", newJString(otaUpdateId))
  add(query_612011, "forceDeleteAWSJob", newJBool(forceDeleteAWSJob))
  result = call_612009.call(path_612010, query_612011, nil, nil, nil)

var deleteOTAUpdate* = Call_DeleteOTAUpdate_611995(name: "deleteOTAUpdate",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_DeleteOTAUpdate_611996,
    base: "/", url: url_DeleteOTAUpdate_611997, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreatePolicy_612026 = ref object of OpenApiRestCall_610658
proc url_CreatePolicy_612028(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreatePolicy_612027(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_612029 = path.getOrDefault("policyName")
  valid_612029 = validateParameter(valid_612029, JString, required = true,
                                 default = nil)
  if valid_612029 != nil:
    section.add "policyName", valid_612029
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612030 = header.getOrDefault("X-Amz-Signature")
  valid_612030 = validateParameter(valid_612030, JString, required = false,
                                 default = nil)
  if valid_612030 != nil:
    section.add "X-Amz-Signature", valid_612030
  var valid_612031 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612031 = validateParameter(valid_612031, JString, required = false,
                                 default = nil)
  if valid_612031 != nil:
    section.add "X-Amz-Content-Sha256", valid_612031
  var valid_612032 = header.getOrDefault("X-Amz-Date")
  valid_612032 = validateParameter(valid_612032, JString, required = false,
                                 default = nil)
  if valid_612032 != nil:
    section.add "X-Amz-Date", valid_612032
  var valid_612033 = header.getOrDefault("X-Amz-Credential")
  valid_612033 = validateParameter(valid_612033, JString, required = false,
                                 default = nil)
  if valid_612033 != nil:
    section.add "X-Amz-Credential", valid_612033
  var valid_612034 = header.getOrDefault("X-Amz-Security-Token")
  valid_612034 = validateParameter(valid_612034, JString, required = false,
                                 default = nil)
  if valid_612034 != nil:
    section.add "X-Amz-Security-Token", valid_612034
  var valid_612035 = header.getOrDefault("X-Amz-Algorithm")
  valid_612035 = validateParameter(valid_612035, JString, required = false,
                                 default = nil)
  if valid_612035 != nil:
    section.add "X-Amz-Algorithm", valid_612035
  var valid_612036 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612036 = validateParameter(valid_612036, JString, required = false,
                                 default = nil)
  if valid_612036 != nil:
    section.add "X-Amz-SignedHeaders", valid_612036
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612038: Call_CreatePolicy_612026; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ## 
  let valid = call_612038.validator(path, query, header, formData, body)
  let scheme = call_612038.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612038.url(scheme.get, call_612038.host, call_612038.base,
                         call_612038.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612038, url, valid)

proc call*(call_612039: Call_CreatePolicy_612026; policyName: string; body: JsonNode): Recallable =
  ## createPolicy
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ##   policyName: string (required)
  ##             : The policy name.
  ##   body: JObject (required)
  var path_612040 = newJObject()
  var body_612041 = newJObject()
  add(path_612040, "policyName", newJString(policyName))
  if body != nil:
    body_612041 = body
  result = call_612039.call(path_612040, nil, nil, nil, body_612041)

var createPolicy* = Call_CreatePolicy_612026(name: "createPolicy",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/policies/{policyName}", validator: validate_CreatePolicy_612027,
    base: "/", url: url_CreatePolicy_612028, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPolicy_612012 = ref object of OpenApiRestCall_610658
proc url_GetPolicy_612014(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetPolicy_612013(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the specified policy with the policy document of the default version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_612015 = path.getOrDefault("policyName")
  valid_612015 = validateParameter(valid_612015, JString, required = true,
                                 default = nil)
  if valid_612015 != nil:
    section.add "policyName", valid_612015
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612016 = header.getOrDefault("X-Amz-Signature")
  valid_612016 = validateParameter(valid_612016, JString, required = false,
                                 default = nil)
  if valid_612016 != nil:
    section.add "X-Amz-Signature", valid_612016
  var valid_612017 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612017 = validateParameter(valid_612017, JString, required = false,
                                 default = nil)
  if valid_612017 != nil:
    section.add "X-Amz-Content-Sha256", valid_612017
  var valid_612018 = header.getOrDefault("X-Amz-Date")
  valid_612018 = validateParameter(valid_612018, JString, required = false,
                                 default = nil)
  if valid_612018 != nil:
    section.add "X-Amz-Date", valid_612018
  var valid_612019 = header.getOrDefault("X-Amz-Credential")
  valid_612019 = validateParameter(valid_612019, JString, required = false,
                                 default = nil)
  if valid_612019 != nil:
    section.add "X-Amz-Credential", valid_612019
  var valid_612020 = header.getOrDefault("X-Amz-Security-Token")
  valid_612020 = validateParameter(valid_612020, JString, required = false,
                                 default = nil)
  if valid_612020 != nil:
    section.add "X-Amz-Security-Token", valid_612020
  var valid_612021 = header.getOrDefault("X-Amz-Algorithm")
  valid_612021 = validateParameter(valid_612021, JString, required = false,
                                 default = nil)
  if valid_612021 != nil:
    section.add "X-Amz-Algorithm", valid_612021
  var valid_612022 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612022 = validateParameter(valid_612022, JString, required = false,
                                 default = nil)
  if valid_612022 != nil:
    section.add "X-Amz-SignedHeaders", valid_612022
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612023: Call_GetPolicy_612012; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified policy with the policy document of the default version.
  ## 
  let valid = call_612023.validator(path, query, header, formData, body)
  let scheme = call_612023.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612023.url(scheme.get, call_612023.host, call_612023.base,
                         call_612023.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612023, url, valid)

proc call*(call_612024: Call_GetPolicy_612012; policyName: string): Recallable =
  ## getPolicy
  ## Gets information about the specified policy with the policy document of the default version.
  ##   policyName: string (required)
  ##             : The name of the policy.
  var path_612025 = newJObject()
  add(path_612025, "policyName", newJString(policyName))
  result = call_612024.call(path_612025, nil, nil, nil, nil)

var getPolicy* = Call_GetPolicy_612012(name: "getPolicy", meth: HttpMethod.HttpGet,
                                    host: "iot.amazonaws.com",
                                    route: "/policies/{policyName}",
                                    validator: validate_GetPolicy_612013,
                                    base: "/", url: url_GetPolicy_612014,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeletePolicy_612042 = ref object of OpenApiRestCall_610658
proc url_DeletePolicy_612044(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeletePolicy_612043(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_612045 = path.getOrDefault("policyName")
  valid_612045 = validateParameter(valid_612045, JString, required = true,
                                 default = nil)
  if valid_612045 != nil:
    section.add "policyName", valid_612045
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612046 = header.getOrDefault("X-Amz-Signature")
  valid_612046 = validateParameter(valid_612046, JString, required = false,
                                 default = nil)
  if valid_612046 != nil:
    section.add "X-Amz-Signature", valid_612046
  var valid_612047 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612047 = validateParameter(valid_612047, JString, required = false,
                                 default = nil)
  if valid_612047 != nil:
    section.add "X-Amz-Content-Sha256", valid_612047
  var valid_612048 = header.getOrDefault("X-Amz-Date")
  valid_612048 = validateParameter(valid_612048, JString, required = false,
                                 default = nil)
  if valid_612048 != nil:
    section.add "X-Amz-Date", valid_612048
  var valid_612049 = header.getOrDefault("X-Amz-Credential")
  valid_612049 = validateParameter(valid_612049, JString, required = false,
                                 default = nil)
  if valid_612049 != nil:
    section.add "X-Amz-Credential", valid_612049
  var valid_612050 = header.getOrDefault("X-Amz-Security-Token")
  valid_612050 = validateParameter(valid_612050, JString, required = false,
                                 default = nil)
  if valid_612050 != nil:
    section.add "X-Amz-Security-Token", valid_612050
  var valid_612051 = header.getOrDefault("X-Amz-Algorithm")
  valid_612051 = validateParameter(valid_612051, JString, required = false,
                                 default = nil)
  if valid_612051 != nil:
    section.add "X-Amz-Algorithm", valid_612051
  var valid_612052 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612052 = validateParameter(valid_612052, JString, required = false,
                                 default = nil)
  if valid_612052 != nil:
    section.add "X-Amz-SignedHeaders", valid_612052
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612053: Call_DeletePolicy_612042; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ## 
  let valid = call_612053.validator(path, query, header, formData, body)
  let scheme = call_612053.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612053.url(scheme.get, call_612053.host, call_612053.base,
                         call_612053.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612053, url, valid)

proc call*(call_612054: Call_DeletePolicy_612042; policyName: string): Recallable =
  ## deletePolicy
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ##   policyName: string (required)
  ##             : The name of the policy to delete.
  var path_612055 = newJObject()
  add(path_612055, "policyName", newJString(policyName))
  result = call_612054.call(path_612055, nil, nil, nil, nil)

var deletePolicy* = Call_DeletePolicy_612042(name: "deletePolicy",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/policies/{policyName}", validator: validate_DeletePolicy_612043,
    base: "/", url: url_DeletePolicy_612044, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreatePolicyVersion_612070 = ref object of OpenApiRestCall_610658
proc url_CreatePolicyVersion_612072(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreatePolicyVersion_612071(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_612073 = path.getOrDefault("policyName")
  valid_612073 = validateParameter(valid_612073, JString, required = true,
                                 default = nil)
  if valid_612073 != nil:
    section.add "policyName", valid_612073
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsDefault: JBool
  ##               : Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
  section = newJObject()
  var valid_612074 = query.getOrDefault("setAsDefault")
  valid_612074 = validateParameter(valid_612074, JBool, required = false, default = nil)
  if valid_612074 != nil:
    section.add "setAsDefault", valid_612074
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612075 = header.getOrDefault("X-Amz-Signature")
  valid_612075 = validateParameter(valid_612075, JString, required = false,
                                 default = nil)
  if valid_612075 != nil:
    section.add "X-Amz-Signature", valid_612075
  var valid_612076 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612076 = validateParameter(valid_612076, JString, required = false,
                                 default = nil)
  if valid_612076 != nil:
    section.add "X-Amz-Content-Sha256", valid_612076
  var valid_612077 = header.getOrDefault("X-Amz-Date")
  valid_612077 = validateParameter(valid_612077, JString, required = false,
                                 default = nil)
  if valid_612077 != nil:
    section.add "X-Amz-Date", valid_612077
  var valid_612078 = header.getOrDefault("X-Amz-Credential")
  valid_612078 = validateParameter(valid_612078, JString, required = false,
                                 default = nil)
  if valid_612078 != nil:
    section.add "X-Amz-Credential", valid_612078
  var valid_612079 = header.getOrDefault("X-Amz-Security-Token")
  valid_612079 = validateParameter(valid_612079, JString, required = false,
                                 default = nil)
  if valid_612079 != nil:
    section.add "X-Amz-Security-Token", valid_612079
  var valid_612080 = header.getOrDefault("X-Amz-Algorithm")
  valid_612080 = validateParameter(valid_612080, JString, required = false,
                                 default = nil)
  if valid_612080 != nil:
    section.add "X-Amz-Algorithm", valid_612080
  var valid_612081 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612081 = validateParameter(valid_612081, JString, required = false,
                                 default = nil)
  if valid_612081 != nil:
    section.add "X-Amz-SignedHeaders", valid_612081
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612083: Call_CreatePolicyVersion_612070; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ## 
  let valid = call_612083.validator(path, query, header, formData, body)
  let scheme = call_612083.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612083.url(scheme.get, call_612083.host, call_612083.base,
                         call_612083.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612083, url, valid)

proc call*(call_612084: Call_CreatePolicyVersion_612070; policyName: string;
          body: JsonNode; setAsDefault: bool = false): Recallable =
  ## createPolicyVersion
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ##   policyName: string (required)
  ##             : The policy name.
  ##   setAsDefault: bool
  ##               : Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
  ##   body: JObject (required)
  var path_612085 = newJObject()
  var query_612086 = newJObject()
  var body_612087 = newJObject()
  add(path_612085, "policyName", newJString(policyName))
  add(query_612086, "setAsDefault", newJBool(setAsDefault))
  if body != nil:
    body_612087 = body
  result = call_612084.call(path_612085, query_612086, nil, nil, body_612087)

var createPolicyVersion* = Call_CreatePolicyVersion_612070(
    name: "createPolicyVersion", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/policies/{policyName}/version",
    validator: validate_CreatePolicyVersion_612071, base: "/",
    url: url_CreatePolicyVersion_612072, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicyVersions_612056 = ref object of OpenApiRestCall_610658
proc url_ListPolicyVersions_612058(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListPolicyVersions_612057(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Lists the versions of the specified policy and identifies the default version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_612059 = path.getOrDefault("policyName")
  valid_612059 = validateParameter(valid_612059, JString, required = true,
                                 default = nil)
  if valid_612059 != nil:
    section.add "policyName", valid_612059
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612060 = header.getOrDefault("X-Amz-Signature")
  valid_612060 = validateParameter(valid_612060, JString, required = false,
                                 default = nil)
  if valid_612060 != nil:
    section.add "X-Amz-Signature", valid_612060
  var valid_612061 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612061 = validateParameter(valid_612061, JString, required = false,
                                 default = nil)
  if valid_612061 != nil:
    section.add "X-Amz-Content-Sha256", valid_612061
  var valid_612062 = header.getOrDefault("X-Amz-Date")
  valid_612062 = validateParameter(valid_612062, JString, required = false,
                                 default = nil)
  if valid_612062 != nil:
    section.add "X-Amz-Date", valid_612062
  var valid_612063 = header.getOrDefault("X-Amz-Credential")
  valid_612063 = validateParameter(valid_612063, JString, required = false,
                                 default = nil)
  if valid_612063 != nil:
    section.add "X-Amz-Credential", valid_612063
  var valid_612064 = header.getOrDefault("X-Amz-Security-Token")
  valid_612064 = validateParameter(valid_612064, JString, required = false,
                                 default = nil)
  if valid_612064 != nil:
    section.add "X-Amz-Security-Token", valid_612064
  var valid_612065 = header.getOrDefault("X-Amz-Algorithm")
  valid_612065 = validateParameter(valid_612065, JString, required = false,
                                 default = nil)
  if valid_612065 != nil:
    section.add "X-Amz-Algorithm", valid_612065
  var valid_612066 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612066 = validateParameter(valid_612066, JString, required = false,
                                 default = nil)
  if valid_612066 != nil:
    section.add "X-Amz-SignedHeaders", valid_612066
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612067: Call_ListPolicyVersions_612056; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the versions of the specified policy and identifies the default version.
  ## 
  let valid = call_612067.validator(path, query, header, formData, body)
  let scheme = call_612067.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612067.url(scheme.get, call_612067.host, call_612067.base,
                         call_612067.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612067, url, valid)

proc call*(call_612068: Call_ListPolicyVersions_612056; policyName: string): Recallable =
  ## listPolicyVersions
  ## Lists the versions of the specified policy and identifies the default version.
  ##   policyName: string (required)
  ##             : The policy name.
  var path_612069 = newJObject()
  add(path_612069, "policyName", newJString(policyName))
  result = call_612068.call(path_612069, nil, nil, nil, nil)

var listPolicyVersions* = Call_ListPolicyVersions_612056(
    name: "listPolicyVersions", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version",
    validator: validate_ListPolicyVersions_612057, base: "/",
    url: url_ListPolicyVersions_612058, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateProvisioningClaim_612088 = ref object of OpenApiRestCall_610658
proc url_CreateProvisioningClaim_612090(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/provisioning-claim")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateProvisioningClaim_612089(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a provisioning claim.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the provisioning template to use.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_612091 = path.getOrDefault("templateName")
  valid_612091 = validateParameter(valid_612091, JString, required = true,
                                 default = nil)
  if valid_612091 != nil:
    section.add "templateName", valid_612091
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612092 = header.getOrDefault("X-Amz-Signature")
  valid_612092 = validateParameter(valid_612092, JString, required = false,
                                 default = nil)
  if valid_612092 != nil:
    section.add "X-Amz-Signature", valid_612092
  var valid_612093 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612093 = validateParameter(valid_612093, JString, required = false,
                                 default = nil)
  if valid_612093 != nil:
    section.add "X-Amz-Content-Sha256", valid_612093
  var valid_612094 = header.getOrDefault("X-Amz-Date")
  valid_612094 = validateParameter(valid_612094, JString, required = false,
                                 default = nil)
  if valid_612094 != nil:
    section.add "X-Amz-Date", valid_612094
  var valid_612095 = header.getOrDefault("X-Amz-Credential")
  valid_612095 = validateParameter(valid_612095, JString, required = false,
                                 default = nil)
  if valid_612095 != nil:
    section.add "X-Amz-Credential", valid_612095
  var valid_612096 = header.getOrDefault("X-Amz-Security-Token")
  valid_612096 = validateParameter(valid_612096, JString, required = false,
                                 default = nil)
  if valid_612096 != nil:
    section.add "X-Amz-Security-Token", valid_612096
  var valid_612097 = header.getOrDefault("X-Amz-Algorithm")
  valid_612097 = validateParameter(valid_612097, JString, required = false,
                                 default = nil)
  if valid_612097 != nil:
    section.add "X-Amz-Algorithm", valid_612097
  var valid_612098 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612098 = validateParameter(valid_612098, JString, required = false,
                                 default = nil)
  if valid_612098 != nil:
    section.add "X-Amz-SignedHeaders", valid_612098
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612099: Call_CreateProvisioningClaim_612088; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a provisioning claim.
  ## 
  let valid = call_612099.validator(path, query, header, formData, body)
  let scheme = call_612099.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612099.url(scheme.get, call_612099.host, call_612099.base,
                         call_612099.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612099, url, valid)

proc call*(call_612100: Call_CreateProvisioningClaim_612088; templateName: string): Recallable =
  ## createProvisioningClaim
  ## Creates a provisioning claim.
  ##   templateName: string (required)
  ##               : The name of the provisioning template to use.
  var path_612101 = newJObject()
  add(path_612101, "templateName", newJString(templateName))
  result = call_612100.call(path_612101, nil, nil, nil, nil)

var createProvisioningClaim* = Call_CreateProvisioningClaim_612088(
    name: "createProvisioningClaim", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/provisioning-claim",
    validator: validate_CreateProvisioningClaim_612089, base: "/",
    url: url_CreateProvisioningClaim_612090, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateProvisioningTemplate_612117 = ref object of OpenApiRestCall_610658
proc url_CreateProvisioningTemplate_612119(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateProvisioningTemplate_612118(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612120 = header.getOrDefault("X-Amz-Signature")
  valid_612120 = validateParameter(valid_612120, JString, required = false,
                                 default = nil)
  if valid_612120 != nil:
    section.add "X-Amz-Signature", valid_612120
  var valid_612121 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612121 = validateParameter(valid_612121, JString, required = false,
                                 default = nil)
  if valid_612121 != nil:
    section.add "X-Amz-Content-Sha256", valid_612121
  var valid_612122 = header.getOrDefault("X-Amz-Date")
  valid_612122 = validateParameter(valid_612122, JString, required = false,
                                 default = nil)
  if valid_612122 != nil:
    section.add "X-Amz-Date", valid_612122
  var valid_612123 = header.getOrDefault("X-Amz-Credential")
  valid_612123 = validateParameter(valid_612123, JString, required = false,
                                 default = nil)
  if valid_612123 != nil:
    section.add "X-Amz-Credential", valid_612123
  var valid_612124 = header.getOrDefault("X-Amz-Security-Token")
  valid_612124 = validateParameter(valid_612124, JString, required = false,
                                 default = nil)
  if valid_612124 != nil:
    section.add "X-Amz-Security-Token", valid_612124
  var valid_612125 = header.getOrDefault("X-Amz-Algorithm")
  valid_612125 = validateParameter(valid_612125, JString, required = false,
                                 default = nil)
  if valid_612125 != nil:
    section.add "X-Amz-Algorithm", valid_612125
  var valid_612126 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612126 = validateParameter(valid_612126, JString, required = false,
                                 default = nil)
  if valid_612126 != nil:
    section.add "X-Amz-SignedHeaders", valid_612126
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612128: Call_CreateProvisioningTemplate_612117; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a fleet provisioning template.
  ## 
  let valid = call_612128.validator(path, query, header, formData, body)
  let scheme = call_612128.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612128.url(scheme.get, call_612128.host, call_612128.base,
                         call_612128.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612128, url, valid)

proc call*(call_612129: Call_CreateProvisioningTemplate_612117; body: JsonNode): Recallable =
  ## createProvisioningTemplate
  ## Creates a fleet provisioning template.
  ##   body: JObject (required)
  var body_612130 = newJObject()
  if body != nil:
    body_612130 = body
  result = call_612129.call(nil, nil, nil, nil, body_612130)

var createProvisioningTemplate* = Call_CreateProvisioningTemplate_612117(
    name: "createProvisioningTemplate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/provisioning-templates",
    validator: validate_CreateProvisioningTemplate_612118, base: "/",
    url: url_CreateProvisioningTemplate_612119,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListProvisioningTemplates_612102 = ref object of OpenApiRestCall_610658
proc url_ListProvisioningTemplates_612104(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListProvisioningTemplates_612103(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the fleet provisioning templates in your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_612105 = query.getOrDefault("nextToken")
  valid_612105 = validateParameter(valid_612105, JString, required = false,
                                 default = nil)
  if valid_612105 != nil:
    section.add "nextToken", valid_612105
  var valid_612106 = query.getOrDefault("maxResults")
  valid_612106 = validateParameter(valid_612106, JInt, required = false, default = nil)
  if valid_612106 != nil:
    section.add "maxResults", valid_612106
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612107 = header.getOrDefault("X-Amz-Signature")
  valid_612107 = validateParameter(valid_612107, JString, required = false,
                                 default = nil)
  if valid_612107 != nil:
    section.add "X-Amz-Signature", valid_612107
  var valid_612108 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612108 = validateParameter(valid_612108, JString, required = false,
                                 default = nil)
  if valid_612108 != nil:
    section.add "X-Amz-Content-Sha256", valid_612108
  var valid_612109 = header.getOrDefault("X-Amz-Date")
  valid_612109 = validateParameter(valid_612109, JString, required = false,
                                 default = nil)
  if valid_612109 != nil:
    section.add "X-Amz-Date", valid_612109
  var valid_612110 = header.getOrDefault("X-Amz-Credential")
  valid_612110 = validateParameter(valid_612110, JString, required = false,
                                 default = nil)
  if valid_612110 != nil:
    section.add "X-Amz-Credential", valid_612110
  var valid_612111 = header.getOrDefault("X-Amz-Security-Token")
  valid_612111 = validateParameter(valid_612111, JString, required = false,
                                 default = nil)
  if valid_612111 != nil:
    section.add "X-Amz-Security-Token", valid_612111
  var valid_612112 = header.getOrDefault("X-Amz-Algorithm")
  valid_612112 = validateParameter(valid_612112, JString, required = false,
                                 default = nil)
  if valid_612112 != nil:
    section.add "X-Amz-Algorithm", valid_612112
  var valid_612113 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612113 = validateParameter(valid_612113, JString, required = false,
                                 default = nil)
  if valid_612113 != nil:
    section.add "X-Amz-SignedHeaders", valid_612113
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612114: Call_ListProvisioningTemplates_612102; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the fleet provisioning templates in your AWS account.
  ## 
  let valid = call_612114.validator(path, query, header, formData, body)
  let scheme = call_612114.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612114.url(scheme.get, call_612114.host, call_612114.base,
                         call_612114.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612114, url, valid)

proc call*(call_612115: Call_ListProvisioningTemplates_612102;
          nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listProvisioningTemplates
  ## Lists the fleet provisioning templates in your AWS account.
  ##   nextToken: string
  ##            : A token to retrieve the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_612116 = newJObject()
  add(query_612116, "nextToken", newJString(nextToken))
  add(query_612116, "maxResults", newJInt(maxResults))
  result = call_612115.call(nil, query_612116, nil, nil, nil)

var listProvisioningTemplates* = Call_ListProvisioningTemplates_612102(
    name: "listProvisioningTemplates", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/provisioning-templates",
    validator: validate_ListProvisioningTemplates_612103, base: "/",
    url: url_ListProvisioningTemplates_612104,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateProvisioningTemplateVersion_612148 = ref object of OpenApiRestCall_610658
proc url_CreateProvisioningTemplateVersion_612150(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/versions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateProvisioningTemplateVersion_612149(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new version of a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_612151 = path.getOrDefault("templateName")
  valid_612151 = validateParameter(valid_612151, JString, required = true,
                                 default = nil)
  if valid_612151 != nil:
    section.add "templateName", valid_612151
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsDefault: JBool
  ##               : Sets a fleet provision template version as the default version.
  section = newJObject()
  var valid_612152 = query.getOrDefault("setAsDefault")
  valid_612152 = validateParameter(valid_612152, JBool, required = false, default = nil)
  if valid_612152 != nil:
    section.add "setAsDefault", valid_612152
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612153 = header.getOrDefault("X-Amz-Signature")
  valid_612153 = validateParameter(valid_612153, JString, required = false,
                                 default = nil)
  if valid_612153 != nil:
    section.add "X-Amz-Signature", valid_612153
  var valid_612154 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612154 = validateParameter(valid_612154, JString, required = false,
                                 default = nil)
  if valid_612154 != nil:
    section.add "X-Amz-Content-Sha256", valid_612154
  var valid_612155 = header.getOrDefault("X-Amz-Date")
  valid_612155 = validateParameter(valid_612155, JString, required = false,
                                 default = nil)
  if valid_612155 != nil:
    section.add "X-Amz-Date", valid_612155
  var valid_612156 = header.getOrDefault("X-Amz-Credential")
  valid_612156 = validateParameter(valid_612156, JString, required = false,
                                 default = nil)
  if valid_612156 != nil:
    section.add "X-Amz-Credential", valid_612156
  var valid_612157 = header.getOrDefault("X-Amz-Security-Token")
  valid_612157 = validateParameter(valid_612157, JString, required = false,
                                 default = nil)
  if valid_612157 != nil:
    section.add "X-Amz-Security-Token", valid_612157
  var valid_612158 = header.getOrDefault("X-Amz-Algorithm")
  valid_612158 = validateParameter(valid_612158, JString, required = false,
                                 default = nil)
  if valid_612158 != nil:
    section.add "X-Amz-Algorithm", valid_612158
  var valid_612159 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612159 = validateParameter(valid_612159, JString, required = false,
                                 default = nil)
  if valid_612159 != nil:
    section.add "X-Amz-SignedHeaders", valid_612159
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612161: Call_CreateProvisioningTemplateVersion_612148;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Creates a new version of a fleet provisioning template.
  ## 
  let valid = call_612161.validator(path, query, header, formData, body)
  let scheme = call_612161.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612161.url(scheme.get, call_612161.host, call_612161.base,
                         call_612161.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612161, url, valid)

proc call*(call_612162: Call_CreateProvisioningTemplateVersion_612148;
          body: JsonNode; templateName: string; setAsDefault: bool = false): Recallable =
  ## createProvisioningTemplateVersion
  ## Creates a new version of a fleet provisioning template.
  ##   setAsDefault: bool
  ##               : Sets a fleet provision template version as the default version.
  ##   body: JObject (required)
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template.
  var path_612163 = newJObject()
  var query_612164 = newJObject()
  var body_612165 = newJObject()
  add(query_612164, "setAsDefault", newJBool(setAsDefault))
  if body != nil:
    body_612165 = body
  add(path_612163, "templateName", newJString(templateName))
  result = call_612162.call(path_612163, query_612164, nil, nil, body_612165)

var createProvisioningTemplateVersion* = Call_CreateProvisioningTemplateVersion_612148(
    name: "createProvisioningTemplateVersion", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/versions",
    validator: validate_CreateProvisioningTemplateVersion_612149, base: "/",
    url: url_CreateProvisioningTemplateVersion_612150,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListProvisioningTemplateVersions_612131 = ref object of OpenApiRestCall_610658
proc url_ListProvisioningTemplateVersions_612133(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/versions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListProvisioningTemplateVersions_612132(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## A list of fleet provisioning template versions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_612134 = path.getOrDefault("templateName")
  valid_612134 = validateParameter(valid_612134, JString, required = true,
                                 default = nil)
  if valid_612134 != nil:
    section.add "templateName", valid_612134
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_612135 = query.getOrDefault("nextToken")
  valid_612135 = validateParameter(valid_612135, JString, required = false,
                                 default = nil)
  if valid_612135 != nil:
    section.add "nextToken", valid_612135
  var valid_612136 = query.getOrDefault("maxResults")
  valid_612136 = validateParameter(valid_612136, JInt, required = false, default = nil)
  if valid_612136 != nil:
    section.add "maxResults", valid_612136
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612137 = header.getOrDefault("X-Amz-Signature")
  valid_612137 = validateParameter(valid_612137, JString, required = false,
                                 default = nil)
  if valid_612137 != nil:
    section.add "X-Amz-Signature", valid_612137
  var valid_612138 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612138 = validateParameter(valid_612138, JString, required = false,
                                 default = nil)
  if valid_612138 != nil:
    section.add "X-Amz-Content-Sha256", valid_612138
  var valid_612139 = header.getOrDefault("X-Amz-Date")
  valid_612139 = validateParameter(valid_612139, JString, required = false,
                                 default = nil)
  if valid_612139 != nil:
    section.add "X-Amz-Date", valid_612139
  var valid_612140 = header.getOrDefault("X-Amz-Credential")
  valid_612140 = validateParameter(valid_612140, JString, required = false,
                                 default = nil)
  if valid_612140 != nil:
    section.add "X-Amz-Credential", valid_612140
  var valid_612141 = header.getOrDefault("X-Amz-Security-Token")
  valid_612141 = validateParameter(valid_612141, JString, required = false,
                                 default = nil)
  if valid_612141 != nil:
    section.add "X-Amz-Security-Token", valid_612141
  var valid_612142 = header.getOrDefault("X-Amz-Algorithm")
  valid_612142 = validateParameter(valid_612142, JString, required = false,
                                 default = nil)
  if valid_612142 != nil:
    section.add "X-Amz-Algorithm", valid_612142
  var valid_612143 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612143 = validateParameter(valid_612143, JString, required = false,
                                 default = nil)
  if valid_612143 != nil:
    section.add "X-Amz-SignedHeaders", valid_612143
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612144: Call_ListProvisioningTemplateVersions_612131;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## A list of fleet provisioning template versions.
  ## 
  let valid = call_612144.validator(path, query, header, formData, body)
  let scheme = call_612144.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612144.url(scheme.get, call_612144.host, call_612144.base,
                         call_612144.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612144, url, valid)

proc call*(call_612145: Call_ListProvisioningTemplateVersions_612131;
          templateName: string; nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listProvisioningTemplateVersions
  ## A list of fleet provisioning template versions.
  ##   nextToken: string
  ##            : A token to retrieve the next set of results.
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_612146 = newJObject()
  var query_612147 = newJObject()
  add(query_612147, "nextToken", newJString(nextToken))
  add(path_612146, "templateName", newJString(templateName))
  add(query_612147, "maxResults", newJInt(maxResults))
  result = call_612145.call(path_612146, query_612147, nil, nil, nil)

var listProvisioningTemplateVersions* = Call_ListProvisioningTemplateVersions_612131(
    name: "listProvisioningTemplateVersions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/versions",
    validator: validate_ListProvisioningTemplateVersions_612132, base: "/",
    url: url_ListProvisioningTemplateVersions_612133,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateRoleAlias_612180 = ref object of OpenApiRestCall_610658
proc url_UpdateRoleAlias_612182(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateRoleAlias_612181(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Updates a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_612183 = path.getOrDefault("roleAlias")
  valid_612183 = validateParameter(valid_612183, JString, required = true,
                                 default = nil)
  if valid_612183 != nil:
    section.add "roleAlias", valid_612183
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612184 = header.getOrDefault("X-Amz-Signature")
  valid_612184 = validateParameter(valid_612184, JString, required = false,
                                 default = nil)
  if valid_612184 != nil:
    section.add "X-Amz-Signature", valid_612184
  var valid_612185 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612185 = validateParameter(valid_612185, JString, required = false,
                                 default = nil)
  if valid_612185 != nil:
    section.add "X-Amz-Content-Sha256", valid_612185
  var valid_612186 = header.getOrDefault("X-Amz-Date")
  valid_612186 = validateParameter(valid_612186, JString, required = false,
                                 default = nil)
  if valid_612186 != nil:
    section.add "X-Amz-Date", valid_612186
  var valid_612187 = header.getOrDefault("X-Amz-Credential")
  valid_612187 = validateParameter(valid_612187, JString, required = false,
                                 default = nil)
  if valid_612187 != nil:
    section.add "X-Amz-Credential", valid_612187
  var valid_612188 = header.getOrDefault("X-Amz-Security-Token")
  valid_612188 = validateParameter(valid_612188, JString, required = false,
                                 default = nil)
  if valid_612188 != nil:
    section.add "X-Amz-Security-Token", valid_612188
  var valid_612189 = header.getOrDefault("X-Amz-Algorithm")
  valid_612189 = validateParameter(valid_612189, JString, required = false,
                                 default = nil)
  if valid_612189 != nil:
    section.add "X-Amz-Algorithm", valid_612189
  var valid_612190 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612190 = validateParameter(valid_612190, JString, required = false,
                                 default = nil)
  if valid_612190 != nil:
    section.add "X-Amz-SignedHeaders", valid_612190
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612192: Call_UpdateRoleAlias_612180; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a role alias.
  ## 
  let valid = call_612192.validator(path, query, header, formData, body)
  let scheme = call_612192.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612192.url(scheme.get, call_612192.host, call_612192.base,
                         call_612192.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612192, url, valid)

proc call*(call_612193: Call_UpdateRoleAlias_612180; roleAlias: string;
          body: JsonNode): Recallable =
  ## updateRoleAlias
  ## Updates a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias to update.
  ##   body: JObject (required)
  var path_612194 = newJObject()
  var body_612195 = newJObject()
  add(path_612194, "roleAlias", newJString(roleAlias))
  if body != nil:
    body_612195 = body
  result = call_612193.call(path_612194, nil, nil, nil, body_612195)

var updateRoleAlias* = Call_UpdateRoleAlias_612180(name: "updateRoleAlias",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_UpdateRoleAlias_612181,
    base: "/", url: url_UpdateRoleAlias_612182, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateRoleAlias_612196 = ref object of OpenApiRestCall_610658
proc url_CreateRoleAlias_612198(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateRoleAlias_612197(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias that points to a role ARN. This allows you to change the role without having to update the device.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_612199 = path.getOrDefault("roleAlias")
  valid_612199 = validateParameter(valid_612199, JString, required = true,
                                 default = nil)
  if valid_612199 != nil:
    section.add "roleAlias", valid_612199
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612200 = header.getOrDefault("X-Amz-Signature")
  valid_612200 = validateParameter(valid_612200, JString, required = false,
                                 default = nil)
  if valid_612200 != nil:
    section.add "X-Amz-Signature", valid_612200
  var valid_612201 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612201 = validateParameter(valid_612201, JString, required = false,
                                 default = nil)
  if valid_612201 != nil:
    section.add "X-Amz-Content-Sha256", valid_612201
  var valid_612202 = header.getOrDefault("X-Amz-Date")
  valid_612202 = validateParameter(valid_612202, JString, required = false,
                                 default = nil)
  if valid_612202 != nil:
    section.add "X-Amz-Date", valid_612202
  var valid_612203 = header.getOrDefault("X-Amz-Credential")
  valid_612203 = validateParameter(valid_612203, JString, required = false,
                                 default = nil)
  if valid_612203 != nil:
    section.add "X-Amz-Credential", valid_612203
  var valid_612204 = header.getOrDefault("X-Amz-Security-Token")
  valid_612204 = validateParameter(valid_612204, JString, required = false,
                                 default = nil)
  if valid_612204 != nil:
    section.add "X-Amz-Security-Token", valid_612204
  var valid_612205 = header.getOrDefault("X-Amz-Algorithm")
  valid_612205 = validateParameter(valid_612205, JString, required = false,
                                 default = nil)
  if valid_612205 != nil:
    section.add "X-Amz-Algorithm", valid_612205
  var valid_612206 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612206 = validateParameter(valid_612206, JString, required = false,
                                 default = nil)
  if valid_612206 != nil:
    section.add "X-Amz-SignedHeaders", valid_612206
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612208: Call_CreateRoleAlias_612196; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a role alias.
  ## 
  let valid = call_612208.validator(path, query, header, formData, body)
  let scheme = call_612208.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612208.url(scheme.get, call_612208.host, call_612208.base,
                         call_612208.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612208, url, valid)

proc call*(call_612209: Call_CreateRoleAlias_612196; roleAlias: string;
          body: JsonNode): Recallable =
  ## createRoleAlias
  ## Creates a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias that points to a role ARN. This allows you to change the role without having to update the device.
  ##   body: JObject (required)
  var path_612210 = newJObject()
  var body_612211 = newJObject()
  add(path_612210, "roleAlias", newJString(roleAlias))
  if body != nil:
    body_612211 = body
  result = call_612209.call(path_612210, nil, nil, nil, body_612211)

var createRoleAlias* = Call_CreateRoleAlias_612196(name: "createRoleAlias",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_CreateRoleAlias_612197,
    base: "/", url: url_CreateRoleAlias_612198, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeRoleAlias_612166 = ref object of OpenApiRestCall_610658
proc url_DescribeRoleAlias_612168(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeRoleAlias_612167(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Describes a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to describe.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_612169 = path.getOrDefault("roleAlias")
  valid_612169 = validateParameter(valid_612169, JString, required = true,
                                 default = nil)
  if valid_612169 != nil:
    section.add "roleAlias", valid_612169
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612170 = header.getOrDefault("X-Amz-Signature")
  valid_612170 = validateParameter(valid_612170, JString, required = false,
                                 default = nil)
  if valid_612170 != nil:
    section.add "X-Amz-Signature", valid_612170
  var valid_612171 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612171 = validateParameter(valid_612171, JString, required = false,
                                 default = nil)
  if valid_612171 != nil:
    section.add "X-Amz-Content-Sha256", valid_612171
  var valid_612172 = header.getOrDefault("X-Amz-Date")
  valid_612172 = validateParameter(valid_612172, JString, required = false,
                                 default = nil)
  if valid_612172 != nil:
    section.add "X-Amz-Date", valid_612172
  var valid_612173 = header.getOrDefault("X-Amz-Credential")
  valid_612173 = validateParameter(valid_612173, JString, required = false,
                                 default = nil)
  if valid_612173 != nil:
    section.add "X-Amz-Credential", valid_612173
  var valid_612174 = header.getOrDefault("X-Amz-Security-Token")
  valid_612174 = validateParameter(valid_612174, JString, required = false,
                                 default = nil)
  if valid_612174 != nil:
    section.add "X-Amz-Security-Token", valid_612174
  var valid_612175 = header.getOrDefault("X-Amz-Algorithm")
  valid_612175 = validateParameter(valid_612175, JString, required = false,
                                 default = nil)
  if valid_612175 != nil:
    section.add "X-Amz-Algorithm", valid_612175
  var valid_612176 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612176 = validateParameter(valid_612176, JString, required = false,
                                 default = nil)
  if valid_612176 != nil:
    section.add "X-Amz-SignedHeaders", valid_612176
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612177: Call_DescribeRoleAlias_612166; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a role alias.
  ## 
  let valid = call_612177.validator(path, query, header, formData, body)
  let scheme = call_612177.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612177.url(scheme.get, call_612177.host, call_612177.base,
                         call_612177.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612177, url, valid)

proc call*(call_612178: Call_DescribeRoleAlias_612166; roleAlias: string): Recallable =
  ## describeRoleAlias
  ## Describes a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias to describe.
  var path_612179 = newJObject()
  add(path_612179, "roleAlias", newJString(roleAlias))
  result = call_612178.call(path_612179, nil, nil, nil, nil)

var describeRoleAlias* = Call_DescribeRoleAlias_612166(name: "describeRoleAlias",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_DescribeRoleAlias_612167,
    base: "/", url: url_DescribeRoleAlias_612168,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRoleAlias_612212 = ref object of OpenApiRestCall_610658
proc url_DeleteRoleAlias_612214(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteRoleAlias_612213(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes a role alias
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_612215 = path.getOrDefault("roleAlias")
  valid_612215 = validateParameter(valid_612215, JString, required = true,
                                 default = nil)
  if valid_612215 != nil:
    section.add "roleAlias", valid_612215
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612216 = header.getOrDefault("X-Amz-Signature")
  valid_612216 = validateParameter(valid_612216, JString, required = false,
                                 default = nil)
  if valid_612216 != nil:
    section.add "X-Amz-Signature", valid_612216
  var valid_612217 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612217 = validateParameter(valid_612217, JString, required = false,
                                 default = nil)
  if valid_612217 != nil:
    section.add "X-Amz-Content-Sha256", valid_612217
  var valid_612218 = header.getOrDefault("X-Amz-Date")
  valid_612218 = validateParameter(valid_612218, JString, required = false,
                                 default = nil)
  if valid_612218 != nil:
    section.add "X-Amz-Date", valid_612218
  var valid_612219 = header.getOrDefault("X-Amz-Credential")
  valid_612219 = validateParameter(valid_612219, JString, required = false,
                                 default = nil)
  if valid_612219 != nil:
    section.add "X-Amz-Credential", valid_612219
  var valid_612220 = header.getOrDefault("X-Amz-Security-Token")
  valid_612220 = validateParameter(valid_612220, JString, required = false,
                                 default = nil)
  if valid_612220 != nil:
    section.add "X-Amz-Security-Token", valid_612220
  var valid_612221 = header.getOrDefault("X-Amz-Algorithm")
  valid_612221 = validateParameter(valid_612221, JString, required = false,
                                 default = nil)
  if valid_612221 != nil:
    section.add "X-Amz-Algorithm", valid_612221
  var valid_612222 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612222 = validateParameter(valid_612222, JString, required = false,
                                 default = nil)
  if valid_612222 != nil:
    section.add "X-Amz-SignedHeaders", valid_612222
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612223: Call_DeleteRoleAlias_612212; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a role alias
  ## 
  let valid = call_612223.validator(path, query, header, formData, body)
  let scheme = call_612223.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612223.url(scheme.get, call_612223.host, call_612223.base,
                         call_612223.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612223, url, valid)

proc call*(call_612224: Call_DeleteRoleAlias_612212; roleAlias: string): Recallable =
  ## deleteRoleAlias
  ## Deletes a role alias
  ##   roleAlias: string (required)
  ##            : The role alias to delete.
  var path_612225 = newJObject()
  add(path_612225, "roleAlias", newJString(roleAlias))
  result = call_612224.call(path_612225, nil, nil, nil, nil)

var deleteRoleAlias* = Call_DeleteRoleAlias_612212(name: "deleteRoleAlias",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_DeleteRoleAlias_612213,
    base: "/", url: url_DeleteRoleAlias_612214, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateScheduledAudit_612240 = ref object of OpenApiRestCall_610658
proc url_CreateScheduledAudit_612242(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateScheduledAudit_612241(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled audit that is run at a specified time interval.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name you want to give to the scheduled audit. (Max. 128 chars)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_612243 = path.getOrDefault("scheduledAuditName")
  valid_612243 = validateParameter(valid_612243, JString, required = true,
                                 default = nil)
  if valid_612243 != nil:
    section.add "scheduledAuditName", valid_612243
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612244 = header.getOrDefault("X-Amz-Signature")
  valid_612244 = validateParameter(valid_612244, JString, required = false,
                                 default = nil)
  if valid_612244 != nil:
    section.add "X-Amz-Signature", valid_612244
  var valid_612245 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612245 = validateParameter(valid_612245, JString, required = false,
                                 default = nil)
  if valid_612245 != nil:
    section.add "X-Amz-Content-Sha256", valid_612245
  var valid_612246 = header.getOrDefault("X-Amz-Date")
  valid_612246 = validateParameter(valid_612246, JString, required = false,
                                 default = nil)
  if valid_612246 != nil:
    section.add "X-Amz-Date", valid_612246
  var valid_612247 = header.getOrDefault("X-Amz-Credential")
  valid_612247 = validateParameter(valid_612247, JString, required = false,
                                 default = nil)
  if valid_612247 != nil:
    section.add "X-Amz-Credential", valid_612247
  var valid_612248 = header.getOrDefault("X-Amz-Security-Token")
  valid_612248 = validateParameter(valid_612248, JString, required = false,
                                 default = nil)
  if valid_612248 != nil:
    section.add "X-Amz-Security-Token", valid_612248
  var valid_612249 = header.getOrDefault("X-Amz-Algorithm")
  valid_612249 = validateParameter(valid_612249, JString, required = false,
                                 default = nil)
  if valid_612249 != nil:
    section.add "X-Amz-Algorithm", valid_612249
  var valid_612250 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612250 = validateParameter(valid_612250, JString, required = false,
                                 default = nil)
  if valid_612250 != nil:
    section.add "X-Amz-SignedHeaders", valid_612250
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612252: Call_CreateScheduledAudit_612240; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled audit that is run at a specified time interval.
  ## 
  let valid = call_612252.validator(path, query, header, formData, body)
  let scheme = call_612252.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612252.url(scheme.get, call_612252.host, call_612252.base,
                         call_612252.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612252, url, valid)

proc call*(call_612253: Call_CreateScheduledAudit_612240;
          scheduledAuditName: string; body: JsonNode): Recallable =
  ## createScheduledAudit
  ## Creates a scheduled audit that is run at a specified time interval.
  ##   scheduledAuditName: string (required)
  ##                     : The name you want to give to the scheduled audit. (Max. 128 chars)
  ##   body: JObject (required)
  var path_612254 = newJObject()
  var body_612255 = newJObject()
  add(path_612254, "scheduledAuditName", newJString(scheduledAuditName))
  if body != nil:
    body_612255 = body
  result = call_612253.call(path_612254, nil, nil, nil, body_612255)

var createScheduledAudit* = Call_CreateScheduledAudit_612240(
    name: "createScheduledAudit", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_CreateScheduledAudit_612241, base: "/",
    url: url_CreateScheduledAudit_612242, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeScheduledAudit_612226 = ref object of OpenApiRestCall_610658
proc url_DescribeScheduledAudit_612228(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeScheduledAudit_612227(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a scheduled audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit whose information you want to get.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_612229 = path.getOrDefault("scheduledAuditName")
  valid_612229 = validateParameter(valid_612229, JString, required = true,
                                 default = nil)
  if valid_612229 != nil:
    section.add "scheduledAuditName", valid_612229
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612230 = header.getOrDefault("X-Amz-Signature")
  valid_612230 = validateParameter(valid_612230, JString, required = false,
                                 default = nil)
  if valid_612230 != nil:
    section.add "X-Amz-Signature", valid_612230
  var valid_612231 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612231 = validateParameter(valid_612231, JString, required = false,
                                 default = nil)
  if valid_612231 != nil:
    section.add "X-Amz-Content-Sha256", valid_612231
  var valid_612232 = header.getOrDefault("X-Amz-Date")
  valid_612232 = validateParameter(valid_612232, JString, required = false,
                                 default = nil)
  if valid_612232 != nil:
    section.add "X-Amz-Date", valid_612232
  var valid_612233 = header.getOrDefault("X-Amz-Credential")
  valid_612233 = validateParameter(valid_612233, JString, required = false,
                                 default = nil)
  if valid_612233 != nil:
    section.add "X-Amz-Credential", valid_612233
  var valid_612234 = header.getOrDefault("X-Amz-Security-Token")
  valid_612234 = validateParameter(valid_612234, JString, required = false,
                                 default = nil)
  if valid_612234 != nil:
    section.add "X-Amz-Security-Token", valid_612234
  var valid_612235 = header.getOrDefault("X-Amz-Algorithm")
  valid_612235 = validateParameter(valid_612235, JString, required = false,
                                 default = nil)
  if valid_612235 != nil:
    section.add "X-Amz-Algorithm", valid_612235
  var valid_612236 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612236 = validateParameter(valid_612236, JString, required = false,
                                 default = nil)
  if valid_612236 != nil:
    section.add "X-Amz-SignedHeaders", valid_612236
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612237: Call_DescribeScheduledAudit_612226; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a scheduled audit.
  ## 
  let valid = call_612237.validator(path, query, header, formData, body)
  let scheme = call_612237.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612237.url(scheme.get, call_612237.host, call_612237.base,
                         call_612237.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612237, url, valid)

proc call*(call_612238: Call_DescribeScheduledAudit_612226;
          scheduledAuditName: string): Recallable =
  ## describeScheduledAudit
  ## Gets information about a scheduled audit.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit whose information you want to get.
  var path_612239 = newJObject()
  add(path_612239, "scheduledAuditName", newJString(scheduledAuditName))
  result = call_612238.call(path_612239, nil, nil, nil, nil)

var describeScheduledAudit* = Call_DescribeScheduledAudit_612226(
    name: "describeScheduledAudit", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_DescribeScheduledAudit_612227, base: "/",
    url: url_DescribeScheduledAudit_612228, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateScheduledAudit_612270 = ref object of OpenApiRestCall_610658
proc url_UpdateScheduledAudit_612272(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateScheduledAudit_612271(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit. (Max. 128 chars)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_612273 = path.getOrDefault("scheduledAuditName")
  valid_612273 = validateParameter(valid_612273, JString, required = true,
                                 default = nil)
  if valid_612273 != nil:
    section.add "scheduledAuditName", valid_612273
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612274 = header.getOrDefault("X-Amz-Signature")
  valid_612274 = validateParameter(valid_612274, JString, required = false,
                                 default = nil)
  if valid_612274 != nil:
    section.add "X-Amz-Signature", valid_612274
  var valid_612275 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612275 = validateParameter(valid_612275, JString, required = false,
                                 default = nil)
  if valid_612275 != nil:
    section.add "X-Amz-Content-Sha256", valid_612275
  var valid_612276 = header.getOrDefault("X-Amz-Date")
  valid_612276 = validateParameter(valid_612276, JString, required = false,
                                 default = nil)
  if valid_612276 != nil:
    section.add "X-Amz-Date", valid_612276
  var valid_612277 = header.getOrDefault("X-Amz-Credential")
  valid_612277 = validateParameter(valid_612277, JString, required = false,
                                 default = nil)
  if valid_612277 != nil:
    section.add "X-Amz-Credential", valid_612277
  var valid_612278 = header.getOrDefault("X-Amz-Security-Token")
  valid_612278 = validateParameter(valid_612278, JString, required = false,
                                 default = nil)
  if valid_612278 != nil:
    section.add "X-Amz-Security-Token", valid_612278
  var valid_612279 = header.getOrDefault("X-Amz-Algorithm")
  valid_612279 = validateParameter(valid_612279, JString, required = false,
                                 default = nil)
  if valid_612279 != nil:
    section.add "X-Amz-Algorithm", valid_612279
  var valid_612280 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612280 = validateParameter(valid_612280, JString, required = false,
                                 default = nil)
  if valid_612280 != nil:
    section.add "X-Amz-SignedHeaders", valid_612280
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612282: Call_UpdateScheduledAudit_612270; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ## 
  let valid = call_612282.validator(path, query, header, formData, body)
  let scheme = call_612282.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612282.url(scheme.get, call_612282.host, call_612282.base,
                         call_612282.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612282, url, valid)

proc call*(call_612283: Call_UpdateScheduledAudit_612270;
          scheduledAuditName: string; body: JsonNode): Recallable =
  ## updateScheduledAudit
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit. (Max. 128 chars)
  ##   body: JObject (required)
  var path_612284 = newJObject()
  var body_612285 = newJObject()
  add(path_612284, "scheduledAuditName", newJString(scheduledAuditName))
  if body != nil:
    body_612285 = body
  result = call_612283.call(path_612284, nil, nil, nil, body_612285)

var updateScheduledAudit* = Call_UpdateScheduledAudit_612270(
    name: "updateScheduledAudit", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_UpdateScheduledAudit_612271, base: "/",
    url: url_UpdateScheduledAudit_612272, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteScheduledAudit_612256 = ref object of OpenApiRestCall_610658
proc url_DeleteScheduledAudit_612258(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteScheduledAudit_612257(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit you want to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_612259 = path.getOrDefault("scheduledAuditName")
  valid_612259 = validateParameter(valid_612259, JString, required = true,
                                 default = nil)
  if valid_612259 != nil:
    section.add "scheduledAuditName", valid_612259
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612260 = header.getOrDefault("X-Amz-Signature")
  valid_612260 = validateParameter(valid_612260, JString, required = false,
                                 default = nil)
  if valid_612260 != nil:
    section.add "X-Amz-Signature", valid_612260
  var valid_612261 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612261 = validateParameter(valid_612261, JString, required = false,
                                 default = nil)
  if valid_612261 != nil:
    section.add "X-Amz-Content-Sha256", valid_612261
  var valid_612262 = header.getOrDefault("X-Amz-Date")
  valid_612262 = validateParameter(valid_612262, JString, required = false,
                                 default = nil)
  if valid_612262 != nil:
    section.add "X-Amz-Date", valid_612262
  var valid_612263 = header.getOrDefault("X-Amz-Credential")
  valid_612263 = validateParameter(valid_612263, JString, required = false,
                                 default = nil)
  if valid_612263 != nil:
    section.add "X-Amz-Credential", valid_612263
  var valid_612264 = header.getOrDefault("X-Amz-Security-Token")
  valid_612264 = validateParameter(valid_612264, JString, required = false,
                                 default = nil)
  if valid_612264 != nil:
    section.add "X-Amz-Security-Token", valid_612264
  var valid_612265 = header.getOrDefault("X-Amz-Algorithm")
  valid_612265 = validateParameter(valid_612265, JString, required = false,
                                 default = nil)
  if valid_612265 != nil:
    section.add "X-Amz-Algorithm", valid_612265
  var valid_612266 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612266 = validateParameter(valid_612266, JString, required = false,
                                 default = nil)
  if valid_612266 != nil:
    section.add "X-Amz-SignedHeaders", valid_612266
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612267: Call_DeleteScheduledAudit_612256; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled audit.
  ## 
  let valid = call_612267.validator(path, query, header, formData, body)
  let scheme = call_612267.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612267.url(scheme.get, call_612267.host, call_612267.base,
                         call_612267.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612267, url, valid)

proc call*(call_612268: Call_DeleteScheduledAudit_612256;
          scheduledAuditName: string): Recallable =
  ## deleteScheduledAudit
  ## Deletes a scheduled audit.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit you want to delete.
  var path_612269 = newJObject()
  add(path_612269, "scheduledAuditName", newJString(scheduledAuditName))
  result = call_612268.call(path_612269, nil, nil, nil, nil)

var deleteScheduledAudit* = Call_DeleteScheduledAudit_612256(
    name: "deleteScheduledAudit", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_DeleteScheduledAudit_612257, base: "/",
    url: url_DeleteScheduledAudit_612258, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateSecurityProfile_612300 = ref object of OpenApiRestCall_610658
proc url_CreateSecurityProfile_612302(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateSecurityProfile_612301(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name you are giving to the security profile.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_612303 = path.getOrDefault("securityProfileName")
  valid_612303 = validateParameter(valid_612303, JString, required = true,
                                 default = nil)
  if valid_612303 != nil:
    section.add "securityProfileName", valid_612303
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612304 = header.getOrDefault("X-Amz-Signature")
  valid_612304 = validateParameter(valid_612304, JString, required = false,
                                 default = nil)
  if valid_612304 != nil:
    section.add "X-Amz-Signature", valid_612304
  var valid_612305 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612305 = validateParameter(valid_612305, JString, required = false,
                                 default = nil)
  if valid_612305 != nil:
    section.add "X-Amz-Content-Sha256", valid_612305
  var valid_612306 = header.getOrDefault("X-Amz-Date")
  valid_612306 = validateParameter(valid_612306, JString, required = false,
                                 default = nil)
  if valid_612306 != nil:
    section.add "X-Amz-Date", valid_612306
  var valid_612307 = header.getOrDefault("X-Amz-Credential")
  valid_612307 = validateParameter(valid_612307, JString, required = false,
                                 default = nil)
  if valid_612307 != nil:
    section.add "X-Amz-Credential", valid_612307
  var valid_612308 = header.getOrDefault("X-Amz-Security-Token")
  valid_612308 = validateParameter(valid_612308, JString, required = false,
                                 default = nil)
  if valid_612308 != nil:
    section.add "X-Amz-Security-Token", valid_612308
  var valid_612309 = header.getOrDefault("X-Amz-Algorithm")
  valid_612309 = validateParameter(valid_612309, JString, required = false,
                                 default = nil)
  if valid_612309 != nil:
    section.add "X-Amz-Algorithm", valid_612309
  var valid_612310 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612310 = validateParameter(valid_612310, JString, required = false,
                                 default = nil)
  if valid_612310 != nil:
    section.add "X-Amz-SignedHeaders", valid_612310
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612312: Call_CreateSecurityProfile_612300; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Device Defender security profile.
  ## 
  let valid = call_612312.validator(path, query, header, formData, body)
  let scheme = call_612312.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612312.url(scheme.get, call_612312.host, call_612312.base,
                         call_612312.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612312, url, valid)

proc call*(call_612313: Call_CreateSecurityProfile_612300; body: JsonNode;
          securityProfileName: string): Recallable =
  ## createSecurityProfile
  ## Creates a Device Defender security profile.
  ##   body: JObject (required)
  ##   securityProfileName: string (required)
  ##                      : The name you are giving to the security profile.
  var path_612314 = newJObject()
  var body_612315 = newJObject()
  if body != nil:
    body_612315 = body
  add(path_612314, "securityProfileName", newJString(securityProfileName))
  result = call_612313.call(path_612314, nil, nil, nil, body_612315)

var createSecurityProfile* = Call_CreateSecurityProfile_612300(
    name: "createSecurityProfile", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_CreateSecurityProfile_612301, base: "/",
    url: url_CreateSecurityProfile_612302, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeSecurityProfile_612286 = ref object of OpenApiRestCall_610658
proc url_DescribeSecurityProfile_612288(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeSecurityProfile_612287(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile whose information you want to get.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_612289 = path.getOrDefault("securityProfileName")
  valid_612289 = validateParameter(valid_612289, JString, required = true,
                                 default = nil)
  if valid_612289 != nil:
    section.add "securityProfileName", valid_612289
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612290 = header.getOrDefault("X-Amz-Signature")
  valid_612290 = validateParameter(valid_612290, JString, required = false,
                                 default = nil)
  if valid_612290 != nil:
    section.add "X-Amz-Signature", valid_612290
  var valid_612291 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612291 = validateParameter(valid_612291, JString, required = false,
                                 default = nil)
  if valid_612291 != nil:
    section.add "X-Amz-Content-Sha256", valid_612291
  var valid_612292 = header.getOrDefault("X-Amz-Date")
  valid_612292 = validateParameter(valid_612292, JString, required = false,
                                 default = nil)
  if valid_612292 != nil:
    section.add "X-Amz-Date", valid_612292
  var valid_612293 = header.getOrDefault("X-Amz-Credential")
  valid_612293 = validateParameter(valid_612293, JString, required = false,
                                 default = nil)
  if valid_612293 != nil:
    section.add "X-Amz-Credential", valid_612293
  var valid_612294 = header.getOrDefault("X-Amz-Security-Token")
  valid_612294 = validateParameter(valid_612294, JString, required = false,
                                 default = nil)
  if valid_612294 != nil:
    section.add "X-Amz-Security-Token", valid_612294
  var valid_612295 = header.getOrDefault("X-Amz-Algorithm")
  valid_612295 = validateParameter(valid_612295, JString, required = false,
                                 default = nil)
  if valid_612295 != nil:
    section.add "X-Amz-Algorithm", valid_612295
  var valid_612296 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612296 = validateParameter(valid_612296, JString, required = false,
                                 default = nil)
  if valid_612296 != nil:
    section.add "X-Amz-SignedHeaders", valid_612296
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612297: Call_DescribeSecurityProfile_612286; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a Device Defender security profile.
  ## 
  let valid = call_612297.validator(path, query, header, formData, body)
  let scheme = call_612297.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612297.url(scheme.get, call_612297.host, call_612297.base,
                         call_612297.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612297, url, valid)

proc call*(call_612298: Call_DescribeSecurityProfile_612286;
          securityProfileName: string): Recallable =
  ## describeSecurityProfile
  ## Gets information about a Device Defender security profile.
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile whose information you want to get.
  var path_612299 = newJObject()
  add(path_612299, "securityProfileName", newJString(securityProfileName))
  result = call_612298.call(path_612299, nil, nil, nil, nil)

var describeSecurityProfile* = Call_DescribeSecurityProfile_612286(
    name: "describeSecurityProfile", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_DescribeSecurityProfile_612287, base: "/",
    url: url_DescribeSecurityProfile_612288, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateSecurityProfile_612332 = ref object of OpenApiRestCall_610658
proc url_UpdateSecurityProfile_612334(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateSecurityProfile_612333(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile you want to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_612335 = path.getOrDefault("securityProfileName")
  valid_612335 = validateParameter(valid_612335, JString, required = true,
                                 default = nil)
  if valid_612335 != nil:
    section.add "securityProfileName", valid_612335
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  section = newJObject()
  var valid_612336 = query.getOrDefault("expectedVersion")
  valid_612336 = validateParameter(valid_612336, JInt, required = false, default = nil)
  if valid_612336 != nil:
    section.add "expectedVersion", valid_612336
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612337 = header.getOrDefault("X-Amz-Signature")
  valid_612337 = validateParameter(valid_612337, JString, required = false,
                                 default = nil)
  if valid_612337 != nil:
    section.add "X-Amz-Signature", valid_612337
  var valid_612338 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612338 = validateParameter(valid_612338, JString, required = false,
                                 default = nil)
  if valid_612338 != nil:
    section.add "X-Amz-Content-Sha256", valid_612338
  var valid_612339 = header.getOrDefault("X-Amz-Date")
  valid_612339 = validateParameter(valid_612339, JString, required = false,
                                 default = nil)
  if valid_612339 != nil:
    section.add "X-Amz-Date", valid_612339
  var valid_612340 = header.getOrDefault("X-Amz-Credential")
  valid_612340 = validateParameter(valid_612340, JString, required = false,
                                 default = nil)
  if valid_612340 != nil:
    section.add "X-Amz-Credential", valid_612340
  var valid_612341 = header.getOrDefault("X-Amz-Security-Token")
  valid_612341 = validateParameter(valid_612341, JString, required = false,
                                 default = nil)
  if valid_612341 != nil:
    section.add "X-Amz-Security-Token", valid_612341
  var valid_612342 = header.getOrDefault("X-Amz-Algorithm")
  valid_612342 = validateParameter(valid_612342, JString, required = false,
                                 default = nil)
  if valid_612342 != nil:
    section.add "X-Amz-Algorithm", valid_612342
  var valid_612343 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612343 = validateParameter(valid_612343, JString, required = false,
                                 default = nil)
  if valid_612343 != nil:
    section.add "X-Amz-SignedHeaders", valid_612343
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612345: Call_UpdateSecurityProfile_612332; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a Device Defender security profile.
  ## 
  let valid = call_612345.validator(path, query, header, formData, body)
  let scheme = call_612345.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612345.url(scheme.get, call_612345.host, call_612345.base,
                         call_612345.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612345, url, valid)

proc call*(call_612346: Call_UpdateSecurityProfile_612332; body: JsonNode;
          securityProfileName: string; expectedVersion: int = 0): Recallable =
  ## updateSecurityProfile
  ## Updates a Device Defender security profile.
  ##   expectedVersion: int
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  ##   body: JObject (required)
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile you want to update.
  var path_612347 = newJObject()
  var query_612348 = newJObject()
  var body_612349 = newJObject()
  add(query_612348, "expectedVersion", newJInt(expectedVersion))
  if body != nil:
    body_612349 = body
  add(path_612347, "securityProfileName", newJString(securityProfileName))
  result = call_612346.call(path_612347, query_612348, nil, nil, body_612349)

var updateSecurityProfile* = Call_UpdateSecurityProfile_612332(
    name: "updateSecurityProfile", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_UpdateSecurityProfile_612333, base: "/",
    url: url_UpdateSecurityProfile_612334, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteSecurityProfile_612316 = ref object of OpenApiRestCall_610658
proc url_DeleteSecurityProfile_612318(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteSecurityProfile_612317(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile to be deleted.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_612319 = path.getOrDefault("securityProfileName")
  valid_612319 = validateParameter(valid_612319, JString, required = true,
                                 default = nil)
  if valid_612319 != nil:
    section.add "securityProfileName", valid_612319
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  section = newJObject()
  var valid_612320 = query.getOrDefault("expectedVersion")
  valid_612320 = validateParameter(valid_612320, JInt, required = false, default = nil)
  if valid_612320 != nil:
    section.add "expectedVersion", valid_612320
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612321 = header.getOrDefault("X-Amz-Signature")
  valid_612321 = validateParameter(valid_612321, JString, required = false,
                                 default = nil)
  if valid_612321 != nil:
    section.add "X-Amz-Signature", valid_612321
  var valid_612322 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612322 = validateParameter(valid_612322, JString, required = false,
                                 default = nil)
  if valid_612322 != nil:
    section.add "X-Amz-Content-Sha256", valid_612322
  var valid_612323 = header.getOrDefault("X-Amz-Date")
  valid_612323 = validateParameter(valid_612323, JString, required = false,
                                 default = nil)
  if valid_612323 != nil:
    section.add "X-Amz-Date", valid_612323
  var valid_612324 = header.getOrDefault("X-Amz-Credential")
  valid_612324 = validateParameter(valid_612324, JString, required = false,
                                 default = nil)
  if valid_612324 != nil:
    section.add "X-Amz-Credential", valid_612324
  var valid_612325 = header.getOrDefault("X-Amz-Security-Token")
  valid_612325 = validateParameter(valid_612325, JString, required = false,
                                 default = nil)
  if valid_612325 != nil:
    section.add "X-Amz-Security-Token", valid_612325
  var valid_612326 = header.getOrDefault("X-Amz-Algorithm")
  valid_612326 = validateParameter(valid_612326, JString, required = false,
                                 default = nil)
  if valid_612326 != nil:
    section.add "X-Amz-Algorithm", valid_612326
  var valid_612327 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612327 = validateParameter(valid_612327, JString, required = false,
                                 default = nil)
  if valid_612327 != nil:
    section.add "X-Amz-SignedHeaders", valid_612327
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612328: Call_DeleteSecurityProfile_612316; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a Device Defender security profile.
  ## 
  let valid = call_612328.validator(path, query, header, formData, body)
  let scheme = call_612328.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612328.url(scheme.get, call_612328.host, call_612328.base,
                         call_612328.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612328, url, valid)

proc call*(call_612329: Call_DeleteSecurityProfile_612316;
          securityProfileName: string; expectedVersion: int = 0): Recallable =
  ## deleteSecurityProfile
  ## Deletes a Device Defender security profile.
  ##   expectedVersion: int
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile to be deleted.
  var path_612330 = newJObject()
  var query_612331 = newJObject()
  add(query_612331, "expectedVersion", newJInt(expectedVersion))
  add(path_612330, "securityProfileName", newJString(securityProfileName))
  result = call_612329.call(path_612330, query_612331, nil, nil, nil)

var deleteSecurityProfile* = Call_DeleteSecurityProfile_612316(
    name: "deleteSecurityProfile", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_DeleteSecurityProfile_612317, base: "/",
    url: url_DeleteSecurityProfile_612318, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateStream_612364 = ref object of OpenApiRestCall_610658
proc url_UpdateStream_612366(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateStream_612365(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing stream. The stream version will be incremented by one.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_612367 = path.getOrDefault("streamId")
  valid_612367 = validateParameter(valid_612367, JString, required = true,
                                 default = nil)
  if valid_612367 != nil:
    section.add "streamId", valid_612367
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612368 = header.getOrDefault("X-Amz-Signature")
  valid_612368 = validateParameter(valid_612368, JString, required = false,
                                 default = nil)
  if valid_612368 != nil:
    section.add "X-Amz-Signature", valid_612368
  var valid_612369 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612369 = validateParameter(valid_612369, JString, required = false,
                                 default = nil)
  if valid_612369 != nil:
    section.add "X-Amz-Content-Sha256", valid_612369
  var valid_612370 = header.getOrDefault("X-Amz-Date")
  valid_612370 = validateParameter(valid_612370, JString, required = false,
                                 default = nil)
  if valid_612370 != nil:
    section.add "X-Amz-Date", valid_612370
  var valid_612371 = header.getOrDefault("X-Amz-Credential")
  valid_612371 = validateParameter(valid_612371, JString, required = false,
                                 default = nil)
  if valid_612371 != nil:
    section.add "X-Amz-Credential", valid_612371
  var valid_612372 = header.getOrDefault("X-Amz-Security-Token")
  valid_612372 = validateParameter(valid_612372, JString, required = false,
                                 default = nil)
  if valid_612372 != nil:
    section.add "X-Amz-Security-Token", valid_612372
  var valid_612373 = header.getOrDefault("X-Amz-Algorithm")
  valid_612373 = validateParameter(valid_612373, JString, required = false,
                                 default = nil)
  if valid_612373 != nil:
    section.add "X-Amz-Algorithm", valid_612373
  var valid_612374 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612374 = validateParameter(valid_612374, JString, required = false,
                                 default = nil)
  if valid_612374 != nil:
    section.add "X-Amz-SignedHeaders", valid_612374
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612376: Call_UpdateStream_612364; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing stream. The stream version will be incremented by one.
  ## 
  let valid = call_612376.validator(path, query, header, formData, body)
  let scheme = call_612376.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612376.url(scheme.get, call_612376.host, call_612376.base,
                         call_612376.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612376, url, valid)

proc call*(call_612377: Call_UpdateStream_612364; streamId: string; body: JsonNode): Recallable =
  ## updateStream
  ## Updates an existing stream. The stream version will be incremented by one.
  ##   streamId: string (required)
  ##           : The stream ID.
  ##   body: JObject (required)
  var path_612378 = newJObject()
  var body_612379 = newJObject()
  add(path_612378, "streamId", newJString(streamId))
  if body != nil:
    body_612379 = body
  result = call_612377.call(path_612378, nil, nil, nil, body_612379)

var updateStream* = Call_UpdateStream_612364(name: "updateStream",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_UpdateStream_612365,
    base: "/", url: url_UpdateStream_612366, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateStream_612380 = ref object of OpenApiRestCall_610658
proc url_CreateStream_612382(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateStream_612381(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_612383 = path.getOrDefault("streamId")
  valid_612383 = validateParameter(valid_612383, JString, required = true,
                                 default = nil)
  if valid_612383 != nil:
    section.add "streamId", valid_612383
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612384 = header.getOrDefault("X-Amz-Signature")
  valid_612384 = validateParameter(valid_612384, JString, required = false,
                                 default = nil)
  if valid_612384 != nil:
    section.add "X-Amz-Signature", valid_612384
  var valid_612385 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612385 = validateParameter(valid_612385, JString, required = false,
                                 default = nil)
  if valid_612385 != nil:
    section.add "X-Amz-Content-Sha256", valid_612385
  var valid_612386 = header.getOrDefault("X-Amz-Date")
  valid_612386 = validateParameter(valid_612386, JString, required = false,
                                 default = nil)
  if valid_612386 != nil:
    section.add "X-Amz-Date", valid_612386
  var valid_612387 = header.getOrDefault("X-Amz-Credential")
  valid_612387 = validateParameter(valid_612387, JString, required = false,
                                 default = nil)
  if valid_612387 != nil:
    section.add "X-Amz-Credential", valid_612387
  var valid_612388 = header.getOrDefault("X-Amz-Security-Token")
  valid_612388 = validateParameter(valid_612388, JString, required = false,
                                 default = nil)
  if valid_612388 != nil:
    section.add "X-Amz-Security-Token", valid_612388
  var valid_612389 = header.getOrDefault("X-Amz-Algorithm")
  valid_612389 = validateParameter(valid_612389, JString, required = false,
                                 default = nil)
  if valid_612389 != nil:
    section.add "X-Amz-Algorithm", valid_612389
  var valid_612390 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612390 = validateParameter(valid_612390, JString, required = false,
                                 default = nil)
  if valid_612390 != nil:
    section.add "X-Amz-SignedHeaders", valid_612390
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612392: Call_CreateStream_612380; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.
  ## 
  let valid = call_612392.validator(path, query, header, formData, body)
  let scheme = call_612392.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612392.url(scheme.get, call_612392.host, call_612392.base,
                         call_612392.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612392, url, valid)

proc call*(call_612393: Call_CreateStream_612380; streamId: string; body: JsonNode): Recallable =
  ## createStream
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  ##   body: JObject (required)
  var path_612394 = newJObject()
  var body_612395 = newJObject()
  add(path_612394, "streamId", newJString(streamId))
  if body != nil:
    body_612395 = body
  result = call_612393.call(path_612394, nil, nil, nil, body_612395)

var createStream* = Call_CreateStream_612380(name: "createStream",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_CreateStream_612381,
    base: "/", url: url_CreateStream_612382, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeStream_612350 = ref object of OpenApiRestCall_610658
proc url_DescribeStream_612352(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeStream_612351(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets information about a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_612353 = path.getOrDefault("streamId")
  valid_612353 = validateParameter(valid_612353, JString, required = true,
                                 default = nil)
  if valid_612353 != nil:
    section.add "streamId", valid_612353
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612354 = header.getOrDefault("X-Amz-Signature")
  valid_612354 = validateParameter(valid_612354, JString, required = false,
                                 default = nil)
  if valid_612354 != nil:
    section.add "X-Amz-Signature", valid_612354
  var valid_612355 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612355 = validateParameter(valid_612355, JString, required = false,
                                 default = nil)
  if valid_612355 != nil:
    section.add "X-Amz-Content-Sha256", valid_612355
  var valid_612356 = header.getOrDefault("X-Amz-Date")
  valid_612356 = validateParameter(valid_612356, JString, required = false,
                                 default = nil)
  if valid_612356 != nil:
    section.add "X-Amz-Date", valid_612356
  var valid_612357 = header.getOrDefault("X-Amz-Credential")
  valid_612357 = validateParameter(valid_612357, JString, required = false,
                                 default = nil)
  if valid_612357 != nil:
    section.add "X-Amz-Credential", valid_612357
  var valid_612358 = header.getOrDefault("X-Amz-Security-Token")
  valid_612358 = validateParameter(valid_612358, JString, required = false,
                                 default = nil)
  if valid_612358 != nil:
    section.add "X-Amz-Security-Token", valid_612358
  var valid_612359 = header.getOrDefault("X-Amz-Algorithm")
  valid_612359 = validateParameter(valid_612359, JString, required = false,
                                 default = nil)
  if valid_612359 != nil:
    section.add "X-Amz-Algorithm", valid_612359
  var valid_612360 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612360 = validateParameter(valid_612360, JString, required = false,
                                 default = nil)
  if valid_612360 != nil:
    section.add "X-Amz-SignedHeaders", valid_612360
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612361: Call_DescribeStream_612350; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a stream.
  ## 
  let valid = call_612361.validator(path, query, header, formData, body)
  let scheme = call_612361.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612361.url(scheme.get, call_612361.host, call_612361.base,
                         call_612361.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612361, url, valid)

proc call*(call_612362: Call_DescribeStream_612350; streamId: string): Recallable =
  ## describeStream
  ## Gets information about a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_612363 = newJObject()
  add(path_612363, "streamId", newJString(streamId))
  result = call_612362.call(path_612363, nil, nil, nil, nil)

var describeStream* = Call_DescribeStream_612350(name: "describeStream",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_DescribeStream_612351,
    base: "/", url: url_DescribeStream_612352, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteStream_612396 = ref object of OpenApiRestCall_610658
proc url_DeleteStream_612398(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteStream_612397(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_612399 = path.getOrDefault("streamId")
  valid_612399 = validateParameter(valid_612399, JString, required = true,
                                 default = nil)
  if valid_612399 != nil:
    section.add "streamId", valid_612399
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612400 = header.getOrDefault("X-Amz-Signature")
  valid_612400 = validateParameter(valid_612400, JString, required = false,
                                 default = nil)
  if valid_612400 != nil:
    section.add "X-Amz-Signature", valid_612400
  var valid_612401 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612401 = validateParameter(valid_612401, JString, required = false,
                                 default = nil)
  if valid_612401 != nil:
    section.add "X-Amz-Content-Sha256", valid_612401
  var valid_612402 = header.getOrDefault("X-Amz-Date")
  valid_612402 = validateParameter(valid_612402, JString, required = false,
                                 default = nil)
  if valid_612402 != nil:
    section.add "X-Amz-Date", valid_612402
  var valid_612403 = header.getOrDefault("X-Amz-Credential")
  valid_612403 = validateParameter(valid_612403, JString, required = false,
                                 default = nil)
  if valid_612403 != nil:
    section.add "X-Amz-Credential", valid_612403
  var valid_612404 = header.getOrDefault("X-Amz-Security-Token")
  valid_612404 = validateParameter(valid_612404, JString, required = false,
                                 default = nil)
  if valid_612404 != nil:
    section.add "X-Amz-Security-Token", valid_612404
  var valid_612405 = header.getOrDefault("X-Amz-Algorithm")
  valid_612405 = validateParameter(valid_612405, JString, required = false,
                                 default = nil)
  if valid_612405 != nil:
    section.add "X-Amz-Algorithm", valid_612405
  var valid_612406 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612406 = validateParameter(valid_612406, JString, required = false,
                                 default = nil)
  if valid_612406 != nil:
    section.add "X-Amz-SignedHeaders", valid_612406
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612407: Call_DeleteStream_612396; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a stream.
  ## 
  let valid = call_612407.validator(path, query, header, formData, body)
  let scheme = call_612407.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612407.url(scheme.get, call_612407.host, call_612407.base,
                         call_612407.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612407, url, valid)

proc call*(call_612408: Call_DeleteStream_612396; streamId: string): Recallable =
  ## deleteStream
  ## Deletes a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_612409 = newJObject()
  add(path_612409, "streamId", newJString(streamId))
  result = call_612408.call(path_612409, nil, nil, nil, nil)

var deleteStream* = Call_DeleteStream_612396(name: "deleteStream",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_DeleteStream_612397,
    base: "/", url: url_DeleteStream_612398, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThing_612424 = ref object of OpenApiRestCall_610658
proc url_CreateThing_612426(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateThing_612425(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to create.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_612427 = path.getOrDefault("thingName")
  valid_612427 = validateParameter(valid_612427, JString, required = true,
                                 default = nil)
  if valid_612427 != nil:
    section.add "thingName", valid_612427
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612428 = header.getOrDefault("X-Amz-Signature")
  valid_612428 = validateParameter(valid_612428, JString, required = false,
                                 default = nil)
  if valid_612428 != nil:
    section.add "X-Amz-Signature", valid_612428
  var valid_612429 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612429 = validateParameter(valid_612429, JString, required = false,
                                 default = nil)
  if valid_612429 != nil:
    section.add "X-Amz-Content-Sha256", valid_612429
  var valid_612430 = header.getOrDefault("X-Amz-Date")
  valid_612430 = validateParameter(valid_612430, JString, required = false,
                                 default = nil)
  if valid_612430 != nil:
    section.add "X-Amz-Date", valid_612430
  var valid_612431 = header.getOrDefault("X-Amz-Credential")
  valid_612431 = validateParameter(valid_612431, JString, required = false,
                                 default = nil)
  if valid_612431 != nil:
    section.add "X-Amz-Credential", valid_612431
  var valid_612432 = header.getOrDefault("X-Amz-Security-Token")
  valid_612432 = validateParameter(valid_612432, JString, required = false,
                                 default = nil)
  if valid_612432 != nil:
    section.add "X-Amz-Security-Token", valid_612432
  var valid_612433 = header.getOrDefault("X-Amz-Algorithm")
  valid_612433 = validateParameter(valid_612433, JString, required = false,
                                 default = nil)
  if valid_612433 != nil:
    section.add "X-Amz-Algorithm", valid_612433
  var valid_612434 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612434 = validateParameter(valid_612434, JString, required = false,
                                 default = nil)
  if valid_612434 != nil:
    section.add "X-Amz-SignedHeaders", valid_612434
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612436: Call_CreateThing_612424; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  let valid = call_612436.validator(path, query, header, formData, body)
  let scheme = call_612436.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612436.url(scheme.get, call_612436.host, call_612436.base,
                         call_612436.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612436, url, valid)

proc call*(call_612437: Call_CreateThing_612424; thingName: string; body: JsonNode): Recallable =
  ## createThing
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing to create.
  ##   body: JObject (required)
  var path_612438 = newJObject()
  var body_612439 = newJObject()
  add(path_612438, "thingName", newJString(thingName))
  if body != nil:
    body_612439 = body
  result = call_612437.call(path_612438, nil, nil, nil, body_612439)

var createThing* = Call_CreateThing_612424(name: "createThing",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_CreateThing_612425,
                                        base: "/", url: url_CreateThing_612426,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThing_612410 = ref object of OpenApiRestCall_610658
proc url_DescribeThing_612412(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThing_612411(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the specified thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_612413 = path.getOrDefault("thingName")
  valid_612413 = validateParameter(valid_612413, JString, required = true,
                                 default = nil)
  if valid_612413 != nil:
    section.add "thingName", valid_612413
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612414 = header.getOrDefault("X-Amz-Signature")
  valid_612414 = validateParameter(valid_612414, JString, required = false,
                                 default = nil)
  if valid_612414 != nil:
    section.add "X-Amz-Signature", valid_612414
  var valid_612415 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612415 = validateParameter(valid_612415, JString, required = false,
                                 default = nil)
  if valid_612415 != nil:
    section.add "X-Amz-Content-Sha256", valid_612415
  var valid_612416 = header.getOrDefault("X-Amz-Date")
  valid_612416 = validateParameter(valid_612416, JString, required = false,
                                 default = nil)
  if valid_612416 != nil:
    section.add "X-Amz-Date", valid_612416
  var valid_612417 = header.getOrDefault("X-Amz-Credential")
  valid_612417 = validateParameter(valid_612417, JString, required = false,
                                 default = nil)
  if valid_612417 != nil:
    section.add "X-Amz-Credential", valid_612417
  var valid_612418 = header.getOrDefault("X-Amz-Security-Token")
  valid_612418 = validateParameter(valid_612418, JString, required = false,
                                 default = nil)
  if valid_612418 != nil:
    section.add "X-Amz-Security-Token", valid_612418
  var valid_612419 = header.getOrDefault("X-Amz-Algorithm")
  valid_612419 = validateParameter(valid_612419, JString, required = false,
                                 default = nil)
  if valid_612419 != nil:
    section.add "X-Amz-Algorithm", valid_612419
  var valid_612420 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612420 = validateParameter(valid_612420, JString, required = false,
                                 default = nil)
  if valid_612420 != nil:
    section.add "X-Amz-SignedHeaders", valid_612420
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612421: Call_DescribeThing_612410; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified thing.
  ## 
  let valid = call_612421.validator(path, query, header, formData, body)
  let scheme = call_612421.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612421.url(scheme.get, call_612421.host, call_612421.base,
                         call_612421.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612421, url, valid)

proc call*(call_612422: Call_DescribeThing_612410; thingName: string): Recallable =
  ## describeThing
  ## Gets information about the specified thing.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_612423 = newJObject()
  add(path_612423, "thingName", newJString(thingName))
  result = call_612422.call(path_612423, nil, nil, nil, nil)

var describeThing* = Call_DescribeThing_612410(name: "describeThing",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/things/{thingName}", validator: validate_DescribeThing_612411,
    base: "/", url: url_DescribeThing_612412, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThing_612456 = ref object of OpenApiRestCall_610658
proc url_UpdateThing_612458(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateThing_612457(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the data for a thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_612459 = path.getOrDefault("thingName")
  valid_612459 = validateParameter(valid_612459, JString, required = true,
                                 default = nil)
  if valid_612459 != nil:
    section.add "thingName", valid_612459
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612460 = header.getOrDefault("X-Amz-Signature")
  valid_612460 = validateParameter(valid_612460, JString, required = false,
                                 default = nil)
  if valid_612460 != nil:
    section.add "X-Amz-Signature", valid_612460
  var valid_612461 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612461 = validateParameter(valid_612461, JString, required = false,
                                 default = nil)
  if valid_612461 != nil:
    section.add "X-Amz-Content-Sha256", valid_612461
  var valid_612462 = header.getOrDefault("X-Amz-Date")
  valid_612462 = validateParameter(valid_612462, JString, required = false,
                                 default = nil)
  if valid_612462 != nil:
    section.add "X-Amz-Date", valid_612462
  var valid_612463 = header.getOrDefault("X-Amz-Credential")
  valid_612463 = validateParameter(valid_612463, JString, required = false,
                                 default = nil)
  if valid_612463 != nil:
    section.add "X-Amz-Credential", valid_612463
  var valid_612464 = header.getOrDefault("X-Amz-Security-Token")
  valid_612464 = validateParameter(valid_612464, JString, required = false,
                                 default = nil)
  if valid_612464 != nil:
    section.add "X-Amz-Security-Token", valid_612464
  var valid_612465 = header.getOrDefault("X-Amz-Algorithm")
  valid_612465 = validateParameter(valid_612465, JString, required = false,
                                 default = nil)
  if valid_612465 != nil:
    section.add "X-Amz-Algorithm", valid_612465
  var valid_612466 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612466 = validateParameter(valid_612466, JString, required = false,
                                 default = nil)
  if valid_612466 != nil:
    section.add "X-Amz-SignedHeaders", valid_612466
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612468: Call_UpdateThing_612456; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the data for a thing.
  ## 
  let valid = call_612468.validator(path, query, header, formData, body)
  let scheme = call_612468.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612468.url(scheme.get, call_612468.host, call_612468.base,
                         call_612468.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612468, url, valid)

proc call*(call_612469: Call_UpdateThing_612456; thingName: string; body: JsonNode): Recallable =
  ## updateThing
  ## Updates the data for a thing.
  ##   thingName: string (required)
  ##            : The name of the thing to update.
  ##   body: JObject (required)
  var path_612470 = newJObject()
  var body_612471 = newJObject()
  add(path_612470, "thingName", newJString(thingName))
  if body != nil:
    body_612471 = body
  result = call_612469.call(path_612470, nil, nil, nil, body_612471)

var updateThing* = Call_UpdateThing_612456(name: "updateThing",
                                        meth: HttpMethod.HttpPatch,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_UpdateThing_612457,
                                        base: "/", url: url_UpdateThing_612458,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThing_612440 = ref object of OpenApiRestCall_610658
proc url_DeleteThing_612442(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteThing_612441(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_612443 = path.getOrDefault("thingName")
  valid_612443 = validateParameter(valid_612443, JString, required = true,
                                 default = nil)
  if valid_612443 != nil:
    section.add "thingName", valid_612443
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.
  section = newJObject()
  var valid_612444 = query.getOrDefault("expectedVersion")
  valid_612444 = validateParameter(valid_612444, JInt, required = false, default = nil)
  if valid_612444 != nil:
    section.add "expectedVersion", valid_612444
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612445 = header.getOrDefault("X-Amz-Signature")
  valid_612445 = validateParameter(valid_612445, JString, required = false,
                                 default = nil)
  if valid_612445 != nil:
    section.add "X-Amz-Signature", valid_612445
  var valid_612446 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612446 = validateParameter(valid_612446, JString, required = false,
                                 default = nil)
  if valid_612446 != nil:
    section.add "X-Amz-Content-Sha256", valid_612446
  var valid_612447 = header.getOrDefault("X-Amz-Date")
  valid_612447 = validateParameter(valid_612447, JString, required = false,
                                 default = nil)
  if valid_612447 != nil:
    section.add "X-Amz-Date", valid_612447
  var valid_612448 = header.getOrDefault("X-Amz-Credential")
  valid_612448 = validateParameter(valid_612448, JString, required = false,
                                 default = nil)
  if valid_612448 != nil:
    section.add "X-Amz-Credential", valid_612448
  var valid_612449 = header.getOrDefault("X-Amz-Security-Token")
  valid_612449 = validateParameter(valid_612449, JString, required = false,
                                 default = nil)
  if valid_612449 != nil:
    section.add "X-Amz-Security-Token", valid_612449
  var valid_612450 = header.getOrDefault("X-Amz-Algorithm")
  valid_612450 = validateParameter(valid_612450, JString, required = false,
                                 default = nil)
  if valid_612450 != nil:
    section.add "X-Amz-Algorithm", valid_612450
  var valid_612451 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612451 = validateParameter(valid_612451, JString, required = false,
                                 default = nil)
  if valid_612451 != nil:
    section.add "X-Amz-SignedHeaders", valid_612451
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612452: Call_DeleteThing_612440; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ## 
  let valid = call_612452.validator(path, query, header, formData, body)
  let scheme = call_612452.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612452.url(scheme.get, call_612452.host, call_612452.base,
                         call_612452.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612452, url, valid)

proc call*(call_612453: Call_DeleteThing_612440; thingName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteThing
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ##   expectedVersion: int
  ##                  : The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.
  ##   thingName: string (required)
  ##            : The name of the thing to delete.
  var path_612454 = newJObject()
  var query_612455 = newJObject()
  add(query_612455, "expectedVersion", newJInt(expectedVersion))
  add(path_612454, "thingName", newJString(thingName))
  result = call_612453.call(path_612454, query_612455, nil, nil, nil)

var deleteThing* = Call_DeleteThing_612440(name: "deleteThing",
                                        meth: HttpMethod.HttpDelete,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_DeleteThing_612441,
                                        base: "/", url: url_DeleteThing_612442,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThingGroup_612486 = ref object of OpenApiRestCall_610658
proc url_CreateThingGroup_612488(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateThingGroup_612487(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group name to create.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_612489 = path.getOrDefault("thingGroupName")
  valid_612489 = validateParameter(valid_612489, JString, required = true,
                                 default = nil)
  if valid_612489 != nil:
    section.add "thingGroupName", valid_612489
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612490 = header.getOrDefault("X-Amz-Signature")
  valid_612490 = validateParameter(valid_612490, JString, required = false,
                                 default = nil)
  if valid_612490 != nil:
    section.add "X-Amz-Signature", valid_612490
  var valid_612491 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612491 = validateParameter(valid_612491, JString, required = false,
                                 default = nil)
  if valid_612491 != nil:
    section.add "X-Amz-Content-Sha256", valid_612491
  var valid_612492 = header.getOrDefault("X-Amz-Date")
  valid_612492 = validateParameter(valid_612492, JString, required = false,
                                 default = nil)
  if valid_612492 != nil:
    section.add "X-Amz-Date", valid_612492
  var valid_612493 = header.getOrDefault("X-Amz-Credential")
  valid_612493 = validateParameter(valid_612493, JString, required = false,
                                 default = nil)
  if valid_612493 != nil:
    section.add "X-Amz-Credential", valid_612493
  var valid_612494 = header.getOrDefault("X-Amz-Security-Token")
  valid_612494 = validateParameter(valid_612494, JString, required = false,
                                 default = nil)
  if valid_612494 != nil:
    section.add "X-Amz-Security-Token", valid_612494
  var valid_612495 = header.getOrDefault("X-Amz-Algorithm")
  valid_612495 = validateParameter(valid_612495, JString, required = false,
                                 default = nil)
  if valid_612495 != nil:
    section.add "X-Amz-Algorithm", valid_612495
  var valid_612496 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612496 = validateParameter(valid_612496, JString, required = false,
                                 default = nil)
  if valid_612496 != nil:
    section.add "X-Amz-SignedHeaders", valid_612496
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612498: Call_CreateThingGroup_612486; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  let valid = call_612498.validator(path, query, header, formData, body)
  let scheme = call_612498.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612498.url(scheme.get, call_612498.host, call_612498.base,
                         call_612498.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612498, url, valid)

proc call*(call_612499: Call_CreateThingGroup_612486; thingGroupName: string;
          body: JsonNode): Recallable =
  ## createThingGroup
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ##   thingGroupName: string (required)
  ##                 : The thing group name to create.
  ##   body: JObject (required)
  var path_612500 = newJObject()
  var body_612501 = newJObject()
  add(path_612500, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_612501 = body
  result = call_612499.call(path_612500, nil, nil, nil, body_612501)

var createThingGroup* = Call_CreateThingGroup_612486(name: "createThingGroup",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_CreateThingGroup_612487,
    base: "/", url: url_CreateThingGroup_612488,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingGroup_612472 = ref object of OpenApiRestCall_610658
proc url_DescribeThingGroup_612474(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThingGroup_612473(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Describe a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the thing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_612475 = path.getOrDefault("thingGroupName")
  valid_612475 = validateParameter(valid_612475, JString, required = true,
                                 default = nil)
  if valid_612475 != nil:
    section.add "thingGroupName", valid_612475
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612476 = header.getOrDefault("X-Amz-Signature")
  valid_612476 = validateParameter(valid_612476, JString, required = false,
                                 default = nil)
  if valid_612476 != nil:
    section.add "X-Amz-Signature", valid_612476
  var valid_612477 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612477 = validateParameter(valid_612477, JString, required = false,
                                 default = nil)
  if valid_612477 != nil:
    section.add "X-Amz-Content-Sha256", valid_612477
  var valid_612478 = header.getOrDefault("X-Amz-Date")
  valid_612478 = validateParameter(valid_612478, JString, required = false,
                                 default = nil)
  if valid_612478 != nil:
    section.add "X-Amz-Date", valid_612478
  var valid_612479 = header.getOrDefault("X-Amz-Credential")
  valid_612479 = validateParameter(valid_612479, JString, required = false,
                                 default = nil)
  if valid_612479 != nil:
    section.add "X-Amz-Credential", valid_612479
  var valid_612480 = header.getOrDefault("X-Amz-Security-Token")
  valid_612480 = validateParameter(valid_612480, JString, required = false,
                                 default = nil)
  if valid_612480 != nil:
    section.add "X-Amz-Security-Token", valid_612480
  var valid_612481 = header.getOrDefault("X-Amz-Algorithm")
  valid_612481 = validateParameter(valid_612481, JString, required = false,
                                 default = nil)
  if valid_612481 != nil:
    section.add "X-Amz-Algorithm", valid_612481
  var valid_612482 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612482 = validateParameter(valid_612482, JString, required = false,
                                 default = nil)
  if valid_612482 != nil:
    section.add "X-Amz-SignedHeaders", valid_612482
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612483: Call_DescribeThingGroup_612472; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describe a thing group.
  ## 
  let valid = call_612483.validator(path, query, header, formData, body)
  let scheme = call_612483.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612483.url(scheme.get, call_612483.host, call_612483.base,
                         call_612483.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612483, url, valid)

proc call*(call_612484: Call_DescribeThingGroup_612472; thingGroupName: string): Recallable =
  ## describeThingGroup
  ## Describe a thing group.
  ##   thingGroupName: string (required)
  ##                 : The name of the thing group.
  var path_612485 = newJObject()
  add(path_612485, "thingGroupName", newJString(thingGroupName))
  result = call_612484.call(path_612485, nil, nil, nil, nil)

var describeThingGroup* = Call_DescribeThingGroup_612472(
    name: "describeThingGroup", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}",
    validator: validate_DescribeThingGroup_612473, base: "/",
    url: url_DescribeThingGroup_612474, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThingGroup_612518 = ref object of OpenApiRestCall_610658
proc url_UpdateThingGroup_612520(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateThingGroup_612519(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Update a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group to update.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_612521 = path.getOrDefault("thingGroupName")
  valid_612521 = validateParameter(valid_612521, JString, required = true,
                                 default = nil)
  if valid_612521 != nil:
    section.add "thingGroupName", valid_612521
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612522 = header.getOrDefault("X-Amz-Signature")
  valid_612522 = validateParameter(valid_612522, JString, required = false,
                                 default = nil)
  if valid_612522 != nil:
    section.add "X-Amz-Signature", valid_612522
  var valid_612523 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612523 = validateParameter(valid_612523, JString, required = false,
                                 default = nil)
  if valid_612523 != nil:
    section.add "X-Amz-Content-Sha256", valid_612523
  var valid_612524 = header.getOrDefault("X-Amz-Date")
  valid_612524 = validateParameter(valid_612524, JString, required = false,
                                 default = nil)
  if valid_612524 != nil:
    section.add "X-Amz-Date", valid_612524
  var valid_612525 = header.getOrDefault("X-Amz-Credential")
  valid_612525 = validateParameter(valid_612525, JString, required = false,
                                 default = nil)
  if valid_612525 != nil:
    section.add "X-Amz-Credential", valid_612525
  var valid_612526 = header.getOrDefault("X-Amz-Security-Token")
  valid_612526 = validateParameter(valid_612526, JString, required = false,
                                 default = nil)
  if valid_612526 != nil:
    section.add "X-Amz-Security-Token", valid_612526
  var valid_612527 = header.getOrDefault("X-Amz-Algorithm")
  valid_612527 = validateParameter(valid_612527, JString, required = false,
                                 default = nil)
  if valid_612527 != nil:
    section.add "X-Amz-Algorithm", valid_612527
  var valid_612528 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612528 = validateParameter(valid_612528, JString, required = false,
                                 default = nil)
  if valid_612528 != nil:
    section.add "X-Amz-SignedHeaders", valid_612528
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612530: Call_UpdateThingGroup_612518; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update a thing group.
  ## 
  let valid = call_612530.validator(path, query, header, formData, body)
  let scheme = call_612530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612530.url(scheme.get, call_612530.host, call_612530.base,
                         call_612530.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612530, url, valid)

proc call*(call_612531: Call_UpdateThingGroup_612518; thingGroupName: string;
          body: JsonNode): Recallable =
  ## updateThingGroup
  ## Update a thing group.
  ##   thingGroupName: string (required)
  ##                 : The thing group to update.
  ##   body: JObject (required)
  var path_612532 = newJObject()
  var body_612533 = newJObject()
  add(path_612532, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_612533 = body
  result = call_612531.call(path_612532, nil, nil, nil, body_612533)

var updateThingGroup* = Call_UpdateThingGroup_612518(name: "updateThingGroup",
    meth: HttpMethod.HttpPatch, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_UpdateThingGroup_612519,
    base: "/", url: url_UpdateThingGroup_612520,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThingGroup_612502 = ref object of OpenApiRestCall_610658
proc url_DeleteThingGroup_612504(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteThingGroup_612503(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Deletes a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the thing group to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_612505 = path.getOrDefault("thingGroupName")
  valid_612505 = validateParameter(valid_612505, JString, required = true,
                                 default = nil)
  if valid_612505 != nil:
    section.add "thingGroupName", valid_612505
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the thing group to delete.
  section = newJObject()
  var valid_612506 = query.getOrDefault("expectedVersion")
  valid_612506 = validateParameter(valid_612506, JInt, required = false, default = nil)
  if valid_612506 != nil:
    section.add "expectedVersion", valid_612506
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612507 = header.getOrDefault("X-Amz-Signature")
  valid_612507 = validateParameter(valid_612507, JString, required = false,
                                 default = nil)
  if valid_612507 != nil:
    section.add "X-Amz-Signature", valid_612507
  var valid_612508 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612508 = validateParameter(valid_612508, JString, required = false,
                                 default = nil)
  if valid_612508 != nil:
    section.add "X-Amz-Content-Sha256", valid_612508
  var valid_612509 = header.getOrDefault("X-Amz-Date")
  valid_612509 = validateParameter(valid_612509, JString, required = false,
                                 default = nil)
  if valid_612509 != nil:
    section.add "X-Amz-Date", valid_612509
  var valid_612510 = header.getOrDefault("X-Amz-Credential")
  valid_612510 = validateParameter(valid_612510, JString, required = false,
                                 default = nil)
  if valid_612510 != nil:
    section.add "X-Amz-Credential", valid_612510
  var valid_612511 = header.getOrDefault("X-Amz-Security-Token")
  valid_612511 = validateParameter(valid_612511, JString, required = false,
                                 default = nil)
  if valid_612511 != nil:
    section.add "X-Amz-Security-Token", valid_612511
  var valid_612512 = header.getOrDefault("X-Amz-Algorithm")
  valid_612512 = validateParameter(valid_612512, JString, required = false,
                                 default = nil)
  if valid_612512 != nil:
    section.add "X-Amz-Algorithm", valid_612512
  var valid_612513 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612513 = validateParameter(valid_612513, JString, required = false,
                                 default = nil)
  if valid_612513 != nil:
    section.add "X-Amz-SignedHeaders", valid_612513
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612514: Call_DeleteThingGroup_612502; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a thing group.
  ## 
  let valid = call_612514.validator(path, query, header, formData, body)
  let scheme = call_612514.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612514.url(scheme.get, call_612514.host, call_612514.base,
                         call_612514.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612514, url, valid)

proc call*(call_612515: Call_DeleteThingGroup_612502; thingGroupName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteThingGroup
  ## Deletes a thing group.
  ##   expectedVersion: int
  ##                  : The expected version of the thing group to delete.
  ##   thingGroupName: string (required)
  ##                 : The name of the thing group to delete.
  var path_612516 = newJObject()
  var query_612517 = newJObject()
  add(query_612517, "expectedVersion", newJInt(expectedVersion))
  add(path_612516, "thingGroupName", newJString(thingGroupName))
  result = call_612515.call(path_612516, query_612517, nil, nil, nil)

var deleteThingGroup* = Call_DeleteThingGroup_612502(name: "deleteThingGroup",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_DeleteThingGroup_612503,
    base: "/", url: url_DeleteThingGroup_612504,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThingType_612548 = ref object of OpenApiRestCall_610658
proc url_CreateThingType_612550(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateThingType_612549(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a new thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_612551 = path.getOrDefault("thingTypeName")
  valid_612551 = validateParameter(valid_612551, JString, required = true,
                                 default = nil)
  if valid_612551 != nil:
    section.add "thingTypeName", valid_612551
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612552 = header.getOrDefault("X-Amz-Signature")
  valid_612552 = validateParameter(valid_612552, JString, required = false,
                                 default = nil)
  if valid_612552 != nil:
    section.add "X-Amz-Signature", valid_612552
  var valid_612553 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612553 = validateParameter(valid_612553, JString, required = false,
                                 default = nil)
  if valid_612553 != nil:
    section.add "X-Amz-Content-Sha256", valid_612553
  var valid_612554 = header.getOrDefault("X-Amz-Date")
  valid_612554 = validateParameter(valid_612554, JString, required = false,
                                 default = nil)
  if valid_612554 != nil:
    section.add "X-Amz-Date", valid_612554
  var valid_612555 = header.getOrDefault("X-Amz-Credential")
  valid_612555 = validateParameter(valid_612555, JString, required = false,
                                 default = nil)
  if valid_612555 != nil:
    section.add "X-Amz-Credential", valid_612555
  var valid_612556 = header.getOrDefault("X-Amz-Security-Token")
  valid_612556 = validateParameter(valid_612556, JString, required = false,
                                 default = nil)
  if valid_612556 != nil:
    section.add "X-Amz-Security-Token", valid_612556
  var valid_612557 = header.getOrDefault("X-Amz-Algorithm")
  valid_612557 = validateParameter(valid_612557, JString, required = false,
                                 default = nil)
  if valid_612557 != nil:
    section.add "X-Amz-Algorithm", valid_612557
  var valid_612558 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612558 = validateParameter(valid_612558, JString, required = false,
                                 default = nil)
  if valid_612558 != nil:
    section.add "X-Amz-SignedHeaders", valid_612558
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612560: Call_CreateThingType_612548; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new thing type.
  ## 
  let valid = call_612560.validator(path, query, header, formData, body)
  let scheme = call_612560.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612560.url(scheme.get, call_612560.host, call_612560.base,
                         call_612560.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612560, url, valid)

proc call*(call_612561: Call_CreateThingType_612548; thingTypeName: string;
          body: JsonNode): Recallable =
  ## createThingType
  ## Creates a new thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  ##   body: JObject (required)
  var path_612562 = newJObject()
  var body_612563 = newJObject()
  add(path_612562, "thingTypeName", newJString(thingTypeName))
  if body != nil:
    body_612563 = body
  result = call_612561.call(path_612562, nil, nil, nil, body_612563)

var createThingType* = Call_CreateThingType_612548(name: "createThingType",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_CreateThingType_612549,
    base: "/", url: url_CreateThingType_612550, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingType_612534 = ref object of OpenApiRestCall_610658
proc url_DescribeThingType_612536(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThingType_612535(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Gets information about the specified thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_612537 = path.getOrDefault("thingTypeName")
  valid_612537 = validateParameter(valid_612537, JString, required = true,
                                 default = nil)
  if valid_612537 != nil:
    section.add "thingTypeName", valid_612537
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612538 = header.getOrDefault("X-Amz-Signature")
  valid_612538 = validateParameter(valid_612538, JString, required = false,
                                 default = nil)
  if valid_612538 != nil:
    section.add "X-Amz-Signature", valid_612538
  var valid_612539 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612539 = validateParameter(valid_612539, JString, required = false,
                                 default = nil)
  if valid_612539 != nil:
    section.add "X-Amz-Content-Sha256", valid_612539
  var valid_612540 = header.getOrDefault("X-Amz-Date")
  valid_612540 = validateParameter(valid_612540, JString, required = false,
                                 default = nil)
  if valid_612540 != nil:
    section.add "X-Amz-Date", valid_612540
  var valid_612541 = header.getOrDefault("X-Amz-Credential")
  valid_612541 = validateParameter(valid_612541, JString, required = false,
                                 default = nil)
  if valid_612541 != nil:
    section.add "X-Amz-Credential", valid_612541
  var valid_612542 = header.getOrDefault("X-Amz-Security-Token")
  valid_612542 = validateParameter(valid_612542, JString, required = false,
                                 default = nil)
  if valid_612542 != nil:
    section.add "X-Amz-Security-Token", valid_612542
  var valid_612543 = header.getOrDefault("X-Amz-Algorithm")
  valid_612543 = validateParameter(valid_612543, JString, required = false,
                                 default = nil)
  if valid_612543 != nil:
    section.add "X-Amz-Algorithm", valid_612543
  var valid_612544 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612544 = validateParameter(valid_612544, JString, required = false,
                                 default = nil)
  if valid_612544 != nil:
    section.add "X-Amz-SignedHeaders", valid_612544
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612545: Call_DescribeThingType_612534; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified thing type.
  ## 
  let valid = call_612545.validator(path, query, header, formData, body)
  let scheme = call_612545.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612545.url(scheme.get, call_612545.host, call_612545.base,
                         call_612545.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612545, url, valid)

proc call*(call_612546: Call_DescribeThingType_612534; thingTypeName: string): Recallable =
  ## describeThingType
  ## Gets information about the specified thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_612547 = newJObject()
  add(path_612547, "thingTypeName", newJString(thingTypeName))
  result = call_612546.call(path_612547, nil, nil, nil, nil)

var describeThingType* = Call_DescribeThingType_612534(name: "describeThingType",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_DescribeThingType_612535,
    base: "/", url: url_DescribeThingType_612536,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThingType_612564 = ref object of OpenApiRestCall_610658
proc url_DeleteThingType_612566(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteThingType_612565(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_612567 = path.getOrDefault("thingTypeName")
  valid_612567 = validateParameter(valid_612567, JString, required = true,
                                 default = nil)
  if valid_612567 != nil:
    section.add "thingTypeName", valid_612567
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612568 = header.getOrDefault("X-Amz-Signature")
  valid_612568 = validateParameter(valid_612568, JString, required = false,
                                 default = nil)
  if valid_612568 != nil:
    section.add "X-Amz-Signature", valid_612568
  var valid_612569 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612569 = validateParameter(valid_612569, JString, required = false,
                                 default = nil)
  if valid_612569 != nil:
    section.add "X-Amz-Content-Sha256", valid_612569
  var valid_612570 = header.getOrDefault("X-Amz-Date")
  valid_612570 = validateParameter(valid_612570, JString, required = false,
                                 default = nil)
  if valid_612570 != nil:
    section.add "X-Amz-Date", valid_612570
  var valid_612571 = header.getOrDefault("X-Amz-Credential")
  valid_612571 = validateParameter(valid_612571, JString, required = false,
                                 default = nil)
  if valid_612571 != nil:
    section.add "X-Amz-Credential", valid_612571
  var valid_612572 = header.getOrDefault("X-Amz-Security-Token")
  valid_612572 = validateParameter(valid_612572, JString, required = false,
                                 default = nil)
  if valid_612572 != nil:
    section.add "X-Amz-Security-Token", valid_612572
  var valid_612573 = header.getOrDefault("X-Amz-Algorithm")
  valid_612573 = validateParameter(valid_612573, JString, required = false,
                                 default = nil)
  if valid_612573 != nil:
    section.add "X-Amz-Algorithm", valid_612573
  var valid_612574 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612574 = validateParameter(valid_612574, JString, required = false,
                                 default = nil)
  if valid_612574 != nil:
    section.add "X-Amz-SignedHeaders", valid_612574
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612575: Call_DeleteThingType_612564; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ## 
  let valid = call_612575.validator(path, query, header, formData, body)
  let scheme = call_612575.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612575.url(scheme.get, call_612575.host, call_612575.base,
                         call_612575.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612575, url, valid)

proc call*(call_612576: Call_DeleteThingType_612564; thingTypeName: string): Recallable =
  ## deleteThingType
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_612577 = newJObject()
  add(path_612577, "thingTypeName", newJString(thingTypeName))
  result = call_612576.call(path_612577, nil, nil, nil, nil)

var deleteThingType* = Call_DeleteThingType_612564(name: "deleteThingType",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_DeleteThingType_612565,
    base: "/", url: url_DeleteThingType_612566, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateTopicRule_612592 = ref object of OpenApiRestCall_610658
proc url_CreateTopicRule_612594(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateTopicRule_612593(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_612595 = path.getOrDefault("ruleName")
  valid_612595 = validateParameter(valid_612595, JString, required = true,
                                 default = nil)
  if valid_612595 != nil:
    section.add "ruleName", valid_612595
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   x-amz-tagging: JString
  ##                : <p>Metadata which can be used to manage the topic rule.</p> <note> <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p> <p>For the CLI command-line parameter use format: --tags "key1=value1&amp;key2=value2..."</p> <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p> </note>
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612596 = header.getOrDefault("x-amz-tagging")
  valid_612596 = validateParameter(valid_612596, JString, required = false,
                                 default = nil)
  if valid_612596 != nil:
    section.add "x-amz-tagging", valid_612596
  var valid_612597 = header.getOrDefault("X-Amz-Signature")
  valid_612597 = validateParameter(valid_612597, JString, required = false,
                                 default = nil)
  if valid_612597 != nil:
    section.add "X-Amz-Signature", valid_612597
  var valid_612598 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612598 = validateParameter(valid_612598, JString, required = false,
                                 default = nil)
  if valid_612598 != nil:
    section.add "X-Amz-Content-Sha256", valid_612598
  var valid_612599 = header.getOrDefault("X-Amz-Date")
  valid_612599 = validateParameter(valid_612599, JString, required = false,
                                 default = nil)
  if valid_612599 != nil:
    section.add "X-Amz-Date", valid_612599
  var valid_612600 = header.getOrDefault("X-Amz-Credential")
  valid_612600 = validateParameter(valid_612600, JString, required = false,
                                 default = nil)
  if valid_612600 != nil:
    section.add "X-Amz-Credential", valid_612600
  var valid_612601 = header.getOrDefault("X-Amz-Security-Token")
  valid_612601 = validateParameter(valid_612601, JString, required = false,
                                 default = nil)
  if valid_612601 != nil:
    section.add "X-Amz-Security-Token", valid_612601
  var valid_612602 = header.getOrDefault("X-Amz-Algorithm")
  valid_612602 = validateParameter(valid_612602, JString, required = false,
                                 default = nil)
  if valid_612602 != nil:
    section.add "X-Amz-Algorithm", valid_612602
  var valid_612603 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612603 = validateParameter(valid_612603, JString, required = false,
                                 default = nil)
  if valid_612603 != nil:
    section.add "X-Amz-SignedHeaders", valid_612603
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612605: Call_CreateTopicRule_612592; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  let valid = call_612605.validator(path, query, header, formData, body)
  let scheme = call_612605.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612605.url(scheme.get, call_612605.host, call_612605.base,
                         call_612605.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612605, url, valid)

proc call*(call_612606: Call_CreateTopicRule_612592; ruleName: string; body: JsonNode): Recallable =
  ## createTopicRule
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  ##   body: JObject (required)
  var path_612607 = newJObject()
  var body_612608 = newJObject()
  add(path_612607, "ruleName", newJString(ruleName))
  if body != nil:
    body_612608 = body
  result = call_612606.call(path_612607, nil, nil, nil, body_612608)

var createTopicRule* = Call_CreateTopicRule_612592(name: "createTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_CreateTopicRule_612593,
    base: "/", url: url_CreateTopicRule_612594, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetTopicRule_612578 = ref object of OpenApiRestCall_610658
proc url_GetTopicRule_612580(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTopicRule_612579(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_612581 = path.getOrDefault("ruleName")
  valid_612581 = validateParameter(valid_612581, JString, required = true,
                                 default = nil)
  if valid_612581 != nil:
    section.add "ruleName", valid_612581
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612582 = header.getOrDefault("X-Amz-Signature")
  valid_612582 = validateParameter(valid_612582, JString, required = false,
                                 default = nil)
  if valid_612582 != nil:
    section.add "X-Amz-Signature", valid_612582
  var valid_612583 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612583 = validateParameter(valid_612583, JString, required = false,
                                 default = nil)
  if valid_612583 != nil:
    section.add "X-Amz-Content-Sha256", valid_612583
  var valid_612584 = header.getOrDefault("X-Amz-Date")
  valid_612584 = validateParameter(valid_612584, JString, required = false,
                                 default = nil)
  if valid_612584 != nil:
    section.add "X-Amz-Date", valid_612584
  var valid_612585 = header.getOrDefault("X-Amz-Credential")
  valid_612585 = validateParameter(valid_612585, JString, required = false,
                                 default = nil)
  if valid_612585 != nil:
    section.add "X-Amz-Credential", valid_612585
  var valid_612586 = header.getOrDefault("X-Amz-Security-Token")
  valid_612586 = validateParameter(valid_612586, JString, required = false,
                                 default = nil)
  if valid_612586 != nil:
    section.add "X-Amz-Security-Token", valid_612586
  var valid_612587 = header.getOrDefault("X-Amz-Algorithm")
  valid_612587 = validateParameter(valid_612587, JString, required = false,
                                 default = nil)
  if valid_612587 != nil:
    section.add "X-Amz-Algorithm", valid_612587
  var valid_612588 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612588 = validateParameter(valid_612588, JString, required = false,
                                 default = nil)
  if valid_612588 != nil:
    section.add "X-Amz-SignedHeaders", valid_612588
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612589: Call_GetTopicRule_612578; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the rule.
  ## 
  let valid = call_612589.validator(path, query, header, formData, body)
  let scheme = call_612589.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612589.url(scheme.get, call_612589.host, call_612589.base,
                         call_612589.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612589, url, valid)

proc call*(call_612590: Call_GetTopicRule_612578; ruleName: string): Recallable =
  ## getTopicRule
  ## Gets information about the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  var path_612591 = newJObject()
  add(path_612591, "ruleName", newJString(ruleName))
  result = call_612590.call(path_612591, nil, nil, nil, nil)

var getTopicRule* = Call_GetTopicRule_612578(name: "getTopicRule",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/rules/{ruleName}",
    validator: validate_GetTopicRule_612579, base: "/", url: url_GetTopicRule_612580,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReplaceTopicRule_612623 = ref object of OpenApiRestCall_610658
proc url_ReplaceTopicRule_612625(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ReplaceTopicRule_612624(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_612626 = path.getOrDefault("ruleName")
  valid_612626 = validateParameter(valid_612626, JString, required = true,
                                 default = nil)
  if valid_612626 != nil:
    section.add "ruleName", valid_612626
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612627 = header.getOrDefault("X-Amz-Signature")
  valid_612627 = validateParameter(valid_612627, JString, required = false,
                                 default = nil)
  if valid_612627 != nil:
    section.add "X-Amz-Signature", valid_612627
  var valid_612628 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612628 = validateParameter(valid_612628, JString, required = false,
                                 default = nil)
  if valid_612628 != nil:
    section.add "X-Amz-Content-Sha256", valid_612628
  var valid_612629 = header.getOrDefault("X-Amz-Date")
  valid_612629 = validateParameter(valid_612629, JString, required = false,
                                 default = nil)
  if valid_612629 != nil:
    section.add "X-Amz-Date", valid_612629
  var valid_612630 = header.getOrDefault("X-Amz-Credential")
  valid_612630 = validateParameter(valid_612630, JString, required = false,
                                 default = nil)
  if valid_612630 != nil:
    section.add "X-Amz-Credential", valid_612630
  var valid_612631 = header.getOrDefault("X-Amz-Security-Token")
  valid_612631 = validateParameter(valid_612631, JString, required = false,
                                 default = nil)
  if valid_612631 != nil:
    section.add "X-Amz-Security-Token", valid_612631
  var valid_612632 = header.getOrDefault("X-Amz-Algorithm")
  valid_612632 = validateParameter(valid_612632, JString, required = false,
                                 default = nil)
  if valid_612632 != nil:
    section.add "X-Amz-Algorithm", valid_612632
  var valid_612633 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612633 = validateParameter(valid_612633, JString, required = false,
                                 default = nil)
  if valid_612633 != nil:
    section.add "X-Amz-SignedHeaders", valid_612633
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612635: Call_ReplaceTopicRule_612623; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  let valid = call_612635.validator(path, query, header, formData, body)
  let scheme = call_612635.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612635.url(scheme.get, call_612635.host, call_612635.base,
                         call_612635.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612635, url, valid)

proc call*(call_612636: Call_ReplaceTopicRule_612623; ruleName: string;
          body: JsonNode): Recallable =
  ## replaceTopicRule
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  ##   body: JObject (required)
  var path_612637 = newJObject()
  var body_612638 = newJObject()
  add(path_612637, "ruleName", newJString(ruleName))
  if body != nil:
    body_612638 = body
  result = call_612636.call(path_612637, nil, nil, nil, body_612638)

var replaceTopicRule* = Call_ReplaceTopicRule_612623(name: "replaceTopicRule",
    meth: HttpMethod.HttpPatch, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_ReplaceTopicRule_612624,
    base: "/", url: url_ReplaceTopicRule_612625,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteTopicRule_612609 = ref object of OpenApiRestCall_610658
proc url_DeleteTopicRule_612611(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTopicRule_612610(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_612612 = path.getOrDefault("ruleName")
  valid_612612 = validateParameter(valid_612612, JString, required = true,
                                 default = nil)
  if valid_612612 != nil:
    section.add "ruleName", valid_612612
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612613 = header.getOrDefault("X-Amz-Signature")
  valid_612613 = validateParameter(valid_612613, JString, required = false,
                                 default = nil)
  if valid_612613 != nil:
    section.add "X-Amz-Signature", valid_612613
  var valid_612614 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612614 = validateParameter(valid_612614, JString, required = false,
                                 default = nil)
  if valid_612614 != nil:
    section.add "X-Amz-Content-Sha256", valid_612614
  var valid_612615 = header.getOrDefault("X-Amz-Date")
  valid_612615 = validateParameter(valid_612615, JString, required = false,
                                 default = nil)
  if valid_612615 != nil:
    section.add "X-Amz-Date", valid_612615
  var valid_612616 = header.getOrDefault("X-Amz-Credential")
  valid_612616 = validateParameter(valid_612616, JString, required = false,
                                 default = nil)
  if valid_612616 != nil:
    section.add "X-Amz-Credential", valid_612616
  var valid_612617 = header.getOrDefault("X-Amz-Security-Token")
  valid_612617 = validateParameter(valid_612617, JString, required = false,
                                 default = nil)
  if valid_612617 != nil:
    section.add "X-Amz-Security-Token", valid_612617
  var valid_612618 = header.getOrDefault("X-Amz-Algorithm")
  valid_612618 = validateParameter(valid_612618, JString, required = false,
                                 default = nil)
  if valid_612618 != nil:
    section.add "X-Amz-Algorithm", valid_612618
  var valid_612619 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612619 = validateParameter(valid_612619, JString, required = false,
                                 default = nil)
  if valid_612619 != nil:
    section.add "X-Amz-SignedHeaders", valid_612619
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612620: Call_DeleteTopicRule_612609; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the rule.
  ## 
  let valid = call_612620.validator(path, query, header, formData, body)
  let scheme = call_612620.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612620.url(scheme.get, call_612620.host, call_612620.base,
                         call_612620.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612620, url, valid)

proc call*(call_612621: Call_DeleteTopicRule_612609; ruleName: string): Recallable =
  ## deleteTopicRule
  ## Deletes the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  var path_612622 = newJObject()
  add(path_612622, "ruleName", newJString(ruleName))
  result = call_612621.call(path_612622, nil, nil, nil, nil)

var deleteTopicRule* = Call_DeleteTopicRule_612609(name: "deleteTopicRule",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_DeleteTopicRule_612610,
    base: "/", url: url_DeleteTopicRule_612611, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateTopicRuleDestination_612654 = ref object of OpenApiRestCall_610658
proc url_CreateTopicRuleDestination_612656(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateTopicRuleDestination_612655(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a topic rule destination. The destination must be confirmed prior to use.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612657 = header.getOrDefault("X-Amz-Signature")
  valid_612657 = validateParameter(valid_612657, JString, required = false,
                                 default = nil)
  if valid_612657 != nil:
    section.add "X-Amz-Signature", valid_612657
  var valid_612658 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612658 = validateParameter(valid_612658, JString, required = false,
                                 default = nil)
  if valid_612658 != nil:
    section.add "X-Amz-Content-Sha256", valid_612658
  var valid_612659 = header.getOrDefault("X-Amz-Date")
  valid_612659 = validateParameter(valid_612659, JString, required = false,
                                 default = nil)
  if valid_612659 != nil:
    section.add "X-Amz-Date", valid_612659
  var valid_612660 = header.getOrDefault("X-Amz-Credential")
  valid_612660 = validateParameter(valid_612660, JString, required = false,
                                 default = nil)
  if valid_612660 != nil:
    section.add "X-Amz-Credential", valid_612660
  var valid_612661 = header.getOrDefault("X-Amz-Security-Token")
  valid_612661 = validateParameter(valid_612661, JString, required = false,
                                 default = nil)
  if valid_612661 != nil:
    section.add "X-Amz-Security-Token", valid_612661
  var valid_612662 = header.getOrDefault("X-Amz-Algorithm")
  valid_612662 = validateParameter(valid_612662, JString, required = false,
                                 default = nil)
  if valid_612662 != nil:
    section.add "X-Amz-Algorithm", valid_612662
  var valid_612663 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612663 = validateParameter(valid_612663, JString, required = false,
                                 default = nil)
  if valid_612663 != nil:
    section.add "X-Amz-SignedHeaders", valid_612663
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612665: Call_CreateTopicRuleDestination_612654; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a topic rule destination. The destination must be confirmed prior to use.
  ## 
  let valid = call_612665.validator(path, query, header, formData, body)
  let scheme = call_612665.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612665.url(scheme.get, call_612665.host, call_612665.base,
                         call_612665.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612665, url, valid)

proc call*(call_612666: Call_CreateTopicRuleDestination_612654; body: JsonNode): Recallable =
  ## createTopicRuleDestination
  ## Creates a topic rule destination. The destination must be confirmed prior to use.
  ##   body: JObject (required)
  var body_612667 = newJObject()
  if body != nil:
    body_612667 = body
  result = call_612666.call(nil, nil, nil, nil, body_612667)

var createTopicRuleDestination* = Call_CreateTopicRuleDestination_612654(
    name: "createTopicRuleDestination", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/destinations",
    validator: validate_CreateTopicRuleDestination_612655, base: "/",
    url: url_CreateTopicRuleDestination_612656,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTopicRuleDestinations_612639 = ref object of OpenApiRestCall_610658
proc url_ListTopicRuleDestinations_612641(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListTopicRuleDestinations_612640(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all the topic rule destinations in your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_612642 = query.getOrDefault("nextToken")
  valid_612642 = validateParameter(valid_612642, JString, required = false,
                                 default = nil)
  if valid_612642 != nil:
    section.add "nextToken", valid_612642
  var valid_612643 = query.getOrDefault("maxResults")
  valid_612643 = validateParameter(valid_612643, JInt, required = false, default = nil)
  if valid_612643 != nil:
    section.add "maxResults", valid_612643
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612644 = header.getOrDefault("X-Amz-Signature")
  valid_612644 = validateParameter(valid_612644, JString, required = false,
                                 default = nil)
  if valid_612644 != nil:
    section.add "X-Amz-Signature", valid_612644
  var valid_612645 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612645 = validateParameter(valid_612645, JString, required = false,
                                 default = nil)
  if valid_612645 != nil:
    section.add "X-Amz-Content-Sha256", valid_612645
  var valid_612646 = header.getOrDefault("X-Amz-Date")
  valid_612646 = validateParameter(valid_612646, JString, required = false,
                                 default = nil)
  if valid_612646 != nil:
    section.add "X-Amz-Date", valid_612646
  var valid_612647 = header.getOrDefault("X-Amz-Credential")
  valid_612647 = validateParameter(valid_612647, JString, required = false,
                                 default = nil)
  if valid_612647 != nil:
    section.add "X-Amz-Credential", valid_612647
  var valid_612648 = header.getOrDefault("X-Amz-Security-Token")
  valid_612648 = validateParameter(valid_612648, JString, required = false,
                                 default = nil)
  if valid_612648 != nil:
    section.add "X-Amz-Security-Token", valid_612648
  var valid_612649 = header.getOrDefault("X-Amz-Algorithm")
  valid_612649 = validateParameter(valid_612649, JString, required = false,
                                 default = nil)
  if valid_612649 != nil:
    section.add "X-Amz-Algorithm", valid_612649
  var valid_612650 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612650 = validateParameter(valid_612650, JString, required = false,
                                 default = nil)
  if valid_612650 != nil:
    section.add "X-Amz-SignedHeaders", valid_612650
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612651: Call_ListTopicRuleDestinations_612639; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all the topic rule destinations in your AWS account.
  ## 
  let valid = call_612651.validator(path, query, header, formData, body)
  let scheme = call_612651.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612651.url(scheme.get, call_612651.host, call_612651.base,
                         call_612651.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612651, url, valid)

proc call*(call_612652: Call_ListTopicRuleDestinations_612639;
          nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listTopicRuleDestinations
  ## Lists all the topic rule destinations in your AWS account.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_612653 = newJObject()
  add(query_612653, "nextToken", newJString(nextToken))
  add(query_612653, "maxResults", newJInt(maxResults))
  result = call_612652.call(nil, query_612653, nil, nil, nil)

var listTopicRuleDestinations* = Call_ListTopicRuleDestinations_612639(
    name: "listTopicRuleDestinations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/destinations",
    validator: validate_ListTopicRuleDestinations_612640, base: "/",
    url: url_ListTopicRuleDestinations_612641,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateTopicRuleDestination_612668 = ref object of OpenApiRestCall_610658
proc url_UpdateTopicRuleDestination_612670(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateTopicRuleDestination_612669(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a topic rule destination. You use this to change the status, endpoint URL, or confirmation URL of the destination.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612671 = header.getOrDefault("X-Amz-Signature")
  valid_612671 = validateParameter(valid_612671, JString, required = false,
                                 default = nil)
  if valid_612671 != nil:
    section.add "X-Amz-Signature", valid_612671
  var valid_612672 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612672 = validateParameter(valid_612672, JString, required = false,
                                 default = nil)
  if valid_612672 != nil:
    section.add "X-Amz-Content-Sha256", valid_612672
  var valid_612673 = header.getOrDefault("X-Amz-Date")
  valid_612673 = validateParameter(valid_612673, JString, required = false,
                                 default = nil)
  if valid_612673 != nil:
    section.add "X-Amz-Date", valid_612673
  var valid_612674 = header.getOrDefault("X-Amz-Credential")
  valid_612674 = validateParameter(valid_612674, JString, required = false,
                                 default = nil)
  if valid_612674 != nil:
    section.add "X-Amz-Credential", valid_612674
  var valid_612675 = header.getOrDefault("X-Amz-Security-Token")
  valid_612675 = validateParameter(valid_612675, JString, required = false,
                                 default = nil)
  if valid_612675 != nil:
    section.add "X-Amz-Security-Token", valid_612675
  var valid_612676 = header.getOrDefault("X-Amz-Algorithm")
  valid_612676 = validateParameter(valid_612676, JString, required = false,
                                 default = nil)
  if valid_612676 != nil:
    section.add "X-Amz-Algorithm", valid_612676
  var valid_612677 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612677 = validateParameter(valid_612677, JString, required = false,
                                 default = nil)
  if valid_612677 != nil:
    section.add "X-Amz-SignedHeaders", valid_612677
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612679: Call_UpdateTopicRuleDestination_612668; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a topic rule destination. You use this to change the status, endpoint URL, or confirmation URL of the destination.
  ## 
  let valid = call_612679.validator(path, query, header, formData, body)
  let scheme = call_612679.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612679.url(scheme.get, call_612679.host, call_612679.base,
                         call_612679.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612679, url, valid)

proc call*(call_612680: Call_UpdateTopicRuleDestination_612668; body: JsonNode): Recallable =
  ## updateTopicRuleDestination
  ## Updates a topic rule destination. You use this to change the status, endpoint URL, or confirmation URL of the destination.
  ##   body: JObject (required)
  var body_612681 = newJObject()
  if body != nil:
    body_612681 = body
  result = call_612680.call(nil, nil, nil, nil, body_612681)

var updateTopicRuleDestination* = Call_UpdateTopicRuleDestination_612668(
    name: "updateTopicRuleDestination", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/destinations",
    validator: validate_UpdateTopicRuleDestination_612669, base: "/",
    url: url_UpdateTopicRuleDestination_612670,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAccountAuditConfiguration_612682 = ref object of OpenApiRestCall_610658
proc url_DescribeAccountAuditConfiguration_612684(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeAccountAuditConfiguration_612683(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612685 = header.getOrDefault("X-Amz-Signature")
  valid_612685 = validateParameter(valid_612685, JString, required = false,
                                 default = nil)
  if valid_612685 != nil:
    section.add "X-Amz-Signature", valid_612685
  var valid_612686 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612686 = validateParameter(valid_612686, JString, required = false,
                                 default = nil)
  if valid_612686 != nil:
    section.add "X-Amz-Content-Sha256", valid_612686
  var valid_612687 = header.getOrDefault("X-Amz-Date")
  valid_612687 = validateParameter(valid_612687, JString, required = false,
                                 default = nil)
  if valid_612687 != nil:
    section.add "X-Amz-Date", valid_612687
  var valid_612688 = header.getOrDefault("X-Amz-Credential")
  valid_612688 = validateParameter(valid_612688, JString, required = false,
                                 default = nil)
  if valid_612688 != nil:
    section.add "X-Amz-Credential", valid_612688
  var valid_612689 = header.getOrDefault("X-Amz-Security-Token")
  valid_612689 = validateParameter(valid_612689, JString, required = false,
                                 default = nil)
  if valid_612689 != nil:
    section.add "X-Amz-Security-Token", valid_612689
  var valid_612690 = header.getOrDefault("X-Amz-Algorithm")
  valid_612690 = validateParameter(valid_612690, JString, required = false,
                                 default = nil)
  if valid_612690 != nil:
    section.add "X-Amz-Algorithm", valid_612690
  var valid_612691 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612691 = validateParameter(valid_612691, JString, required = false,
                                 default = nil)
  if valid_612691 != nil:
    section.add "X-Amz-SignedHeaders", valid_612691
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612692: Call_DescribeAccountAuditConfiguration_612682;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  let valid = call_612692.validator(path, query, header, formData, body)
  let scheme = call_612692.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612692.url(scheme.get, call_612692.host, call_612692.base,
                         call_612692.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612692, url, valid)

proc call*(call_612693: Call_DescribeAccountAuditConfiguration_612682): Recallable =
  ## describeAccountAuditConfiguration
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  result = call_612693.call(nil, nil, nil, nil, nil)

var describeAccountAuditConfiguration* = Call_DescribeAccountAuditConfiguration_612682(
    name: "describeAccountAuditConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_DescribeAccountAuditConfiguration_612683, base: "/",
    url: url_DescribeAccountAuditConfiguration_612684,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateAccountAuditConfiguration_612708 = ref object of OpenApiRestCall_610658
proc url_UpdateAccountAuditConfiguration_612710(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateAccountAuditConfiguration_612709(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612711 = header.getOrDefault("X-Amz-Signature")
  valid_612711 = validateParameter(valid_612711, JString, required = false,
                                 default = nil)
  if valid_612711 != nil:
    section.add "X-Amz-Signature", valid_612711
  var valid_612712 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612712 = validateParameter(valid_612712, JString, required = false,
                                 default = nil)
  if valid_612712 != nil:
    section.add "X-Amz-Content-Sha256", valid_612712
  var valid_612713 = header.getOrDefault("X-Amz-Date")
  valid_612713 = validateParameter(valid_612713, JString, required = false,
                                 default = nil)
  if valid_612713 != nil:
    section.add "X-Amz-Date", valid_612713
  var valid_612714 = header.getOrDefault("X-Amz-Credential")
  valid_612714 = validateParameter(valid_612714, JString, required = false,
                                 default = nil)
  if valid_612714 != nil:
    section.add "X-Amz-Credential", valid_612714
  var valid_612715 = header.getOrDefault("X-Amz-Security-Token")
  valid_612715 = validateParameter(valid_612715, JString, required = false,
                                 default = nil)
  if valid_612715 != nil:
    section.add "X-Amz-Security-Token", valid_612715
  var valid_612716 = header.getOrDefault("X-Amz-Algorithm")
  valid_612716 = validateParameter(valid_612716, JString, required = false,
                                 default = nil)
  if valid_612716 != nil:
    section.add "X-Amz-Algorithm", valid_612716
  var valid_612717 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612717 = validateParameter(valid_612717, JString, required = false,
                                 default = nil)
  if valid_612717 != nil:
    section.add "X-Amz-SignedHeaders", valid_612717
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612719: Call_UpdateAccountAuditConfiguration_612708;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  let valid = call_612719.validator(path, query, header, formData, body)
  let scheme = call_612719.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612719.url(scheme.get, call_612719.host, call_612719.base,
                         call_612719.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612719, url, valid)

proc call*(call_612720: Call_UpdateAccountAuditConfiguration_612708; body: JsonNode): Recallable =
  ## updateAccountAuditConfiguration
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ##   body: JObject (required)
  var body_612721 = newJObject()
  if body != nil:
    body_612721 = body
  result = call_612720.call(nil, nil, nil, nil, body_612721)

var updateAccountAuditConfiguration* = Call_UpdateAccountAuditConfiguration_612708(
    name: "updateAccountAuditConfiguration", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_UpdateAccountAuditConfiguration_612709, base: "/",
    url: url_UpdateAccountAuditConfiguration_612710,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteAccountAuditConfiguration_612694 = ref object of OpenApiRestCall_610658
proc url_DeleteAccountAuditConfiguration_612696(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteAccountAuditConfiguration_612695(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   deleteScheduledAudits: JBool
  ##                        : If true, all scheduled audits are deleted.
  section = newJObject()
  var valid_612697 = query.getOrDefault("deleteScheduledAudits")
  valid_612697 = validateParameter(valid_612697, JBool, required = false, default = nil)
  if valid_612697 != nil:
    section.add "deleteScheduledAudits", valid_612697
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612698 = header.getOrDefault("X-Amz-Signature")
  valid_612698 = validateParameter(valid_612698, JString, required = false,
                                 default = nil)
  if valid_612698 != nil:
    section.add "X-Amz-Signature", valid_612698
  var valid_612699 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612699 = validateParameter(valid_612699, JString, required = false,
                                 default = nil)
  if valid_612699 != nil:
    section.add "X-Amz-Content-Sha256", valid_612699
  var valid_612700 = header.getOrDefault("X-Amz-Date")
  valid_612700 = validateParameter(valid_612700, JString, required = false,
                                 default = nil)
  if valid_612700 != nil:
    section.add "X-Amz-Date", valid_612700
  var valid_612701 = header.getOrDefault("X-Amz-Credential")
  valid_612701 = validateParameter(valid_612701, JString, required = false,
                                 default = nil)
  if valid_612701 != nil:
    section.add "X-Amz-Credential", valid_612701
  var valid_612702 = header.getOrDefault("X-Amz-Security-Token")
  valid_612702 = validateParameter(valid_612702, JString, required = false,
                                 default = nil)
  if valid_612702 != nil:
    section.add "X-Amz-Security-Token", valid_612702
  var valid_612703 = header.getOrDefault("X-Amz-Algorithm")
  valid_612703 = validateParameter(valid_612703, JString, required = false,
                                 default = nil)
  if valid_612703 != nil:
    section.add "X-Amz-Algorithm", valid_612703
  var valid_612704 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612704 = validateParameter(valid_612704, JString, required = false,
                                 default = nil)
  if valid_612704 != nil:
    section.add "X-Amz-SignedHeaders", valid_612704
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612705: Call_DeleteAccountAuditConfiguration_612694;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ## 
  let valid = call_612705.validator(path, query, header, formData, body)
  let scheme = call_612705.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612705.url(scheme.get, call_612705.host, call_612705.base,
                         call_612705.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612705, url, valid)

proc call*(call_612706: Call_DeleteAccountAuditConfiguration_612694;
          deleteScheduledAudits: bool = false): Recallable =
  ## deleteAccountAuditConfiguration
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ##   deleteScheduledAudits: bool
  ##                        : If true, all scheduled audits are deleted.
  var query_612707 = newJObject()
  add(query_612707, "deleteScheduledAudits", newJBool(deleteScheduledAudits))
  result = call_612706.call(nil, query_612707, nil, nil, nil)

var deleteAccountAuditConfiguration* = Call_DeleteAccountAuditConfiguration_612694(
    name: "deleteAccountAuditConfiguration", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_DeleteAccountAuditConfiguration_612695, base: "/",
    url: url_DeleteAccountAuditConfiguration_612696,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateCACertificate_612736 = ref object of OpenApiRestCall_610658
proc url_UpdateCACertificate_612738(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateCACertificate_612737(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Updates a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The CA certificate identifier.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_612739 = path.getOrDefault("caCertificateId")
  valid_612739 = validateParameter(valid_612739, JString, required = true,
                                 default = nil)
  if valid_612739 != nil:
    section.add "caCertificateId", valid_612739
  result.add "path", section
  ## parameters in `query` object:
  ##   newAutoRegistrationStatus: JString
  ##                            : The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
  ##   newStatus: JString
  ##            : <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  section = newJObject()
  var valid_612753 = query.getOrDefault("newAutoRegistrationStatus")
  valid_612753 = validateParameter(valid_612753, JString, required = false,
                                 default = newJString("ENABLE"))
  if valid_612753 != nil:
    section.add "newAutoRegistrationStatus", valid_612753
  var valid_612754 = query.getOrDefault("newStatus")
  valid_612754 = validateParameter(valid_612754, JString, required = false,
                                 default = newJString("ACTIVE"))
  if valid_612754 != nil:
    section.add "newStatus", valid_612754
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612755 = header.getOrDefault("X-Amz-Signature")
  valid_612755 = validateParameter(valid_612755, JString, required = false,
                                 default = nil)
  if valid_612755 != nil:
    section.add "X-Amz-Signature", valid_612755
  var valid_612756 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612756 = validateParameter(valid_612756, JString, required = false,
                                 default = nil)
  if valid_612756 != nil:
    section.add "X-Amz-Content-Sha256", valid_612756
  var valid_612757 = header.getOrDefault("X-Amz-Date")
  valid_612757 = validateParameter(valid_612757, JString, required = false,
                                 default = nil)
  if valid_612757 != nil:
    section.add "X-Amz-Date", valid_612757
  var valid_612758 = header.getOrDefault("X-Amz-Credential")
  valid_612758 = validateParameter(valid_612758, JString, required = false,
                                 default = nil)
  if valid_612758 != nil:
    section.add "X-Amz-Credential", valid_612758
  var valid_612759 = header.getOrDefault("X-Amz-Security-Token")
  valid_612759 = validateParameter(valid_612759, JString, required = false,
                                 default = nil)
  if valid_612759 != nil:
    section.add "X-Amz-Security-Token", valid_612759
  var valid_612760 = header.getOrDefault("X-Amz-Algorithm")
  valid_612760 = validateParameter(valid_612760, JString, required = false,
                                 default = nil)
  if valid_612760 != nil:
    section.add "X-Amz-Algorithm", valid_612760
  var valid_612761 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612761 = validateParameter(valid_612761, JString, required = false,
                                 default = nil)
  if valid_612761 != nil:
    section.add "X-Amz-SignedHeaders", valid_612761
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612763: Call_UpdateCACertificate_612736; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a registered CA certificate.
  ## 
  let valid = call_612763.validator(path, query, header, formData, body)
  let scheme = call_612763.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612763.url(scheme.get, call_612763.host, call_612763.base,
                         call_612763.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612763, url, valid)

proc call*(call_612764: Call_UpdateCACertificate_612736; caCertificateId: string;
          body: JsonNode; newAutoRegistrationStatus: string = "ENABLE";
          newStatus: string = "ACTIVE"): Recallable =
  ## updateCACertificate
  ## Updates a registered CA certificate.
  ##   newAutoRegistrationStatus: string
  ##                            : The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
  ##   caCertificateId: string (required)
  ##                  : The CA certificate identifier.
  ##   newStatus: string
  ##            : <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  ##   body: JObject (required)
  var path_612765 = newJObject()
  var query_612766 = newJObject()
  var body_612767 = newJObject()
  add(query_612766, "newAutoRegistrationStatus",
      newJString(newAutoRegistrationStatus))
  add(path_612765, "caCertificateId", newJString(caCertificateId))
  add(query_612766, "newStatus", newJString(newStatus))
  if body != nil:
    body_612767 = body
  result = call_612764.call(path_612765, query_612766, nil, nil, body_612767)

var updateCACertificate* = Call_UpdateCACertificate_612736(
    name: "updateCACertificate", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_UpdateCACertificate_612737, base: "/",
    url: url_UpdateCACertificate_612738, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeCACertificate_612722 = ref object of OpenApiRestCall_610658
proc url_DescribeCACertificate_612724(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeCACertificate_612723(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The CA certificate identifier.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_612725 = path.getOrDefault("caCertificateId")
  valid_612725 = validateParameter(valid_612725, JString, required = true,
                                 default = nil)
  if valid_612725 != nil:
    section.add "caCertificateId", valid_612725
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612726 = header.getOrDefault("X-Amz-Signature")
  valid_612726 = validateParameter(valid_612726, JString, required = false,
                                 default = nil)
  if valid_612726 != nil:
    section.add "X-Amz-Signature", valid_612726
  var valid_612727 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612727 = validateParameter(valid_612727, JString, required = false,
                                 default = nil)
  if valid_612727 != nil:
    section.add "X-Amz-Content-Sha256", valid_612727
  var valid_612728 = header.getOrDefault("X-Amz-Date")
  valid_612728 = validateParameter(valid_612728, JString, required = false,
                                 default = nil)
  if valid_612728 != nil:
    section.add "X-Amz-Date", valid_612728
  var valid_612729 = header.getOrDefault("X-Amz-Credential")
  valid_612729 = validateParameter(valid_612729, JString, required = false,
                                 default = nil)
  if valid_612729 != nil:
    section.add "X-Amz-Credential", valid_612729
  var valid_612730 = header.getOrDefault("X-Amz-Security-Token")
  valid_612730 = validateParameter(valid_612730, JString, required = false,
                                 default = nil)
  if valid_612730 != nil:
    section.add "X-Amz-Security-Token", valid_612730
  var valid_612731 = header.getOrDefault("X-Amz-Algorithm")
  valid_612731 = validateParameter(valid_612731, JString, required = false,
                                 default = nil)
  if valid_612731 != nil:
    section.add "X-Amz-Algorithm", valid_612731
  var valid_612732 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612732 = validateParameter(valid_612732, JString, required = false,
                                 default = nil)
  if valid_612732 != nil:
    section.add "X-Amz-SignedHeaders", valid_612732
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612733: Call_DescribeCACertificate_612722; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a registered CA certificate.
  ## 
  let valid = call_612733.validator(path, query, header, formData, body)
  let scheme = call_612733.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612733.url(scheme.get, call_612733.host, call_612733.base,
                         call_612733.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612733, url, valid)

proc call*(call_612734: Call_DescribeCACertificate_612722; caCertificateId: string): Recallable =
  ## describeCACertificate
  ## Describes a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The CA certificate identifier.
  var path_612735 = newJObject()
  add(path_612735, "caCertificateId", newJString(caCertificateId))
  result = call_612734.call(path_612735, nil, nil, nil, nil)

var describeCACertificate* = Call_DescribeCACertificate_612722(
    name: "describeCACertificate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_DescribeCACertificate_612723, base: "/",
    url: url_DescribeCACertificate_612724, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteCACertificate_612768 = ref object of OpenApiRestCall_610658
proc url_DeleteCACertificate_612770(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteCACertificate_612769(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Deletes a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_612771 = path.getOrDefault("caCertificateId")
  valid_612771 = validateParameter(valid_612771, JString, required = true,
                                 default = nil)
  if valid_612771 != nil:
    section.add "caCertificateId", valid_612771
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612772 = header.getOrDefault("X-Amz-Signature")
  valid_612772 = validateParameter(valid_612772, JString, required = false,
                                 default = nil)
  if valid_612772 != nil:
    section.add "X-Amz-Signature", valid_612772
  var valid_612773 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612773 = validateParameter(valid_612773, JString, required = false,
                                 default = nil)
  if valid_612773 != nil:
    section.add "X-Amz-Content-Sha256", valid_612773
  var valid_612774 = header.getOrDefault("X-Amz-Date")
  valid_612774 = validateParameter(valid_612774, JString, required = false,
                                 default = nil)
  if valid_612774 != nil:
    section.add "X-Amz-Date", valid_612774
  var valid_612775 = header.getOrDefault("X-Amz-Credential")
  valid_612775 = validateParameter(valid_612775, JString, required = false,
                                 default = nil)
  if valid_612775 != nil:
    section.add "X-Amz-Credential", valid_612775
  var valid_612776 = header.getOrDefault("X-Amz-Security-Token")
  valid_612776 = validateParameter(valid_612776, JString, required = false,
                                 default = nil)
  if valid_612776 != nil:
    section.add "X-Amz-Security-Token", valid_612776
  var valid_612777 = header.getOrDefault("X-Amz-Algorithm")
  valid_612777 = validateParameter(valid_612777, JString, required = false,
                                 default = nil)
  if valid_612777 != nil:
    section.add "X-Amz-Algorithm", valid_612777
  var valid_612778 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612778 = validateParameter(valid_612778, JString, required = false,
                                 default = nil)
  if valid_612778 != nil:
    section.add "X-Amz-SignedHeaders", valid_612778
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612779: Call_DeleteCACertificate_612768; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a registered CA certificate.
  ## 
  let valid = call_612779.validator(path, query, header, formData, body)
  let scheme = call_612779.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612779.url(scheme.get, call_612779.host, call_612779.base,
                         call_612779.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612779, url, valid)

proc call*(call_612780: Call_DeleteCACertificate_612768; caCertificateId: string): Recallable =
  ## deleteCACertificate
  ## Deletes a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
  var path_612781 = newJObject()
  add(path_612781, "caCertificateId", newJString(caCertificateId))
  result = call_612780.call(path_612781, nil, nil, nil, nil)

var deleteCACertificate* = Call_DeleteCACertificate_612768(
    name: "deleteCACertificate", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_DeleteCACertificate_612769, base: "/",
    url: url_DeleteCACertificate_612770, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeCertificate_612782 = ref object of OpenApiRestCall_610658
proc url_DescribeCertificate_612784(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeCertificate_612783(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets information about the specified certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_612785 = path.getOrDefault("certificateId")
  valid_612785 = validateParameter(valid_612785, JString, required = true,
                                 default = nil)
  if valid_612785 != nil:
    section.add "certificateId", valid_612785
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612786 = header.getOrDefault("X-Amz-Signature")
  valid_612786 = validateParameter(valid_612786, JString, required = false,
                                 default = nil)
  if valid_612786 != nil:
    section.add "X-Amz-Signature", valid_612786
  var valid_612787 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612787 = validateParameter(valid_612787, JString, required = false,
                                 default = nil)
  if valid_612787 != nil:
    section.add "X-Amz-Content-Sha256", valid_612787
  var valid_612788 = header.getOrDefault("X-Amz-Date")
  valid_612788 = validateParameter(valid_612788, JString, required = false,
                                 default = nil)
  if valid_612788 != nil:
    section.add "X-Amz-Date", valid_612788
  var valid_612789 = header.getOrDefault("X-Amz-Credential")
  valid_612789 = validateParameter(valid_612789, JString, required = false,
                                 default = nil)
  if valid_612789 != nil:
    section.add "X-Amz-Credential", valid_612789
  var valid_612790 = header.getOrDefault("X-Amz-Security-Token")
  valid_612790 = validateParameter(valid_612790, JString, required = false,
                                 default = nil)
  if valid_612790 != nil:
    section.add "X-Amz-Security-Token", valid_612790
  var valid_612791 = header.getOrDefault("X-Amz-Algorithm")
  valid_612791 = validateParameter(valid_612791, JString, required = false,
                                 default = nil)
  if valid_612791 != nil:
    section.add "X-Amz-Algorithm", valid_612791
  var valid_612792 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612792 = validateParameter(valid_612792, JString, required = false,
                                 default = nil)
  if valid_612792 != nil:
    section.add "X-Amz-SignedHeaders", valid_612792
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612793: Call_DescribeCertificate_612782; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified certificate.
  ## 
  let valid = call_612793.validator(path, query, header, formData, body)
  let scheme = call_612793.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612793.url(scheme.get, call_612793.host, call_612793.base,
                         call_612793.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612793, url, valid)

proc call*(call_612794: Call_DescribeCertificate_612782; certificateId: string): Recallable =
  ## describeCertificate
  ## Gets information about the specified certificate.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_612795 = newJObject()
  add(path_612795, "certificateId", newJString(certificateId))
  result = call_612794.call(path_612795, nil, nil, nil, nil)

var describeCertificate* = Call_DescribeCertificate_612782(
    name: "describeCertificate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates/{certificateId}",
    validator: validate_DescribeCertificate_612783, base: "/",
    url: url_DescribeCertificate_612784, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteCertificate_612796 = ref object of OpenApiRestCall_610658
proc url_DeleteCertificate_612798(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteCertificate_612797(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_612799 = path.getOrDefault("certificateId")
  valid_612799 = validateParameter(valid_612799, JString, required = true,
                                 default = nil)
  if valid_612799 != nil:
    section.add "certificateId", valid_612799
  result.add "path", section
  ## parameters in `query` object:
  ##   forceDelete: JBool
  ##              : Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
  section = newJObject()
  var valid_612800 = query.getOrDefault("forceDelete")
  valid_612800 = validateParameter(valid_612800, JBool, required = false, default = nil)
  if valid_612800 != nil:
    section.add "forceDelete", valid_612800
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612801 = header.getOrDefault("X-Amz-Signature")
  valid_612801 = validateParameter(valid_612801, JString, required = false,
                                 default = nil)
  if valid_612801 != nil:
    section.add "X-Amz-Signature", valid_612801
  var valid_612802 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612802 = validateParameter(valid_612802, JString, required = false,
                                 default = nil)
  if valid_612802 != nil:
    section.add "X-Amz-Content-Sha256", valid_612802
  var valid_612803 = header.getOrDefault("X-Amz-Date")
  valid_612803 = validateParameter(valid_612803, JString, required = false,
                                 default = nil)
  if valid_612803 != nil:
    section.add "X-Amz-Date", valid_612803
  var valid_612804 = header.getOrDefault("X-Amz-Credential")
  valid_612804 = validateParameter(valid_612804, JString, required = false,
                                 default = nil)
  if valid_612804 != nil:
    section.add "X-Amz-Credential", valid_612804
  var valid_612805 = header.getOrDefault("X-Amz-Security-Token")
  valid_612805 = validateParameter(valid_612805, JString, required = false,
                                 default = nil)
  if valid_612805 != nil:
    section.add "X-Amz-Security-Token", valid_612805
  var valid_612806 = header.getOrDefault("X-Amz-Algorithm")
  valid_612806 = validateParameter(valid_612806, JString, required = false,
                                 default = nil)
  if valid_612806 != nil:
    section.add "X-Amz-Algorithm", valid_612806
  var valid_612807 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612807 = validateParameter(valid_612807, JString, required = false,
                                 default = nil)
  if valid_612807 != nil:
    section.add "X-Amz-SignedHeaders", valid_612807
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612808: Call_DeleteCertificate_612796; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ## 
  let valid = call_612808.validator(path, query, header, formData, body)
  let scheme = call_612808.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612808.url(scheme.get, call_612808.host, call_612808.base,
                         call_612808.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612808, url, valid)

proc call*(call_612809: Call_DeleteCertificate_612796; certificateId: string;
          forceDelete: bool = false): Recallable =
  ## deleteCertificate
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ##   forceDelete: bool
  ##              : Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_612810 = newJObject()
  var query_612811 = newJObject()
  add(query_612811, "forceDelete", newJBool(forceDelete))
  add(path_612810, "certificateId", newJString(certificateId))
  result = call_612809.call(path_612810, query_612811, nil, nil, nil)

var deleteCertificate* = Call_DeleteCertificate_612796(name: "deleteCertificate",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/certificates/{certificateId}", validator: validate_DeleteCertificate_612797,
    base: "/", url: url_DeleteCertificate_612798,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteJobExecution_612812 = ref object of OpenApiRestCall_610658
proc url_DeleteJobExecution_612814(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  assert "executionNumber" in path, "`executionNumber` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/executionNumber/"),
               (kind: VariableSegment, value: "executionNumber")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteJobExecution_612813(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deletes a job execution.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   executionNumber: JInt (required)
  ##                  : <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
  ##   jobId: JString (required)
  ##        : The ID of the job whose execution on a particular device will be deleted.
  ##   thingName: JString (required)
  ##            : The name of the thing whose job execution will be deleted.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `executionNumber` field"
  var valid_612815 = path.getOrDefault("executionNumber")
  valid_612815 = validateParameter(valid_612815, JInt, required = true, default = nil)
  if valid_612815 != nil:
    section.add "executionNumber", valid_612815
  var valid_612816 = path.getOrDefault("jobId")
  valid_612816 = validateParameter(valid_612816, JString, required = true,
                                 default = nil)
  if valid_612816 != nil:
    section.add "jobId", valid_612816
  var valid_612817 = path.getOrDefault("thingName")
  valid_612817 = validateParameter(valid_612817, JString, required = true,
                                 default = nil)
  if valid_612817 != nil:
    section.add "thingName", valid_612817
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
  section = newJObject()
  var valid_612818 = query.getOrDefault("force")
  valid_612818 = validateParameter(valid_612818, JBool, required = false, default = nil)
  if valid_612818 != nil:
    section.add "force", valid_612818
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612819 = header.getOrDefault("X-Amz-Signature")
  valid_612819 = validateParameter(valid_612819, JString, required = false,
                                 default = nil)
  if valid_612819 != nil:
    section.add "X-Amz-Signature", valid_612819
  var valid_612820 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612820 = validateParameter(valid_612820, JString, required = false,
                                 default = nil)
  if valid_612820 != nil:
    section.add "X-Amz-Content-Sha256", valid_612820
  var valid_612821 = header.getOrDefault("X-Amz-Date")
  valid_612821 = validateParameter(valid_612821, JString, required = false,
                                 default = nil)
  if valid_612821 != nil:
    section.add "X-Amz-Date", valid_612821
  var valid_612822 = header.getOrDefault("X-Amz-Credential")
  valid_612822 = validateParameter(valid_612822, JString, required = false,
                                 default = nil)
  if valid_612822 != nil:
    section.add "X-Amz-Credential", valid_612822
  var valid_612823 = header.getOrDefault("X-Amz-Security-Token")
  valid_612823 = validateParameter(valid_612823, JString, required = false,
                                 default = nil)
  if valid_612823 != nil:
    section.add "X-Amz-Security-Token", valid_612823
  var valid_612824 = header.getOrDefault("X-Amz-Algorithm")
  valid_612824 = validateParameter(valid_612824, JString, required = false,
                                 default = nil)
  if valid_612824 != nil:
    section.add "X-Amz-Algorithm", valid_612824
  var valid_612825 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612825 = validateParameter(valid_612825, JString, required = false,
                                 default = nil)
  if valid_612825 != nil:
    section.add "X-Amz-SignedHeaders", valid_612825
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612826: Call_DeleteJobExecution_612812; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a job execution.
  ## 
  let valid = call_612826.validator(path, query, header, formData, body)
  let scheme = call_612826.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612826.url(scheme.get, call_612826.host, call_612826.base,
                         call_612826.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612826, url, valid)

proc call*(call_612827: Call_DeleteJobExecution_612812; executionNumber: int;
          jobId: string; thingName: string; force: bool = false): Recallable =
  ## deleteJobExecution
  ## Deletes a job execution.
  ##   executionNumber: int (required)
  ##                  : <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
  ##   jobId: string (required)
  ##        : The ID of the job whose execution on a particular device will be deleted.
  ##   thingName: string (required)
  ##            : The name of the thing whose job execution will be deleted.
  ##   force: bool
  ##        : <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
  var path_612828 = newJObject()
  var query_612829 = newJObject()
  add(path_612828, "executionNumber", newJInt(executionNumber))
  add(path_612828, "jobId", newJString(jobId))
  add(path_612828, "thingName", newJString(thingName))
  add(query_612829, "force", newJBool(force))
  result = call_612827.call(path_612828, query_612829, nil, nil, nil)

var deleteJobExecution* = Call_DeleteJobExecution_612812(
    name: "deleteJobExecution", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}",
    validator: validate_DeleteJobExecution_612813, base: "/",
    url: url_DeleteJobExecution_612814, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPolicyVersion_612830 = ref object of OpenApiRestCall_610658
proc url_GetPolicyVersion_612832(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetPolicyVersion_612831(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets information about the specified policy version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_612833 = path.getOrDefault("policyName")
  valid_612833 = validateParameter(valid_612833, JString, required = true,
                                 default = nil)
  if valid_612833 != nil:
    section.add "policyName", valid_612833
  var valid_612834 = path.getOrDefault("policyVersionId")
  valid_612834 = validateParameter(valid_612834, JString, required = true,
                                 default = nil)
  if valid_612834 != nil:
    section.add "policyVersionId", valid_612834
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612835 = header.getOrDefault("X-Amz-Signature")
  valid_612835 = validateParameter(valid_612835, JString, required = false,
                                 default = nil)
  if valid_612835 != nil:
    section.add "X-Amz-Signature", valid_612835
  var valid_612836 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612836 = validateParameter(valid_612836, JString, required = false,
                                 default = nil)
  if valid_612836 != nil:
    section.add "X-Amz-Content-Sha256", valid_612836
  var valid_612837 = header.getOrDefault("X-Amz-Date")
  valid_612837 = validateParameter(valid_612837, JString, required = false,
                                 default = nil)
  if valid_612837 != nil:
    section.add "X-Amz-Date", valid_612837
  var valid_612838 = header.getOrDefault("X-Amz-Credential")
  valid_612838 = validateParameter(valid_612838, JString, required = false,
                                 default = nil)
  if valid_612838 != nil:
    section.add "X-Amz-Credential", valid_612838
  var valid_612839 = header.getOrDefault("X-Amz-Security-Token")
  valid_612839 = validateParameter(valid_612839, JString, required = false,
                                 default = nil)
  if valid_612839 != nil:
    section.add "X-Amz-Security-Token", valid_612839
  var valid_612840 = header.getOrDefault("X-Amz-Algorithm")
  valid_612840 = validateParameter(valid_612840, JString, required = false,
                                 default = nil)
  if valid_612840 != nil:
    section.add "X-Amz-Algorithm", valid_612840
  var valid_612841 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612841 = validateParameter(valid_612841, JString, required = false,
                                 default = nil)
  if valid_612841 != nil:
    section.add "X-Amz-SignedHeaders", valid_612841
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612842: Call_GetPolicyVersion_612830; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified policy version.
  ## 
  let valid = call_612842.validator(path, query, header, formData, body)
  let scheme = call_612842.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612842.url(scheme.get, call_612842.host, call_612842.base,
                         call_612842.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612842, url, valid)

proc call*(call_612843: Call_GetPolicyVersion_612830; policyName: string;
          policyVersionId: string): Recallable =
  ## getPolicyVersion
  ## Gets information about the specified policy version.
  ##   policyName: string (required)
  ##             : The name of the policy.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_612844 = newJObject()
  add(path_612844, "policyName", newJString(policyName))
  add(path_612844, "policyVersionId", newJString(policyVersionId))
  result = call_612843.call(path_612844, nil, nil, nil, nil)

var getPolicyVersion* = Call_GetPolicyVersion_612830(name: "getPolicyVersion",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_GetPolicyVersion_612831, base: "/",
    url: url_GetPolicyVersion_612832, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetDefaultPolicyVersion_612860 = ref object of OpenApiRestCall_610658
proc url_SetDefaultPolicyVersion_612862(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_SetDefaultPolicyVersion_612861(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_612863 = path.getOrDefault("policyName")
  valid_612863 = validateParameter(valid_612863, JString, required = true,
                                 default = nil)
  if valid_612863 != nil:
    section.add "policyName", valid_612863
  var valid_612864 = path.getOrDefault("policyVersionId")
  valid_612864 = validateParameter(valid_612864, JString, required = true,
                                 default = nil)
  if valid_612864 != nil:
    section.add "policyVersionId", valid_612864
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612865 = header.getOrDefault("X-Amz-Signature")
  valid_612865 = validateParameter(valid_612865, JString, required = false,
                                 default = nil)
  if valid_612865 != nil:
    section.add "X-Amz-Signature", valid_612865
  var valid_612866 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612866 = validateParameter(valid_612866, JString, required = false,
                                 default = nil)
  if valid_612866 != nil:
    section.add "X-Amz-Content-Sha256", valid_612866
  var valid_612867 = header.getOrDefault("X-Amz-Date")
  valid_612867 = validateParameter(valid_612867, JString, required = false,
                                 default = nil)
  if valid_612867 != nil:
    section.add "X-Amz-Date", valid_612867
  var valid_612868 = header.getOrDefault("X-Amz-Credential")
  valid_612868 = validateParameter(valid_612868, JString, required = false,
                                 default = nil)
  if valid_612868 != nil:
    section.add "X-Amz-Credential", valid_612868
  var valid_612869 = header.getOrDefault("X-Amz-Security-Token")
  valid_612869 = validateParameter(valid_612869, JString, required = false,
                                 default = nil)
  if valid_612869 != nil:
    section.add "X-Amz-Security-Token", valid_612869
  var valid_612870 = header.getOrDefault("X-Amz-Algorithm")
  valid_612870 = validateParameter(valid_612870, JString, required = false,
                                 default = nil)
  if valid_612870 != nil:
    section.add "X-Amz-Algorithm", valid_612870
  var valid_612871 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612871 = validateParameter(valid_612871, JString, required = false,
                                 default = nil)
  if valid_612871 != nil:
    section.add "X-Amz-SignedHeaders", valid_612871
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612872: Call_SetDefaultPolicyVersion_612860; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ## 
  let valid = call_612872.validator(path, query, header, formData, body)
  let scheme = call_612872.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612872.url(scheme.get, call_612872.host, call_612872.base,
                         call_612872.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612872, url, valid)

proc call*(call_612873: Call_SetDefaultPolicyVersion_612860; policyName: string;
          policyVersionId: string): Recallable =
  ## setDefaultPolicyVersion
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ##   policyName: string (required)
  ##             : The policy name.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_612874 = newJObject()
  add(path_612874, "policyName", newJString(policyName))
  add(path_612874, "policyVersionId", newJString(policyVersionId))
  result = call_612873.call(path_612874, nil, nil, nil, nil)

var setDefaultPolicyVersion* = Call_SetDefaultPolicyVersion_612860(
    name: "setDefaultPolicyVersion", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_SetDefaultPolicyVersion_612861, base: "/",
    url: url_SetDefaultPolicyVersion_612862, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeletePolicyVersion_612845 = ref object of OpenApiRestCall_610658
proc url_DeletePolicyVersion_612847(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeletePolicyVersion_612846(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_612848 = path.getOrDefault("policyName")
  valid_612848 = validateParameter(valid_612848, JString, required = true,
                                 default = nil)
  if valid_612848 != nil:
    section.add "policyName", valid_612848
  var valid_612849 = path.getOrDefault("policyVersionId")
  valid_612849 = validateParameter(valid_612849, JString, required = true,
                                 default = nil)
  if valid_612849 != nil:
    section.add "policyVersionId", valid_612849
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612850 = header.getOrDefault("X-Amz-Signature")
  valid_612850 = validateParameter(valid_612850, JString, required = false,
                                 default = nil)
  if valid_612850 != nil:
    section.add "X-Amz-Signature", valid_612850
  var valid_612851 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612851 = validateParameter(valid_612851, JString, required = false,
                                 default = nil)
  if valid_612851 != nil:
    section.add "X-Amz-Content-Sha256", valid_612851
  var valid_612852 = header.getOrDefault("X-Amz-Date")
  valid_612852 = validateParameter(valid_612852, JString, required = false,
                                 default = nil)
  if valid_612852 != nil:
    section.add "X-Amz-Date", valid_612852
  var valid_612853 = header.getOrDefault("X-Amz-Credential")
  valid_612853 = validateParameter(valid_612853, JString, required = false,
                                 default = nil)
  if valid_612853 != nil:
    section.add "X-Amz-Credential", valid_612853
  var valid_612854 = header.getOrDefault("X-Amz-Security-Token")
  valid_612854 = validateParameter(valid_612854, JString, required = false,
                                 default = nil)
  if valid_612854 != nil:
    section.add "X-Amz-Security-Token", valid_612854
  var valid_612855 = header.getOrDefault("X-Amz-Algorithm")
  valid_612855 = validateParameter(valid_612855, JString, required = false,
                                 default = nil)
  if valid_612855 != nil:
    section.add "X-Amz-Algorithm", valid_612855
  var valid_612856 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612856 = validateParameter(valid_612856, JString, required = false,
                                 default = nil)
  if valid_612856 != nil:
    section.add "X-Amz-SignedHeaders", valid_612856
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612857: Call_DeletePolicyVersion_612845; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ## 
  let valid = call_612857.validator(path, query, header, formData, body)
  let scheme = call_612857.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612857.url(scheme.get, call_612857.host, call_612857.base,
                         call_612857.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612857, url, valid)

proc call*(call_612858: Call_DeletePolicyVersion_612845; policyName: string;
          policyVersionId: string): Recallable =
  ## deletePolicyVersion
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ##   policyName: string (required)
  ##             : The name of the policy.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_612859 = newJObject()
  add(path_612859, "policyName", newJString(policyName))
  add(path_612859, "policyVersionId", newJString(policyVersionId))
  result = call_612858.call(path_612859, nil, nil, nil, nil)

var deletePolicyVersion* = Call_DeletePolicyVersion_612845(
    name: "deletePolicyVersion", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_DeletePolicyVersion_612846, base: "/",
    url: url_DeletePolicyVersion_612847, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeProvisioningTemplate_612875 = ref object of OpenApiRestCall_610658
proc url_DescribeProvisioningTemplate_612877(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeProvisioningTemplate_612876(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_612878 = path.getOrDefault("templateName")
  valid_612878 = validateParameter(valid_612878, JString, required = true,
                                 default = nil)
  if valid_612878 != nil:
    section.add "templateName", valid_612878
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612879 = header.getOrDefault("X-Amz-Signature")
  valid_612879 = validateParameter(valid_612879, JString, required = false,
                                 default = nil)
  if valid_612879 != nil:
    section.add "X-Amz-Signature", valid_612879
  var valid_612880 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612880 = validateParameter(valid_612880, JString, required = false,
                                 default = nil)
  if valid_612880 != nil:
    section.add "X-Amz-Content-Sha256", valid_612880
  var valid_612881 = header.getOrDefault("X-Amz-Date")
  valid_612881 = validateParameter(valid_612881, JString, required = false,
                                 default = nil)
  if valid_612881 != nil:
    section.add "X-Amz-Date", valid_612881
  var valid_612882 = header.getOrDefault("X-Amz-Credential")
  valid_612882 = validateParameter(valid_612882, JString, required = false,
                                 default = nil)
  if valid_612882 != nil:
    section.add "X-Amz-Credential", valid_612882
  var valid_612883 = header.getOrDefault("X-Amz-Security-Token")
  valid_612883 = validateParameter(valid_612883, JString, required = false,
                                 default = nil)
  if valid_612883 != nil:
    section.add "X-Amz-Security-Token", valid_612883
  var valid_612884 = header.getOrDefault("X-Amz-Algorithm")
  valid_612884 = validateParameter(valid_612884, JString, required = false,
                                 default = nil)
  if valid_612884 != nil:
    section.add "X-Amz-Algorithm", valid_612884
  var valid_612885 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612885 = validateParameter(valid_612885, JString, required = false,
                                 default = nil)
  if valid_612885 != nil:
    section.add "X-Amz-SignedHeaders", valid_612885
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612886: Call_DescribeProvisioningTemplate_612875; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about a fleet provisioning template.
  ## 
  let valid = call_612886.validator(path, query, header, formData, body)
  let scheme = call_612886.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612886.url(scheme.get, call_612886.host, call_612886.base,
                         call_612886.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612886, url, valid)

proc call*(call_612887: Call_DescribeProvisioningTemplate_612875;
          templateName: string): Recallable =
  ## describeProvisioningTemplate
  ## Returns information about a fleet provisioning template.
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template.
  var path_612888 = newJObject()
  add(path_612888, "templateName", newJString(templateName))
  result = call_612887.call(path_612888, nil, nil, nil, nil)

var describeProvisioningTemplate* = Call_DescribeProvisioningTemplate_612875(
    name: "describeProvisioningTemplate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/provisioning-templates/{templateName}",
    validator: validate_DescribeProvisioningTemplate_612876, base: "/",
    url: url_DescribeProvisioningTemplate_612877,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateProvisioningTemplate_612903 = ref object of OpenApiRestCall_610658
proc url_UpdateProvisioningTemplate_612905(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateProvisioningTemplate_612904(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_612906 = path.getOrDefault("templateName")
  valid_612906 = validateParameter(valid_612906, JString, required = true,
                                 default = nil)
  if valid_612906 != nil:
    section.add "templateName", valid_612906
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612907 = header.getOrDefault("X-Amz-Signature")
  valid_612907 = validateParameter(valid_612907, JString, required = false,
                                 default = nil)
  if valid_612907 != nil:
    section.add "X-Amz-Signature", valid_612907
  var valid_612908 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612908 = validateParameter(valid_612908, JString, required = false,
                                 default = nil)
  if valid_612908 != nil:
    section.add "X-Amz-Content-Sha256", valid_612908
  var valid_612909 = header.getOrDefault("X-Amz-Date")
  valid_612909 = validateParameter(valid_612909, JString, required = false,
                                 default = nil)
  if valid_612909 != nil:
    section.add "X-Amz-Date", valid_612909
  var valid_612910 = header.getOrDefault("X-Amz-Credential")
  valid_612910 = validateParameter(valid_612910, JString, required = false,
                                 default = nil)
  if valid_612910 != nil:
    section.add "X-Amz-Credential", valid_612910
  var valid_612911 = header.getOrDefault("X-Amz-Security-Token")
  valid_612911 = validateParameter(valid_612911, JString, required = false,
                                 default = nil)
  if valid_612911 != nil:
    section.add "X-Amz-Security-Token", valid_612911
  var valid_612912 = header.getOrDefault("X-Amz-Algorithm")
  valid_612912 = validateParameter(valid_612912, JString, required = false,
                                 default = nil)
  if valid_612912 != nil:
    section.add "X-Amz-Algorithm", valid_612912
  var valid_612913 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612913 = validateParameter(valid_612913, JString, required = false,
                                 default = nil)
  if valid_612913 != nil:
    section.add "X-Amz-SignedHeaders", valid_612913
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_612915: Call_UpdateProvisioningTemplate_612903; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a fleet provisioning template.
  ## 
  let valid = call_612915.validator(path, query, header, formData, body)
  let scheme = call_612915.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612915.url(scheme.get, call_612915.host, call_612915.base,
                         call_612915.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612915, url, valid)

proc call*(call_612916: Call_UpdateProvisioningTemplate_612903; body: JsonNode;
          templateName: string): Recallable =
  ## updateProvisioningTemplate
  ## Updates a fleet provisioning template.
  ##   body: JObject (required)
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template.
  var path_612917 = newJObject()
  var body_612918 = newJObject()
  if body != nil:
    body_612918 = body
  add(path_612917, "templateName", newJString(templateName))
  result = call_612916.call(path_612917, nil, nil, nil, body_612918)

var updateProvisioningTemplate* = Call_UpdateProvisioningTemplate_612903(
    name: "updateProvisioningTemplate", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/provisioning-templates/{templateName}",
    validator: validate_UpdateProvisioningTemplate_612904, base: "/",
    url: url_UpdateProvisioningTemplate_612905,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteProvisioningTemplate_612889 = ref object of OpenApiRestCall_610658
proc url_DeleteProvisioningTemplate_612891(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteProvisioningTemplate_612890(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provision template to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_612892 = path.getOrDefault("templateName")
  valid_612892 = validateParameter(valid_612892, JString, required = true,
                                 default = nil)
  if valid_612892 != nil:
    section.add "templateName", valid_612892
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612893 = header.getOrDefault("X-Amz-Signature")
  valid_612893 = validateParameter(valid_612893, JString, required = false,
                                 default = nil)
  if valid_612893 != nil:
    section.add "X-Amz-Signature", valid_612893
  var valid_612894 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612894 = validateParameter(valid_612894, JString, required = false,
                                 default = nil)
  if valid_612894 != nil:
    section.add "X-Amz-Content-Sha256", valid_612894
  var valid_612895 = header.getOrDefault("X-Amz-Date")
  valid_612895 = validateParameter(valid_612895, JString, required = false,
                                 default = nil)
  if valid_612895 != nil:
    section.add "X-Amz-Date", valid_612895
  var valid_612896 = header.getOrDefault("X-Amz-Credential")
  valid_612896 = validateParameter(valid_612896, JString, required = false,
                                 default = nil)
  if valid_612896 != nil:
    section.add "X-Amz-Credential", valid_612896
  var valid_612897 = header.getOrDefault("X-Amz-Security-Token")
  valid_612897 = validateParameter(valid_612897, JString, required = false,
                                 default = nil)
  if valid_612897 != nil:
    section.add "X-Amz-Security-Token", valid_612897
  var valid_612898 = header.getOrDefault("X-Amz-Algorithm")
  valid_612898 = validateParameter(valid_612898, JString, required = false,
                                 default = nil)
  if valid_612898 != nil:
    section.add "X-Amz-Algorithm", valid_612898
  var valid_612899 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612899 = validateParameter(valid_612899, JString, required = false,
                                 default = nil)
  if valid_612899 != nil:
    section.add "X-Amz-SignedHeaders", valid_612899
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612900: Call_DeleteProvisioningTemplate_612889; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a fleet provisioning template.
  ## 
  let valid = call_612900.validator(path, query, header, formData, body)
  let scheme = call_612900.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612900.url(scheme.get, call_612900.host, call_612900.base,
                         call_612900.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612900, url, valid)

proc call*(call_612901: Call_DeleteProvisioningTemplate_612889;
          templateName: string): Recallable =
  ## deleteProvisioningTemplate
  ## Deletes a fleet provisioning template.
  ##   templateName: string (required)
  ##               : The name of the fleet provision template to delete.
  var path_612902 = newJObject()
  add(path_612902, "templateName", newJString(templateName))
  result = call_612901.call(path_612902, nil, nil, nil, nil)

var deleteProvisioningTemplate* = Call_DeleteProvisioningTemplate_612889(
    name: "deleteProvisioningTemplate", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/provisioning-templates/{templateName}",
    validator: validate_DeleteProvisioningTemplate_612890, base: "/",
    url: url_DeleteProvisioningTemplate_612891,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeProvisioningTemplateVersion_612919 = ref object of OpenApiRestCall_610658
proc url_DescribeProvisioningTemplateVersion_612921(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  assert "versionId" in path, "`versionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/versions/"),
               (kind: VariableSegment, value: "versionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeProvisioningTemplateVersion_612920(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about a fleet provisioning template version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The template name.
  ##   versionId: JInt (required)
  ##            : The fleet provisioning template version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_612922 = path.getOrDefault("templateName")
  valid_612922 = validateParameter(valid_612922, JString, required = true,
                                 default = nil)
  if valid_612922 != nil:
    section.add "templateName", valid_612922
  var valid_612923 = path.getOrDefault("versionId")
  valid_612923 = validateParameter(valid_612923, JInt, required = true, default = nil)
  if valid_612923 != nil:
    section.add "versionId", valid_612923
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612924 = header.getOrDefault("X-Amz-Signature")
  valid_612924 = validateParameter(valid_612924, JString, required = false,
                                 default = nil)
  if valid_612924 != nil:
    section.add "X-Amz-Signature", valid_612924
  var valid_612925 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612925 = validateParameter(valid_612925, JString, required = false,
                                 default = nil)
  if valid_612925 != nil:
    section.add "X-Amz-Content-Sha256", valid_612925
  var valid_612926 = header.getOrDefault("X-Amz-Date")
  valid_612926 = validateParameter(valid_612926, JString, required = false,
                                 default = nil)
  if valid_612926 != nil:
    section.add "X-Amz-Date", valid_612926
  var valid_612927 = header.getOrDefault("X-Amz-Credential")
  valid_612927 = validateParameter(valid_612927, JString, required = false,
                                 default = nil)
  if valid_612927 != nil:
    section.add "X-Amz-Credential", valid_612927
  var valid_612928 = header.getOrDefault("X-Amz-Security-Token")
  valid_612928 = validateParameter(valid_612928, JString, required = false,
                                 default = nil)
  if valid_612928 != nil:
    section.add "X-Amz-Security-Token", valid_612928
  var valid_612929 = header.getOrDefault("X-Amz-Algorithm")
  valid_612929 = validateParameter(valid_612929, JString, required = false,
                                 default = nil)
  if valid_612929 != nil:
    section.add "X-Amz-Algorithm", valid_612929
  var valid_612930 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612930 = validateParameter(valid_612930, JString, required = false,
                                 default = nil)
  if valid_612930 != nil:
    section.add "X-Amz-SignedHeaders", valid_612930
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612931: Call_DescribeProvisioningTemplateVersion_612919;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns information about a fleet provisioning template version.
  ## 
  let valid = call_612931.validator(path, query, header, formData, body)
  let scheme = call_612931.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612931.url(scheme.get, call_612931.host, call_612931.base,
                         call_612931.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612931, url, valid)

proc call*(call_612932: Call_DescribeProvisioningTemplateVersion_612919;
          templateName: string; versionId: int): Recallable =
  ## describeProvisioningTemplateVersion
  ## Returns information about a fleet provisioning template version.
  ##   templateName: string (required)
  ##               : The template name.
  ##   versionId: int (required)
  ##            : The fleet provisioning template version ID.
  var path_612933 = newJObject()
  add(path_612933, "templateName", newJString(templateName))
  add(path_612933, "versionId", newJInt(versionId))
  result = call_612932.call(path_612933, nil, nil, nil, nil)

var describeProvisioningTemplateVersion* = Call_DescribeProvisioningTemplateVersion_612919(
    name: "describeProvisioningTemplateVersion", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/versions/{versionId}",
    validator: validate_DescribeProvisioningTemplateVersion_612920, base: "/",
    url: url_DescribeProvisioningTemplateVersion_612921,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteProvisioningTemplateVersion_612934 = ref object of OpenApiRestCall_610658
proc url_DeleteProvisioningTemplateVersion_612936(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  assert "versionId" in path, "`versionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/versions/"),
               (kind: VariableSegment, value: "versionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteProvisioningTemplateVersion_612935(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a fleet provisioning template version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template version to delete.
  ##   versionId: JInt (required)
  ##            : The fleet provisioning template version ID to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_612937 = path.getOrDefault("templateName")
  valid_612937 = validateParameter(valid_612937, JString, required = true,
                                 default = nil)
  if valid_612937 != nil:
    section.add "templateName", valid_612937
  var valid_612938 = path.getOrDefault("versionId")
  valid_612938 = validateParameter(valid_612938, JInt, required = true, default = nil)
  if valid_612938 != nil:
    section.add "versionId", valid_612938
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612939 = header.getOrDefault("X-Amz-Signature")
  valid_612939 = validateParameter(valid_612939, JString, required = false,
                                 default = nil)
  if valid_612939 != nil:
    section.add "X-Amz-Signature", valid_612939
  var valid_612940 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612940 = validateParameter(valid_612940, JString, required = false,
                                 default = nil)
  if valid_612940 != nil:
    section.add "X-Amz-Content-Sha256", valid_612940
  var valid_612941 = header.getOrDefault("X-Amz-Date")
  valid_612941 = validateParameter(valid_612941, JString, required = false,
                                 default = nil)
  if valid_612941 != nil:
    section.add "X-Amz-Date", valid_612941
  var valid_612942 = header.getOrDefault("X-Amz-Credential")
  valid_612942 = validateParameter(valid_612942, JString, required = false,
                                 default = nil)
  if valid_612942 != nil:
    section.add "X-Amz-Credential", valid_612942
  var valid_612943 = header.getOrDefault("X-Amz-Security-Token")
  valid_612943 = validateParameter(valid_612943, JString, required = false,
                                 default = nil)
  if valid_612943 != nil:
    section.add "X-Amz-Security-Token", valid_612943
  var valid_612944 = header.getOrDefault("X-Amz-Algorithm")
  valid_612944 = validateParameter(valid_612944, JString, required = false,
                                 default = nil)
  if valid_612944 != nil:
    section.add "X-Amz-Algorithm", valid_612944
  var valid_612945 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612945 = validateParameter(valid_612945, JString, required = false,
                                 default = nil)
  if valid_612945 != nil:
    section.add "X-Amz-SignedHeaders", valid_612945
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612946: Call_DeleteProvisioningTemplateVersion_612934;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes a fleet provisioning template version.
  ## 
  let valid = call_612946.validator(path, query, header, formData, body)
  let scheme = call_612946.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612946.url(scheme.get, call_612946.host, call_612946.base,
                         call_612946.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612946, url, valid)

proc call*(call_612947: Call_DeleteProvisioningTemplateVersion_612934;
          templateName: string; versionId: int): Recallable =
  ## deleteProvisioningTemplateVersion
  ## Deletes a fleet provisioning template version.
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template version to delete.
  ##   versionId: int (required)
  ##            : The fleet provisioning template version ID to delete.
  var path_612948 = newJObject()
  add(path_612948, "templateName", newJString(templateName))
  add(path_612948, "versionId", newJInt(versionId))
  result = call_612947.call(path_612948, nil, nil, nil, nil)

var deleteProvisioningTemplateVersion* = Call_DeleteProvisioningTemplateVersion_612934(
    name: "deleteProvisioningTemplateVersion", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/versions/{versionId}",
    validator: validate_DeleteProvisioningTemplateVersion_612935, base: "/",
    url: url_DeleteProvisioningTemplateVersion_612936,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRegistrationCode_612949 = ref object of OpenApiRestCall_610658
proc url_GetRegistrationCode_612951(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRegistrationCode_612950(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612952 = header.getOrDefault("X-Amz-Signature")
  valid_612952 = validateParameter(valid_612952, JString, required = false,
                                 default = nil)
  if valid_612952 != nil:
    section.add "X-Amz-Signature", valid_612952
  var valid_612953 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612953 = validateParameter(valid_612953, JString, required = false,
                                 default = nil)
  if valid_612953 != nil:
    section.add "X-Amz-Content-Sha256", valid_612953
  var valid_612954 = header.getOrDefault("X-Amz-Date")
  valid_612954 = validateParameter(valid_612954, JString, required = false,
                                 default = nil)
  if valid_612954 != nil:
    section.add "X-Amz-Date", valid_612954
  var valid_612955 = header.getOrDefault("X-Amz-Credential")
  valid_612955 = validateParameter(valid_612955, JString, required = false,
                                 default = nil)
  if valid_612955 != nil:
    section.add "X-Amz-Credential", valid_612955
  var valid_612956 = header.getOrDefault("X-Amz-Security-Token")
  valid_612956 = validateParameter(valid_612956, JString, required = false,
                                 default = nil)
  if valid_612956 != nil:
    section.add "X-Amz-Security-Token", valid_612956
  var valid_612957 = header.getOrDefault("X-Amz-Algorithm")
  valid_612957 = validateParameter(valid_612957, JString, required = false,
                                 default = nil)
  if valid_612957 != nil:
    section.add "X-Amz-Algorithm", valid_612957
  var valid_612958 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612958 = validateParameter(valid_612958, JString, required = false,
                                 default = nil)
  if valid_612958 != nil:
    section.add "X-Amz-SignedHeaders", valid_612958
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612959: Call_GetRegistrationCode_612949; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  ## 
  let valid = call_612959.validator(path, query, header, formData, body)
  let scheme = call_612959.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612959.url(scheme.get, call_612959.host, call_612959.base,
                         call_612959.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612959, url, valid)

proc call*(call_612960: Call_GetRegistrationCode_612949): Recallable =
  ## getRegistrationCode
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  result = call_612960.call(nil, nil, nil, nil, nil)

var getRegistrationCode* = Call_GetRegistrationCode_612949(
    name: "getRegistrationCode", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/registrationcode",
    validator: validate_GetRegistrationCode_612950, base: "/",
    url: url_GetRegistrationCode_612951, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRegistrationCode_612961 = ref object of OpenApiRestCall_610658
proc url_DeleteRegistrationCode_612963(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteRegistrationCode_612962(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a CA certificate registration code.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612964 = header.getOrDefault("X-Amz-Signature")
  valid_612964 = validateParameter(valid_612964, JString, required = false,
                                 default = nil)
  if valid_612964 != nil:
    section.add "X-Amz-Signature", valid_612964
  var valid_612965 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612965 = validateParameter(valid_612965, JString, required = false,
                                 default = nil)
  if valid_612965 != nil:
    section.add "X-Amz-Content-Sha256", valid_612965
  var valid_612966 = header.getOrDefault("X-Amz-Date")
  valid_612966 = validateParameter(valid_612966, JString, required = false,
                                 default = nil)
  if valid_612966 != nil:
    section.add "X-Amz-Date", valid_612966
  var valid_612967 = header.getOrDefault("X-Amz-Credential")
  valid_612967 = validateParameter(valid_612967, JString, required = false,
                                 default = nil)
  if valid_612967 != nil:
    section.add "X-Amz-Credential", valid_612967
  var valid_612968 = header.getOrDefault("X-Amz-Security-Token")
  valid_612968 = validateParameter(valid_612968, JString, required = false,
                                 default = nil)
  if valid_612968 != nil:
    section.add "X-Amz-Security-Token", valid_612968
  var valid_612969 = header.getOrDefault("X-Amz-Algorithm")
  valid_612969 = validateParameter(valid_612969, JString, required = false,
                                 default = nil)
  if valid_612969 != nil:
    section.add "X-Amz-Algorithm", valid_612969
  var valid_612970 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612970 = validateParameter(valid_612970, JString, required = false,
                                 default = nil)
  if valid_612970 != nil:
    section.add "X-Amz-SignedHeaders", valid_612970
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612971: Call_DeleteRegistrationCode_612961; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a CA certificate registration code.
  ## 
  let valid = call_612971.validator(path, query, header, formData, body)
  let scheme = call_612971.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612971.url(scheme.get, call_612971.host, call_612971.base,
                         call_612971.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612971, url, valid)

proc call*(call_612972: Call_DeleteRegistrationCode_612961): Recallable =
  ## deleteRegistrationCode
  ## Deletes a CA certificate registration code.
  result = call_612972.call(nil, nil, nil, nil, nil)

var deleteRegistrationCode* = Call_DeleteRegistrationCode_612961(
    name: "deleteRegistrationCode", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/registrationcode",
    validator: validate_DeleteRegistrationCode_612962, base: "/",
    url: url_DeleteRegistrationCode_612963, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetTopicRuleDestination_612973 = ref object of OpenApiRestCall_610658
proc url_GetTopicRuleDestination_612975(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "arn" in path, "`arn` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/destinations/"),
               (kind: VariableSegment, value: "arn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTopicRuleDestination_612974(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a topic rule destination.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   arn: JString (required)
  ##      : The ARN of the topic rule destination.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `arn` field"
  var valid_612976 = path.getOrDefault("arn")
  valid_612976 = validateParameter(valid_612976, JString, required = true,
                                 default = nil)
  if valid_612976 != nil:
    section.add "arn", valid_612976
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612977 = header.getOrDefault("X-Amz-Signature")
  valid_612977 = validateParameter(valid_612977, JString, required = false,
                                 default = nil)
  if valid_612977 != nil:
    section.add "X-Amz-Signature", valid_612977
  var valid_612978 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612978 = validateParameter(valid_612978, JString, required = false,
                                 default = nil)
  if valid_612978 != nil:
    section.add "X-Amz-Content-Sha256", valid_612978
  var valid_612979 = header.getOrDefault("X-Amz-Date")
  valid_612979 = validateParameter(valid_612979, JString, required = false,
                                 default = nil)
  if valid_612979 != nil:
    section.add "X-Amz-Date", valid_612979
  var valid_612980 = header.getOrDefault("X-Amz-Credential")
  valid_612980 = validateParameter(valid_612980, JString, required = false,
                                 default = nil)
  if valid_612980 != nil:
    section.add "X-Amz-Credential", valid_612980
  var valid_612981 = header.getOrDefault("X-Amz-Security-Token")
  valid_612981 = validateParameter(valid_612981, JString, required = false,
                                 default = nil)
  if valid_612981 != nil:
    section.add "X-Amz-Security-Token", valid_612981
  var valid_612982 = header.getOrDefault("X-Amz-Algorithm")
  valid_612982 = validateParameter(valid_612982, JString, required = false,
                                 default = nil)
  if valid_612982 != nil:
    section.add "X-Amz-Algorithm", valid_612982
  var valid_612983 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612983 = validateParameter(valid_612983, JString, required = false,
                                 default = nil)
  if valid_612983 != nil:
    section.add "X-Amz-SignedHeaders", valid_612983
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612984: Call_GetTopicRuleDestination_612973; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a topic rule destination.
  ## 
  let valid = call_612984.validator(path, query, header, formData, body)
  let scheme = call_612984.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612984.url(scheme.get, call_612984.host, call_612984.base,
                         call_612984.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612984, url, valid)

proc call*(call_612985: Call_GetTopicRuleDestination_612973; arn: string): Recallable =
  ## getTopicRuleDestination
  ## Gets information about a topic rule destination.
  ##   arn: string (required)
  ##      : The ARN of the topic rule destination.
  var path_612986 = newJObject()
  add(path_612986, "arn", newJString(arn))
  result = call_612985.call(path_612986, nil, nil, nil, nil)

var getTopicRuleDestination* = Call_GetTopicRuleDestination_612973(
    name: "getTopicRuleDestination", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/destinations/{arn}",
    validator: validate_GetTopicRuleDestination_612974, base: "/",
    url: url_GetTopicRuleDestination_612975, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteTopicRuleDestination_612987 = ref object of OpenApiRestCall_610658
proc url_DeleteTopicRuleDestination_612989(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "arn" in path, "`arn` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/destinations/"),
               (kind: VariableSegment, value: "arn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTopicRuleDestination_612988(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a topic rule destination.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   arn: JString (required)
  ##      : The ARN of the topic rule destination to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `arn` field"
  var valid_612990 = path.getOrDefault("arn")
  valid_612990 = validateParameter(valid_612990, JString, required = true,
                                 default = nil)
  if valid_612990 != nil:
    section.add "arn", valid_612990
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_612991 = header.getOrDefault("X-Amz-Signature")
  valid_612991 = validateParameter(valid_612991, JString, required = false,
                                 default = nil)
  if valid_612991 != nil:
    section.add "X-Amz-Signature", valid_612991
  var valid_612992 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_612992 = validateParameter(valid_612992, JString, required = false,
                                 default = nil)
  if valid_612992 != nil:
    section.add "X-Amz-Content-Sha256", valid_612992
  var valid_612993 = header.getOrDefault("X-Amz-Date")
  valid_612993 = validateParameter(valid_612993, JString, required = false,
                                 default = nil)
  if valid_612993 != nil:
    section.add "X-Amz-Date", valid_612993
  var valid_612994 = header.getOrDefault("X-Amz-Credential")
  valid_612994 = validateParameter(valid_612994, JString, required = false,
                                 default = nil)
  if valid_612994 != nil:
    section.add "X-Amz-Credential", valid_612994
  var valid_612995 = header.getOrDefault("X-Amz-Security-Token")
  valid_612995 = validateParameter(valid_612995, JString, required = false,
                                 default = nil)
  if valid_612995 != nil:
    section.add "X-Amz-Security-Token", valid_612995
  var valid_612996 = header.getOrDefault("X-Amz-Algorithm")
  valid_612996 = validateParameter(valid_612996, JString, required = false,
                                 default = nil)
  if valid_612996 != nil:
    section.add "X-Amz-Algorithm", valid_612996
  var valid_612997 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_612997 = validateParameter(valid_612997, JString, required = false,
                                 default = nil)
  if valid_612997 != nil:
    section.add "X-Amz-SignedHeaders", valid_612997
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_612998: Call_DeleteTopicRuleDestination_612987; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a topic rule destination.
  ## 
  let valid = call_612998.validator(path, query, header, formData, body)
  let scheme = call_612998.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_612998.url(scheme.get, call_612998.host, call_612998.base,
                         call_612998.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_612998, url, valid)

proc call*(call_612999: Call_DeleteTopicRuleDestination_612987; arn: string): Recallable =
  ## deleteTopicRuleDestination
  ## Deletes a topic rule destination.
  ##   arn: string (required)
  ##      : The ARN of the topic rule destination to delete.
  var path_613000 = newJObject()
  add(path_613000, "arn", newJString(arn))
  result = call_612999.call(path_613000, nil, nil, nil, nil)

var deleteTopicRuleDestination* = Call_DeleteTopicRuleDestination_612987(
    name: "deleteTopicRuleDestination", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/destinations/{arn}",
    validator: validate_DeleteTopicRuleDestination_612988, base: "/",
    url: url_DeleteTopicRuleDestination_612989,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteV2LoggingLevel_613001 = ref object of OpenApiRestCall_610658
proc url_DeleteV2LoggingLevel_613003(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteV2LoggingLevel_613002(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a logging level.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   targetName: JString (required)
  ##             : The name of the resource for which you are configuring logging.
  ##   targetType: JString (required)
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `targetName` field"
  var valid_613004 = query.getOrDefault("targetName")
  valid_613004 = validateParameter(valid_613004, JString, required = true,
                                 default = nil)
  if valid_613004 != nil:
    section.add "targetName", valid_613004
  var valid_613005 = query.getOrDefault("targetType")
  valid_613005 = validateParameter(valid_613005, JString, required = true,
                                 default = newJString("DEFAULT"))
  if valid_613005 != nil:
    section.add "targetType", valid_613005
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613006 = header.getOrDefault("X-Amz-Signature")
  valid_613006 = validateParameter(valid_613006, JString, required = false,
                                 default = nil)
  if valid_613006 != nil:
    section.add "X-Amz-Signature", valid_613006
  var valid_613007 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613007 = validateParameter(valid_613007, JString, required = false,
                                 default = nil)
  if valid_613007 != nil:
    section.add "X-Amz-Content-Sha256", valid_613007
  var valid_613008 = header.getOrDefault("X-Amz-Date")
  valid_613008 = validateParameter(valid_613008, JString, required = false,
                                 default = nil)
  if valid_613008 != nil:
    section.add "X-Amz-Date", valid_613008
  var valid_613009 = header.getOrDefault("X-Amz-Credential")
  valid_613009 = validateParameter(valid_613009, JString, required = false,
                                 default = nil)
  if valid_613009 != nil:
    section.add "X-Amz-Credential", valid_613009
  var valid_613010 = header.getOrDefault("X-Amz-Security-Token")
  valid_613010 = validateParameter(valid_613010, JString, required = false,
                                 default = nil)
  if valid_613010 != nil:
    section.add "X-Amz-Security-Token", valid_613010
  var valid_613011 = header.getOrDefault("X-Amz-Algorithm")
  valid_613011 = validateParameter(valid_613011, JString, required = false,
                                 default = nil)
  if valid_613011 != nil:
    section.add "X-Amz-Algorithm", valid_613011
  var valid_613012 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613012 = validateParameter(valid_613012, JString, required = false,
                                 default = nil)
  if valid_613012 != nil:
    section.add "X-Amz-SignedHeaders", valid_613012
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613013: Call_DeleteV2LoggingLevel_613001; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a logging level.
  ## 
  let valid = call_613013.validator(path, query, header, formData, body)
  let scheme = call_613013.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613013.url(scheme.get, call_613013.host, call_613013.base,
                         call_613013.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613013, url, valid)

proc call*(call_613014: Call_DeleteV2LoggingLevel_613001; targetName: string;
          targetType: string = "DEFAULT"): Recallable =
  ## deleteV2LoggingLevel
  ## Deletes a logging level.
  ##   targetName: string (required)
  ##             : The name of the resource for which you are configuring logging.
  ##   targetType: string (required)
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  var query_613015 = newJObject()
  add(query_613015, "targetName", newJString(targetName))
  add(query_613015, "targetType", newJString(targetType))
  result = call_613014.call(nil, query_613015, nil, nil, nil)

var deleteV2LoggingLevel* = Call_DeleteV2LoggingLevel_613001(
    name: "deleteV2LoggingLevel", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/v2LoggingLevel#targetType&targetName",
    validator: validate_DeleteV2LoggingLevel_613002, base: "/",
    url: url_DeleteV2LoggingLevel_613003, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeprecateThingType_613016 = ref object of OpenApiRestCall_610658
proc url_DeprecateThingType_613018(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName"),
               (kind: ConstantSegment, value: "/deprecate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeprecateThingType_613017(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type to deprecate.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_613019 = path.getOrDefault("thingTypeName")
  valid_613019 = validateParameter(valid_613019, JString, required = true,
                                 default = nil)
  if valid_613019 != nil:
    section.add "thingTypeName", valid_613019
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613020 = header.getOrDefault("X-Amz-Signature")
  valid_613020 = validateParameter(valid_613020, JString, required = false,
                                 default = nil)
  if valid_613020 != nil:
    section.add "X-Amz-Signature", valid_613020
  var valid_613021 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613021 = validateParameter(valid_613021, JString, required = false,
                                 default = nil)
  if valid_613021 != nil:
    section.add "X-Amz-Content-Sha256", valid_613021
  var valid_613022 = header.getOrDefault("X-Amz-Date")
  valid_613022 = validateParameter(valid_613022, JString, required = false,
                                 default = nil)
  if valid_613022 != nil:
    section.add "X-Amz-Date", valid_613022
  var valid_613023 = header.getOrDefault("X-Amz-Credential")
  valid_613023 = validateParameter(valid_613023, JString, required = false,
                                 default = nil)
  if valid_613023 != nil:
    section.add "X-Amz-Credential", valid_613023
  var valid_613024 = header.getOrDefault("X-Amz-Security-Token")
  valid_613024 = validateParameter(valid_613024, JString, required = false,
                                 default = nil)
  if valid_613024 != nil:
    section.add "X-Amz-Security-Token", valid_613024
  var valid_613025 = header.getOrDefault("X-Amz-Algorithm")
  valid_613025 = validateParameter(valid_613025, JString, required = false,
                                 default = nil)
  if valid_613025 != nil:
    section.add "X-Amz-Algorithm", valid_613025
  var valid_613026 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613026 = validateParameter(valid_613026, JString, required = false,
                                 default = nil)
  if valid_613026 != nil:
    section.add "X-Amz-SignedHeaders", valid_613026
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613028: Call_DeprecateThingType_613016; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ## 
  let valid = call_613028.validator(path, query, header, formData, body)
  let scheme = call_613028.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613028.url(scheme.get, call_613028.host, call_613028.base,
                         call_613028.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613028, url, valid)

proc call*(call_613029: Call_DeprecateThingType_613016; thingTypeName: string;
          body: JsonNode): Recallable =
  ## deprecateThingType
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type to deprecate.
  ##   body: JObject (required)
  var path_613030 = newJObject()
  var body_613031 = newJObject()
  add(path_613030, "thingTypeName", newJString(thingTypeName))
  if body != nil:
    body_613031 = body
  result = call_613029.call(path_613030, nil, nil, nil, body_613031)

var deprecateThingType* = Call_DeprecateThingType_613016(
    name: "deprecateThingType", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/thing-types/{thingTypeName}/deprecate",
    validator: validate_DeprecateThingType_613017, base: "/",
    url: url_DeprecateThingType_613018, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditFinding_613032 = ref object of OpenApiRestCall_610658
proc url_DescribeAuditFinding_613034(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "findingId" in path, "`findingId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/findings/"),
               (kind: VariableSegment, value: "findingId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuditFinding_613033(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   findingId: JString (required)
  ##            : A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `findingId` field"
  var valid_613035 = path.getOrDefault("findingId")
  valid_613035 = validateParameter(valid_613035, JString, required = true,
                                 default = nil)
  if valid_613035 != nil:
    section.add "findingId", valid_613035
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613036 = header.getOrDefault("X-Amz-Signature")
  valid_613036 = validateParameter(valid_613036, JString, required = false,
                                 default = nil)
  if valid_613036 != nil:
    section.add "X-Amz-Signature", valid_613036
  var valid_613037 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613037 = validateParameter(valid_613037, JString, required = false,
                                 default = nil)
  if valid_613037 != nil:
    section.add "X-Amz-Content-Sha256", valid_613037
  var valid_613038 = header.getOrDefault("X-Amz-Date")
  valid_613038 = validateParameter(valid_613038, JString, required = false,
                                 default = nil)
  if valid_613038 != nil:
    section.add "X-Amz-Date", valid_613038
  var valid_613039 = header.getOrDefault("X-Amz-Credential")
  valid_613039 = validateParameter(valid_613039, JString, required = false,
                                 default = nil)
  if valid_613039 != nil:
    section.add "X-Amz-Credential", valid_613039
  var valid_613040 = header.getOrDefault("X-Amz-Security-Token")
  valid_613040 = validateParameter(valid_613040, JString, required = false,
                                 default = nil)
  if valid_613040 != nil:
    section.add "X-Amz-Security-Token", valid_613040
  var valid_613041 = header.getOrDefault("X-Amz-Algorithm")
  valid_613041 = validateParameter(valid_613041, JString, required = false,
                                 default = nil)
  if valid_613041 != nil:
    section.add "X-Amz-Algorithm", valid_613041
  var valid_613042 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613042 = validateParameter(valid_613042, JString, required = false,
                                 default = nil)
  if valid_613042 != nil:
    section.add "X-Amz-SignedHeaders", valid_613042
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613043: Call_DescribeAuditFinding_613032; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ## 
  let valid = call_613043.validator(path, query, header, formData, body)
  let scheme = call_613043.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613043.url(scheme.get, call_613043.host, call_613043.base,
                         call_613043.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613043, url, valid)

proc call*(call_613044: Call_DescribeAuditFinding_613032; findingId: string): Recallable =
  ## describeAuditFinding
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ##   findingId: string (required)
  ##            : A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
  var path_613045 = newJObject()
  add(path_613045, "findingId", newJString(findingId))
  result = call_613044.call(path_613045, nil, nil, nil, nil)

var describeAuditFinding* = Call_DescribeAuditFinding_613032(
    name: "describeAuditFinding", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/findings/{findingId}",
    validator: validate_DescribeAuditFinding_613033, base: "/",
    url: url_DescribeAuditFinding_613034, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartAuditMitigationActionsTask_613060 = ref object of OpenApiRestCall_610658
proc url_StartAuditMitigationActionsTask_613062(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_StartAuditMitigationActionsTask_613061(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_613063 = path.getOrDefault("taskId")
  valid_613063 = validateParameter(valid_613063, JString, required = true,
                                 default = nil)
  if valid_613063 != nil:
    section.add "taskId", valid_613063
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613064 = header.getOrDefault("X-Amz-Signature")
  valid_613064 = validateParameter(valid_613064, JString, required = false,
                                 default = nil)
  if valid_613064 != nil:
    section.add "X-Amz-Signature", valid_613064
  var valid_613065 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613065 = validateParameter(valid_613065, JString, required = false,
                                 default = nil)
  if valid_613065 != nil:
    section.add "X-Amz-Content-Sha256", valid_613065
  var valid_613066 = header.getOrDefault("X-Amz-Date")
  valid_613066 = validateParameter(valid_613066, JString, required = false,
                                 default = nil)
  if valid_613066 != nil:
    section.add "X-Amz-Date", valid_613066
  var valid_613067 = header.getOrDefault("X-Amz-Credential")
  valid_613067 = validateParameter(valid_613067, JString, required = false,
                                 default = nil)
  if valid_613067 != nil:
    section.add "X-Amz-Credential", valid_613067
  var valid_613068 = header.getOrDefault("X-Amz-Security-Token")
  valid_613068 = validateParameter(valid_613068, JString, required = false,
                                 default = nil)
  if valid_613068 != nil:
    section.add "X-Amz-Security-Token", valid_613068
  var valid_613069 = header.getOrDefault("X-Amz-Algorithm")
  valid_613069 = validateParameter(valid_613069, JString, required = false,
                                 default = nil)
  if valid_613069 != nil:
    section.add "X-Amz-Algorithm", valid_613069
  var valid_613070 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613070 = validateParameter(valid_613070, JString, required = false,
                                 default = nil)
  if valid_613070 != nil:
    section.add "X-Amz-SignedHeaders", valid_613070
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613072: Call_StartAuditMitigationActionsTask_613060;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ## 
  let valid = call_613072.validator(path, query, header, formData, body)
  let scheme = call_613072.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613072.url(scheme.get, call_613072.host, call_613072.base,
                         call_613072.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613072, url, valid)

proc call*(call_613073: Call_StartAuditMitigationActionsTask_613060;
          body: JsonNode; taskId: string): Recallable =
  ## startAuditMitigationActionsTask
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ##   body: JObject (required)
  ##   taskId: string (required)
  ##         : A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
  var path_613074 = newJObject()
  var body_613075 = newJObject()
  if body != nil:
    body_613075 = body
  add(path_613074, "taskId", newJString(taskId))
  result = call_613073.call(path_613074, nil, nil, nil, body_613075)

var startAuditMitigationActionsTask* = Call_StartAuditMitigationActionsTask_613060(
    name: "startAuditMitigationActionsTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/audit/mitigationactions/tasks/{taskId}",
    validator: validate_StartAuditMitigationActionsTask_613061, base: "/",
    url: url_StartAuditMitigationActionsTask_613062,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditMitigationActionsTask_613046 = ref object of OpenApiRestCall_610658
proc url_DescribeAuditMitigationActionsTask_613048(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuditMitigationActionsTask_613047(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The unique identifier for the audit mitigation task.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_613049 = path.getOrDefault("taskId")
  valid_613049 = validateParameter(valid_613049, JString, required = true,
                                 default = nil)
  if valid_613049 != nil:
    section.add "taskId", valid_613049
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613050 = header.getOrDefault("X-Amz-Signature")
  valid_613050 = validateParameter(valid_613050, JString, required = false,
                                 default = nil)
  if valid_613050 != nil:
    section.add "X-Amz-Signature", valid_613050
  var valid_613051 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613051 = validateParameter(valid_613051, JString, required = false,
                                 default = nil)
  if valid_613051 != nil:
    section.add "X-Amz-Content-Sha256", valid_613051
  var valid_613052 = header.getOrDefault("X-Amz-Date")
  valid_613052 = validateParameter(valid_613052, JString, required = false,
                                 default = nil)
  if valid_613052 != nil:
    section.add "X-Amz-Date", valid_613052
  var valid_613053 = header.getOrDefault("X-Amz-Credential")
  valid_613053 = validateParameter(valid_613053, JString, required = false,
                                 default = nil)
  if valid_613053 != nil:
    section.add "X-Amz-Credential", valid_613053
  var valid_613054 = header.getOrDefault("X-Amz-Security-Token")
  valid_613054 = validateParameter(valid_613054, JString, required = false,
                                 default = nil)
  if valid_613054 != nil:
    section.add "X-Amz-Security-Token", valid_613054
  var valid_613055 = header.getOrDefault("X-Amz-Algorithm")
  valid_613055 = validateParameter(valid_613055, JString, required = false,
                                 default = nil)
  if valid_613055 != nil:
    section.add "X-Amz-Algorithm", valid_613055
  var valid_613056 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613056 = validateParameter(valid_613056, JString, required = false,
                                 default = nil)
  if valid_613056 != nil:
    section.add "X-Amz-SignedHeaders", valid_613056
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613057: Call_DescribeAuditMitigationActionsTask_613046;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ## 
  let valid = call_613057.validator(path, query, header, formData, body)
  let scheme = call_613057.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613057.url(scheme.get, call_613057.host, call_613057.base,
                         call_613057.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613057, url, valid)

proc call*(call_613058: Call_DescribeAuditMitigationActionsTask_613046;
          taskId: string): Recallable =
  ## describeAuditMitigationActionsTask
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ##   taskId: string (required)
  ##         : The unique identifier for the audit mitigation task.
  var path_613059 = newJObject()
  add(path_613059, "taskId", newJString(taskId))
  result = call_613058.call(path_613059, nil, nil, nil, nil)

var describeAuditMitigationActionsTask* = Call_DescribeAuditMitigationActionsTask_613046(
    name: "describeAuditMitigationActionsTask", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/mitigationactions/tasks/{taskId}",
    validator: validate_DescribeAuditMitigationActionsTask_613047, base: "/",
    url: url_DescribeAuditMitigationActionsTask_613048,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditTask_613076 = ref object of OpenApiRestCall_610658
proc url_DescribeAuditTask_613078(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuditTask_613077(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Gets information about a Device Defender audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The ID of the audit whose information you want to get.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_613079 = path.getOrDefault("taskId")
  valid_613079 = validateParameter(valid_613079, JString, required = true,
                                 default = nil)
  if valid_613079 != nil:
    section.add "taskId", valid_613079
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613080 = header.getOrDefault("X-Amz-Signature")
  valid_613080 = validateParameter(valid_613080, JString, required = false,
                                 default = nil)
  if valid_613080 != nil:
    section.add "X-Amz-Signature", valid_613080
  var valid_613081 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613081 = validateParameter(valid_613081, JString, required = false,
                                 default = nil)
  if valid_613081 != nil:
    section.add "X-Amz-Content-Sha256", valid_613081
  var valid_613082 = header.getOrDefault("X-Amz-Date")
  valid_613082 = validateParameter(valid_613082, JString, required = false,
                                 default = nil)
  if valid_613082 != nil:
    section.add "X-Amz-Date", valid_613082
  var valid_613083 = header.getOrDefault("X-Amz-Credential")
  valid_613083 = validateParameter(valid_613083, JString, required = false,
                                 default = nil)
  if valid_613083 != nil:
    section.add "X-Amz-Credential", valid_613083
  var valid_613084 = header.getOrDefault("X-Amz-Security-Token")
  valid_613084 = validateParameter(valid_613084, JString, required = false,
                                 default = nil)
  if valid_613084 != nil:
    section.add "X-Amz-Security-Token", valid_613084
  var valid_613085 = header.getOrDefault("X-Amz-Algorithm")
  valid_613085 = validateParameter(valid_613085, JString, required = false,
                                 default = nil)
  if valid_613085 != nil:
    section.add "X-Amz-Algorithm", valid_613085
  var valid_613086 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613086 = validateParameter(valid_613086, JString, required = false,
                                 default = nil)
  if valid_613086 != nil:
    section.add "X-Amz-SignedHeaders", valid_613086
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613087: Call_DescribeAuditTask_613076; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a Device Defender audit.
  ## 
  let valid = call_613087.validator(path, query, header, formData, body)
  let scheme = call_613087.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613087.url(scheme.get, call_613087.host, call_613087.base,
                         call_613087.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613087, url, valid)

proc call*(call_613088: Call_DescribeAuditTask_613076; taskId: string): Recallable =
  ## describeAuditTask
  ## Gets information about a Device Defender audit.
  ##   taskId: string (required)
  ##         : The ID of the audit whose information you want to get.
  var path_613089 = newJObject()
  add(path_613089, "taskId", newJString(taskId))
  result = call_613088.call(path_613089, nil, nil, nil, nil)

var describeAuditTask* = Call_DescribeAuditTask_613076(name: "describeAuditTask",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/audit/tasks/{taskId}", validator: validate_DescribeAuditTask_613077,
    base: "/", url: url_DescribeAuditTask_613078,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeEndpoint_613090 = ref object of OpenApiRestCall_610658
proc url_DescribeEndpoint_613092(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeEndpoint_613091(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Returns a unique endpoint specific to the AWS account making the call.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endpointType: JString
  ##               : <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
  section = newJObject()
  var valid_613093 = query.getOrDefault("endpointType")
  valid_613093 = validateParameter(valid_613093, JString, required = false,
                                 default = nil)
  if valid_613093 != nil:
    section.add "endpointType", valid_613093
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613094 = header.getOrDefault("X-Amz-Signature")
  valid_613094 = validateParameter(valid_613094, JString, required = false,
                                 default = nil)
  if valid_613094 != nil:
    section.add "X-Amz-Signature", valid_613094
  var valid_613095 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613095 = validateParameter(valid_613095, JString, required = false,
                                 default = nil)
  if valid_613095 != nil:
    section.add "X-Amz-Content-Sha256", valid_613095
  var valid_613096 = header.getOrDefault("X-Amz-Date")
  valid_613096 = validateParameter(valid_613096, JString, required = false,
                                 default = nil)
  if valid_613096 != nil:
    section.add "X-Amz-Date", valid_613096
  var valid_613097 = header.getOrDefault("X-Amz-Credential")
  valid_613097 = validateParameter(valid_613097, JString, required = false,
                                 default = nil)
  if valid_613097 != nil:
    section.add "X-Amz-Credential", valid_613097
  var valid_613098 = header.getOrDefault("X-Amz-Security-Token")
  valid_613098 = validateParameter(valid_613098, JString, required = false,
                                 default = nil)
  if valid_613098 != nil:
    section.add "X-Amz-Security-Token", valid_613098
  var valid_613099 = header.getOrDefault("X-Amz-Algorithm")
  valid_613099 = validateParameter(valid_613099, JString, required = false,
                                 default = nil)
  if valid_613099 != nil:
    section.add "X-Amz-Algorithm", valid_613099
  var valid_613100 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613100 = validateParameter(valid_613100, JString, required = false,
                                 default = nil)
  if valid_613100 != nil:
    section.add "X-Amz-SignedHeaders", valid_613100
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613101: Call_DescribeEndpoint_613090; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a unique endpoint specific to the AWS account making the call.
  ## 
  let valid = call_613101.validator(path, query, header, formData, body)
  let scheme = call_613101.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613101.url(scheme.get, call_613101.host, call_613101.base,
                         call_613101.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613101, url, valid)

proc call*(call_613102: Call_DescribeEndpoint_613090; endpointType: string = ""): Recallable =
  ## describeEndpoint
  ## Returns a unique endpoint specific to the AWS account making the call.
  ##   endpointType: string
  ##               : <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
  var query_613103 = newJObject()
  add(query_613103, "endpointType", newJString(endpointType))
  result = call_613102.call(nil, query_613103, nil, nil, nil)

var describeEndpoint* = Call_DescribeEndpoint_613090(name: "describeEndpoint",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/endpoint",
    validator: validate_DescribeEndpoint_613091, base: "/",
    url: url_DescribeEndpoint_613092, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeEventConfigurations_613104 = ref object of OpenApiRestCall_610658
proc url_DescribeEventConfigurations_613106(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeEventConfigurations_613105(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes event configurations.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613107 = header.getOrDefault("X-Amz-Signature")
  valid_613107 = validateParameter(valid_613107, JString, required = false,
                                 default = nil)
  if valid_613107 != nil:
    section.add "X-Amz-Signature", valid_613107
  var valid_613108 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613108 = validateParameter(valid_613108, JString, required = false,
                                 default = nil)
  if valid_613108 != nil:
    section.add "X-Amz-Content-Sha256", valid_613108
  var valid_613109 = header.getOrDefault("X-Amz-Date")
  valid_613109 = validateParameter(valid_613109, JString, required = false,
                                 default = nil)
  if valid_613109 != nil:
    section.add "X-Amz-Date", valid_613109
  var valid_613110 = header.getOrDefault("X-Amz-Credential")
  valid_613110 = validateParameter(valid_613110, JString, required = false,
                                 default = nil)
  if valid_613110 != nil:
    section.add "X-Amz-Credential", valid_613110
  var valid_613111 = header.getOrDefault("X-Amz-Security-Token")
  valid_613111 = validateParameter(valid_613111, JString, required = false,
                                 default = nil)
  if valid_613111 != nil:
    section.add "X-Amz-Security-Token", valid_613111
  var valid_613112 = header.getOrDefault("X-Amz-Algorithm")
  valid_613112 = validateParameter(valid_613112, JString, required = false,
                                 default = nil)
  if valid_613112 != nil:
    section.add "X-Amz-Algorithm", valid_613112
  var valid_613113 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613113 = validateParameter(valid_613113, JString, required = false,
                                 default = nil)
  if valid_613113 != nil:
    section.add "X-Amz-SignedHeaders", valid_613113
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613114: Call_DescribeEventConfigurations_613104; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes event configurations.
  ## 
  let valid = call_613114.validator(path, query, header, formData, body)
  let scheme = call_613114.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613114.url(scheme.get, call_613114.host, call_613114.base,
                         call_613114.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613114, url, valid)

proc call*(call_613115: Call_DescribeEventConfigurations_613104): Recallable =
  ## describeEventConfigurations
  ## Describes event configurations.
  result = call_613115.call(nil, nil, nil, nil, nil)

var describeEventConfigurations* = Call_DescribeEventConfigurations_613104(
    name: "describeEventConfigurations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/event-configurations",
    validator: validate_DescribeEventConfigurations_613105, base: "/",
    url: url_DescribeEventConfigurations_613106,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateEventConfigurations_613116 = ref object of OpenApiRestCall_610658
proc url_UpdateEventConfigurations_613118(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateEventConfigurations_613117(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the event configurations.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613119 = header.getOrDefault("X-Amz-Signature")
  valid_613119 = validateParameter(valid_613119, JString, required = false,
                                 default = nil)
  if valid_613119 != nil:
    section.add "X-Amz-Signature", valid_613119
  var valid_613120 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613120 = validateParameter(valid_613120, JString, required = false,
                                 default = nil)
  if valid_613120 != nil:
    section.add "X-Amz-Content-Sha256", valid_613120
  var valid_613121 = header.getOrDefault("X-Amz-Date")
  valid_613121 = validateParameter(valid_613121, JString, required = false,
                                 default = nil)
  if valid_613121 != nil:
    section.add "X-Amz-Date", valid_613121
  var valid_613122 = header.getOrDefault("X-Amz-Credential")
  valid_613122 = validateParameter(valid_613122, JString, required = false,
                                 default = nil)
  if valid_613122 != nil:
    section.add "X-Amz-Credential", valid_613122
  var valid_613123 = header.getOrDefault("X-Amz-Security-Token")
  valid_613123 = validateParameter(valid_613123, JString, required = false,
                                 default = nil)
  if valid_613123 != nil:
    section.add "X-Amz-Security-Token", valid_613123
  var valid_613124 = header.getOrDefault("X-Amz-Algorithm")
  valid_613124 = validateParameter(valid_613124, JString, required = false,
                                 default = nil)
  if valid_613124 != nil:
    section.add "X-Amz-Algorithm", valid_613124
  var valid_613125 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613125 = validateParameter(valid_613125, JString, required = false,
                                 default = nil)
  if valid_613125 != nil:
    section.add "X-Amz-SignedHeaders", valid_613125
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613127: Call_UpdateEventConfigurations_613116; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the event configurations.
  ## 
  let valid = call_613127.validator(path, query, header, formData, body)
  let scheme = call_613127.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613127.url(scheme.get, call_613127.host, call_613127.base,
                         call_613127.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613127, url, valid)

proc call*(call_613128: Call_UpdateEventConfigurations_613116; body: JsonNode): Recallable =
  ## updateEventConfigurations
  ## Updates the event configurations.
  ##   body: JObject (required)
  var body_613129 = newJObject()
  if body != nil:
    body_613129 = body
  result = call_613128.call(nil, nil, nil, nil, body_613129)

var updateEventConfigurations* = Call_UpdateEventConfigurations_613116(
    name: "updateEventConfigurations", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/event-configurations",
    validator: validate_UpdateEventConfigurations_613117, base: "/",
    url: url_UpdateEventConfigurations_613118,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeIndex_613130 = ref object of OpenApiRestCall_610658
proc url_DescribeIndex_613132(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "indexName" in path, "`indexName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/indices/"),
               (kind: VariableSegment, value: "indexName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeIndex_613131(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a search index.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   indexName: JString (required)
  ##            : The index name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `indexName` field"
  var valid_613133 = path.getOrDefault("indexName")
  valid_613133 = validateParameter(valid_613133, JString, required = true,
                                 default = nil)
  if valid_613133 != nil:
    section.add "indexName", valid_613133
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613134 = header.getOrDefault("X-Amz-Signature")
  valid_613134 = validateParameter(valid_613134, JString, required = false,
                                 default = nil)
  if valid_613134 != nil:
    section.add "X-Amz-Signature", valid_613134
  var valid_613135 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613135 = validateParameter(valid_613135, JString, required = false,
                                 default = nil)
  if valid_613135 != nil:
    section.add "X-Amz-Content-Sha256", valid_613135
  var valid_613136 = header.getOrDefault("X-Amz-Date")
  valid_613136 = validateParameter(valid_613136, JString, required = false,
                                 default = nil)
  if valid_613136 != nil:
    section.add "X-Amz-Date", valid_613136
  var valid_613137 = header.getOrDefault("X-Amz-Credential")
  valid_613137 = validateParameter(valid_613137, JString, required = false,
                                 default = nil)
  if valid_613137 != nil:
    section.add "X-Amz-Credential", valid_613137
  var valid_613138 = header.getOrDefault("X-Amz-Security-Token")
  valid_613138 = validateParameter(valid_613138, JString, required = false,
                                 default = nil)
  if valid_613138 != nil:
    section.add "X-Amz-Security-Token", valid_613138
  var valid_613139 = header.getOrDefault("X-Amz-Algorithm")
  valid_613139 = validateParameter(valid_613139, JString, required = false,
                                 default = nil)
  if valid_613139 != nil:
    section.add "X-Amz-Algorithm", valid_613139
  var valid_613140 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613140 = validateParameter(valid_613140, JString, required = false,
                                 default = nil)
  if valid_613140 != nil:
    section.add "X-Amz-SignedHeaders", valid_613140
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613141: Call_DescribeIndex_613130; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a search index.
  ## 
  let valid = call_613141.validator(path, query, header, formData, body)
  let scheme = call_613141.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613141.url(scheme.get, call_613141.host, call_613141.base,
                         call_613141.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613141, url, valid)

proc call*(call_613142: Call_DescribeIndex_613130; indexName: string): Recallable =
  ## describeIndex
  ## Describes a search index.
  ##   indexName: string (required)
  ##            : The index name.
  var path_613143 = newJObject()
  add(path_613143, "indexName", newJString(indexName))
  result = call_613142.call(path_613143, nil, nil, nil, nil)

var describeIndex* = Call_DescribeIndex_613130(name: "describeIndex",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/indices/{indexName}", validator: validate_DescribeIndex_613131,
    base: "/", url: url_DescribeIndex_613132, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeJobExecution_613144 = ref object of OpenApiRestCall_610658
proc url_DescribeJobExecution_613146(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeJobExecution_613145(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a job execution.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   thingName: JString (required)
  ##            : The name of the thing on which the job execution is running.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_613147 = path.getOrDefault("jobId")
  valid_613147 = validateParameter(valid_613147, JString, required = true,
                                 default = nil)
  if valid_613147 != nil:
    section.add "jobId", valid_613147
  var valid_613148 = path.getOrDefault("thingName")
  valid_613148 = validateParameter(valid_613148, JString, required = true,
                                 default = nil)
  if valid_613148 != nil:
    section.add "thingName", valid_613148
  result.add "path", section
  ## parameters in `query` object:
  ##   executionNumber: JInt
  ##                  : A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
  section = newJObject()
  var valid_613149 = query.getOrDefault("executionNumber")
  valid_613149 = validateParameter(valid_613149, JInt, required = false, default = nil)
  if valid_613149 != nil:
    section.add "executionNumber", valid_613149
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613150 = header.getOrDefault("X-Amz-Signature")
  valid_613150 = validateParameter(valid_613150, JString, required = false,
                                 default = nil)
  if valid_613150 != nil:
    section.add "X-Amz-Signature", valid_613150
  var valid_613151 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613151 = validateParameter(valid_613151, JString, required = false,
                                 default = nil)
  if valid_613151 != nil:
    section.add "X-Amz-Content-Sha256", valid_613151
  var valid_613152 = header.getOrDefault("X-Amz-Date")
  valid_613152 = validateParameter(valid_613152, JString, required = false,
                                 default = nil)
  if valid_613152 != nil:
    section.add "X-Amz-Date", valid_613152
  var valid_613153 = header.getOrDefault("X-Amz-Credential")
  valid_613153 = validateParameter(valid_613153, JString, required = false,
                                 default = nil)
  if valid_613153 != nil:
    section.add "X-Amz-Credential", valid_613153
  var valid_613154 = header.getOrDefault("X-Amz-Security-Token")
  valid_613154 = validateParameter(valid_613154, JString, required = false,
                                 default = nil)
  if valid_613154 != nil:
    section.add "X-Amz-Security-Token", valid_613154
  var valid_613155 = header.getOrDefault("X-Amz-Algorithm")
  valid_613155 = validateParameter(valid_613155, JString, required = false,
                                 default = nil)
  if valid_613155 != nil:
    section.add "X-Amz-Algorithm", valid_613155
  var valid_613156 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613156 = validateParameter(valid_613156, JString, required = false,
                                 default = nil)
  if valid_613156 != nil:
    section.add "X-Amz-SignedHeaders", valid_613156
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613157: Call_DescribeJobExecution_613144; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a job execution.
  ## 
  let valid = call_613157.validator(path, query, header, formData, body)
  let scheme = call_613157.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613157.url(scheme.get, call_613157.host, call_613157.base,
                         call_613157.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613157, url, valid)

proc call*(call_613158: Call_DescribeJobExecution_613144; jobId: string;
          thingName: string; executionNumber: int = 0): Recallable =
  ## describeJobExecution
  ## Describes a job execution.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   executionNumber: int
  ##                  : A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
  ##   thingName: string (required)
  ##            : The name of the thing on which the job execution is running.
  var path_613159 = newJObject()
  var query_613160 = newJObject()
  add(path_613159, "jobId", newJString(jobId))
  add(query_613160, "executionNumber", newJInt(executionNumber))
  add(path_613159, "thingName", newJString(thingName))
  result = call_613158.call(path_613159, query_613160, nil, nil, nil)

var describeJobExecution* = Call_DescribeJobExecution_613144(
    name: "describeJobExecution", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs/{jobId}",
    validator: validate_DescribeJobExecution_613145, base: "/",
    url: url_DescribeJobExecution_613146, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingRegistrationTask_613161 = ref object of OpenApiRestCall_610658
proc url_DescribeThingRegistrationTask_613163(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThingRegistrationTask_613162(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The task ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_613164 = path.getOrDefault("taskId")
  valid_613164 = validateParameter(valid_613164, JString, required = true,
                                 default = nil)
  if valid_613164 != nil:
    section.add "taskId", valid_613164
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613165 = header.getOrDefault("X-Amz-Signature")
  valid_613165 = validateParameter(valid_613165, JString, required = false,
                                 default = nil)
  if valid_613165 != nil:
    section.add "X-Amz-Signature", valid_613165
  var valid_613166 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613166 = validateParameter(valid_613166, JString, required = false,
                                 default = nil)
  if valid_613166 != nil:
    section.add "X-Amz-Content-Sha256", valid_613166
  var valid_613167 = header.getOrDefault("X-Amz-Date")
  valid_613167 = validateParameter(valid_613167, JString, required = false,
                                 default = nil)
  if valid_613167 != nil:
    section.add "X-Amz-Date", valid_613167
  var valid_613168 = header.getOrDefault("X-Amz-Credential")
  valid_613168 = validateParameter(valid_613168, JString, required = false,
                                 default = nil)
  if valid_613168 != nil:
    section.add "X-Amz-Credential", valid_613168
  var valid_613169 = header.getOrDefault("X-Amz-Security-Token")
  valid_613169 = validateParameter(valid_613169, JString, required = false,
                                 default = nil)
  if valid_613169 != nil:
    section.add "X-Amz-Security-Token", valid_613169
  var valid_613170 = header.getOrDefault("X-Amz-Algorithm")
  valid_613170 = validateParameter(valid_613170, JString, required = false,
                                 default = nil)
  if valid_613170 != nil:
    section.add "X-Amz-Algorithm", valid_613170
  var valid_613171 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613171 = validateParameter(valid_613171, JString, required = false,
                                 default = nil)
  if valid_613171 != nil:
    section.add "X-Amz-SignedHeaders", valid_613171
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613172: Call_DescribeThingRegistrationTask_613161; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a bulk thing provisioning task.
  ## 
  let valid = call_613172.validator(path, query, header, formData, body)
  let scheme = call_613172.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613172.url(scheme.get, call_613172.host, call_613172.base,
                         call_613172.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613172, url, valid)

proc call*(call_613173: Call_DescribeThingRegistrationTask_613161; taskId: string): Recallable =
  ## describeThingRegistrationTask
  ## Describes a bulk thing provisioning task.
  ##   taskId: string (required)
  ##         : The task ID.
  var path_613174 = newJObject()
  add(path_613174, "taskId", newJString(taskId))
  result = call_613173.call(path_613174, nil, nil, nil, nil)

var describeThingRegistrationTask* = Call_DescribeThingRegistrationTask_613161(
    name: "describeThingRegistrationTask", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks/{taskId}",
    validator: validate_DescribeThingRegistrationTask_613162, base: "/",
    url: url_DescribeThingRegistrationTask_613163,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DisableTopicRule_613175 = ref object of OpenApiRestCall_610658
proc url_DisableTopicRule_613177(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName"),
               (kind: ConstantSegment, value: "/disable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DisableTopicRule_613176(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Disables the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule to disable.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_613178 = path.getOrDefault("ruleName")
  valid_613178 = validateParameter(valid_613178, JString, required = true,
                                 default = nil)
  if valid_613178 != nil:
    section.add "ruleName", valid_613178
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613179 = header.getOrDefault("X-Amz-Signature")
  valid_613179 = validateParameter(valid_613179, JString, required = false,
                                 default = nil)
  if valid_613179 != nil:
    section.add "X-Amz-Signature", valid_613179
  var valid_613180 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613180 = validateParameter(valid_613180, JString, required = false,
                                 default = nil)
  if valid_613180 != nil:
    section.add "X-Amz-Content-Sha256", valid_613180
  var valid_613181 = header.getOrDefault("X-Amz-Date")
  valid_613181 = validateParameter(valid_613181, JString, required = false,
                                 default = nil)
  if valid_613181 != nil:
    section.add "X-Amz-Date", valid_613181
  var valid_613182 = header.getOrDefault("X-Amz-Credential")
  valid_613182 = validateParameter(valid_613182, JString, required = false,
                                 default = nil)
  if valid_613182 != nil:
    section.add "X-Amz-Credential", valid_613182
  var valid_613183 = header.getOrDefault("X-Amz-Security-Token")
  valid_613183 = validateParameter(valid_613183, JString, required = false,
                                 default = nil)
  if valid_613183 != nil:
    section.add "X-Amz-Security-Token", valid_613183
  var valid_613184 = header.getOrDefault("X-Amz-Algorithm")
  valid_613184 = validateParameter(valid_613184, JString, required = false,
                                 default = nil)
  if valid_613184 != nil:
    section.add "X-Amz-Algorithm", valid_613184
  var valid_613185 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613185 = validateParameter(valid_613185, JString, required = false,
                                 default = nil)
  if valid_613185 != nil:
    section.add "X-Amz-SignedHeaders", valid_613185
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613186: Call_DisableTopicRule_613175; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Disables the rule.
  ## 
  let valid = call_613186.validator(path, query, header, formData, body)
  let scheme = call_613186.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613186.url(scheme.get, call_613186.host, call_613186.base,
                         call_613186.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613186, url, valid)

proc call*(call_613187: Call_DisableTopicRule_613175; ruleName: string): Recallable =
  ## disableTopicRule
  ## Disables the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule to disable.
  var path_613188 = newJObject()
  add(path_613188, "ruleName", newJString(ruleName))
  result = call_613187.call(path_613188, nil, nil, nil, nil)

var disableTopicRule* = Call_DisableTopicRule_613175(name: "disableTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}/disable", validator: validate_DisableTopicRule_613176,
    base: "/", url: url_DisableTopicRule_613177,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_EnableTopicRule_613189 = ref object of OpenApiRestCall_610658
proc url_EnableTopicRule_613191(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName"),
               (kind: ConstantSegment, value: "/enable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_EnableTopicRule_613190(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Enables the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the topic rule to enable.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_613192 = path.getOrDefault("ruleName")
  valid_613192 = validateParameter(valid_613192, JString, required = true,
                                 default = nil)
  if valid_613192 != nil:
    section.add "ruleName", valid_613192
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613193 = header.getOrDefault("X-Amz-Signature")
  valid_613193 = validateParameter(valid_613193, JString, required = false,
                                 default = nil)
  if valid_613193 != nil:
    section.add "X-Amz-Signature", valid_613193
  var valid_613194 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613194 = validateParameter(valid_613194, JString, required = false,
                                 default = nil)
  if valid_613194 != nil:
    section.add "X-Amz-Content-Sha256", valid_613194
  var valid_613195 = header.getOrDefault("X-Amz-Date")
  valid_613195 = validateParameter(valid_613195, JString, required = false,
                                 default = nil)
  if valid_613195 != nil:
    section.add "X-Amz-Date", valid_613195
  var valid_613196 = header.getOrDefault("X-Amz-Credential")
  valid_613196 = validateParameter(valid_613196, JString, required = false,
                                 default = nil)
  if valid_613196 != nil:
    section.add "X-Amz-Credential", valid_613196
  var valid_613197 = header.getOrDefault("X-Amz-Security-Token")
  valid_613197 = validateParameter(valid_613197, JString, required = false,
                                 default = nil)
  if valid_613197 != nil:
    section.add "X-Amz-Security-Token", valid_613197
  var valid_613198 = header.getOrDefault("X-Amz-Algorithm")
  valid_613198 = validateParameter(valid_613198, JString, required = false,
                                 default = nil)
  if valid_613198 != nil:
    section.add "X-Amz-Algorithm", valid_613198
  var valid_613199 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613199 = validateParameter(valid_613199, JString, required = false,
                                 default = nil)
  if valid_613199 != nil:
    section.add "X-Amz-SignedHeaders", valid_613199
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613200: Call_EnableTopicRule_613189; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the rule.
  ## 
  let valid = call_613200.validator(path, query, header, formData, body)
  let scheme = call_613200.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613200.url(scheme.get, call_613200.host, call_613200.base,
                         call_613200.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613200, url, valid)

proc call*(call_613201: Call_EnableTopicRule_613189; ruleName: string): Recallable =
  ## enableTopicRule
  ## Enables the rule.
  ##   ruleName: string (required)
  ##           : The name of the topic rule to enable.
  var path_613202 = newJObject()
  add(path_613202, "ruleName", newJString(ruleName))
  result = call_613201.call(path_613202, nil, nil, nil, nil)

var enableTopicRule* = Call_EnableTopicRule_613189(name: "enableTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}/enable", validator: validate_EnableTopicRule_613190,
    base: "/", url: url_EnableTopicRule_613191, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCardinality_613203 = ref object of OpenApiRestCall_610658
proc url_GetCardinality_613205(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCardinality_613204(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Returns the approximate count of unique values that match the query.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613206 = header.getOrDefault("X-Amz-Signature")
  valid_613206 = validateParameter(valid_613206, JString, required = false,
                                 default = nil)
  if valid_613206 != nil:
    section.add "X-Amz-Signature", valid_613206
  var valid_613207 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613207 = validateParameter(valid_613207, JString, required = false,
                                 default = nil)
  if valid_613207 != nil:
    section.add "X-Amz-Content-Sha256", valid_613207
  var valid_613208 = header.getOrDefault("X-Amz-Date")
  valid_613208 = validateParameter(valid_613208, JString, required = false,
                                 default = nil)
  if valid_613208 != nil:
    section.add "X-Amz-Date", valid_613208
  var valid_613209 = header.getOrDefault("X-Amz-Credential")
  valid_613209 = validateParameter(valid_613209, JString, required = false,
                                 default = nil)
  if valid_613209 != nil:
    section.add "X-Amz-Credential", valid_613209
  var valid_613210 = header.getOrDefault("X-Amz-Security-Token")
  valid_613210 = validateParameter(valid_613210, JString, required = false,
                                 default = nil)
  if valid_613210 != nil:
    section.add "X-Amz-Security-Token", valid_613210
  var valid_613211 = header.getOrDefault("X-Amz-Algorithm")
  valid_613211 = validateParameter(valid_613211, JString, required = false,
                                 default = nil)
  if valid_613211 != nil:
    section.add "X-Amz-Algorithm", valid_613211
  var valid_613212 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613212 = validateParameter(valid_613212, JString, required = false,
                                 default = nil)
  if valid_613212 != nil:
    section.add "X-Amz-SignedHeaders", valid_613212
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613214: Call_GetCardinality_613203; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the approximate count of unique values that match the query.
  ## 
  let valid = call_613214.validator(path, query, header, formData, body)
  let scheme = call_613214.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613214.url(scheme.get, call_613214.host, call_613214.base,
                         call_613214.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613214, url, valid)

proc call*(call_613215: Call_GetCardinality_613203; body: JsonNode): Recallable =
  ## getCardinality
  ## Returns the approximate count of unique values that match the query.
  ##   body: JObject (required)
  var body_613216 = newJObject()
  if body != nil:
    body_613216 = body
  result = call_613215.call(nil, nil, nil, nil, body_613216)

var getCardinality* = Call_GetCardinality_613203(name: "getCardinality",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/cardinality", validator: validate_GetCardinality_613204,
    base: "/", url: url_GetCardinality_613205, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEffectivePolicies_613217 = ref object of OpenApiRestCall_610658
proc url_GetEffectivePolicies_613219(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEffectivePolicies_613218(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingName: JString
  ##            : The thing name.
  section = newJObject()
  var valid_613220 = query.getOrDefault("thingName")
  valid_613220 = validateParameter(valid_613220, JString, required = false,
                                 default = nil)
  if valid_613220 != nil:
    section.add "thingName", valid_613220
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613221 = header.getOrDefault("X-Amz-Signature")
  valid_613221 = validateParameter(valid_613221, JString, required = false,
                                 default = nil)
  if valid_613221 != nil:
    section.add "X-Amz-Signature", valid_613221
  var valid_613222 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613222 = validateParameter(valid_613222, JString, required = false,
                                 default = nil)
  if valid_613222 != nil:
    section.add "X-Amz-Content-Sha256", valid_613222
  var valid_613223 = header.getOrDefault("X-Amz-Date")
  valid_613223 = validateParameter(valid_613223, JString, required = false,
                                 default = nil)
  if valid_613223 != nil:
    section.add "X-Amz-Date", valid_613223
  var valid_613224 = header.getOrDefault("X-Amz-Credential")
  valid_613224 = validateParameter(valid_613224, JString, required = false,
                                 default = nil)
  if valid_613224 != nil:
    section.add "X-Amz-Credential", valid_613224
  var valid_613225 = header.getOrDefault("X-Amz-Security-Token")
  valid_613225 = validateParameter(valid_613225, JString, required = false,
                                 default = nil)
  if valid_613225 != nil:
    section.add "X-Amz-Security-Token", valid_613225
  var valid_613226 = header.getOrDefault("X-Amz-Algorithm")
  valid_613226 = validateParameter(valid_613226, JString, required = false,
                                 default = nil)
  if valid_613226 != nil:
    section.add "X-Amz-Algorithm", valid_613226
  var valid_613227 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613227 = validateParameter(valid_613227, JString, required = false,
                                 default = nil)
  if valid_613227 != nil:
    section.add "X-Amz-SignedHeaders", valid_613227
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613229: Call_GetEffectivePolicies_613217; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ## 
  let valid = call_613229.validator(path, query, header, formData, body)
  let scheme = call_613229.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613229.url(scheme.get, call_613229.host, call_613229.base,
                         call_613229.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613229, url, valid)

proc call*(call_613230: Call_GetEffectivePolicies_613217; body: JsonNode;
          thingName: string = ""): Recallable =
  ## getEffectivePolicies
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ##   thingName: string
  ##            : The thing name.
  ##   body: JObject (required)
  var query_613231 = newJObject()
  var body_613232 = newJObject()
  add(query_613231, "thingName", newJString(thingName))
  if body != nil:
    body_613232 = body
  result = call_613230.call(nil, query_613231, nil, nil, body_613232)

var getEffectivePolicies* = Call_GetEffectivePolicies_613217(
    name: "getEffectivePolicies", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/effective-policies",
    validator: validate_GetEffectivePolicies_613218, base: "/",
    url: url_GetEffectivePolicies_613219, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateIndexingConfiguration_613245 = ref object of OpenApiRestCall_610658
proc url_UpdateIndexingConfiguration_613247(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateIndexingConfiguration_613246(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the search configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613248 = header.getOrDefault("X-Amz-Signature")
  valid_613248 = validateParameter(valid_613248, JString, required = false,
                                 default = nil)
  if valid_613248 != nil:
    section.add "X-Amz-Signature", valid_613248
  var valid_613249 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613249 = validateParameter(valid_613249, JString, required = false,
                                 default = nil)
  if valid_613249 != nil:
    section.add "X-Amz-Content-Sha256", valid_613249
  var valid_613250 = header.getOrDefault("X-Amz-Date")
  valid_613250 = validateParameter(valid_613250, JString, required = false,
                                 default = nil)
  if valid_613250 != nil:
    section.add "X-Amz-Date", valid_613250
  var valid_613251 = header.getOrDefault("X-Amz-Credential")
  valid_613251 = validateParameter(valid_613251, JString, required = false,
                                 default = nil)
  if valid_613251 != nil:
    section.add "X-Amz-Credential", valid_613251
  var valid_613252 = header.getOrDefault("X-Amz-Security-Token")
  valid_613252 = validateParameter(valid_613252, JString, required = false,
                                 default = nil)
  if valid_613252 != nil:
    section.add "X-Amz-Security-Token", valid_613252
  var valid_613253 = header.getOrDefault("X-Amz-Algorithm")
  valid_613253 = validateParameter(valid_613253, JString, required = false,
                                 default = nil)
  if valid_613253 != nil:
    section.add "X-Amz-Algorithm", valid_613253
  var valid_613254 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613254 = validateParameter(valid_613254, JString, required = false,
                                 default = nil)
  if valid_613254 != nil:
    section.add "X-Amz-SignedHeaders", valid_613254
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613256: Call_UpdateIndexingConfiguration_613245; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the search configuration.
  ## 
  let valid = call_613256.validator(path, query, header, formData, body)
  let scheme = call_613256.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613256.url(scheme.get, call_613256.host, call_613256.base,
                         call_613256.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613256, url, valid)

proc call*(call_613257: Call_UpdateIndexingConfiguration_613245; body: JsonNode): Recallable =
  ## updateIndexingConfiguration
  ## Updates the search configuration.
  ##   body: JObject (required)
  var body_613258 = newJObject()
  if body != nil:
    body_613258 = body
  result = call_613257.call(nil, nil, nil, nil, body_613258)

var updateIndexingConfiguration* = Call_UpdateIndexingConfiguration_613245(
    name: "updateIndexingConfiguration", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/indexing/config",
    validator: validate_UpdateIndexingConfiguration_613246, base: "/",
    url: url_UpdateIndexingConfiguration_613247,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetIndexingConfiguration_613233 = ref object of OpenApiRestCall_610658
proc url_GetIndexingConfiguration_613235(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetIndexingConfiguration_613234(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the indexing configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613236 = header.getOrDefault("X-Amz-Signature")
  valid_613236 = validateParameter(valid_613236, JString, required = false,
                                 default = nil)
  if valid_613236 != nil:
    section.add "X-Amz-Signature", valid_613236
  var valid_613237 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613237 = validateParameter(valid_613237, JString, required = false,
                                 default = nil)
  if valid_613237 != nil:
    section.add "X-Amz-Content-Sha256", valid_613237
  var valid_613238 = header.getOrDefault("X-Amz-Date")
  valid_613238 = validateParameter(valid_613238, JString, required = false,
                                 default = nil)
  if valid_613238 != nil:
    section.add "X-Amz-Date", valid_613238
  var valid_613239 = header.getOrDefault("X-Amz-Credential")
  valid_613239 = validateParameter(valid_613239, JString, required = false,
                                 default = nil)
  if valid_613239 != nil:
    section.add "X-Amz-Credential", valid_613239
  var valid_613240 = header.getOrDefault("X-Amz-Security-Token")
  valid_613240 = validateParameter(valid_613240, JString, required = false,
                                 default = nil)
  if valid_613240 != nil:
    section.add "X-Amz-Security-Token", valid_613240
  var valid_613241 = header.getOrDefault("X-Amz-Algorithm")
  valid_613241 = validateParameter(valid_613241, JString, required = false,
                                 default = nil)
  if valid_613241 != nil:
    section.add "X-Amz-Algorithm", valid_613241
  var valid_613242 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613242 = validateParameter(valid_613242, JString, required = false,
                                 default = nil)
  if valid_613242 != nil:
    section.add "X-Amz-SignedHeaders", valid_613242
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613243: Call_GetIndexingConfiguration_613233; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the indexing configuration.
  ## 
  let valid = call_613243.validator(path, query, header, formData, body)
  let scheme = call_613243.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613243.url(scheme.get, call_613243.host, call_613243.base,
                         call_613243.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613243, url, valid)

proc call*(call_613244: Call_GetIndexingConfiguration_613233): Recallable =
  ## getIndexingConfiguration
  ## Gets the indexing configuration.
  result = call_613244.call(nil, nil, nil, nil, nil)

var getIndexingConfiguration* = Call_GetIndexingConfiguration_613233(
    name: "getIndexingConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/indexing/config",
    validator: validate_GetIndexingConfiguration_613234, base: "/",
    url: url_GetIndexingConfiguration_613235, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetJobDocument_613259 = ref object of OpenApiRestCall_610658
proc url_GetJobDocument_613261(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/job-document")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetJobDocument_613260(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets a job document.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_613262 = path.getOrDefault("jobId")
  valid_613262 = validateParameter(valid_613262, JString, required = true,
                                 default = nil)
  if valid_613262 != nil:
    section.add "jobId", valid_613262
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613263 = header.getOrDefault("X-Amz-Signature")
  valid_613263 = validateParameter(valid_613263, JString, required = false,
                                 default = nil)
  if valid_613263 != nil:
    section.add "X-Amz-Signature", valid_613263
  var valid_613264 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613264 = validateParameter(valid_613264, JString, required = false,
                                 default = nil)
  if valid_613264 != nil:
    section.add "X-Amz-Content-Sha256", valid_613264
  var valid_613265 = header.getOrDefault("X-Amz-Date")
  valid_613265 = validateParameter(valid_613265, JString, required = false,
                                 default = nil)
  if valid_613265 != nil:
    section.add "X-Amz-Date", valid_613265
  var valid_613266 = header.getOrDefault("X-Amz-Credential")
  valid_613266 = validateParameter(valid_613266, JString, required = false,
                                 default = nil)
  if valid_613266 != nil:
    section.add "X-Amz-Credential", valid_613266
  var valid_613267 = header.getOrDefault("X-Amz-Security-Token")
  valid_613267 = validateParameter(valid_613267, JString, required = false,
                                 default = nil)
  if valid_613267 != nil:
    section.add "X-Amz-Security-Token", valid_613267
  var valid_613268 = header.getOrDefault("X-Amz-Algorithm")
  valid_613268 = validateParameter(valid_613268, JString, required = false,
                                 default = nil)
  if valid_613268 != nil:
    section.add "X-Amz-Algorithm", valid_613268
  var valid_613269 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613269 = validateParameter(valid_613269, JString, required = false,
                                 default = nil)
  if valid_613269 != nil:
    section.add "X-Amz-SignedHeaders", valid_613269
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613270: Call_GetJobDocument_613259; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a job document.
  ## 
  let valid = call_613270.validator(path, query, header, formData, body)
  let scheme = call_613270.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613270.url(scheme.get, call_613270.host, call_613270.base,
                         call_613270.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613270, url, valid)

proc call*(call_613271: Call_GetJobDocument_613259; jobId: string): Recallable =
  ## getJobDocument
  ## Gets a job document.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  var path_613272 = newJObject()
  add(path_613272, "jobId", newJString(jobId))
  result = call_613271.call(path_613272, nil, nil, nil, nil)

var getJobDocument* = Call_GetJobDocument_613259(name: "getJobDocument",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/jobs/{jobId}/job-document", validator: validate_GetJobDocument_613260,
    base: "/", url: url_GetJobDocument_613261, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetLoggingOptions_613285 = ref object of OpenApiRestCall_610658
proc url_SetLoggingOptions_613287(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetLoggingOptions_613286(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613288 = header.getOrDefault("X-Amz-Signature")
  valid_613288 = validateParameter(valid_613288, JString, required = false,
                                 default = nil)
  if valid_613288 != nil:
    section.add "X-Amz-Signature", valid_613288
  var valid_613289 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613289 = validateParameter(valid_613289, JString, required = false,
                                 default = nil)
  if valid_613289 != nil:
    section.add "X-Amz-Content-Sha256", valid_613289
  var valid_613290 = header.getOrDefault("X-Amz-Date")
  valid_613290 = validateParameter(valid_613290, JString, required = false,
                                 default = nil)
  if valid_613290 != nil:
    section.add "X-Amz-Date", valid_613290
  var valid_613291 = header.getOrDefault("X-Amz-Credential")
  valid_613291 = validateParameter(valid_613291, JString, required = false,
                                 default = nil)
  if valid_613291 != nil:
    section.add "X-Amz-Credential", valid_613291
  var valid_613292 = header.getOrDefault("X-Amz-Security-Token")
  valid_613292 = validateParameter(valid_613292, JString, required = false,
                                 default = nil)
  if valid_613292 != nil:
    section.add "X-Amz-Security-Token", valid_613292
  var valid_613293 = header.getOrDefault("X-Amz-Algorithm")
  valid_613293 = validateParameter(valid_613293, JString, required = false,
                                 default = nil)
  if valid_613293 != nil:
    section.add "X-Amz-Algorithm", valid_613293
  var valid_613294 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613294 = validateParameter(valid_613294, JString, required = false,
                                 default = nil)
  if valid_613294 != nil:
    section.add "X-Amz-SignedHeaders", valid_613294
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613296: Call_SetLoggingOptions_613285; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ## 
  let valid = call_613296.validator(path, query, header, formData, body)
  let scheme = call_613296.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613296.url(scheme.get, call_613296.host, call_613296.base,
                         call_613296.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613296, url, valid)

proc call*(call_613297: Call_SetLoggingOptions_613285; body: JsonNode): Recallable =
  ## setLoggingOptions
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ##   body: JObject (required)
  var body_613298 = newJObject()
  if body != nil:
    body_613298 = body
  result = call_613297.call(nil, nil, nil, nil, body_613298)

var setLoggingOptions* = Call_SetLoggingOptions_613285(name: "setLoggingOptions",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/loggingOptions",
    validator: validate_SetLoggingOptions_613286, base: "/",
    url: url_SetLoggingOptions_613287, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetLoggingOptions_613273 = ref object of OpenApiRestCall_610658
proc url_GetLoggingOptions_613275(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetLoggingOptions_613274(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613276 = header.getOrDefault("X-Amz-Signature")
  valid_613276 = validateParameter(valid_613276, JString, required = false,
                                 default = nil)
  if valid_613276 != nil:
    section.add "X-Amz-Signature", valid_613276
  var valid_613277 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613277 = validateParameter(valid_613277, JString, required = false,
                                 default = nil)
  if valid_613277 != nil:
    section.add "X-Amz-Content-Sha256", valid_613277
  var valid_613278 = header.getOrDefault("X-Amz-Date")
  valid_613278 = validateParameter(valid_613278, JString, required = false,
                                 default = nil)
  if valid_613278 != nil:
    section.add "X-Amz-Date", valid_613278
  var valid_613279 = header.getOrDefault("X-Amz-Credential")
  valid_613279 = validateParameter(valid_613279, JString, required = false,
                                 default = nil)
  if valid_613279 != nil:
    section.add "X-Amz-Credential", valid_613279
  var valid_613280 = header.getOrDefault("X-Amz-Security-Token")
  valid_613280 = validateParameter(valid_613280, JString, required = false,
                                 default = nil)
  if valid_613280 != nil:
    section.add "X-Amz-Security-Token", valid_613280
  var valid_613281 = header.getOrDefault("X-Amz-Algorithm")
  valid_613281 = validateParameter(valid_613281, JString, required = false,
                                 default = nil)
  if valid_613281 != nil:
    section.add "X-Amz-Algorithm", valid_613281
  var valid_613282 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613282 = validateParameter(valid_613282, JString, required = false,
                                 default = nil)
  if valid_613282 != nil:
    section.add "X-Amz-SignedHeaders", valid_613282
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613283: Call_GetLoggingOptions_613273; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  ## 
  let valid = call_613283.validator(path, query, header, formData, body)
  let scheme = call_613283.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613283.url(scheme.get, call_613283.host, call_613283.base,
                         call_613283.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613283, url, valid)

proc call*(call_613284: Call_GetLoggingOptions_613273): Recallable =
  ## getLoggingOptions
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  result = call_613284.call(nil, nil, nil, nil, nil)

var getLoggingOptions* = Call_GetLoggingOptions_613273(name: "getLoggingOptions",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/loggingOptions",
    validator: validate_GetLoggingOptions_613274, base: "/",
    url: url_GetLoggingOptions_613275, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPercentiles_613299 = ref object of OpenApiRestCall_610658
proc url_GetPercentiles_613301(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetPercentiles_613300(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Groups the aggregated values that match the query into percentile groupings. The default percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own when you call <code>GetPercentiles</code>. This function returns a value for each percentile group specified (or the default percentile groupings). The percentile group "1" contains the aggregated field value that occurs in approximately one percent of the values that match the query. The percentile group "5" contains the aggregated field value that occurs in approximately five percent of the values that match the query, and so on. The result is an approximation, the more values that match the query, the more accurate the percentile values.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613302 = header.getOrDefault("X-Amz-Signature")
  valid_613302 = validateParameter(valid_613302, JString, required = false,
                                 default = nil)
  if valid_613302 != nil:
    section.add "X-Amz-Signature", valid_613302
  var valid_613303 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613303 = validateParameter(valid_613303, JString, required = false,
                                 default = nil)
  if valid_613303 != nil:
    section.add "X-Amz-Content-Sha256", valid_613303
  var valid_613304 = header.getOrDefault("X-Amz-Date")
  valid_613304 = validateParameter(valid_613304, JString, required = false,
                                 default = nil)
  if valid_613304 != nil:
    section.add "X-Amz-Date", valid_613304
  var valid_613305 = header.getOrDefault("X-Amz-Credential")
  valid_613305 = validateParameter(valid_613305, JString, required = false,
                                 default = nil)
  if valid_613305 != nil:
    section.add "X-Amz-Credential", valid_613305
  var valid_613306 = header.getOrDefault("X-Amz-Security-Token")
  valid_613306 = validateParameter(valid_613306, JString, required = false,
                                 default = nil)
  if valid_613306 != nil:
    section.add "X-Amz-Security-Token", valid_613306
  var valid_613307 = header.getOrDefault("X-Amz-Algorithm")
  valid_613307 = validateParameter(valid_613307, JString, required = false,
                                 default = nil)
  if valid_613307 != nil:
    section.add "X-Amz-Algorithm", valid_613307
  var valid_613308 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613308 = validateParameter(valid_613308, JString, required = false,
                                 default = nil)
  if valid_613308 != nil:
    section.add "X-Amz-SignedHeaders", valid_613308
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613310: Call_GetPercentiles_613299; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Groups the aggregated values that match the query into percentile groupings. The default percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own when you call <code>GetPercentiles</code>. This function returns a value for each percentile group specified (or the default percentile groupings). The percentile group "1" contains the aggregated field value that occurs in approximately one percent of the values that match the query. The percentile group "5" contains the aggregated field value that occurs in approximately five percent of the values that match the query, and so on. The result is an approximation, the more values that match the query, the more accurate the percentile values.
  ## 
  let valid = call_613310.validator(path, query, header, formData, body)
  let scheme = call_613310.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613310.url(scheme.get, call_613310.host, call_613310.base,
                         call_613310.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613310, url, valid)

proc call*(call_613311: Call_GetPercentiles_613299; body: JsonNode): Recallable =
  ## getPercentiles
  ## Groups the aggregated values that match the query into percentile groupings. The default percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own when you call <code>GetPercentiles</code>. This function returns a value for each percentile group specified (or the default percentile groupings). The percentile group "1" contains the aggregated field value that occurs in approximately one percent of the values that match the query. The percentile group "5" contains the aggregated field value that occurs in approximately five percent of the values that match the query, and so on. The result is an approximation, the more values that match the query, the more accurate the percentile values.
  ##   body: JObject (required)
  var body_613312 = newJObject()
  if body != nil:
    body_613312 = body
  result = call_613311.call(nil, nil, nil, nil, body_613312)

var getPercentiles* = Call_GetPercentiles_613299(name: "getPercentiles",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/percentiles", validator: validate_GetPercentiles_613300,
    base: "/", url: url_GetPercentiles_613301, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetStatistics_613313 = ref object of OpenApiRestCall_610658
proc url_GetStatistics_613315(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetStatistics_613314(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the count, average, sum, minimum, maximum, sum of squares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type <code>String</code>, only the count statistic is returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613316 = header.getOrDefault("X-Amz-Signature")
  valid_613316 = validateParameter(valid_613316, JString, required = false,
                                 default = nil)
  if valid_613316 != nil:
    section.add "X-Amz-Signature", valid_613316
  var valid_613317 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613317 = validateParameter(valid_613317, JString, required = false,
                                 default = nil)
  if valid_613317 != nil:
    section.add "X-Amz-Content-Sha256", valid_613317
  var valid_613318 = header.getOrDefault("X-Amz-Date")
  valid_613318 = validateParameter(valid_613318, JString, required = false,
                                 default = nil)
  if valid_613318 != nil:
    section.add "X-Amz-Date", valid_613318
  var valid_613319 = header.getOrDefault("X-Amz-Credential")
  valid_613319 = validateParameter(valid_613319, JString, required = false,
                                 default = nil)
  if valid_613319 != nil:
    section.add "X-Amz-Credential", valid_613319
  var valid_613320 = header.getOrDefault("X-Amz-Security-Token")
  valid_613320 = validateParameter(valid_613320, JString, required = false,
                                 default = nil)
  if valid_613320 != nil:
    section.add "X-Amz-Security-Token", valid_613320
  var valid_613321 = header.getOrDefault("X-Amz-Algorithm")
  valid_613321 = validateParameter(valid_613321, JString, required = false,
                                 default = nil)
  if valid_613321 != nil:
    section.add "X-Amz-Algorithm", valid_613321
  var valid_613322 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613322 = validateParameter(valid_613322, JString, required = false,
                                 default = nil)
  if valid_613322 != nil:
    section.add "X-Amz-SignedHeaders", valid_613322
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613324: Call_GetStatistics_613313; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the count, average, sum, minimum, maximum, sum of squares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type <code>String</code>, only the count statistic is returned.
  ## 
  let valid = call_613324.validator(path, query, header, formData, body)
  let scheme = call_613324.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613324.url(scheme.get, call_613324.host, call_613324.base,
                         call_613324.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613324, url, valid)

proc call*(call_613325: Call_GetStatistics_613313; body: JsonNode): Recallable =
  ## getStatistics
  ## Returns the count, average, sum, minimum, maximum, sum of squares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type <code>String</code>, only the count statistic is returned.
  ##   body: JObject (required)
  var body_613326 = newJObject()
  if body != nil:
    body_613326 = body
  result = call_613325.call(nil, nil, nil, nil, body_613326)

var getStatistics* = Call_GetStatistics_613313(name: "getStatistics",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/statistics", validator: validate_GetStatistics_613314,
    base: "/", url: url_GetStatistics_613315, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetV2LoggingOptions_613339 = ref object of OpenApiRestCall_610658
proc url_SetV2LoggingOptions_613341(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetV2LoggingOptions_613340(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Sets the logging options for the V2 logging service.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613342 = header.getOrDefault("X-Amz-Signature")
  valid_613342 = validateParameter(valid_613342, JString, required = false,
                                 default = nil)
  if valid_613342 != nil:
    section.add "X-Amz-Signature", valid_613342
  var valid_613343 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613343 = validateParameter(valid_613343, JString, required = false,
                                 default = nil)
  if valid_613343 != nil:
    section.add "X-Amz-Content-Sha256", valid_613343
  var valid_613344 = header.getOrDefault("X-Amz-Date")
  valid_613344 = validateParameter(valid_613344, JString, required = false,
                                 default = nil)
  if valid_613344 != nil:
    section.add "X-Amz-Date", valid_613344
  var valid_613345 = header.getOrDefault("X-Amz-Credential")
  valid_613345 = validateParameter(valid_613345, JString, required = false,
                                 default = nil)
  if valid_613345 != nil:
    section.add "X-Amz-Credential", valid_613345
  var valid_613346 = header.getOrDefault("X-Amz-Security-Token")
  valid_613346 = validateParameter(valid_613346, JString, required = false,
                                 default = nil)
  if valid_613346 != nil:
    section.add "X-Amz-Security-Token", valid_613346
  var valid_613347 = header.getOrDefault("X-Amz-Algorithm")
  valid_613347 = validateParameter(valid_613347, JString, required = false,
                                 default = nil)
  if valid_613347 != nil:
    section.add "X-Amz-Algorithm", valid_613347
  var valid_613348 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613348 = validateParameter(valid_613348, JString, required = false,
                                 default = nil)
  if valid_613348 != nil:
    section.add "X-Amz-SignedHeaders", valid_613348
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613350: Call_SetV2LoggingOptions_613339; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the logging options for the V2 logging service.
  ## 
  let valid = call_613350.validator(path, query, header, formData, body)
  let scheme = call_613350.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613350.url(scheme.get, call_613350.host, call_613350.base,
                         call_613350.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613350, url, valid)

proc call*(call_613351: Call_SetV2LoggingOptions_613339; body: JsonNode): Recallable =
  ## setV2LoggingOptions
  ## Sets the logging options for the V2 logging service.
  ##   body: JObject (required)
  var body_613352 = newJObject()
  if body != nil:
    body_613352 = body
  result = call_613351.call(nil, nil, nil, nil, body_613352)

var setV2LoggingOptions* = Call_SetV2LoggingOptions_613339(
    name: "setV2LoggingOptions", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/v2LoggingOptions",
    validator: validate_SetV2LoggingOptions_613340, base: "/",
    url: url_SetV2LoggingOptions_613341, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetV2LoggingOptions_613327 = ref object of OpenApiRestCall_610658
proc url_GetV2LoggingOptions_613329(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV2LoggingOptions_613328(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets the fine grained logging options.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613330 = header.getOrDefault("X-Amz-Signature")
  valid_613330 = validateParameter(valid_613330, JString, required = false,
                                 default = nil)
  if valid_613330 != nil:
    section.add "X-Amz-Signature", valid_613330
  var valid_613331 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613331 = validateParameter(valid_613331, JString, required = false,
                                 default = nil)
  if valid_613331 != nil:
    section.add "X-Amz-Content-Sha256", valid_613331
  var valid_613332 = header.getOrDefault("X-Amz-Date")
  valid_613332 = validateParameter(valid_613332, JString, required = false,
                                 default = nil)
  if valid_613332 != nil:
    section.add "X-Amz-Date", valid_613332
  var valid_613333 = header.getOrDefault("X-Amz-Credential")
  valid_613333 = validateParameter(valid_613333, JString, required = false,
                                 default = nil)
  if valid_613333 != nil:
    section.add "X-Amz-Credential", valid_613333
  var valid_613334 = header.getOrDefault("X-Amz-Security-Token")
  valid_613334 = validateParameter(valid_613334, JString, required = false,
                                 default = nil)
  if valid_613334 != nil:
    section.add "X-Amz-Security-Token", valid_613334
  var valid_613335 = header.getOrDefault("X-Amz-Algorithm")
  valid_613335 = validateParameter(valid_613335, JString, required = false,
                                 default = nil)
  if valid_613335 != nil:
    section.add "X-Amz-Algorithm", valid_613335
  var valid_613336 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613336 = validateParameter(valid_613336, JString, required = false,
                                 default = nil)
  if valid_613336 != nil:
    section.add "X-Amz-SignedHeaders", valid_613336
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613337: Call_GetV2LoggingOptions_613327; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the fine grained logging options.
  ## 
  let valid = call_613337.validator(path, query, header, formData, body)
  let scheme = call_613337.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613337.url(scheme.get, call_613337.host, call_613337.base,
                         call_613337.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613337, url, valid)

proc call*(call_613338: Call_GetV2LoggingOptions_613327): Recallable =
  ## getV2LoggingOptions
  ## Gets the fine grained logging options.
  result = call_613338.call(nil, nil, nil, nil, nil)

var getV2LoggingOptions* = Call_GetV2LoggingOptions_613327(
    name: "getV2LoggingOptions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/v2LoggingOptions",
    validator: validate_GetV2LoggingOptions_613328, base: "/",
    url: url_GetV2LoggingOptions_613329, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListActiveViolations_613353 = ref object of OpenApiRestCall_610658
proc url_ListActiveViolations_613355(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListActiveViolations_613354(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the active violations for a given Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   securityProfileName: JString
  ##                      : The name of the Device Defender security profile for which violations are listed.
  ##   thingName: JString
  ##            : The name of the thing whose active violations are listed.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_613356 = query.getOrDefault("nextToken")
  valid_613356 = validateParameter(valid_613356, JString, required = false,
                                 default = nil)
  if valid_613356 != nil:
    section.add "nextToken", valid_613356
  var valid_613357 = query.getOrDefault("securityProfileName")
  valid_613357 = validateParameter(valid_613357, JString, required = false,
                                 default = nil)
  if valid_613357 != nil:
    section.add "securityProfileName", valid_613357
  var valid_613358 = query.getOrDefault("thingName")
  valid_613358 = validateParameter(valid_613358, JString, required = false,
                                 default = nil)
  if valid_613358 != nil:
    section.add "thingName", valid_613358
  var valid_613359 = query.getOrDefault("maxResults")
  valid_613359 = validateParameter(valid_613359, JInt, required = false, default = nil)
  if valid_613359 != nil:
    section.add "maxResults", valid_613359
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613360 = header.getOrDefault("X-Amz-Signature")
  valid_613360 = validateParameter(valid_613360, JString, required = false,
                                 default = nil)
  if valid_613360 != nil:
    section.add "X-Amz-Signature", valid_613360
  var valid_613361 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613361 = validateParameter(valid_613361, JString, required = false,
                                 default = nil)
  if valid_613361 != nil:
    section.add "X-Amz-Content-Sha256", valid_613361
  var valid_613362 = header.getOrDefault("X-Amz-Date")
  valid_613362 = validateParameter(valid_613362, JString, required = false,
                                 default = nil)
  if valid_613362 != nil:
    section.add "X-Amz-Date", valid_613362
  var valid_613363 = header.getOrDefault("X-Amz-Credential")
  valid_613363 = validateParameter(valid_613363, JString, required = false,
                                 default = nil)
  if valid_613363 != nil:
    section.add "X-Amz-Credential", valid_613363
  var valid_613364 = header.getOrDefault("X-Amz-Security-Token")
  valid_613364 = validateParameter(valid_613364, JString, required = false,
                                 default = nil)
  if valid_613364 != nil:
    section.add "X-Amz-Security-Token", valid_613364
  var valid_613365 = header.getOrDefault("X-Amz-Algorithm")
  valid_613365 = validateParameter(valid_613365, JString, required = false,
                                 default = nil)
  if valid_613365 != nil:
    section.add "X-Amz-Algorithm", valid_613365
  var valid_613366 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613366 = validateParameter(valid_613366, JString, required = false,
                                 default = nil)
  if valid_613366 != nil:
    section.add "X-Amz-SignedHeaders", valid_613366
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613367: Call_ListActiveViolations_613353; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the active violations for a given Device Defender security profile.
  ## 
  let valid = call_613367.validator(path, query, header, formData, body)
  let scheme = call_613367.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613367.url(scheme.get, call_613367.host, call_613367.base,
                         call_613367.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613367, url, valid)

proc call*(call_613368: Call_ListActiveViolations_613353; nextToken: string = "";
          securityProfileName: string = ""; thingName: string = ""; maxResults: int = 0): Recallable =
  ## listActiveViolations
  ## Lists the active violations for a given Device Defender security profile.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string
  ##                      : The name of the Device Defender security profile for which violations are listed.
  ##   thingName: string
  ##            : The name of the thing whose active violations are listed.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_613369 = newJObject()
  add(query_613369, "nextToken", newJString(nextToken))
  add(query_613369, "securityProfileName", newJString(securityProfileName))
  add(query_613369, "thingName", newJString(thingName))
  add(query_613369, "maxResults", newJInt(maxResults))
  result = call_613368.call(nil, query_613369, nil, nil, nil)

var listActiveViolations* = Call_ListActiveViolations_613353(
    name: "listActiveViolations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/active-violations",
    validator: validate_ListActiveViolations_613354, base: "/",
    url: url_ListActiveViolations_613355, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAttachedPolicies_613370 = ref object of OpenApiRestCall_610658
proc url_ListAttachedPolicies_613372(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "target" in path, "`target` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/attached-policies/"),
               (kind: VariableSegment, value: "target")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListAttachedPolicies_613371(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the policies attached to the specified thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   target: JString (required)
  ##         : The group or principal for which the policies will be listed.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `target` field"
  var valid_613373 = path.getOrDefault("target")
  valid_613373 = validateParameter(valid_613373, JString, required = true,
                                 default = nil)
  if valid_613373 != nil:
    section.add "target", valid_613373
  result.add "path", section
  ## parameters in `query` object:
  ##   pageSize: JInt
  ##           : The maximum number of results to be returned per request.
  ##   recursive: JBool
  ##            : When true, recursively list attached policies.
  ##   marker: JString
  ##         : The token to retrieve the next set of results.
  section = newJObject()
  var valid_613374 = query.getOrDefault("pageSize")
  valid_613374 = validateParameter(valid_613374, JInt, required = false, default = nil)
  if valid_613374 != nil:
    section.add "pageSize", valid_613374
  var valid_613375 = query.getOrDefault("recursive")
  valid_613375 = validateParameter(valid_613375, JBool, required = false, default = nil)
  if valid_613375 != nil:
    section.add "recursive", valid_613375
  var valid_613376 = query.getOrDefault("marker")
  valid_613376 = validateParameter(valid_613376, JString, required = false,
                                 default = nil)
  if valid_613376 != nil:
    section.add "marker", valid_613376
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613377 = header.getOrDefault("X-Amz-Signature")
  valid_613377 = validateParameter(valid_613377, JString, required = false,
                                 default = nil)
  if valid_613377 != nil:
    section.add "X-Amz-Signature", valid_613377
  var valid_613378 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613378 = validateParameter(valid_613378, JString, required = false,
                                 default = nil)
  if valid_613378 != nil:
    section.add "X-Amz-Content-Sha256", valid_613378
  var valid_613379 = header.getOrDefault("X-Amz-Date")
  valid_613379 = validateParameter(valid_613379, JString, required = false,
                                 default = nil)
  if valid_613379 != nil:
    section.add "X-Amz-Date", valid_613379
  var valid_613380 = header.getOrDefault("X-Amz-Credential")
  valid_613380 = validateParameter(valid_613380, JString, required = false,
                                 default = nil)
  if valid_613380 != nil:
    section.add "X-Amz-Credential", valid_613380
  var valid_613381 = header.getOrDefault("X-Amz-Security-Token")
  valid_613381 = validateParameter(valid_613381, JString, required = false,
                                 default = nil)
  if valid_613381 != nil:
    section.add "X-Amz-Security-Token", valid_613381
  var valid_613382 = header.getOrDefault("X-Amz-Algorithm")
  valid_613382 = validateParameter(valid_613382, JString, required = false,
                                 default = nil)
  if valid_613382 != nil:
    section.add "X-Amz-Algorithm", valid_613382
  var valid_613383 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613383 = validateParameter(valid_613383, JString, required = false,
                                 default = nil)
  if valid_613383 != nil:
    section.add "X-Amz-SignedHeaders", valid_613383
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613384: Call_ListAttachedPolicies_613370; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the policies attached to the specified thing group.
  ## 
  let valid = call_613384.validator(path, query, header, formData, body)
  let scheme = call_613384.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613384.url(scheme.get, call_613384.host, call_613384.base,
                         call_613384.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613384, url, valid)

proc call*(call_613385: Call_ListAttachedPolicies_613370; target: string;
          pageSize: int = 0; recursive: bool = false; marker: string = ""): Recallable =
  ## listAttachedPolicies
  ## Lists the policies attached to the specified thing group.
  ##   pageSize: int
  ##           : The maximum number of results to be returned per request.
  ##   recursive: bool
  ##            : When true, recursively list attached policies.
  ##   target: string (required)
  ##         : The group or principal for which the policies will be listed.
  ##   marker: string
  ##         : The token to retrieve the next set of results.
  var path_613386 = newJObject()
  var query_613387 = newJObject()
  add(query_613387, "pageSize", newJInt(pageSize))
  add(query_613387, "recursive", newJBool(recursive))
  add(path_613386, "target", newJString(target))
  add(query_613387, "marker", newJString(marker))
  result = call_613385.call(path_613386, query_613387, nil, nil, nil)

var listAttachedPolicies* = Call_ListAttachedPolicies_613370(
    name: "listAttachedPolicies", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/attached-policies/{target}",
    validator: validate_ListAttachedPolicies_613371, base: "/",
    url: url_ListAttachedPolicies_613372, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditFindings_613388 = ref object of OpenApiRestCall_610658
proc url_ListAuditFindings_613390(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditFindings_613389(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613391 = header.getOrDefault("X-Amz-Signature")
  valid_613391 = validateParameter(valid_613391, JString, required = false,
                                 default = nil)
  if valid_613391 != nil:
    section.add "X-Amz-Signature", valid_613391
  var valid_613392 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613392 = validateParameter(valid_613392, JString, required = false,
                                 default = nil)
  if valid_613392 != nil:
    section.add "X-Amz-Content-Sha256", valid_613392
  var valid_613393 = header.getOrDefault("X-Amz-Date")
  valid_613393 = validateParameter(valid_613393, JString, required = false,
                                 default = nil)
  if valid_613393 != nil:
    section.add "X-Amz-Date", valid_613393
  var valid_613394 = header.getOrDefault("X-Amz-Credential")
  valid_613394 = validateParameter(valid_613394, JString, required = false,
                                 default = nil)
  if valid_613394 != nil:
    section.add "X-Amz-Credential", valid_613394
  var valid_613395 = header.getOrDefault("X-Amz-Security-Token")
  valid_613395 = validateParameter(valid_613395, JString, required = false,
                                 default = nil)
  if valid_613395 != nil:
    section.add "X-Amz-Security-Token", valid_613395
  var valid_613396 = header.getOrDefault("X-Amz-Algorithm")
  valid_613396 = validateParameter(valid_613396, JString, required = false,
                                 default = nil)
  if valid_613396 != nil:
    section.add "X-Amz-Algorithm", valid_613396
  var valid_613397 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613397 = validateParameter(valid_613397, JString, required = false,
                                 default = nil)
  if valid_613397 != nil:
    section.add "X-Amz-SignedHeaders", valid_613397
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613399: Call_ListAuditFindings_613388; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ## 
  let valid = call_613399.validator(path, query, header, formData, body)
  let scheme = call_613399.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613399.url(scheme.get, call_613399.host, call_613399.base,
                         call_613399.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613399, url, valid)

proc call*(call_613400: Call_ListAuditFindings_613388; body: JsonNode): Recallable =
  ## listAuditFindings
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ##   body: JObject (required)
  var body_613401 = newJObject()
  if body != nil:
    body_613401 = body
  result = call_613400.call(nil, nil, nil, nil, body_613401)

var listAuditFindings* = Call_ListAuditFindings_613388(name: "listAuditFindings",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/audit/findings",
    validator: validate_ListAuditFindings_613389, base: "/",
    url: url_ListAuditFindings_613390, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditMitigationActionsExecutions_613402 = ref object of OpenApiRestCall_610658
proc url_ListAuditMitigationActionsExecutions_613404(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditMitigationActionsExecutions_613403(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the status of audit mitigation action tasks that were executed.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   actionStatus: JString
  ##               : Specify this filter to limit results to those with a specific status.
  ##   taskId: JString (required)
  ##         : Specify this filter to limit results to actions for a specific audit mitigation actions task.
  ##   findingId: JString (required)
  ##            : Specify this filter to limit results to those that were applied to a specific audit finding.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  var valid_613405 = query.getOrDefault("nextToken")
  valid_613405 = validateParameter(valid_613405, JString, required = false,
                                 default = nil)
  if valid_613405 != nil:
    section.add "nextToken", valid_613405
  var valid_613406 = query.getOrDefault("actionStatus")
  valid_613406 = validateParameter(valid_613406, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_613406 != nil:
    section.add "actionStatus", valid_613406
  assert query != nil, "query argument is necessary due to required `taskId` field"
  var valid_613407 = query.getOrDefault("taskId")
  valid_613407 = validateParameter(valid_613407, JString, required = true,
                                 default = nil)
  if valid_613407 != nil:
    section.add "taskId", valid_613407
  var valid_613408 = query.getOrDefault("findingId")
  valid_613408 = validateParameter(valid_613408, JString, required = true,
                                 default = nil)
  if valid_613408 != nil:
    section.add "findingId", valid_613408
  var valid_613409 = query.getOrDefault("maxResults")
  valid_613409 = validateParameter(valid_613409, JInt, required = false, default = nil)
  if valid_613409 != nil:
    section.add "maxResults", valid_613409
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613410 = header.getOrDefault("X-Amz-Signature")
  valid_613410 = validateParameter(valid_613410, JString, required = false,
                                 default = nil)
  if valid_613410 != nil:
    section.add "X-Amz-Signature", valid_613410
  var valid_613411 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613411 = validateParameter(valid_613411, JString, required = false,
                                 default = nil)
  if valid_613411 != nil:
    section.add "X-Amz-Content-Sha256", valid_613411
  var valid_613412 = header.getOrDefault("X-Amz-Date")
  valid_613412 = validateParameter(valid_613412, JString, required = false,
                                 default = nil)
  if valid_613412 != nil:
    section.add "X-Amz-Date", valid_613412
  var valid_613413 = header.getOrDefault("X-Amz-Credential")
  valid_613413 = validateParameter(valid_613413, JString, required = false,
                                 default = nil)
  if valid_613413 != nil:
    section.add "X-Amz-Credential", valid_613413
  var valid_613414 = header.getOrDefault("X-Amz-Security-Token")
  valid_613414 = validateParameter(valid_613414, JString, required = false,
                                 default = nil)
  if valid_613414 != nil:
    section.add "X-Amz-Security-Token", valid_613414
  var valid_613415 = header.getOrDefault("X-Amz-Algorithm")
  valid_613415 = validateParameter(valid_613415, JString, required = false,
                                 default = nil)
  if valid_613415 != nil:
    section.add "X-Amz-Algorithm", valid_613415
  var valid_613416 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613416 = validateParameter(valid_613416, JString, required = false,
                                 default = nil)
  if valid_613416 != nil:
    section.add "X-Amz-SignedHeaders", valid_613416
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613417: Call_ListAuditMitigationActionsExecutions_613402;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the status of audit mitigation action tasks that were executed.
  ## 
  let valid = call_613417.validator(path, query, header, formData, body)
  let scheme = call_613417.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613417.url(scheme.get, call_613417.host, call_613417.base,
                         call_613417.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613417, url, valid)

proc call*(call_613418: Call_ListAuditMitigationActionsExecutions_613402;
          taskId: string; findingId: string; nextToken: string = "";
          actionStatus: string = "IN_PROGRESS"; maxResults: int = 0): Recallable =
  ## listAuditMitigationActionsExecutions
  ## Gets the status of audit mitigation action tasks that were executed.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   actionStatus: string
  ##               : Specify this filter to limit results to those with a specific status.
  ##   taskId: string (required)
  ##         : Specify this filter to limit results to actions for a specific audit mitigation actions task.
  ##   findingId: string (required)
  ##            : Specify this filter to limit results to those that were applied to a specific audit finding.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_613419 = newJObject()
  add(query_613419, "nextToken", newJString(nextToken))
  add(query_613419, "actionStatus", newJString(actionStatus))
  add(query_613419, "taskId", newJString(taskId))
  add(query_613419, "findingId", newJString(findingId))
  add(query_613419, "maxResults", newJInt(maxResults))
  result = call_613418.call(nil, query_613419, nil, nil, nil)

var listAuditMitigationActionsExecutions* = Call_ListAuditMitigationActionsExecutions_613402(
    name: "listAuditMitigationActionsExecutions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/executions#taskId&findingId",
    validator: validate_ListAuditMitigationActionsExecutions_613403, base: "/",
    url: url_ListAuditMitigationActionsExecutions_613404,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditMitigationActionsTasks_613420 = ref object of OpenApiRestCall_610658
proc url_ListAuditMitigationActionsTasks_613422(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditMitigationActionsTasks_613421(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endTime: JString (required)
  ##          : Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : Specify this filter to limit results to tasks that began on or after a specific date and time.
  ##   findingId: JString
  ##            : Specify this filter to limit results to tasks that were applied to a specific audit finding.
  ##   taskStatus: JString
  ##             : Specify this filter to limit results to tasks that are in a specific state.
  ##   auditTaskId: JString
  ##              : Specify this filter to limit results to tasks that were applied to results for a specific audit.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_613423 = query.getOrDefault("endTime")
  valid_613423 = validateParameter(valid_613423, JString, required = true,
                                 default = nil)
  if valid_613423 != nil:
    section.add "endTime", valid_613423
  var valid_613424 = query.getOrDefault("nextToken")
  valid_613424 = validateParameter(valid_613424, JString, required = false,
                                 default = nil)
  if valid_613424 != nil:
    section.add "nextToken", valid_613424
  var valid_613425 = query.getOrDefault("startTime")
  valid_613425 = validateParameter(valid_613425, JString, required = true,
                                 default = nil)
  if valid_613425 != nil:
    section.add "startTime", valid_613425
  var valid_613426 = query.getOrDefault("findingId")
  valid_613426 = validateParameter(valid_613426, JString, required = false,
                                 default = nil)
  if valid_613426 != nil:
    section.add "findingId", valid_613426
  var valid_613427 = query.getOrDefault("taskStatus")
  valid_613427 = validateParameter(valid_613427, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_613427 != nil:
    section.add "taskStatus", valid_613427
  var valid_613428 = query.getOrDefault("auditTaskId")
  valid_613428 = validateParameter(valid_613428, JString, required = false,
                                 default = nil)
  if valid_613428 != nil:
    section.add "auditTaskId", valid_613428
  var valid_613429 = query.getOrDefault("maxResults")
  valid_613429 = validateParameter(valid_613429, JInt, required = false, default = nil)
  if valid_613429 != nil:
    section.add "maxResults", valid_613429
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613430 = header.getOrDefault("X-Amz-Signature")
  valid_613430 = validateParameter(valid_613430, JString, required = false,
                                 default = nil)
  if valid_613430 != nil:
    section.add "X-Amz-Signature", valid_613430
  var valid_613431 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613431 = validateParameter(valid_613431, JString, required = false,
                                 default = nil)
  if valid_613431 != nil:
    section.add "X-Amz-Content-Sha256", valid_613431
  var valid_613432 = header.getOrDefault("X-Amz-Date")
  valid_613432 = validateParameter(valid_613432, JString, required = false,
                                 default = nil)
  if valid_613432 != nil:
    section.add "X-Amz-Date", valid_613432
  var valid_613433 = header.getOrDefault("X-Amz-Credential")
  valid_613433 = validateParameter(valid_613433, JString, required = false,
                                 default = nil)
  if valid_613433 != nil:
    section.add "X-Amz-Credential", valid_613433
  var valid_613434 = header.getOrDefault("X-Amz-Security-Token")
  valid_613434 = validateParameter(valid_613434, JString, required = false,
                                 default = nil)
  if valid_613434 != nil:
    section.add "X-Amz-Security-Token", valid_613434
  var valid_613435 = header.getOrDefault("X-Amz-Algorithm")
  valid_613435 = validateParameter(valid_613435, JString, required = false,
                                 default = nil)
  if valid_613435 != nil:
    section.add "X-Amz-Algorithm", valid_613435
  var valid_613436 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613436 = validateParameter(valid_613436, JString, required = false,
                                 default = nil)
  if valid_613436 != nil:
    section.add "X-Amz-SignedHeaders", valid_613436
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613437: Call_ListAuditMitigationActionsTasks_613420;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ## 
  let valid = call_613437.validator(path, query, header, formData, body)
  let scheme = call_613437.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613437.url(scheme.get, call_613437.host, call_613437.base,
                         call_613437.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613437, url, valid)

proc call*(call_613438: Call_ListAuditMitigationActionsTasks_613420;
          endTime: string; startTime: string; nextToken: string = "";
          findingId: string = ""; taskStatus: string = "IN_PROGRESS";
          auditTaskId: string = ""; maxResults: int = 0): Recallable =
  ## listAuditMitigationActionsTasks
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ##   endTime: string (required)
  ##          : Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : Specify this filter to limit results to tasks that began on or after a specific date and time.
  ##   findingId: string
  ##            : Specify this filter to limit results to tasks that were applied to a specific audit finding.
  ##   taskStatus: string
  ##             : Specify this filter to limit results to tasks that are in a specific state.
  ##   auditTaskId: string
  ##              : Specify this filter to limit results to tasks that were applied to results for a specific audit.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_613439 = newJObject()
  add(query_613439, "endTime", newJString(endTime))
  add(query_613439, "nextToken", newJString(nextToken))
  add(query_613439, "startTime", newJString(startTime))
  add(query_613439, "findingId", newJString(findingId))
  add(query_613439, "taskStatus", newJString(taskStatus))
  add(query_613439, "auditTaskId", newJString(auditTaskId))
  add(query_613439, "maxResults", newJInt(maxResults))
  result = call_613438.call(nil, query_613439, nil, nil, nil)

var listAuditMitigationActionsTasks* = Call_ListAuditMitigationActionsTasks_613420(
    name: "listAuditMitigationActionsTasks", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/tasks#startTime&endTime",
    validator: validate_ListAuditMitigationActionsTasks_613421, base: "/",
    url: url_ListAuditMitigationActionsTasks_613422,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditTasks_613440 = ref object of OpenApiRestCall_610658
proc url_ListAuditTasks_613442(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditTasks_613441(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the Device Defender audits that have been performed during a given time period.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endTime: JString (required)
  ##          : The end of the time period.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
  ##   taskStatus: JString
  ##             : A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
  ##   taskType: JString
  ##           : A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_613443 = query.getOrDefault("endTime")
  valid_613443 = validateParameter(valid_613443, JString, required = true,
                                 default = nil)
  if valid_613443 != nil:
    section.add "endTime", valid_613443
  var valid_613444 = query.getOrDefault("nextToken")
  valid_613444 = validateParameter(valid_613444, JString, required = false,
                                 default = nil)
  if valid_613444 != nil:
    section.add "nextToken", valid_613444
  var valid_613445 = query.getOrDefault("startTime")
  valid_613445 = validateParameter(valid_613445, JString, required = true,
                                 default = nil)
  if valid_613445 != nil:
    section.add "startTime", valid_613445
  var valid_613446 = query.getOrDefault("taskStatus")
  valid_613446 = validateParameter(valid_613446, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_613446 != nil:
    section.add "taskStatus", valid_613446
  var valid_613447 = query.getOrDefault("taskType")
  valid_613447 = validateParameter(valid_613447, JString, required = false,
                                 default = newJString("ON_DEMAND_AUDIT_TASK"))
  if valid_613447 != nil:
    section.add "taskType", valid_613447
  var valid_613448 = query.getOrDefault("maxResults")
  valid_613448 = validateParameter(valid_613448, JInt, required = false, default = nil)
  if valid_613448 != nil:
    section.add "maxResults", valid_613448
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613449 = header.getOrDefault("X-Amz-Signature")
  valid_613449 = validateParameter(valid_613449, JString, required = false,
                                 default = nil)
  if valid_613449 != nil:
    section.add "X-Amz-Signature", valid_613449
  var valid_613450 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613450 = validateParameter(valid_613450, JString, required = false,
                                 default = nil)
  if valid_613450 != nil:
    section.add "X-Amz-Content-Sha256", valid_613450
  var valid_613451 = header.getOrDefault("X-Amz-Date")
  valid_613451 = validateParameter(valid_613451, JString, required = false,
                                 default = nil)
  if valid_613451 != nil:
    section.add "X-Amz-Date", valid_613451
  var valid_613452 = header.getOrDefault("X-Amz-Credential")
  valid_613452 = validateParameter(valid_613452, JString, required = false,
                                 default = nil)
  if valid_613452 != nil:
    section.add "X-Amz-Credential", valid_613452
  var valid_613453 = header.getOrDefault("X-Amz-Security-Token")
  valid_613453 = validateParameter(valid_613453, JString, required = false,
                                 default = nil)
  if valid_613453 != nil:
    section.add "X-Amz-Security-Token", valid_613453
  var valid_613454 = header.getOrDefault("X-Amz-Algorithm")
  valid_613454 = validateParameter(valid_613454, JString, required = false,
                                 default = nil)
  if valid_613454 != nil:
    section.add "X-Amz-Algorithm", valid_613454
  var valid_613455 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613455 = validateParameter(valid_613455, JString, required = false,
                                 default = nil)
  if valid_613455 != nil:
    section.add "X-Amz-SignedHeaders", valid_613455
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613456: Call_ListAuditTasks_613440; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender audits that have been performed during a given time period.
  ## 
  let valid = call_613456.validator(path, query, header, formData, body)
  let scheme = call_613456.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613456.url(scheme.get, call_613456.host, call_613456.base,
                         call_613456.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613456, url, valid)

proc call*(call_613457: Call_ListAuditTasks_613440; endTime: string;
          startTime: string; nextToken: string = "";
          taskStatus: string = "IN_PROGRESS";
          taskType: string = "ON_DEMAND_AUDIT_TASK"; maxResults: int = 0): Recallable =
  ## listAuditTasks
  ## Lists the Device Defender audits that have been performed during a given time period.
  ##   endTime: string (required)
  ##          : The end of the time period.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
  ##   taskStatus: string
  ##             : A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
  ##   taskType: string
  ##           : A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_613458 = newJObject()
  add(query_613458, "endTime", newJString(endTime))
  add(query_613458, "nextToken", newJString(nextToken))
  add(query_613458, "startTime", newJString(startTime))
  add(query_613458, "taskStatus", newJString(taskStatus))
  add(query_613458, "taskType", newJString(taskType))
  add(query_613458, "maxResults", newJInt(maxResults))
  result = call_613457.call(nil, query_613458, nil, nil, nil)

var listAuditTasks* = Call_ListAuditTasks_613440(name: "listAuditTasks",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/audit/tasks#startTime&endTime", validator: validate_ListAuditTasks_613441,
    base: "/", url: url_ListAuditTasks_613442, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuthorizers_613459 = ref object of OpenApiRestCall_610658
proc url_ListAuthorizers_613461(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuthorizers_613460(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Lists the authorizers registered in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Return the list of authorizers in ascending alphabetical order.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   status: JString
  ##         : The status of the list authorizers request.
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  section = newJObject()
  var valid_613462 = query.getOrDefault("isAscendingOrder")
  valid_613462 = validateParameter(valid_613462, JBool, required = false, default = nil)
  if valid_613462 != nil:
    section.add "isAscendingOrder", valid_613462
  var valid_613463 = query.getOrDefault("pageSize")
  valid_613463 = validateParameter(valid_613463, JInt, required = false, default = nil)
  if valid_613463 != nil:
    section.add "pageSize", valid_613463
  var valid_613464 = query.getOrDefault("status")
  valid_613464 = validateParameter(valid_613464, JString, required = false,
                                 default = newJString("ACTIVE"))
  if valid_613464 != nil:
    section.add "status", valid_613464
  var valid_613465 = query.getOrDefault("marker")
  valid_613465 = validateParameter(valid_613465, JString, required = false,
                                 default = nil)
  if valid_613465 != nil:
    section.add "marker", valid_613465
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613466 = header.getOrDefault("X-Amz-Signature")
  valid_613466 = validateParameter(valid_613466, JString, required = false,
                                 default = nil)
  if valid_613466 != nil:
    section.add "X-Amz-Signature", valid_613466
  var valid_613467 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613467 = validateParameter(valid_613467, JString, required = false,
                                 default = nil)
  if valid_613467 != nil:
    section.add "X-Amz-Content-Sha256", valid_613467
  var valid_613468 = header.getOrDefault("X-Amz-Date")
  valid_613468 = validateParameter(valid_613468, JString, required = false,
                                 default = nil)
  if valid_613468 != nil:
    section.add "X-Amz-Date", valid_613468
  var valid_613469 = header.getOrDefault("X-Amz-Credential")
  valid_613469 = validateParameter(valid_613469, JString, required = false,
                                 default = nil)
  if valid_613469 != nil:
    section.add "X-Amz-Credential", valid_613469
  var valid_613470 = header.getOrDefault("X-Amz-Security-Token")
  valid_613470 = validateParameter(valid_613470, JString, required = false,
                                 default = nil)
  if valid_613470 != nil:
    section.add "X-Amz-Security-Token", valid_613470
  var valid_613471 = header.getOrDefault("X-Amz-Algorithm")
  valid_613471 = validateParameter(valid_613471, JString, required = false,
                                 default = nil)
  if valid_613471 != nil:
    section.add "X-Amz-Algorithm", valid_613471
  var valid_613472 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613472 = validateParameter(valid_613472, JString, required = false,
                                 default = nil)
  if valid_613472 != nil:
    section.add "X-Amz-SignedHeaders", valid_613472
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613473: Call_ListAuthorizers_613459; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the authorizers registered in your account.
  ## 
  let valid = call_613473.validator(path, query, header, formData, body)
  let scheme = call_613473.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613473.url(scheme.get, call_613473.host, call_613473.base,
                         call_613473.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613473, url, valid)

proc call*(call_613474: Call_ListAuthorizers_613459;
          isAscendingOrder: bool = false; pageSize: int = 0; status: string = "ACTIVE";
          marker: string = ""): Recallable =
  ## listAuthorizers
  ## Lists the authorizers registered in your account.
  ##   isAscendingOrder: bool
  ##                   : Return the list of authorizers in ascending alphabetical order.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   status: string
  ##         : The status of the list authorizers request.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  var query_613475 = newJObject()
  add(query_613475, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_613475, "pageSize", newJInt(pageSize))
  add(query_613475, "status", newJString(status))
  add(query_613475, "marker", newJString(marker))
  result = call_613474.call(nil, query_613475, nil, nil, nil)

var listAuthorizers* = Call_ListAuthorizers_613459(name: "listAuthorizers",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/authorizers/",
    validator: validate_ListAuthorizers_613460, base: "/", url: url_ListAuthorizers_613461,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListBillingGroups_613476 = ref object of OpenApiRestCall_610658
proc url_ListBillingGroups_613478(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListBillingGroups_613477(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Lists the billing groups you have created.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   namePrefixFilter: JString
  ##                   : Limit the results to billing groups whose names have the given prefix.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_613479 = query.getOrDefault("nextToken")
  valid_613479 = validateParameter(valid_613479, JString, required = false,
                                 default = nil)
  if valid_613479 != nil:
    section.add "nextToken", valid_613479
  var valid_613480 = query.getOrDefault("namePrefixFilter")
  valid_613480 = validateParameter(valid_613480, JString, required = false,
                                 default = nil)
  if valid_613480 != nil:
    section.add "namePrefixFilter", valid_613480
  var valid_613481 = query.getOrDefault("maxResults")
  valid_613481 = validateParameter(valid_613481, JInt, required = false, default = nil)
  if valid_613481 != nil:
    section.add "maxResults", valid_613481
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613482 = header.getOrDefault("X-Amz-Signature")
  valid_613482 = validateParameter(valid_613482, JString, required = false,
                                 default = nil)
  if valid_613482 != nil:
    section.add "X-Amz-Signature", valid_613482
  var valid_613483 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613483 = validateParameter(valid_613483, JString, required = false,
                                 default = nil)
  if valid_613483 != nil:
    section.add "X-Amz-Content-Sha256", valid_613483
  var valid_613484 = header.getOrDefault("X-Amz-Date")
  valid_613484 = validateParameter(valid_613484, JString, required = false,
                                 default = nil)
  if valid_613484 != nil:
    section.add "X-Amz-Date", valid_613484
  var valid_613485 = header.getOrDefault("X-Amz-Credential")
  valid_613485 = validateParameter(valid_613485, JString, required = false,
                                 default = nil)
  if valid_613485 != nil:
    section.add "X-Amz-Credential", valid_613485
  var valid_613486 = header.getOrDefault("X-Amz-Security-Token")
  valid_613486 = validateParameter(valid_613486, JString, required = false,
                                 default = nil)
  if valid_613486 != nil:
    section.add "X-Amz-Security-Token", valid_613486
  var valid_613487 = header.getOrDefault("X-Amz-Algorithm")
  valid_613487 = validateParameter(valid_613487, JString, required = false,
                                 default = nil)
  if valid_613487 != nil:
    section.add "X-Amz-Algorithm", valid_613487
  var valid_613488 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613488 = validateParameter(valid_613488, JString, required = false,
                                 default = nil)
  if valid_613488 != nil:
    section.add "X-Amz-SignedHeaders", valid_613488
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613489: Call_ListBillingGroups_613476; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the billing groups you have created.
  ## 
  let valid = call_613489.validator(path, query, header, formData, body)
  let scheme = call_613489.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613489.url(scheme.get, call_613489.host, call_613489.base,
                         call_613489.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613489, url, valid)

proc call*(call_613490: Call_ListBillingGroups_613476; nextToken: string = "";
          namePrefixFilter: string = ""; maxResults: int = 0): Recallable =
  ## listBillingGroups
  ## Lists the billing groups you have created.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   namePrefixFilter: string
  ##                   : Limit the results to billing groups whose names have the given prefix.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var query_613491 = newJObject()
  add(query_613491, "nextToken", newJString(nextToken))
  add(query_613491, "namePrefixFilter", newJString(namePrefixFilter))
  add(query_613491, "maxResults", newJInt(maxResults))
  result = call_613490.call(nil, query_613491, nil, nil, nil)

var listBillingGroups* = Call_ListBillingGroups_613476(name: "listBillingGroups",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/billing-groups",
    validator: validate_ListBillingGroups_613477, base: "/",
    url: url_ListBillingGroups_613478, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCACertificates_613492 = ref object of OpenApiRestCall_610658
proc url_ListCACertificates_613494(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListCACertificates_613493(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Determines the order of the results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_613495 = query.getOrDefault("isAscendingOrder")
  valid_613495 = validateParameter(valid_613495, JBool, required = false, default = nil)
  if valid_613495 != nil:
    section.add "isAscendingOrder", valid_613495
  var valid_613496 = query.getOrDefault("pageSize")
  valid_613496 = validateParameter(valid_613496, JInt, required = false, default = nil)
  if valid_613496 != nil:
    section.add "pageSize", valid_613496
  var valid_613497 = query.getOrDefault("marker")
  valid_613497 = validateParameter(valid_613497, JString, required = false,
                                 default = nil)
  if valid_613497 != nil:
    section.add "marker", valid_613497
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613498 = header.getOrDefault("X-Amz-Signature")
  valid_613498 = validateParameter(valid_613498, JString, required = false,
                                 default = nil)
  if valid_613498 != nil:
    section.add "X-Amz-Signature", valid_613498
  var valid_613499 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613499 = validateParameter(valid_613499, JString, required = false,
                                 default = nil)
  if valid_613499 != nil:
    section.add "X-Amz-Content-Sha256", valid_613499
  var valid_613500 = header.getOrDefault("X-Amz-Date")
  valid_613500 = validateParameter(valid_613500, JString, required = false,
                                 default = nil)
  if valid_613500 != nil:
    section.add "X-Amz-Date", valid_613500
  var valid_613501 = header.getOrDefault("X-Amz-Credential")
  valid_613501 = validateParameter(valid_613501, JString, required = false,
                                 default = nil)
  if valid_613501 != nil:
    section.add "X-Amz-Credential", valid_613501
  var valid_613502 = header.getOrDefault("X-Amz-Security-Token")
  valid_613502 = validateParameter(valid_613502, JString, required = false,
                                 default = nil)
  if valid_613502 != nil:
    section.add "X-Amz-Security-Token", valid_613502
  var valid_613503 = header.getOrDefault("X-Amz-Algorithm")
  valid_613503 = validateParameter(valid_613503, JString, required = false,
                                 default = nil)
  if valid_613503 != nil:
    section.add "X-Amz-Algorithm", valid_613503
  var valid_613504 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613504 = validateParameter(valid_613504, JString, required = false,
                                 default = nil)
  if valid_613504 != nil:
    section.add "X-Amz-SignedHeaders", valid_613504
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613505: Call_ListCACertificates_613492; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  let valid = call_613505.validator(path, query, header, formData, body)
  let scheme = call_613505.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613505.url(scheme.get, call_613505.host, call_613505.base,
                         call_613505.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613505, url, valid)

proc call*(call_613506: Call_ListCACertificates_613492;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listCACertificates
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ##   isAscendingOrder: bool
  ##                   : Determines the order of the results.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_613507 = newJObject()
  add(query_613507, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_613507, "pageSize", newJInt(pageSize))
  add(query_613507, "marker", newJString(marker))
  result = call_613506.call(nil, query_613507, nil, nil, nil)

var listCACertificates* = Call_ListCACertificates_613492(
    name: "listCACertificates", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/cacertificates", validator: validate_ListCACertificates_613493,
    base: "/", url: url_ListCACertificates_613494,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCertificatesByCA_613508 = ref object of OpenApiRestCall_610658
proc url_ListCertificatesByCA_613510(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates-by-ca/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListCertificatesByCA_613509(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List the device certificates signed by the specified CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_613511 = path.getOrDefault("caCertificateId")
  valid_613511 = validateParameter(valid_613511, JString, required = true,
                                 default = nil)
  if valid_613511 != nil:
    section.add "caCertificateId", valid_613511
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_613512 = query.getOrDefault("isAscendingOrder")
  valid_613512 = validateParameter(valid_613512, JBool, required = false, default = nil)
  if valid_613512 != nil:
    section.add "isAscendingOrder", valid_613512
  var valid_613513 = query.getOrDefault("pageSize")
  valid_613513 = validateParameter(valid_613513, JInt, required = false, default = nil)
  if valid_613513 != nil:
    section.add "pageSize", valid_613513
  var valid_613514 = query.getOrDefault("marker")
  valid_613514 = validateParameter(valid_613514, JString, required = false,
                                 default = nil)
  if valid_613514 != nil:
    section.add "marker", valid_613514
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613515 = header.getOrDefault("X-Amz-Signature")
  valid_613515 = validateParameter(valid_613515, JString, required = false,
                                 default = nil)
  if valid_613515 != nil:
    section.add "X-Amz-Signature", valid_613515
  var valid_613516 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613516 = validateParameter(valid_613516, JString, required = false,
                                 default = nil)
  if valid_613516 != nil:
    section.add "X-Amz-Content-Sha256", valid_613516
  var valid_613517 = header.getOrDefault("X-Amz-Date")
  valid_613517 = validateParameter(valid_613517, JString, required = false,
                                 default = nil)
  if valid_613517 != nil:
    section.add "X-Amz-Date", valid_613517
  var valid_613518 = header.getOrDefault("X-Amz-Credential")
  valid_613518 = validateParameter(valid_613518, JString, required = false,
                                 default = nil)
  if valid_613518 != nil:
    section.add "X-Amz-Credential", valid_613518
  var valid_613519 = header.getOrDefault("X-Amz-Security-Token")
  valid_613519 = validateParameter(valid_613519, JString, required = false,
                                 default = nil)
  if valid_613519 != nil:
    section.add "X-Amz-Security-Token", valid_613519
  var valid_613520 = header.getOrDefault("X-Amz-Algorithm")
  valid_613520 = validateParameter(valid_613520, JString, required = false,
                                 default = nil)
  if valid_613520 != nil:
    section.add "X-Amz-Algorithm", valid_613520
  var valid_613521 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613521 = validateParameter(valid_613521, JString, required = false,
                                 default = nil)
  if valid_613521 != nil:
    section.add "X-Amz-SignedHeaders", valid_613521
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613522: Call_ListCertificatesByCA_613508; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the device certificates signed by the specified CA certificate.
  ## 
  let valid = call_613522.validator(path, query, header, formData, body)
  let scheme = call_613522.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613522.url(scheme.get, call_613522.host, call_613522.base,
                         call_613522.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613522, url, valid)

proc call*(call_613523: Call_ListCertificatesByCA_613508; caCertificateId: string;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listCertificatesByCA
  ## List the device certificates signed by the specified CA certificate.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: int
  ##           : The result page size.
  ##   caCertificateId: string (required)
  ##                  : The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
  ##   marker: string
  ##         : The marker for the next set of results.
  var path_613524 = newJObject()
  var query_613525 = newJObject()
  add(query_613525, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_613525, "pageSize", newJInt(pageSize))
  add(path_613524, "caCertificateId", newJString(caCertificateId))
  add(query_613525, "marker", newJString(marker))
  result = call_613523.call(path_613524, query_613525, nil, nil, nil)

var listCertificatesByCA* = Call_ListCertificatesByCA_613508(
    name: "listCertificatesByCA", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates-by-ca/{caCertificateId}",
    validator: validate_ListCertificatesByCA_613509, base: "/",
    url: url_ListCertificatesByCA_613510, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListDomainConfigurations_613526 = ref object of OpenApiRestCall_610658
proc url_ListDomainConfigurations_613528(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListDomainConfigurations_613527(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   pageSize: JInt
  ##           : The result page size.
  ##   serviceType: JString
  ##              : The type of service delivered by the endpoint.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_613529 = query.getOrDefault("pageSize")
  valid_613529 = validateParameter(valid_613529, JInt, required = false, default = nil)
  if valid_613529 != nil:
    section.add "pageSize", valid_613529
  var valid_613530 = query.getOrDefault("serviceType")
  valid_613530 = validateParameter(valid_613530, JString, required = false,
                                 default = newJString("DATA"))
  if valid_613530 != nil:
    section.add "serviceType", valid_613530
  var valid_613531 = query.getOrDefault("marker")
  valid_613531 = validateParameter(valid_613531, JString, required = false,
                                 default = nil)
  if valid_613531 != nil:
    section.add "marker", valid_613531
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613532 = header.getOrDefault("X-Amz-Signature")
  valid_613532 = validateParameter(valid_613532, JString, required = false,
                                 default = nil)
  if valid_613532 != nil:
    section.add "X-Amz-Signature", valid_613532
  var valid_613533 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613533 = validateParameter(valid_613533, JString, required = false,
                                 default = nil)
  if valid_613533 != nil:
    section.add "X-Amz-Content-Sha256", valid_613533
  var valid_613534 = header.getOrDefault("X-Amz-Date")
  valid_613534 = validateParameter(valid_613534, JString, required = false,
                                 default = nil)
  if valid_613534 != nil:
    section.add "X-Amz-Date", valid_613534
  var valid_613535 = header.getOrDefault("X-Amz-Credential")
  valid_613535 = validateParameter(valid_613535, JString, required = false,
                                 default = nil)
  if valid_613535 != nil:
    section.add "X-Amz-Credential", valid_613535
  var valid_613536 = header.getOrDefault("X-Amz-Security-Token")
  valid_613536 = validateParameter(valid_613536, JString, required = false,
                                 default = nil)
  if valid_613536 != nil:
    section.add "X-Amz-Security-Token", valid_613536
  var valid_613537 = header.getOrDefault("X-Amz-Algorithm")
  valid_613537 = validateParameter(valid_613537, JString, required = false,
                                 default = nil)
  if valid_613537 != nil:
    section.add "X-Amz-Algorithm", valid_613537
  var valid_613538 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613538 = validateParameter(valid_613538, JString, required = false,
                                 default = nil)
  if valid_613538 != nil:
    section.add "X-Amz-SignedHeaders", valid_613538
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613539: Call_ListDomainConfigurations_613526; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_613539.validator(path, query, header, formData, body)
  let scheme = call_613539.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613539.url(scheme.get, call_613539.host, call_613539.base,
                         call_613539.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613539, url, valid)

proc call*(call_613540: Call_ListDomainConfigurations_613526; pageSize: int = 0;
          serviceType: string = "DATA"; marker: string = ""): Recallable =
  ## listDomainConfigurations
  ## <p>Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   pageSize: int
  ##           : The result page size.
  ##   serviceType: string
  ##              : The type of service delivered by the endpoint.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_613541 = newJObject()
  add(query_613541, "pageSize", newJInt(pageSize))
  add(query_613541, "serviceType", newJString(serviceType))
  add(query_613541, "marker", newJString(marker))
  result = call_613540.call(nil, query_613541, nil, nil, nil)

var listDomainConfigurations* = Call_ListDomainConfigurations_613526(
    name: "listDomainConfigurations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/domainConfigurations",
    validator: validate_ListDomainConfigurations_613527, base: "/",
    url: url_ListDomainConfigurations_613528, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListIndices_613542 = ref object of OpenApiRestCall_610658
proc url_ListIndices_613544(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListIndices_613543(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the search indices.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token used to get the next set of results, or <code>null</code> if there are no additional results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_613545 = query.getOrDefault("nextToken")
  valid_613545 = validateParameter(valid_613545, JString, required = false,
                                 default = nil)
  if valid_613545 != nil:
    section.add "nextToken", valid_613545
  var valid_613546 = query.getOrDefault("maxResults")
  valid_613546 = validateParameter(valid_613546, JInt, required = false, default = nil)
  if valid_613546 != nil:
    section.add "maxResults", valid_613546
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613547 = header.getOrDefault("X-Amz-Signature")
  valid_613547 = validateParameter(valid_613547, JString, required = false,
                                 default = nil)
  if valid_613547 != nil:
    section.add "X-Amz-Signature", valid_613547
  var valid_613548 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613548 = validateParameter(valid_613548, JString, required = false,
                                 default = nil)
  if valid_613548 != nil:
    section.add "X-Amz-Content-Sha256", valid_613548
  var valid_613549 = header.getOrDefault("X-Amz-Date")
  valid_613549 = validateParameter(valid_613549, JString, required = false,
                                 default = nil)
  if valid_613549 != nil:
    section.add "X-Amz-Date", valid_613549
  var valid_613550 = header.getOrDefault("X-Amz-Credential")
  valid_613550 = validateParameter(valid_613550, JString, required = false,
                                 default = nil)
  if valid_613550 != nil:
    section.add "X-Amz-Credential", valid_613550
  var valid_613551 = header.getOrDefault("X-Amz-Security-Token")
  valid_613551 = validateParameter(valid_613551, JString, required = false,
                                 default = nil)
  if valid_613551 != nil:
    section.add "X-Amz-Security-Token", valid_613551
  var valid_613552 = header.getOrDefault("X-Amz-Algorithm")
  valid_613552 = validateParameter(valid_613552, JString, required = false,
                                 default = nil)
  if valid_613552 != nil:
    section.add "X-Amz-Algorithm", valid_613552
  var valid_613553 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613553 = validateParameter(valid_613553, JString, required = false,
                                 default = nil)
  if valid_613553 != nil:
    section.add "X-Amz-SignedHeaders", valid_613553
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613554: Call_ListIndices_613542; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the search indices.
  ## 
  let valid = call_613554.validator(path, query, header, formData, body)
  let scheme = call_613554.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613554.url(scheme.get, call_613554.host, call_613554.base,
                         call_613554.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613554, url, valid)

proc call*(call_613555: Call_ListIndices_613542; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listIndices
  ## Lists the search indices.
  ##   nextToken: string
  ##            : The token used to get the next set of results, or <code>null</code> if there are no additional results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_613556 = newJObject()
  add(query_613556, "nextToken", newJString(nextToken))
  add(query_613556, "maxResults", newJInt(maxResults))
  result = call_613555.call(nil, query_613556, nil, nil, nil)

var listIndices* = Call_ListIndices_613542(name: "listIndices",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/indices",
                                        validator: validate_ListIndices_613543,
                                        base: "/", url: url_ListIndices_613544,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobExecutionsForJob_613557 = ref object of OpenApiRestCall_610658
proc url_ListJobExecutionsForJob_613559(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListJobExecutionsForJob_613558(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the job executions for a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_613560 = path.getOrDefault("jobId")
  valid_613560 = validateParameter(valid_613560, JString, required = true,
                                 default = nil)
  if valid_613560 != nil:
    section.add "jobId", valid_613560
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : The status of the job.
  ##   maxResults: JInt
  ##             : The maximum number of results to be returned per request.
  section = newJObject()
  var valid_613561 = query.getOrDefault("nextToken")
  valid_613561 = validateParameter(valid_613561, JString, required = false,
                                 default = nil)
  if valid_613561 != nil:
    section.add "nextToken", valid_613561
  var valid_613562 = query.getOrDefault("status")
  valid_613562 = validateParameter(valid_613562, JString, required = false,
                                 default = newJString("QUEUED"))
  if valid_613562 != nil:
    section.add "status", valid_613562
  var valid_613563 = query.getOrDefault("maxResults")
  valid_613563 = validateParameter(valid_613563, JInt, required = false, default = nil)
  if valid_613563 != nil:
    section.add "maxResults", valid_613563
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613564 = header.getOrDefault("X-Amz-Signature")
  valid_613564 = validateParameter(valid_613564, JString, required = false,
                                 default = nil)
  if valid_613564 != nil:
    section.add "X-Amz-Signature", valid_613564
  var valid_613565 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613565 = validateParameter(valid_613565, JString, required = false,
                                 default = nil)
  if valid_613565 != nil:
    section.add "X-Amz-Content-Sha256", valid_613565
  var valid_613566 = header.getOrDefault("X-Amz-Date")
  valid_613566 = validateParameter(valid_613566, JString, required = false,
                                 default = nil)
  if valid_613566 != nil:
    section.add "X-Amz-Date", valid_613566
  var valid_613567 = header.getOrDefault("X-Amz-Credential")
  valid_613567 = validateParameter(valid_613567, JString, required = false,
                                 default = nil)
  if valid_613567 != nil:
    section.add "X-Amz-Credential", valid_613567
  var valid_613568 = header.getOrDefault("X-Amz-Security-Token")
  valid_613568 = validateParameter(valid_613568, JString, required = false,
                                 default = nil)
  if valid_613568 != nil:
    section.add "X-Amz-Security-Token", valid_613568
  var valid_613569 = header.getOrDefault("X-Amz-Algorithm")
  valid_613569 = validateParameter(valid_613569, JString, required = false,
                                 default = nil)
  if valid_613569 != nil:
    section.add "X-Amz-Algorithm", valid_613569
  var valid_613570 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613570 = validateParameter(valid_613570, JString, required = false,
                                 default = nil)
  if valid_613570 != nil:
    section.add "X-Amz-SignedHeaders", valid_613570
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613571: Call_ListJobExecutionsForJob_613557; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the job executions for a job.
  ## 
  let valid = call_613571.validator(path, query, header, formData, body)
  let scheme = call_613571.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613571.url(scheme.get, call_613571.host, call_613571.base,
                         call_613571.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613571, url, valid)

proc call*(call_613572: Call_ListJobExecutionsForJob_613557; jobId: string;
          nextToken: string = ""; status: string = "QUEUED"; maxResults: int = 0): Recallable =
  ## listJobExecutionsForJob
  ## Lists the job executions for a job.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   status: string
  ##         : The status of the job.
  ##   maxResults: int
  ##             : The maximum number of results to be returned per request.
  var path_613573 = newJObject()
  var query_613574 = newJObject()
  add(query_613574, "nextToken", newJString(nextToken))
  add(path_613573, "jobId", newJString(jobId))
  add(query_613574, "status", newJString(status))
  add(query_613574, "maxResults", newJInt(maxResults))
  result = call_613572.call(path_613573, query_613574, nil, nil, nil)

var listJobExecutionsForJob* = Call_ListJobExecutionsForJob_613557(
    name: "listJobExecutionsForJob", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/jobs/{jobId}/things",
    validator: validate_ListJobExecutionsForJob_613558, base: "/",
    url: url_ListJobExecutionsForJob_613559, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobExecutionsForThing_613575 = ref object of OpenApiRestCall_610658
proc url_ListJobExecutionsForThing_613577(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListJobExecutionsForThing_613576(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the job executions for the specified thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The thing name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_613578 = path.getOrDefault("thingName")
  valid_613578 = validateParameter(valid_613578, JString, required = true,
                                 default = nil)
  if valid_613578 != nil:
    section.add "thingName", valid_613578
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: JInt
  ##             : The maximum number of results to be returned per request.
  section = newJObject()
  var valid_613579 = query.getOrDefault("nextToken")
  valid_613579 = validateParameter(valid_613579, JString, required = false,
                                 default = nil)
  if valid_613579 != nil:
    section.add "nextToken", valid_613579
  var valid_613580 = query.getOrDefault("status")
  valid_613580 = validateParameter(valid_613580, JString, required = false,
                                 default = newJString("QUEUED"))
  if valid_613580 != nil:
    section.add "status", valid_613580
  var valid_613581 = query.getOrDefault("maxResults")
  valid_613581 = validateParameter(valid_613581, JInt, required = false, default = nil)
  if valid_613581 != nil:
    section.add "maxResults", valid_613581
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613582 = header.getOrDefault("X-Amz-Signature")
  valid_613582 = validateParameter(valid_613582, JString, required = false,
                                 default = nil)
  if valid_613582 != nil:
    section.add "X-Amz-Signature", valid_613582
  var valid_613583 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613583 = validateParameter(valid_613583, JString, required = false,
                                 default = nil)
  if valid_613583 != nil:
    section.add "X-Amz-Content-Sha256", valid_613583
  var valid_613584 = header.getOrDefault("X-Amz-Date")
  valid_613584 = validateParameter(valid_613584, JString, required = false,
                                 default = nil)
  if valid_613584 != nil:
    section.add "X-Amz-Date", valid_613584
  var valid_613585 = header.getOrDefault("X-Amz-Credential")
  valid_613585 = validateParameter(valid_613585, JString, required = false,
                                 default = nil)
  if valid_613585 != nil:
    section.add "X-Amz-Credential", valid_613585
  var valid_613586 = header.getOrDefault("X-Amz-Security-Token")
  valid_613586 = validateParameter(valid_613586, JString, required = false,
                                 default = nil)
  if valid_613586 != nil:
    section.add "X-Amz-Security-Token", valid_613586
  var valid_613587 = header.getOrDefault("X-Amz-Algorithm")
  valid_613587 = validateParameter(valid_613587, JString, required = false,
                                 default = nil)
  if valid_613587 != nil:
    section.add "X-Amz-Algorithm", valid_613587
  var valid_613588 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613588 = validateParameter(valid_613588, JString, required = false,
                                 default = nil)
  if valid_613588 != nil:
    section.add "X-Amz-SignedHeaders", valid_613588
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613589: Call_ListJobExecutionsForThing_613575; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the job executions for the specified thing.
  ## 
  let valid = call_613589.validator(path, query, header, formData, body)
  let scheme = call_613589.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613589.url(scheme.get, call_613589.host, call_613589.base,
                         call_613589.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613589, url, valid)

proc call*(call_613590: Call_ListJobExecutionsForThing_613575; thingName: string;
          nextToken: string = ""; status: string = "QUEUED"; maxResults: int = 0): Recallable =
  ## listJobExecutionsForThing
  ## Lists the job executions for the specified thing.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingName: string (required)
  ##            : The thing name.
  ##   status: string
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: int
  ##             : The maximum number of results to be returned per request.
  var path_613591 = newJObject()
  var query_613592 = newJObject()
  add(query_613592, "nextToken", newJString(nextToken))
  add(path_613591, "thingName", newJString(thingName))
  add(query_613592, "status", newJString(status))
  add(query_613592, "maxResults", newJInt(maxResults))
  result = call_613590.call(path_613591, query_613592, nil, nil, nil)

var listJobExecutionsForThing* = Call_ListJobExecutionsForThing_613575(
    name: "listJobExecutionsForThing", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs",
    validator: validate_ListJobExecutionsForThing_613576, base: "/",
    url: url_ListJobExecutionsForThing_613577,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobs_613593 = ref object of OpenApiRestCall_610658
proc url_ListJobs_613595(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListJobs_613594(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists jobs.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: JString
  ##                 : A filter that limits the returned jobs to those for the specified group.
  ##   targetSelection: JString
  ##                  : Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. 
  ##   thingGroupId: JString
  ##               : A filter that limits the returned jobs to those for the specified group.
  ##   status: JString
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_613596 = query.getOrDefault("nextToken")
  valid_613596 = validateParameter(valid_613596, JString, required = false,
                                 default = nil)
  if valid_613596 != nil:
    section.add "nextToken", valid_613596
  var valid_613597 = query.getOrDefault("thingGroupName")
  valid_613597 = validateParameter(valid_613597, JString, required = false,
                                 default = nil)
  if valid_613597 != nil:
    section.add "thingGroupName", valid_613597
  var valid_613598 = query.getOrDefault("targetSelection")
  valid_613598 = validateParameter(valid_613598, JString, required = false,
                                 default = newJString("CONTINUOUS"))
  if valid_613598 != nil:
    section.add "targetSelection", valid_613598
  var valid_613599 = query.getOrDefault("thingGroupId")
  valid_613599 = validateParameter(valid_613599, JString, required = false,
                                 default = nil)
  if valid_613599 != nil:
    section.add "thingGroupId", valid_613599
  var valid_613600 = query.getOrDefault("status")
  valid_613600 = validateParameter(valid_613600, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_613600 != nil:
    section.add "status", valid_613600
  var valid_613601 = query.getOrDefault("maxResults")
  valid_613601 = validateParameter(valid_613601, JInt, required = false, default = nil)
  if valid_613601 != nil:
    section.add "maxResults", valid_613601
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613602 = header.getOrDefault("X-Amz-Signature")
  valid_613602 = validateParameter(valid_613602, JString, required = false,
                                 default = nil)
  if valid_613602 != nil:
    section.add "X-Amz-Signature", valid_613602
  var valid_613603 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613603 = validateParameter(valid_613603, JString, required = false,
                                 default = nil)
  if valid_613603 != nil:
    section.add "X-Amz-Content-Sha256", valid_613603
  var valid_613604 = header.getOrDefault("X-Amz-Date")
  valid_613604 = validateParameter(valid_613604, JString, required = false,
                                 default = nil)
  if valid_613604 != nil:
    section.add "X-Amz-Date", valid_613604
  var valid_613605 = header.getOrDefault("X-Amz-Credential")
  valid_613605 = validateParameter(valid_613605, JString, required = false,
                                 default = nil)
  if valid_613605 != nil:
    section.add "X-Amz-Credential", valid_613605
  var valid_613606 = header.getOrDefault("X-Amz-Security-Token")
  valid_613606 = validateParameter(valid_613606, JString, required = false,
                                 default = nil)
  if valid_613606 != nil:
    section.add "X-Amz-Security-Token", valid_613606
  var valid_613607 = header.getOrDefault("X-Amz-Algorithm")
  valid_613607 = validateParameter(valid_613607, JString, required = false,
                                 default = nil)
  if valid_613607 != nil:
    section.add "X-Amz-Algorithm", valid_613607
  var valid_613608 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613608 = validateParameter(valid_613608, JString, required = false,
                                 default = nil)
  if valid_613608 != nil:
    section.add "X-Amz-SignedHeaders", valid_613608
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613609: Call_ListJobs_613593; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists jobs.
  ## 
  let valid = call_613609.validator(path, query, header, formData, body)
  let scheme = call_613609.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613609.url(scheme.get, call_613609.host, call_613609.base,
                         call_613609.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613609, url, valid)

proc call*(call_613610: Call_ListJobs_613593; nextToken: string = "";
          thingGroupName: string = ""; targetSelection: string = "CONTINUOUS";
          thingGroupId: string = ""; status: string = "IN_PROGRESS"; maxResults: int = 0): Recallable =
  ## listJobs
  ## Lists jobs.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: string
  ##                 : A filter that limits the returned jobs to those for the specified group.
  ##   targetSelection: string
  ##                  : Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. 
  ##   thingGroupId: string
  ##               : A filter that limits the returned jobs to those for the specified group.
  ##   status: string
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var query_613611 = newJObject()
  add(query_613611, "nextToken", newJString(nextToken))
  add(query_613611, "thingGroupName", newJString(thingGroupName))
  add(query_613611, "targetSelection", newJString(targetSelection))
  add(query_613611, "thingGroupId", newJString(thingGroupId))
  add(query_613611, "status", newJString(status))
  add(query_613611, "maxResults", newJInt(maxResults))
  result = call_613610.call(nil, query_613611, nil, nil, nil)

var listJobs* = Call_ListJobs_613593(name: "listJobs", meth: HttpMethod.HttpGet,
                                  host: "iot.amazonaws.com", route: "/jobs",
                                  validator: validate_ListJobs_613594, base: "/",
                                  url: url_ListJobs_613595,
                                  schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListMitigationActions_613612 = ref object of OpenApiRestCall_610658
proc url_ListMitigationActions_613614(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListMitigationActions_613613(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   actionType: JString
  ##             : Specify a value to limit the result to mitigation actions with a specific action type.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  var valid_613615 = query.getOrDefault("nextToken")
  valid_613615 = validateParameter(valid_613615, JString, required = false,
                                 default = nil)
  if valid_613615 != nil:
    section.add "nextToken", valid_613615
  var valid_613616 = query.getOrDefault("actionType")
  valid_613616 = validateParameter(valid_613616, JString, required = false, default = newJString(
      "UPDATE_DEVICE_CERTIFICATE"))
  if valid_613616 != nil:
    section.add "actionType", valid_613616
  var valid_613617 = query.getOrDefault("maxResults")
  valid_613617 = validateParameter(valid_613617, JInt, required = false, default = nil)
  if valid_613617 != nil:
    section.add "maxResults", valid_613617
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613618 = header.getOrDefault("X-Amz-Signature")
  valid_613618 = validateParameter(valid_613618, JString, required = false,
                                 default = nil)
  if valid_613618 != nil:
    section.add "X-Amz-Signature", valid_613618
  var valid_613619 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613619 = validateParameter(valid_613619, JString, required = false,
                                 default = nil)
  if valid_613619 != nil:
    section.add "X-Amz-Content-Sha256", valid_613619
  var valid_613620 = header.getOrDefault("X-Amz-Date")
  valid_613620 = validateParameter(valid_613620, JString, required = false,
                                 default = nil)
  if valid_613620 != nil:
    section.add "X-Amz-Date", valid_613620
  var valid_613621 = header.getOrDefault("X-Amz-Credential")
  valid_613621 = validateParameter(valid_613621, JString, required = false,
                                 default = nil)
  if valid_613621 != nil:
    section.add "X-Amz-Credential", valid_613621
  var valid_613622 = header.getOrDefault("X-Amz-Security-Token")
  valid_613622 = validateParameter(valid_613622, JString, required = false,
                                 default = nil)
  if valid_613622 != nil:
    section.add "X-Amz-Security-Token", valid_613622
  var valid_613623 = header.getOrDefault("X-Amz-Algorithm")
  valid_613623 = validateParameter(valid_613623, JString, required = false,
                                 default = nil)
  if valid_613623 != nil:
    section.add "X-Amz-Algorithm", valid_613623
  var valid_613624 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613624 = validateParameter(valid_613624, JString, required = false,
                                 default = nil)
  if valid_613624 != nil:
    section.add "X-Amz-SignedHeaders", valid_613624
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613625: Call_ListMitigationActions_613612; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ## 
  let valid = call_613625.validator(path, query, header, formData, body)
  let scheme = call_613625.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613625.url(scheme.get, call_613625.host, call_613625.base,
                         call_613625.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613625, url, valid)

proc call*(call_613626: Call_ListMitigationActions_613612; nextToken: string = "";
          actionType: string = "UPDATE_DEVICE_CERTIFICATE"; maxResults: int = 0): Recallable =
  ## listMitigationActions
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   actionType: string
  ##             : Specify a value to limit the result to mitigation actions with a specific action type.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_613627 = newJObject()
  add(query_613627, "nextToken", newJString(nextToken))
  add(query_613627, "actionType", newJString(actionType))
  add(query_613627, "maxResults", newJInt(maxResults))
  result = call_613626.call(nil, query_613627, nil, nil, nil)

var listMitigationActions* = Call_ListMitigationActions_613612(
    name: "listMitigationActions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions",
    validator: validate_ListMitigationActions_613613, base: "/",
    url: url_ListMitigationActions_613614, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListOTAUpdates_613628 = ref object of OpenApiRestCall_610658
proc url_ListOTAUpdates_613630(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListOTAUpdates_613629(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists OTA updates.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token used to retrieve the next set of results.
  ##   otaUpdateStatus: JString
  ##                  : The OTA update job status.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_613631 = query.getOrDefault("nextToken")
  valid_613631 = validateParameter(valid_613631, JString, required = false,
                                 default = nil)
  if valid_613631 != nil:
    section.add "nextToken", valid_613631
  var valid_613632 = query.getOrDefault("otaUpdateStatus")
  valid_613632 = validateParameter(valid_613632, JString, required = false,
                                 default = newJString("CREATE_PENDING"))
  if valid_613632 != nil:
    section.add "otaUpdateStatus", valid_613632
  var valid_613633 = query.getOrDefault("maxResults")
  valid_613633 = validateParameter(valid_613633, JInt, required = false, default = nil)
  if valid_613633 != nil:
    section.add "maxResults", valid_613633
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613634 = header.getOrDefault("X-Amz-Signature")
  valid_613634 = validateParameter(valid_613634, JString, required = false,
                                 default = nil)
  if valid_613634 != nil:
    section.add "X-Amz-Signature", valid_613634
  var valid_613635 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613635 = validateParameter(valid_613635, JString, required = false,
                                 default = nil)
  if valid_613635 != nil:
    section.add "X-Amz-Content-Sha256", valid_613635
  var valid_613636 = header.getOrDefault("X-Amz-Date")
  valid_613636 = validateParameter(valid_613636, JString, required = false,
                                 default = nil)
  if valid_613636 != nil:
    section.add "X-Amz-Date", valid_613636
  var valid_613637 = header.getOrDefault("X-Amz-Credential")
  valid_613637 = validateParameter(valid_613637, JString, required = false,
                                 default = nil)
  if valid_613637 != nil:
    section.add "X-Amz-Credential", valid_613637
  var valid_613638 = header.getOrDefault("X-Amz-Security-Token")
  valid_613638 = validateParameter(valid_613638, JString, required = false,
                                 default = nil)
  if valid_613638 != nil:
    section.add "X-Amz-Security-Token", valid_613638
  var valid_613639 = header.getOrDefault("X-Amz-Algorithm")
  valid_613639 = validateParameter(valid_613639, JString, required = false,
                                 default = nil)
  if valid_613639 != nil:
    section.add "X-Amz-Algorithm", valid_613639
  var valid_613640 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613640 = validateParameter(valid_613640, JString, required = false,
                                 default = nil)
  if valid_613640 != nil:
    section.add "X-Amz-SignedHeaders", valid_613640
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613641: Call_ListOTAUpdates_613628; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists OTA updates.
  ## 
  let valid = call_613641.validator(path, query, header, formData, body)
  let scheme = call_613641.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613641.url(scheme.get, call_613641.host, call_613641.base,
                         call_613641.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613641, url, valid)

proc call*(call_613642: Call_ListOTAUpdates_613628; nextToken: string = "";
          otaUpdateStatus: string = "CREATE_PENDING"; maxResults: int = 0): Recallable =
  ## listOTAUpdates
  ## Lists OTA updates.
  ##   nextToken: string
  ##            : A token used to retrieve the next set of results.
  ##   otaUpdateStatus: string
  ##                  : The OTA update job status.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_613643 = newJObject()
  add(query_613643, "nextToken", newJString(nextToken))
  add(query_613643, "otaUpdateStatus", newJString(otaUpdateStatus))
  add(query_613643, "maxResults", newJInt(maxResults))
  result = call_613642.call(nil, query_613643, nil, nil, nil)

var listOTAUpdates* = Call_ListOTAUpdates_613628(name: "listOTAUpdates",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/otaUpdates",
    validator: validate_ListOTAUpdates_613629, base: "/", url: url_ListOTAUpdates_613630,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListOutgoingCertificates_613644 = ref object of OpenApiRestCall_610658
proc url_ListOutgoingCertificates_613646(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListOutgoingCertificates_613645(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists certificates that are being transferred but not yet accepted.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_613647 = query.getOrDefault("isAscendingOrder")
  valid_613647 = validateParameter(valid_613647, JBool, required = false, default = nil)
  if valid_613647 != nil:
    section.add "isAscendingOrder", valid_613647
  var valid_613648 = query.getOrDefault("pageSize")
  valid_613648 = validateParameter(valid_613648, JInt, required = false, default = nil)
  if valid_613648 != nil:
    section.add "pageSize", valid_613648
  var valid_613649 = query.getOrDefault("marker")
  valid_613649 = validateParameter(valid_613649, JString, required = false,
                                 default = nil)
  if valid_613649 != nil:
    section.add "marker", valid_613649
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613650 = header.getOrDefault("X-Amz-Signature")
  valid_613650 = validateParameter(valid_613650, JString, required = false,
                                 default = nil)
  if valid_613650 != nil:
    section.add "X-Amz-Signature", valid_613650
  var valid_613651 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613651 = validateParameter(valid_613651, JString, required = false,
                                 default = nil)
  if valid_613651 != nil:
    section.add "X-Amz-Content-Sha256", valid_613651
  var valid_613652 = header.getOrDefault("X-Amz-Date")
  valid_613652 = validateParameter(valid_613652, JString, required = false,
                                 default = nil)
  if valid_613652 != nil:
    section.add "X-Amz-Date", valid_613652
  var valid_613653 = header.getOrDefault("X-Amz-Credential")
  valid_613653 = validateParameter(valid_613653, JString, required = false,
                                 default = nil)
  if valid_613653 != nil:
    section.add "X-Amz-Credential", valid_613653
  var valid_613654 = header.getOrDefault("X-Amz-Security-Token")
  valid_613654 = validateParameter(valid_613654, JString, required = false,
                                 default = nil)
  if valid_613654 != nil:
    section.add "X-Amz-Security-Token", valid_613654
  var valid_613655 = header.getOrDefault("X-Amz-Algorithm")
  valid_613655 = validateParameter(valid_613655, JString, required = false,
                                 default = nil)
  if valid_613655 != nil:
    section.add "X-Amz-Algorithm", valid_613655
  var valid_613656 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613656 = validateParameter(valid_613656, JString, required = false,
                                 default = nil)
  if valid_613656 != nil:
    section.add "X-Amz-SignedHeaders", valid_613656
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613657: Call_ListOutgoingCertificates_613644; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists certificates that are being transferred but not yet accepted.
  ## 
  let valid = call_613657.validator(path, query, header, formData, body)
  let scheme = call_613657.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613657.url(scheme.get, call_613657.host, call_613657.base,
                         call_613657.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613657, url, valid)

proc call*(call_613658: Call_ListOutgoingCertificates_613644;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listOutgoingCertificates
  ## Lists certificates that are being transferred but not yet accepted.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_613659 = newJObject()
  add(query_613659, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_613659, "pageSize", newJInt(pageSize))
  add(query_613659, "marker", newJString(marker))
  result = call_613658.call(nil, query_613659, nil, nil, nil)

var listOutgoingCertificates* = Call_ListOutgoingCertificates_613644(
    name: "listOutgoingCertificates", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates-out-going",
    validator: validate_ListOutgoingCertificates_613645, base: "/",
    url: url_ListOutgoingCertificates_613646, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicies_613660 = ref object of OpenApiRestCall_610658
proc url_ListPolicies_613662(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPolicies_613661(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists your policies.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_613663 = query.getOrDefault("isAscendingOrder")
  valid_613663 = validateParameter(valid_613663, JBool, required = false, default = nil)
  if valid_613663 != nil:
    section.add "isAscendingOrder", valid_613663
  var valid_613664 = query.getOrDefault("pageSize")
  valid_613664 = validateParameter(valid_613664, JInt, required = false, default = nil)
  if valid_613664 != nil:
    section.add "pageSize", valid_613664
  var valid_613665 = query.getOrDefault("marker")
  valid_613665 = validateParameter(valid_613665, JString, required = false,
                                 default = nil)
  if valid_613665 != nil:
    section.add "marker", valid_613665
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613666 = header.getOrDefault("X-Amz-Signature")
  valid_613666 = validateParameter(valid_613666, JString, required = false,
                                 default = nil)
  if valid_613666 != nil:
    section.add "X-Amz-Signature", valid_613666
  var valid_613667 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613667 = validateParameter(valid_613667, JString, required = false,
                                 default = nil)
  if valid_613667 != nil:
    section.add "X-Amz-Content-Sha256", valid_613667
  var valid_613668 = header.getOrDefault("X-Amz-Date")
  valid_613668 = validateParameter(valid_613668, JString, required = false,
                                 default = nil)
  if valid_613668 != nil:
    section.add "X-Amz-Date", valid_613668
  var valid_613669 = header.getOrDefault("X-Amz-Credential")
  valid_613669 = validateParameter(valid_613669, JString, required = false,
                                 default = nil)
  if valid_613669 != nil:
    section.add "X-Amz-Credential", valid_613669
  var valid_613670 = header.getOrDefault("X-Amz-Security-Token")
  valid_613670 = validateParameter(valid_613670, JString, required = false,
                                 default = nil)
  if valid_613670 != nil:
    section.add "X-Amz-Security-Token", valid_613670
  var valid_613671 = header.getOrDefault("X-Amz-Algorithm")
  valid_613671 = validateParameter(valid_613671, JString, required = false,
                                 default = nil)
  if valid_613671 != nil:
    section.add "X-Amz-Algorithm", valid_613671
  var valid_613672 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613672 = validateParameter(valid_613672, JString, required = false,
                                 default = nil)
  if valid_613672 != nil:
    section.add "X-Amz-SignedHeaders", valid_613672
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613673: Call_ListPolicies_613660; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists your policies.
  ## 
  let valid = call_613673.validator(path, query, header, formData, body)
  let scheme = call_613673.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613673.url(scheme.get, call_613673.host, call_613673.base,
                         call_613673.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613673, url, valid)

proc call*(call_613674: Call_ListPolicies_613660; isAscendingOrder: bool = false;
          pageSize: int = 0; marker: string = ""): Recallable =
  ## listPolicies
  ## Lists your policies.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_613675 = newJObject()
  add(query_613675, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_613675, "pageSize", newJInt(pageSize))
  add(query_613675, "marker", newJString(marker))
  result = call_613674.call(nil, query_613675, nil, nil, nil)

var listPolicies* = Call_ListPolicies_613660(name: "listPolicies",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/policies",
    validator: validate_ListPolicies_613661, base: "/", url: url_ListPolicies_613662,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicyPrincipals_613676 = ref object of OpenApiRestCall_610658
proc url_ListPolicyPrincipals_613678(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPolicyPrincipals_613677(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_613679 = query.getOrDefault("isAscendingOrder")
  valid_613679 = validateParameter(valid_613679, JBool, required = false, default = nil)
  if valid_613679 != nil:
    section.add "isAscendingOrder", valid_613679
  var valid_613680 = query.getOrDefault("pageSize")
  valid_613680 = validateParameter(valid_613680, JInt, required = false, default = nil)
  if valid_613680 != nil:
    section.add "pageSize", valid_613680
  var valid_613681 = query.getOrDefault("marker")
  valid_613681 = validateParameter(valid_613681, JString, required = false,
                                 default = nil)
  if valid_613681 != nil:
    section.add "marker", valid_613681
  result.add "query", section
  ## parameters in `header` object:
  ##   x-amzn-iot-policy: JString (required)
  ##                    : The policy name.
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-policy` field"
  var valid_613682 = header.getOrDefault("x-amzn-iot-policy")
  valid_613682 = validateParameter(valid_613682, JString, required = true,
                                 default = nil)
  if valid_613682 != nil:
    section.add "x-amzn-iot-policy", valid_613682
  var valid_613683 = header.getOrDefault("X-Amz-Signature")
  valid_613683 = validateParameter(valid_613683, JString, required = false,
                                 default = nil)
  if valid_613683 != nil:
    section.add "X-Amz-Signature", valid_613683
  var valid_613684 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613684 = validateParameter(valid_613684, JString, required = false,
                                 default = nil)
  if valid_613684 != nil:
    section.add "X-Amz-Content-Sha256", valid_613684
  var valid_613685 = header.getOrDefault("X-Amz-Date")
  valid_613685 = validateParameter(valid_613685, JString, required = false,
                                 default = nil)
  if valid_613685 != nil:
    section.add "X-Amz-Date", valid_613685
  var valid_613686 = header.getOrDefault("X-Amz-Credential")
  valid_613686 = validateParameter(valid_613686, JString, required = false,
                                 default = nil)
  if valid_613686 != nil:
    section.add "X-Amz-Credential", valid_613686
  var valid_613687 = header.getOrDefault("X-Amz-Security-Token")
  valid_613687 = validateParameter(valid_613687, JString, required = false,
                                 default = nil)
  if valid_613687 != nil:
    section.add "X-Amz-Security-Token", valid_613687
  var valid_613688 = header.getOrDefault("X-Amz-Algorithm")
  valid_613688 = validateParameter(valid_613688, JString, required = false,
                                 default = nil)
  if valid_613688 != nil:
    section.add "X-Amz-Algorithm", valid_613688
  var valid_613689 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613689 = validateParameter(valid_613689, JString, required = false,
                                 default = nil)
  if valid_613689 != nil:
    section.add "X-Amz-SignedHeaders", valid_613689
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613690: Call_ListPolicyPrincipals_613676; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ## 
  let valid = call_613690.validator(path, query, header, formData, body)
  let scheme = call_613690.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613690.url(scheme.get, call_613690.host, call_613690.base,
                         call_613690.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613690, url, valid)

proc call*(call_613691: Call_ListPolicyPrincipals_613676;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listPolicyPrincipals
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_613692 = newJObject()
  add(query_613692, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_613692, "pageSize", newJInt(pageSize))
  add(query_613692, "marker", newJString(marker))
  result = call_613691.call(nil, query_613692, nil, nil, nil)

var listPolicyPrincipals* = Call_ListPolicyPrincipals_613676(
    name: "listPolicyPrincipals", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/policy-principals#x-amzn-iot-policy",
    validator: validate_ListPolicyPrincipals_613677, base: "/",
    url: url_ListPolicyPrincipals_613678, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPrincipalPolicies_613693 = ref object of OpenApiRestCall_610658
proc url_ListPrincipalPolicies_613695(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPrincipalPolicies_613694(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, results are returned in ascending creation order.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_613696 = query.getOrDefault("isAscendingOrder")
  valid_613696 = validateParameter(valid_613696, JBool, required = false, default = nil)
  if valid_613696 != nil:
    section.add "isAscendingOrder", valid_613696
  var valid_613697 = query.getOrDefault("pageSize")
  valid_613697 = validateParameter(valid_613697, JInt, required = false, default = nil)
  if valid_613697 != nil:
    section.add "pageSize", valid_613697
  var valid_613698 = query.getOrDefault("marker")
  valid_613698 = validateParameter(valid_613698, JString, required = false,
                                 default = nil)
  if valid_613698 != nil:
    section.add "marker", valid_613698
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : The principal.
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613699 = header.getOrDefault("X-Amz-Signature")
  valid_613699 = validateParameter(valid_613699, JString, required = false,
                                 default = nil)
  if valid_613699 != nil:
    section.add "X-Amz-Signature", valid_613699
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_613700 = header.getOrDefault("x-amzn-iot-principal")
  valid_613700 = validateParameter(valid_613700, JString, required = true,
                                 default = nil)
  if valid_613700 != nil:
    section.add "x-amzn-iot-principal", valid_613700
  var valid_613701 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613701 = validateParameter(valid_613701, JString, required = false,
                                 default = nil)
  if valid_613701 != nil:
    section.add "X-Amz-Content-Sha256", valid_613701
  var valid_613702 = header.getOrDefault("X-Amz-Date")
  valid_613702 = validateParameter(valid_613702, JString, required = false,
                                 default = nil)
  if valid_613702 != nil:
    section.add "X-Amz-Date", valid_613702
  var valid_613703 = header.getOrDefault("X-Amz-Credential")
  valid_613703 = validateParameter(valid_613703, JString, required = false,
                                 default = nil)
  if valid_613703 != nil:
    section.add "X-Amz-Credential", valid_613703
  var valid_613704 = header.getOrDefault("X-Amz-Security-Token")
  valid_613704 = validateParameter(valid_613704, JString, required = false,
                                 default = nil)
  if valid_613704 != nil:
    section.add "X-Amz-Security-Token", valid_613704
  var valid_613705 = header.getOrDefault("X-Amz-Algorithm")
  valid_613705 = validateParameter(valid_613705, JString, required = false,
                                 default = nil)
  if valid_613705 != nil:
    section.add "X-Amz-Algorithm", valid_613705
  var valid_613706 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613706 = validateParameter(valid_613706, JString, required = false,
                                 default = nil)
  if valid_613706 != nil:
    section.add "X-Amz-SignedHeaders", valid_613706
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613707: Call_ListPrincipalPolicies_613693; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ## 
  let valid = call_613707.validator(path, query, header, formData, body)
  let scheme = call_613707.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613707.url(scheme.get, call_613707.host, call_613707.base,
                         call_613707.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613707, url, valid)

proc call*(call_613708: Call_ListPrincipalPolicies_613693;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listPrincipalPolicies
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, results are returned in ascending creation order.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_613709 = newJObject()
  add(query_613709, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_613709, "pageSize", newJInt(pageSize))
  add(query_613709, "marker", newJString(marker))
  result = call_613708.call(nil, query_613709, nil, nil, nil)

var listPrincipalPolicies* = Call_ListPrincipalPolicies_613693(
    name: "listPrincipalPolicies", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/principal-policies#x-amzn-iot-principal",
    validator: validate_ListPrincipalPolicies_613694, base: "/",
    url: url_ListPrincipalPolicies_613695, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPrincipalThings_613710 = ref object of OpenApiRestCall_610658
proc url_ListPrincipalThings_613712(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPrincipalThings_613711(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  section = newJObject()
  var valid_613713 = query.getOrDefault("nextToken")
  valid_613713 = validateParameter(valid_613713, JString, required = false,
                                 default = nil)
  if valid_613713 != nil:
    section.add "nextToken", valid_613713
  var valid_613714 = query.getOrDefault("maxResults")
  valid_613714 = validateParameter(valid_613714, JInt, required = false, default = nil)
  if valid_613714 != nil:
    section.add "maxResults", valid_613714
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : The principal.
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613715 = header.getOrDefault("X-Amz-Signature")
  valid_613715 = validateParameter(valid_613715, JString, required = false,
                                 default = nil)
  if valid_613715 != nil:
    section.add "X-Amz-Signature", valid_613715
  var valid_613716 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613716 = validateParameter(valid_613716, JString, required = false,
                                 default = nil)
  if valid_613716 != nil:
    section.add "X-Amz-Content-Sha256", valid_613716
  var valid_613717 = header.getOrDefault("X-Amz-Date")
  valid_613717 = validateParameter(valid_613717, JString, required = false,
                                 default = nil)
  if valid_613717 != nil:
    section.add "X-Amz-Date", valid_613717
  var valid_613718 = header.getOrDefault("X-Amz-Credential")
  valid_613718 = validateParameter(valid_613718, JString, required = false,
                                 default = nil)
  if valid_613718 != nil:
    section.add "X-Amz-Credential", valid_613718
  var valid_613719 = header.getOrDefault("X-Amz-Security-Token")
  valid_613719 = validateParameter(valid_613719, JString, required = false,
                                 default = nil)
  if valid_613719 != nil:
    section.add "X-Amz-Security-Token", valid_613719
  var valid_613720 = header.getOrDefault("X-Amz-Algorithm")
  valid_613720 = validateParameter(valid_613720, JString, required = false,
                                 default = nil)
  if valid_613720 != nil:
    section.add "X-Amz-Algorithm", valid_613720
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_613721 = header.getOrDefault("x-amzn-principal")
  valid_613721 = validateParameter(valid_613721, JString, required = true,
                                 default = nil)
  if valid_613721 != nil:
    section.add "x-amzn-principal", valid_613721
  var valid_613722 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613722 = validateParameter(valid_613722, JString, required = false,
                                 default = nil)
  if valid_613722 != nil:
    section.add "X-Amz-SignedHeaders", valid_613722
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613723: Call_ListPrincipalThings_613710; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ## 
  let valid = call_613723.validator(path, query, header, formData, body)
  let scheme = call_613723.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613723.url(scheme.get, call_613723.host, call_613723.base,
                         call_613723.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613723, url, valid)

proc call*(call_613724: Call_ListPrincipalThings_613710; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listPrincipalThings
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  var query_613725 = newJObject()
  add(query_613725, "nextToken", newJString(nextToken))
  add(query_613725, "maxResults", newJInt(maxResults))
  result = call_613724.call(nil, query_613725, nil, nil, nil)

var listPrincipalThings* = Call_ListPrincipalThings_613710(
    name: "listPrincipalThings", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/principals/things#x-amzn-principal",
    validator: validate_ListPrincipalThings_613711, base: "/",
    url: url_ListPrincipalThings_613712, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListRoleAliases_613726 = ref object of OpenApiRestCall_610658
proc url_ListRoleAliases_613728(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListRoleAliases_613727(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Lists the role aliases registered in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Return the list of role aliases in ascending alphabetical order.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  section = newJObject()
  var valid_613729 = query.getOrDefault("isAscendingOrder")
  valid_613729 = validateParameter(valid_613729, JBool, required = false, default = nil)
  if valid_613729 != nil:
    section.add "isAscendingOrder", valid_613729
  var valid_613730 = query.getOrDefault("pageSize")
  valid_613730 = validateParameter(valid_613730, JInt, required = false, default = nil)
  if valid_613730 != nil:
    section.add "pageSize", valid_613730
  var valid_613731 = query.getOrDefault("marker")
  valid_613731 = validateParameter(valid_613731, JString, required = false,
                                 default = nil)
  if valid_613731 != nil:
    section.add "marker", valid_613731
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613732 = header.getOrDefault("X-Amz-Signature")
  valid_613732 = validateParameter(valid_613732, JString, required = false,
                                 default = nil)
  if valid_613732 != nil:
    section.add "X-Amz-Signature", valid_613732
  var valid_613733 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613733 = validateParameter(valid_613733, JString, required = false,
                                 default = nil)
  if valid_613733 != nil:
    section.add "X-Amz-Content-Sha256", valid_613733
  var valid_613734 = header.getOrDefault("X-Amz-Date")
  valid_613734 = validateParameter(valid_613734, JString, required = false,
                                 default = nil)
  if valid_613734 != nil:
    section.add "X-Amz-Date", valid_613734
  var valid_613735 = header.getOrDefault("X-Amz-Credential")
  valid_613735 = validateParameter(valid_613735, JString, required = false,
                                 default = nil)
  if valid_613735 != nil:
    section.add "X-Amz-Credential", valid_613735
  var valid_613736 = header.getOrDefault("X-Amz-Security-Token")
  valid_613736 = validateParameter(valid_613736, JString, required = false,
                                 default = nil)
  if valid_613736 != nil:
    section.add "X-Amz-Security-Token", valid_613736
  var valid_613737 = header.getOrDefault("X-Amz-Algorithm")
  valid_613737 = validateParameter(valid_613737, JString, required = false,
                                 default = nil)
  if valid_613737 != nil:
    section.add "X-Amz-Algorithm", valid_613737
  var valid_613738 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613738 = validateParameter(valid_613738, JString, required = false,
                                 default = nil)
  if valid_613738 != nil:
    section.add "X-Amz-SignedHeaders", valid_613738
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613739: Call_ListRoleAliases_613726; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the role aliases registered in your account.
  ## 
  let valid = call_613739.validator(path, query, header, formData, body)
  let scheme = call_613739.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613739.url(scheme.get, call_613739.host, call_613739.base,
                         call_613739.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613739, url, valid)

proc call*(call_613740: Call_ListRoleAliases_613726;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listRoleAliases
  ## Lists the role aliases registered in your account.
  ##   isAscendingOrder: bool
  ##                   : Return the list of role aliases in ascending alphabetical order.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  var query_613741 = newJObject()
  add(query_613741, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_613741, "pageSize", newJInt(pageSize))
  add(query_613741, "marker", newJString(marker))
  result = call_613740.call(nil, query_613741, nil, nil, nil)

var listRoleAliases* = Call_ListRoleAliases_613726(name: "listRoleAliases",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/role-aliases",
    validator: validate_ListRoleAliases_613727, base: "/", url: url_ListRoleAliases_613728,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListScheduledAudits_613742 = ref object of OpenApiRestCall_610658
proc url_ListScheduledAudits_613744(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListScheduledAudits_613743(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists all of your scheduled audits.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  var valid_613745 = query.getOrDefault("nextToken")
  valid_613745 = validateParameter(valid_613745, JString, required = false,
                                 default = nil)
  if valid_613745 != nil:
    section.add "nextToken", valid_613745
  var valid_613746 = query.getOrDefault("maxResults")
  valid_613746 = validateParameter(valid_613746, JInt, required = false, default = nil)
  if valid_613746 != nil:
    section.add "maxResults", valid_613746
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613747 = header.getOrDefault("X-Amz-Signature")
  valid_613747 = validateParameter(valid_613747, JString, required = false,
                                 default = nil)
  if valid_613747 != nil:
    section.add "X-Amz-Signature", valid_613747
  var valid_613748 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613748 = validateParameter(valid_613748, JString, required = false,
                                 default = nil)
  if valid_613748 != nil:
    section.add "X-Amz-Content-Sha256", valid_613748
  var valid_613749 = header.getOrDefault("X-Amz-Date")
  valid_613749 = validateParameter(valid_613749, JString, required = false,
                                 default = nil)
  if valid_613749 != nil:
    section.add "X-Amz-Date", valid_613749
  var valid_613750 = header.getOrDefault("X-Amz-Credential")
  valid_613750 = validateParameter(valid_613750, JString, required = false,
                                 default = nil)
  if valid_613750 != nil:
    section.add "X-Amz-Credential", valid_613750
  var valid_613751 = header.getOrDefault("X-Amz-Security-Token")
  valid_613751 = validateParameter(valid_613751, JString, required = false,
                                 default = nil)
  if valid_613751 != nil:
    section.add "X-Amz-Security-Token", valid_613751
  var valid_613752 = header.getOrDefault("X-Amz-Algorithm")
  valid_613752 = validateParameter(valid_613752, JString, required = false,
                                 default = nil)
  if valid_613752 != nil:
    section.add "X-Amz-Algorithm", valid_613752
  var valid_613753 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613753 = validateParameter(valid_613753, JString, required = false,
                                 default = nil)
  if valid_613753 != nil:
    section.add "X-Amz-SignedHeaders", valid_613753
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613754: Call_ListScheduledAudits_613742; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all of your scheduled audits.
  ## 
  let valid = call_613754.validator(path, query, header, formData, body)
  let scheme = call_613754.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613754.url(scheme.get, call_613754.host, call_613754.base,
                         call_613754.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613754, url, valid)

proc call*(call_613755: Call_ListScheduledAudits_613742; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listScheduledAudits
  ## Lists all of your scheduled audits.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_613756 = newJObject()
  add(query_613756, "nextToken", newJString(nextToken))
  add(query_613756, "maxResults", newJInt(maxResults))
  result = call_613755.call(nil, query_613756, nil, nil, nil)

var listScheduledAudits* = Call_ListScheduledAudits_613742(
    name: "listScheduledAudits", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/scheduledaudits",
    validator: validate_ListScheduledAudits_613743, base: "/",
    url: url_ListScheduledAudits_613744, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListSecurityProfiles_613757 = ref object of OpenApiRestCall_610658
proc url_ListSecurityProfiles_613759(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListSecurityProfiles_613758(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_613760 = query.getOrDefault("nextToken")
  valid_613760 = validateParameter(valid_613760, JString, required = false,
                                 default = nil)
  if valid_613760 != nil:
    section.add "nextToken", valid_613760
  var valid_613761 = query.getOrDefault("maxResults")
  valid_613761 = validateParameter(valid_613761, JInt, required = false, default = nil)
  if valid_613761 != nil:
    section.add "maxResults", valid_613761
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613762 = header.getOrDefault("X-Amz-Signature")
  valid_613762 = validateParameter(valid_613762, JString, required = false,
                                 default = nil)
  if valid_613762 != nil:
    section.add "X-Amz-Signature", valid_613762
  var valid_613763 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613763 = validateParameter(valid_613763, JString, required = false,
                                 default = nil)
  if valid_613763 != nil:
    section.add "X-Amz-Content-Sha256", valid_613763
  var valid_613764 = header.getOrDefault("X-Amz-Date")
  valid_613764 = validateParameter(valid_613764, JString, required = false,
                                 default = nil)
  if valid_613764 != nil:
    section.add "X-Amz-Date", valid_613764
  var valid_613765 = header.getOrDefault("X-Amz-Credential")
  valid_613765 = validateParameter(valid_613765, JString, required = false,
                                 default = nil)
  if valid_613765 != nil:
    section.add "X-Amz-Credential", valid_613765
  var valid_613766 = header.getOrDefault("X-Amz-Security-Token")
  valid_613766 = validateParameter(valid_613766, JString, required = false,
                                 default = nil)
  if valid_613766 != nil:
    section.add "X-Amz-Security-Token", valid_613766
  var valid_613767 = header.getOrDefault("X-Amz-Algorithm")
  valid_613767 = validateParameter(valid_613767, JString, required = false,
                                 default = nil)
  if valid_613767 != nil:
    section.add "X-Amz-Algorithm", valid_613767
  var valid_613768 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613768 = validateParameter(valid_613768, JString, required = false,
                                 default = nil)
  if valid_613768 != nil:
    section.add "X-Amz-SignedHeaders", valid_613768
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613769: Call_ListSecurityProfiles_613757; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ## 
  let valid = call_613769.validator(path, query, header, formData, body)
  let scheme = call_613769.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613769.url(scheme.get, call_613769.host, call_613769.base,
                         call_613769.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613769, url, valid)

proc call*(call_613770: Call_ListSecurityProfiles_613757; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listSecurityProfiles
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_613771 = newJObject()
  add(query_613771, "nextToken", newJString(nextToken))
  add(query_613771, "maxResults", newJInt(maxResults))
  result = call_613770.call(nil, query_613771, nil, nil, nil)

var listSecurityProfiles* = Call_ListSecurityProfiles_613757(
    name: "listSecurityProfiles", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/security-profiles",
    validator: validate_ListSecurityProfiles_613758, base: "/",
    url: url_ListSecurityProfiles_613759, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListSecurityProfilesForTarget_613772 = ref object of OpenApiRestCall_610658
proc url_ListSecurityProfilesForTarget_613774(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListSecurityProfilesForTarget_613773(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   recursive: JBool
  ##            : If true, return child groups too.
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the target (thing group) whose attached security profiles you want to get.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_613775 = query.getOrDefault("nextToken")
  valid_613775 = validateParameter(valid_613775, JString, required = false,
                                 default = nil)
  if valid_613775 != nil:
    section.add "nextToken", valid_613775
  var valid_613776 = query.getOrDefault("recursive")
  valid_613776 = validateParameter(valid_613776, JBool, required = false, default = nil)
  if valid_613776 != nil:
    section.add "recursive", valid_613776
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_613777 = query.getOrDefault("securityProfileTargetArn")
  valid_613777 = validateParameter(valid_613777, JString, required = true,
                                 default = nil)
  if valid_613777 != nil:
    section.add "securityProfileTargetArn", valid_613777
  var valid_613778 = query.getOrDefault("maxResults")
  valid_613778 = validateParameter(valid_613778, JInt, required = false, default = nil)
  if valid_613778 != nil:
    section.add "maxResults", valid_613778
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613779 = header.getOrDefault("X-Amz-Signature")
  valid_613779 = validateParameter(valid_613779, JString, required = false,
                                 default = nil)
  if valid_613779 != nil:
    section.add "X-Amz-Signature", valid_613779
  var valid_613780 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613780 = validateParameter(valid_613780, JString, required = false,
                                 default = nil)
  if valid_613780 != nil:
    section.add "X-Amz-Content-Sha256", valid_613780
  var valid_613781 = header.getOrDefault("X-Amz-Date")
  valid_613781 = validateParameter(valid_613781, JString, required = false,
                                 default = nil)
  if valid_613781 != nil:
    section.add "X-Amz-Date", valid_613781
  var valid_613782 = header.getOrDefault("X-Amz-Credential")
  valid_613782 = validateParameter(valid_613782, JString, required = false,
                                 default = nil)
  if valid_613782 != nil:
    section.add "X-Amz-Credential", valid_613782
  var valid_613783 = header.getOrDefault("X-Amz-Security-Token")
  valid_613783 = validateParameter(valid_613783, JString, required = false,
                                 default = nil)
  if valid_613783 != nil:
    section.add "X-Amz-Security-Token", valid_613783
  var valid_613784 = header.getOrDefault("X-Amz-Algorithm")
  valid_613784 = validateParameter(valid_613784, JString, required = false,
                                 default = nil)
  if valid_613784 != nil:
    section.add "X-Amz-Algorithm", valid_613784
  var valid_613785 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613785 = validateParameter(valid_613785, JString, required = false,
                                 default = nil)
  if valid_613785 != nil:
    section.add "X-Amz-SignedHeaders", valid_613785
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613786: Call_ListSecurityProfilesForTarget_613772; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ## 
  let valid = call_613786.validator(path, query, header, formData, body)
  let scheme = call_613786.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613786.url(scheme.get, call_613786.host, call_613786.base,
                         call_613786.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613786, url, valid)

proc call*(call_613787: Call_ListSecurityProfilesForTarget_613772;
          securityProfileTargetArn: string; nextToken: string = "";
          recursive: bool = false; maxResults: int = 0): Recallable =
  ## listSecurityProfilesForTarget
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   recursive: bool
  ##            : If true, return child groups too.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the target (thing group) whose attached security profiles you want to get.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_613788 = newJObject()
  add(query_613788, "nextToken", newJString(nextToken))
  add(query_613788, "recursive", newJBool(recursive))
  add(query_613788, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(query_613788, "maxResults", newJInt(maxResults))
  result = call_613787.call(nil, query_613788, nil, nil, nil)

var listSecurityProfilesForTarget* = Call_ListSecurityProfilesForTarget_613772(
    name: "listSecurityProfilesForTarget", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/security-profiles-for-target#securityProfileTargetArn",
    validator: validate_ListSecurityProfilesForTarget_613773, base: "/",
    url: url_ListSecurityProfilesForTarget_613774,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListStreams_613789 = ref object of OpenApiRestCall_610658
proc url_ListStreams_613791(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListStreams_613790(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all of the streams in your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token used to get the next set of results.
  ##   isAscendingOrder: JBool
  ##                   : Set to true to return the list of streams in ascending order.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at a time.
  section = newJObject()
  var valid_613792 = query.getOrDefault("nextToken")
  valid_613792 = validateParameter(valid_613792, JString, required = false,
                                 default = nil)
  if valid_613792 != nil:
    section.add "nextToken", valid_613792
  var valid_613793 = query.getOrDefault("isAscendingOrder")
  valid_613793 = validateParameter(valid_613793, JBool, required = false, default = nil)
  if valid_613793 != nil:
    section.add "isAscendingOrder", valid_613793
  var valid_613794 = query.getOrDefault("maxResults")
  valid_613794 = validateParameter(valid_613794, JInt, required = false, default = nil)
  if valid_613794 != nil:
    section.add "maxResults", valid_613794
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613795 = header.getOrDefault("X-Amz-Signature")
  valid_613795 = validateParameter(valid_613795, JString, required = false,
                                 default = nil)
  if valid_613795 != nil:
    section.add "X-Amz-Signature", valid_613795
  var valid_613796 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613796 = validateParameter(valid_613796, JString, required = false,
                                 default = nil)
  if valid_613796 != nil:
    section.add "X-Amz-Content-Sha256", valid_613796
  var valid_613797 = header.getOrDefault("X-Amz-Date")
  valid_613797 = validateParameter(valid_613797, JString, required = false,
                                 default = nil)
  if valid_613797 != nil:
    section.add "X-Amz-Date", valid_613797
  var valid_613798 = header.getOrDefault("X-Amz-Credential")
  valid_613798 = validateParameter(valid_613798, JString, required = false,
                                 default = nil)
  if valid_613798 != nil:
    section.add "X-Amz-Credential", valid_613798
  var valid_613799 = header.getOrDefault("X-Amz-Security-Token")
  valid_613799 = validateParameter(valid_613799, JString, required = false,
                                 default = nil)
  if valid_613799 != nil:
    section.add "X-Amz-Security-Token", valid_613799
  var valid_613800 = header.getOrDefault("X-Amz-Algorithm")
  valid_613800 = validateParameter(valid_613800, JString, required = false,
                                 default = nil)
  if valid_613800 != nil:
    section.add "X-Amz-Algorithm", valid_613800
  var valid_613801 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613801 = validateParameter(valid_613801, JString, required = false,
                                 default = nil)
  if valid_613801 != nil:
    section.add "X-Amz-SignedHeaders", valid_613801
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613802: Call_ListStreams_613789; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all of the streams in your AWS account.
  ## 
  let valid = call_613802.validator(path, query, header, formData, body)
  let scheme = call_613802.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613802.url(scheme.get, call_613802.host, call_613802.base,
                         call_613802.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613802, url, valid)

proc call*(call_613803: Call_ListStreams_613789; nextToken: string = "";
          isAscendingOrder: bool = false; maxResults: int = 0): Recallable =
  ## listStreams
  ## Lists all of the streams in your AWS account.
  ##   nextToken: string
  ##            : A token used to get the next set of results.
  ##   isAscendingOrder: bool
  ##                   : Set to true to return the list of streams in ascending order.
  ##   maxResults: int
  ##             : The maximum number of results to return at a time.
  var query_613804 = newJObject()
  add(query_613804, "nextToken", newJString(nextToken))
  add(query_613804, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_613804, "maxResults", newJInt(maxResults))
  result = call_613803.call(nil, query_613804, nil, nil, nil)

var listStreams* = Call_ListStreams_613789(name: "listStreams",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/streams",
                                        validator: validate_ListStreams_613790,
                                        base: "/", url: url_ListStreams_613791,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTagsForResource_613805 = ref object of OpenApiRestCall_610658
proc url_ListTagsForResource_613807(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListTagsForResource_613806(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the tags (metadata) you have assigned to the resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   resourceArn: JString (required)
  ##              : The ARN of the resource.
  section = newJObject()
  var valid_613808 = query.getOrDefault("nextToken")
  valid_613808 = validateParameter(valid_613808, JString, required = false,
                                 default = nil)
  if valid_613808 != nil:
    section.add "nextToken", valid_613808
  assert query != nil,
        "query argument is necessary due to required `resourceArn` field"
  var valid_613809 = query.getOrDefault("resourceArn")
  valid_613809 = validateParameter(valid_613809, JString, required = true,
                                 default = nil)
  if valid_613809 != nil:
    section.add "resourceArn", valid_613809
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613810 = header.getOrDefault("X-Amz-Signature")
  valid_613810 = validateParameter(valid_613810, JString, required = false,
                                 default = nil)
  if valid_613810 != nil:
    section.add "X-Amz-Signature", valid_613810
  var valid_613811 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613811 = validateParameter(valid_613811, JString, required = false,
                                 default = nil)
  if valid_613811 != nil:
    section.add "X-Amz-Content-Sha256", valid_613811
  var valid_613812 = header.getOrDefault("X-Amz-Date")
  valid_613812 = validateParameter(valid_613812, JString, required = false,
                                 default = nil)
  if valid_613812 != nil:
    section.add "X-Amz-Date", valid_613812
  var valid_613813 = header.getOrDefault("X-Amz-Credential")
  valid_613813 = validateParameter(valid_613813, JString, required = false,
                                 default = nil)
  if valid_613813 != nil:
    section.add "X-Amz-Credential", valid_613813
  var valid_613814 = header.getOrDefault("X-Amz-Security-Token")
  valid_613814 = validateParameter(valid_613814, JString, required = false,
                                 default = nil)
  if valid_613814 != nil:
    section.add "X-Amz-Security-Token", valid_613814
  var valid_613815 = header.getOrDefault("X-Amz-Algorithm")
  valid_613815 = validateParameter(valid_613815, JString, required = false,
                                 default = nil)
  if valid_613815 != nil:
    section.add "X-Amz-Algorithm", valid_613815
  var valid_613816 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613816 = validateParameter(valid_613816, JString, required = false,
                                 default = nil)
  if valid_613816 != nil:
    section.add "X-Amz-SignedHeaders", valid_613816
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613817: Call_ListTagsForResource_613805; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the tags (metadata) you have assigned to the resource.
  ## 
  let valid = call_613817.validator(path, query, header, formData, body)
  let scheme = call_613817.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613817.url(scheme.get, call_613817.host, call_613817.base,
                         call_613817.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613817, url, valid)

proc call*(call_613818: Call_ListTagsForResource_613805; resourceArn: string;
          nextToken: string = ""): Recallable =
  ## listTagsForResource
  ## Lists the tags (metadata) you have assigned to the resource.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   resourceArn: string (required)
  ##              : The ARN of the resource.
  var query_613819 = newJObject()
  add(query_613819, "nextToken", newJString(nextToken))
  add(query_613819, "resourceArn", newJString(resourceArn))
  result = call_613818.call(nil, query_613819, nil, nil, nil)

var listTagsForResource* = Call_ListTagsForResource_613805(
    name: "listTagsForResource", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/tags#resourceArn",
    validator: validate_ListTagsForResource_613806, base: "/",
    url: url_ListTagsForResource_613807, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTargetsForPolicy_613820 = ref object of OpenApiRestCall_610658
proc url_ListTargetsForPolicy_613822(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policy-targets/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListTargetsForPolicy_613821(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List targets for the specified policy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_613823 = path.getOrDefault("policyName")
  valid_613823 = validateParameter(valid_613823, JString, required = true,
                                 default = nil)
  if valid_613823 != nil:
    section.add "policyName", valid_613823
  result.add "path", section
  ## parameters in `query` object:
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  section = newJObject()
  var valid_613824 = query.getOrDefault("pageSize")
  valid_613824 = validateParameter(valid_613824, JInt, required = false, default = nil)
  if valid_613824 != nil:
    section.add "pageSize", valid_613824
  var valid_613825 = query.getOrDefault("marker")
  valid_613825 = validateParameter(valid_613825, JString, required = false,
                                 default = nil)
  if valid_613825 != nil:
    section.add "marker", valid_613825
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613826 = header.getOrDefault("X-Amz-Signature")
  valid_613826 = validateParameter(valid_613826, JString, required = false,
                                 default = nil)
  if valid_613826 != nil:
    section.add "X-Amz-Signature", valid_613826
  var valid_613827 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613827 = validateParameter(valid_613827, JString, required = false,
                                 default = nil)
  if valid_613827 != nil:
    section.add "X-Amz-Content-Sha256", valid_613827
  var valid_613828 = header.getOrDefault("X-Amz-Date")
  valid_613828 = validateParameter(valid_613828, JString, required = false,
                                 default = nil)
  if valid_613828 != nil:
    section.add "X-Amz-Date", valid_613828
  var valid_613829 = header.getOrDefault("X-Amz-Credential")
  valid_613829 = validateParameter(valid_613829, JString, required = false,
                                 default = nil)
  if valid_613829 != nil:
    section.add "X-Amz-Credential", valid_613829
  var valid_613830 = header.getOrDefault("X-Amz-Security-Token")
  valid_613830 = validateParameter(valid_613830, JString, required = false,
                                 default = nil)
  if valid_613830 != nil:
    section.add "X-Amz-Security-Token", valid_613830
  var valid_613831 = header.getOrDefault("X-Amz-Algorithm")
  valid_613831 = validateParameter(valid_613831, JString, required = false,
                                 default = nil)
  if valid_613831 != nil:
    section.add "X-Amz-Algorithm", valid_613831
  var valid_613832 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613832 = validateParameter(valid_613832, JString, required = false,
                                 default = nil)
  if valid_613832 != nil:
    section.add "X-Amz-SignedHeaders", valid_613832
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613833: Call_ListTargetsForPolicy_613820; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List targets for the specified policy.
  ## 
  let valid = call_613833.validator(path, query, header, formData, body)
  let scheme = call_613833.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613833.url(scheme.get, call_613833.host, call_613833.base,
                         call_613833.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613833, url, valid)

proc call*(call_613834: Call_ListTargetsForPolicy_613820; policyName: string;
          pageSize: int = 0; marker: string = ""): Recallable =
  ## listTargetsForPolicy
  ## List targets for the specified policy.
  ##   policyName: string (required)
  ##             : The policy name.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  var path_613835 = newJObject()
  var query_613836 = newJObject()
  add(path_613835, "policyName", newJString(policyName))
  add(query_613836, "pageSize", newJInt(pageSize))
  add(query_613836, "marker", newJString(marker))
  result = call_613834.call(path_613835, query_613836, nil, nil, nil)

var listTargetsForPolicy* = Call_ListTargetsForPolicy_613820(
    name: "listTargetsForPolicy", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/policy-targets/{policyName}",
    validator: validate_ListTargetsForPolicy_613821, base: "/",
    url: url_ListTargetsForPolicy_613822, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTargetsForSecurityProfile_613837 = ref object of OpenApiRestCall_610658
proc url_ListTargetsForSecurityProfile_613839(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"),
               (kind: ConstantSegment, value: "/targets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListTargetsForSecurityProfile_613838(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_613840 = path.getOrDefault("securityProfileName")
  valid_613840 = validateParameter(valid_613840, JString, required = true,
                                 default = nil)
  if valid_613840 != nil:
    section.add "securityProfileName", valid_613840
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_613841 = query.getOrDefault("nextToken")
  valid_613841 = validateParameter(valid_613841, JString, required = false,
                                 default = nil)
  if valid_613841 != nil:
    section.add "nextToken", valid_613841
  var valid_613842 = query.getOrDefault("maxResults")
  valid_613842 = validateParameter(valid_613842, JInt, required = false, default = nil)
  if valid_613842 != nil:
    section.add "maxResults", valid_613842
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613843 = header.getOrDefault("X-Amz-Signature")
  valid_613843 = validateParameter(valid_613843, JString, required = false,
                                 default = nil)
  if valid_613843 != nil:
    section.add "X-Amz-Signature", valid_613843
  var valid_613844 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613844 = validateParameter(valid_613844, JString, required = false,
                                 default = nil)
  if valid_613844 != nil:
    section.add "X-Amz-Content-Sha256", valid_613844
  var valid_613845 = header.getOrDefault("X-Amz-Date")
  valid_613845 = validateParameter(valid_613845, JString, required = false,
                                 default = nil)
  if valid_613845 != nil:
    section.add "X-Amz-Date", valid_613845
  var valid_613846 = header.getOrDefault("X-Amz-Credential")
  valid_613846 = validateParameter(valid_613846, JString, required = false,
                                 default = nil)
  if valid_613846 != nil:
    section.add "X-Amz-Credential", valid_613846
  var valid_613847 = header.getOrDefault("X-Amz-Security-Token")
  valid_613847 = validateParameter(valid_613847, JString, required = false,
                                 default = nil)
  if valid_613847 != nil:
    section.add "X-Amz-Security-Token", valid_613847
  var valid_613848 = header.getOrDefault("X-Amz-Algorithm")
  valid_613848 = validateParameter(valid_613848, JString, required = false,
                                 default = nil)
  if valid_613848 != nil:
    section.add "X-Amz-Algorithm", valid_613848
  var valid_613849 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613849 = validateParameter(valid_613849, JString, required = false,
                                 default = nil)
  if valid_613849 != nil:
    section.add "X-Amz-SignedHeaders", valid_613849
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613850: Call_ListTargetsForSecurityProfile_613837; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ## 
  let valid = call_613850.validator(path, query, header, formData, body)
  let scheme = call_613850.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613850.url(scheme.get, call_613850.host, call_613850.base,
                         call_613850.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613850, url, valid)

proc call*(call_613851: Call_ListTargetsForSecurityProfile_613837;
          securityProfileName: string; nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listTargetsForSecurityProfile
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string (required)
  ##                      : The security profile.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_613852 = newJObject()
  var query_613853 = newJObject()
  add(query_613853, "nextToken", newJString(nextToken))
  add(path_613852, "securityProfileName", newJString(securityProfileName))
  add(query_613853, "maxResults", newJInt(maxResults))
  result = call_613851.call(path_613852, query_613853, nil, nil, nil)

var listTargetsForSecurityProfile* = Call_ListTargetsForSecurityProfile_613837(
    name: "listTargetsForSecurityProfile", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/security-profiles/{securityProfileName}/targets",
    validator: validate_ListTargetsForSecurityProfile_613838, base: "/",
    url: url_ListTargetsForSecurityProfile_613839,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingGroups_613854 = ref object of OpenApiRestCall_610658
proc url_ListThingGroups_613856(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThingGroups_613855(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List the thing groups in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   recursive: JBool
  ##            : If true, return child groups as well.
  ##   parentGroup: JString
  ##              : A filter that limits the results to those with the specified parent group.
  ##   namePrefixFilter: JString
  ##                   : A filter that limits the results to those with the specified name prefix.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_613857 = query.getOrDefault("nextToken")
  valid_613857 = validateParameter(valid_613857, JString, required = false,
                                 default = nil)
  if valid_613857 != nil:
    section.add "nextToken", valid_613857
  var valid_613858 = query.getOrDefault("recursive")
  valid_613858 = validateParameter(valid_613858, JBool, required = false, default = nil)
  if valid_613858 != nil:
    section.add "recursive", valid_613858
  var valid_613859 = query.getOrDefault("parentGroup")
  valid_613859 = validateParameter(valid_613859, JString, required = false,
                                 default = nil)
  if valid_613859 != nil:
    section.add "parentGroup", valid_613859
  var valid_613860 = query.getOrDefault("namePrefixFilter")
  valid_613860 = validateParameter(valid_613860, JString, required = false,
                                 default = nil)
  if valid_613860 != nil:
    section.add "namePrefixFilter", valid_613860
  var valid_613861 = query.getOrDefault("maxResults")
  valid_613861 = validateParameter(valid_613861, JInt, required = false, default = nil)
  if valid_613861 != nil:
    section.add "maxResults", valid_613861
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613862 = header.getOrDefault("X-Amz-Signature")
  valid_613862 = validateParameter(valid_613862, JString, required = false,
                                 default = nil)
  if valid_613862 != nil:
    section.add "X-Amz-Signature", valid_613862
  var valid_613863 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613863 = validateParameter(valid_613863, JString, required = false,
                                 default = nil)
  if valid_613863 != nil:
    section.add "X-Amz-Content-Sha256", valid_613863
  var valid_613864 = header.getOrDefault("X-Amz-Date")
  valid_613864 = validateParameter(valid_613864, JString, required = false,
                                 default = nil)
  if valid_613864 != nil:
    section.add "X-Amz-Date", valid_613864
  var valid_613865 = header.getOrDefault("X-Amz-Credential")
  valid_613865 = validateParameter(valid_613865, JString, required = false,
                                 default = nil)
  if valid_613865 != nil:
    section.add "X-Amz-Credential", valid_613865
  var valid_613866 = header.getOrDefault("X-Amz-Security-Token")
  valid_613866 = validateParameter(valid_613866, JString, required = false,
                                 default = nil)
  if valid_613866 != nil:
    section.add "X-Amz-Security-Token", valid_613866
  var valid_613867 = header.getOrDefault("X-Amz-Algorithm")
  valid_613867 = validateParameter(valid_613867, JString, required = false,
                                 default = nil)
  if valid_613867 != nil:
    section.add "X-Amz-Algorithm", valid_613867
  var valid_613868 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613868 = validateParameter(valid_613868, JString, required = false,
                                 default = nil)
  if valid_613868 != nil:
    section.add "X-Amz-SignedHeaders", valid_613868
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613869: Call_ListThingGroups_613854; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the thing groups in your account.
  ## 
  let valid = call_613869.validator(path, query, header, formData, body)
  let scheme = call_613869.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613869.url(scheme.get, call_613869.host, call_613869.base,
                         call_613869.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613869, url, valid)

proc call*(call_613870: Call_ListThingGroups_613854; nextToken: string = "";
          recursive: bool = false; parentGroup: string = "";
          namePrefixFilter: string = ""; maxResults: int = 0): Recallable =
  ## listThingGroups
  ## List the thing groups in your account.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   recursive: bool
  ##            : If true, return child groups as well.
  ##   parentGroup: string
  ##              : A filter that limits the results to those with the specified parent group.
  ##   namePrefixFilter: string
  ##                   : A filter that limits the results to those with the specified name prefix.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_613871 = newJObject()
  add(query_613871, "nextToken", newJString(nextToken))
  add(query_613871, "recursive", newJBool(recursive))
  add(query_613871, "parentGroup", newJString(parentGroup))
  add(query_613871, "namePrefixFilter", newJString(namePrefixFilter))
  add(query_613871, "maxResults", newJInt(maxResults))
  result = call_613870.call(nil, query_613871, nil, nil, nil)

var listThingGroups* = Call_ListThingGroups_613854(name: "listThingGroups",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/thing-groups",
    validator: validate_ListThingGroups_613855, base: "/", url: url_ListThingGroups_613856,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingGroupsForThing_613872 = ref object of OpenApiRestCall_610658
proc url_ListThingGroupsForThing_613874(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/thing-groups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingGroupsForThing_613873(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List the thing groups to which the specified thing belongs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The thing name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_613875 = path.getOrDefault("thingName")
  valid_613875 = validateParameter(valid_613875, JString, required = true,
                                 default = nil)
  if valid_613875 != nil:
    section.add "thingName", valid_613875
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_613876 = query.getOrDefault("nextToken")
  valid_613876 = validateParameter(valid_613876, JString, required = false,
                                 default = nil)
  if valid_613876 != nil:
    section.add "nextToken", valid_613876
  var valid_613877 = query.getOrDefault("maxResults")
  valid_613877 = validateParameter(valid_613877, JInt, required = false, default = nil)
  if valid_613877 != nil:
    section.add "maxResults", valid_613877
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613878 = header.getOrDefault("X-Amz-Signature")
  valid_613878 = validateParameter(valid_613878, JString, required = false,
                                 default = nil)
  if valid_613878 != nil:
    section.add "X-Amz-Signature", valid_613878
  var valid_613879 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613879 = validateParameter(valid_613879, JString, required = false,
                                 default = nil)
  if valid_613879 != nil:
    section.add "X-Amz-Content-Sha256", valid_613879
  var valid_613880 = header.getOrDefault("X-Amz-Date")
  valid_613880 = validateParameter(valid_613880, JString, required = false,
                                 default = nil)
  if valid_613880 != nil:
    section.add "X-Amz-Date", valid_613880
  var valid_613881 = header.getOrDefault("X-Amz-Credential")
  valid_613881 = validateParameter(valid_613881, JString, required = false,
                                 default = nil)
  if valid_613881 != nil:
    section.add "X-Amz-Credential", valid_613881
  var valid_613882 = header.getOrDefault("X-Amz-Security-Token")
  valid_613882 = validateParameter(valid_613882, JString, required = false,
                                 default = nil)
  if valid_613882 != nil:
    section.add "X-Amz-Security-Token", valid_613882
  var valid_613883 = header.getOrDefault("X-Amz-Algorithm")
  valid_613883 = validateParameter(valid_613883, JString, required = false,
                                 default = nil)
  if valid_613883 != nil:
    section.add "X-Amz-Algorithm", valid_613883
  var valid_613884 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613884 = validateParameter(valid_613884, JString, required = false,
                                 default = nil)
  if valid_613884 != nil:
    section.add "X-Amz-SignedHeaders", valid_613884
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613885: Call_ListThingGroupsForThing_613872; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the thing groups to which the specified thing belongs.
  ## 
  let valid = call_613885.validator(path, query, header, formData, body)
  let scheme = call_613885.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613885.url(scheme.get, call_613885.host, call_613885.base,
                         call_613885.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613885, url, valid)

proc call*(call_613886: Call_ListThingGroupsForThing_613872; thingName: string;
          nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listThingGroupsForThing
  ## List the thing groups to which the specified thing belongs.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingName: string (required)
  ##            : The thing name.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_613887 = newJObject()
  var query_613888 = newJObject()
  add(query_613888, "nextToken", newJString(nextToken))
  add(path_613887, "thingName", newJString(thingName))
  add(query_613888, "maxResults", newJInt(maxResults))
  result = call_613886.call(path_613887, query_613888, nil, nil, nil)

var listThingGroupsForThing* = Call_ListThingGroupsForThing_613872(
    name: "listThingGroupsForThing", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/thing-groups",
    validator: validate_ListThingGroupsForThing_613873, base: "/",
    url: url_ListThingGroupsForThing_613874, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingPrincipals_613889 = ref object of OpenApiRestCall_610658
proc url_ListThingPrincipals_613891(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingPrincipals_613890(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_613892 = path.getOrDefault("thingName")
  valid_613892 = validateParameter(valid_613892, JString, required = true,
                                 default = nil)
  if valid_613892 != nil:
    section.add "thingName", valid_613892
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613893 = header.getOrDefault("X-Amz-Signature")
  valid_613893 = validateParameter(valid_613893, JString, required = false,
                                 default = nil)
  if valid_613893 != nil:
    section.add "X-Amz-Signature", valid_613893
  var valid_613894 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613894 = validateParameter(valid_613894, JString, required = false,
                                 default = nil)
  if valid_613894 != nil:
    section.add "X-Amz-Content-Sha256", valid_613894
  var valid_613895 = header.getOrDefault("X-Amz-Date")
  valid_613895 = validateParameter(valid_613895, JString, required = false,
                                 default = nil)
  if valid_613895 != nil:
    section.add "X-Amz-Date", valid_613895
  var valid_613896 = header.getOrDefault("X-Amz-Credential")
  valid_613896 = validateParameter(valid_613896, JString, required = false,
                                 default = nil)
  if valid_613896 != nil:
    section.add "X-Amz-Credential", valid_613896
  var valid_613897 = header.getOrDefault("X-Amz-Security-Token")
  valid_613897 = validateParameter(valid_613897, JString, required = false,
                                 default = nil)
  if valid_613897 != nil:
    section.add "X-Amz-Security-Token", valid_613897
  var valid_613898 = header.getOrDefault("X-Amz-Algorithm")
  valid_613898 = validateParameter(valid_613898, JString, required = false,
                                 default = nil)
  if valid_613898 != nil:
    section.add "X-Amz-Algorithm", valid_613898
  var valid_613899 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613899 = validateParameter(valid_613899, JString, required = false,
                                 default = nil)
  if valid_613899 != nil:
    section.add "X-Amz-SignedHeaders", valid_613899
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613900: Call_ListThingPrincipals_613889; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  let valid = call_613900.validator(path, query, header, formData, body)
  let scheme = call_613900.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613900.url(scheme.get, call_613900.host, call_613900.base,
                         call_613900.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613900, url, valid)

proc call*(call_613901: Call_ListThingPrincipals_613889; thingName: string): Recallable =
  ## listThingPrincipals
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_613902 = newJObject()
  add(path_613902, "thingName", newJString(thingName))
  result = call_613901.call(path_613902, nil, nil, nil, nil)

var listThingPrincipals* = Call_ListThingPrincipals_613889(
    name: "listThingPrincipals", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/principals",
    validator: validate_ListThingPrincipals_613890, base: "/",
    url: url_ListThingPrincipals_613891, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingRegistrationTaskReports_613903 = ref object of OpenApiRestCall_610658
proc url_ListThingRegistrationTaskReports_613905(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/reports#reportType")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingRegistrationTaskReports_613904(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Information about the thing registration tasks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The id of the task.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_613906 = path.getOrDefault("taskId")
  valid_613906 = validateParameter(valid_613906, JString, required = true,
                                 default = nil)
  if valid_613906 != nil:
    section.add "taskId", valid_613906
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   reportType: JString (required)
  ##             : The type of task report.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_613907 = query.getOrDefault("nextToken")
  valid_613907 = validateParameter(valid_613907, JString, required = false,
                                 default = nil)
  if valid_613907 != nil:
    section.add "nextToken", valid_613907
  var valid_613908 = query.getOrDefault("reportType")
  valid_613908 = validateParameter(valid_613908, JString, required = true,
                                 default = newJString("ERRORS"))
  if valid_613908 != nil:
    section.add "reportType", valid_613908
  var valid_613909 = query.getOrDefault("maxResults")
  valid_613909 = validateParameter(valid_613909, JInt, required = false, default = nil)
  if valid_613909 != nil:
    section.add "maxResults", valid_613909
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613910 = header.getOrDefault("X-Amz-Signature")
  valid_613910 = validateParameter(valid_613910, JString, required = false,
                                 default = nil)
  if valid_613910 != nil:
    section.add "X-Amz-Signature", valid_613910
  var valid_613911 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613911 = validateParameter(valid_613911, JString, required = false,
                                 default = nil)
  if valid_613911 != nil:
    section.add "X-Amz-Content-Sha256", valid_613911
  var valid_613912 = header.getOrDefault("X-Amz-Date")
  valid_613912 = validateParameter(valid_613912, JString, required = false,
                                 default = nil)
  if valid_613912 != nil:
    section.add "X-Amz-Date", valid_613912
  var valid_613913 = header.getOrDefault("X-Amz-Credential")
  valid_613913 = validateParameter(valid_613913, JString, required = false,
                                 default = nil)
  if valid_613913 != nil:
    section.add "X-Amz-Credential", valid_613913
  var valid_613914 = header.getOrDefault("X-Amz-Security-Token")
  valid_613914 = validateParameter(valid_613914, JString, required = false,
                                 default = nil)
  if valid_613914 != nil:
    section.add "X-Amz-Security-Token", valid_613914
  var valid_613915 = header.getOrDefault("X-Amz-Algorithm")
  valid_613915 = validateParameter(valid_613915, JString, required = false,
                                 default = nil)
  if valid_613915 != nil:
    section.add "X-Amz-Algorithm", valid_613915
  var valid_613916 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613916 = validateParameter(valid_613916, JString, required = false,
                                 default = nil)
  if valid_613916 != nil:
    section.add "X-Amz-SignedHeaders", valid_613916
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613917: Call_ListThingRegistrationTaskReports_613903;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Information about the thing registration tasks.
  ## 
  let valid = call_613917.validator(path, query, header, formData, body)
  let scheme = call_613917.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613917.url(scheme.get, call_613917.host, call_613917.base,
                         call_613917.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613917, url, valid)

proc call*(call_613918: Call_ListThingRegistrationTaskReports_613903;
          taskId: string; nextToken: string = ""; reportType: string = "ERRORS";
          maxResults: int = 0): Recallable =
  ## listThingRegistrationTaskReports
  ## Information about the thing registration tasks.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   taskId: string (required)
  ##         : The id of the task.
  ##   reportType: string (required)
  ##             : The type of task report.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var path_613919 = newJObject()
  var query_613920 = newJObject()
  add(query_613920, "nextToken", newJString(nextToken))
  add(path_613919, "taskId", newJString(taskId))
  add(query_613920, "reportType", newJString(reportType))
  add(query_613920, "maxResults", newJInt(maxResults))
  result = call_613918.call(path_613919, query_613920, nil, nil, nil)

var listThingRegistrationTaskReports* = Call_ListThingRegistrationTaskReports_613903(
    name: "listThingRegistrationTaskReports", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/thing-registration-tasks/{taskId}/reports#reportType",
    validator: validate_ListThingRegistrationTaskReports_613904, base: "/",
    url: url_ListThingRegistrationTaskReports_613905,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartThingRegistrationTask_613937 = ref object of OpenApiRestCall_610658
proc url_StartThingRegistrationTask_613939(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_StartThingRegistrationTask_613938(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613940 = header.getOrDefault("X-Amz-Signature")
  valid_613940 = validateParameter(valid_613940, JString, required = false,
                                 default = nil)
  if valid_613940 != nil:
    section.add "X-Amz-Signature", valid_613940
  var valid_613941 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613941 = validateParameter(valid_613941, JString, required = false,
                                 default = nil)
  if valid_613941 != nil:
    section.add "X-Amz-Content-Sha256", valid_613941
  var valid_613942 = header.getOrDefault("X-Amz-Date")
  valid_613942 = validateParameter(valid_613942, JString, required = false,
                                 default = nil)
  if valid_613942 != nil:
    section.add "X-Amz-Date", valid_613942
  var valid_613943 = header.getOrDefault("X-Amz-Credential")
  valid_613943 = validateParameter(valid_613943, JString, required = false,
                                 default = nil)
  if valid_613943 != nil:
    section.add "X-Amz-Credential", valid_613943
  var valid_613944 = header.getOrDefault("X-Amz-Security-Token")
  valid_613944 = validateParameter(valid_613944, JString, required = false,
                                 default = nil)
  if valid_613944 != nil:
    section.add "X-Amz-Security-Token", valid_613944
  var valid_613945 = header.getOrDefault("X-Amz-Algorithm")
  valid_613945 = validateParameter(valid_613945, JString, required = false,
                                 default = nil)
  if valid_613945 != nil:
    section.add "X-Amz-Algorithm", valid_613945
  var valid_613946 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613946 = validateParameter(valid_613946, JString, required = false,
                                 default = nil)
  if valid_613946 != nil:
    section.add "X-Amz-SignedHeaders", valid_613946
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613948: Call_StartThingRegistrationTask_613937; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a bulk thing provisioning task.
  ## 
  let valid = call_613948.validator(path, query, header, formData, body)
  let scheme = call_613948.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613948.url(scheme.get, call_613948.host, call_613948.base,
                         call_613948.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613948, url, valid)

proc call*(call_613949: Call_StartThingRegistrationTask_613937; body: JsonNode): Recallable =
  ## startThingRegistrationTask
  ## Creates a bulk thing provisioning task.
  ##   body: JObject (required)
  var body_613950 = newJObject()
  if body != nil:
    body_613950 = body
  result = call_613949.call(nil, nil, nil, nil, body_613950)

var startThingRegistrationTask* = Call_StartThingRegistrationTask_613937(
    name: "startThingRegistrationTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks",
    validator: validate_StartThingRegistrationTask_613938, base: "/",
    url: url_StartThingRegistrationTask_613939,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingRegistrationTasks_613921 = ref object of OpenApiRestCall_610658
proc url_ListThingRegistrationTasks_613923(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThingRegistrationTasks_613922(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List bulk thing provisioning tasks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : The status of the bulk thing provisioning task.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_613924 = query.getOrDefault("nextToken")
  valid_613924 = validateParameter(valid_613924, JString, required = false,
                                 default = nil)
  if valid_613924 != nil:
    section.add "nextToken", valid_613924
  var valid_613925 = query.getOrDefault("status")
  valid_613925 = validateParameter(valid_613925, JString, required = false,
                                 default = newJString("InProgress"))
  if valid_613925 != nil:
    section.add "status", valid_613925
  var valid_613926 = query.getOrDefault("maxResults")
  valid_613926 = validateParameter(valid_613926, JInt, required = false, default = nil)
  if valid_613926 != nil:
    section.add "maxResults", valid_613926
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613927 = header.getOrDefault("X-Amz-Signature")
  valid_613927 = validateParameter(valid_613927, JString, required = false,
                                 default = nil)
  if valid_613927 != nil:
    section.add "X-Amz-Signature", valid_613927
  var valid_613928 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613928 = validateParameter(valid_613928, JString, required = false,
                                 default = nil)
  if valid_613928 != nil:
    section.add "X-Amz-Content-Sha256", valid_613928
  var valid_613929 = header.getOrDefault("X-Amz-Date")
  valid_613929 = validateParameter(valid_613929, JString, required = false,
                                 default = nil)
  if valid_613929 != nil:
    section.add "X-Amz-Date", valid_613929
  var valid_613930 = header.getOrDefault("X-Amz-Credential")
  valid_613930 = validateParameter(valid_613930, JString, required = false,
                                 default = nil)
  if valid_613930 != nil:
    section.add "X-Amz-Credential", valid_613930
  var valid_613931 = header.getOrDefault("X-Amz-Security-Token")
  valid_613931 = validateParameter(valid_613931, JString, required = false,
                                 default = nil)
  if valid_613931 != nil:
    section.add "X-Amz-Security-Token", valid_613931
  var valid_613932 = header.getOrDefault("X-Amz-Algorithm")
  valid_613932 = validateParameter(valid_613932, JString, required = false,
                                 default = nil)
  if valid_613932 != nil:
    section.add "X-Amz-Algorithm", valid_613932
  var valid_613933 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613933 = validateParameter(valid_613933, JString, required = false,
                                 default = nil)
  if valid_613933 != nil:
    section.add "X-Amz-SignedHeaders", valid_613933
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613934: Call_ListThingRegistrationTasks_613921; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List bulk thing provisioning tasks.
  ## 
  let valid = call_613934.validator(path, query, header, formData, body)
  let scheme = call_613934.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613934.url(scheme.get, call_613934.host, call_613934.base,
                         call_613934.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613934, url, valid)

proc call*(call_613935: Call_ListThingRegistrationTasks_613921;
          nextToken: string = ""; status: string = "InProgress"; maxResults: int = 0): Recallable =
  ## listThingRegistrationTasks
  ## List bulk thing provisioning tasks.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : The status of the bulk thing provisioning task.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_613936 = newJObject()
  add(query_613936, "nextToken", newJString(nextToken))
  add(query_613936, "status", newJString(status))
  add(query_613936, "maxResults", newJInt(maxResults))
  result = call_613935.call(nil, query_613936, nil, nil, nil)

var listThingRegistrationTasks* = Call_ListThingRegistrationTasks_613921(
    name: "listThingRegistrationTasks", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks",
    validator: validate_ListThingRegistrationTasks_613922, base: "/",
    url: url_ListThingRegistrationTasks_613923,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingTypes_613951 = ref object of OpenApiRestCall_610658
proc url_ListThingTypes_613953(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThingTypes_613952(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the existing thing types.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   thingTypeName: JString
  ##                : The name of the thing type.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  section = newJObject()
  var valid_613954 = query.getOrDefault("nextToken")
  valid_613954 = validateParameter(valid_613954, JString, required = false,
                                 default = nil)
  if valid_613954 != nil:
    section.add "nextToken", valid_613954
  var valid_613955 = query.getOrDefault("thingTypeName")
  valid_613955 = validateParameter(valid_613955, JString, required = false,
                                 default = nil)
  if valid_613955 != nil:
    section.add "thingTypeName", valid_613955
  var valid_613956 = query.getOrDefault("maxResults")
  valid_613956 = validateParameter(valid_613956, JInt, required = false, default = nil)
  if valid_613956 != nil:
    section.add "maxResults", valid_613956
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613957 = header.getOrDefault("X-Amz-Signature")
  valid_613957 = validateParameter(valid_613957, JString, required = false,
                                 default = nil)
  if valid_613957 != nil:
    section.add "X-Amz-Signature", valid_613957
  var valid_613958 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613958 = validateParameter(valid_613958, JString, required = false,
                                 default = nil)
  if valid_613958 != nil:
    section.add "X-Amz-Content-Sha256", valid_613958
  var valid_613959 = header.getOrDefault("X-Amz-Date")
  valid_613959 = validateParameter(valid_613959, JString, required = false,
                                 default = nil)
  if valid_613959 != nil:
    section.add "X-Amz-Date", valid_613959
  var valid_613960 = header.getOrDefault("X-Amz-Credential")
  valid_613960 = validateParameter(valid_613960, JString, required = false,
                                 default = nil)
  if valid_613960 != nil:
    section.add "X-Amz-Credential", valid_613960
  var valid_613961 = header.getOrDefault("X-Amz-Security-Token")
  valid_613961 = validateParameter(valid_613961, JString, required = false,
                                 default = nil)
  if valid_613961 != nil:
    section.add "X-Amz-Security-Token", valid_613961
  var valid_613962 = header.getOrDefault("X-Amz-Algorithm")
  valid_613962 = validateParameter(valid_613962, JString, required = false,
                                 default = nil)
  if valid_613962 != nil:
    section.add "X-Amz-Algorithm", valid_613962
  var valid_613963 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613963 = validateParameter(valid_613963, JString, required = false,
                                 default = nil)
  if valid_613963 != nil:
    section.add "X-Amz-SignedHeaders", valid_613963
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613964: Call_ListThingTypes_613951; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the existing thing types.
  ## 
  let valid = call_613964.validator(path, query, header, formData, body)
  let scheme = call_613964.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613964.url(scheme.get, call_613964.host, call_613964.base,
                         call_613964.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613964, url, valid)

proc call*(call_613965: Call_ListThingTypes_613951; nextToken: string = "";
          thingTypeName: string = ""; maxResults: int = 0): Recallable =
  ## listThingTypes
  ## Lists the existing thing types.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingTypeName: string
  ##                : The name of the thing type.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  var query_613966 = newJObject()
  add(query_613966, "nextToken", newJString(nextToken))
  add(query_613966, "thingTypeName", newJString(thingTypeName))
  add(query_613966, "maxResults", newJInt(maxResults))
  result = call_613965.call(nil, query_613966, nil, nil, nil)

var listThingTypes* = Call_ListThingTypes_613951(name: "listThingTypes",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/thing-types",
    validator: validate_ListThingTypes_613952, base: "/", url: url_ListThingTypes_613953,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterThing_613985 = ref object of OpenApiRestCall_610658
proc url_RegisterThing_613987(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RegisterThing_613986(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613988 = header.getOrDefault("X-Amz-Signature")
  valid_613988 = validateParameter(valid_613988, JString, required = false,
                                 default = nil)
  if valid_613988 != nil:
    section.add "X-Amz-Signature", valid_613988
  var valid_613989 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613989 = validateParameter(valid_613989, JString, required = false,
                                 default = nil)
  if valid_613989 != nil:
    section.add "X-Amz-Content-Sha256", valid_613989
  var valid_613990 = header.getOrDefault("X-Amz-Date")
  valid_613990 = validateParameter(valid_613990, JString, required = false,
                                 default = nil)
  if valid_613990 != nil:
    section.add "X-Amz-Date", valid_613990
  var valid_613991 = header.getOrDefault("X-Amz-Credential")
  valid_613991 = validateParameter(valid_613991, JString, required = false,
                                 default = nil)
  if valid_613991 != nil:
    section.add "X-Amz-Credential", valid_613991
  var valid_613992 = header.getOrDefault("X-Amz-Security-Token")
  valid_613992 = validateParameter(valid_613992, JString, required = false,
                                 default = nil)
  if valid_613992 != nil:
    section.add "X-Amz-Security-Token", valid_613992
  var valid_613993 = header.getOrDefault("X-Amz-Algorithm")
  valid_613993 = validateParameter(valid_613993, JString, required = false,
                                 default = nil)
  if valid_613993 != nil:
    section.add "X-Amz-Algorithm", valid_613993
  var valid_613994 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613994 = validateParameter(valid_613994, JString, required = false,
                                 default = nil)
  if valid_613994 != nil:
    section.add "X-Amz-SignedHeaders", valid_613994
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_613996: Call_RegisterThing_613985; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.
  ## 
  let valid = call_613996.validator(path, query, header, formData, body)
  let scheme = call_613996.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613996.url(scheme.get, call_613996.host, call_613996.base,
                         call_613996.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613996, url, valid)

proc call*(call_613997: Call_RegisterThing_613985; body: JsonNode): Recallable =
  ## registerThing
  ## Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.
  ##   body: JObject (required)
  var body_613998 = newJObject()
  if body != nil:
    body_613998 = body
  result = call_613997.call(nil, nil, nil, nil, body_613998)

var registerThing* = Call_RegisterThing_613985(name: "registerThing",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/things",
    validator: validate_RegisterThing_613986, base: "/", url: url_RegisterThing_613987,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThings_613967 = ref object of OpenApiRestCall_610658
proc url_ListThings_613969(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThings_613968(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   attributeName: JString
  ##                : The attribute name used to search for things.
  ##   thingTypeName: JString
  ##                : The name of the thing type used to search for things.
  ##   attributeValue: JString
  ##                 : The attribute value used to search for things.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  section = newJObject()
  var valid_613970 = query.getOrDefault("nextToken")
  valid_613970 = validateParameter(valid_613970, JString, required = false,
                                 default = nil)
  if valid_613970 != nil:
    section.add "nextToken", valid_613970
  var valid_613971 = query.getOrDefault("attributeName")
  valid_613971 = validateParameter(valid_613971, JString, required = false,
                                 default = nil)
  if valid_613971 != nil:
    section.add "attributeName", valid_613971
  var valid_613972 = query.getOrDefault("thingTypeName")
  valid_613972 = validateParameter(valid_613972, JString, required = false,
                                 default = nil)
  if valid_613972 != nil:
    section.add "thingTypeName", valid_613972
  var valid_613973 = query.getOrDefault("attributeValue")
  valid_613973 = validateParameter(valid_613973, JString, required = false,
                                 default = nil)
  if valid_613973 != nil:
    section.add "attributeValue", valid_613973
  var valid_613974 = query.getOrDefault("maxResults")
  valid_613974 = validateParameter(valid_613974, JInt, required = false, default = nil)
  if valid_613974 != nil:
    section.add "maxResults", valid_613974
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_613975 = header.getOrDefault("X-Amz-Signature")
  valid_613975 = validateParameter(valid_613975, JString, required = false,
                                 default = nil)
  if valid_613975 != nil:
    section.add "X-Amz-Signature", valid_613975
  var valid_613976 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_613976 = validateParameter(valid_613976, JString, required = false,
                                 default = nil)
  if valid_613976 != nil:
    section.add "X-Amz-Content-Sha256", valid_613976
  var valid_613977 = header.getOrDefault("X-Amz-Date")
  valid_613977 = validateParameter(valid_613977, JString, required = false,
                                 default = nil)
  if valid_613977 != nil:
    section.add "X-Amz-Date", valid_613977
  var valid_613978 = header.getOrDefault("X-Amz-Credential")
  valid_613978 = validateParameter(valid_613978, JString, required = false,
                                 default = nil)
  if valid_613978 != nil:
    section.add "X-Amz-Credential", valid_613978
  var valid_613979 = header.getOrDefault("X-Amz-Security-Token")
  valid_613979 = validateParameter(valid_613979, JString, required = false,
                                 default = nil)
  if valid_613979 != nil:
    section.add "X-Amz-Security-Token", valid_613979
  var valid_613980 = header.getOrDefault("X-Amz-Algorithm")
  valid_613980 = validateParameter(valid_613980, JString, required = false,
                                 default = nil)
  if valid_613980 != nil:
    section.add "X-Amz-Algorithm", valid_613980
  var valid_613981 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_613981 = validateParameter(valid_613981, JString, required = false,
                                 default = nil)
  if valid_613981 != nil:
    section.add "X-Amz-SignedHeaders", valid_613981
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_613982: Call_ListThings_613967; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ## 
  let valid = call_613982.validator(path, query, header, formData, body)
  let scheme = call_613982.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_613982.url(scheme.get, call_613982.host, call_613982.base,
                         call_613982.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_613982, url, valid)

proc call*(call_613983: Call_ListThings_613967; nextToken: string = "";
          attributeName: string = ""; thingTypeName: string = "";
          attributeValue: string = ""; maxResults: int = 0): Recallable =
  ## listThings
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   attributeName: string
  ##                : The attribute name used to search for things.
  ##   thingTypeName: string
  ##                : The name of the thing type used to search for things.
  ##   attributeValue: string
  ##                 : The attribute value used to search for things.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  var query_613984 = newJObject()
  add(query_613984, "nextToken", newJString(nextToken))
  add(query_613984, "attributeName", newJString(attributeName))
  add(query_613984, "thingTypeName", newJString(thingTypeName))
  add(query_613984, "attributeValue", newJString(attributeValue))
  add(query_613984, "maxResults", newJInt(maxResults))
  result = call_613983.call(nil, query_613984, nil, nil, nil)

var listThings* = Call_ListThings_613967(name: "listThings",
                                      meth: HttpMethod.HttpGet,
                                      host: "iot.amazonaws.com", route: "/things",
                                      validator: validate_ListThings_613968,
                                      base: "/", url: url_ListThings_613969,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingsInBillingGroup_613999 = ref object of OpenApiRestCall_610658
proc url_ListThingsInBillingGroup_614001(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingsInBillingGroup_614000(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the things you have added to the given billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_614002 = path.getOrDefault("billingGroupName")
  valid_614002 = validateParameter(valid_614002, JString, required = true,
                                 default = nil)
  if valid_614002 != nil:
    section.add "billingGroupName", valid_614002
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_614003 = query.getOrDefault("nextToken")
  valid_614003 = validateParameter(valid_614003, JString, required = false,
                                 default = nil)
  if valid_614003 != nil:
    section.add "nextToken", valid_614003
  var valid_614004 = query.getOrDefault("maxResults")
  valid_614004 = validateParameter(valid_614004, JInt, required = false, default = nil)
  if valid_614004 != nil:
    section.add "maxResults", valid_614004
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614005 = header.getOrDefault("X-Amz-Signature")
  valid_614005 = validateParameter(valid_614005, JString, required = false,
                                 default = nil)
  if valid_614005 != nil:
    section.add "X-Amz-Signature", valid_614005
  var valid_614006 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614006 = validateParameter(valid_614006, JString, required = false,
                                 default = nil)
  if valid_614006 != nil:
    section.add "X-Amz-Content-Sha256", valid_614006
  var valid_614007 = header.getOrDefault("X-Amz-Date")
  valid_614007 = validateParameter(valid_614007, JString, required = false,
                                 default = nil)
  if valid_614007 != nil:
    section.add "X-Amz-Date", valid_614007
  var valid_614008 = header.getOrDefault("X-Amz-Credential")
  valid_614008 = validateParameter(valid_614008, JString, required = false,
                                 default = nil)
  if valid_614008 != nil:
    section.add "X-Amz-Credential", valid_614008
  var valid_614009 = header.getOrDefault("X-Amz-Security-Token")
  valid_614009 = validateParameter(valid_614009, JString, required = false,
                                 default = nil)
  if valid_614009 != nil:
    section.add "X-Amz-Security-Token", valid_614009
  var valid_614010 = header.getOrDefault("X-Amz-Algorithm")
  valid_614010 = validateParameter(valid_614010, JString, required = false,
                                 default = nil)
  if valid_614010 != nil:
    section.add "X-Amz-Algorithm", valid_614010
  var valid_614011 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614011 = validateParameter(valid_614011, JString, required = false,
                                 default = nil)
  if valid_614011 != nil:
    section.add "X-Amz-SignedHeaders", valid_614011
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614012: Call_ListThingsInBillingGroup_613999; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things you have added to the given billing group.
  ## 
  let valid = call_614012.validator(path, query, header, formData, body)
  let scheme = call_614012.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614012.url(scheme.get, call_614012.host, call_614012.base,
                         call_614012.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614012, url, valid)

proc call*(call_614013: Call_ListThingsInBillingGroup_613999;
          billingGroupName: string; nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listThingsInBillingGroup
  ## Lists the things you have added to the given billing group.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var path_614014 = newJObject()
  var query_614015 = newJObject()
  add(query_614015, "nextToken", newJString(nextToken))
  add(path_614014, "billingGroupName", newJString(billingGroupName))
  add(query_614015, "maxResults", newJInt(maxResults))
  result = call_614013.call(path_614014, query_614015, nil, nil, nil)

var listThingsInBillingGroup* = Call_ListThingsInBillingGroup_613999(
    name: "listThingsInBillingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}/things",
    validator: validate_ListThingsInBillingGroup_614000, base: "/",
    url: url_ListThingsInBillingGroup_614001, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingsInThingGroup_614016 = ref object of OpenApiRestCall_610658
proc url_ListThingsInThingGroup_614018(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingsInThingGroup_614017(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the things in the specified group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_614019 = path.getOrDefault("thingGroupName")
  valid_614019 = validateParameter(valid_614019, JString, required = true,
                                 default = nil)
  if valid_614019 != nil:
    section.add "thingGroupName", valid_614019
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   recursive: JBool
  ##            : When true, list things in this thing group and in all child groups as well.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_614020 = query.getOrDefault("nextToken")
  valid_614020 = validateParameter(valid_614020, JString, required = false,
                                 default = nil)
  if valid_614020 != nil:
    section.add "nextToken", valid_614020
  var valid_614021 = query.getOrDefault("recursive")
  valid_614021 = validateParameter(valid_614021, JBool, required = false, default = nil)
  if valid_614021 != nil:
    section.add "recursive", valid_614021
  var valid_614022 = query.getOrDefault("maxResults")
  valid_614022 = validateParameter(valid_614022, JInt, required = false, default = nil)
  if valid_614022 != nil:
    section.add "maxResults", valid_614022
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614023 = header.getOrDefault("X-Amz-Signature")
  valid_614023 = validateParameter(valid_614023, JString, required = false,
                                 default = nil)
  if valid_614023 != nil:
    section.add "X-Amz-Signature", valid_614023
  var valid_614024 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614024 = validateParameter(valid_614024, JString, required = false,
                                 default = nil)
  if valid_614024 != nil:
    section.add "X-Amz-Content-Sha256", valid_614024
  var valid_614025 = header.getOrDefault("X-Amz-Date")
  valid_614025 = validateParameter(valid_614025, JString, required = false,
                                 default = nil)
  if valid_614025 != nil:
    section.add "X-Amz-Date", valid_614025
  var valid_614026 = header.getOrDefault("X-Amz-Credential")
  valid_614026 = validateParameter(valid_614026, JString, required = false,
                                 default = nil)
  if valid_614026 != nil:
    section.add "X-Amz-Credential", valid_614026
  var valid_614027 = header.getOrDefault("X-Amz-Security-Token")
  valid_614027 = validateParameter(valid_614027, JString, required = false,
                                 default = nil)
  if valid_614027 != nil:
    section.add "X-Amz-Security-Token", valid_614027
  var valid_614028 = header.getOrDefault("X-Amz-Algorithm")
  valid_614028 = validateParameter(valid_614028, JString, required = false,
                                 default = nil)
  if valid_614028 != nil:
    section.add "X-Amz-Algorithm", valid_614028
  var valid_614029 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614029 = validateParameter(valid_614029, JString, required = false,
                                 default = nil)
  if valid_614029 != nil:
    section.add "X-Amz-SignedHeaders", valid_614029
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614030: Call_ListThingsInThingGroup_614016; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things in the specified group.
  ## 
  let valid = call_614030.validator(path, query, header, formData, body)
  let scheme = call_614030.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614030.url(scheme.get, call_614030.host, call_614030.base,
                         call_614030.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614030, url, valid)

proc call*(call_614031: Call_ListThingsInThingGroup_614016; thingGroupName: string;
          nextToken: string = ""; recursive: bool = false; maxResults: int = 0): Recallable =
  ## listThingsInThingGroup
  ## Lists the things in the specified group.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: string (required)
  ##                 : The thing group name.
  ##   recursive: bool
  ##            : When true, list things in this thing group and in all child groups as well.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_614032 = newJObject()
  var query_614033 = newJObject()
  add(query_614033, "nextToken", newJString(nextToken))
  add(path_614032, "thingGroupName", newJString(thingGroupName))
  add(query_614033, "recursive", newJBool(recursive))
  add(query_614033, "maxResults", newJInt(maxResults))
  result = call_614031.call(path_614032, query_614033, nil, nil, nil)

var listThingsInThingGroup* = Call_ListThingsInThingGroup_614016(
    name: "listThingsInThingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-groups/{thingGroupName}/things",
    validator: validate_ListThingsInThingGroup_614017, base: "/",
    url: url_ListThingsInThingGroup_614018, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTopicRules_614034 = ref object of OpenApiRestCall_610658
proc url_ListTopicRules_614036(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListTopicRules_614035(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the rules for the specific topic.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token used to retrieve the next value.
  ##   topic: JString
  ##        : The topic.
  ##   ruleDisabled: JBool
  ##               : Specifies whether the rule is disabled.
  ##   maxResults: JInt
  ##             : The maximum number of results to return.
  section = newJObject()
  var valid_614037 = query.getOrDefault("nextToken")
  valid_614037 = validateParameter(valid_614037, JString, required = false,
                                 default = nil)
  if valid_614037 != nil:
    section.add "nextToken", valid_614037
  var valid_614038 = query.getOrDefault("topic")
  valid_614038 = validateParameter(valid_614038, JString, required = false,
                                 default = nil)
  if valid_614038 != nil:
    section.add "topic", valid_614038
  var valid_614039 = query.getOrDefault("ruleDisabled")
  valid_614039 = validateParameter(valid_614039, JBool, required = false, default = nil)
  if valid_614039 != nil:
    section.add "ruleDisabled", valid_614039
  var valid_614040 = query.getOrDefault("maxResults")
  valid_614040 = validateParameter(valid_614040, JInt, required = false, default = nil)
  if valid_614040 != nil:
    section.add "maxResults", valid_614040
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614041 = header.getOrDefault("X-Amz-Signature")
  valid_614041 = validateParameter(valid_614041, JString, required = false,
                                 default = nil)
  if valid_614041 != nil:
    section.add "X-Amz-Signature", valid_614041
  var valid_614042 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614042 = validateParameter(valid_614042, JString, required = false,
                                 default = nil)
  if valid_614042 != nil:
    section.add "X-Amz-Content-Sha256", valid_614042
  var valid_614043 = header.getOrDefault("X-Amz-Date")
  valid_614043 = validateParameter(valid_614043, JString, required = false,
                                 default = nil)
  if valid_614043 != nil:
    section.add "X-Amz-Date", valid_614043
  var valid_614044 = header.getOrDefault("X-Amz-Credential")
  valid_614044 = validateParameter(valid_614044, JString, required = false,
                                 default = nil)
  if valid_614044 != nil:
    section.add "X-Amz-Credential", valid_614044
  var valid_614045 = header.getOrDefault("X-Amz-Security-Token")
  valid_614045 = validateParameter(valid_614045, JString, required = false,
                                 default = nil)
  if valid_614045 != nil:
    section.add "X-Amz-Security-Token", valid_614045
  var valid_614046 = header.getOrDefault("X-Amz-Algorithm")
  valid_614046 = validateParameter(valid_614046, JString, required = false,
                                 default = nil)
  if valid_614046 != nil:
    section.add "X-Amz-Algorithm", valid_614046
  var valid_614047 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614047 = validateParameter(valid_614047, JString, required = false,
                                 default = nil)
  if valid_614047 != nil:
    section.add "X-Amz-SignedHeaders", valid_614047
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614048: Call_ListTopicRules_614034; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the rules for the specific topic.
  ## 
  let valid = call_614048.validator(path, query, header, formData, body)
  let scheme = call_614048.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614048.url(scheme.get, call_614048.host, call_614048.base,
                         call_614048.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614048, url, valid)

proc call*(call_614049: Call_ListTopicRules_614034; nextToken: string = "";
          topic: string = ""; ruleDisabled: bool = false; maxResults: int = 0): Recallable =
  ## listTopicRules
  ## Lists the rules for the specific topic.
  ##   nextToken: string
  ##            : A token used to retrieve the next value.
  ##   topic: string
  ##        : The topic.
  ##   ruleDisabled: bool
  ##               : Specifies whether the rule is disabled.
  ##   maxResults: int
  ##             : The maximum number of results to return.
  var query_614050 = newJObject()
  add(query_614050, "nextToken", newJString(nextToken))
  add(query_614050, "topic", newJString(topic))
  add(query_614050, "ruleDisabled", newJBool(ruleDisabled))
  add(query_614050, "maxResults", newJInt(maxResults))
  result = call_614049.call(nil, query_614050, nil, nil, nil)

var listTopicRules* = Call_ListTopicRules_614034(name: "listTopicRules",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/rules",
    validator: validate_ListTopicRules_614035, base: "/", url: url_ListTopicRules_614036,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetV2LoggingLevel_614067 = ref object of OpenApiRestCall_610658
proc url_SetV2LoggingLevel_614069(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetV2LoggingLevel_614068(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Sets the logging level.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614070 = header.getOrDefault("X-Amz-Signature")
  valid_614070 = validateParameter(valid_614070, JString, required = false,
                                 default = nil)
  if valid_614070 != nil:
    section.add "X-Amz-Signature", valid_614070
  var valid_614071 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614071 = validateParameter(valid_614071, JString, required = false,
                                 default = nil)
  if valid_614071 != nil:
    section.add "X-Amz-Content-Sha256", valid_614071
  var valid_614072 = header.getOrDefault("X-Amz-Date")
  valid_614072 = validateParameter(valid_614072, JString, required = false,
                                 default = nil)
  if valid_614072 != nil:
    section.add "X-Amz-Date", valid_614072
  var valid_614073 = header.getOrDefault("X-Amz-Credential")
  valid_614073 = validateParameter(valid_614073, JString, required = false,
                                 default = nil)
  if valid_614073 != nil:
    section.add "X-Amz-Credential", valid_614073
  var valid_614074 = header.getOrDefault("X-Amz-Security-Token")
  valid_614074 = validateParameter(valid_614074, JString, required = false,
                                 default = nil)
  if valid_614074 != nil:
    section.add "X-Amz-Security-Token", valid_614074
  var valid_614075 = header.getOrDefault("X-Amz-Algorithm")
  valid_614075 = validateParameter(valid_614075, JString, required = false,
                                 default = nil)
  if valid_614075 != nil:
    section.add "X-Amz-Algorithm", valid_614075
  var valid_614076 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614076 = validateParameter(valid_614076, JString, required = false,
                                 default = nil)
  if valid_614076 != nil:
    section.add "X-Amz-SignedHeaders", valid_614076
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614078: Call_SetV2LoggingLevel_614067; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the logging level.
  ## 
  let valid = call_614078.validator(path, query, header, formData, body)
  let scheme = call_614078.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614078.url(scheme.get, call_614078.host, call_614078.base,
                         call_614078.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614078, url, valid)

proc call*(call_614079: Call_SetV2LoggingLevel_614067; body: JsonNode): Recallable =
  ## setV2LoggingLevel
  ## Sets the logging level.
  ##   body: JObject (required)
  var body_614080 = newJObject()
  if body != nil:
    body_614080 = body
  result = call_614079.call(nil, nil, nil, nil, body_614080)

var setV2LoggingLevel* = Call_SetV2LoggingLevel_614067(name: "setV2LoggingLevel",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/v2LoggingLevel",
    validator: validate_SetV2LoggingLevel_614068, base: "/",
    url: url_SetV2LoggingLevel_614069, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListV2LoggingLevels_614051 = ref object of OpenApiRestCall_610658
proc url_ListV2LoggingLevels_614053(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListV2LoggingLevels_614052(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists logging levels.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token used to get the next set of results, or <b>null</b> if there are no additional results.
  ##   targetType: JString
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_614054 = query.getOrDefault("nextToken")
  valid_614054 = validateParameter(valid_614054, JString, required = false,
                                 default = nil)
  if valid_614054 != nil:
    section.add "nextToken", valid_614054
  var valid_614055 = query.getOrDefault("targetType")
  valid_614055 = validateParameter(valid_614055, JString, required = false,
                                 default = newJString("DEFAULT"))
  if valid_614055 != nil:
    section.add "targetType", valid_614055
  var valid_614056 = query.getOrDefault("maxResults")
  valid_614056 = validateParameter(valid_614056, JInt, required = false, default = nil)
  if valid_614056 != nil:
    section.add "maxResults", valid_614056
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614057 = header.getOrDefault("X-Amz-Signature")
  valid_614057 = validateParameter(valid_614057, JString, required = false,
                                 default = nil)
  if valid_614057 != nil:
    section.add "X-Amz-Signature", valid_614057
  var valid_614058 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614058 = validateParameter(valid_614058, JString, required = false,
                                 default = nil)
  if valid_614058 != nil:
    section.add "X-Amz-Content-Sha256", valid_614058
  var valid_614059 = header.getOrDefault("X-Amz-Date")
  valid_614059 = validateParameter(valid_614059, JString, required = false,
                                 default = nil)
  if valid_614059 != nil:
    section.add "X-Amz-Date", valid_614059
  var valid_614060 = header.getOrDefault("X-Amz-Credential")
  valid_614060 = validateParameter(valid_614060, JString, required = false,
                                 default = nil)
  if valid_614060 != nil:
    section.add "X-Amz-Credential", valid_614060
  var valid_614061 = header.getOrDefault("X-Amz-Security-Token")
  valid_614061 = validateParameter(valid_614061, JString, required = false,
                                 default = nil)
  if valid_614061 != nil:
    section.add "X-Amz-Security-Token", valid_614061
  var valid_614062 = header.getOrDefault("X-Amz-Algorithm")
  valid_614062 = validateParameter(valid_614062, JString, required = false,
                                 default = nil)
  if valid_614062 != nil:
    section.add "X-Amz-Algorithm", valid_614062
  var valid_614063 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614063 = validateParameter(valid_614063, JString, required = false,
                                 default = nil)
  if valid_614063 != nil:
    section.add "X-Amz-SignedHeaders", valid_614063
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614064: Call_ListV2LoggingLevels_614051; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists logging levels.
  ## 
  let valid = call_614064.validator(path, query, header, formData, body)
  let scheme = call_614064.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614064.url(scheme.get, call_614064.host, call_614064.base,
                         call_614064.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614064, url, valid)

proc call*(call_614065: Call_ListV2LoggingLevels_614051; nextToken: string = "";
          targetType: string = "DEFAULT"; maxResults: int = 0): Recallable =
  ## listV2LoggingLevels
  ## Lists logging levels.
  ##   nextToken: string
  ##            : The token used to get the next set of results, or <b>null</b> if there are no additional results.
  ##   targetType: string
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_614066 = newJObject()
  add(query_614066, "nextToken", newJString(nextToken))
  add(query_614066, "targetType", newJString(targetType))
  add(query_614066, "maxResults", newJInt(maxResults))
  result = call_614065.call(nil, query_614066, nil, nil, nil)

var listV2LoggingLevels* = Call_ListV2LoggingLevels_614051(
    name: "listV2LoggingLevels", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/v2LoggingLevel",
    validator: validate_ListV2LoggingLevels_614052, base: "/",
    url: url_ListV2LoggingLevels_614053, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListViolationEvents_614081 = ref object of OpenApiRestCall_610658
proc url_ListViolationEvents_614083(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListViolationEvents_614082(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endTime: JString (required)
  ##          : The end time for the alerts to be listed.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : The start time for the alerts to be listed.
  ##   securityProfileName: JString
  ##                      : A filter to limit results to those alerts generated by the specified security profile.
  ##   thingName: JString
  ##            : A filter to limit results to those alerts caused by the specified thing.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_614084 = query.getOrDefault("endTime")
  valid_614084 = validateParameter(valid_614084, JString, required = true,
                                 default = nil)
  if valid_614084 != nil:
    section.add "endTime", valid_614084
  var valid_614085 = query.getOrDefault("nextToken")
  valid_614085 = validateParameter(valid_614085, JString, required = false,
                                 default = nil)
  if valid_614085 != nil:
    section.add "nextToken", valid_614085
  var valid_614086 = query.getOrDefault("startTime")
  valid_614086 = validateParameter(valid_614086, JString, required = true,
                                 default = nil)
  if valid_614086 != nil:
    section.add "startTime", valid_614086
  var valid_614087 = query.getOrDefault("securityProfileName")
  valid_614087 = validateParameter(valid_614087, JString, required = false,
                                 default = nil)
  if valid_614087 != nil:
    section.add "securityProfileName", valid_614087
  var valid_614088 = query.getOrDefault("thingName")
  valid_614088 = validateParameter(valid_614088, JString, required = false,
                                 default = nil)
  if valid_614088 != nil:
    section.add "thingName", valid_614088
  var valid_614089 = query.getOrDefault("maxResults")
  valid_614089 = validateParameter(valid_614089, JInt, required = false, default = nil)
  if valid_614089 != nil:
    section.add "maxResults", valid_614089
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614090 = header.getOrDefault("X-Amz-Signature")
  valid_614090 = validateParameter(valid_614090, JString, required = false,
                                 default = nil)
  if valid_614090 != nil:
    section.add "X-Amz-Signature", valid_614090
  var valid_614091 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614091 = validateParameter(valid_614091, JString, required = false,
                                 default = nil)
  if valid_614091 != nil:
    section.add "X-Amz-Content-Sha256", valid_614091
  var valid_614092 = header.getOrDefault("X-Amz-Date")
  valid_614092 = validateParameter(valid_614092, JString, required = false,
                                 default = nil)
  if valid_614092 != nil:
    section.add "X-Amz-Date", valid_614092
  var valid_614093 = header.getOrDefault("X-Amz-Credential")
  valid_614093 = validateParameter(valid_614093, JString, required = false,
                                 default = nil)
  if valid_614093 != nil:
    section.add "X-Amz-Credential", valid_614093
  var valid_614094 = header.getOrDefault("X-Amz-Security-Token")
  valid_614094 = validateParameter(valid_614094, JString, required = false,
                                 default = nil)
  if valid_614094 != nil:
    section.add "X-Amz-Security-Token", valid_614094
  var valid_614095 = header.getOrDefault("X-Amz-Algorithm")
  valid_614095 = validateParameter(valid_614095, JString, required = false,
                                 default = nil)
  if valid_614095 != nil:
    section.add "X-Amz-Algorithm", valid_614095
  var valid_614096 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614096 = validateParameter(valid_614096, JString, required = false,
                                 default = nil)
  if valid_614096 != nil:
    section.add "X-Amz-SignedHeaders", valid_614096
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614097: Call_ListViolationEvents_614081; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ## 
  let valid = call_614097.validator(path, query, header, formData, body)
  let scheme = call_614097.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614097.url(scheme.get, call_614097.host, call_614097.base,
                         call_614097.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614097, url, valid)

proc call*(call_614098: Call_ListViolationEvents_614081; endTime: string;
          startTime: string; nextToken: string = ""; securityProfileName: string = "";
          thingName: string = ""; maxResults: int = 0): Recallable =
  ## listViolationEvents
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ##   endTime: string (required)
  ##          : The end time for the alerts to be listed.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : The start time for the alerts to be listed.
  ##   securityProfileName: string
  ##                      : A filter to limit results to those alerts generated by the specified security profile.
  ##   thingName: string
  ##            : A filter to limit results to those alerts caused by the specified thing.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_614099 = newJObject()
  add(query_614099, "endTime", newJString(endTime))
  add(query_614099, "nextToken", newJString(nextToken))
  add(query_614099, "startTime", newJString(startTime))
  add(query_614099, "securityProfileName", newJString(securityProfileName))
  add(query_614099, "thingName", newJString(thingName))
  add(query_614099, "maxResults", newJInt(maxResults))
  result = call_614098.call(nil, query_614099, nil, nil, nil)

var listViolationEvents* = Call_ListViolationEvents_614081(
    name: "listViolationEvents", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/violation-events#startTime&endTime",
    validator: validate_ListViolationEvents_614082, base: "/",
    url: url_ListViolationEvents_614083, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterCACertificate_614100 = ref object of OpenApiRestCall_610658
proc url_RegisterCACertificate_614102(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RegisterCACertificate_614101(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   allowAutoRegistration: JBool
  ##                        : Allows this CA certificate to be used for auto registration of device certificates.
  ##   setAsActive: JBool
  ##              : A boolean value that specifies if the CA certificate is set to active.
  section = newJObject()
  var valid_614103 = query.getOrDefault("allowAutoRegistration")
  valid_614103 = validateParameter(valid_614103, JBool, required = false, default = nil)
  if valid_614103 != nil:
    section.add "allowAutoRegistration", valid_614103
  var valid_614104 = query.getOrDefault("setAsActive")
  valid_614104 = validateParameter(valid_614104, JBool, required = false, default = nil)
  if valid_614104 != nil:
    section.add "setAsActive", valid_614104
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614105 = header.getOrDefault("X-Amz-Signature")
  valid_614105 = validateParameter(valid_614105, JString, required = false,
                                 default = nil)
  if valid_614105 != nil:
    section.add "X-Amz-Signature", valid_614105
  var valid_614106 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614106 = validateParameter(valid_614106, JString, required = false,
                                 default = nil)
  if valid_614106 != nil:
    section.add "X-Amz-Content-Sha256", valid_614106
  var valid_614107 = header.getOrDefault("X-Amz-Date")
  valid_614107 = validateParameter(valid_614107, JString, required = false,
                                 default = nil)
  if valid_614107 != nil:
    section.add "X-Amz-Date", valid_614107
  var valid_614108 = header.getOrDefault("X-Amz-Credential")
  valid_614108 = validateParameter(valid_614108, JString, required = false,
                                 default = nil)
  if valid_614108 != nil:
    section.add "X-Amz-Credential", valid_614108
  var valid_614109 = header.getOrDefault("X-Amz-Security-Token")
  valid_614109 = validateParameter(valid_614109, JString, required = false,
                                 default = nil)
  if valid_614109 != nil:
    section.add "X-Amz-Security-Token", valid_614109
  var valid_614110 = header.getOrDefault("X-Amz-Algorithm")
  valid_614110 = validateParameter(valid_614110, JString, required = false,
                                 default = nil)
  if valid_614110 != nil:
    section.add "X-Amz-Algorithm", valid_614110
  var valid_614111 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614111 = validateParameter(valid_614111, JString, required = false,
                                 default = nil)
  if valid_614111 != nil:
    section.add "X-Amz-SignedHeaders", valid_614111
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614113: Call_RegisterCACertificate_614100; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ## 
  let valid = call_614113.validator(path, query, header, formData, body)
  let scheme = call_614113.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614113.url(scheme.get, call_614113.host, call_614113.base,
                         call_614113.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614113, url, valid)

proc call*(call_614114: Call_RegisterCACertificate_614100; body: JsonNode;
          allowAutoRegistration: bool = false; setAsActive: bool = false): Recallable =
  ## registerCACertificate
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ##   allowAutoRegistration: bool
  ##                        : Allows this CA certificate to be used for auto registration of device certificates.
  ##   setAsActive: bool
  ##              : A boolean value that specifies if the CA certificate is set to active.
  ##   body: JObject (required)
  var query_614115 = newJObject()
  var body_614116 = newJObject()
  add(query_614115, "allowAutoRegistration", newJBool(allowAutoRegistration))
  add(query_614115, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_614116 = body
  result = call_614114.call(nil, query_614115, nil, nil, body_614116)

var registerCACertificate* = Call_RegisterCACertificate_614100(
    name: "registerCACertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/cacertificate",
    validator: validate_RegisterCACertificate_614101, base: "/",
    url: url_RegisterCACertificate_614102, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterCertificate_614117 = ref object of OpenApiRestCall_610658
proc url_RegisterCertificate_614119(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RegisterCertificate_614118(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : A boolean value that specifies if the certificate is set to active.
  section = newJObject()
  var valid_614120 = query.getOrDefault("setAsActive")
  valid_614120 = validateParameter(valid_614120, JBool, required = false, default = nil)
  if valid_614120 != nil:
    section.add "setAsActive", valid_614120
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614121 = header.getOrDefault("X-Amz-Signature")
  valid_614121 = validateParameter(valid_614121, JString, required = false,
                                 default = nil)
  if valid_614121 != nil:
    section.add "X-Amz-Signature", valid_614121
  var valid_614122 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614122 = validateParameter(valid_614122, JString, required = false,
                                 default = nil)
  if valid_614122 != nil:
    section.add "X-Amz-Content-Sha256", valid_614122
  var valid_614123 = header.getOrDefault("X-Amz-Date")
  valid_614123 = validateParameter(valid_614123, JString, required = false,
                                 default = nil)
  if valid_614123 != nil:
    section.add "X-Amz-Date", valid_614123
  var valid_614124 = header.getOrDefault("X-Amz-Credential")
  valid_614124 = validateParameter(valid_614124, JString, required = false,
                                 default = nil)
  if valid_614124 != nil:
    section.add "X-Amz-Credential", valid_614124
  var valid_614125 = header.getOrDefault("X-Amz-Security-Token")
  valid_614125 = validateParameter(valid_614125, JString, required = false,
                                 default = nil)
  if valid_614125 != nil:
    section.add "X-Amz-Security-Token", valid_614125
  var valid_614126 = header.getOrDefault("X-Amz-Algorithm")
  valid_614126 = validateParameter(valid_614126, JString, required = false,
                                 default = nil)
  if valid_614126 != nil:
    section.add "X-Amz-Algorithm", valid_614126
  var valid_614127 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614127 = validateParameter(valid_614127, JString, required = false,
                                 default = nil)
  if valid_614127 != nil:
    section.add "X-Amz-SignedHeaders", valid_614127
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614129: Call_RegisterCertificate_614117; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ## 
  let valid = call_614129.validator(path, query, header, formData, body)
  let scheme = call_614129.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614129.url(scheme.get, call_614129.host, call_614129.base,
                         call_614129.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614129, url, valid)

proc call*(call_614130: Call_RegisterCertificate_614117; body: JsonNode;
          setAsActive: bool = false): Recallable =
  ## registerCertificate
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ##   setAsActive: bool
  ##              : A boolean value that specifies if the certificate is set to active.
  ##   body: JObject (required)
  var query_614131 = newJObject()
  var body_614132 = newJObject()
  add(query_614131, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_614132 = body
  result = call_614130.call(nil, query_614131, nil, nil, body_614132)

var registerCertificate* = Call_RegisterCertificate_614117(
    name: "registerCertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/certificate/register",
    validator: validate_RegisterCertificate_614118, base: "/",
    url: url_RegisterCertificate_614119, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RejectCertificateTransfer_614133 = ref object of OpenApiRestCall_610658
proc url_RejectCertificateTransfer_614135(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/reject-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_RejectCertificateTransfer_614134(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_614136 = path.getOrDefault("certificateId")
  valid_614136 = validateParameter(valid_614136, JString, required = true,
                                 default = nil)
  if valid_614136 != nil:
    section.add "certificateId", valid_614136
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614137 = header.getOrDefault("X-Amz-Signature")
  valid_614137 = validateParameter(valid_614137, JString, required = false,
                                 default = nil)
  if valid_614137 != nil:
    section.add "X-Amz-Signature", valid_614137
  var valid_614138 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614138 = validateParameter(valid_614138, JString, required = false,
                                 default = nil)
  if valid_614138 != nil:
    section.add "X-Amz-Content-Sha256", valid_614138
  var valid_614139 = header.getOrDefault("X-Amz-Date")
  valid_614139 = validateParameter(valid_614139, JString, required = false,
                                 default = nil)
  if valid_614139 != nil:
    section.add "X-Amz-Date", valid_614139
  var valid_614140 = header.getOrDefault("X-Amz-Credential")
  valid_614140 = validateParameter(valid_614140, JString, required = false,
                                 default = nil)
  if valid_614140 != nil:
    section.add "X-Amz-Credential", valid_614140
  var valid_614141 = header.getOrDefault("X-Amz-Security-Token")
  valid_614141 = validateParameter(valid_614141, JString, required = false,
                                 default = nil)
  if valid_614141 != nil:
    section.add "X-Amz-Security-Token", valid_614141
  var valid_614142 = header.getOrDefault("X-Amz-Algorithm")
  valid_614142 = validateParameter(valid_614142, JString, required = false,
                                 default = nil)
  if valid_614142 != nil:
    section.add "X-Amz-Algorithm", valid_614142
  var valid_614143 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614143 = validateParameter(valid_614143, JString, required = false,
                                 default = nil)
  if valid_614143 != nil:
    section.add "X-Amz-SignedHeaders", valid_614143
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614145: Call_RejectCertificateTransfer_614133; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ## 
  let valid = call_614145.validator(path, query, header, formData, body)
  let scheme = call_614145.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614145.url(scheme.get, call_614145.host, call_614145.base,
                         call_614145.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614145, url, valid)

proc call*(call_614146: Call_RejectCertificateTransfer_614133; body: JsonNode;
          certificateId: string): Recallable =
  ## rejectCertificateTransfer
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ##   body: JObject (required)
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_614147 = newJObject()
  var body_614148 = newJObject()
  if body != nil:
    body_614148 = body
  add(path_614147, "certificateId", newJString(certificateId))
  result = call_614146.call(path_614147, nil, nil, nil, body_614148)

var rejectCertificateTransfer* = Call_RejectCertificateTransfer_614133(
    name: "rejectCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/reject-certificate-transfer/{certificateId}",
    validator: validate_RejectCertificateTransfer_614134, base: "/",
    url: url_RejectCertificateTransfer_614135,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveThingFromBillingGroup_614149 = ref object of OpenApiRestCall_610658
proc url_RemoveThingFromBillingGroup_614151(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RemoveThingFromBillingGroup_614150(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes the given thing from the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614152 = header.getOrDefault("X-Amz-Signature")
  valid_614152 = validateParameter(valid_614152, JString, required = false,
                                 default = nil)
  if valid_614152 != nil:
    section.add "X-Amz-Signature", valid_614152
  var valid_614153 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614153 = validateParameter(valid_614153, JString, required = false,
                                 default = nil)
  if valid_614153 != nil:
    section.add "X-Amz-Content-Sha256", valid_614153
  var valid_614154 = header.getOrDefault("X-Amz-Date")
  valid_614154 = validateParameter(valid_614154, JString, required = false,
                                 default = nil)
  if valid_614154 != nil:
    section.add "X-Amz-Date", valid_614154
  var valid_614155 = header.getOrDefault("X-Amz-Credential")
  valid_614155 = validateParameter(valid_614155, JString, required = false,
                                 default = nil)
  if valid_614155 != nil:
    section.add "X-Amz-Credential", valid_614155
  var valid_614156 = header.getOrDefault("X-Amz-Security-Token")
  valid_614156 = validateParameter(valid_614156, JString, required = false,
                                 default = nil)
  if valid_614156 != nil:
    section.add "X-Amz-Security-Token", valid_614156
  var valid_614157 = header.getOrDefault("X-Amz-Algorithm")
  valid_614157 = validateParameter(valid_614157, JString, required = false,
                                 default = nil)
  if valid_614157 != nil:
    section.add "X-Amz-Algorithm", valid_614157
  var valid_614158 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614158 = validateParameter(valid_614158, JString, required = false,
                                 default = nil)
  if valid_614158 != nil:
    section.add "X-Amz-SignedHeaders", valid_614158
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614160: Call_RemoveThingFromBillingGroup_614149; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes the given thing from the billing group.
  ## 
  let valid = call_614160.validator(path, query, header, formData, body)
  let scheme = call_614160.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614160.url(scheme.get, call_614160.host, call_614160.base,
                         call_614160.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614160, url, valid)

proc call*(call_614161: Call_RemoveThingFromBillingGroup_614149; body: JsonNode): Recallable =
  ## removeThingFromBillingGroup
  ## Removes the given thing from the billing group.
  ##   body: JObject (required)
  var body_614162 = newJObject()
  if body != nil:
    body_614162 = body
  result = call_614161.call(nil, nil, nil, nil, body_614162)

var removeThingFromBillingGroup* = Call_RemoveThingFromBillingGroup_614149(
    name: "removeThingFromBillingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/billing-groups/removeThingFromBillingGroup",
    validator: validate_RemoveThingFromBillingGroup_614150, base: "/",
    url: url_RemoveThingFromBillingGroup_614151,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveThingFromThingGroup_614163 = ref object of OpenApiRestCall_610658
proc url_RemoveThingFromThingGroup_614165(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RemoveThingFromThingGroup_614164(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove the specified thing from the specified group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614166 = header.getOrDefault("X-Amz-Signature")
  valid_614166 = validateParameter(valid_614166, JString, required = false,
                                 default = nil)
  if valid_614166 != nil:
    section.add "X-Amz-Signature", valid_614166
  var valid_614167 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614167 = validateParameter(valid_614167, JString, required = false,
                                 default = nil)
  if valid_614167 != nil:
    section.add "X-Amz-Content-Sha256", valid_614167
  var valid_614168 = header.getOrDefault("X-Amz-Date")
  valid_614168 = validateParameter(valid_614168, JString, required = false,
                                 default = nil)
  if valid_614168 != nil:
    section.add "X-Amz-Date", valid_614168
  var valid_614169 = header.getOrDefault("X-Amz-Credential")
  valid_614169 = validateParameter(valid_614169, JString, required = false,
                                 default = nil)
  if valid_614169 != nil:
    section.add "X-Amz-Credential", valid_614169
  var valid_614170 = header.getOrDefault("X-Amz-Security-Token")
  valid_614170 = validateParameter(valid_614170, JString, required = false,
                                 default = nil)
  if valid_614170 != nil:
    section.add "X-Amz-Security-Token", valid_614170
  var valid_614171 = header.getOrDefault("X-Amz-Algorithm")
  valid_614171 = validateParameter(valid_614171, JString, required = false,
                                 default = nil)
  if valid_614171 != nil:
    section.add "X-Amz-Algorithm", valid_614171
  var valid_614172 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614172 = validateParameter(valid_614172, JString, required = false,
                                 default = nil)
  if valid_614172 != nil:
    section.add "X-Amz-SignedHeaders", valid_614172
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614174: Call_RemoveThingFromThingGroup_614163; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Remove the specified thing from the specified group.
  ## 
  let valid = call_614174.validator(path, query, header, formData, body)
  let scheme = call_614174.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614174.url(scheme.get, call_614174.host, call_614174.base,
                         call_614174.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614174, url, valid)

proc call*(call_614175: Call_RemoveThingFromThingGroup_614163; body: JsonNode): Recallable =
  ## removeThingFromThingGroup
  ## Remove the specified thing from the specified group.
  ##   body: JObject (required)
  var body_614176 = newJObject()
  if body != nil:
    body_614176 = body
  result = call_614175.call(nil, nil, nil, nil, body_614176)

var removeThingFromThingGroup* = Call_RemoveThingFromThingGroup_614163(
    name: "removeThingFromThingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/removeThingFromThingGroup",
    validator: validate_RemoveThingFromThingGroup_614164, base: "/",
    url: url_RemoveThingFromThingGroup_614165,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_SearchIndex_614177 = ref object of OpenApiRestCall_610658
proc url_SearchIndex_614179(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SearchIndex_614178(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## The query search index.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614180 = header.getOrDefault("X-Amz-Signature")
  valid_614180 = validateParameter(valid_614180, JString, required = false,
                                 default = nil)
  if valid_614180 != nil:
    section.add "X-Amz-Signature", valid_614180
  var valid_614181 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614181 = validateParameter(valid_614181, JString, required = false,
                                 default = nil)
  if valid_614181 != nil:
    section.add "X-Amz-Content-Sha256", valid_614181
  var valid_614182 = header.getOrDefault("X-Amz-Date")
  valid_614182 = validateParameter(valid_614182, JString, required = false,
                                 default = nil)
  if valid_614182 != nil:
    section.add "X-Amz-Date", valid_614182
  var valid_614183 = header.getOrDefault("X-Amz-Credential")
  valid_614183 = validateParameter(valid_614183, JString, required = false,
                                 default = nil)
  if valid_614183 != nil:
    section.add "X-Amz-Credential", valid_614183
  var valid_614184 = header.getOrDefault("X-Amz-Security-Token")
  valid_614184 = validateParameter(valid_614184, JString, required = false,
                                 default = nil)
  if valid_614184 != nil:
    section.add "X-Amz-Security-Token", valid_614184
  var valid_614185 = header.getOrDefault("X-Amz-Algorithm")
  valid_614185 = validateParameter(valid_614185, JString, required = false,
                                 default = nil)
  if valid_614185 != nil:
    section.add "X-Amz-Algorithm", valid_614185
  var valid_614186 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614186 = validateParameter(valid_614186, JString, required = false,
                                 default = nil)
  if valid_614186 != nil:
    section.add "X-Amz-SignedHeaders", valid_614186
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614188: Call_SearchIndex_614177; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The query search index.
  ## 
  let valid = call_614188.validator(path, query, header, formData, body)
  let scheme = call_614188.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614188.url(scheme.get, call_614188.host, call_614188.base,
                         call_614188.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614188, url, valid)

proc call*(call_614189: Call_SearchIndex_614177; body: JsonNode): Recallable =
  ## searchIndex
  ## The query search index.
  ##   body: JObject (required)
  var body_614190 = newJObject()
  if body != nil:
    body_614190 = body
  result = call_614189.call(nil, nil, nil, nil, body_614190)

var searchIndex* = Call_SearchIndex_614177(name: "searchIndex",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com",
                                        route: "/indices/search",
                                        validator: validate_SearchIndex_614178,
                                        base: "/", url: url_SearchIndex_614179,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartOnDemandAuditTask_614191 = ref object of OpenApiRestCall_610658
proc url_StartOnDemandAuditTask_614193(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_StartOnDemandAuditTask_614192(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts an on-demand Device Defender audit.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614194 = header.getOrDefault("X-Amz-Signature")
  valid_614194 = validateParameter(valid_614194, JString, required = false,
                                 default = nil)
  if valid_614194 != nil:
    section.add "X-Amz-Signature", valid_614194
  var valid_614195 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614195 = validateParameter(valid_614195, JString, required = false,
                                 default = nil)
  if valid_614195 != nil:
    section.add "X-Amz-Content-Sha256", valid_614195
  var valid_614196 = header.getOrDefault("X-Amz-Date")
  valid_614196 = validateParameter(valid_614196, JString, required = false,
                                 default = nil)
  if valid_614196 != nil:
    section.add "X-Amz-Date", valid_614196
  var valid_614197 = header.getOrDefault("X-Amz-Credential")
  valid_614197 = validateParameter(valid_614197, JString, required = false,
                                 default = nil)
  if valid_614197 != nil:
    section.add "X-Amz-Credential", valid_614197
  var valid_614198 = header.getOrDefault("X-Amz-Security-Token")
  valid_614198 = validateParameter(valid_614198, JString, required = false,
                                 default = nil)
  if valid_614198 != nil:
    section.add "X-Amz-Security-Token", valid_614198
  var valid_614199 = header.getOrDefault("X-Amz-Algorithm")
  valid_614199 = validateParameter(valid_614199, JString, required = false,
                                 default = nil)
  if valid_614199 != nil:
    section.add "X-Amz-Algorithm", valid_614199
  var valid_614200 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614200 = validateParameter(valid_614200, JString, required = false,
                                 default = nil)
  if valid_614200 != nil:
    section.add "X-Amz-SignedHeaders", valid_614200
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614202: Call_StartOnDemandAuditTask_614191; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts an on-demand Device Defender audit.
  ## 
  let valid = call_614202.validator(path, query, header, formData, body)
  let scheme = call_614202.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614202.url(scheme.get, call_614202.host, call_614202.base,
                         call_614202.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614202, url, valid)

proc call*(call_614203: Call_StartOnDemandAuditTask_614191; body: JsonNode): Recallable =
  ## startOnDemandAuditTask
  ## Starts an on-demand Device Defender audit.
  ##   body: JObject (required)
  var body_614204 = newJObject()
  if body != nil:
    body_614204 = body
  result = call_614203.call(nil, nil, nil, nil, body_614204)

var startOnDemandAuditTask* = Call_StartOnDemandAuditTask_614191(
    name: "startOnDemandAuditTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/audit/tasks",
    validator: validate_StartOnDemandAuditTask_614192, base: "/",
    url: url_StartOnDemandAuditTask_614193, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StopThingRegistrationTask_614205 = ref object of OpenApiRestCall_610658
proc url_StopThingRegistrationTask_614207(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_StopThingRegistrationTask_614206(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The bulk thing provisioning task ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_614208 = path.getOrDefault("taskId")
  valid_614208 = validateParameter(valid_614208, JString, required = true,
                                 default = nil)
  if valid_614208 != nil:
    section.add "taskId", valid_614208
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614209 = header.getOrDefault("X-Amz-Signature")
  valid_614209 = validateParameter(valid_614209, JString, required = false,
                                 default = nil)
  if valid_614209 != nil:
    section.add "X-Amz-Signature", valid_614209
  var valid_614210 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614210 = validateParameter(valid_614210, JString, required = false,
                                 default = nil)
  if valid_614210 != nil:
    section.add "X-Amz-Content-Sha256", valid_614210
  var valid_614211 = header.getOrDefault("X-Amz-Date")
  valid_614211 = validateParameter(valid_614211, JString, required = false,
                                 default = nil)
  if valid_614211 != nil:
    section.add "X-Amz-Date", valid_614211
  var valid_614212 = header.getOrDefault("X-Amz-Credential")
  valid_614212 = validateParameter(valid_614212, JString, required = false,
                                 default = nil)
  if valid_614212 != nil:
    section.add "X-Amz-Credential", valid_614212
  var valid_614213 = header.getOrDefault("X-Amz-Security-Token")
  valid_614213 = validateParameter(valid_614213, JString, required = false,
                                 default = nil)
  if valid_614213 != nil:
    section.add "X-Amz-Security-Token", valid_614213
  var valid_614214 = header.getOrDefault("X-Amz-Algorithm")
  valid_614214 = validateParameter(valid_614214, JString, required = false,
                                 default = nil)
  if valid_614214 != nil:
    section.add "X-Amz-Algorithm", valid_614214
  var valid_614215 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614215 = validateParameter(valid_614215, JString, required = false,
                                 default = nil)
  if valid_614215 != nil:
    section.add "X-Amz-SignedHeaders", valid_614215
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614216: Call_StopThingRegistrationTask_614205; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a bulk thing provisioning task.
  ## 
  let valid = call_614216.validator(path, query, header, formData, body)
  let scheme = call_614216.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614216.url(scheme.get, call_614216.host, call_614216.base,
                         call_614216.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614216, url, valid)

proc call*(call_614217: Call_StopThingRegistrationTask_614205; taskId: string): Recallable =
  ## stopThingRegistrationTask
  ## Cancels a bulk thing provisioning task.
  ##   taskId: string (required)
  ##         : The bulk thing provisioning task ID.
  var path_614218 = newJObject()
  add(path_614218, "taskId", newJString(taskId))
  result = call_614217.call(path_614218, nil, nil, nil, nil)

var stopThingRegistrationTask* = Call_StopThingRegistrationTask_614205(
    name: "stopThingRegistrationTask", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks/{taskId}/cancel",
    validator: validate_StopThingRegistrationTask_614206, base: "/",
    url: url_StopThingRegistrationTask_614207,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_TagResource_614219 = ref object of OpenApiRestCall_610658
proc url_TagResource_614221(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_TagResource_614220(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614222 = header.getOrDefault("X-Amz-Signature")
  valid_614222 = validateParameter(valid_614222, JString, required = false,
                                 default = nil)
  if valid_614222 != nil:
    section.add "X-Amz-Signature", valid_614222
  var valid_614223 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614223 = validateParameter(valid_614223, JString, required = false,
                                 default = nil)
  if valid_614223 != nil:
    section.add "X-Amz-Content-Sha256", valid_614223
  var valid_614224 = header.getOrDefault("X-Amz-Date")
  valid_614224 = validateParameter(valid_614224, JString, required = false,
                                 default = nil)
  if valid_614224 != nil:
    section.add "X-Amz-Date", valid_614224
  var valid_614225 = header.getOrDefault("X-Amz-Credential")
  valid_614225 = validateParameter(valid_614225, JString, required = false,
                                 default = nil)
  if valid_614225 != nil:
    section.add "X-Amz-Credential", valid_614225
  var valid_614226 = header.getOrDefault("X-Amz-Security-Token")
  valid_614226 = validateParameter(valid_614226, JString, required = false,
                                 default = nil)
  if valid_614226 != nil:
    section.add "X-Amz-Security-Token", valid_614226
  var valid_614227 = header.getOrDefault("X-Amz-Algorithm")
  valid_614227 = validateParameter(valid_614227, JString, required = false,
                                 default = nil)
  if valid_614227 != nil:
    section.add "X-Amz-Algorithm", valid_614227
  var valid_614228 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614228 = validateParameter(valid_614228, JString, required = false,
                                 default = nil)
  if valid_614228 != nil:
    section.add "X-Amz-SignedHeaders", valid_614228
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614230: Call_TagResource_614219; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ## 
  let valid = call_614230.validator(path, query, header, formData, body)
  let scheme = call_614230.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614230.url(scheme.get, call_614230.host, call_614230.base,
                         call_614230.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614230, url, valid)

proc call*(call_614231: Call_TagResource_614219; body: JsonNode): Recallable =
  ## tagResource
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ##   body: JObject (required)
  var body_614232 = newJObject()
  if body != nil:
    body_614232 = body
  result = call_614231.call(nil, nil, nil, nil, body_614232)

var tagResource* = Call_TagResource_614219(name: "tagResource",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com", route: "/tags",
                                        validator: validate_TagResource_614220,
                                        base: "/", url: url_TagResource_614221,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_TestAuthorization_614233 = ref object of OpenApiRestCall_610658
proc url_TestAuthorization_614235(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_TestAuthorization_614234(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   clientId: JString
  ##           : The MQTT client ID.
  section = newJObject()
  var valid_614236 = query.getOrDefault("clientId")
  valid_614236 = validateParameter(valid_614236, JString, required = false,
                                 default = nil)
  if valid_614236 != nil:
    section.add "clientId", valid_614236
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614237 = header.getOrDefault("X-Amz-Signature")
  valid_614237 = validateParameter(valid_614237, JString, required = false,
                                 default = nil)
  if valid_614237 != nil:
    section.add "X-Amz-Signature", valid_614237
  var valid_614238 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614238 = validateParameter(valid_614238, JString, required = false,
                                 default = nil)
  if valid_614238 != nil:
    section.add "X-Amz-Content-Sha256", valid_614238
  var valid_614239 = header.getOrDefault("X-Amz-Date")
  valid_614239 = validateParameter(valid_614239, JString, required = false,
                                 default = nil)
  if valid_614239 != nil:
    section.add "X-Amz-Date", valid_614239
  var valid_614240 = header.getOrDefault("X-Amz-Credential")
  valid_614240 = validateParameter(valid_614240, JString, required = false,
                                 default = nil)
  if valid_614240 != nil:
    section.add "X-Amz-Credential", valid_614240
  var valid_614241 = header.getOrDefault("X-Amz-Security-Token")
  valid_614241 = validateParameter(valid_614241, JString, required = false,
                                 default = nil)
  if valid_614241 != nil:
    section.add "X-Amz-Security-Token", valid_614241
  var valid_614242 = header.getOrDefault("X-Amz-Algorithm")
  valid_614242 = validateParameter(valid_614242, JString, required = false,
                                 default = nil)
  if valid_614242 != nil:
    section.add "X-Amz-Algorithm", valid_614242
  var valid_614243 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614243 = validateParameter(valid_614243, JString, required = false,
                                 default = nil)
  if valid_614243 != nil:
    section.add "X-Amz-SignedHeaders", valid_614243
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614245: Call_TestAuthorization_614233; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  let valid = call_614245.validator(path, query, header, formData, body)
  let scheme = call_614245.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614245.url(scheme.get, call_614245.host, call_614245.base,
                         call_614245.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614245, url, valid)

proc call*(call_614246: Call_TestAuthorization_614233; body: JsonNode;
          clientId: string = ""): Recallable =
  ## testAuthorization
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ##   clientId: string
  ##           : The MQTT client ID.
  ##   body: JObject (required)
  var query_614247 = newJObject()
  var body_614248 = newJObject()
  add(query_614247, "clientId", newJString(clientId))
  if body != nil:
    body_614248 = body
  result = call_614246.call(nil, query_614247, nil, nil, body_614248)

var testAuthorization* = Call_TestAuthorization_614233(name: "testAuthorization",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/test-authorization", validator: validate_TestAuthorization_614234,
    base: "/", url: url_TestAuthorization_614235,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_TestInvokeAuthorizer_614249 = ref object of OpenApiRestCall_610658
proc url_TestInvokeAuthorizer_614251(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName"),
               (kind: ConstantSegment, value: "/test")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_TestInvokeAuthorizer_614250(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The custom authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_614252 = path.getOrDefault("authorizerName")
  valid_614252 = validateParameter(valid_614252, JString, required = true,
                                 default = nil)
  if valid_614252 != nil:
    section.add "authorizerName", valid_614252
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614253 = header.getOrDefault("X-Amz-Signature")
  valid_614253 = validateParameter(valid_614253, JString, required = false,
                                 default = nil)
  if valid_614253 != nil:
    section.add "X-Amz-Signature", valid_614253
  var valid_614254 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614254 = validateParameter(valid_614254, JString, required = false,
                                 default = nil)
  if valid_614254 != nil:
    section.add "X-Amz-Content-Sha256", valid_614254
  var valid_614255 = header.getOrDefault("X-Amz-Date")
  valid_614255 = validateParameter(valid_614255, JString, required = false,
                                 default = nil)
  if valid_614255 != nil:
    section.add "X-Amz-Date", valid_614255
  var valid_614256 = header.getOrDefault("X-Amz-Credential")
  valid_614256 = validateParameter(valid_614256, JString, required = false,
                                 default = nil)
  if valid_614256 != nil:
    section.add "X-Amz-Credential", valid_614256
  var valid_614257 = header.getOrDefault("X-Amz-Security-Token")
  valid_614257 = validateParameter(valid_614257, JString, required = false,
                                 default = nil)
  if valid_614257 != nil:
    section.add "X-Amz-Security-Token", valid_614257
  var valid_614258 = header.getOrDefault("X-Amz-Algorithm")
  valid_614258 = validateParameter(valid_614258, JString, required = false,
                                 default = nil)
  if valid_614258 != nil:
    section.add "X-Amz-Algorithm", valid_614258
  var valid_614259 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614259 = validateParameter(valid_614259, JString, required = false,
                                 default = nil)
  if valid_614259 != nil:
    section.add "X-Amz-SignedHeaders", valid_614259
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614261: Call_TestInvokeAuthorizer_614249; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  let valid = call_614261.validator(path, query, header, formData, body)
  let scheme = call_614261.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614261.url(scheme.get, call_614261.host, call_614261.base,
                         call_614261.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614261, url, valid)

proc call*(call_614262: Call_TestInvokeAuthorizer_614249; authorizerName: string;
          body: JsonNode): Recallable =
  ## testInvokeAuthorizer
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ##   authorizerName: string (required)
  ##                 : The custom authorizer name.
  ##   body: JObject (required)
  var path_614263 = newJObject()
  var body_614264 = newJObject()
  add(path_614263, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_614264 = body
  result = call_614262.call(path_614263, nil, nil, nil, body_614264)

var testInvokeAuthorizer* = Call_TestInvokeAuthorizer_614249(
    name: "testInvokeAuthorizer", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/authorizer/{authorizerName}/test",
    validator: validate_TestInvokeAuthorizer_614250, base: "/",
    url: url_TestInvokeAuthorizer_614251, schemes: {Scheme.Https, Scheme.Http})
type
  Call_TransferCertificate_614265 = ref object of OpenApiRestCall_610658
proc url_TransferCertificate_614267(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/transfer-certificate/"),
               (kind: VariableSegment, value: "certificateId"),
               (kind: ConstantSegment, value: "#targetAwsAccount")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_TransferCertificate_614266(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_614268 = path.getOrDefault("certificateId")
  valid_614268 = validateParameter(valid_614268, JString, required = true,
                                 default = nil)
  if valid_614268 != nil:
    section.add "certificateId", valid_614268
  result.add "path", section
  ## parameters in `query` object:
  ##   targetAwsAccount: JString (required)
  ##                   : The AWS account.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `targetAwsAccount` field"
  var valid_614269 = query.getOrDefault("targetAwsAccount")
  valid_614269 = validateParameter(valid_614269, JString, required = true,
                                 default = nil)
  if valid_614269 != nil:
    section.add "targetAwsAccount", valid_614269
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614270 = header.getOrDefault("X-Amz-Signature")
  valid_614270 = validateParameter(valid_614270, JString, required = false,
                                 default = nil)
  if valid_614270 != nil:
    section.add "X-Amz-Signature", valid_614270
  var valid_614271 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614271 = validateParameter(valid_614271, JString, required = false,
                                 default = nil)
  if valid_614271 != nil:
    section.add "X-Amz-Content-Sha256", valid_614271
  var valid_614272 = header.getOrDefault("X-Amz-Date")
  valid_614272 = validateParameter(valid_614272, JString, required = false,
                                 default = nil)
  if valid_614272 != nil:
    section.add "X-Amz-Date", valid_614272
  var valid_614273 = header.getOrDefault("X-Amz-Credential")
  valid_614273 = validateParameter(valid_614273, JString, required = false,
                                 default = nil)
  if valid_614273 != nil:
    section.add "X-Amz-Credential", valid_614273
  var valid_614274 = header.getOrDefault("X-Amz-Security-Token")
  valid_614274 = validateParameter(valid_614274, JString, required = false,
                                 default = nil)
  if valid_614274 != nil:
    section.add "X-Amz-Security-Token", valid_614274
  var valid_614275 = header.getOrDefault("X-Amz-Algorithm")
  valid_614275 = validateParameter(valid_614275, JString, required = false,
                                 default = nil)
  if valid_614275 != nil:
    section.add "X-Amz-Algorithm", valid_614275
  var valid_614276 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614276 = validateParameter(valid_614276, JString, required = false,
                                 default = nil)
  if valid_614276 != nil:
    section.add "X-Amz-SignedHeaders", valid_614276
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614278: Call_TransferCertificate_614265; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ## 
  let valid = call_614278.validator(path, query, header, formData, body)
  let scheme = call_614278.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614278.url(scheme.get, call_614278.host, call_614278.base,
                         call_614278.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614278, url, valid)

proc call*(call_614279: Call_TransferCertificate_614265; body: JsonNode;
          certificateId: string; targetAwsAccount: string): Recallable =
  ## transferCertificate
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ##   body: JObject (required)
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   targetAwsAccount: string (required)
  ##                   : The AWS account.
  var path_614280 = newJObject()
  var query_614281 = newJObject()
  var body_614282 = newJObject()
  if body != nil:
    body_614282 = body
  add(path_614280, "certificateId", newJString(certificateId))
  add(query_614281, "targetAwsAccount", newJString(targetAwsAccount))
  result = call_614279.call(path_614280, query_614281, nil, nil, body_614282)

var transferCertificate* = Call_TransferCertificate_614265(
    name: "transferCertificate", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/transfer-certificate/{certificateId}#targetAwsAccount",
    validator: validate_TransferCertificate_614266, base: "/",
    url: url_TransferCertificate_614267, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UntagResource_614283 = ref object of OpenApiRestCall_610658
proc url_UntagResource_614285(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UntagResource_614284(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes the given tags (metadata) from the resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614286 = header.getOrDefault("X-Amz-Signature")
  valid_614286 = validateParameter(valid_614286, JString, required = false,
                                 default = nil)
  if valid_614286 != nil:
    section.add "X-Amz-Signature", valid_614286
  var valid_614287 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614287 = validateParameter(valid_614287, JString, required = false,
                                 default = nil)
  if valid_614287 != nil:
    section.add "X-Amz-Content-Sha256", valid_614287
  var valid_614288 = header.getOrDefault("X-Amz-Date")
  valid_614288 = validateParameter(valid_614288, JString, required = false,
                                 default = nil)
  if valid_614288 != nil:
    section.add "X-Amz-Date", valid_614288
  var valid_614289 = header.getOrDefault("X-Amz-Credential")
  valid_614289 = validateParameter(valid_614289, JString, required = false,
                                 default = nil)
  if valid_614289 != nil:
    section.add "X-Amz-Credential", valid_614289
  var valid_614290 = header.getOrDefault("X-Amz-Security-Token")
  valid_614290 = validateParameter(valid_614290, JString, required = false,
                                 default = nil)
  if valid_614290 != nil:
    section.add "X-Amz-Security-Token", valid_614290
  var valid_614291 = header.getOrDefault("X-Amz-Algorithm")
  valid_614291 = validateParameter(valid_614291, JString, required = false,
                                 default = nil)
  if valid_614291 != nil:
    section.add "X-Amz-Algorithm", valid_614291
  var valid_614292 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614292 = validateParameter(valid_614292, JString, required = false,
                                 default = nil)
  if valid_614292 != nil:
    section.add "X-Amz-SignedHeaders", valid_614292
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614294: Call_UntagResource_614283; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes the given tags (metadata) from the resource.
  ## 
  let valid = call_614294.validator(path, query, header, formData, body)
  let scheme = call_614294.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614294.url(scheme.get, call_614294.host, call_614294.base,
                         call_614294.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614294, url, valid)

proc call*(call_614295: Call_UntagResource_614283; body: JsonNode): Recallable =
  ## untagResource
  ## Removes the given tags (metadata) from the resource.
  ##   body: JObject (required)
  var body_614296 = newJObject()
  if body != nil:
    body_614296 = body
  result = call_614295.call(nil, nil, nil, nil, body_614296)

var untagResource* = Call_UntagResource_614283(name: "untagResource",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/untag",
    validator: validate_UntagResource_614284, base: "/", url: url_UntagResource_614285,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateCertificate_614297 = ref object of OpenApiRestCall_610658
proc url_UpdateCertificate_614299(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId"),
               (kind: ConstantSegment, value: "#newStatus")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateCertificate_614298(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_614300 = path.getOrDefault("certificateId")
  valid_614300 = validateParameter(valid_614300, JString, required = true,
                                 default = nil)
  if valid_614300 != nil:
    section.add "certificateId", valid_614300
  result.add "path", section
  ## parameters in `query` object:
  ##   newStatus: JString (required)
  ##            : <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  section = newJObject()
  var valid_614301 = query.getOrDefault("newStatus")
  valid_614301 = validateParameter(valid_614301, JString, required = true,
                                 default = newJString("ACTIVE"))
  if valid_614301 != nil:
    section.add "newStatus", valid_614301
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614302 = header.getOrDefault("X-Amz-Signature")
  valid_614302 = validateParameter(valid_614302, JString, required = false,
                                 default = nil)
  if valid_614302 != nil:
    section.add "X-Amz-Signature", valid_614302
  var valid_614303 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614303 = validateParameter(valid_614303, JString, required = false,
                                 default = nil)
  if valid_614303 != nil:
    section.add "X-Amz-Content-Sha256", valid_614303
  var valid_614304 = header.getOrDefault("X-Amz-Date")
  valid_614304 = validateParameter(valid_614304, JString, required = false,
                                 default = nil)
  if valid_614304 != nil:
    section.add "X-Amz-Date", valid_614304
  var valid_614305 = header.getOrDefault("X-Amz-Credential")
  valid_614305 = validateParameter(valid_614305, JString, required = false,
                                 default = nil)
  if valid_614305 != nil:
    section.add "X-Amz-Credential", valid_614305
  var valid_614306 = header.getOrDefault("X-Amz-Security-Token")
  valid_614306 = validateParameter(valid_614306, JString, required = false,
                                 default = nil)
  if valid_614306 != nil:
    section.add "X-Amz-Security-Token", valid_614306
  var valid_614307 = header.getOrDefault("X-Amz-Algorithm")
  valid_614307 = validateParameter(valid_614307, JString, required = false,
                                 default = nil)
  if valid_614307 != nil:
    section.add "X-Amz-Algorithm", valid_614307
  var valid_614308 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614308 = validateParameter(valid_614308, JString, required = false,
                                 default = nil)
  if valid_614308 != nil:
    section.add "X-Amz-SignedHeaders", valid_614308
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_614309: Call_UpdateCertificate_614297; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ## 
  let valid = call_614309.validator(path, query, header, formData, body)
  let scheme = call_614309.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614309.url(scheme.get, call_614309.host, call_614309.base,
                         call_614309.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614309, url, valid)

proc call*(call_614310: Call_UpdateCertificate_614297; certificateId: string;
          newStatus: string = "ACTIVE"): Recallable =
  ## updateCertificate
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ##   newStatus: string (required)
  ##            : <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_614311 = newJObject()
  var query_614312 = newJObject()
  add(query_614312, "newStatus", newJString(newStatus))
  add(path_614311, "certificateId", newJString(certificateId))
  result = call_614310.call(path_614311, query_614312, nil, nil, nil)

var updateCertificate* = Call_UpdateCertificate_614297(name: "updateCertificate",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/certificates/{certificateId}#newStatus",
    validator: validate_UpdateCertificate_614298, base: "/",
    url: url_UpdateCertificate_614299, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThingGroupsForThing_614313 = ref object of OpenApiRestCall_610658
proc url_UpdateThingGroupsForThing_614315(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateThingGroupsForThing_614314(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the groups to which the thing belongs.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614316 = header.getOrDefault("X-Amz-Signature")
  valid_614316 = validateParameter(valid_614316, JString, required = false,
                                 default = nil)
  if valid_614316 != nil:
    section.add "X-Amz-Signature", valid_614316
  var valid_614317 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614317 = validateParameter(valid_614317, JString, required = false,
                                 default = nil)
  if valid_614317 != nil:
    section.add "X-Amz-Content-Sha256", valid_614317
  var valid_614318 = header.getOrDefault("X-Amz-Date")
  valid_614318 = validateParameter(valid_614318, JString, required = false,
                                 default = nil)
  if valid_614318 != nil:
    section.add "X-Amz-Date", valid_614318
  var valid_614319 = header.getOrDefault("X-Amz-Credential")
  valid_614319 = validateParameter(valid_614319, JString, required = false,
                                 default = nil)
  if valid_614319 != nil:
    section.add "X-Amz-Credential", valid_614319
  var valid_614320 = header.getOrDefault("X-Amz-Security-Token")
  valid_614320 = validateParameter(valid_614320, JString, required = false,
                                 default = nil)
  if valid_614320 != nil:
    section.add "X-Amz-Security-Token", valid_614320
  var valid_614321 = header.getOrDefault("X-Amz-Algorithm")
  valid_614321 = validateParameter(valid_614321, JString, required = false,
                                 default = nil)
  if valid_614321 != nil:
    section.add "X-Amz-Algorithm", valid_614321
  var valid_614322 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614322 = validateParameter(valid_614322, JString, required = false,
                                 default = nil)
  if valid_614322 != nil:
    section.add "X-Amz-SignedHeaders", valid_614322
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614324: Call_UpdateThingGroupsForThing_614313; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the groups to which the thing belongs.
  ## 
  let valid = call_614324.validator(path, query, header, formData, body)
  let scheme = call_614324.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614324.url(scheme.get, call_614324.host, call_614324.base,
                         call_614324.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614324, url, valid)

proc call*(call_614325: Call_UpdateThingGroupsForThing_614313; body: JsonNode): Recallable =
  ## updateThingGroupsForThing
  ## Updates the groups to which the thing belongs.
  ##   body: JObject (required)
  var body_614326 = newJObject()
  if body != nil:
    body_614326 = body
  result = call_614325.call(nil, nil, nil, nil, body_614326)

var updateThingGroupsForThing* = Call_UpdateThingGroupsForThing_614313(
    name: "updateThingGroupsForThing", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/updateThingGroupsForThing",
    validator: validate_UpdateThingGroupsForThing_614314, base: "/",
    url: url_UpdateThingGroupsForThing_614315,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ValidateSecurityProfileBehaviors_614327 = ref object of OpenApiRestCall_610658
proc url_ValidateSecurityProfileBehaviors_614329(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ValidateSecurityProfileBehaviors_614328(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validates a Device Defender security profile behaviors specification.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_614330 = header.getOrDefault("X-Amz-Signature")
  valid_614330 = validateParameter(valid_614330, JString, required = false,
                                 default = nil)
  if valid_614330 != nil:
    section.add "X-Amz-Signature", valid_614330
  var valid_614331 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_614331 = validateParameter(valid_614331, JString, required = false,
                                 default = nil)
  if valid_614331 != nil:
    section.add "X-Amz-Content-Sha256", valid_614331
  var valid_614332 = header.getOrDefault("X-Amz-Date")
  valid_614332 = validateParameter(valid_614332, JString, required = false,
                                 default = nil)
  if valid_614332 != nil:
    section.add "X-Amz-Date", valid_614332
  var valid_614333 = header.getOrDefault("X-Amz-Credential")
  valid_614333 = validateParameter(valid_614333, JString, required = false,
                                 default = nil)
  if valid_614333 != nil:
    section.add "X-Amz-Credential", valid_614333
  var valid_614334 = header.getOrDefault("X-Amz-Security-Token")
  valid_614334 = validateParameter(valid_614334, JString, required = false,
                                 default = nil)
  if valid_614334 != nil:
    section.add "X-Amz-Security-Token", valid_614334
  var valid_614335 = header.getOrDefault("X-Amz-Algorithm")
  valid_614335 = validateParameter(valid_614335, JString, required = false,
                                 default = nil)
  if valid_614335 != nil:
    section.add "X-Amz-Algorithm", valid_614335
  var valid_614336 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_614336 = validateParameter(valid_614336, JString, required = false,
                                 default = nil)
  if valid_614336 != nil:
    section.add "X-Amz-SignedHeaders", valid_614336
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_614338: Call_ValidateSecurityProfileBehaviors_614327;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Validates a Device Defender security profile behaviors specification.
  ## 
  let valid = call_614338.validator(path, query, header, formData, body)
  let scheme = call_614338.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_614338.url(scheme.get, call_614338.host, call_614338.base,
                         call_614338.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_614338, url, valid)

proc call*(call_614339: Call_ValidateSecurityProfileBehaviors_614327;
          body: JsonNode): Recallable =
  ## validateSecurityProfileBehaviors
  ## Validates a Device Defender security profile behaviors specification.
  ##   body: JObject (required)
  var body_614340 = newJObject()
  if body != nil:
    body_614340 = body
  result = call_614339.call(nil, nil, nil, nil, body_614340)

var validateSecurityProfileBehaviors* = Call_ValidateSecurityProfileBehaviors_614327(
    name: "validateSecurityProfileBehaviors", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/security-profile-behaviors/validate",
    validator: validate_ValidateSecurityProfileBehaviors_614328, base: "/",
    url: url_ValidateSecurityProfileBehaviors_614329,
    schemes: {Scheme.Https, Scheme.Http})
export
  rest

type
  EnvKind = enum
    BakeIntoBinary = "Baking $1 into the binary",
    FetchFromEnv = "Fetch $1 from the environment"
template sloppyConst(via: EnvKind; name: untyped): untyped =
  import
    macros

  const
    name {.strdefine.}: string = case via
    of BakeIntoBinary:
      getEnv(astToStr(name), "")
    of FetchFromEnv:
      ""
  static :
    let msg = block:
      if name == "":
        "Missing $1 in the environment"
      else:
        $via
    warning msg % [astToStr(name)]

sloppyConst FetchFromEnv, AWS_ACCESS_KEY_ID
sloppyConst FetchFromEnv, AWS_SECRET_ACCESS_KEY
sloppyConst BakeIntoBinary, AWS_REGION
sloppyConst FetchFromEnv, AWS_ACCOUNT_ID
proc atozSign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", AWS_ACCESS_KEY_ID)
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", AWS_SECRET_ACCESS_KEY)
    region = os.getEnv("AWS_REGION", AWS_REGION)
  assert secret != "", "need $AWS_SECRET_ACCESS_KEY in environment"
  assert access != "", "need $AWS_ACCESS_KEY_ID in environment"
  assert region != "", "need $AWS_REGION in environment"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  recall.headers.del "Host"
  recall.url = $url

type
  XAmz = enum
    SecurityToken = "X-Amz-Security-Token", ContentSha256 = "X-Amz-Content-Sha256"
method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  ## the hook is a terrible earworm
  var headers = newHttpHeaders(massageHeaders(input.getOrDefault("header")))
  let
    body = input.getOrDefault("body")
    text = if body == nil:
      "" elif body.kind == JString:
      body.getStr else:
      $body
  if body != nil and body.kind != JString:
    if not headers.hasKey("content-type"):
      headers["content-type"] = "application/x-amz-json-1.0"
  if not headers.hasKey($SecurityToken):
    let session = getEnv("AWS_SESSION_TOKEN", "")
    if session != "":
      headers[$SecurityToken] = session
  headers[$ContentSha256] = hash(text, SHA256)
  result = newRecallable(call, url, headers, text)
  result.atozSign(input.getOrDefault("query"), SHA256)
