
import
  json, options, hashes, uri, tables, rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: AWS IoT
## version: 2015-05-28
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>AWS IoT</fullname> <p>AWS IoT provides secure, bi-directional communication between Internet-connected devices (such as sensors, actuators, embedded devices, or smart appliances) and the AWS cloud. You can discover your custom IoT-Data endpoint to communicate with, configure rules for data processing and integration with other services, organize resources associated with each device (Registry), configure logging, and create and manage policies and credentials to authenticate devices.</p> <p>For more information about how AWS IoT works, see the <a href="https://docs.aws.amazon.com/iot/latest/developerguide/aws-iot-how-it-works.html">Developer Guide</a>.</p> <p>For information about how to use the credentials provider for AWS IoT, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorizing-direct-aws.html">Authorizing Direct Calls to AWS Services</a>.</p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/iot/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_602466 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_602466](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_602466): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    if js.kind notin {JString, JInt, JFloat, JNull, JBool}:
      return
    head = $js
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "iot.ap-northeast-1.amazonaws.com", "ap-southeast-1": "iot.ap-southeast-1.amazonaws.com",
                           "us-west-2": "iot.us-west-2.amazonaws.com",
                           "eu-west-2": "iot.eu-west-2.amazonaws.com", "ap-northeast-3": "iot.ap-northeast-3.amazonaws.com",
                           "eu-central-1": "iot.eu-central-1.amazonaws.com",
                           "us-east-2": "iot.us-east-2.amazonaws.com",
                           "us-east-1": "iot.us-east-1.amazonaws.com", "cn-northwest-1": "iot.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "iot.ap-south-1.amazonaws.com",
                           "eu-north-1": "iot.eu-north-1.amazonaws.com", "ap-northeast-2": "iot.ap-northeast-2.amazonaws.com",
                           "us-west-1": "iot.us-west-1.amazonaws.com",
                           "us-gov-east-1": "iot.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "iot.eu-west-3.amazonaws.com",
                           "cn-north-1": "iot.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "iot.sa-east-1.amazonaws.com",
                           "eu-west-1": "iot.eu-west-1.amazonaws.com",
                           "us-gov-west-1": "iot.us-gov-west-1.amazonaws.com", "ap-southeast-2": "iot.ap-southeast-2.amazonaws.com",
                           "ca-central-1": "iot.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "iot.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "iot.ap-southeast-1.amazonaws.com",
      "us-west-2": "iot.us-west-2.amazonaws.com",
      "eu-west-2": "iot.eu-west-2.amazonaws.com",
      "ap-northeast-3": "iot.ap-northeast-3.amazonaws.com",
      "eu-central-1": "iot.eu-central-1.amazonaws.com",
      "us-east-2": "iot.us-east-2.amazonaws.com",
      "us-east-1": "iot.us-east-1.amazonaws.com",
      "cn-northwest-1": "iot.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "iot.ap-south-1.amazonaws.com",
      "eu-north-1": "iot.eu-north-1.amazonaws.com",
      "ap-northeast-2": "iot.ap-northeast-2.amazonaws.com",
      "us-west-1": "iot.us-west-1.amazonaws.com",
      "us-gov-east-1": "iot.us-gov-east-1.amazonaws.com",
      "eu-west-3": "iot.eu-west-3.amazonaws.com",
      "cn-north-1": "iot.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "iot.sa-east-1.amazonaws.com",
      "eu-west-1": "iot.eu-west-1.amazonaws.com",
      "us-gov-west-1": "iot.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "iot.ap-southeast-2.amazonaws.com",
      "ca-central-1": "iot.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "iot"
method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_AcceptCertificateTransfer_602803 = ref object of OpenApiRestCall_602466
proc url_AcceptCertificateTransfer_602805(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/accept-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_AcceptCertificateTransfer_602804(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_602931 = path.getOrDefault("certificateId")
  valid_602931 = validateParameter(valid_602931, JString, required = true,
                                 default = nil)
  if valid_602931 != nil:
    section.add "certificateId", valid_602931
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_602932 = query.getOrDefault("setAsActive")
  valid_602932 = validateParameter(valid_602932, JBool, required = false, default = nil)
  if valid_602932 != nil:
    section.add "setAsActive", valid_602932
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602933 = header.getOrDefault("X-Amz-Date")
  valid_602933 = validateParameter(valid_602933, JString, required = false,
                                 default = nil)
  if valid_602933 != nil:
    section.add "X-Amz-Date", valid_602933
  var valid_602934 = header.getOrDefault("X-Amz-Security-Token")
  valid_602934 = validateParameter(valid_602934, JString, required = false,
                                 default = nil)
  if valid_602934 != nil:
    section.add "X-Amz-Security-Token", valid_602934
  var valid_602935 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602935 = validateParameter(valid_602935, JString, required = false,
                                 default = nil)
  if valid_602935 != nil:
    section.add "X-Amz-Content-Sha256", valid_602935
  var valid_602936 = header.getOrDefault("X-Amz-Algorithm")
  valid_602936 = validateParameter(valid_602936, JString, required = false,
                                 default = nil)
  if valid_602936 != nil:
    section.add "X-Amz-Algorithm", valid_602936
  var valid_602937 = header.getOrDefault("X-Amz-Signature")
  valid_602937 = validateParameter(valid_602937, JString, required = false,
                                 default = nil)
  if valid_602937 != nil:
    section.add "X-Amz-Signature", valid_602937
  var valid_602938 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602938 = validateParameter(valid_602938, JString, required = false,
                                 default = nil)
  if valid_602938 != nil:
    section.add "X-Amz-SignedHeaders", valid_602938
  var valid_602939 = header.getOrDefault("X-Amz-Credential")
  valid_602939 = validateParameter(valid_602939, JString, required = false,
                                 default = nil)
  if valid_602939 != nil:
    section.add "X-Amz-Credential", valid_602939
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602962: Call_AcceptCertificateTransfer_602803; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ## 
  let valid = call_602962.validator(path, query, header, formData, body)
  let scheme = call_602962.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602962.url(scheme.get, call_602962.host, call_602962.base,
                         call_602962.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_602962, url, valid)

proc call*(call_603033: Call_AcceptCertificateTransfer_602803;
          certificateId: string; setAsActive: bool = false): Recallable =
  ## acceptCertificateTransfer
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  var path_603034 = newJObject()
  var query_603036 = newJObject()
  add(path_603034, "certificateId", newJString(certificateId))
  add(query_603036, "setAsActive", newJBool(setAsActive))
  result = call_603033.call(path_603034, query_603036, nil, nil, nil)

var acceptCertificateTransfer* = Call_AcceptCertificateTransfer_602803(
    name: "acceptCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/accept-certificate-transfer/{certificateId}",
    validator: validate_AcceptCertificateTransfer_602804, base: "/",
    url: url_AcceptCertificateTransfer_602805,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_AddThingToBillingGroup_603075 = ref object of OpenApiRestCall_602466
proc url_AddThingToBillingGroup_603077(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_AddThingToBillingGroup_603076(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a thing to a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603078 = header.getOrDefault("X-Amz-Date")
  valid_603078 = validateParameter(valid_603078, JString, required = false,
                                 default = nil)
  if valid_603078 != nil:
    section.add "X-Amz-Date", valid_603078
  var valid_603079 = header.getOrDefault("X-Amz-Security-Token")
  valid_603079 = validateParameter(valid_603079, JString, required = false,
                                 default = nil)
  if valid_603079 != nil:
    section.add "X-Amz-Security-Token", valid_603079
  var valid_603080 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603080 = validateParameter(valid_603080, JString, required = false,
                                 default = nil)
  if valid_603080 != nil:
    section.add "X-Amz-Content-Sha256", valid_603080
  var valid_603081 = header.getOrDefault("X-Amz-Algorithm")
  valid_603081 = validateParameter(valid_603081, JString, required = false,
                                 default = nil)
  if valid_603081 != nil:
    section.add "X-Amz-Algorithm", valid_603081
  var valid_603082 = header.getOrDefault("X-Amz-Signature")
  valid_603082 = validateParameter(valid_603082, JString, required = false,
                                 default = nil)
  if valid_603082 != nil:
    section.add "X-Amz-Signature", valid_603082
  var valid_603083 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603083 = validateParameter(valid_603083, JString, required = false,
                                 default = nil)
  if valid_603083 != nil:
    section.add "X-Amz-SignedHeaders", valid_603083
  var valid_603084 = header.getOrDefault("X-Amz-Credential")
  valid_603084 = validateParameter(valid_603084, JString, required = false,
                                 default = nil)
  if valid_603084 != nil:
    section.add "X-Amz-Credential", valid_603084
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603086: Call_AddThingToBillingGroup_603075; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a thing to a billing group.
  ## 
  let valid = call_603086.validator(path, query, header, formData, body)
  let scheme = call_603086.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603086.url(scheme.get, call_603086.host, call_603086.base,
                         call_603086.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603086, url, valid)

proc call*(call_603087: Call_AddThingToBillingGroup_603075; body: JsonNode): Recallable =
  ## addThingToBillingGroup
  ## Adds a thing to a billing group.
  ##   body: JObject (required)
  var body_603088 = newJObject()
  if body != nil:
    body_603088 = body
  result = call_603087.call(nil, nil, nil, nil, body_603088)

var addThingToBillingGroup* = Call_AddThingToBillingGroup_603075(
    name: "addThingToBillingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/billing-groups/addThingToBillingGroup",
    validator: validate_AddThingToBillingGroup_603076, base: "/",
    url: url_AddThingToBillingGroup_603077, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AddThingToThingGroup_603089 = ref object of OpenApiRestCall_602466
proc url_AddThingToThingGroup_603091(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_AddThingToThingGroup_603090(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a thing to a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603092 = header.getOrDefault("X-Amz-Date")
  valid_603092 = validateParameter(valid_603092, JString, required = false,
                                 default = nil)
  if valid_603092 != nil:
    section.add "X-Amz-Date", valid_603092
  var valid_603093 = header.getOrDefault("X-Amz-Security-Token")
  valid_603093 = validateParameter(valid_603093, JString, required = false,
                                 default = nil)
  if valid_603093 != nil:
    section.add "X-Amz-Security-Token", valid_603093
  var valid_603094 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603094 = validateParameter(valid_603094, JString, required = false,
                                 default = nil)
  if valid_603094 != nil:
    section.add "X-Amz-Content-Sha256", valid_603094
  var valid_603095 = header.getOrDefault("X-Amz-Algorithm")
  valid_603095 = validateParameter(valid_603095, JString, required = false,
                                 default = nil)
  if valid_603095 != nil:
    section.add "X-Amz-Algorithm", valid_603095
  var valid_603096 = header.getOrDefault("X-Amz-Signature")
  valid_603096 = validateParameter(valid_603096, JString, required = false,
                                 default = nil)
  if valid_603096 != nil:
    section.add "X-Amz-Signature", valid_603096
  var valid_603097 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603097 = validateParameter(valid_603097, JString, required = false,
                                 default = nil)
  if valid_603097 != nil:
    section.add "X-Amz-SignedHeaders", valid_603097
  var valid_603098 = header.getOrDefault("X-Amz-Credential")
  valid_603098 = validateParameter(valid_603098, JString, required = false,
                                 default = nil)
  if valid_603098 != nil:
    section.add "X-Amz-Credential", valid_603098
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603100: Call_AddThingToThingGroup_603089; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a thing to a thing group.
  ## 
  let valid = call_603100.validator(path, query, header, formData, body)
  let scheme = call_603100.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603100.url(scheme.get, call_603100.host, call_603100.base,
                         call_603100.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603100, url, valid)

proc call*(call_603101: Call_AddThingToThingGroup_603089; body: JsonNode): Recallable =
  ## addThingToThingGroup
  ## Adds a thing to a thing group.
  ##   body: JObject (required)
  var body_603102 = newJObject()
  if body != nil:
    body_603102 = body
  result = call_603101.call(nil, nil, nil, nil, body_603102)

var addThingToThingGroup* = Call_AddThingToThingGroup_603089(
    name: "addThingToThingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/addThingToThingGroup",
    validator: validate_AddThingToThingGroup_603090, base: "/",
    url: url_AddThingToThingGroup_603091, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AssociateTargetsWithJob_603103 = ref object of OpenApiRestCall_602466
proc url_AssociateTargetsWithJob_603105(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/targets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_AssociateTargetsWithJob_603104(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_603106 = path.getOrDefault("jobId")
  valid_603106 = validateParameter(valid_603106, JString, required = true,
                                 default = nil)
  if valid_603106 != nil:
    section.add "jobId", valid_603106
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603107 = header.getOrDefault("X-Amz-Date")
  valid_603107 = validateParameter(valid_603107, JString, required = false,
                                 default = nil)
  if valid_603107 != nil:
    section.add "X-Amz-Date", valid_603107
  var valid_603108 = header.getOrDefault("X-Amz-Security-Token")
  valid_603108 = validateParameter(valid_603108, JString, required = false,
                                 default = nil)
  if valid_603108 != nil:
    section.add "X-Amz-Security-Token", valid_603108
  var valid_603109 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603109 = validateParameter(valid_603109, JString, required = false,
                                 default = nil)
  if valid_603109 != nil:
    section.add "X-Amz-Content-Sha256", valid_603109
  var valid_603110 = header.getOrDefault("X-Amz-Algorithm")
  valid_603110 = validateParameter(valid_603110, JString, required = false,
                                 default = nil)
  if valid_603110 != nil:
    section.add "X-Amz-Algorithm", valid_603110
  var valid_603111 = header.getOrDefault("X-Amz-Signature")
  valid_603111 = validateParameter(valid_603111, JString, required = false,
                                 default = nil)
  if valid_603111 != nil:
    section.add "X-Amz-Signature", valid_603111
  var valid_603112 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603112 = validateParameter(valid_603112, JString, required = false,
                                 default = nil)
  if valid_603112 != nil:
    section.add "X-Amz-SignedHeaders", valid_603112
  var valid_603113 = header.getOrDefault("X-Amz-Credential")
  valid_603113 = validateParameter(valid_603113, JString, required = false,
                                 default = nil)
  if valid_603113 != nil:
    section.add "X-Amz-Credential", valid_603113
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603115: Call_AssociateTargetsWithJob_603103; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ## 
  let valid = call_603115.validator(path, query, header, formData, body)
  let scheme = call_603115.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603115.url(scheme.get, call_603115.host, call_603115.base,
                         call_603115.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603115, url, valid)

proc call*(call_603116: Call_AssociateTargetsWithJob_603103; jobId: string;
          body: JsonNode): Recallable =
  ## associateTargetsWithJob
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   body: JObject (required)
  var path_603117 = newJObject()
  var body_603118 = newJObject()
  add(path_603117, "jobId", newJString(jobId))
  if body != nil:
    body_603118 = body
  result = call_603116.call(path_603117, nil, nil, nil, body_603118)

var associateTargetsWithJob* = Call_AssociateTargetsWithJob_603103(
    name: "associateTargetsWithJob", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/jobs/{jobId}/targets",
    validator: validate_AssociateTargetsWithJob_603104, base: "/",
    url: url_AssociateTargetsWithJob_603105, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachPolicy_603119 = ref object of OpenApiRestCall_602466
proc url_AttachPolicy_603121(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/target-policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_AttachPolicy_603120(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Attaches a policy to the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to attach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_603122 = path.getOrDefault("policyName")
  valid_603122 = validateParameter(valid_603122, JString, required = true,
                                 default = nil)
  if valid_603122 != nil:
    section.add "policyName", valid_603122
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603123 = header.getOrDefault("X-Amz-Date")
  valid_603123 = validateParameter(valid_603123, JString, required = false,
                                 default = nil)
  if valid_603123 != nil:
    section.add "X-Amz-Date", valid_603123
  var valid_603124 = header.getOrDefault("X-Amz-Security-Token")
  valid_603124 = validateParameter(valid_603124, JString, required = false,
                                 default = nil)
  if valid_603124 != nil:
    section.add "X-Amz-Security-Token", valid_603124
  var valid_603125 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603125 = validateParameter(valid_603125, JString, required = false,
                                 default = nil)
  if valid_603125 != nil:
    section.add "X-Amz-Content-Sha256", valid_603125
  var valid_603126 = header.getOrDefault("X-Amz-Algorithm")
  valid_603126 = validateParameter(valid_603126, JString, required = false,
                                 default = nil)
  if valid_603126 != nil:
    section.add "X-Amz-Algorithm", valid_603126
  var valid_603127 = header.getOrDefault("X-Amz-Signature")
  valid_603127 = validateParameter(valid_603127, JString, required = false,
                                 default = nil)
  if valid_603127 != nil:
    section.add "X-Amz-Signature", valid_603127
  var valid_603128 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603128 = validateParameter(valid_603128, JString, required = false,
                                 default = nil)
  if valid_603128 != nil:
    section.add "X-Amz-SignedHeaders", valid_603128
  var valid_603129 = header.getOrDefault("X-Amz-Credential")
  valid_603129 = validateParameter(valid_603129, JString, required = false,
                                 default = nil)
  if valid_603129 != nil:
    section.add "X-Amz-Credential", valid_603129
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603131: Call_AttachPolicy_603119; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Attaches a policy to the specified target.
  ## 
  let valid = call_603131.validator(path, query, header, formData, body)
  let scheme = call_603131.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603131.url(scheme.get, call_603131.host, call_603131.base,
                         call_603131.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603131, url, valid)

proc call*(call_603132: Call_AttachPolicy_603119; policyName: string; body: JsonNode): Recallable =
  ## attachPolicy
  ## Attaches a policy to the specified target.
  ##   policyName: string (required)
  ##             : The name of the policy to attach.
  ##   body: JObject (required)
  var path_603133 = newJObject()
  var body_603134 = newJObject()
  add(path_603133, "policyName", newJString(policyName))
  if body != nil:
    body_603134 = body
  result = call_603132.call(path_603133, nil, nil, nil, body_603134)

var attachPolicy* = Call_AttachPolicy_603119(name: "attachPolicy",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/target-policies/{policyName}", validator: validate_AttachPolicy_603120,
    base: "/", url: url_AttachPolicy_603121, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachPolicy_603135 = ref object of OpenApiRestCall_602466
proc url_DetachPolicy_603137(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/target-policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DetachPolicy_603136(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Detaches a policy from the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy to detach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_603138 = path.getOrDefault("policyName")
  valid_603138 = validateParameter(valid_603138, JString, required = true,
                                 default = nil)
  if valid_603138 != nil:
    section.add "policyName", valid_603138
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603139 = header.getOrDefault("X-Amz-Date")
  valid_603139 = validateParameter(valid_603139, JString, required = false,
                                 default = nil)
  if valid_603139 != nil:
    section.add "X-Amz-Date", valid_603139
  var valid_603140 = header.getOrDefault("X-Amz-Security-Token")
  valid_603140 = validateParameter(valid_603140, JString, required = false,
                                 default = nil)
  if valid_603140 != nil:
    section.add "X-Amz-Security-Token", valid_603140
  var valid_603141 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603141 = validateParameter(valid_603141, JString, required = false,
                                 default = nil)
  if valid_603141 != nil:
    section.add "X-Amz-Content-Sha256", valid_603141
  var valid_603142 = header.getOrDefault("X-Amz-Algorithm")
  valid_603142 = validateParameter(valid_603142, JString, required = false,
                                 default = nil)
  if valid_603142 != nil:
    section.add "X-Amz-Algorithm", valid_603142
  var valid_603143 = header.getOrDefault("X-Amz-Signature")
  valid_603143 = validateParameter(valid_603143, JString, required = false,
                                 default = nil)
  if valid_603143 != nil:
    section.add "X-Amz-Signature", valid_603143
  var valid_603144 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603144 = validateParameter(valid_603144, JString, required = false,
                                 default = nil)
  if valid_603144 != nil:
    section.add "X-Amz-SignedHeaders", valid_603144
  var valid_603145 = header.getOrDefault("X-Amz-Credential")
  valid_603145 = validateParameter(valid_603145, JString, required = false,
                                 default = nil)
  if valid_603145 != nil:
    section.add "X-Amz-Credential", valid_603145
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603147: Call_DetachPolicy_603135; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Detaches a policy from the specified target.
  ## 
  let valid = call_603147.validator(path, query, header, formData, body)
  let scheme = call_603147.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603147.url(scheme.get, call_603147.host, call_603147.base,
                         call_603147.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603147, url, valid)

proc call*(call_603148: Call_DetachPolicy_603135; policyName: string; body: JsonNode): Recallable =
  ## detachPolicy
  ## Detaches a policy from the specified target.
  ##   policyName: string (required)
  ##             : The policy to detach.
  ##   body: JObject (required)
  var path_603149 = newJObject()
  var body_603150 = newJObject()
  add(path_603149, "policyName", newJString(policyName))
  if body != nil:
    body_603150 = body
  result = call_603148.call(path_603149, nil, nil, nil, body_603150)

var detachPolicy* = Call_DetachPolicy_603135(name: "detachPolicy",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/target-policies/{policyName}", validator: validate_DetachPolicy_603136,
    base: "/", url: url_DetachPolicy_603137, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachPrincipalPolicy_603151 = ref object of OpenApiRestCall_602466
proc url_AttachPrincipalPolicy_603153(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/principal-policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "#x-amzn-iot-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_AttachPrincipalPolicy_603152(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_603154 = path.getOrDefault("policyName")
  valid_603154 = validateParameter(valid_603154, JString, required = true,
                                 default = nil)
  if valid_603154 != nil:
    section.add "policyName", valid_603154
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603155 = header.getOrDefault("X-Amz-Date")
  valid_603155 = validateParameter(valid_603155, JString, required = false,
                                 default = nil)
  if valid_603155 != nil:
    section.add "X-Amz-Date", valid_603155
  var valid_603156 = header.getOrDefault("X-Amz-Security-Token")
  valid_603156 = validateParameter(valid_603156, JString, required = false,
                                 default = nil)
  if valid_603156 != nil:
    section.add "X-Amz-Security-Token", valid_603156
  var valid_603157 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603157 = validateParameter(valid_603157, JString, required = false,
                                 default = nil)
  if valid_603157 != nil:
    section.add "X-Amz-Content-Sha256", valid_603157
  var valid_603158 = header.getOrDefault("X-Amz-Algorithm")
  valid_603158 = validateParameter(valid_603158, JString, required = false,
                                 default = nil)
  if valid_603158 != nil:
    section.add "X-Amz-Algorithm", valid_603158
  var valid_603159 = header.getOrDefault("X-Amz-Signature")
  valid_603159 = validateParameter(valid_603159, JString, required = false,
                                 default = nil)
  if valid_603159 != nil:
    section.add "X-Amz-Signature", valid_603159
  var valid_603160 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603160 = validateParameter(valid_603160, JString, required = false,
                                 default = nil)
  if valid_603160 != nil:
    section.add "X-Amz-SignedHeaders", valid_603160
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_603161 = header.getOrDefault("x-amzn-iot-principal")
  valid_603161 = validateParameter(valid_603161, JString, required = true,
                                 default = nil)
  if valid_603161 != nil:
    section.add "x-amzn-iot-principal", valid_603161
  var valid_603162 = header.getOrDefault("X-Amz-Credential")
  valid_603162 = validateParameter(valid_603162, JString, required = false,
                                 default = nil)
  if valid_603162 != nil:
    section.add "X-Amz-Credential", valid_603162
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603163: Call_AttachPrincipalPolicy_603151; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ## 
  let valid = call_603163.validator(path, query, header, formData, body)
  let scheme = call_603163.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603163.url(scheme.get, call_603163.host, call_603163.base,
                         call_603163.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603163, url, valid)

proc call*(call_603164: Call_AttachPrincipalPolicy_603151; policyName: string): Recallable =
  ## attachPrincipalPolicy
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ##   policyName: string (required)
  ##             : The policy name.
  var path_603165 = newJObject()
  add(path_603165, "policyName", newJString(policyName))
  result = call_603164.call(path_603165, nil, nil, nil, nil)

var attachPrincipalPolicy* = Call_AttachPrincipalPolicy_603151(
    name: "attachPrincipalPolicy", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/principal-policies/{policyName}#x-amzn-iot-principal",
    validator: validate_AttachPrincipalPolicy_603152, base: "/",
    url: url_AttachPrincipalPolicy_603153, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachPrincipalPolicy_603166 = ref object of OpenApiRestCall_602466
proc url_DetachPrincipalPolicy_603168(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/principal-policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "#x-amzn-iot-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DetachPrincipalPolicy_603167(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to detach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_603169 = path.getOrDefault("policyName")
  valid_603169 = validateParameter(valid_603169, JString, required = true,
                                 default = nil)
  if valid_603169 != nil:
    section.add "policyName", valid_603169
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : <p>The principal.</p> <p>If the principal is a certificate, specify the certificate ARN. If the principal is an Amazon Cognito identity, specify the identity ID.</p>
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603170 = header.getOrDefault("X-Amz-Date")
  valid_603170 = validateParameter(valid_603170, JString, required = false,
                                 default = nil)
  if valid_603170 != nil:
    section.add "X-Amz-Date", valid_603170
  var valid_603171 = header.getOrDefault("X-Amz-Security-Token")
  valid_603171 = validateParameter(valid_603171, JString, required = false,
                                 default = nil)
  if valid_603171 != nil:
    section.add "X-Amz-Security-Token", valid_603171
  var valid_603172 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603172 = validateParameter(valid_603172, JString, required = false,
                                 default = nil)
  if valid_603172 != nil:
    section.add "X-Amz-Content-Sha256", valid_603172
  var valid_603173 = header.getOrDefault("X-Amz-Algorithm")
  valid_603173 = validateParameter(valid_603173, JString, required = false,
                                 default = nil)
  if valid_603173 != nil:
    section.add "X-Amz-Algorithm", valid_603173
  var valid_603174 = header.getOrDefault("X-Amz-Signature")
  valid_603174 = validateParameter(valid_603174, JString, required = false,
                                 default = nil)
  if valid_603174 != nil:
    section.add "X-Amz-Signature", valid_603174
  var valid_603175 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603175 = validateParameter(valid_603175, JString, required = false,
                                 default = nil)
  if valid_603175 != nil:
    section.add "X-Amz-SignedHeaders", valid_603175
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_603176 = header.getOrDefault("x-amzn-iot-principal")
  valid_603176 = validateParameter(valid_603176, JString, required = true,
                                 default = nil)
  if valid_603176 != nil:
    section.add "x-amzn-iot-principal", valid_603176
  var valid_603177 = header.getOrDefault("X-Amz-Credential")
  valid_603177 = validateParameter(valid_603177, JString, required = false,
                                 default = nil)
  if valid_603177 != nil:
    section.add "X-Amz-Credential", valid_603177
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603178: Call_DetachPrincipalPolicy_603166; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ## 
  let valid = call_603178.validator(path, query, header, formData, body)
  let scheme = call_603178.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603178.url(scheme.get, call_603178.host, call_603178.base,
                         call_603178.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603178, url, valid)

proc call*(call_603179: Call_DetachPrincipalPolicy_603166; policyName: string): Recallable =
  ## detachPrincipalPolicy
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ##   policyName: string (required)
  ##             : The name of the policy to detach.
  var path_603180 = newJObject()
  add(path_603180, "policyName", newJString(policyName))
  result = call_603179.call(path_603180, nil, nil, nil, nil)

var detachPrincipalPolicy* = Call_DetachPrincipalPolicy_603166(
    name: "detachPrincipalPolicy", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/principal-policies/{policyName}#x-amzn-iot-principal",
    validator: validate_DetachPrincipalPolicy_603167, base: "/",
    url: url_DetachPrincipalPolicy_603168, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachSecurityProfile_603181 = ref object of OpenApiRestCall_602466
proc url_AttachSecurityProfile_603183(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"), (
        kind: ConstantSegment, value: "/targets#securityProfileTargetArn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_AttachSecurityProfile_603182(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile that is attached.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_603184 = path.getOrDefault("securityProfileName")
  valid_603184 = validateParameter(valid_603184, JString, required = true,
                                 default = nil)
  if valid_603184 != nil:
    section.add "securityProfileName", valid_603184
  result.add "path", section
  ## parameters in `query` object:
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the target (thing group) to which the security profile is attached.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_603185 = query.getOrDefault("securityProfileTargetArn")
  valid_603185 = validateParameter(valid_603185, JString, required = true,
                                 default = nil)
  if valid_603185 != nil:
    section.add "securityProfileTargetArn", valid_603185
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603186 = header.getOrDefault("X-Amz-Date")
  valid_603186 = validateParameter(valid_603186, JString, required = false,
                                 default = nil)
  if valid_603186 != nil:
    section.add "X-Amz-Date", valid_603186
  var valid_603187 = header.getOrDefault("X-Amz-Security-Token")
  valid_603187 = validateParameter(valid_603187, JString, required = false,
                                 default = nil)
  if valid_603187 != nil:
    section.add "X-Amz-Security-Token", valid_603187
  var valid_603188 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603188 = validateParameter(valid_603188, JString, required = false,
                                 default = nil)
  if valid_603188 != nil:
    section.add "X-Amz-Content-Sha256", valid_603188
  var valid_603189 = header.getOrDefault("X-Amz-Algorithm")
  valid_603189 = validateParameter(valid_603189, JString, required = false,
                                 default = nil)
  if valid_603189 != nil:
    section.add "X-Amz-Algorithm", valid_603189
  var valid_603190 = header.getOrDefault("X-Amz-Signature")
  valid_603190 = validateParameter(valid_603190, JString, required = false,
                                 default = nil)
  if valid_603190 != nil:
    section.add "X-Amz-Signature", valid_603190
  var valid_603191 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603191 = validateParameter(valid_603191, JString, required = false,
                                 default = nil)
  if valid_603191 != nil:
    section.add "X-Amz-SignedHeaders", valid_603191
  var valid_603192 = header.getOrDefault("X-Amz-Credential")
  valid_603192 = validateParameter(valid_603192, JString, required = false,
                                 default = nil)
  if valid_603192 != nil:
    section.add "X-Amz-Credential", valid_603192
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603193: Call_AttachSecurityProfile_603181; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ## 
  let valid = call_603193.validator(path, query, header, formData, body)
  let scheme = call_603193.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603193.url(scheme.get, call_603193.host, call_603193.base,
                         call_603193.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603193, url, valid)

proc call*(call_603194: Call_AttachSecurityProfile_603181;
          securityProfileTargetArn: string; securityProfileName: string): Recallable =
  ## attachSecurityProfile
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the target (thing group) to which the security profile is attached.
  ##   securityProfileName: string (required)
  ##                      : The security profile that is attached.
  var path_603195 = newJObject()
  var query_603196 = newJObject()
  add(query_603196, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(path_603195, "securityProfileName", newJString(securityProfileName))
  result = call_603194.call(path_603195, query_603196, nil, nil, nil)

var attachSecurityProfile* = Call_AttachSecurityProfile_603181(
    name: "attachSecurityProfile", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}/targets#securityProfileTargetArn",
    validator: validate_AttachSecurityProfile_603182, base: "/",
    url: url_AttachSecurityProfile_603183, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachSecurityProfile_603197 = ref object of OpenApiRestCall_602466
proc url_DetachSecurityProfile_603199(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"), (
        kind: ConstantSegment, value: "/targets#securityProfileTargetArn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DetachSecurityProfile_603198(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile that is detached.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_603200 = path.getOrDefault("securityProfileName")
  valid_603200 = validateParameter(valid_603200, JString, required = true,
                                 default = nil)
  if valid_603200 != nil:
    section.add "securityProfileName", valid_603200
  result.add "path", section
  ## parameters in `query` object:
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the thing group from which the security profile is detached.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_603201 = query.getOrDefault("securityProfileTargetArn")
  valid_603201 = validateParameter(valid_603201, JString, required = true,
                                 default = nil)
  if valid_603201 != nil:
    section.add "securityProfileTargetArn", valid_603201
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603202 = header.getOrDefault("X-Amz-Date")
  valid_603202 = validateParameter(valid_603202, JString, required = false,
                                 default = nil)
  if valid_603202 != nil:
    section.add "X-Amz-Date", valid_603202
  var valid_603203 = header.getOrDefault("X-Amz-Security-Token")
  valid_603203 = validateParameter(valid_603203, JString, required = false,
                                 default = nil)
  if valid_603203 != nil:
    section.add "X-Amz-Security-Token", valid_603203
  var valid_603204 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603204 = validateParameter(valid_603204, JString, required = false,
                                 default = nil)
  if valid_603204 != nil:
    section.add "X-Amz-Content-Sha256", valid_603204
  var valid_603205 = header.getOrDefault("X-Amz-Algorithm")
  valid_603205 = validateParameter(valid_603205, JString, required = false,
                                 default = nil)
  if valid_603205 != nil:
    section.add "X-Amz-Algorithm", valid_603205
  var valid_603206 = header.getOrDefault("X-Amz-Signature")
  valid_603206 = validateParameter(valid_603206, JString, required = false,
                                 default = nil)
  if valid_603206 != nil:
    section.add "X-Amz-Signature", valid_603206
  var valid_603207 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603207 = validateParameter(valid_603207, JString, required = false,
                                 default = nil)
  if valid_603207 != nil:
    section.add "X-Amz-SignedHeaders", valid_603207
  var valid_603208 = header.getOrDefault("X-Amz-Credential")
  valid_603208 = validateParameter(valid_603208, JString, required = false,
                                 default = nil)
  if valid_603208 != nil:
    section.add "X-Amz-Credential", valid_603208
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603209: Call_DetachSecurityProfile_603197; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ## 
  let valid = call_603209.validator(path, query, header, formData, body)
  let scheme = call_603209.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603209.url(scheme.get, call_603209.host, call_603209.base,
                         call_603209.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603209, url, valid)

proc call*(call_603210: Call_DetachSecurityProfile_603197;
          securityProfileTargetArn: string; securityProfileName: string): Recallable =
  ## detachSecurityProfile
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the thing group from which the security profile is detached.
  ##   securityProfileName: string (required)
  ##                      : The security profile that is detached.
  var path_603211 = newJObject()
  var query_603212 = newJObject()
  add(query_603212, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(path_603211, "securityProfileName", newJString(securityProfileName))
  result = call_603210.call(path_603211, query_603212, nil, nil, nil)

var detachSecurityProfile* = Call_DetachSecurityProfile_603197(
    name: "detachSecurityProfile", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}/targets#securityProfileTargetArn",
    validator: validate_DetachSecurityProfile_603198, base: "/",
    url: url_DetachSecurityProfile_603199, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachThingPrincipal_603213 = ref object of OpenApiRestCall_602466
proc url_AttachThingPrincipal_603215(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals#x-amzn-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_AttachThingPrincipal_603214(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_603216 = path.getOrDefault("thingName")
  valid_603216 = validateParameter(valid_603216, JString, required = true,
                                 default = nil)
  if valid_603216 != nil:
    section.add "thingName", valid_603216
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : The principal, such as a certificate or other credential.
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603217 = header.getOrDefault("X-Amz-Date")
  valid_603217 = validateParameter(valid_603217, JString, required = false,
                                 default = nil)
  if valid_603217 != nil:
    section.add "X-Amz-Date", valid_603217
  var valid_603218 = header.getOrDefault("X-Amz-Security-Token")
  valid_603218 = validateParameter(valid_603218, JString, required = false,
                                 default = nil)
  if valid_603218 != nil:
    section.add "X-Amz-Security-Token", valid_603218
  var valid_603219 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603219 = validateParameter(valid_603219, JString, required = false,
                                 default = nil)
  if valid_603219 != nil:
    section.add "X-Amz-Content-Sha256", valid_603219
  var valid_603220 = header.getOrDefault("X-Amz-Algorithm")
  valid_603220 = validateParameter(valid_603220, JString, required = false,
                                 default = nil)
  if valid_603220 != nil:
    section.add "X-Amz-Algorithm", valid_603220
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_603221 = header.getOrDefault("x-amzn-principal")
  valid_603221 = validateParameter(valid_603221, JString, required = true,
                                 default = nil)
  if valid_603221 != nil:
    section.add "x-amzn-principal", valid_603221
  var valid_603222 = header.getOrDefault("X-Amz-Signature")
  valid_603222 = validateParameter(valid_603222, JString, required = false,
                                 default = nil)
  if valid_603222 != nil:
    section.add "X-Amz-Signature", valid_603222
  var valid_603223 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603223 = validateParameter(valid_603223, JString, required = false,
                                 default = nil)
  if valid_603223 != nil:
    section.add "X-Amz-SignedHeaders", valid_603223
  var valid_603224 = header.getOrDefault("X-Amz-Credential")
  valid_603224 = validateParameter(valid_603224, JString, required = false,
                                 default = nil)
  if valid_603224 != nil:
    section.add "X-Amz-Credential", valid_603224
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603225: Call_AttachThingPrincipal_603213; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  let valid = call_603225.validator(path, query, header, formData, body)
  let scheme = call_603225.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603225.url(scheme.get, call_603225.host, call_603225.base,
                         call_603225.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603225, url, valid)

proc call*(call_603226: Call_AttachThingPrincipal_603213; thingName: string): Recallable =
  ## attachThingPrincipal
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_603227 = newJObject()
  add(path_603227, "thingName", newJString(thingName))
  result = call_603226.call(path_603227, nil, nil, nil, nil)

var attachThingPrincipal* = Call_AttachThingPrincipal_603213(
    name: "attachThingPrincipal", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/things/{thingName}/principals#x-amzn-principal",
    validator: validate_AttachThingPrincipal_603214, base: "/",
    url: url_AttachThingPrincipal_603215, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachThingPrincipal_603228 = ref object of OpenApiRestCall_602466
proc url_DetachThingPrincipal_603230(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals#x-amzn-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DetachThingPrincipal_603229(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_603231 = path.getOrDefault("thingName")
  valid_603231 = validateParameter(valid_603231, JString, required = true,
                                 default = nil)
  if valid_603231 != nil:
    section.add "thingName", valid_603231
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603232 = header.getOrDefault("X-Amz-Date")
  valid_603232 = validateParameter(valid_603232, JString, required = false,
                                 default = nil)
  if valid_603232 != nil:
    section.add "X-Amz-Date", valid_603232
  var valid_603233 = header.getOrDefault("X-Amz-Security-Token")
  valid_603233 = validateParameter(valid_603233, JString, required = false,
                                 default = nil)
  if valid_603233 != nil:
    section.add "X-Amz-Security-Token", valid_603233
  var valid_603234 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603234 = validateParameter(valid_603234, JString, required = false,
                                 default = nil)
  if valid_603234 != nil:
    section.add "X-Amz-Content-Sha256", valid_603234
  var valid_603235 = header.getOrDefault("X-Amz-Algorithm")
  valid_603235 = validateParameter(valid_603235, JString, required = false,
                                 default = nil)
  if valid_603235 != nil:
    section.add "X-Amz-Algorithm", valid_603235
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_603236 = header.getOrDefault("x-amzn-principal")
  valid_603236 = validateParameter(valid_603236, JString, required = true,
                                 default = nil)
  if valid_603236 != nil:
    section.add "x-amzn-principal", valid_603236
  var valid_603237 = header.getOrDefault("X-Amz-Signature")
  valid_603237 = validateParameter(valid_603237, JString, required = false,
                                 default = nil)
  if valid_603237 != nil:
    section.add "X-Amz-Signature", valid_603237
  var valid_603238 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603238 = validateParameter(valid_603238, JString, required = false,
                                 default = nil)
  if valid_603238 != nil:
    section.add "X-Amz-SignedHeaders", valid_603238
  var valid_603239 = header.getOrDefault("X-Amz-Credential")
  valid_603239 = validateParameter(valid_603239, JString, required = false,
                                 default = nil)
  if valid_603239 != nil:
    section.add "X-Amz-Credential", valid_603239
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603240: Call_DetachThingPrincipal_603228; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ## 
  let valid = call_603240.validator(path, query, header, formData, body)
  let scheme = call_603240.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603240.url(scheme.get, call_603240.host, call_603240.base,
                         call_603240.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603240, url, valid)

proc call*(call_603241: Call_DetachThingPrincipal_603228; thingName: string): Recallable =
  ## detachThingPrincipal
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_603242 = newJObject()
  add(path_603242, "thingName", newJString(thingName))
  result = call_603241.call(path_603242, nil, nil, nil, nil)

var detachThingPrincipal* = Call_DetachThingPrincipal_603228(
    name: "detachThingPrincipal", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/things/{thingName}/principals#x-amzn-principal",
    validator: validate_DetachThingPrincipal_603229, base: "/",
    url: url_DetachThingPrincipal_603230, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelAuditMitigationActionsTask_603243 = ref object of OpenApiRestCall_602466
proc url_CancelAuditMitigationActionsTask_603245(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CancelAuditMitigationActionsTask_603244(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The unique identifier for the task that you want to cancel. 
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_603246 = path.getOrDefault("taskId")
  valid_603246 = validateParameter(valid_603246, JString, required = true,
                                 default = nil)
  if valid_603246 != nil:
    section.add "taskId", valid_603246
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603247 = header.getOrDefault("X-Amz-Date")
  valid_603247 = validateParameter(valid_603247, JString, required = false,
                                 default = nil)
  if valid_603247 != nil:
    section.add "X-Amz-Date", valid_603247
  var valid_603248 = header.getOrDefault("X-Amz-Security-Token")
  valid_603248 = validateParameter(valid_603248, JString, required = false,
                                 default = nil)
  if valid_603248 != nil:
    section.add "X-Amz-Security-Token", valid_603248
  var valid_603249 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603249 = validateParameter(valid_603249, JString, required = false,
                                 default = nil)
  if valid_603249 != nil:
    section.add "X-Amz-Content-Sha256", valid_603249
  var valid_603250 = header.getOrDefault("X-Amz-Algorithm")
  valid_603250 = validateParameter(valid_603250, JString, required = false,
                                 default = nil)
  if valid_603250 != nil:
    section.add "X-Amz-Algorithm", valid_603250
  var valid_603251 = header.getOrDefault("X-Amz-Signature")
  valid_603251 = validateParameter(valid_603251, JString, required = false,
                                 default = nil)
  if valid_603251 != nil:
    section.add "X-Amz-Signature", valid_603251
  var valid_603252 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603252 = validateParameter(valid_603252, JString, required = false,
                                 default = nil)
  if valid_603252 != nil:
    section.add "X-Amz-SignedHeaders", valid_603252
  var valid_603253 = header.getOrDefault("X-Amz-Credential")
  valid_603253 = validateParameter(valid_603253, JString, required = false,
                                 default = nil)
  if valid_603253 != nil:
    section.add "X-Amz-Credential", valid_603253
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603254: Call_CancelAuditMitigationActionsTask_603243;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ## 
  let valid = call_603254.validator(path, query, header, formData, body)
  let scheme = call_603254.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603254.url(scheme.get, call_603254.host, call_603254.base,
                         call_603254.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603254, url, valid)

proc call*(call_603255: Call_CancelAuditMitigationActionsTask_603243;
          taskId: string): Recallable =
  ## cancelAuditMitigationActionsTask
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ##   taskId: string (required)
  ##         : The unique identifier for the task that you want to cancel. 
  var path_603256 = newJObject()
  add(path_603256, "taskId", newJString(taskId))
  result = call_603255.call(path_603256, nil, nil, nil, nil)

var cancelAuditMitigationActionsTask* = Call_CancelAuditMitigationActionsTask_603243(
    name: "cancelAuditMitigationActionsTask", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/tasks/{taskId}/cancel",
    validator: validate_CancelAuditMitigationActionsTask_603244, base: "/",
    url: url_CancelAuditMitigationActionsTask_603245,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelAuditTask_603257 = ref object of OpenApiRestCall_602466
proc url_CancelAuditTask_603259(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CancelAuditTask_603258(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_603260 = path.getOrDefault("taskId")
  valid_603260 = validateParameter(valid_603260, JString, required = true,
                                 default = nil)
  if valid_603260 != nil:
    section.add "taskId", valid_603260
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603261 = header.getOrDefault("X-Amz-Date")
  valid_603261 = validateParameter(valid_603261, JString, required = false,
                                 default = nil)
  if valid_603261 != nil:
    section.add "X-Amz-Date", valid_603261
  var valid_603262 = header.getOrDefault("X-Amz-Security-Token")
  valid_603262 = validateParameter(valid_603262, JString, required = false,
                                 default = nil)
  if valid_603262 != nil:
    section.add "X-Amz-Security-Token", valid_603262
  var valid_603263 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603263 = validateParameter(valid_603263, JString, required = false,
                                 default = nil)
  if valid_603263 != nil:
    section.add "X-Amz-Content-Sha256", valid_603263
  var valid_603264 = header.getOrDefault("X-Amz-Algorithm")
  valid_603264 = validateParameter(valid_603264, JString, required = false,
                                 default = nil)
  if valid_603264 != nil:
    section.add "X-Amz-Algorithm", valid_603264
  var valid_603265 = header.getOrDefault("X-Amz-Signature")
  valid_603265 = validateParameter(valid_603265, JString, required = false,
                                 default = nil)
  if valid_603265 != nil:
    section.add "X-Amz-Signature", valid_603265
  var valid_603266 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603266 = validateParameter(valid_603266, JString, required = false,
                                 default = nil)
  if valid_603266 != nil:
    section.add "X-Amz-SignedHeaders", valid_603266
  var valid_603267 = header.getOrDefault("X-Amz-Credential")
  valid_603267 = validateParameter(valid_603267, JString, required = false,
                                 default = nil)
  if valid_603267 != nil:
    section.add "X-Amz-Credential", valid_603267
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603268: Call_CancelAuditTask_603257; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ## 
  let valid = call_603268.validator(path, query, header, formData, body)
  let scheme = call_603268.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603268.url(scheme.get, call_603268.host, call_603268.base,
                         call_603268.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603268, url, valid)

proc call*(call_603269: Call_CancelAuditTask_603257; taskId: string): Recallable =
  ## cancelAuditTask
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ##   taskId: string (required)
  ##         : The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
  var path_603270 = newJObject()
  add(path_603270, "taskId", newJString(taskId))
  result = call_603269.call(path_603270, nil, nil, nil, nil)

var cancelAuditTask* = Call_CancelAuditTask_603257(name: "cancelAuditTask",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/audit/tasks/{taskId}/cancel", validator: validate_CancelAuditTask_603258,
    base: "/", url: url_CancelAuditTask_603259, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelCertificateTransfer_603271 = ref object of OpenApiRestCall_602466
proc url_CancelCertificateTransfer_603273(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cancel-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CancelCertificateTransfer_603272(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_603274 = path.getOrDefault("certificateId")
  valid_603274 = validateParameter(valid_603274, JString, required = true,
                                 default = nil)
  if valid_603274 != nil:
    section.add "certificateId", valid_603274
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603275 = header.getOrDefault("X-Amz-Date")
  valid_603275 = validateParameter(valid_603275, JString, required = false,
                                 default = nil)
  if valid_603275 != nil:
    section.add "X-Amz-Date", valid_603275
  var valid_603276 = header.getOrDefault("X-Amz-Security-Token")
  valid_603276 = validateParameter(valid_603276, JString, required = false,
                                 default = nil)
  if valid_603276 != nil:
    section.add "X-Amz-Security-Token", valid_603276
  var valid_603277 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603277 = validateParameter(valid_603277, JString, required = false,
                                 default = nil)
  if valid_603277 != nil:
    section.add "X-Amz-Content-Sha256", valid_603277
  var valid_603278 = header.getOrDefault("X-Amz-Algorithm")
  valid_603278 = validateParameter(valid_603278, JString, required = false,
                                 default = nil)
  if valid_603278 != nil:
    section.add "X-Amz-Algorithm", valid_603278
  var valid_603279 = header.getOrDefault("X-Amz-Signature")
  valid_603279 = validateParameter(valid_603279, JString, required = false,
                                 default = nil)
  if valid_603279 != nil:
    section.add "X-Amz-Signature", valid_603279
  var valid_603280 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603280 = validateParameter(valid_603280, JString, required = false,
                                 default = nil)
  if valid_603280 != nil:
    section.add "X-Amz-SignedHeaders", valid_603280
  var valid_603281 = header.getOrDefault("X-Amz-Credential")
  valid_603281 = validateParameter(valid_603281, JString, required = false,
                                 default = nil)
  if valid_603281 != nil:
    section.add "X-Amz-Credential", valid_603281
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603282: Call_CancelCertificateTransfer_603271; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ## 
  let valid = call_603282.validator(path, query, header, formData, body)
  let scheme = call_603282.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603282.url(scheme.get, call_603282.host, call_603282.base,
                         call_603282.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603282, url, valid)

proc call*(call_603283: Call_CancelCertificateTransfer_603271;
          certificateId: string): Recallable =
  ## cancelCertificateTransfer
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_603284 = newJObject()
  add(path_603284, "certificateId", newJString(certificateId))
  result = call_603283.call(path_603284, nil, nil, nil, nil)

var cancelCertificateTransfer* = Call_CancelCertificateTransfer_603271(
    name: "cancelCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/cancel-certificate-transfer/{certificateId}",
    validator: validate_CancelCertificateTransfer_603272, base: "/",
    url: url_CancelCertificateTransfer_603273,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelJob_603285 = ref object of OpenApiRestCall_602466
proc url_CancelJob_603287(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CancelJob_603286(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_603288 = path.getOrDefault("jobId")
  valid_603288 = validateParameter(valid_603288, JString, required = true,
                                 default = nil)
  if valid_603288 != nil:
    section.add "jobId", valid_603288
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
  section = newJObject()
  var valid_603289 = query.getOrDefault("force")
  valid_603289 = validateParameter(valid_603289, JBool, required = false, default = nil)
  if valid_603289 != nil:
    section.add "force", valid_603289
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603290 = header.getOrDefault("X-Amz-Date")
  valid_603290 = validateParameter(valid_603290, JString, required = false,
                                 default = nil)
  if valid_603290 != nil:
    section.add "X-Amz-Date", valid_603290
  var valid_603291 = header.getOrDefault("X-Amz-Security-Token")
  valid_603291 = validateParameter(valid_603291, JString, required = false,
                                 default = nil)
  if valid_603291 != nil:
    section.add "X-Amz-Security-Token", valid_603291
  var valid_603292 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603292 = validateParameter(valid_603292, JString, required = false,
                                 default = nil)
  if valid_603292 != nil:
    section.add "X-Amz-Content-Sha256", valid_603292
  var valid_603293 = header.getOrDefault("X-Amz-Algorithm")
  valid_603293 = validateParameter(valid_603293, JString, required = false,
                                 default = nil)
  if valid_603293 != nil:
    section.add "X-Amz-Algorithm", valid_603293
  var valid_603294 = header.getOrDefault("X-Amz-Signature")
  valid_603294 = validateParameter(valid_603294, JString, required = false,
                                 default = nil)
  if valid_603294 != nil:
    section.add "X-Amz-Signature", valid_603294
  var valid_603295 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603295 = validateParameter(valid_603295, JString, required = false,
                                 default = nil)
  if valid_603295 != nil:
    section.add "X-Amz-SignedHeaders", valid_603295
  var valid_603296 = header.getOrDefault("X-Amz-Credential")
  valid_603296 = validateParameter(valid_603296, JString, required = false,
                                 default = nil)
  if valid_603296 != nil:
    section.add "X-Amz-Credential", valid_603296
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603298: Call_CancelJob_603285; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a job.
  ## 
  let valid = call_603298.validator(path, query, header, formData, body)
  let scheme = call_603298.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603298.url(scheme.get, call_603298.host, call_603298.base,
                         call_603298.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603298, url, valid)

proc call*(call_603299: Call_CancelJob_603285; jobId: string; body: JsonNode;
          force: bool = false): Recallable =
  ## cancelJob
  ## Cancels a job.
  ##   force: bool
  ##        : <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   body: JObject (required)
  var path_603300 = newJObject()
  var query_603301 = newJObject()
  var body_603302 = newJObject()
  add(query_603301, "force", newJBool(force))
  add(path_603300, "jobId", newJString(jobId))
  if body != nil:
    body_603302 = body
  result = call_603299.call(path_603300, query_603301, nil, nil, body_603302)

var cancelJob* = Call_CancelJob_603285(name: "cancelJob", meth: HttpMethod.HttpPut,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}/cancel",
                                    validator: validate_CancelJob_603286,
                                    base: "/", url: url_CancelJob_603287,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelJobExecution_603303 = ref object of OpenApiRestCall_602466
proc url_CancelJobExecution_603305(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CancelJobExecution_603304(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Cancels the execution of a job for a given thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing whose execution of the job will be canceled.
  ##   jobId: JString (required)
  ##        : The ID of the job to be canceled.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_603306 = path.getOrDefault("thingName")
  valid_603306 = validateParameter(valid_603306, JString, required = true,
                                 default = nil)
  if valid_603306 != nil:
    section.add "thingName", valid_603306
  var valid_603307 = path.getOrDefault("jobId")
  valid_603307 = validateParameter(valid_603307, JString, required = true,
                                 default = nil)
  if valid_603307 != nil:
    section.add "jobId", valid_603307
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
  section = newJObject()
  var valid_603308 = query.getOrDefault("force")
  valid_603308 = validateParameter(valid_603308, JBool, required = false, default = nil)
  if valid_603308 != nil:
    section.add "force", valid_603308
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603309 = header.getOrDefault("X-Amz-Date")
  valid_603309 = validateParameter(valid_603309, JString, required = false,
                                 default = nil)
  if valid_603309 != nil:
    section.add "X-Amz-Date", valid_603309
  var valid_603310 = header.getOrDefault("X-Amz-Security-Token")
  valid_603310 = validateParameter(valid_603310, JString, required = false,
                                 default = nil)
  if valid_603310 != nil:
    section.add "X-Amz-Security-Token", valid_603310
  var valid_603311 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603311 = validateParameter(valid_603311, JString, required = false,
                                 default = nil)
  if valid_603311 != nil:
    section.add "X-Amz-Content-Sha256", valid_603311
  var valid_603312 = header.getOrDefault("X-Amz-Algorithm")
  valid_603312 = validateParameter(valid_603312, JString, required = false,
                                 default = nil)
  if valid_603312 != nil:
    section.add "X-Amz-Algorithm", valid_603312
  var valid_603313 = header.getOrDefault("X-Amz-Signature")
  valid_603313 = validateParameter(valid_603313, JString, required = false,
                                 default = nil)
  if valid_603313 != nil:
    section.add "X-Amz-Signature", valid_603313
  var valid_603314 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603314 = validateParameter(valid_603314, JString, required = false,
                                 default = nil)
  if valid_603314 != nil:
    section.add "X-Amz-SignedHeaders", valid_603314
  var valid_603315 = header.getOrDefault("X-Amz-Credential")
  valid_603315 = validateParameter(valid_603315, JString, required = false,
                                 default = nil)
  if valid_603315 != nil:
    section.add "X-Amz-Credential", valid_603315
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603317: Call_CancelJobExecution_603303; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels the execution of a job for a given thing.
  ## 
  let valid = call_603317.validator(path, query, header, formData, body)
  let scheme = call_603317.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603317.url(scheme.get, call_603317.host, call_603317.base,
                         call_603317.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603317, url, valid)

proc call*(call_603318: Call_CancelJobExecution_603303; thingName: string;
          jobId: string; body: JsonNode; force: bool = false): Recallable =
  ## cancelJobExecution
  ## Cancels the execution of a job for a given thing.
  ##   force: bool
  ##        : <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
  ##   thingName: string (required)
  ##            : The name of the thing whose execution of the job will be canceled.
  ##   jobId: string (required)
  ##        : The ID of the job to be canceled.
  ##   body: JObject (required)
  var path_603319 = newJObject()
  var query_603320 = newJObject()
  var body_603321 = newJObject()
  add(query_603320, "force", newJBool(force))
  add(path_603319, "thingName", newJString(thingName))
  add(path_603319, "jobId", newJString(jobId))
  if body != nil:
    body_603321 = body
  result = call_603318.call(path_603319, query_603320, nil, nil, body_603321)

var cancelJobExecution* = Call_CancelJobExecution_603303(
    name: "cancelJobExecution", meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/things/{thingName}/jobs/{jobId}/cancel",
    validator: validate_CancelJobExecution_603304, base: "/",
    url: url_CancelJobExecution_603305, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetDefaultAuthorizer_603334 = ref object of OpenApiRestCall_602466
proc url_SetDefaultAuthorizer_603336(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_SetDefaultAuthorizer_603335(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603337 = header.getOrDefault("X-Amz-Date")
  valid_603337 = validateParameter(valid_603337, JString, required = false,
                                 default = nil)
  if valid_603337 != nil:
    section.add "X-Amz-Date", valid_603337
  var valid_603338 = header.getOrDefault("X-Amz-Security-Token")
  valid_603338 = validateParameter(valid_603338, JString, required = false,
                                 default = nil)
  if valid_603338 != nil:
    section.add "X-Amz-Security-Token", valid_603338
  var valid_603339 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603339 = validateParameter(valid_603339, JString, required = false,
                                 default = nil)
  if valid_603339 != nil:
    section.add "X-Amz-Content-Sha256", valid_603339
  var valid_603340 = header.getOrDefault("X-Amz-Algorithm")
  valid_603340 = validateParameter(valid_603340, JString, required = false,
                                 default = nil)
  if valid_603340 != nil:
    section.add "X-Amz-Algorithm", valid_603340
  var valid_603341 = header.getOrDefault("X-Amz-Signature")
  valid_603341 = validateParameter(valid_603341, JString, required = false,
                                 default = nil)
  if valid_603341 != nil:
    section.add "X-Amz-Signature", valid_603341
  var valid_603342 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603342 = validateParameter(valid_603342, JString, required = false,
                                 default = nil)
  if valid_603342 != nil:
    section.add "X-Amz-SignedHeaders", valid_603342
  var valid_603343 = header.getOrDefault("X-Amz-Credential")
  valid_603343 = validateParameter(valid_603343, JString, required = false,
                                 default = nil)
  if valid_603343 != nil:
    section.add "X-Amz-Credential", valid_603343
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603345: Call_SetDefaultAuthorizer_603334; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ## 
  let valid = call_603345.validator(path, query, header, formData, body)
  let scheme = call_603345.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603345.url(scheme.get, call_603345.host, call_603345.base,
                         call_603345.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603345, url, valid)

proc call*(call_603346: Call_SetDefaultAuthorizer_603334; body: JsonNode): Recallable =
  ## setDefaultAuthorizer
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ##   body: JObject (required)
  var body_603347 = newJObject()
  if body != nil:
    body_603347 = body
  result = call_603346.call(nil, nil, nil, nil, body_603347)

var setDefaultAuthorizer* = Call_SetDefaultAuthorizer_603334(
    name: "setDefaultAuthorizer", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_SetDefaultAuthorizer_603335, base: "/",
    url: url_SetDefaultAuthorizer_603336, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeDefaultAuthorizer_603322 = ref object of OpenApiRestCall_602466
proc url_DescribeDefaultAuthorizer_603324(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DescribeDefaultAuthorizer_603323(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes the default authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603325 = header.getOrDefault("X-Amz-Date")
  valid_603325 = validateParameter(valid_603325, JString, required = false,
                                 default = nil)
  if valid_603325 != nil:
    section.add "X-Amz-Date", valid_603325
  var valid_603326 = header.getOrDefault("X-Amz-Security-Token")
  valid_603326 = validateParameter(valid_603326, JString, required = false,
                                 default = nil)
  if valid_603326 != nil:
    section.add "X-Amz-Security-Token", valid_603326
  var valid_603327 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603327 = validateParameter(valid_603327, JString, required = false,
                                 default = nil)
  if valid_603327 != nil:
    section.add "X-Amz-Content-Sha256", valid_603327
  var valid_603328 = header.getOrDefault("X-Amz-Algorithm")
  valid_603328 = validateParameter(valid_603328, JString, required = false,
                                 default = nil)
  if valid_603328 != nil:
    section.add "X-Amz-Algorithm", valid_603328
  var valid_603329 = header.getOrDefault("X-Amz-Signature")
  valid_603329 = validateParameter(valid_603329, JString, required = false,
                                 default = nil)
  if valid_603329 != nil:
    section.add "X-Amz-Signature", valid_603329
  var valid_603330 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603330 = validateParameter(valid_603330, JString, required = false,
                                 default = nil)
  if valid_603330 != nil:
    section.add "X-Amz-SignedHeaders", valid_603330
  var valid_603331 = header.getOrDefault("X-Amz-Credential")
  valid_603331 = validateParameter(valid_603331, JString, required = false,
                                 default = nil)
  if valid_603331 != nil:
    section.add "X-Amz-Credential", valid_603331
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603332: Call_DescribeDefaultAuthorizer_603322; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes the default authorizer.
  ## 
  let valid = call_603332.validator(path, query, header, formData, body)
  let scheme = call_603332.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603332.url(scheme.get, call_603332.host, call_603332.base,
                         call_603332.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603332, url, valid)

proc call*(call_603333: Call_DescribeDefaultAuthorizer_603322): Recallable =
  ## describeDefaultAuthorizer
  ## Describes the default authorizer.
  result = call_603333.call(nil, nil, nil, nil, nil)

var describeDefaultAuthorizer* = Call_DescribeDefaultAuthorizer_603322(
    name: "describeDefaultAuthorizer", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_DescribeDefaultAuthorizer_603323, base: "/",
    url: url_DescribeDefaultAuthorizer_603324,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ClearDefaultAuthorizer_603348 = ref object of OpenApiRestCall_602466
proc url_ClearDefaultAuthorizer_603350(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ClearDefaultAuthorizer_603349(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Clears the default authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603351 = header.getOrDefault("X-Amz-Date")
  valid_603351 = validateParameter(valid_603351, JString, required = false,
                                 default = nil)
  if valid_603351 != nil:
    section.add "X-Amz-Date", valid_603351
  var valid_603352 = header.getOrDefault("X-Amz-Security-Token")
  valid_603352 = validateParameter(valid_603352, JString, required = false,
                                 default = nil)
  if valid_603352 != nil:
    section.add "X-Amz-Security-Token", valid_603352
  var valid_603353 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603353 = validateParameter(valid_603353, JString, required = false,
                                 default = nil)
  if valid_603353 != nil:
    section.add "X-Amz-Content-Sha256", valid_603353
  var valid_603354 = header.getOrDefault("X-Amz-Algorithm")
  valid_603354 = validateParameter(valid_603354, JString, required = false,
                                 default = nil)
  if valid_603354 != nil:
    section.add "X-Amz-Algorithm", valid_603354
  var valid_603355 = header.getOrDefault("X-Amz-Signature")
  valid_603355 = validateParameter(valid_603355, JString, required = false,
                                 default = nil)
  if valid_603355 != nil:
    section.add "X-Amz-Signature", valid_603355
  var valid_603356 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603356 = validateParameter(valid_603356, JString, required = false,
                                 default = nil)
  if valid_603356 != nil:
    section.add "X-Amz-SignedHeaders", valid_603356
  var valid_603357 = header.getOrDefault("X-Amz-Credential")
  valid_603357 = validateParameter(valid_603357, JString, required = false,
                                 default = nil)
  if valid_603357 != nil:
    section.add "X-Amz-Credential", valid_603357
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603358: Call_ClearDefaultAuthorizer_603348; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Clears the default authorizer.
  ## 
  let valid = call_603358.validator(path, query, header, formData, body)
  let scheme = call_603358.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603358.url(scheme.get, call_603358.host, call_603358.base,
                         call_603358.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603358, url, valid)

proc call*(call_603359: Call_ClearDefaultAuthorizer_603348): Recallable =
  ## clearDefaultAuthorizer
  ## Clears the default authorizer.
  result = call_603359.call(nil, nil, nil, nil, nil)

var clearDefaultAuthorizer* = Call_ClearDefaultAuthorizer_603348(
    name: "clearDefaultAuthorizer", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_ClearDefaultAuthorizer_603349, base: "/",
    url: url_ClearDefaultAuthorizer_603350, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateAuthorizer_603374 = ref object of OpenApiRestCall_602466
proc url_UpdateAuthorizer_603376(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateAuthorizer_603375(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Updates an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_603377 = path.getOrDefault("authorizerName")
  valid_603377 = validateParameter(valid_603377, JString, required = true,
                                 default = nil)
  if valid_603377 != nil:
    section.add "authorizerName", valid_603377
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603378 = header.getOrDefault("X-Amz-Date")
  valid_603378 = validateParameter(valid_603378, JString, required = false,
                                 default = nil)
  if valid_603378 != nil:
    section.add "X-Amz-Date", valid_603378
  var valid_603379 = header.getOrDefault("X-Amz-Security-Token")
  valid_603379 = validateParameter(valid_603379, JString, required = false,
                                 default = nil)
  if valid_603379 != nil:
    section.add "X-Amz-Security-Token", valid_603379
  var valid_603380 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603380 = validateParameter(valid_603380, JString, required = false,
                                 default = nil)
  if valid_603380 != nil:
    section.add "X-Amz-Content-Sha256", valid_603380
  var valid_603381 = header.getOrDefault("X-Amz-Algorithm")
  valid_603381 = validateParameter(valid_603381, JString, required = false,
                                 default = nil)
  if valid_603381 != nil:
    section.add "X-Amz-Algorithm", valid_603381
  var valid_603382 = header.getOrDefault("X-Amz-Signature")
  valid_603382 = validateParameter(valid_603382, JString, required = false,
                                 default = nil)
  if valid_603382 != nil:
    section.add "X-Amz-Signature", valid_603382
  var valid_603383 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603383 = validateParameter(valid_603383, JString, required = false,
                                 default = nil)
  if valid_603383 != nil:
    section.add "X-Amz-SignedHeaders", valid_603383
  var valid_603384 = header.getOrDefault("X-Amz-Credential")
  valid_603384 = validateParameter(valid_603384, JString, required = false,
                                 default = nil)
  if valid_603384 != nil:
    section.add "X-Amz-Credential", valid_603384
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603386: Call_UpdateAuthorizer_603374; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an authorizer.
  ## 
  let valid = call_603386.validator(path, query, header, formData, body)
  let scheme = call_603386.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603386.url(scheme.get, call_603386.host, call_603386.base,
                         call_603386.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603386, url, valid)

proc call*(call_603387: Call_UpdateAuthorizer_603374; authorizerName: string;
          body: JsonNode): Recallable =
  ## updateAuthorizer
  ## Updates an authorizer.
  ##   authorizerName: string (required)
  ##                 : The authorizer name.
  ##   body: JObject (required)
  var path_603388 = newJObject()
  var body_603389 = newJObject()
  add(path_603388, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_603389 = body
  result = call_603387.call(path_603388, nil, nil, nil, body_603389)

var updateAuthorizer* = Call_UpdateAuthorizer_603374(name: "updateAuthorizer",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_UpdateAuthorizer_603375,
    base: "/", url: url_UpdateAuthorizer_603376,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateAuthorizer_603390 = ref object of OpenApiRestCall_602466
proc url_CreateAuthorizer_603392(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateAuthorizer_603391(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Creates an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_603393 = path.getOrDefault("authorizerName")
  valid_603393 = validateParameter(valid_603393, JString, required = true,
                                 default = nil)
  if valid_603393 != nil:
    section.add "authorizerName", valid_603393
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603394 = header.getOrDefault("X-Amz-Date")
  valid_603394 = validateParameter(valid_603394, JString, required = false,
                                 default = nil)
  if valid_603394 != nil:
    section.add "X-Amz-Date", valid_603394
  var valid_603395 = header.getOrDefault("X-Amz-Security-Token")
  valid_603395 = validateParameter(valid_603395, JString, required = false,
                                 default = nil)
  if valid_603395 != nil:
    section.add "X-Amz-Security-Token", valid_603395
  var valid_603396 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603396 = validateParameter(valid_603396, JString, required = false,
                                 default = nil)
  if valid_603396 != nil:
    section.add "X-Amz-Content-Sha256", valid_603396
  var valid_603397 = header.getOrDefault("X-Amz-Algorithm")
  valid_603397 = validateParameter(valid_603397, JString, required = false,
                                 default = nil)
  if valid_603397 != nil:
    section.add "X-Amz-Algorithm", valid_603397
  var valid_603398 = header.getOrDefault("X-Amz-Signature")
  valid_603398 = validateParameter(valid_603398, JString, required = false,
                                 default = nil)
  if valid_603398 != nil:
    section.add "X-Amz-Signature", valid_603398
  var valid_603399 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603399 = validateParameter(valid_603399, JString, required = false,
                                 default = nil)
  if valid_603399 != nil:
    section.add "X-Amz-SignedHeaders", valid_603399
  var valid_603400 = header.getOrDefault("X-Amz-Credential")
  valid_603400 = validateParameter(valid_603400, JString, required = false,
                                 default = nil)
  if valid_603400 != nil:
    section.add "X-Amz-Credential", valid_603400
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603402: Call_CreateAuthorizer_603390; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates an authorizer.
  ## 
  let valid = call_603402.validator(path, query, header, formData, body)
  let scheme = call_603402.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603402.url(scheme.get, call_603402.host, call_603402.base,
                         call_603402.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603402, url, valid)

proc call*(call_603403: Call_CreateAuthorizer_603390; authorizerName: string;
          body: JsonNode): Recallable =
  ## createAuthorizer
  ## Creates an authorizer.
  ##   authorizerName: string (required)
  ##                 : The authorizer name.
  ##   body: JObject (required)
  var path_603404 = newJObject()
  var body_603405 = newJObject()
  add(path_603404, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_603405 = body
  result = call_603403.call(path_603404, nil, nil, nil, body_603405)

var createAuthorizer* = Call_CreateAuthorizer_603390(name: "createAuthorizer",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_CreateAuthorizer_603391,
    base: "/", url: url_CreateAuthorizer_603392,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuthorizer_603360 = ref object of OpenApiRestCall_602466
proc url_DescribeAuthorizer_603362(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeAuthorizer_603361(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Describes an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The name of the authorizer to describe.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_603363 = path.getOrDefault("authorizerName")
  valid_603363 = validateParameter(valid_603363, JString, required = true,
                                 default = nil)
  if valid_603363 != nil:
    section.add "authorizerName", valid_603363
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603364 = header.getOrDefault("X-Amz-Date")
  valid_603364 = validateParameter(valid_603364, JString, required = false,
                                 default = nil)
  if valid_603364 != nil:
    section.add "X-Amz-Date", valid_603364
  var valid_603365 = header.getOrDefault("X-Amz-Security-Token")
  valid_603365 = validateParameter(valid_603365, JString, required = false,
                                 default = nil)
  if valid_603365 != nil:
    section.add "X-Amz-Security-Token", valid_603365
  var valid_603366 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603366 = validateParameter(valid_603366, JString, required = false,
                                 default = nil)
  if valid_603366 != nil:
    section.add "X-Amz-Content-Sha256", valid_603366
  var valid_603367 = header.getOrDefault("X-Amz-Algorithm")
  valid_603367 = validateParameter(valid_603367, JString, required = false,
                                 default = nil)
  if valid_603367 != nil:
    section.add "X-Amz-Algorithm", valid_603367
  var valid_603368 = header.getOrDefault("X-Amz-Signature")
  valid_603368 = validateParameter(valid_603368, JString, required = false,
                                 default = nil)
  if valid_603368 != nil:
    section.add "X-Amz-Signature", valid_603368
  var valid_603369 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603369 = validateParameter(valid_603369, JString, required = false,
                                 default = nil)
  if valid_603369 != nil:
    section.add "X-Amz-SignedHeaders", valid_603369
  var valid_603370 = header.getOrDefault("X-Amz-Credential")
  valid_603370 = validateParameter(valid_603370, JString, required = false,
                                 default = nil)
  if valid_603370 != nil:
    section.add "X-Amz-Credential", valid_603370
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603371: Call_DescribeAuthorizer_603360; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes an authorizer.
  ## 
  let valid = call_603371.validator(path, query, header, formData, body)
  let scheme = call_603371.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603371.url(scheme.get, call_603371.host, call_603371.base,
                         call_603371.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603371, url, valid)

proc call*(call_603372: Call_DescribeAuthorizer_603360; authorizerName: string): Recallable =
  ## describeAuthorizer
  ## Describes an authorizer.
  ##   authorizerName: string (required)
  ##                 : The name of the authorizer to describe.
  var path_603373 = newJObject()
  add(path_603373, "authorizerName", newJString(authorizerName))
  result = call_603372.call(path_603373, nil, nil, nil, nil)

var describeAuthorizer* = Call_DescribeAuthorizer_603360(
    name: "describeAuthorizer", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_DescribeAuthorizer_603361,
    base: "/", url: url_DescribeAuthorizer_603362,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteAuthorizer_603406 = ref object of OpenApiRestCall_602466
proc url_DeleteAuthorizer_603408(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteAuthorizer_603407(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Deletes an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The name of the authorizer to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_603409 = path.getOrDefault("authorizerName")
  valid_603409 = validateParameter(valid_603409, JString, required = true,
                                 default = nil)
  if valid_603409 != nil:
    section.add "authorizerName", valid_603409
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603410 = header.getOrDefault("X-Amz-Date")
  valid_603410 = validateParameter(valid_603410, JString, required = false,
                                 default = nil)
  if valid_603410 != nil:
    section.add "X-Amz-Date", valid_603410
  var valid_603411 = header.getOrDefault("X-Amz-Security-Token")
  valid_603411 = validateParameter(valid_603411, JString, required = false,
                                 default = nil)
  if valid_603411 != nil:
    section.add "X-Amz-Security-Token", valid_603411
  var valid_603412 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603412 = validateParameter(valid_603412, JString, required = false,
                                 default = nil)
  if valid_603412 != nil:
    section.add "X-Amz-Content-Sha256", valid_603412
  var valid_603413 = header.getOrDefault("X-Amz-Algorithm")
  valid_603413 = validateParameter(valid_603413, JString, required = false,
                                 default = nil)
  if valid_603413 != nil:
    section.add "X-Amz-Algorithm", valid_603413
  var valid_603414 = header.getOrDefault("X-Amz-Signature")
  valid_603414 = validateParameter(valid_603414, JString, required = false,
                                 default = nil)
  if valid_603414 != nil:
    section.add "X-Amz-Signature", valid_603414
  var valid_603415 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603415 = validateParameter(valid_603415, JString, required = false,
                                 default = nil)
  if valid_603415 != nil:
    section.add "X-Amz-SignedHeaders", valid_603415
  var valid_603416 = header.getOrDefault("X-Amz-Credential")
  valid_603416 = validateParameter(valid_603416, JString, required = false,
                                 default = nil)
  if valid_603416 != nil:
    section.add "X-Amz-Credential", valid_603416
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603417: Call_DeleteAuthorizer_603406; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an authorizer.
  ## 
  let valid = call_603417.validator(path, query, header, formData, body)
  let scheme = call_603417.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603417.url(scheme.get, call_603417.host, call_603417.base,
                         call_603417.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603417, url, valid)

proc call*(call_603418: Call_DeleteAuthorizer_603406; authorizerName: string): Recallable =
  ## deleteAuthorizer
  ## Deletes an authorizer.
  ##   authorizerName: string (required)
  ##                 : The name of the authorizer to delete.
  var path_603419 = newJObject()
  add(path_603419, "authorizerName", newJString(authorizerName))
  result = call_603418.call(path_603419, nil, nil, nil, nil)

var deleteAuthorizer* = Call_DeleteAuthorizer_603406(name: "deleteAuthorizer",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_DeleteAuthorizer_603407,
    base: "/", url: url_DeleteAuthorizer_603408,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateBillingGroup_603434 = ref object of OpenApiRestCall_602466
proc url_CreateBillingGroup_603436(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateBillingGroup_603435(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Creates a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name you wish to give to the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_603437 = path.getOrDefault("billingGroupName")
  valid_603437 = validateParameter(valid_603437, JString, required = true,
                                 default = nil)
  if valid_603437 != nil:
    section.add "billingGroupName", valid_603437
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603438 = header.getOrDefault("X-Amz-Date")
  valid_603438 = validateParameter(valid_603438, JString, required = false,
                                 default = nil)
  if valid_603438 != nil:
    section.add "X-Amz-Date", valid_603438
  var valid_603439 = header.getOrDefault("X-Amz-Security-Token")
  valid_603439 = validateParameter(valid_603439, JString, required = false,
                                 default = nil)
  if valid_603439 != nil:
    section.add "X-Amz-Security-Token", valid_603439
  var valid_603440 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603440 = validateParameter(valid_603440, JString, required = false,
                                 default = nil)
  if valid_603440 != nil:
    section.add "X-Amz-Content-Sha256", valid_603440
  var valid_603441 = header.getOrDefault("X-Amz-Algorithm")
  valid_603441 = validateParameter(valid_603441, JString, required = false,
                                 default = nil)
  if valid_603441 != nil:
    section.add "X-Amz-Algorithm", valid_603441
  var valid_603442 = header.getOrDefault("X-Amz-Signature")
  valid_603442 = validateParameter(valid_603442, JString, required = false,
                                 default = nil)
  if valid_603442 != nil:
    section.add "X-Amz-Signature", valid_603442
  var valid_603443 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603443 = validateParameter(valid_603443, JString, required = false,
                                 default = nil)
  if valid_603443 != nil:
    section.add "X-Amz-SignedHeaders", valid_603443
  var valid_603444 = header.getOrDefault("X-Amz-Credential")
  valid_603444 = validateParameter(valid_603444, JString, required = false,
                                 default = nil)
  if valid_603444 != nil:
    section.add "X-Amz-Credential", valid_603444
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603446: Call_CreateBillingGroup_603434; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a billing group.
  ## 
  let valid = call_603446.validator(path, query, header, formData, body)
  let scheme = call_603446.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603446.url(scheme.get, call_603446.host, call_603446.base,
                         call_603446.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603446, url, valid)

proc call*(call_603447: Call_CreateBillingGroup_603434; billingGroupName: string;
          body: JsonNode): Recallable =
  ## createBillingGroup
  ## Creates a billing group.
  ##   billingGroupName: string (required)
  ##                   : The name you wish to give to the billing group.
  ##   body: JObject (required)
  var path_603448 = newJObject()
  var body_603449 = newJObject()
  add(path_603448, "billingGroupName", newJString(billingGroupName))
  if body != nil:
    body_603449 = body
  result = call_603447.call(path_603448, nil, nil, nil, body_603449)

var createBillingGroup* = Call_CreateBillingGroup_603434(
    name: "createBillingGroup", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_CreateBillingGroup_603435, base: "/",
    url: url_CreateBillingGroup_603436, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeBillingGroup_603420 = ref object of OpenApiRestCall_602466
proc url_DescribeBillingGroup_603422(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeBillingGroup_603421(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_603423 = path.getOrDefault("billingGroupName")
  valid_603423 = validateParameter(valid_603423, JString, required = true,
                                 default = nil)
  if valid_603423 != nil:
    section.add "billingGroupName", valid_603423
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603424 = header.getOrDefault("X-Amz-Date")
  valid_603424 = validateParameter(valid_603424, JString, required = false,
                                 default = nil)
  if valid_603424 != nil:
    section.add "X-Amz-Date", valid_603424
  var valid_603425 = header.getOrDefault("X-Amz-Security-Token")
  valid_603425 = validateParameter(valid_603425, JString, required = false,
                                 default = nil)
  if valid_603425 != nil:
    section.add "X-Amz-Security-Token", valid_603425
  var valid_603426 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603426 = validateParameter(valid_603426, JString, required = false,
                                 default = nil)
  if valid_603426 != nil:
    section.add "X-Amz-Content-Sha256", valid_603426
  var valid_603427 = header.getOrDefault("X-Amz-Algorithm")
  valid_603427 = validateParameter(valid_603427, JString, required = false,
                                 default = nil)
  if valid_603427 != nil:
    section.add "X-Amz-Algorithm", valid_603427
  var valid_603428 = header.getOrDefault("X-Amz-Signature")
  valid_603428 = validateParameter(valid_603428, JString, required = false,
                                 default = nil)
  if valid_603428 != nil:
    section.add "X-Amz-Signature", valid_603428
  var valid_603429 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603429 = validateParameter(valid_603429, JString, required = false,
                                 default = nil)
  if valid_603429 != nil:
    section.add "X-Amz-SignedHeaders", valid_603429
  var valid_603430 = header.getOrDefault("X-Amz-Credential")
  valid_603430 = validateParameter(valid_603430, JString, required = false,
                                 default = nil)
  if valid_603430 != nil:
    section.add "X-Amz-Credential", valid_603430
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603431: Call_DescribeBillingGroup_603420; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about a billing group.
  ## 
  let valid = call_603431.validator(path, query, header, formData, body)
  let scheme = call_603431.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603431.url(scheme.get, call_603431.host, call_603431.base,
                         call_603431.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603431, url, valid)

proc call*(call_603432: Call_DescribeBillingGroup_603420; billingGroupName: string): Recallable =
  ## describeBillingGroup
  ## Returns information about a billing group.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_603433 = newJObject()
  add(path_603433, "billingGroupName", newJString(billingGroupName))
  result = call_603432.call(path_603433, nil, nil, nil, nil)

var describeBillingGroup* = Call_DescribeBillingGroup_603420(
    name: "describeBillingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_DescribeBillingGroup_603421, base: "/",
    url: url_DescribeBillingGroup_603422, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateBillingGroup_603466 = ref object of OpenApiRestCall_602466
proc url_UpdateBillingGroup_603468(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateBillingGroup_603467(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Updates information about the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_603469 = path.getOrDefault("billingGroupName")
  valid_603469 = validateParameter(valid_603469, JString, required = true,
                                 default = nil)
  if valid_603469 != nil:
    section.add "billingGroupName", valid_603469
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603470 = header.getOrDefault("X-Amz-Date")
  valid_603470 = validateParameter(valid_603470, JString, required = false,
                                 default = nil)
  if valid_603470 != nil:
    section.add "X-Amz-Date", valid_603470
  var valid_603471 = header.getOrDefault("X-Amz-Security-Token")
  valid_603471 = validateParameter(valid_603471, JString, required = false,
                                 default = nil)
  if valid_603471 != nil:
    section.add "X-Amz-Security-Token", valid_603471
  var valid_603472 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603472 = validateParameter(valid_603472, JString, required = false,
                                 default = nil)
  if valid_603472 != nil:
    section.add "X-Amz-Content-Sha256", valid_603472
  var valid_603473 = header.getOrDefault("X-Amz-Algorithm")
  valid_603473 = validateParameter(valid_603473, JString, required = false,
                                 default = nil)
  if valid_603473 != nil:
    section.add "X-Amz-Algorithm", valid_603473
  var valid_603474 = header.getOrDefault("X-Amz-Signature")
  valid_603474 = validateParameter(valid_603474, JString, required = false,
                                 default = nil)
  if valid_603474 != nil:
    section.add "X-Amz-Signature", valid_603474
  var valid_603475 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603475 = validateParameter(valid_603475, JString, required = false,
                                 default = nil)
  if valid_603475 != nil:
    section.add "X-Amz-SignedHeaders", valid_603475
  var valid_603476 = header.getOrDefault("X-Amz-Credential")
  valid_603476 = validateParameter(valid_603476, JString, required = false,
                                 default = nil)
  if valid_603476 != nil:
    section.add "X-Amz-Credential", valid_603476
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603478: Call_UpdateBillingGroup_603466; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates information about the billing group.
  ## 
  let valid = call_603478.validator(path, query, header, formData, body)
  let scheme = call_603478.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603478.url(scheme.get, call_603478.host, call_603478.base,
                         call_603478.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603478, url, valid)

proc call*(call_603479: Call_UpdateBillingGroup_603466; billingGroupName: string;
          body: JsonNode): Recallable =
  ## updateBillingGroup
  ## Updates information about the billing group.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  ##   body: JObject (required)
  var path_603480 = newJObject()
  var body_603481 = newJObject()
  add(path_603480, "billingGroupName", newJString(billingGroupName))
  if body != nil:
    body_603481 = body
  result = call_603479.call(path_603480, nil, nil, nil, body_603481)

var updateBillingGroup* = Call_UpdateBillingGroup_603466(
    name: "updateBillingGroup", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_UpdateBillingGroup_603467, base: "/",
    url: url_UpdateBillingGroup_603468, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteBillingGroup_603450 = ref object of OpenApiRestCall_602466
proc url_DeleteBillingGroup_603452(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteBillingGroup_603451(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deletes the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_603453 = path.getOrDefault("billingGroupName")
  valid_603453 = validateParameter(valid_603453, JString, required = true,
                                 default = nil)
  if valid_603453 != nil:
    section.add "billingGroupName", valid_603453
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.
  section = newJObject()
  var valid_603454 = query.getOrDefault("expectedVersion")
  valid_603454 = validateParameter(valid_603454, JInt, required = false, default = nil)
  if valid_603454 != nil:
    section.add "expectedVersion", valid_603454
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603455 = header.getOrDefault("X-Amz-Date")
  valid_603455 = validateParameter(valid_603455, JString, required = false,
                                 default = nil)
  if valid_603455 != nil:
    section.add "X-Amz-Date", valid_603455
  var valid_603456 = header.getOrDefault("X-Amz-Security-Token")
  valid_603456 = validateParameter(valid_603456, JString, required = false,
                                 default = nil)
  if valid_603456 != nil:
    section.add "X-Amz-Security-Token", valid_603456
  var valid_603457 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603457 = validateParameter(valid_603457, JString, required = false,
                                 default = nil)
  if valid_603457 != nil:
    section.add "X-Amz-Content-Sha256", valid_603457
  var valid_603458 = header.getOrDefault("X-Amz-Algorithm")
  valid_603458 = validateParameter(valid_603458, JString, required = false,
                                 default = nil)
  if valid_603458 != nil:
    section.add "X-Amz-Algorithm", valid_603458
  var valid_603459 = header.getOrDefault("X-Amz-Signature")
  valid_603459 = validateParameter(valid_603459, JString, required = false,
                                 default = nil)
  if valid_603459 != nil:
    section.add "X-Amz-Signature", valid_603459
  var valid_603460 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603460 = validateParameter(valid_603460, JString, required = false,
                                 default = nil)
  if valid_603460 != nil:
    section.add "X-Amz-SignedHeaders", valid_603460
  var valid_603461 = header.getOrDefault("X-Amz-Credential")
  valid_603461 = validateParameter(valid_603461, JString, required = false,
                                 default = nil)
  if valid_603461 != nil:
    section.add "X-Amz-Credential", valid_603461
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603462: Call_DeleteBillingGroup_603450; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the billing group.
  ## 
  let valid = call_603462.validator(path, query, header, formData, body)
  let scheme = call_603462.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603462.url(scheme.get, call_603462.host, call_603462.base,
                         call_603462.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603462, url, valid)

proc call*(call_603463: Call_DeleteBillingGroup_603450; billingGroupName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteBillingGroup
  ## Deletes the billing group.
  ##   expectedVersion: int
  ##                  : The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_603464 = newJObject()
  var query_603465 = newJObject()
  add(query_603465, "expectedVersion", newJInt(expectedVersion))
  add(path_603464, "billingGroupName", newJString(billingGroupName))
  result = call_603463.call(path_603464, query_603465, nil, nil, nil)

var deleteBillingGroup* = Call_DeleteBillingGroup_603450(
    name: "deleteBillingGroup", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_DeleteBillingGroup_603451, base: "/",
    url: url_DeleteBillingGroup_603452, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateCertificateFromCsr_603498 = ref object of OpenApiRestCall_602466
proc url_CreateCertificateFromCsr_603500(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CreateCertificateFromCsr_603499(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_603501 = query.getOrDefault("setAsActive")
  valid_603501 = validateParameter(valid_603501, JBool, required = false, default = nil)
  if valid_603501 != nil:
    section.add "setAsActive", valid_603501
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603502 = header.getOrDefault("X-Amz-Date")
  valid_603502 = validateParameter(valid_603502, JString, required = false,
                                 default = nil)
  if valid_603502 != nil:
    section.add "X-Amz-Date", valid_603502
  var valid_603503 = header.getOrDefault("X-Amz-Security-Token")
  valid_603503 = validateParameter(valid_603503, JString, required = false,
                                 default = nil)
  if valid_603503 != nil:
    section.add "X-Amz-Security-Token", valid_603503
  var valid_603504 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603504 = validateParameter(valid_603504, JString, required = false,
                                 default = nil)
  if valid_603504 != nil:
    section.add "X-Amz-Content-Sha256", valid_603504
  var valid_603505 = header.getOrDefault("X-Amz-Algorithm")
  valid_603505 = validateParameter(valid_603505, JString, required = false,
                                 default = nil)
  if valid_603505 != nil:
    section.add "X-Amz-Algorithm", valid_603505
  var valid_603506 = header.getOrDefault("X-Amz-Signature")
  valid_603506 = validateParameter(valid_603506, JString, required = false,
                                 default = nil)
  if valid_603506 != nil:
    section.add "X-Amz-Signature", valid_603506
  var valid_603507 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603507 = validateParameter(valid_603507, JString, required = false,
                                 default = nil)
  if valid_603507 != nil:
    section.add "X-Amz-SignedHeaders", valid_603507
  var valid_603508 = header.getOrDefault("X-Amz-Credential")
  valid_603508 = validateParameter(valid_603508, JString, required = false,
                                 default = nil)
  if valid_603508 != nil:
    section.add "X-Amz-Credential", valid_603508
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603510: Call_CreateCertificateFromCsr_603498; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ## 
  let valid = call_603510.validator(path, query, header, formData, body)
  let scheme = call_603510.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603510.url(scheme.get, call_603510.host, call_603510.base,
                         call_603510.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603510, url, valid)

proc call*(call_603511: Call_CreateCertificateFromCsr_603498; body: JsonNode;
          setAsActive: bool = false): Recallable =
  ## createCertificateFromCsr
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  ##   body: JObject (required)
  var query_603512 = newJObject()
  var body_603513 = newJObject()
  add(query_603512, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_603513 = body
  result = call_603511.call(nil, query_603512, nil, nil, body_603513)

var createCertificateFromCsr* = Call_CreateCertificateFromCsr_603498(
    name: "createCertificateFromCsr", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/certificates",
    validator: validate_CreateCertificateFromCsr_603499, base: "/",
    url: url_CreateCertificateFromCsr_603500, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCertificates_603482 = ref object of OpenApiRestCall_602466
proc url_ListCertificates_603484(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListCertificates_603483(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  section = newJObject()
  var valid_603485 = query.getOrDefault("marker")
  valid_603485 = validateParameter(valid_603485, JString, required = false,
                                 default = nil)
  if valid_603485 != nil:
    section.add "marker", valid_603485
  var valid_603486 = query.getOrDefault("pageSize")
  valid_603486 = validateParameter(valid_603486, JInt, required = false, default = nil)
  if valid_603486 != nil:
    section.add "pageSize", valid_603486
  var valid_603487 = query.getOrDefault("isAscendingOrder")
  valid_603487 = validateParameter(valid_603487, JBool, required = false, default = nil)
  if valid_603487 != nil:
    section.add "isAscendingOrder", valid_603487
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603488 = header.getOrDefault("X-Amz-Date")
  valid_603488 = validateParameter(valid_603488, JString, required = false,
                                 default = nil)
  if valid_603488 != nil:
    section.add "X-Amz-Date", valid_603488
  var valid_603489 = header.getOrDefault("X-Amz-Security-Token")
  valid_603489 = validateParameter(valid_603489, JString, required = false,
                                 default = nil)
  if valid_603489 != nil:
    section.add "X-Amz-Security-Token", valid_603489
  var valid_603490 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603490 = validateParameter(valid_603490, JString, required = false,
                                 default = nil)
  if valid_603490 != nil:
    section.add "X-Amz-Content-Sha256", valid_603490
  var valid_603491 = header.getOrDefault("X-Amz-Algorithm")
  valid_603491 = validateParameter(valid_603491, JString, required = false,
                                 default = nil)
  if valid_603491 != nil:
    section.add "X-Amz-Algorithm", valid_603491
  var valid_603492 = header.getOrDefault("X-Amz-Signature")
  valid_603492 = validateParameter(valid_603492, JString, required = false,
                                 default = nil)
  if valid_603492 != nil:
    section.add "X-Amz-Signature", valid_603492
  var valid_603493 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603493 = validateParameter(valid_603493, JString, required = false,
                                 default = nil)
  if valid_603493 != nil:
    section.add "X-Amz-SignedHeaders", valid_603493
  var valid_603494 = header.getOrDefault("X-Amz-Credential")
  valid_603494 = validateParameter(valid_603494, JString, required = false,
                                 default = nil)
  if valid_603494 != nil:
    section.add "X-Amz-Credential", valid_603494
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603495: Call_ListCertificates_603482; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  let valid = call_603495.validator(path, query, header, formData, body)
  let scheme = call_603495.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603495.url(scheme.get, call_603495.host, call_603495.base,
                         call_603495.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603495, url, valid)

proc call*(call_603496: Call_ListCertificates_603482; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listCertificates
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  var query_603497 = newJObject()
  add(query_603497, "marker", newJString(marker))
  add(query_603497, "pageSize", newJInt(pageSize))
  add(query_603497, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_603496.call(nil, query_603497, nil, nil, nil)

var listCertificates* = Call_ListCertificates_603482(name: "listCertificates",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/certificates",
    validator: validate_ListCertificates_603483, base: "/",
    url: url_ListCertificates_603484, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateDynamicThingGroup_603514 = ref object of OpenApiRestCall_602466
proc url_CreateDynamicThingGroup_603516(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateDynamicThingGroup_603515(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The dynamic thing group name to create.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_603517 = path.getOrDefault("thingGroupName")
  valid_603517 = validateParameter(valid_603517, JString, required = true,
                                 default = nil)
  if valid_603517 != nil:
    section.add "thingGroupName", valid_603517
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603518 = header.getOrDefault("X-Amz-Date")
  valid_603518 = validateParameter(valid_603518, JString, required = false,
                                 default = nil)
  if valid_603518 != nil:
    section.add "X-Amz-Date", valid_603518
  var valid_603519 = header.getOrDefault("X-Amz-Security-Token")
  valid_603519 = validateParameter(valid_603519, JString, required = false,
                                 default = nil)
  if valid_603519 != nil:
    section.add "X-Amz-Security-Token", valid_603519
  var valid_603520 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603520 = validateParameter(valid_603520, JString, required = false,
                                 default = nil)
  if valid_603520 != nil:
    section.add "X-Amz-Content-Sha256", valid_603520
  var valid_603521 = header.getOrDefault("X-Amz-Algorithm")
  valid_603521 = validateParameter(valid_603521, JString, required = false,
                                 default = nil)
  if valid_603521 != nil:
    section.add "X-Amz-Algorithm", valid_603521
  var valid_603522 = header.getOrDefault("X-Amz-Signature")
  valid_603522 = validateParameter(valid_603522, JString, required = false,
                                 default = nil)
  if valid_603522 != nil:
    section.add "X-Amz-Signature", valid_603522
  var valid_603523 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603523 = validateParameter(valid_603523, JString, required = false,
                                 default = nil)
  if valid_603523 != nil:
    section.add "X-Amz-SignedHeaders", valid_603523
  var valid_603524 = header.getOrDefault("X-Amz-Credential")
  valid_603524 = validateParameter(valid_603524, JString, required = false,
                                 default = nil)
  if valid_603524 != nil:
    section.add "X-Amz-Credential", valid_603524
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603526: Call_CreateDynamicThingGroup_603514; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a dynamic thing group.
  ## 
  let valid = call_603526.validator(path, query, header, formData, body)
  let scheme = call_603526.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603526.url(scheme.get, call_603526.host, call_603526.base,
                         call_603526.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603526, url, valid)

proc call*(call_603527: Call_CreateDynamicThingGroup_603514; body: JsonNode;
          thingGroupName: string): Recallable =
  ## createDynamicThingGroup
  ## Creates a dynamic thing group.
  ##   body: JObject (required)
  ##   thingGroupName: string (required)
  ##                 : The dynamic thing group name to create.
  var path_603528 = newJObject()
  var body_603529 = newJObject()
  if body != nil:
    body_603529 = body
  add(path_603528, "thingGroupName", newJString(thingGroupName))
  result = call_603527.call(path_603528, nil, nil, nil, body_603529)

var createDynamicThingGroup* = Call_CreateDynamicThingGroup_603514(
    name: "createDynamicThingGroup", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_CreateDynamicThingGroup_603515, base: "/",
    url: url_CreateDynamicThingGroup_603516, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateDynamicThingGroup_603546 = ref object of OpenApiRestCall_602466
proc url_UpdateDynamicThingGroup_603548(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateDynamicThingGroup_603547(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the dynamic thing group to update.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_603549 = path.getOrDefault("thingGroupName")
  valid_603549 = validateParameter(valid_603549, JString, required = true,
                                 default = nil)
  if valid_603549 != nil:
    section.add "thingGroupName", valid_603549
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603550 = header.getOrDefault("X-Amz-Date")
  valid_603550 = validateParameter(valid_603550, JString, required = false,
                                 default = nil)
  if valid_603550 != nil:
    section.add "X-Amz-Date", valid_603550
  var valid_603551 = header.getOrDefault("X-Amz-Security-Token")
  valid_603551 = validateParameter(valid_603551, JString, required = false,
                                 default = nil)
  if valid_603551 != nil:
    section.add "X-Amz-Security-Token", valid_603551
  var valid_603552 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603552 = validateParameter(valid_603552, JString, required = false,
                                 default = nil)
  if valid_603552 != nil:
    section.add "X-Amz-Content-Sha256", valid_603552
  var valid_603553 = header.getOrDefault("X-Amz-Algorithm")
  valid_603553 = validateParameter(valid_603553, JString, required = false,
                                 default = nil)
  if valid_603553 != nil:
    section.add "X-Amz-Algorithm", valid_603553
  var valid_603554 = header.getOrDefault("X-Amz-Signature")
  valid_603554 = validateParameter(valid_603554, JString, required = false,
                                 default = nil)
  if valid_603554 != nil:
    section.add "X-Amz-Signature", valid_603554
  var valid_603555 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603555 = validateParameter(valid_603555, JString, required = false,
                                 default = nil)
  if valid_603555 != nil:
    section.add "X-Amz-SignedHeaders", valid_603555
  var valid_603556 = header.getOrDefault("X-Amz-Credential")
  valid_603556 = validateParameter(valid_603556, JString, required = false,
                                 default = nil)
  if valid_603556 != nil:
    section.add "X-Amz-Credential", valid_603556
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603558: Call_UpdateDynamicThingGroup_603546; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a dynamic thing group.
  ## 
  let valid = call_603558.validator(path, query, header, formData, body)
  let scheme = call_603558.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603558.url(scheme.get, call_603558.host, call_603558.base,
                         call_603558.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603558, url, valid)

proc call*(call_603559: Call_UpdateDynamicThingGroup_603546; body: JsonNode;
          thingGroupName: string): Recallable =
  ## updateDynamicThingGroup
  ## Updates a dynamic thing group.
  ##   body: JObject (required)
  ##   thingGroupName: string (required)
  ##                 : The name of the dynamic thing group to update.
  var path_603560 = newJObject()
  var body_603561 = newJObject()
  if body != nil:
    body_603561 = body
  add(path_603560, "thingGroupName", newJString(thingGroupName))
  result = call_603559.call(path_603560, nil, nil, nil, body_603561)

var updateDynamicThingGroup* = Call_UpdateDynamicThingGroup_603546(
    name: "updateDynamicThingGroup", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_UpdateDynamicThingGroup_603547, base: "/",
    url: url_UpdateDynamicThingGroup_603548, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteDynamicThingGroup_603530 = ref object of OpenApiRestCall_602466
proc url_DeleteDynamicThingGroup_603532(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteDynamicThingGroup_603531(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the dynamic thing group to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_603533 = path.getOrDefault("thingGroupName")
  valid_603533 = validateParameter(valid_603533, JString, required = true,
                                 default = nil)
  if valid_603533 != nil:
    section.add "thingGroupName", valid_603533
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the dynamic thing group to delete.
  section = newJObject()
  var valid_603534 = query.getOrDefault("expectedVersion")
  valid_603534 = validateParameter(valid_603534, JInt, required = false, default = nil)
  if valid_603534 != nil:
    section.add "expectedVersion", valid_603534
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603535 = header.getOrDefault("X-Amz-Date")
  valid_603535 = validateParameter(valid_603535, JString, required = false,
                                 default = nil)
  if valid_603535 != nil:
    section.add "X-Amz-Date", valid_603535
  var valid_603536 = header.getOrDefault("X-Amz-Security-Token")
  valid_603536 = validateParameter(valid_603536, JString, required = false,
                                 default = nil)
  if valid_603536 != nil:
    section.add "X-Amz-Security-Token", valid_603536
  var valid_603537 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603537 = validateParameter(valid_603537, JString, required = false,
                                 default = nil)
  if valid_603537 != nil:
    section.add "X-Amz-Content-Sha256", valid_603537
  var valid_603538 = header.getOrDefault("X-Amz-Algorithm")
  valid_603538 = validateParameter(valid_603538, JString, required = false,
                                 default = nil)
  if valid_603538 != nil:
    section.add "X-Amz-Algorithm", valid_603538
  var valid_603539 = header.getOrDefault("X-Amz-Signature")
  valid_603539 = validateParameter(valid_603539, JString, required = false,
                                 default = nil)
  if valid_603539 != nil:
    section.add "X-Amz-Signature", valid_603539
  var valid_603540 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603540 = validateParameter(valid_603540, JString, required = false,
                                 default = nil)
  if valid_603540 != nil:
    section.add "X-Amz-SignedHeaders", valid_603540
  var valid_603541 = header.getOrDefault("X-Amz-Credential")
  valid_603541 = validateParameter(valid_603541, JString, required = false,
                                 default = nil)
  if valid_603541 != nil:
    section.add "X-Amz-Credential", valid_603541
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603542: Call_DeleteDynamicThingGroup_603530; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a dynamic thing group.
  ## 
  let valid = call_603542.validator(path, query, header, formData, body)
  let scheme = call_603542.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603542.url(scheme.get, call_603542.host, call_603542.base,
                         call_603542.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603542, url, valid)

proc call*(call_603543: Call_DeleteDynamicThingGroup_603530;
          thingGroupName: string; expectedVersion: int = 0): Recallable =
  ## deleteDynamicThingGroup
  ## Deletes a dynamic thing group.
  ##   expectedVersion: int
  ##                  : The expected version of the dynamic thing group to delete.
  ##   thingGroupName: string (required)
  ##                 : The name of the dynamic thing group to delete.
  var path_603544 = newJObject()
  var query_603545 = newJObject()
  add(query_603545, "expectedVersion", newJInt(expectedVersion))
  add(path_603544, "thingGroupName", newJString(thingGroupName))
  result = call_603543.call(path_603544, query_603545, nil, nil, nil)

var deleteDynamicThingGroup* = Call_DeleteDynamicThingGroup_603530(
    name: "deleteDynamicThingGroup", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_DeleteDynamicThingGroup_603531, base: "/",
    url: url_DeleteDynamicThingGroup_603532, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateJob_603576 = ref object of OpenApiRestCall_602466
proc url_CreateJob_603578(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateJob_603577(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_603579 = path.getOrDefault("jobId")
  valid_603579 = validateParameter(valid_603579, JString, required = true,
                                 default = nil)
  if valid_603579 != nil:
    section.add "jobId", valid_603579
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603580 = header.getOrDefault("X-Amz-Date")
  valid_603580 = validateParameter(valid_603580, JString, required = false,
                                 default = nil)
  if valid_603580 != nil:
    section.add "X-Amz-Date", valid_603580
  var valid_603581 = header.getOrDefault("X-Amz-Security-Token")
  valid_603581 = validateParameter(valid_603581, JString, required = false,
                                 default = nil)
  if valid_603581 != nil:
    section.add "X-Amz-Security-Token", valid_603581
  var valid_603582 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603582 = validateParameter(valid_603582, JString, required = false,
                                 default = nil)
  if valid_603582 != nil:
    section.add "X-Amz-Content-Sha256", valid_603582
  var valid_603583 = header.getOrDefault("X-Amz-Algorithm")
  valid_603583 = validateParameter(valid_603583, JString, required = false,
                                 default = nil)
  if valid_603583 != nil:
    section.add "X-Amz-Algorithm", valid_603583
  var valid_603584 = header.getOrDefault("X-Amz-Signature")
  valid_603584 = validateParameter(valid_603584, JString, required = false,
                                 default = nil)
  if valid_603584 != nil:
    section.add "X-Amz-Signature", valid_603584
  var valid_603585 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603585 = validateParameter(valid_603585, JString, required = false,
                                 default = nil)
  if valid_603585 != nil:
    section.add "X-Amz-SignedHeaders", valid_603585
  var valid_603586 = header.getOrDefault("X-Amz-Credential")
  valid_603586 = validateParameter(valid_603586, JString, required = false,
                                 default = nil)
  if valid_603586 != nil:
    section.add "X-Amz-Credential", valid_603586
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603588: Call_CreateJob_603576; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a job.
  ## 
  let valid = call_603588.validator(path, query, header, formData, body)
  let scheme = call_603588.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603588.url(scheme.get, call_603588.host, call_603588.base,
                         call_603588.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603588, url, valid)

proc call*(call_603589: Call_CreateJob_603576; jobId: string; body: JsonNode): Recallable =
  ## createJob
  ## Creates a job.
  ##   jobId: string (required)
  ##        : A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
  ##   body: JObject (required)
  var path_603590 = newJObject()
  var body_603591 = newJObject()
  add(path_603590, "jobId", newJString(jobId))
  if body != nil:
    body_603591 = body
  result = call_603589.call(path_603590, nil, nil, nil, body_603591)

var createJob* = Call_CreateJob_603576(name: "createJob", meth: HttpMethod.HttpPut,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_CreateJob_603577,
                                    base: "/", url: url_CreateJob_603578,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeJob_603562 = ref object of OpenApiRestCall_602466
proc url_DescribeJob_603564(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeJob_603563(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_603565 = path.getOrDefault("jobId")
  valid_603565 = validateParameter(valid_603565, JString, required = true,
                                 default = nil)
  if valid_603565 != nil:
    section.add "jobId", valid_603565
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603566 = header.getOrDefault("X-Amz-Date")
  valid_603566 = validateParameter(valid_603566, JString, required = false,
                                 default = nil)
  if valid_603566 != nil:
    section.add "X-Amz-Date", valid_603566
  var valid_603567 = header.getOrDefault("X-Amz-Security-Token")
  valid_603567 = validateParameter(valid_603567, JString, required = false,
                                 default = nil)
  if valid_603567 != nil:
    section.add "X-Amz-Security-Token", valid_603567
  var valid_603568 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603568 = validateParameter(valid_603568, JString, required = false,
                                 default = nil)
  if valid_603568 != nil:
    section.add "X-Amz-Content-Sha256", valid_603568
  var valid_603569 = header.getOrDefault("X-Amz-Algorithm")
  valid_603569 = validateParameter(valid_603569, JString, required = false,
                                 default = nil)
  if valid_603569 != nil:
    section.add "X-Amz-Algorithm", valid_603569
  var valid_603570 = header.getOrDefault("X-Amz-Signature")
  valid_603570 = validateParameter(valid_603570, JString, required = false,
                                 default = nil)
  if valid_603570 != nil:
    section.add "X-Amz-Signature", valid_603570
  var valid_603571 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603571 = validateParameter(valid_603571, JString, required = false,
                                 default = nil)
  if valid_603571 != nil:
    section.add "X-Amz-SignedHeaders", valid_603571
  var valid_603572 = header.getOrDefault("X-Amz-Credential")
  valid_603572 = validateParameter(valid_603572, JString, required = false,
                                 default = nil)
  if valid_603572 != nil:
    section.add "X-Amz-Credential", valid_603572
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603573: Call_DescribeJob_603562; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a job.
  ## 
  let valid = call_603573.validator(path, query, header, formData, body)
  let scheme = call_603573.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603573.url(scheme.get, call_603573.host, call_603573.base,
                         call_603573.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603573, url, valid)

proc call*(call_603574: Call_DescribeJob_603562; jobId: string): Recallable =
  ## describeJob
  ## Describes a job.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  var path_603575 = newJObject()
  add(path_603575, "jobId", newJString(jobId))
  result = call_603574.call(path_603575, nil, nil, nil, nil)

var describeJob* = Call_DescribeJob_603562(name: "describeJob",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/jobs/{jobId}",
                                        validator: validate_DescribeJob_603563,
                                        base: "/", url: url_DescribeJob_603564,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateJob_603608 = ref object of OpenApiRestCall_602466
proc url_UpdateJob_603610(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateJob_603609(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates supported fields of the specified job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The ID of the job to be updated.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_603611 = path.getOrDefault("jobId")
  valid_603611 = validateParameter(valid_603611, JString, required = true,
                                 default = nil)
  if valid_603611 != nil:
    section.add "jobId", valid_603611
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603612 = header.getOrDefault("X-Amz-Date")
  valid_603612 = validateParameter(valid_603612, JString, required = false,
                                 default = nil)
  if valid_603612 != nil:
    section.add "X-Amz-Date", valid_603612
  var valid_603613 = header.getOrDefault("X-Amz-Security-Token")
  valid_603613 = validateParameter(valid_603613, JString, required = false,
                                 default = nil)
  if valid_603613 != nil:
    section.add "X-Amz-Security-Token", valid_603613
  var valid_603614 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603614 = validateParameter(valid_603614, JString, required = false,
                                 default = nil)
  if valid_603614 != nil:
    section.add "X-Amz-Content-Sha256", valid_603614
  var valid_603615 = header.getOrDefault("X-Amz-Algorithm")
  valid_603615 = validateParameter(valid_603615, JString, required = false,
                                 default = nil)
  if valid_603615 != nil:
    section.add "X-Amz-Algorithm", valid_603615
  var valid_603616 = header.getOrDefault("X-Amz-Signature")
  valid_603616 = validateParameter(valid_603616, JString, required = false,
                                 default = nil)
  if valid_603616 != nil:
    section.add "X-Amz-Signature", valid_603616
  var valid_603617 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603617 = validateParameter(valid_603617, JString, required = false,
                                 default = nil)
  if valid_603617 != nil:
    section.add "X-Amz-SignedHeaders", valid_603617
  var valid_603618 = header.getOrDefault("X-Amz-Credential")
  valid_603618 = validateParameter(valid_603618, JString, required = false,
                                 default = nil)
  if valid_603618 != nil:
    section.add "X-Amz-Credential", valid_603618
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603620: Call_UpdateJob_603608; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates supported fields of the specified job.
  ## 
  let valid = call_603620.validator(path, query, header, formData, body)
  let scheme = call_603620.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603620.url(scheme.get, call_603620.host, call_603620.base,
                         call_603620.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603620, url, valid)

proc call*(call_603621: Call_UpdateJob_603608; jobId: string; body: JsonNode): Recallable =
  ## updateJob
  ## Updates supported fields of the specified job.
  ##   jobId: string (required)
  ##        : The ID of the job to be updated.
  ##   body: JObject (required)
  var path_603622 = newJObject()
  var body_603623 = newJObject()
  add(path_603622, "jobId", newJString(jobId))
  if body != nil:
    body_603623 = body
  result = call_603621.call(path_603622, nil, nil, nil, body_603623)

var updateJob* = Call_UpdateJob_603608(name: "updateJob", meth: HttpMethod.HttpPatch,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_UpdateJob_603609,
                                    base: "/", url: url_UpdateJob_603610,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteJob_603592 = ref object of OpenApiRestCall_602466
proc url_DeleteJob_603594(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteJob_603593(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_603595 = path.getOrDefault("jobId")
  valid_603595 = validateParameter(valid_603595, JString, required = true,
                                 default = nil)
  if valid_603595 != nil:
    section.add "jobId", valid_603595
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
  section = newJObject()
  var valid_603596 = query.getOrDefault("force")
  valid_603596 = validateParameter(valid_603596, JBool, required = false, default = nil)
  if valid_603596 != nil:
    section.add "force", valid_603596
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603597 = header.getOrDefault("X-Amz-Date")
  valid_603597 = validateParameter(valid_603597, JString, required = false,
                                 default = nil)
  if valid_603597 != nil:
    section.add "X-Amz-Date", valid_603597
  var valid_603598 = header.getOrDefault("X-Amz-Security-Token")
  valid_603598 = validateParameter(valid_603598, JString, required = false,
                                 default = nil)
  if valid_603598 != nil:
    section.add "X-Amz-Security-Token", valid_603598
  var valid_603599 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603599 = validateParameter(valid_603599, JString, required = false,
                                 default = nil)
  if valid_603599 != nil:
    section.add "X-Amz-Content-Sha256", valid_603599
  var valid_603600 = header.getOrDefault("X-Amz-Algorithm")
  valid_603600 = validateParameter(valid_603600, JString, required = false,
                                 default = nil)
  if valid_603600 != nil:
    section.add "X-Amz-Algorithm", valid_603600
  var valid_603601 = header.getOrDefault("X-Amz-Signature")
  valid_603601 = validateParameter(valid_603601, JString, required = false,
                                 default = nil)
  if valid_603601 != nil:
    section.add "X-Amz-Signature", valid_603601
  var valid_603602 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603602 = validateParameter(valid_603602, JString, required = false,
                                 default = nil)
  if valid_603602 != nil:
    section.add "X-Amz-SignedHeaders", valid_603602
  var valid_603603 = header.getOrDefault("X-Amz-Credential")
  valid_603603 = validateParameter(valid_603603, JString, required = false,
                                 default = nil)
  if valid_603603 != nil:
    section.add "X-Amz-Credential", valid_603603
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603604: Call_DeleteJob_603592; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ## 
  let valid = call_603604.validator(path, query, header, formData, body)
  let scheme = call_603604.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603604.url(scheme.get, call_603604.host, call_603604.base,
                         call_603604.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603604, url, valid)

proc call*(call_603605: Call_DeleteJob_603592; jobId: string; force: bool = false): Recallable =
  ## deleteJob
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ##   force: bool
  ##        : <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
  ##   jobId: string (required)
  ##        : <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
  var path_603606 = newJObject()
  var query_603607 = newJObject()
  add(query_603607, "force", newJBool(force))
  add(path_603606, "jobId", newJString(jobId))
  result = call_603605.call(path_603606, query_603607, nil, nil, nil)

var deleteJob* = Call_DeleteJob_603592(name: "deleteJob",
                                    meth: HttpMethod.HttpDelete,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_DeleteJob_603593,
                                    base: "/", url: url_DeleteJob_603594,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateKeysAndCertificate_603624 = ref object of OpenApiRestCall_602466
proc url_CreateKeysAndCertificate_603626(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CreateKeysAndCertificate_603625(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_603627 = query.getOrDefault("setAsActive")
  valid_603627 = validateParameter(valid_603627, JBool, required = false, default = nil)
  if valid_603627 != nil:
    section.add "setAsActive", valid_603627
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603628 = header.getOrDefault("X-Amz-Date")
  valid_603628 = validateParameter(valid_603628, JString, required = false,
                                 default = nil)
  if valid_603628 != nil:
    section.add "X-Amz-Date", valid_603628
  var valid_603629 = header.getOrDefault("X-Amz-Security-Token")
  valid_603629 = validateParameter(valid_603629, JString, required = false,
                                 default = nil)
  if valid_603629 != nil:
    section.add "X-Amz-Security-Token", valid_603629
  var valid_603630 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603630 = validateParameter(valid_603630, JString, required = false,
                                 default = nil)
  if valid_603630 != nil:
    section.add "X-Amz-Content-Sha256", valid_603630
  var valid_603631 = header.getOrDefault("X-Amz-Algorithm")
  valid_603631 = validateParameter(valid_603631, JString, required = false,
                                 default = nil)
  if valid_603631 != nil:
    section.add "X-Amz-Algorithm", valid_603631
  var valid_603632 = header.getOrDefault("X-Amz-Signature")
  valid_603632 = validateParameter(valid_603632, JString, required = false,
                                 default = nil)
  if valid_603632 != nil:
    section.add "X-Amz-Signature", valid_603632
  var valid_603633 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603633 = validateParameter(valid_603633, JString, required = false,
                                 default = nil)
  if valid_603633 != nil:
    section.add "X-Amz-SignedHeaders", valid_603633
  var valid_603634 = header.getOrDefault("X-Amz-Credential")
  valid_603634 = validateParameter(valid_603634, JString, required = false,
                                 default = nil)
  if valid_603634 != nil:
    section.add "X-Amz-Credential", valid_603634
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603635: Call_CreateKeysAndCertificate_603624; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ## 
  let valid = call_603635.validator(path, query, header, formData, body)
  let scheme = call_603635.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603635.url(scheme.get, call_603635.host, call_603635.base,
                         call_603635.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603635, url, valid)

proc call*(call_603636: Call_CreateKeysAndCertificate_603624;
          setAsActive: bool = false): Recallable =
  ## createKeysAndCertificate
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  var query_603637 = newJObject()
  add(query_603637, "setAsActive", newJBool(setAsActive))
  result = call_603636.call(nil, query_603637, nil, nil, nil)

var createKeysAndCertificate* = Call_CreateKeysAndCertificate_603624(
    name: "createKeysAndCertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/keys-and-certificate",
    validator: validate_CreateKeysAndCertificate_603625, base: "/",
    url: url_CreateKeysAndCertificate_603626, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateMitigationAction_603652 = ref object of OpenApiRestCall_602466
proc url_CreateMitigationAction_603654(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateMitigationAction_603653(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_603655 = path.getOrDefault("actionName")
  valid_603655 = validateParameter(valid_603655, JString, required = true,
                                 default = nil)
  if valid_603655 != nil:
    section.add "actionName", valid_603655
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603656 = header.getOrDefault("X-Amz-Date")
  valid_603656 = validateParameter(valid_603656, JString, required = false,
                                 default = nil)
  if valid_603656 != nil:
    section.add "X-Amz-Date", valid_603656
  var valid_603657 = header.getOrDefault("X-Amz-Security-Token")
  valid_603657 = validateParameter(valid_603657, JString, required = false,
                                 default = nil)
  if valid_603657 != nil:
    section.add "X-Amz-Security-Token", valid_603657
  var valid_603658 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603658 = validateParameter(valid_603658, JString, required = false,
                                 default = nil)
  if valid_603658 != nil:
    section.add "X-Amz-Content-Sha256", valid_603658
  var valid_603659 = header.getOrDefault("X-Amz-Algorithm")
  valid_603659 = validateParameter(valid_603659, JString, required = false,
                                 default = nil)
  if valid_603659 != nil:
    section.add "X-Amz-Algorithm", valid_603659
  var valid_603660 = header.getOrDefault("X-Amz-Signature")
  valid_603660 = validateParameter(valid_603660, JString, required = false,
                                 default = nil)
  if valid_603660 != nil:
    section.add "X-Amz-Signature", valid_603660
  var valid_603661 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603661 = validateParameter(valid_603661, JString, required = false,
                                 default = nil)
  if valid_603661 != nil:
    section.add "X-Amz-SignedHeaders", valid_603661
  var valid_603662 = header.getOrDefault("X-Amz-Credential")
  valid_603662 = validateParameter(valid_603662, JString, required = false,
                                 default = nil)
  if valid_603662 != nil:
    section.add "X-Amz-Credential", valid_603662
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603664: Call_CreateMitigationAction_603652; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ## 
  let valid = call_603664.validator(path, query, header, formData, body)
  let scheme = call_603664.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603664.url(scheme.get, call_603664.host, call_603664.base,
                         call_603664.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603664, url, valid)

proc call*(call_603665: Call_CreateMitigationAction_603652; actionName: string;
          body: JsonNode): Recallable =
  ## createMitigationAction
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ##   actionName: string (required)
  ##             : A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).
  ##   body: JObject (required)
  var path_603666 = newJObject()
  var body_603667 = newJObject()
  add(path_603666, "actionName", newJString(actionName))
  if body != nil:
    body_603667 = body
  result = call_603665.call(path_603666, nil, nil, nil, body_603667)

var createMitigationAction* = Call_CreateMitigationAction_603652(
    name: "createMitigationAction", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_CreateMitigationAction_603653, base: "/",
    url: url_CreateMitigationAction_603654, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeMitigationAction_603638 = ref object of OpenApiRestCall_602466
proc url_DescribeMitigationAction_603640(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeMitigationAction_603639(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a mitigation action.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The friendly name that uniquely identifies the mitigation action.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_603641 = path.getOrDefault("actionName")
  valid_603641 = validateParameter(valid_603641, JString, required = true,
                                 default = nil)
  if valid_603641 != nil:
    section.add "actionName", valid_603641
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603642 = header.getOrDefault("X-Amz-Date")
  valid_603642 = validateParameter(valid_603642, JString, required = false,
                                 default = nil)
  if valid_603642 != nil:
    section.add "X-Amz-Date", valid_603642
  var valid_603643 = header.getOrDefault("X-Amz-Security-Token")
  valid_603643 = validateParameter(valid_603643, JString, required = false,
                                 default = nil)
  if valid_603643 != nil:
    section.add "X-Amz-Security-Token", valid_603643
  var valid_603644 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603644 = validateParameter(valid_603644, JString, required = false,
                                 default = nil)
  if valid_603644 != nil:
    section.add "X-Amz-Content-Sha256", valid_603644
  var valid_603645 = header.getOrDefault("X-Amz-Algorithm")
  valid_603645 = validateParameter(valid_603645, JString, required = false,
                                 default = nil)
  if valid_603645 != nil:
    section.add "X-Amz-Algorithm", valid_603645
  var valid_603646 = header.getOrDefault("X-Amz-Signature")
  valid_603646 = validateParameter(valid_603646, JString, required = false,
                                 default = nil)
  if valid_603646 != nil:
    section.add "X-Amz-Signature", valid_603646
  var valid_603647 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603647 = validateParameter(valid_603647, JString, required = false,
                                 default = nil)
  if valid_603647 != nil:
    section.add "X-Amz-SignedHeaders", valid_603647
  var valid_603648 = header.getOrDefault("X-Amz-Credential")
  valid_603648 = validateParameter(valid_603648, JString, required = false,
                                 default = nil)
  if valid_603648 != nil:
    section.add "X-Amz-Credential", valid_603648
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603649: Call_DescribeMitigationAction_603638; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a mitigation action.
  ## 
  let valid = call_603649.validator(path, query, header, formData, body)
  let scheme = call_603649.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603649.url(scheme.get, call_603649.host, call_603649.base,
                         call_603649.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603649, url, valid)

proc call*(call_603650: Call_DescribeMitigationAction_603638; actionName: string): Recallable =
  ## describeMitigationAction
  ## Gets information about a mitigation action.
  ##   actionName: string (required)
  ##             : The friendly name that uniquely identifies the mitigation action.
  var path_603651 = newJObject()
  add(path_603651, "actionName", newJString(actionName))
  result = call_603650.call(path_603651, nil, nil, nil, nil)

var describeMitigationAction* = Call_DescribeMitigationAction_603638(
    name: "describeMitigationAction", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_DescribeMitigationAction_603639, base: "/",
    url: url_DescribeMitigationAction_603640, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateMitigationAction_603682 = ref object of OpenApiRestCall_602466
proc url_UpdateMitigationAction_603684(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateMitigationAction_603683(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the definition for the specified mitigation action.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_603685 = path.getOrDefault("actionName")
  valid_603685 = validateParameter(valid_603685, JString, required = true,
                                 default = nil)
  if valid_603685 != nil:
    section.add "actionName", valid_603685
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603686 = header.getOrDefault("X-Amz-Date")
  valid_603686 = validateParameter(valid_603686, JString, required = false,
                                 default = nil)
  if valid_603686 != nil:
    section.add "X-Amz-Date", valid_603686
  var valid_603687 = header.getOrDefault("X-Amz-Security-Token")
  valid_603687 = validateParameter(valid_603687, JString, required = false,
                                 default = nil)
  if valid_603687 != nil:
    section.add "X-Amz-Security-Token", valid_603687
  var valid_603688 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603688 = validateParameter(valid_603688, JString, required = false,
                                 default = nil)
  if valid_603688 != nil:
    section.add "X-Amz-Content-Sha256", valid_603688
  var valid_603689 = header.getOrDefault("X-Amz-Algorithm")
  valid_603689 = validateParameter(valid_603689, JString, required = false,
                                 default = nil)
  if valid_603689 != nil:
    section.add "X-Amz-Algorithm", valid_603689
  var valid_603690 = header.getOrDefault("X-Amz-Signature")
  valid_603690 = validateParameter(valid_603690, JString, required = false,
                                 default = nil)
  if valid_603690 != nil:
    section.add "X-Amz-Signature", valid_603690
  var valid_603691 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603691 = validateParameter(valid_603691, JString, required = false,
                                 default = nil)
  if valid_603691 != nil:
    section.add "X-Amz-SignedHeaders", valid_603691
  var valid_603692 = header.getOrDefault("X-Amz-Credential")
  valid_603692 = validateParameter(valid_603692, JString, required = false,
                                 default = nil)
  if valid_603692 != nil:
    section.add "X-Amz-Credential", valid_603692
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603694: Call_UpdateMitigationAction_603682; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the definition for the specified mitigation action.
  ## 
  let valid = call_603694.validator(path, query, header, formData, body)
  let scheme = call_603694.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603694.url(scheme.get, call_603694.host, call_603694.base,
                         call_603694.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603694, url, valid)

proc call*(call_603695: Call_UpdateMitigationAction_603682; actionName: string;
          body: JsonNode): Recallable =
  ## updateMitigationAction
  ## Updates the definition for the specified mitigation action.
  ##   actionName: string (required)
  ##             : The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.
  ##   body: JObject (required)
  var path_603696 = newJObject()
  var body_603697 = newJObject()
  add(path_603696, "actionName", newJString(actionName))
  if body != nil:
    body_603697 = body
  result = call_603695.call(path_603696, nil, nil, nil, body_603697)

var updateMitigationAction* = Call_UpdateMitigationAction_603682(
    name: "updateMitigationAction", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_UpdateMitigationAction_603683, base: "/",
    url: url_UpdateMitigationAction_603684, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteMitigationAction_603668 = ref object of OpenApiRestCall_602466
proc url_DeleteMitigationAction_603670(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteMitigationAction_603669(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a defined mitigation action from your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The name of the mitigation action that you want to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_603671 = path.getOrDefault("actionName")
  valid_603671 = validateParameter(valid_603671, JString, required = true,
                                 default = nil)
  if valid_603671 != nil:
    section.add "actionName", valid_603671
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603672 = header.getOrDefault("X-Amz-Date")
  valid_603672 = validateParameter(valid_603672, JString, required = false,
                                 default = nil)
  if valid_603672 != nil:
    section.add "X-Amz-Date", valid_603672
  var valid_603673 = header.getOrDefault("X-Amz-Security-Token")
  valid_603673 = validateParameter(valid_603673, JString, required = false,
                                 default = nil)
  if valid_603673 != nil:
    section.add "X-Amz-Security-Token", valid_603673
  var valid_603674 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603674 = validateParameter(valid_603674, JString, required = false,
                                 default = nil)
  if valid_603674 != nil:
    section.add "X-Amz-Content-Sha256", valid_603674
  var valid_603675 = header.getOrDefault("X-Amz-Algorithm")
  valid_603675 = validateParameter(valid_603675, JString, required = false,
                                 default = nil)
  if valid_603675 != nil:
    section.add "X-Amz-Algorithm", valid_603675
  var valid_603676 = header.getOrDefault("X-Amz-Signature")
  valid_603676 = validateParameter(valid_603676, JString, required = false,
                                 default = nil)
  if valid_603676 != nil:
    section.add "X-Amz-Signature", valid_603676
  var valid_603677 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603677 = validateParameter(valid_603677, JString, required = false,
                                 default = nil)
  if valid_603677 != nil:
    section.add "X-Amz-SignedHeaders", valid_603677
  var valid_603678 = header.getOrDefault("X-Amz-Credential")
  valid_603678 = validateParameter(valid_603678, JString, required = false,
                                 default = nil)
  if valid_603678 != nil:
    section.add "X-Amz-Credential", valid_603678
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603679: Call_DeleteMitigationAction_603668; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a defined mitigation action from your AWS account.
  ## 
  let valid = call_603679.validator(path, query, header, formData, body)
  let scheme = call_603679.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603679.url(scheme.get, call_603679.host, call_603679.base,
                         call_603679.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603679, url, valid)

proc call*(call_603680: Call_DeleteMitigationAction_603668; actionName: string): Recallable =
  ## deleteMitigationAction
  ## Deletes a defined mitigation action from your AWS account.
  ##   actionName: string (required)
  ##             : The name of the mitigation action that you want to delete.
  var path_603681 = newJObject()
  add(path_603681, "actionName", newJString(actionName))
  result = call_603680.call(path_603681, nil, nil, nil, nil)

var deleteMitigationAction* = Call_DeleteMitigationAction_603668(
    name: "deleteMitigationAction", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_DeleteMitigationAction_603669, base: "/",
    url: url_DeleteMitigationAction_603670, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateOTAUpdate_603712 = ref object of OpenApiRestCall_602466
proc url_CreateOTAUpdate_603714(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateOTAUpdate_603713(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The ID of the OTA update to be created.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_603715 = path.getOrDefault("otaUpdateId")
  valid_603715 = validateParameter(valid_603715, JString, required = true,
                                 default = nil)
  if valid_603715 != nil:
    section.add "otaUpdateId", valid_603715
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603716 = header.getOrDefault("X-Amz-Date")
  valid_603716 = validateParameter(valid_603716, JString, required = false,
                                 default = nil)
  if valid_603716 != nil:
    section.add "X-Amz-Date", valid_603716
  var valid_603717 = header.getOrDefault("X-Amz-Security-Token")
  valid_603717 = validateParameter(valid_603717, JString, required = false,
                                 default = nil)
  if valid_603717 != nil:
    section.add "X-Amz-Security-Token", valid_603717
  var valid_603718 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603718 = validateParameter(valid_603718, JString, required = false,
                                 default = nil)
  if valid_603718 != nil:
    section.add "X-Amz-Content-Sha256", valid_603718
  var valid_603719 = header.getOrDefault("X-Amz-Algorithm")
  valid_603719 = validateParameter(valid_603719, JString, required = false,
                                 default = nil)
  if valid_603719 != nil:
    section.add "X-Amz-Algorithm", valid_603719
  var valid_603720 = header.getOrDefault("X-Amz-Signature")
  valid_603720 = validateParameter(valid_603720, JString, required = false,
                                 default = nil)
  if valid_603720 != nil:
    section.add "X-Amz-Signature", valid_603720
  var valid_603721 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603721 = validateParameter(valid_603721, JString, required = false,
                                 default = nil)
  if valid_603721 != nil:
    section.add "X-Amz-SignedHeaders", valid_603721
  var valid_603722 = header.getOrDefault("X-Amz-Credential")
  valid_603722 = validateParameter(valid_603722, JString, required = false,
                                 default = nil)
  if valid_603722 != nil:
    section.add "X-Amz-Credential", valid_603722
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603724: Call_CreateOTAUpdate_603712; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ## 
  let valid = call_603724.validator(path, query, header, formData, body)
  let scheme = call_603724.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603724.url(scheme.get, call_603724.host, call_603724.base,
                         call_603724.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603724, url, valid)

proc call*(call_603725: Call_CreateOTAUpdate_603712; otaUpdateId: string;
          body: JsonNode): Recallable =
  ## createOTAUpdate
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ##   otaUpdateId: string (required)
  ##              : The ID of the OTA update to be created.
  ##   body: JObject (required)
  var path_603726 = newJObject()
  var body_603727 = newJObject()
  add(path_603726, "otaUpdateId", newJString(otaUpdateId))
  if body != nil:
    body_603727 = body
  result = call_603725.call(path_603726, nil, nil, nil, body_603727)

var createOTAUpdate* = Call_CreateOTAUpdate_603712(name: "createOTAUpdate",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_CreateOTAUpdate_603713,
    base: "/", url: url_CreateOTAUpdate_603714, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetOTAUpdate_603698 = ref object of OpenApiRestCall_602466
proc url_GetOTAUpdate_603700(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetOTAUpdate_603699(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets an OTA update.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The OTA update ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_603701 = path.getOrDefault("otaUpdateId")
  valid_603701 = validateParameter(valid_603701, JString, required = true,
                                 default = nil)
  if valid_603701 != nil:
    section.add "otaUpdateId", valid_603701
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603702 = header.getOrDefault("X-Amz-Date")
  valid_603702 = validateParameter(valid_603702, JString, required = false,
                                 default = nil)
  if valid_603702 != nil:
    section.add "X-Amz-Date", valid_603702
  var valid_603703 = header.getOrDefault("X-Amz-Security-Token")
  valid_603703 = validateParameter(valid_603703, JString, required = false,
                                 default = nil)
  if valid_603703 != nil:
    section.add "X-Amz-Security-Token", valid_603703
  var valid_603704 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603704 = validateParameter(valid_603704, JString, required = false,
                                 default = nil)
  if valid_603704 != nil:
    section.add "X-Amz-Content-Sha256", valid_603704
  var valid_603705 = header.getOrDefault("X-Amz-Algorithm")
  valid_603705 = validateParameter(valid_603705, JString, required = false,
                                 default = nil)
  if valid_603705 != nil:
    section.add "X-Amz-Algorithm", valid_603705
  var valid_603706 = header.getOrDefault("X-Amz-Signature")
  valid_603706 = validateParameter(valid_603706, JString, required = false,
                                 default = nil)
  if valid_603706 != nil:
    section.add "X-Amz-Signature", valid_603706
  var valid_603707 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603707 = validateParameter(valid_603707, JString, required = false,
                                 default = nil)
  if valid_603707 != nil:
    section.add "X-Amz-SignedHeaders", valid_603707
  var valid_603708 = header.getOrDefault("X-Amz-Credential")
  valid_603708 = validateParameter(valid_603708, JString, required = false,
                                 default = nil)
  if valid_603708 != nil:
    section.add "X-Amz-Credential", valid_603708
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603709: Call_GetOTAUpdate_603698; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets an OTA update.
  ## 
  let valid = call_603709.validator(path, query, header, formData, body)
  let scheme = call_603709.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603709.url(scheme.get, call_603709.host, call_603709.base,
                         call_603709.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603709, url, valid)

proc call*(call_603710: Call_GetOTAUpdate_603698; otaUpdateId: string): Recallable =
  ## getOTAUpdate
  ## Gets an OTA update.
  ##   otaUpdateId: string (required)
  ##              : The OTA update ID.
  var path_603711 = newJObject()
  add(path_603711, "otaUpdateId", newJString(otaUpdateId))
  result = call_603710.call(path_603711, nil, nil, nil, nil)

var getOTAUpdate* = Call_GetOTAUpdate_603698(name: "getOTAUpdate",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_GetOTAUpdate_603699,
    base: "/", url: url_GetOTAUpdate_603700, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteOTAUpdate_603728 = ref object of OpenApiRestCall_602466
proc url_DeleteOTAUpdate_603730(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteOTAUpdate_603729(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Delete an OTA update.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The OTA update ID to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_603731 = path.getOrDefault("otaUpdateId")
  valid_603731 = validateParameter(valid_603731, JString, required = true,
                                 default = nil)
  if valid_603731 != nil:
    section.add "otaUpdateId", valid_603731
  result.add "path", section
  ## parameters in `query` object:
  ##   deleteStream: JBool
  ##               : Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.
  ##   forceDeleteAWSJob: JBool
  ##                    : Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.
  section = newJObject()
  var valid_603732 = query.getOrDefault("deleteStream")
  valid_603732 = validateParameter(valid_603732, JBool, required = false, default = nil)
  if valid_603732 != nil:
    section.add "deleteStream", valid_603732
  var valid_603733 = query.getOrDefault("forceDeleteAWSJob")
  valid_603733 = validateParameter(valid_603733, JBool, required = false, default = nil)
  if valid_603733 != nil:
    section.add "forceDeleteAWSJob", valid_603733
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603734 = header.getOrDefault("X-Amz-Date")
  valid_603734 = validateParameter(valid_603734, JString, required = false,
                                 default = nil)
  if valid_603734 != nil:
    section.add "X-Amz-Date", valid_603734
  var valid_603735 = header.getOrDefault("X-Amz-Security-Token")
  valid_603735 = validateParameter(valid_603735, JString, required = false,
                                 default = nil)
  if valid_603735 != nil:
    section.add "X-Amz-Security-Token", valid_603735
  var valid_603736 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603736 = validateParameter(valid_603736, JString, required = false,
                                 default = nil)
  if valid_603736 != nil:
    section.add "X-Amz-Content-Sha256", valid_603736
  var valid_603737 = header.getOrDefault("X-Amz-Algorithm")
  valid_603737 = validateParameter(valid_603737, JString, required = false,
                                 default = nil)
  if valid_603737 != nil:
    section.add "X-Amz-Algorithm", valid_603737
  var valid_603738 = header.getOrDefault("X-Amz-Signature")
  valid_603738 = validateParameter(valid_603738, JString, required = false,
                                 default = nil)
  if valid_603738 != nil:
    section.add "X-Amz-Signature", valid_603738
  var valid_603739 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603739 = validateParameter(valid_603739, JString, required = false,
                                 default = nil)
  if valid_603739 != nil:
    section.add "X-Amz-SignedHeaders", valid_603739
  var valid_603740 = header.getOrDefault("X-Amz-Credential")
  valid_603740 = validateParameter(valid_603740, JString, required = false,
                                 default = nil)
  if valid_603740 != nil:
    section.add "X-Amz-Credential", valid_603740
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603741: Call_DeleteOTAUpdate_603728; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete an OTA update.
  ## 
  let valid = call_603741.validator(path, query, header, formData, body)
  let scheme = call_603741.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603741.url(scheme.get, call_603741.host, call_603741.base,
                         call_603741.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603741, url, valid)

proc call*(call_603742: Call_DeleteOTAUpdate_603728; otaUpdateId: string;
          deleteStream: bool = false; forceDeleteAWSJob: bool = false): Recallable =
  ## deleteOTAUpdate
  ## Delete an OTA update.
  ##   deleteStream: bool
  ##               : Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.
  ##   otaUpdateId: string (required)
  ##              : The OTA update ID to delete.
  ##   forceDeleteAWSJob: bool
  ##                    : Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.
  var path_603743 = newJObject()
  var query_603744 = newJObject()
  add(query_603744, "deleteStream", newJBool(deleteStream))
  add(path_603743, "otaUpdateId", newJString(otaUpdateId))
  add(query_603744, "forceDeleteAWSJob", newJBool(forceDeleteAWSJob))
  result = call_603742.call(path_603743, query_603744, nil, nil, nil)

var deleteOTAUpdate* = Call_DeleteOTAUpdate_603728(name: "deleteOTAUpdate",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_DeleteOTAUpdate_603729,
    base: "/", url: url_DeleteOTAUpdate_603730, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreatePolicy_603759 = ref object of OpenApiRestCall_602466
proc url_CreatePolicy_603761(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreatePolicy_603760(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_603762 = path.getOrDefault("policyName")
  valid_603762 = validateParameter(valid_603762, JString, required = true,
                                 default = nil)
  if valid_603762 != nil:
    section.add "policyName", valid_603762
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603763 = header.getOrDefault("X-Amz-Date")
  valid_603763 = validateParameter(valid_603763, JString, required = false,
                                 default = nil)
  if valid_603763 != nil:
    section.add "X-Amz-Date", valid_603763
  var valid_603764 = header.getOrDefault("X-Amz-Security-Token")
  valid_603764 = validateParameter(valid_603764, JString, required = false,
                                 default = nil)
  if valid_603764 != nil:
    section.add "X-Amz-Security-Token", valid_603764
  var valid_603765 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603765 = validateParameter(valid_603765, JString, required = false,
                                 default = nil)
  if valid_603765 != nil:
    section.add "X-Amz-Content-Sha256", valid_603765
  var valid_603766 = header.getOrDefault("X-Amz-Algorithm")
  valid_603766 = validateParameter(valid_603766, JString, required = false,
                                 default = nil)
  if valid_603766 != nil:
    section.add "X-Amz-Algorithm", valid_603766
  var valid_603767 = header.getOrDefault("X-Amz-Signature")
  valid_603767 = validateParameter(valid_603767, JString, required = false,
                                 default = nil)
  if valid_603767 != nil:
    section.add "X-Amz-Signature", valid_603767
  var valid_603768 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603768 = validateParameter(valid_603768, JString, required = false,
                                 default = nil)
  if valid_603768 != nil:
    section.add "X-Amz-SignedHeaders", valid_603768
  var valid_603769 = header.getOrDefault("X-Amz-Credential")
  valid_603769 = validateParameter(valid_603769, JString, required = false,
                                 default = nil)
  if valid_603769 != nil:
    section.add "X-Amz-Credential", valid_603769
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603771: Call_CreatePolicy_603759; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ## 
  let valid = call_603771.validator(path, query, header, formData, body)
  let scheme = call_603771.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603771.url(scheme.get, call_603771.host, call_603771.base,
                         call_603771.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603771, url, valid)

proc call*(call_603772: Call_CreatePolicy_603759; policyName: string; body: JsonNode): Recallable =
  ## createPolicy
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ##   policyName: string (required)
  ##             : The policy name.
  ##   body: JObject (required)
  var path_603773 = newJObject()
  var body_603774 = newJObject()
  add(path_603773, "policyName", newJString(policyName))
  if body != nil:
    body_603774 = body
  result = call_603772.call(path_603773, nil, nil, nil, body_603774)

var createPolicy* = Call_CreatePolicy_603759(name: "createPolicy",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/policies/{policyName}", validator: validate_CreatePolicy_603760,
    base: "/", url: url_CreatePolicy_603761, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPolicy_603745 = ref object of OpenApiRestCall_602466
proc url_GetPolicy_603747(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPolicy_603746(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the specified policy with the policy document of the default version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_603748 = path.getOrDefault("policyName")
  valid_603748 = validateParameter(valid_603748, JString, required = true,
                                 default = nil)
  if valid_603748 != nil:
    section.add "policyName", valid_603748
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603749 = header.getOrDefault("X-Amz-Date")
  valid_603749 = validateParameter(valid_603749, JString, required = false,
                                 default = nil)
  if valid_603749 != nil:
    section.add "X-Amz-Date", valid_603749
  var valid_603750 = header.getOrDefault("X-Amz-Security-Token")
  valid_603750 = validateParameter(valid_603750, JString, required = false,
                                 default = nil)
  if valid_603750 != nil:
    section.add "X-Amz-Security-Token", valid_603750
  var valid_603751 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603751 = validateParameter(valid_603751, JString, required = false,
                                 default = nil)
  if valid_603751 != nil:
    section.add "X-Amz-Content-Sha256", valid_603751
  var valid_603752 = header.getOrDefault("X-Amz-Algorithm")
  valid_603752 = validateParameter(valid_603752, JString, required = false,
                                 default = nil)
  if valid_603752 != nil:
    section.add "X-Amz-Algorithm", valid_603752
  var valid_603753 = header.getOrDefault("X-Amz-Signature")
  valid_603753 = validateParameter(valid_603753, JString, required = false,
                                 default = nil)
  if valid_603753 != nil:
    section.add "X-Amz-Signature", valid_603753
  var valid_603754 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603754 = validateParameter(valid_603754, JString, required = false,
                                 default = nil)
  if valid_603754 != nil:
    section.add "X-Amz-SignedHeaders", valid_603754
  var valid_603755 = header.getOrDefault("X-Amz-Credential")
  valid_603755 = validateParameter(valid_603755, JString, required = false,
                                 default = nil)
  if valid_603755 != nil:
    section.add "X-Amz-Credential", valid_603755
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603756: Call_GetPolicy_603745; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified policy with the policy document of the default version.
  ## 
  let valid = call_603756.validator(path, query, header, formData, body)
  let scheme = call_603756.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603756.url(scheme.get, call_603756.host, call_603756.base,
                         call_603756.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603756, url, valid)

proc call*(call_603757: Call_GetPolicy_603745; policyName: string): Recallable =
  ## getPolicy
  ## Gets information about the specified policy with the policy document of the default version.
  ##   policyName: string (required)
  ##             : The name of the policy.
  var path_603758 = newJObject()
  add(path_603758, "policyName", newJString(policyName))
  result = call_603757.call(path_603758, nil, nil, nil, nil)

var getPolicy* = Call_GetPolicy_603745(name: "getPolicy", meth: HttpMethod.HttpGet,
                                    host: "iot.amazonaws.com",
                                    route: "/policies/{policyName}",
                                    validator: validate_GetPolicy_603746,
                                    base: "/", url: url_GetPolicy_603747,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeletePolicy_603775 = ref object of OpenApiRestCall_602466
proc url_DeletePolicy_603777(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeletePolicy_603776(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_603778 = path.getOrDefault("policyName")
  valid_603778 = validateParameter(valid_603778, JString, required = true,
                                 default = nil)
  if valid_603778 != nil:
    section.add "policyName", valid_603778
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603779 = header.getOrDefault("X-Amz-Date")
  valid_603779 = validateParameter(valid_603779, JString, required = false,
                                 default = nil)
  if valid_603779 != nil:
    section.add "X-Amz-Date", valid_603779
  var valid_603780 = header.getOrDefault("X-Amz-Security-Token")
  valid_603780 = validateParameter(valid_603780, JString, required = false,
                                 default = nil)
  if valid_603780 != nil:
    section.add "X-Amz-Security-Token", valid_603780
  var valid_603781 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603781 = validateParameter(valid_603781, JString, required = false,
                                 default = nil)
  if valid_603781 != nil:
    section.add "X-Amz-Content-Sha256", valid_603781
  var valid_603782 = header.getOrDefault("X-Amz-Algorithm")
  valid_603782 = validateParameter(valid_603782, JString, required = false,
                                 default = nil)
  if valid_603782 != nil:
    section.add "X-Amz-Algorithm", valid_603782
  var valid_603783 = header.getOrDefault("X-Amz-Signature")
  valid_603783 = validateParameter(valid_603783, JString, required = false,
                                 default = nil)
  if valid_603783 != nil:
    section.add "X-Amz-Signature", valid_603783
  var valid_603784 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603784 = validateParameter(valid_603784, JString, required = false,
                                 default = nil)
  if valid_603784 != nil:
    section.add "X-Amz-SignedHeaders", valid_603784
  var valid_603785 = header.getOrDefault("X-Amz-Credential")
  valid_603785 = validateParameter(valid_603785, JString, required = false,
                                 default = nil)
  if valid_603785 != nil:
    section.add "X-Amz-Credential", valid_603785
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603786: Call_DeletePolicy_603775; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ## 
  let valid = call_603786.validator(path, query, header, formData, body)
  let scheme = call_603786.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603786.url(scheme.get, call_603786.host, call_603786.base,
                         call_603786.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603786, url, valid)

proc call*(call_603787: Call_DeletePolicy_603775; policyName: string): Recallable =
  ## deletePolicy
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ##   policyName: string (required)
  ##             : The name of the policy to delete.
  var path_603788 = newJObject()
  add(path_603788, "policyName", newJString(policyName))
  result = call_603787.call(path_603788, nil, nil, nil, nil)

var deletePolicy* = Call_DeletePolicy_603775(name: "deletePolicy",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/policies/{policyName}", validator: validate_DeletePolicy_603776,
    base: "/", url: url_DeletePolicy_603777, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreatePolicyVersion_603803 = ref object of OpenApiRestCall_602466
proc url_CreatePolicyVersion_603805(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreatePolicyVersion_603804(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_603806 = path.getOrDefault("policyName")
  valid_603806 = validateParameter(valid_603806, JString, required = true,
                                 default = nil)
  if valid_603806 != nil:
    section.add "policyName", valid_603806
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsDefault: JBool
  ##               : Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
  section = newJObject()
  var valid_603807 = query.getOrDefault("setAsDefault")
  valid_603807 = validateParameter(valid_603807, JBool, required = false, default = nil)
  if valid_603807 != nil:
    section.add "setAsDefault", valid_603807
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603808 = header.getOrDefault("X-Amz-Date")
  valid_603808 = validateParameter(valid_603808, JString, required = false,
                                 default = nil)
  if valid_603808 != nil:
    section.add "X-Amz-Date", valid_603808
  var valid_603809 = header.getOrDefault("X-Amz-Security-Token")
  valid_603809 = validateParameter(valid_603809, JString, required = false,
                                 default = nil)
  if valid_603809 != nil:
    section.add "X-Amz-Security-Token", valid_603809
  var valid_603810 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603810 = validateParameter(valid_603810, JString, required = false,
                                 default = nil)
  if valid_603810 != nil:
    section.add "X-Amz-Content-Sha256", valid_603810
  var valid_603811 = header.getOrDefault("X-Amz-Algorithm")
  valid_603811 = validateParameter(valid_603811, JString, required = false,
                                 default = nil)
  if valid_603811 != nil:
    section.add "X-Amz-Algorithm", valid_603811
  var valid_603812 = header.getOrDefault("X-Amz-Signature")
  valid_603812 = validateParameter(valid_603812, JString, required = false,
                                 default = nil)
  if valid_603812 != nil:
    section.add "X-Amz-Signature", valid_603812
  var valid_603813 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603813 = validateParameter(valid_603813, JString, required = false,
                                 default = nil)
  if valid_603813 != nil:
    section.add "X-Amz-SignedHeaders", valid_603813
  var valid_603814 = header.getOrDefault("X-Amz-Credential")
  valid_603814 = validateParameter(valid_603814, JString, required = false,
                                 default = nil)
  if valid_603814 != nil:
    section.add "X-Amz-Credential", valid_603814
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603816: Call_CreatePolicyVersion_603803; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ## 
  let valid = call_603816.validator(path, query, header, formData, body)
  let scheme = call_603816.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603816.url(scheme.get, call_603816.host, call_603816.base,
                         call_603816.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603816, url, valid)

proc call*(call_603817: Call_CreatePolicyVersion_603803; policyName: string;
          body: JsonNode; setAsDefault: bool = false): Recallable =
  ## createPolicyVersion
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ##   setAsDefault: bool
  ##               : Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
  ##   policyName: string (required)
  ##             : The policy name.
  ##   body: JObject (required)
  var path_603818 = newJObject()
  var query_603819 = newJObject()
  var body_603820 = newJObject()
  add(query_603819, "setAsDefault", newJBool(setAsDefault))
  add(path_603818, "policyName", newJString(policyName))
  if body != nil:
    body_603820 = body
  result = call_603817.call(path_603818, query_603819, nil, nil, body_603820)

var createPolicyVersion* = Call_CreatePolicyVersion_603803(
    name: "createPolicyVersion", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/policies/{policyName}/version",
    validator: validate_CreatePolicyVersion_603804, base: "/",
    url: url_CreatePolicyVersion_603805, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicyVersions_603789 = ref object of OpenApiRestCall_602466
proc url_ListPolicyVersions_603791(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListPolicyVersions_603790(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Lists the versions of the specified policy and identifies the default version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_603792 = path.getOrDefault("policyName")
  valid_603792 = validateParameter(valid_603792, JString, required = true,
                                 default = nil)
  if valid_603792 != nil:
    section.add "policyName", valid_603792
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603793 = header.getOrDefault("X-Amz-Date")
  valid_603793 = validateParameter(valid_603793, JString, required = false,
                                 default = nil)
  if valid_603793 != nil:
    section.add "X-Amz-Date", valid_603793
  var valid_603794 = header.getOrDefault("X-Amz-Security-Token")
  valid_603794 = validateParameter(valid_603794, JString, required = false,
                                 default = nil)
  if valid_603794 != nil:
    section.add "X-Amz-Security-Token", valid_603794
  var valid_603795 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603795 = validateParameter(valid_603795, JString, required = false,
                                 default = nil)
  if valid_603795 != nil:
    section.add "X-Amz-Content-Sha256", valid_603795
  var valid_603796 = header.getOrDefault("X-Amz-Algorithm")
  valid_603796 = validateParameter(valid_603796, JString, required = false,
                                 default = nil)
  if valid_603796 != nil:
    section.add "X-Amz-Algorithm", valid_603796
  var valid_603797 = header.getOrDefault("X-Amz-Signature")
  valid_603797 = validateParameter(valid_603797, JString, required = false,
                                 default = nil)
  if valid_603797 != nil:
    section.add "X-Amz-Signature", valid_603797
  var valid_603798 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603798 = validateParameter(valid_603798, JString, required = false,
                                 default = nil)
  if valid_603798 != nil:
    section.add "X-Amz-SignedHeaders", valid_603798
  var valid_603799 = header.getOrDefault("X-Amz-Credential")
  valid_603799 = validateParameter(valid_603799, JString, required = false,
                                 default = nil)
  if valid_603799 != nil:
    section.add "X-Amz-Credential", valid_603799
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603800: Call_ListPolicyVersions_603789; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the versions of the specified policy and identifies the default version.
  ## 
  let valid = call_603800.validator(path, query, header, formData, body)
  let scheme = call_603800.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603800.url(scheme.get, call_603800.host, call_603800.base,
                         call_603800.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603800, url, valid)

proc call*(call_603801: Call_ListPolicyVersions_603789; policyName: string): Recallable =
  ## listPolicyVersions
  ## Lists the versions of the specified policy and identifies the default version.
  ##   policyName: string (required)
  ##             : The policy name.
  var path_603802 = newJObject()
  add(path_603802, "policyName", newJString(policyName))
  result = call_603801.call(path_603802, nil, nil, nil, nil)

var listPolicyVersions* = Call_ListPolicyVersions_603789(
    name: "listPolicyVersions", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version",
    validator: validate_ListPolicyVersions_603790, base: "/",
    url: url_ListPolicyVersions_603791, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateRoleAlias_603835 = ref object of OpenApiRestCall_602466
proc url_UpdateRoleAlias_603837(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateRoleAlias_603836(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Updates a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_603838 = path.getOrDefault("roleAlias")
  valid_603838 = validateParameter(valid_603838, JString, required = true,
                                 default = nil)
  if valid_603838 != nil:
    section.add "roleAlias", valid_603838
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603839 = header.getOrDefault("X-Amz-Date")
  valid_603839 = validateParameter(valid_603839, JString, required = false,
                                 default = nil)
  if valid_603839 != nil:
    section.add "X-Amz-Date", valid_603839
  var valid_603840 = header.getOrDefault("X-Amz-Security-Token")
  valid_603840 = validateParameter(valid_603840, JString, required = false,
                                 default = nil)
  if valid_603840 != nil:
    section.add "X-Amz-Security-Token", valid_603840
  var valid_603841 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603841 = validateParameter(valid_603841, JString, required = false,
                                 default = nil)
  if valid_603841 != nil:
    section.add "X-Amz-Content-Sha256", valid_603841
  var valid_603842 = header.getOrDefault("X-Amz-Algorithm")
  valid_603842 = validateParameter(valid_603842, JString, required = false,
                                 default = nil)
  if valid_603842 != nil:
    section.add "X-Amz-Algorithm", valid_603842
  var valid_603843 = header.getOrDefault("X-Amz-Signature")
  valid_603843 = validateParameter(valid_603843, JString, required = false,
                                 default = nil)
  if valid_603843 != nil:
    section.add "X-Amz-Signature", valid_603843
  var valid_603844 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603844 = validateParameter(valid_603844, JString, required = false,
                                 default = nil)
  if valid_603844 != nil:
    section.add "X-Amz-SignedHeaders", valid_603844
  var valid_603845 = header.getOrDefault("X-Amz-Credential")
  valid_603845 = validateParameter(valid_603845, JString, required = false,
                                 default = nil)
  if valid_603845 != nil:
    section.add "X-Amz-Credential", valid_603845
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603847: Call_UpdateRoleAlias_603835; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a role alias.
  ## 
  let valid = call_603847.validator(path, query, header, formData, body)
  let scheme = call_603847.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603847.url(scheme.get, call_603847.host, call_603847.base,
                         call_603847.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603847, url, valid)

proc call*(call_603848: Call_UpdateRoleAlias_603835; body: JsonNode;
          roleAlias: string): Recallable =
  ## updateRoleAlias
  ## Updates a role alias.
  ##   body: JObject (required)
  ##   roleAlias: string (required)
  ##            : The role alias to update.
  var path_603849 = newJObject()
  var body_603850 = newJObject()
  if body != nil:
    body_603850 = body
  add(path_603849, "roleAlias", newJString(roleAlias))
  result = call_603848.call(path_603849, nil, nil, nil, body_603850)

var updateRoleAlias* = Call_UpdateRoleAlias_603835(name: "updateRoleAlias",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_UpdateRoleAlias_603836,
    base: "/", url: url_UpdateRoleAlias_603837, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateRoleAlias_603851 = ref object of OpenApiRestCall_602466
proc url_CreateRoleAlias_603853(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateRoleAlias_603852(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias that points to a role ARN. This allows you to change the role without having to update the device.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_603854 = path.getOrDefault("roleAlias")
  valid_603854 = validateParameter(valid_603854, JString, required = true,
                                 default = nil)
  if valid_603854 != nil:
    section.add "roleAlias", valid_603854
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603855 = header.getOrDefault("X-Amz-Date")
  valid_603855 = validateParameter(valid_603855, JString, required = false,
                                 default = nil)
  if valid_603855 != nil:
    section.add "X-Amz-Date", valid_603855
  var valid_603856 = header.getOrDefault("X-Amz-Security-Token")
  valid_603856 = validateParameter(valid_603856, JString, required = false,
                                 default = nil)
  if valid_603856 != nil:
    section.add "X-Amz-Security-Token", valid_603856
  var valid_603857 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603857 = validateParameter(valid_603857, JString, required = false,
                                 default = nil)
  if valid_603857 != nil:
    section.add "X-Amz-Content-Sha256", valid_603857
  var valid_603858 = header.getOrDefault("X-Amz-Algorithm")
  valid_603858 = validateParameter(valid_603858, JString, required = false,
                                 default = nil)
  if valid_603858 != nil:
    section.add "X-Amz-Algorithm", valid_603858
  var valid_603859 = header.getOrDefault("X-Amz-Signature")
  valid_603859 = validateParameter(valid_603859, JString, required = false,
                                 default = nil)
  if valid_603859 != nil:
    section.add "X-Amz-Signature", valid_603859
  var valid_603860 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603860 = validateParameter(valid_603860, JString, required = false,
                                 default = nil)
  if valid_603860 != nil:
    section.add "X-Amz-SignedHeaders", valid_603860
  var valid_603861 = header.getOrDefault("X-Amz-Credential")
  valid_603861 = validateParameter(valid_603861, JString, required = false,
                                 default = nil)
  if valid_603861 != nil:
    section.add "X-Amz-Credential", valid_603861
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603863: Call_CreateRoleAlias_603851; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a role alias.
  ## 
  let valid = call_603863.validator(path, query, header, formData, body)
  let scheme = call_603863.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603863.url(scheme.get, call_603863.host, call_603863.base,
                         call_603863.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603863, url, valid)

proc call*(call_603864: Call_CreateRoleAlias_603851; body: JsonNode;
          roleAlias: string): Recallable =
  ## createRoleAlias
  ## Creates a role alias.
  ##   body: JObject (required)
  ##   roleAlias: string (required)
  ##            : The role alias that points to a role ARN. This allows you to change the role without having to update the device.
  var path_603865 = newJObject()
  var body_603866 = newJObject()
  if body != nil:
    body_603866 = body
  add(path_603865, "roleAlias", newJString(roleAlias))
  result = call_603864.call(path_603865, nil, nil, nil, body_603866)

var createRoleAlias* = Call_CreateRoleAlias_603851(name: "createRoleAlias",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_CreateRoleAlias_603852,
    base: "/", url: url_CreateRoleAlias_603853, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeRoleAlias_603821 = ref object of OpenApiRestCall_602466
proc url_DescribeRoleAlias_603823(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeRoleAlias_603822(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Describes a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to describe.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_603824 = path.getOrDefault("roleAlias")
  valid_603824 = validateParameter(valid_603824, JString, required = true,
                                 default = nil)
  if valid_603824 != nil:
    section.add "roleAlias", valid_603824
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603825 = header.getOrDefault("X-Amz-Date")
  valid_603825 = validateParameter(valid_603825, JString, required = false,
                                 default = nil)
  if valid_603825 != nil:
    section.add "X-Amz-Date", valid_603825
  var valid_603826 = header.getOrDefault("X-Amz-Security-Token")
  valid_603826 = validateParameter(valid_603826, JString, required = false,
                                 default = nil)
  if valid_603826 != nil:
    section.add "X-Amz-Security-Token", valid_603826
  var valid_603827 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603827 = validateParameter(valid_603827, JString, required = false,
                                 default = nil)
  if valid_603827 != nil:
    section.add "X-Amz-Content-Sha256", valid_603827
  var valid_603828 = header.getOrDefault("X-Amz-Algorithm")
  valid_603828 = validateParameter(valid_603828, JString, required = false,
                                 default = nil)
  if valid_603828 != nil:
    section.add "X-Amz-Algorithm", valid_603828
  var valid_603829 = header.getOrDefault("X-Amz-Signature")
  valid_603829 = validateParameter(valid_603829, JString, required = false,
                                 default = nil)
  if valid_603829 != nil:
    section.add "X-Amz-Signature", valid_603829
  var valid_603830 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603830 = validateParameter(valid_603830, JString, required = false,
                                 default = nil)
  if valid_603830 != nil:
    section.add "X-Amz-SignedHeaders", valid_603830
  var valid_603831 = header.getOrDefault("X-Amz-Credential")
  valid_603831 = validateParameter(valid_603831, JString, required = false,
                                 default = nil)
  if valid_603831 != nil:
    section.add "X-Amz-Credential", valid_603831
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603832: Call_DescribeRoleAlias_603821; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a role alias.
  ## 
  let valid = call_603832.validator(path, query, header, formData, body)
  let scheme = call_603832.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603832.url(scheme.get, call_603832.host, call_603832.base,
                         call_603832.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603832, url, valid)

proc call*(call_603833: Call_DescribeRoleAlias_603821; roleAlias: string): Recallable =
  ## describeRoleAlias
  ## Describes a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias to describe.
  var path_603834 = newJObject()
  add(path_603834, "roleAlias", newJString(roleAlias))
  result = call_603833.call(path_603834, nil, nil, nil, nil)

var describeRoleAlias* = Call_DescribeRoleAlias_603821(name: "describeRoleAlias",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_DescribeRoleAlias_603822,
    base: "/", url: url_DescribeRoleAlias_603823,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRoleAlias_603867 = ref object of OpenApiRestCall_602466
proc url_DeleteRoleAlias_603869(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteRoleAlias_603868(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes a role alias
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_603870 = path.getOrDefault("roleAlias")
  valid_603870 = validateParameter(valid_603870, JString, required = true,
                                 default = nil)
  if valid_603870 != nil:
    section.add "roleAlias", valid_603870
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603871 = header.getOrDefault("X-Amz-Date")
  valid_603871 = validateParameter(valid_603871, JString, required = false,
                                 default = nil)
  if valid_603871 != nil:
    section.add "X-Amz-Date", valid_603871
  var valid_603872 = header.getOrDefault("X-Amz-Security-Token")
  valid_603872 = validateParameter(valid_603872, JString, required = false,
                                 default = nil)
  if valid_603872 != nil:
    section.add "X-Amz-Security-Token", valid_603872
  var valid_603873 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603873 = validateParameter(valid_603873, JString, required = false,
                                 default = nil)
  if valid_603873 != nil:
    section.add "X-Amz-Content-Sha256", valid_603873
  var valid_603874 = header.getOrDefault("X-Amz-Algorithm")
  valid_603874 = validateParameter(valid_603874, JString, required = false,
                                 default = nil)
  if valid_603874 != nil:
    section.add "X-Amz-Algorithm", valid_603874
  var valid_603875 = header.getOrDefault("X-Amz-Signature")
  valid_603875 = validateParameter(valid_603875, JString, required = false,
                                 default = nil)
  if valid_603875 != nil:
    section.add "X-Amz-Signature", valid_603875
  var valid_603876 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603876 = validateParameter(valid_603876, JString, required = false,
                                 default = nil)
  if valid_603876 != nil:
    section.add "X-Amz-SignedHeaders", valid_603876
  var valid_603877 = header.getOrDefault("X-Amz-Credential")
  valid_603877 = validateParameter(valid_603877, JString, required = false,
                                 default = nil)
  if valid_603877 != nil:
    section.add "X-Amz-Credential", valid_603877
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603878: Call_DeleteRoleAlias_603867; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a role alias
  ## 
  let valid = call_603878.validator(path, query, header, formData, body)
  let scheme = call_603878.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603878.url(scheme.get, call_603878.host, call_603878.base,
                         call_603878.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603878, url, valid)

proc call*(call_603879: Call_DeleteRoleAlias_603867; roleAlias: string): Recallable =
  ## deleteRoleAlias
  ## Deletes a role alias
  ##   roleAlias: string (required)
  ##            : The role alias to delete.
  var path_603880 = newJObject()
  add(path_603880, "roleAlias", newJString(roleAlias))
  result = call_603879.call(path_603880, nil, nil, nil, nil)

var deleteRoleAlias* = Call_DeleteRoleAlias_603867(name: "deleteRoleAlias",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_DeleteRoleAlias_603868,
    base: "/", url: url_DeleteRoleAlias_603869, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateScheduledAudit_603895 = ref object of OpenApiRestCall_602466
proc url_CreateScheduledAudit_603897(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateScheduledAudit_603896(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled audit that is run at a specified time interval.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name you want to give to the scheduled audit. (Max. 128 chars)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_603898 = path.getOrDefault("scheduledAuditName")
  valid_603898 = validateParameter(valid_603898, JString, required = true,
                                 default = nil)
  if valid_603898 != nil:
    section.add "scheduledAuditName", valid_603898
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603899 = header.getOrDefault("X-Amz-Date")
  valid_603899 = validateParameter(valid_603899, JString, required = false,
                                 default = nil)
  if valid_603899 != nil:
    section.add "X-Amz-Date", valid_603899
  var valid_603900 = header.getOrDefault("X-Amz-Security-Token")
  valid_603900 = validateParameter(valid_603900, JString, required = false,
                                 default = nil)
  if valid_603900 != nil:
    section.add "X-Amz-Security-Token", valid_603900
  var valid_603901 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603901 = validateParameter(valid_603901, JString, required = false,
                                 default = nil)
  if valid_603901 != nil:
    section.add "X-Amz-Content-Sha256", valid_603901
  var valid_603902 = header.getOrDefault("X-Amz-Algorithm")
  valid_603902 = validateParameter(valid_603902, JString, required = false,
                                 default = nil)
  if valid_603902 != nil:
    section.add "X-Amz-Algorithm", valid_603902
  var valid_603903 = header.getOrDefault("X-Amz-Signature")
  valid_603903 = validateParameter(valid_603903, JString, required = false,
                                 default = nil)
  if valid_603903 != nil:
    section.add "X-Amz-Signature", valid_603903
  var valid_603904 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603904 = validateParameter(valid_603904, JString, required = false,
                                 default = nil)
  if valid_603904 != nil:
    section.add "X-Amz-SignedHeaders", valid_603904
  var valid_603905 = header.getOrDefault("X-Amz-Credential")
  valid_603905 = validateParameter(valid_603905, JString, required = false,
                                 default = nil)
  if valid_603905 != nil:
    section.add "X-Amz-Credential", valid_603905
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603907: Call_CreateScheduledAudit_603895; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled audit that is run at a specified time interval.
  ## 
  let valid = call_603907.validator(path, query, header, formData, body)
  let scheme = call_603907.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603907.url(scheme.get, call_603907.host, call_603907.base,
                         call_603907.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603907, url, valid)

proc call*(call_603908: Call_CreateScheduledAudit_603895;
          scheduledAuditName: string; body: JsonNode): Recallable =
  ## createScheduledAudit
  ## Creates a scheduled audit that is run at a specified time interval.
  ##   scheduledAuditName: string (required)
  ##                     : The name you want to give to the scheduled audit. (Max. 128 chars)
  ##   body: JObject (required)
  var path_603909 = newJObject()
  var body_603910 = newJObject()
  add(path_603909, "scheduledAuditName", newJString(scheduledAuditName))
  if body != nil:
    body_603910 = body
  result = call_603908.call(path_603909, nil, nil, nil, body_603910)

var createScheduledAudit* = Call_CreateScheduledAudit_603895(
    name: "createScheduledAudit", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_CreateScheduledAudit_603896, base: "/",
    url: url_CreateScheduledAudit_603897, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeScheduledAudit_603881 = ref object of OpenApiRestCall_602466
proc url_DescribeScheduledAudit_603883(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeScheduledAudit_603882(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a scheduled audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit whose information you want to get.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_603884 = path.getOrDefault("scheduledAuditName")
  valid_603884 = validateParameter(valid_603884, JString, required = true,
                                 default = nil)
  if valid_603884 != nil:
    section.add "scheduledAuditName", valid_603884
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603885 = header.getOrDefault("X-Amz-Date")
  valid_603885 = validateParameter(valid_603885, JString, required = false,
                                 default = nil)
  if valid_603885 != nil:
    section.add "X-Amz-Date", valid_603885
  var valid_603886 = header.getOrDefault("X-Amz-Security-Token")
  valid_603886 = validateParameter(valid_603886, JString, required = false,
                                 default = nil)
  if valid_603886 != nil:
    section.add "X-Amz-Security-Token", valid_603886
  var valid_603887 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603887 = validateParameter(valid_603887, JString, required = false,
                                 default = nil)
  if valid_603887 != nil:
    section.add "X-Amz-Content-Sha256", valid_603887
  var valid_603888 = header.getOrDefault("X-Amz-Algorithm")
  valid_603888 = validateParameter(valid_603888, JString, required = false,
                                 default = nil)
  if valid_603888 != nil:
    section.add "X-Amz-Algorithm", valid_603888
  var valid_603889 = header.getOrDefault("X-Amz-Signature")
  valid_603889 = validateParameter(valid_603889, JString, required = false,
                                 default = nil)
  if valid_603889 != nil:
    section.add "X-Amz-Signature", valid_603889
  var valid_603890 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603890 = validateParameter(valid_603890, JString, required = false,
                                 default = nil)
  if valid_603890 != nil:
    section.add "X-Amz-SignedHeaders", valid_603890
  var valid_603891 = header.getOrDefault("X-Amz-Credential")
  valid_603891 = validateParameter(valid_603891, JString, required = false,
                                 default = nil)
  if valid_603891 != nil:
    section.add "X-Amz-Credential", valid_603891
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603892: Call_DescribeScheduledAudit_603881; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a scheduled audit.
  ## 
  let valid = call_603892.validator(path, query, header, formData, body)
  let scheme = call_603892.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603892.url(scheme.get, call_603892.host, call_603892.base,
                         call_603892.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603892, url, valid)

proc call*(call_603893: Call_DescribeScheduledAudit_603881;
          scheduledAuditName: string): Recallable =
  ## describeScheduledAudit
  ## Gets information about a scheduled audit.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit whose information you want to get.
  var path_603894 = newJObject()
  add(path_603894, "scheduledAuditName", newJString(scheduledAuditName))
  result = call_603893.call(path_603894, nil, nil, nil, nil)

var describeScheduledAudit* = Call_DescribeScheduledAudit_603881(
    name: "describeScheduledAudit", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_DescribeScheduledAudit_603882, base: "/",
    url: url_DescribeScheduledAudit_603883, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateScheduledAudit_603925 = ref object of OpenApiRestCall_602466
proc url_UpdateScheduledAudit_603927(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateScheduledAudit_603926(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit. (Max. 128 chars)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_603928 = path.getOrDefault("scheduledAuditName")
  valid_603928 = validateParameter(valid_603928, JString, required = true,
                                 default = nil)
  if valid_603928 != nil:
    section.add "scheduledAuditName", valid_603928
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603929 = header.getOrDefault("X-Amz-Date")
  valid_603929 = validateParameter(valid_603929, JString, required = false,
                                 default = nil)
  if valid_603929 != nil:
    section.add "X-Amz-Date", valid_603929
  var valid_603930 = header.getOrDefault("X-Amz-Security-Token")
  valid_603930 = validateParameter(valid_603930, JString, required = false,
                                 default = nil)
  if valid_603930 != nil:
    section.add "X-Amz-Security-Token", valid_603930
  var valid_603931 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603931 = validateParameter(valid_603931, JString, required = false,
                                 default = nil)
  if valid_603931 != nil:
    section.add "X-Amz-Content-Sha256", valid_603931
  var valid_603932 = header.getOrDefault("X-Amz-Algorithm")
  valid_603932 = validateParameter(valid_603932, JString, required = false,
                                 default = nil)
  if valid_603932 != nil:
    section.add "X-Amz-Algorithm", valid_603932
  var valid_603933 = header.getOrDefault("X-Amz-Signature")
  valid_603933 = validateParameter(valid_603933, JString, required = false,
                                 default = nil)
  if valid_603933 != nil:
    section.add "X-Amz-Signature", valid_603933
  var valid_603934 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603934 = validateParameter(valid_603934, JString, required = false,
                                 default = nil)
  if valid_603934 != nil:
    section.add "X-Amz-SignedHeaders", valid_603934
  var valid_603935 = header.getOrDefault("X-Amz-Credential")
  valid_603935 = validateParameter(valid_603935, JString, required = false,
                                 default = nil)
  if valid_603935 != nil:
    section.add "X-Amz-Credential", valid_603935
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603937: Call_UpdateScheduledAudit_603925; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ## 
  let valid = call_603937.validator(path, query, header, formData, body)
  let scheme = call_603937.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603937.url(scheme.get, call_603937.host, call_603937.base,
                         call_603937.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603937, url, valid)

proc call*(call_603938: Call_UpdateScheduledAudit_603925;
          scheduledAuditName: string; body: JsonNode): Recallable =
  ## updateScheduledAudit
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit. (Max. 128 chars)
  ##   body: JObject (required)
  var path_603939 = newJObject()
  var body_603940 = newJObject()
  add(path_603939, "scheduledAuditName", newJString(scheduledAuditName))
  if body != nil:
    body_603940 = body
  result = call_603938.call(path_603939, nil, nil, nil, body_603940)

var updateScheduledAudit* = Call_UpdateScheduledAudit_603925(
    name: "updateScheduledAudit", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_UpdateScheduledAudit_603926, base: "/",
    url: url_UpdateScheduledAudit_603927, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteScheduledAudit_603911 = ref object of OpenApiRestCall_602466
proc url_DeleteScheduledAudit_603913(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteScheduledAudit_603912(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit you want to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_603914 = path.getOrDefault("scheduledAuditName")
  valid_603914 = validateParameter(valid_603914, JString, required = true,
                                 default = nil)
  if valid_603914 != nil:
    section.add "scheduledAuditName", valid_603914
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603915 = header.getOrDefault("X-Amz-Date")
  valid_603915 = validateParameter(valid_603915, JString, required = false,
                                 default = nil)
  if valid_603915 != nil:
    section.add "X-Amz-Date", valid_603915
  var valid_603916 = header.getOrDefault("X-Amz-Security-Token")
  valid_603916 = validateParameter(valid_603916, JString, required = false,
                                 default = nil)
  if valid_603916 != nil:
    section.add "X-Amz-Security-Token", valid_603916
  var valid_603917 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603917 = validateParameter(valid_603917, JString, required = false,
                                 default = nil)
  if valid_603917 != nil:
    section.add "X-Amz-Content-Sha256", valid_603917
  var valid_603918 = header.getOrDefault("X-Amz-Algorithm")
  valid_603918 = validateParameter(valid_603918, JString, required = false,
                                 default = nil)
  if valid_603918 != nil:
    section.add "X-Amz-Algorithm", valid_603918
  var valid_603919 = header.getOrDefault("X-Amz-Signature")
  valid_603919 = validateParameter(valid_603919, JString, required = false,
                                 default = nil)
  if valid_603919 != nil:
    section.add "X-Amz-Signature", valid_603919
  var valid_603920 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603920 = validateParameter(valid_603920, JString, required = false,
                                 default = nil)
  if valid_603920 != nil:
    section.add "X-Amz-SignedHeaders", valid_603920
  var valid_603921 = header.getOrDefault("X-Amz-Credential")
  valid_603921 = validateParameter(valid_603921, JString, required = false,
                                 default = nil)
  if valid_603921 != nil:
    section.add "X-Amz-Credential", valid_603921
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603922: Call_DeleteScheduledAudit_603911; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled audit.
  ## 
  let valid = call_603922.validator(path, query, header, formData, body)
  let scheme = call_603922.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603922.url(scheme.get, call_603922.host, call_603922.base,
                         call_603922.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603922, url, valid)

proc call*(call_603923: Call_DeleteScheduledAudit_603911;
          scheduledAuditName: string): Recallable =
  ## deleteScheduledAudit
  ## Deletes a scheduled audit.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit you want to delete.
  var path_603924 = newJObject()
  add(path_603924, "scheduledAuditName", newJString(scheduledAuditName))
  result = call_603923.call(path_603924, nil, nil, nil, nil)

var deleteScheduledAudit* = Call_DeleteScheduledAudit_603911(
    name: "deleteScheduledAudit", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_DeleteScheduledAudit_603912, base: "/",
    url: url_DeleteScheduledAudit_603913, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateSecurityProfile_603955 = ref object of OpenApiRestCall_602466
proc url_CreateSecurityProfile_603957(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateSecurityProfile_603956(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name you are giving to the security profile.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_603958 = path.getOrDefault("securityProfileName")
  valid_603958 = validateParameter(valid_603958, JString, required = true,
                                 default = nil)
  if valid_603958 != nil:
    section.add "securityProfileName", valid_603958
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603959 = header.getOrDefault("X-Amz-Date")
  valid_603959 = validateParameter(valid_603959, JString, required = false,
                                 default = nil)
  if valid_603959 != nil:
    section.add "X-Amz-Date", valid_603959
  var valid_603960 = header.getOrDefault("X-Amz-Security-Token")
  valid_603960 = validateParameter(valid_603960, JString, required = false,
                                 default = nil)
  if valid_603960 != nil:
    section.add "X-Amz-Security-Token", valid_603960
  var valid_603961 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603961 = validateParameter(valid_603961, JString, required = false,
                                 default = nil)
  if valid_603961 != nil:
    section.add "X-Amz-Content-Sha256", valid_603961
  var valid_603962 = header.getOrDefault("X-Amz-Algorithm")
  valid_603962 = validateParameter(valid_603962, JString, required = false,
                                 default = nil)
  if valid_603962 != nil:
    section.add "X-Amz-Algorithm", valid_603962
  var valid_603963 = header.getOrDefault("X-Amz-Signature")
  valid_603963 = validateParameter(valid_603963, JString, required = false,
                                 default = nil)
  if valid_603963 != nil:
    section.add "X-Amz-Signature", valid_603963
  var valid_603964 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603964 = validateParameter(valid_603964, JString, required = false,
                                 default = nil)
  if valid_603964 != nil:
    section.add "X-Amz-SignedHeaders", valid_603964
  var valid_603965 = header.getOrDefault("X-Amz-Credential")
  valid_603965 = validateParameter(valid_603965, JString, required = false,
                                 default = nil)
  if valid_603965 != nil:
    section.add "X-Amz-Credential", valid_603965
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_603967: Call_CreateSecurityProfile_603955; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Device Defender security profile.
  ## 
  let valid = call_603967.validator(path, query, header, formData, body)
  let scheme = call_603967.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603967.url(scheme.get, call_603967.host, call_603967.base,
                         call_603967.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603967, url, valid)

proc call*(call_603968: Call_CreateSecurityProfile_603955; body: JsonNode;
          securityProfileName: string): Recallable =
  ## createSecurityProfile
  ## Creates a Device Defender security profile.
  ##   body: JObject (required)
  ##   securityProfileName: string (required)
  ##                      : The name you are giving to the security profile.
  var path_603969 = newJObject()
  var body_603970 = newJObject()
  if body != nil:
    body_603970 = body
  add(path_603969, "securityProfileName", newJString(securityProfileName))
  result = call_603968.call(path_603969, nil, nil, nil, body_603970)

var createSecurityProfile* = Call_CreateSecurityProfile_603955(
    name: "createSecurityProfile", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_CreateSecurityProfile_603956, base: "/",
    url: url_CreateSecurityProfile_603957, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeSecurityProfile_603941 = ref object of OpenApiRestCall_602466
proc url_DescribeSecurityProfile_603943(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeSecurityProfile_603942(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile whose information you want to get.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_603944 = path.getOrDefault("securityProfileName")
  valid_603944 = validateParameter(valid_603944, JString, required = true,
                                 default = nil)
  if valid_603944 != nil:
    section.add "securityProfileName", valid_603944
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603945 = header.getOrDefault("X-Amz-Date")
  valid_603945 = validateParameter(valid_603945, JString, required = false,
                                 default = nil)
  if valid_603945 != nil:
    section.add "X-Amz-Date", valid_603945
  var valid_603946 = header.getOrDefault("X-Amz-Security-Token")
  valid_603946 = validateParameter(valid_603946, JString, required = false,
                                 default = nil)
  if valid_603946 != nil:
    section.add "X-Amz-Security-Token", valid_603946
  var valid_603947 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603947 = validateParameter(valid_603947, JString, required = false,
                                 default = nil)
  if valid_603947 != nil:
    section.add "X-Amz-Content-Sha256", valid_603947
  var valid_603948 = header.getOrDefault("X-Amz-Algorithm")
  valid_603948 = validateParameter(valid_603948, JString, required = false,
                                 default = nil)
  if valid_603948 != nil:
    section.add "X-Amz-Algorithm", valid_603948
  var valid_603949 = header.getOrDefault("X-Amz-Signature")
  valid_603949 = validateParameter(valid_603949, JString, required = false,
                                 default = nil)
  if valid_603949 != nil:
    section.add "X-Amz-Signature", valid_603949
  var valid_603950 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603950 = validateParameter(valid_603950, JString, required = false,
                                 default = nil)
  if valid_603950 != nil:
    section.add "X-Amz-SignedHeaders", valid_603950
  var valid_603951 = header.getOrDefault("X-Amz-Credential")
  valid_603951 = validateParameter(valid_603951, JString, required = false,
                                 default = nil)
  if valid_603951 != nil:
    section.add "X-Amz-Credential", valid_603951
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603952: Call_DescribeSecurityProfile_603941; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a Device Defender security profile.
  ## 
  let valid = call_603952.validator(path, query, header, formData, body)
  let scheme = call_603952.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603952.url(scheme.get, call_603952.host, call_603952.base,
                         call_603952.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603952, url, valid)

proc call*(call_603953: Call_DescribeSecurityProfile_603941;
          securityProfileName: string): Recallable =
  ## describeSecurityProfile
  ## Gets information about a Device Defender security profile.
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile whose information you want to get.
  var path_603954 = newJObject()
  add(path_603954, "securityProfileName", newJString(securityProfileName))
  result = call_603953.call(path_603954, nil, nil, nil, nil)

var describeSecurityProfile* = Call_DescribeSecurityProfile_603941(
    name: "describeSecurityProfile", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_DescribeSecurityProfile_603942, base: "/",
    url: url_DescribeSecurityProfile_603943, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateSecurityProfile_603987 = ref object of OpenApiRestCall_602466
proc url_UpdateSecurityProfile_603989(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateSecurityProfile_603988(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile you want to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_603990 = path.getOrDefault("securityProfileName")
  valid_603990 = validateParameter(valid_603990, JString, required = true,
                                 default = nil)
  if valid_603990 != nil:
    section.add "securityProfileName", valid_603990
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  section = newJObject()
  var valid_603991 = query.getOrDefault("expectedVersion")
  valid_603991 = validateParameter(valid_603991, JInt, required = false, default = nil)
  if valid_603991 != nil:
    section.add "expectedVersion", valid_603991
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603992 = header.getOrDefault("X-Amz-Date")
  valid_603992 = validateParameter(valid_603992, JString, required = false,
                                 default = nil)
  if valid_603992 != nil:
    section.add "X-Amz-Date", valid_603992
  var valid_603993 = header.getOrDefault("X-Amz-Security-Token")
  valid_603993 = validateParameter(valid_603993, JString, required = false,
                                 default = nil)
  if valid_603993 != nil:
    section.add "X-Amz-Security-Token", valid_603993
  var valid_603994 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603994 = validateParameter(valid_603994, JString, required = false,
                                 default = nil)
  if valid_603994 != nil:
    section.add "X-Amz-Content-Sha256", valid_603994
  var valid_603995 = header.getOrDefault("X-Amz-Algorithm")
  valid_603995 = validateParameter(valid_603995, JString, required = false,
                                 default = nil)
  if valid_603995 != nil:
    section.add "X-Amz-Algorithm", valid_603995
  var valid_603996 = header.getOrDefault("X-Amz-Signature")
  valid_603996 = validateParameter(valid_603996, JString, required = false,
                                 default = nil)
  if valid_603996 != nil:
    section.add "X-Amz-Signature", valid_603996
  var valid_603997 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603997 = validateParameter(valid_603997, JString, required = false,
                                 default = nil)
  if valid_603997 != nil:
    section.add "X-Amz-SignedHeaders", valid_603997
  var valid_603998 = header.getOrDefault("X-Amz-Credential")
  valid_603998 = validateParameter(valid_603998, JString, required = false,
                                 default = nil)
  if valid_603998 != nil:
    section.add "X-Amz-Credential", valid_603998
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604000: Call_UpdateSecurityProfile_603987; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a Device Defender security profile.
  ## 
  let valid = call_604000.validator(path, query, header, formData, body)
  let scheme = call_604000.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604000.url(scheme.get, call_604000.host, call_604000.base,
                         call_604000.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604000, url, valid)

proc call*(call_604001: Call_UpdateSecurityProfile_603987; body: JsonNode;
          securityProfileName: string; expectedVersion: int = 0): Recallable =
  ## updateSecurityProfile
  ## Updates a Device Defender security profile.
  ##   expectedVersion: int
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  ##   body: JObject (required)
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile you want to update.
  var path_604002 = newJObject()
  var query_604003 = newJObject()
  var body_604004 = newJObject()
  add(query_604003, "expectedVersion", newJInt(expectedVersion))
  if body != nil:
    body_604004 = body
  add(path_604002, "securityProfileName", newJString(securityProfileName))
  result = call_604001.call(path_604002, query_604003, nil, nil, body_604004)

var updateSecurityProfile* = Call_UpdateSecurityProfile_603987(
    name: "updateSecurityProfile", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_UpdateSecurityProfile_603988, base: "/",
    url: url_UpdateSecurityProfile_603989, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteSecurityProfile_603971 = ref object of OpenApiRestCall_602466
proc url_DeleteSecurityProfile_603973(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteSecurityProfile_603972(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile to be deleted.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_603974 = path.getOrDefault("securityProfileName")
  valid_603974 = validateParameter(valid_603974, JString, required = true,
                                 default = nil)
  if valid_603974 != nil:
    section.add "securityProfileName", valid_603974
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  section = newJObject()
  var valid_603975 = query.getOrDefault("expectedVersion")
  valid_603975 = validateParameter(valid_603975, JInt, required = false, default = nil)
  if valid_603975 != nil:
    section.add "expectedVersion", valid_603975
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603976 = header.getOrDefault("X-Amz-Date")
  valid_603976 = validateParameter(valid_603976, JString, required = false,
                                 default = nil)
  if valid_603976 != nil:
    section.add "X-Amz-Date", valid_603976
  var valid_603977 = header.getOrDefault("X-Amz-Security-Token")
  valid_603977 = validateParameter(valid_603977, JString, required = false,
                                 default = nil)
  if valid_603977 != nil:
    section.add "X-Amz-Security-Token", valid_603977
  var valid_603978 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603978 = validateParameter(valid_603978, JString, required = false,
                                 default = nil)
  if valid_603978 != nil:
    section.add "X-Amz-Content-Sha256", valid_603978
  var valid_603979 = header.getOrDefault("X-Amz-Algorithm")
  valid_603979 = validateParameter(valid_603979, JString, required = false,
                                 default = nil)
  if valid_603979 != nil:
    section.add "X-Amz-Algorithm", valid_603979
  var valid_603980 = header.getOrDefault("X-Amz-Signature")
  valid_603980 = validateParameter(valid_603980, JString, required = false,
                                 default = nil)
  if valid_603980 != nil:
    section.add "X-Amz-Signature", valid_603980
  var valid_603981 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603981 = validateParameter(valid_603981, JString, required = false,
                                 default = nil)
  if valid_603981 != nil:
    section.add "X-Amz-SignedHeaders", valid_603981
  var valid_603982 = header.getOrDefault("X-Amz-Credential")
  valid_603982 = validateParameter(valid_603982, JString, required = false,
                                 default = nil)
  if valid_603982 != nil:
    section.add "X-Amz-Credential", valid_603982
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603983: Call_DeleteSecurityProfile_603971; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a Device Defender security profile.
  ## 
  let valid = call_603983.validator(path, query, header, formData, body)
  let scheme = call_603983.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603983.url(scheme.get, call_603983.host, call_603983.base,
                         call_603983.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_603983, url, valid)

proc call*(call_603984: Call_DeleteSecurityProfile_603971;
          securityProfileName: string; expectedVersion: int = 0): Recallable =
  ## deleteSecurityProfile
  ## Deletes a Device Defender security profile.
  ##   expectedVersion: int
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile to be deleted.
  var path_603985 = newJObject()
  var query_603986 = newJObject()
  add(query_603986, "expectedVersion", newJInt(expectedVersion))
  add(path_603985, "securityProfileName", newJString(securityProfileName))
  result = call_603984.call(path_603985, query_603986, nil, nil, nil)

var deleteSecurityProfile* = Call_DeleteSecurityProfile_603971(
    name: "deleteSecurityProfile", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_DeleteSecurityProfile_603972, base: "/",
    url: url_DeleteSecurityProfile_603973, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateStream_604019 = ref object of OpenApiRestCall_602466
proc url_UpdateStream_604021(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateStream_604020(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing stream. The stream version will be incremented by one.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_604022 = path.getOrDefault("streamId")
  valid_604022 = validateParameter(valid_604022, JString, required = true,
                                 default = nil)
  if valid_604022 != nil:
    section.add "streamId", valid_604022
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604023 = header.getOrDefault("X-Amz-Date")
  valid_604023 = validateParameter(valid_604023, JString, required = false,
                                 default = nil)
  if valid_604023 != nil:
    section.add "X-Amz-Date", valid_604023
  var valid_604024 = header.getOrDefault("X-Amz-Security-Token")
  valid_604024 = validateParameter(valid_604024, JString, required = false,
                                 default = nil)
  if valid_604024 != nil:
    section.add "X-Amz-Security-Token", valid_604024
  var valid_604025 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604025 = validateParameter(valid_604025, JString, required = false,
                                 default = nil)
  if valid_604025 != nil:
    section.add "X-Amz-Content-Sha256", valid_604025
  var valid_604026 = header.getOrDefault("X-Amz-Algorithm")
  valid_604026 = validateParameter(valid_604026, JString, required = false,
                                 default = nil)
  if valid_604026 != nil:
    section.add "X-Amz-Algorithm", valid_604026
  var valid_604027 = header.getOrDefault("X-Amz-Signature")
  valid_604027 = validateParameter(valid_604027, JString, required = false,
                                 default = nil)
  if valid_604027 != nil:
    section.add "X-Amz-Signature", valid_604027
  var valid_604028 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604028 = validateParameter(valid_604028, JString, required = false,
                                 default = nil)
  if valid_604028 != nil:
    section.add "X-Amz-SignedHeaders", valid_604028
  var valid_604029 = header.getOrDefault("X-Amz-Credential")
  valid_604029 = validateParameter(valid_604029, JString, required = false,
                                 default = nil)
  if valid_604029 != nil:
    section.add "X-Amz-Credential", valid_604029
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604031: Call_UpdateStream_604019; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing stream. The stream version will be incremented by one.
  ## 
  let valid = call_604031.validator(path, query, header, formData, body)
  let scheme = call_604031.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604031.url(scheme.get, call_604031.host, call_604031.base,
                         call_604031.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604031, url, valid)

proc call*(call_604032: Call_UpdateStream_604019; body: JsonNode; streamId: string): Recallable =
  ## updateStream
  ## Updates an existing stream. The stream version will be incremented by one.
  ##   body: JObject (required)
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_604033 = newJObject()
  var body_604034 = newJObject()
  if body != nil:
    body_604034 = body
  add(path_604033, "streamId", newJString(streamId))
  result = call_604032.call(path_604033, nil, nil, nil, body_604034)

var updateStream* = Call_UpdateStream_604019(name: "updateStream",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_UpdateStream_604020,
    base: "/", url: url_UpdateStream_604021, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateStream_604035 = ref object of OpenApiRestCall_602466
proc url_CreateStream_604037(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateStream_604036(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream. The total size of a file associated with the stream cannot exceed more than 2 MB. The stream will be created with version 0. If a stream is created with the same streamID as a stream that existed and was deleted within last 90 days, we will resurrect that old stream by incrementing the version by 1.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_604038 = path.getOrDefault("streamId")
  valid_604038 = validateParameter(valid_604038, JString, required = true,
                                 default = nil)
  if valid_604038 != nil:
    section.add "streamId", valid_604038
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604039 = header.getOrDefault("X-Amz-Date")
  valid_604039 = validateParameter(valid_604039, JString, required = false,
                                 default = nil)
  if valid_604039 != nil:
    section.add "X-Amz-Date", valid_604039
  var valid_604040 = header.getOrDefault("X-Amz-Security-Token")
  valid_604040 = validateParameter(valid_604040, JString, required = false,
                                 default = nil)
  if valid_604040 != nil:
    section.add "X-Amz-Security-Token", valid_604040
  var valid_604041 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604041 = validateParameter(valid_604041, JString, required = false,
                                 default = nil)
  if valid_604041 != nil:
    section.add "X-Amz-Content-Sha256", valid_604041
  var valid_604042 = header.getOrDefault("X-Amz-Algorithm")
  valid_604042 = validateParameter(valid_604042, JString, required = false,
                                 default = nil)
  if valid_604042 != nil:
    section.add "X-Amz-Algorithm", valid_604042
  var valid_604043 = header.getOrDefault("X-Amz-Signature")
  valid_604043 = validateParameter(valid_604043, JString, required = false,
                                 default = nil)
  if valid_604043 != nil:
    section.add "X-Amz-Signature", valid_604043
  var valid_604044 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604044 = validateParameter(valid_604044, JString, required = false,
                                 default = nil)
  if valid_604044 != nil:
    section.add "X-Amz-SignedHeaders", valid_604044
  var valid_604045 = header.getOrDefault("X-Amz-Credential")
  valid_604045 = validateParameter(valid_604045, JString, required = false,
                                 default = nil)
  if valid_604045 != nil:
    section.add "X-Amz-Credential", valid_604045
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604047: Call_CreateStream_604035; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream. The total size of a file associated with the stream cannot exceed more than 2 MB. The stream will be created with version 0. If a stream is created with the same streamID as a stream that existed and was deleted within last 90 days, we will resurrect that old stream by incrementing the version by 1.
  ## 
  let valid = call_604047.validator(path, query, header, formData, body)
  let scheme = call_604047.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604047.url(scheme.get, call_604047.host, call_604047.base,
                         call_604047.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604047, url, valid)

proc call*(call_604048: Call_CreateStream_604035; body: JsonNode; streamId: string): Recallable =
  ## createStream
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream. The total size of a file associated with the stream cannot exceed more than 2 MB. The stream will be created with version 0. If a stream is created with the same streamID as a stream that existed and was deleted within last 90 days, we will resurrect that old stream by incrementing the version by 1.
  ##   body: JObject (required)
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_604049 = newJObject()
  var body_604050 = newJObject()
  if body != nil:
    body_604050 = body
  add(path_604049, "streamId", newJString(streamId))
  result = call_604048.call(path_604049, nil, nil, nil, body_604050)

var createStream* = Call_CreateStream_604035(name: "createStream",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_CreateStream_604036,
    base: "/", url: url_CreateStream_604037, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeStream_604005 = ref object of OpenApiRestCall_602466
proc url_DescribeStream_604007(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeStream_604006(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets information about a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_604008 = path.getOrDefault("streamId")
  valid_604008 = validateParameter(valid_604008, JString, required = true,
                                 default = nil)
  if valid_604008 != nil:
    section.add "streamId", valid_604008
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604009 = header.getOrDefault("X-Amz-Date")
  valid_604009 = validateParameter(valid_604009, JString, required = false,
                                 default = nil)
  if valid_604009 != nil:
    section.add "X-Amz-Date", valid_604009
  var valid_604010 = header.getOrDefault("X-Amz-Security-Token")
  valid_604010 = validateParameter(valid_604010, JString, required = false,
                                 default = nil)
  if valid_604010 != nil:
    section.add "X-Amz-Security-Token", valid_604010
  var valid_604011 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604011 = validateParameter(valid_604011, JString, required = false,
                                 default = nil)
  if valid_604011 != nil:
    section.add "X-Amz-Content-Sha256", valid_604011
  var valid_604012 = header.getOrDefault("X-Amz-Algorithm")
  valid_604012 = validateParameter(valid_604012, JString, required = false,
                                 default = nil)
  if valid_604012 != nil:
    section.add "X-Amz-Algorithm", valid_604012
  var valid_604013 = header.getOrDefault("X-Amz-Signature")
  valid_604013 = validateParameter(valid_604013, JString, required = false,
                                 default = nil)
  if valid_604013 != nil:
    section.add "X-Amz-Signature", valid_604013
  var valid_604014 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604014 = validateParameter(valid_604014, JString, required = false,
                                 default = nil)
  if valid_604014 != nil:
    section.add "X-Amz-SignedHeaders", valid_604014
  var valid_604015 = header.getOrDefault("X-Amz-Credential")
  valid_604015 = validateParameter(valid_604015, JString, required = false,
                                 default = nil)
  if valid_604015 != nil:
    section.add "X-Amz-Credential", valid_604015
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604016: Call_DescribeStream_604005; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a stream.
  ## 
  let valid = call_604016.validator(path, query, header, formData, body)
  let scheme = call_604016.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604016.url(scheme.get, call_604016.host, call_604016.base,
                         call_604016.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604016, url, valid)

proc call*(call_604017: Call_DescribeStream_604005; streamId: string): Recallable =
  ## describeStream
  ## Gets information about a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_604018 = newJObject()
  add(path_604018, "streamId", newJString(streamId))
  result = call_604017.call(path_604018, nil, nil, nil, nil)

var describeStream* = Call_DescribeStream_604005(name: "describeStream",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_DescribeStream_604006,
    base: "/", url: url_DescribeStream_604007, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteStream_604051 = ref object of OpenApiRestCall_602466
proc url_DeleteStream_604053(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteStream_604052(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_604054 = path.getOrDefault("streamId")
  valid_604054 = validateParameter(valid_604054, JString, required = true,
                                 default = nil)
  if valid_604054 != nil:
    section.add "streamId", valid_604054
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604055 = header.getOrDefault("X-Amz-Date")
  valid_604055 = validateParameter(valid_604055, JString, required = false,
                                 default = nil)
  if valid_604055 != nil:
    section.add "X-Amz-Date", valid_604055
  var valid_604056 = header.getOrDefault("X-Amz-Security-Token")
  valid_604056 = validateParameter(valid_604056, JString, required = false,
                                 default = nil)
  if valid_604056 != nil:
    section.add "X-Amz-Security-Token", valid_604056
  var valid_604057 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604057 = validateParameter(valid_604057, JString, required = false,
                                 default = nil)
  if valid_604057 != nil:
    section.add "X-Amz-Content-Sha256", valid_604057
  var valid_604058 = header.getOrDefault("X-Amz-Algorithm")
  valid_604058 = validateParameter(valid_604058, JString, required = false,
                                 default = nil)
  if valid_604058 != nil:
    section.add "X-Amz-Algorithm", valid_604058
  var valid_604059 = header.getOrDefault("X-Amz-Signature")
  valid_604059 = validateParameter(valid_604059, JString, required = false,
                                 default = nil)
  if valid_604059 != nil:
    section.add "X-Amz-Signature", valid_604059
  var valid_604060 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604060 = validateParameter(valid_604060, JString, required = false,
                                 default = nil)
  if valid_604060 != nil:
    section.add "X-Amz-SignedHeaders", valid_604060
  var valid_604061 = header.getOrDefault("X-Amz-Credential")
  valid_604061 = validateParameter(valid_604061, JString, required = false,
                                 default = nil)
  if valid_604061 != nil:
    section.add "X-Amz-Credential", valid_604061
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604062: Call_DeleteStream_604051; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a stream.
  ## 
  let valid = call_604062.validator(path, query, header, formData, body)
  let scheme = call_604062.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604062.url(scheme.get, call_604062.host, call_604062.base,
                         call_604062.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604062, url, valid)

proc call*(call_604063: Call_DeleteStream_604051; streamId: string): Recallable =
  ## deleteStream
  ## Deletes a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_604064 = newJObject()
  add(path_604064, "streamId", newJString(streamId))
  result = call_604063.call(path_604064, nil, nil, nil, nil)

var deleteStream* = Call_DeleteStream_604051(name: "deleteStream",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_DeleteStream_604052,
    base: "/", url: url_DeleteStream_604053, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThing_604079 = ref object of OpenApiRestCall_602466
proc url_CreateThing_604081(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateThing_604080(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to create.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_604082 = path.getOrDefault("thingName")
  valid_604082 = validateParameter(valid_604082, JString, required = true,
                                 default = nil)
  if valid_604082 != nil:
    section.add "thingName", valid_604082
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604083 = header.getOrDefault("X-Amz-Date")
  valid_604083 = validateParameter(valid_604083, JString, required = false,
                                 default = nil)
  if valid_604083 != nil:
    section.add "X-Amz-Date", valid_604083
  var valid_604084 = header.getOrDefault("X-Amz-Security-Token")
  valid_604084 = validateParameter(valid_604084, JString, required = false,
                                 default = nil)
  if valid_604084 != nil:
    section.add "X-Amz-Security-Token", valid_604084
  var valid_604085 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604085 = validateParameter(valid_604085, JString, required = false,
                                 default = nil)
  if valid_604085 != nil:
    section.add "X-Amz-Content-Sha256", valid_604085
  var valid_604086 = header.getOrDefault("X-Amz-Algorithm")
  valid_604086 = validateParameter(valid_604086, JString, required = false,
                                 default = nil)
  if valid_604086 != nil:
    section.add "X-Amz-Algorithm", valid_604086
  var valid_604087 = header.getOrDefault("X-Amz-Signature")
  valid_604087 = validateParameter(valid_604087, JString, required = false,
                                 default = nil)
  if valid_604087 != nil:
    section.add "X-Amz-Signature", valid_604087
  var valid_604088 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604088 = validateParameter(valid_604088, JString, required = false,
                                 default = nil)
  if valid_604088 != nil:
    section.add "X-Amz-SignedHeaders", valid_604088
  var valid_604089 = header.getOrDefault("X-Amz-Credential")
  valid_604089 = validateParameter(valid_604089, JString, required = false,
                                 default = nil)
  if valid_604089 != nil:
    section.add "X-Amz-Credential", valid_604089
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604091: Call_CreateThing_604079; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  let valid = call_604091.validator(path, query, header, formData, body)
  let scheme = call_604091.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604091.url(scheme.get, call_604091.host, call_604091.base,
                         call_604091.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604091, url, valid)

proc call*(call_604092: Call_CreateThing_604079; thingName: string; body: JsonNode): Recallable =
  ## createThing
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing to create.
  ##   body: JObject (required)
  var path_604093 = newJObject()
  var body_604094 = newJObject()
  add(path_604093, "thingName", newJString(thingName))
  if body != nil:
    body_604094 = body
  result = call_604092.call(path_604093, nil, nil, nil, body_604094)

var createThing* = Call_CreateThing_604079(name: "createThing",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_CreateThing_604080,
                                        base: "/", url: url_CreateThing_604081,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThing_604065 = ref object of OpenApiRestCall_602466
proc url_DescribeThing_604067(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeThing_604066(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the specified thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_604068 = path.getOrDefault("thingName")
  valid_604068 = validateParameter(valid_604068, JString, required = true,
                                 default = nil)
  if valid_604068 != nil:
    section.add "thingName", valid_604068
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604069 = header.getOrDefault("X-Amz-Date")
  valid_604069 = validateParameter(valid_604069, JString, required = false,
                                 default = nil)
  if valid_604069 != nil:
    section.add "X-Amz-Date", valid_604069
  var valid_604070 = header.getOrDefault("X-Amz-Security-Token")
  valid_604070 = validateParameter(valid_604070, JString, required = false,
                                 default = nil)
  if valid_604070 != nil:
    section.add "X-Amz-Security-Token", valid_604070
  var valid_604071 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604071 = validateParameter(valid_604071, JString, required = false,
                                 default = nil)
  if valid_604071 != nil:
    section.add "X-Amz-Content-Sha256", valid_604071
  var valid_604072 = header.getOrDefault("X-Amz-Algorithm")
  valid_604072 = validateParameter(valid_604072, JString, required = false,
                                 default = nil)
  if valid_604072 != nil:
    section.add "X-Amz-Algorithm", valid_604072
  var valid_604073 = header.getOrDefault("X-Amz-Signature")
  valid_604073 = validateParameter(valid_604073, JString, required = false,
                                 default = nil)
  if valid_604073 != nil:
    section.add "X-Amz-Signature", valid_604073
  var valid_604074 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604074 = validateParameter(valid_604074, JString, required = false,
                                 default = nil)
  if valid_604074 != nil:
    section.add "X-Amz-SignedHeaders", valid_604074
  var valid_604075 = header.getOrDefault("X-Amz-Credential")
  valid_604075 = validateParameter(valid_604075, JString, required = false,
                                 default = nil)
  if valid_604075 != nil:
    section.add "X-Amz-Credential", valid_604075
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604076: Call_DescribeThing_604065; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified thing.
  ## 
  let valid = call_604076.validator(path, query, header, formData, body)
  let scheme = call_604076.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604076.url(scheme.get, call_604076.host, call_604076.base,
                         call_604076.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604076, url, valid)

proc call*(call_604077: Call_DescribeThing_604065; thingName: string): Recallable =
  ## describeThing
  ## Gets information about the specified thing.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_604078 = newJObject()
  add(path_604078, "thingName", newJString(thingName))
  result = call_604077.call(path_604078, nil, nil, nil, nil)

var describeThing* = Call_DescribeThing_604065(name: "describeThing",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/things/{thingName}", validator: validate_DescribeThing_604066,
    base: "/", url: url_DescribeThing_604067, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThing_604111 = ref object of OpenApiRestCall_602466
proc url_UpdateThing_604113(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateThing_604112(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the data for a thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_604114 = path.getOrDefault("thingName")
  valid_604114 = validateParameter(valid_604114, JString, required = true,
                                 default = nil)
  if valid_604114 != nil:
    section.add "thingName", valid_604114
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604115 = header.getOrDefault("X-Amz-Date")
  valid_604115 = validateParameter(valid_604115, JString, required = false,
                                 default = nil)
  if valid_604115 != nil:
    section.add "X-Amz-Date", valid_604115
  var valid_604116 = header.getOrDefault("X-Amz-Security-Token")
  valid_604116 = validateParameter(valid_604116, JString, required = false,
                                 default = nil)
  if valid_604116 != nil:
    section.add "X-Amz-Security-Token", valid_604116
  var valid_604117 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604117 = validateParameter(valid_604117, JString, required = false,
                                 default = nil)
  if valid_604117 != nil:
    section.add "X-Amz-Content-Sha256", valid_604117
  var valid_604118 = header.getOrDefault("X-Amz-Algorithm")
  valid_604118 = validateParameter(valid_604118, JString, required = false,
                                 default = nil)
  if valid_604118 != nil:
    section.add "X-Amz-Algorithm", valid_604118
  var valid_604119 = header.getOrDefault("X-Amz-Signature")
  valid_604119 = validateParameter(valid_604119, JString, required = false,
                                 default = nil)
  if valid_604119 != nil:
    section.add "X-Amz-Signature", valid_604119
  var valid_604120 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604120 = validateParameter(valid_604120, JString, required = false,
                                 default = nil)
  if valid_604120 != nil:
    section.add "X-Amz-SignedHeaders", valid_604120
  var valid_604121 = header.getOrDefault("X-Amz-Credential")
  valid_604121 = validateParameter(valid_604121, JString, required = false,
                                 default = nil)
  if valid_604121 != nil:
    section.add "X-Amz-Credential", valid_604121
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604123: Call_UpdateThing_604111; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the data for a thing.
  ## 
  let valid = call_604123.validator(path, query, header, formData, body)
  let scheme = call_604123.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604123.url(scheme.get, call_604123.host, call_604123.base,
                         call_604123.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604123, url, valid)

proc call*(call_604124: Call_UpdateThing_604111; thingName: string; body: JsonNode): Recallable =
  ## updateThing
  ## Updates the data for a thing.
  ##   thingName: string (required)
  ##            : The name of the thing to update.
  ##   body: JObject (required)
  var path_604125 = newJObject()
  var body_604126 = newJObject()
  add(path_604125, "thingName", newJString(thingName))
  if body != nil:
    body_604126 = body
  result = call_604124.call(path_604125, nil, nil, nil, body_604126)

var updateThing* = Call_UpdateThing_604111(name: "updateThing",
                                        meth: HttpMethod.HttpPatch,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_UpdateThing_604112,
                                        base: "/", url: url_UpdateThing_604113,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThing_604095 = ref object of OpenApiRestCall_602466
proc url_DeleteThing_604097(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteThing_604096(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_604098 = path.getOrDefault("thingName")
  valid_604098 = validateParameter(valid_604098, JString, required = true,
                                 default = nil)
  if valid_604098 != nil:
    section.add "thingName", valid_604098
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.
  section = newJObject()
  var valid_604099 = query.getOrDefault("expectedVersion")
  valid_604099 = validateParameter(valid_604099, JInt, required = false, default = nil)
  if valid_604099 != nil:
    section.add "expectedVersion", valid_604099
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604100 = header.getOrDefault("X-Amz-Date")
  valid_604100 = validateParameter(valid_604100, JString, required = false,
                                 default = nil)
  if valid_604100 != nil:
    section.add "X-Amz-Date", valid_604100
  var valid_604101 = header.getOrDefault("X-Amz-Security-Token")
  valid_604101 = validateParameter(valid_604101, JString, required = false,
                                 default = nil)
  if valid_604101 != nil:
    section.add "X-Amz-Security-Token", valid_604101
  var valid_604102 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604102 = validateParameter(valid_604102, JString, required = false,
                                 default = nil)
  if valid_604102 != nil:
    section.add "X-Amz-Content-Sha256", valid_604102
  var valid_604103 = header.getOrDefault("X-Amz-Algorithm")
  valid_604103 = validateParameter(valid_604103, JString, required = false,
                                 default = nil)
  if valid_604103 != nil:
    section.add "X-Amz-Algorithm", valid_604103
  var valid_604104 = header.getOrDefault("X-Amz-Signature")
  valid_604104 = validateParameter(valid_604104, JString, required = false,
                                 default = nil)
  if valid_604104 != nil:
    section.add "X-Amz-Signature", valid_604104
  var valid_604105 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604105 = validateParameter(valid_604105, JString, required = false,
                                 default = nil)
  if valid_604105 != nil:
    section.add "X-Amz-SignedHeaders", valid_604105
  var valid_604106 = header.getOrDefault("X-Amz-Credential")
  valid_604106 = validateParameter(valid_604106, JString, required = false,
                                 default = nil)
  if valid_604106 != nil:
    section.add "X-Amz-Credential", valid_604106
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604107: Call_DeleteThing_604095; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ## 
  let valid = call_604107.validator(path, query, header, formData, body)
  let scheme = call_604107.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604107.url(scheme.get, call_604107.host, call_604107.base,
                         call_604107.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604107, url, valid)

proc call*(call_604108: Call_DeleteThing_604095; thingName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteThing
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ##   expectedVersion: int
  ##                  : The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.
  ##   thingName: string (required)
  ##            : The name of the thing to delete.
  var path_604109 = newJObject()
  var query_604110 = newJObject()
  add(query_604110, "expectedVersion", newJInt(expectedVersion))
  add(path_604109, "thingName", newJString(thingName))
  result = call_604108.call(path_604109, query_604110, nil, nil, nil)

var deleteThing* = Call_DeleteThing_604095(name: "deleteThing",
                                        meth: HttpMethod.HttpDelete,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_DeleteThing_604096,
                                        base: "/", url: url_DeleteThing_604097,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThingGroup_604141 = ref object of OpenApiRestCall_602466
proc url_CreateThingGroup_604143(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateThingGroup_604142(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group name to create.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_604144 = path.getOrDefault("thingGroupName")
  valid_604144 = validateParameter(valid_604144, JString, required = true,
                                 default = nil)
  if valid_604144 != nil:
    section.add "thingGroupName", valid_604144
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604145 = header.getOrDefault("X-Amz-Date")
  valid_604145 = validateParameter(valid_604145, JString, required = false,
                                 default = nil)
  if valid_604145 != nil:
    section.add "X-Amz-Date", valid_604145
  var valid_604146 = header.getOrDefault("X-Amz-Security-Token")
  valid_604146 = validateParameter(valid_604146, JString, required = false,
                                 default = nil)
  if valid_604146 != nil:
    section.add "X-Amz-Security-Token", valid_604146
  var valid_604147 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604147 = validateParameter(valid_604147, JString, required = false,
                                 default = nil)
  if valid_604147 != nil:
    section.add "X-Amz-Content-Sha256", valid_604147
  var valid_604148 = header.getOrDefault("X-Amz-Algorithm")
  valid_604148 = validateParameter(valid_604148, JString, required = false,
                                 default = nil)
  if valid_604148 != nil:
    section.add "X-Amz-Algorithm", valid_604148
  var valid_604149 = header.getOrDefault("X-Amz-Signature")
  valid_604149 = validateParameter(valid_604149, JString, required = false,
                                 default = nil)
  if valid_604149 != nil:
    section.add "X-Amz-Signature", valid_604149
  var valid_604150 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604150 = validateParameter(valid_604150, JString, required = false,
                                 default = nil)
  if valid_604150 != nil:
    section.add "X-Amz-SignedHeaders", valid_604150
  var valid_604151 = header.getOrDefault("X-Amz-Credential")
  valid_604151 = validateParameter(valid_604151, JString, required = false,
                                 default = nil)
  if valid_604151 != nil:
    section.add "X-Amz-Credential", valid_604151
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604153: Call_CreateThingGroup_604141; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  let valid = call_604153.validator(path, query, header, formData, body)
  let scheme = call_604153.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604153.url(scheme.get, call_604153.host, call_604153.base,
                         call_604153.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604153, url, valid)

proc call*(call_604154: Call_CreateThingGroup_604141; body: JsonNode;
          thingGroupName: string): Recallable =
  ## createThingGroup
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ##   body: JObject (required)
  ##   thingGroupName: string (required)
  ##                 : The thing group name to create.
  var path_604155 = newJObject()
  var body_604156 = newJObject()
  if body != nil:
    body_604156 = body
  add(path_604155, "thingGroupName", newJString(thingGroupName))
  result = call_604154.call(path_604155, nil, nil, nil, body_604156)

var createThingGroup* = Call_CreateThingGroup_604141(name: "createThingGroup",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_CreateThingGroup_604142,
    base: "/", url: url_CreateThingGroup_604143,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingGroup_604127 = ref object of OpenApiRestCall_602466
proc url_DescribeThingGroup_604129(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeThingGroup_604128(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Describe a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the thing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_604130 = path.getOrDefault("thingGroupName")
  valid_604130 = validateParameter(valid_604130, JString, required = true,
                                 default = nil)
  if valid_604130 != nil:
    section.add "thingGroupName", valid_604130
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604131 = header.getOrDefault("X-Amz-Date")
  valid_604131 = validateParameter(valid_604131, JString, required = false,
                                 default = nil)
  if valid_604131 != nil:
    section.add "X-Amz-Date", valid_604131
  var valid_604132 = header.getOrDefault("X-Amz-Security-Token")
  valid_604132 = validateParameter(valid_604132, JString, required = false,
                                 default = nil)
  if valid_604132 != nil:
    section.add "X-Amz-Security-Token", valid_604132
  var valid_604133 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604133 = validateParameter(valid_604133, JString, required = false,
                                 default = nil)
  if valid_604133 != nil:
    section.add "X-Amz-Content-Sha256", valid_604133
  var valid_604134 = header.getOrDefault("X-Amz-Algorithm")
  valid_604134 = validateParameter(valid_604134, JString, required = false,
                                 default = nil)
  if valid_604134 != nil:
    section.add "X-Amz-Algorithm", valid_604134
  var valid_604135 = header.getOrDefault("X-Amz-Signature")
  valid_604135 = validateParameter(valid_604135, JString, required = false,
                                 default = nil)
  if valid_604135 != nil:
    section.add "X-Amz-Signature", valid_604135
  var valid_604136 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604136 = validateParameter(valid_604136, JString, required = false,
                                 default = nil)
  if valid_604136 != nil:
    section.add "X-Amz-SignedHeaders", valid_604136
  var valid_604137 = header.getOrDefault("X-Amz-Credential")
  valid_604137 = validateParameter(valid_604137, JString, required = false,
                                 default = nil)
  if valid_604137 != nil:
    section.add "X-Amz-Credential", valid_604137
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604138: Call_DescribeThingGroup_604127; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describe a thing group.
  ## 
  let valid = call_604138.validator(path, query, header, formData, body)
  let scheme = call_604138.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604138.url(scheme.get, call_604138.host, call_604138.base,
                         call_604138.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604138, url, valid)

proc call*(call_604139: Call_DescribeThingGroup_604127; thingGroupName: string): Recallable =
  ## describeThingGroup
  ## Describe a thing group.
  ##   thingGroupName: string (required)
  ##                 : The name of the thing group.
  var path_604140 = newJObject()
  add(path_604140, "thingGroupName", newJString(thingGroupName))
  result = call_604139.call(path_604140, nil, nil, nil, nil)

var describeThingGroup* = Call_DescribeThingGroup_604127(
    name: "describeThingGroup", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}",
    validator: validate_DescribeThingGroup_604128, base: "/",
    url: url_DescribeThingGroup_604129, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThingGroup_604173 = ref object of OpenApiRestCall_602466
proc url_UpdateThingGroup_604175(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateThingGroup_604174(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Update a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group to update.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_604176 = path.getOrDefault("thingGroupName")
  valid_604176 = validateParameter(valid_604176, JString, required = true,
                                 default = nil)
  if valid_604176 != nil:
    section.add "thingGroupName", valid_604176
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604177 = header.getOrDefault("X-Amz-Date")
  valid_604177 = validateParameter(valid_604177, JString, required = false,
                                 default = nil)
  if valid_604177 != nil:
    section.add "X-Amz-Date", valid_604177
  var valid_604178 = header.getOrDefault("X-Amz-Security-Token")
  valid_604178 = validateParameter(valid_604178, JString, required = false,
                                 default = nil)
  if valid_604178 != nil:
    section.add "X-Amz-Security-Token", valid_604178
  var valid_604179 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604179 = validateParameter(valid_604179, JString, required = false,
                                 default = nil)
  if valid_604179 != nil:
    section.add "X-Amz-Content-Sha256", valid_604179
  var valid_604180 = header.getOrDefault("X-Amz-Algorithm")
  valid_604180 = validateParameter(valid_604180, JString, required = false,
                                 default = nil)
  if valid_604180 != nil:
    section.add "X-Amz-Algorithm", valid_604180
  var valid_604181 = header.getOrDefault("X-Amz-Signature")
  valid_604181 = validateParameter(valid_604181, JString, required = false,
                                 default = nil)
  if valid_604181 != nil:
    section.add "X-Amz-Signature", valid_604181
  var valid_604182 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604182 = validateParameter(valid_604182, JString, required = false,
                                 default = nil)
  if valid_604182 != nil:
    section.add "X-Amz-SignedHeaders", valid_604182
  var valid_604183 = header.getOrDefault("X-Amz-Credential")
  valid_604183 = validateParameter(valid_604183, JString, required = false,
                                 default = nil)
  if valid_604183 != nil:
    section.add "X-Amz-Credential", valid_604183
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604185: Call_UpdateThingGroup_604173; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update a thing group.
  ## 
  let valid = call_604185.validator(path, query, header, formData, body)
  let scheme = call_604185.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604185.url(scheme.get, call_604185.host, call_604185.base,
                         call_604185.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604185, url, valid)

proc call*(call_604186: Call_UpdateThingGroup_604173; body: JsonNode;
          thingGroupName: string): Recallable =
  ## updateThingGroup
  ## Update a thing group.
  ##   body: JObject (required)
  ##   thingGroupName: string (required)
  ##                 : The thing group to update.
  var path_604187 = newJObject()
  var body_604188 = newJObject()
  if body != nil:
    body_604188 = body
  add(path_604187, "thingGroupName", newJString(thingGroupName))
  result = call_604186.call(path_604187, nil, nil, nil, body_604188)

var updateThingGroup* = Call_UpdateThingGroup_604173(name: "updateThingGroup",
    meth: HttpMethod.HttpPatch, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_UpdateThingGroup_604174,
    base: "/", url: url_UpdateThingGroup_604175,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThingGroup_604157 = ref object of OpenApiRestCall_602466
proc url_DeleteThingGroup_604159(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteThingGroup_604158(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Deletes a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the thing group to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_604160 = path.getOrDefault("thingGroupName")
  valid_604160 = validateParameter(valid_604160, JString, required = true,
                                 default = nil)
  if valid_604160 != nil:
    section.add "thingGroupName", valid_604160
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the thing group to delete.
  section = newJObject()
  var valid_604161 = query.getOrDefault("expectedVersion")
  valid_604161 = validateParameter(valid_604161, JInt, required = false, default = nil)
  if valid_604161 != nil:
    section.add "expectedVersion", valid_604161
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604162 = header.getOrDefault("X-Amz-Date")
  valid_604162 = validateParameter(valid_604162, JString, required = false,
                                 default = nil)
  if valid_604162 != nil:
    section.add "X-Amz-Date", valid_604162
  var valid_604163 = header.getOrDefault("X-Amz-Security-Token")
  valid_604163 = validateParameter(valid_604163, JString, required = false,
                                 default = nil)
  if valid_604163 != nil:
    section.add "X-Amz-Security-Token", valid_604163
  var valid_604164 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604164 = validateParameter(valid_604164, JString, required = false,
                                 default = nil)
  if valid_604164 != nil:
    section.add "X-Amz-Content-Sha256", valid_604164
  var valid_604165 = header.getOrDefault("X-Amz-Algorithm")
  valid_604165 = validateParameter(valid_604165, JString, required = false,
                                 default = nil)
  if valid_604165 != nil:
    section.add "X-Amz-Algorithm", valid_604165
  var valid_604166 = header.getOrDefault("X-Amz-Signature")
  valid_604166 = validateParameter(valid_604166, JString, required = false,
                                 default = nil)
  if valid_604166 != nil:
    section.add "X-Amz-Signature", valid_604166
  var valid_604167 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604167 = validateParameter(valid_604167, JString, required = false,
                                 default = nil)
  if valid_604167 != nil:
    section.add "X-Amz-SignedHeaders", valid_604167
  var valid_604168 = header.getOrDefault("X-Amz-Credential")
  valid_604168 = validateParameter(valid_604168, JString, required = false,
                                 default = nil)
  if valid_604168 != nil:
    section.add "X-Amz-Credential", valid_604168
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604169: Call_DeleteThingGroup_604157; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a thing group.
  ## 
  let valid = call_604169.validator(path, query, header, formData, body)
  let scheme = call_604169.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604169.url(scheme.get, call_604169.host, call_604169.base,
                         call_604169.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604169, url, valid)

proc call*(call_604170: Call_DeleteThingGroup_604157; thingGroupName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteThingGroup
  ## Deletes a thing group.
  ##   expectedVersion: int
  ##                  : The expected version of the thing group to delete.
  ##   thingGroupName: string (required)
  ##                 : The name of the thing group to delete.
  var path_604171 = newJObject()
  var query_604172 = newJObject()
  add(query_604172, "expectedVersion", newJInt(expectedVersion))
  add(path_604171, "thingGroupName", newJString(thingGroupName))
  result = call_604170.call(path_604171, query_604172, nil, nil, nil)

var deleteThingGroup* = Call_DeleteThingGroup_604157(name: "deleteThingGroup",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_DeleteThingGroup_604158,
    base: "/", url: url_DeleteThingGroup_604159,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThingType_604203 = ref object of OpenApiRestCall_602466
proc url_CreateThingType_604205(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateThingType_604204(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a new thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_604206 = path.getOrDefault("thingTypeName")
  valid_604206 = validateParameter(valid_604206, JString, required = true,
                                 default = nil)
  if valid_604206 != nil:
    section.add "thingTypeName", valid_604206
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604207 = header.getOrDefault("X-Amz-Date")
  valid_604207 = validateParameter(valid_604207, JString, required = false,
                                 default = nil)
  if valid_604207 != nil:
    section.add "X-Amz-Date", valid_604207
  var valid_604208 = header.getOrDefault("X-Amz-Security-Token")
  valid_604208 = validateParameter(valid_604208, JString, required = false,
                                 default = nil)
  if valid_604208 != nil:
    section.add "X-Amz-Security-Token", valid_604208
  var valid_604209 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604209 = validateParameter(valid_604209, JString, required = false,
                                 default = nil)
  if valid_604209 != nil:
    section.add "X-Amz-Content-Sha256", valid_604209
  var valid_604210 = header.getOrDefault("X-Amz-Algorithm")
  valid_604210 = validateParameter(valid_604210, JString, required = false,
                                 default = nil)
  if valid_604210 != nil:
    section.add "X-Amz-Algorithm", valid_604210
  var valid_604211 = header.getOrDefault("X-Amz-Signature")
  valid_604211 = validateParameter(valid_604211, JString, required = false,
                                 default = nil)
  if valid_604211 != nil:
    section.add "X-Amz-Signature", valid_604211
  var valid_604212 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604212 = validateParameter(valid_604212, JString, required = false,
                                 default = nil)
  if valid_604212 != nil:
    section.add "X-Amz-SignedHeaders", valid_604212
  var valid_604213 = header.getOrDefault("X-Amz-Credential")
  valid_604213 = validateParameter(valid_604213, JString, required = false,
                                 default = nil)
  if valid_604213 != nil:
    section.add "X-Amz-Credential", valid_604213
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604215: Call_CreateThingType_604203; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new thing type.
  ## 
  let valid = call_604215.validator(path, query, header, formData, body)
  let scheme = call_604215.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604215.url(scheme.get, call_604215.host, call_604215.base,
                         call_604215.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604215, url, valid)

proc call*(call_604216: Call_CreateThingType_604203; body: JsonNode;
          thingTypeName: string): Recallable =
  ## createThingType
  ## Creates a new thing type.
  ##   body: JObject (required)
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_604217 = newJObject()
  var body_604218 = newJObject()
  if body != nil:
    body_604218 = body
  add(path_604217, "thingTypeName", newJString(thingTypeName))
  result = call_604216.call(path_604217, nil, nil, nil, body_604218)

var createThingType* = Call_CreateThingType_604203(name: "createThingType",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_CreateThingType_604204,
    base: "/", url: url_CreateThingType_604205, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingType_604189 = ref object of OpenApiRestCall_602466
proc url_DescribeThingType_604191(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeThingType_604190(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Gets information about the specified thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_604192 = path.getOrDefault("thingTypeName")
  valid_604192 = validateParameter(valid_604192, JString, required = true,
                                 default = nil)
  if valid_604192 != nil:
    section.add "thingTypeName", valid_604192
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604193 = header.getOrDefault("X-Amz-Date")
  valid_604193 = validateParameter(valid_604193, JString, required = false,
                                 default = nil)
  if valid_604193 != nil:
    section.add "X-Amz-Date", valid_604193
  var valid_604194 = header.getOrDefault("X-Amz-Security-Token")
  valid_604194 = validateParameter(valid_604194, JString, required = false,
                                 default = nil)
  if valid_604194 != nil:
    section.add "X-Amz-Security-Token", valid_604194
  var valid_604195 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604195 = validateParameter(valid_604195, JString, required = false,
                                 default = nil)
  if valid_604195 != nil:
    section.add "X-Amz-Content-Sha256", valid_604195
  var valid_604196 = header.getOrDefault("X-Amz-Algorithm")
  valid_604196 = validateParameter(valid_604196, JString, required = false,
                                 default = nil)
  if valid_604196 != nil:
    section.add "X-Amz-Algorithm", valid_604196
  var valid_604197 = header.getOrDefault("X-Amz-Signature")
  valid_604197 = validateParameter(valid_604197, JString, required = false,
                                 default = nil)
  if valid_604197 != nil:
    section.add "X-Amz-Signature", valid_604197
  var valid_604198 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604198 = validateParameter(valid_604198, JString, required = false,
                                 default = nil)
  if valid_604198 != nil:
    section.add "X-Amz-SignedHeaders", valid_604198
  var valid_604199 = header.getOrDefault("X-Amz-Credential")
  valid_604199 = validateParameter(valid_604199, JString, required = false,
                                 default = nil)
  if valid_604199 != nil:
    section.add "X-Amz-Credential", valid_604199
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604200: Call_DescribeThingType_604189; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified thing type.
  ## 
  let valid = call_604200.validator(path, query, header, formData, body)
  let scheme = call_604200.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604200.url(scheme.get, call_604200.host, call_604200.base,
                         call_604200.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604200, url, valid)

proc call*(call_604201: Call_DescribeThingType_604189; thingTypeName: string): Recallable =
  ## describeThingType
  ## Gets information about the specified thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_604202 = newJObject()
  add(path_604202, "thingTypeName", newJString(thingTypeName))
  result = call_604201.call(path_604202, nil, nil, nil, nil)

var describeThingType* = Call_DescribeThingType_604189(name: "describeThingType",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_DescribeThingType_604190,
    base: "/", url: url_DescribeThingType_604191,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThingType_604219 = ref object of OpenApiRestCall_602466
proc url_DeleteThingType_604221(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteThingType_604220(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_604222 = path.getOrDefault("thingTypeName")
  valid_604222 = validateParameter(valid_604222, JString, required = true,
                                 default = nil)
  if valid_604222 != nil:
    section.add "thingTypeName", valid_604222
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604223 = header.getOrDefault("X-Amz-Date")
  valid_604223 = validateParameter(valid_604223, JString, required = false,
                                 default = nil)
  if valid_604223 != nil:
    section.add "X-Amz-Date", valid_604223
  var valid_604224 = header.getOrDefault("X-Amz-Security-Token")
  valid_604224 = validateParameter(valid_604224, JString, required = false,
                                 default = nil)
  if valid_604224 != nil:
    section.add "X-Amz-Security-Token", valid_604224
  var valid_604225 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604225 = validateParameter(valid_604225, JString, required = false,
                                 default = nil)
  if valid_604225 != nil:
    section.add "X-Amz-Content-Sha256", valid_604225
  var valid_604226 = header.getOrDefault("X-Amz-Algorithm")
  valid_604226 = validateParameter(valid_604226, JString, required = false,
                                 default = nil)
  if valid_604226 != nil:
    section.add "X-Amz-Algorithm", valid_604226
  var valid_604227 = header.getOrDefault("X-Amz-Signature")
  valid_604227 = validateParameter(valid_604227, JString, required = false,
                                 default = nil)
  if valid_604227 != nil:
    section.add "X-Amz-Signature", valid_604227
  var valid_604228 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604228 = validateParameter(valid_604228, JString, required = false,
                                 default = nil)
  if valid_604228 != nil:
    section.add "X-Amz-SignedHeaders", valid_604228
  var valid_604229 = header.getOrDefault("X-Amz-Credential")
  valid_604229 = validateParameter(valid_604229, JString, required = false,
                                 default = nil)
  if valid_604229 != nil:
    section.add "X-Amz-Credential", valid_604229
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604230: Call_DeleteThingType_604219; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ## 
  let valid = call_604230.validator(path, query, header, formData, body)
  let scheme = call_604230.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604230.url(scheme.get, call_604230.host, call_604230.base,
                         call_604230.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604230, url, valid)

proc call*(call_604231: Call_DeleteThingType_604219; thingTypeName: string): Recallable =
  ## deleteThingType
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_604232 = newJObject()
  add(path_604232, "thingTypeName", newJString(thingTypeName))
  result = call_604231.call(path_604232, nil, nil, nil, nil)

var deleteThingType* = Call_DeleteThingType_604219(name: "deleteThingType",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_DeleteThingType_604220,
    base: "/", url: url_DeleteThingType_604221, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateTopicRule_604247 = ref object of OpenApiRestCall_602466
proc url_CreateTopicRule_604249(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateTopicRule_604248(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_604250 = path.getOrDefault("ruleName")
  valid_604250 = validateParameter(valid_604250, JString, required = true,
                                 default = nil)
  if valid_604250 != nil:
    section.add "ruleName", valid_604250
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   x-amz-tagging: JString
  ##                : <p>Metadata which can be used to manage the topic rule.</p> <note> <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p> <p>For the CLI command-line parameter use format: --tags "key1=value1&amp;key2=value2..."</p> <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p> </note>
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604251 = header.getOrDefault("X-Amz-Date")
  valid_604251 = validateParameter(valid_604251, JString, required = false,
                                 default = nil)
  if valid_604251 != nil:
    section.add "X-Amz-Date", valid_604251
  var valid_604252 = header.getOrDefault("X-Amz-Security-Token")
  valid_604252 = validateParameter(valid_604252, JString, required = false,
                                 default = nil)
  if valid_604252 != nil:
    section.add "X-Amz-Security-Token", valid_604252
  var valid_604253 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604253 = validateParameter(valid_604253, JString, required = false,
                                 default = nil)
  if valid_604253 != nil:
    section.add "X-Amz-Content-Sha256", valid_604253
  var valid_604254 = header.getOrDefault("X-Amz-Algorithm")
  valid_604254 = validateParameter(valid_604254, JString, required = false,
                                 default = nil)
  if valid_604254 != nil:
    section.add "X-Amz-Algorithm", valid_604254
  var valid_604255 = header.getOrDefault("X-Amz-Signature")
  valid_604255 = validateParameter(valid_604255, JString, required = false,
                                 default = nil)
  if valid_604255 != nil:
    section.add "X-Amz-Signature", valid_604255
  var valid_604256 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604256 = validateParameter(valid_604256, JString, required = false,
                                 default = nil)
  if valid_604256 != nil:
    section.add "X-Amz-SignedHeaders", valid_604256
  var valid_604257 = header.getOrDefault("x-amz-tagging")
  valid_604257 = validateParameter(valid_604257, JString, required = false,
                                 default = nil)
  if valid_604257 != nil:
    section.add "x-amz-tagging", valid_604257
  var valid_604258 = header.getOrDefault("X-Amz-Credential")
  valid_604258 = validateParameter(valid_604258, JString, required = false,
                                 default = nil)
  if valid_604258 != nil:
    section.add "X-Amz-Credential", valid_604258
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604260: Call_CreateTopicRule_604247; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  let valid = call_604260.validator(path, query, header, formData, body)
  let scheme = call_604260.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604260.url(scheme.get, call_604260.host, call_604260.base,
                         call_604260.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604260, url, valid)

proc call*(call_604261: Call_CreateTopicRule_604247; ruleName: string; body: JsonNode): Recallable =
  ## createTopicRule
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  ##   body: JObject (required)
  var path_604262 = newJObject()
  var body_604263 = newJObject()
  add(path_604262, "ruleName", newJString(ruleName))
  if body != nil:
    body_604263 = body
  result = call_604261.call(path_604262, nil, nil, nil, body_604263)

var createTopicRule* = Call_CreateTopicRule_604247(name: "createTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_CreateTopicRule_604248,
    base: "/", url: url_CreateTopicRule_604249, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetTopicRule_604233 = ref object of OpenApiRestCall_602466
proc url_GetTopicRule_604235(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetTopicRule_604234(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_604236 = path.getOrDefault("ruleName")
  valid_604236 = validateParameter(valid_604236, JString, required = true,
                                 default = nil)
  if valid_604236 != nil:
    section.add "ruleName", valid_604236
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604237 = header.getOrDefault("X-Amz-Date")
  valid_604237 = validateParameter(valid_604237, JString, required = false,
                                 default = nil)
  if valid_604237 != nil:
    section.add "X-Amz-Date", valid_604237
  var valid_604238 = header.getOrDefault("X-Amz-Security-Token")
  valid_604238 = validateParameter(valid_604238, JString, required = false,
                                 default = nil)
  if valid_604238 != nil:
    section.add "X-Amz-Security-Token", valid_604238
  var valid_604239 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604239 = validateParameter(valid_604239, JString, required = false,
                                 default = nil)
  if valid_604239 != nil:
    section.add "X-Amz-Content-Sha256", valid_604239
  var valid_604240 = header.getOrDefault("X-Amz-Algorithm")
  valid_604240 = validateParameter(valid_604240, JString, required = false,
                                 default = nil)
  if valid_604240 != nil:
    section.add "X-Amz-Algorithm", valid_604240
  var valid_604241 = header.getOrDefault("X-Amz-Signature")
  valid_604241 = validateParameter(valid_604241, JString, required = false,
                                 default = nil)
  if valid_604241 != nil:
    section.add "X-Amz-Signature", valid_604241
  var valid_604242 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604242 = validateParameter(valid_604242, JString, required = false,
                                 default = nil)
  if valid_604242 != nil:
    section.add "X-Amz-SignedHeaders", valid_604242
  var valid_604243 = header.getOrDefault("X-Amz-Credential")
  valid_604243 = validateParameter(valid_604243, JString, required = false,
                                 default = nil)
  if valid_604243 != nil:
    section.add "X-Amz-Credential", valid_604243
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604244: Call_GetTopicRule_604233; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the rule.
  ## 
  let valid = call_604244.validator(path, query, header, formData, body)
  let scheme = call_604244.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604244.url(scheme.get, call_604244.host, call_604244.base,
                         call_604244.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604244, url, valid)

proc call*(call_604245: Call_GetTopicRule_604233; ruleName: string): Recallable =
  ## getTopicRule
  ## Gets information about the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  var path_604246 = newJObject()
  add(path_604246, "ruleName", newJString(ruleName))
  result = call_604245.call(path_604246, nil, nil, nil, nil)

var getTopicRule* = Call_GetTopicRule_604233(name: "getTopicRule",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/rules/{ruleName}",
    validator: validate_GetTopicRule_604234, base: "/", url: url_GetTopicRule_604235,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReplaceTopicRule_604278 = ref object of OpenApiRestCall_602466
proc url_ReplaceTopicRule_604280(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReplaceTopicRule_604279(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_604281 = path.getOrDefault("ruleName")
  valid_604281 = validateParameter(valid_604281, JString, required = true,
                                 default = nil)
  if valid_604281 != nil:
    section.add "ruleName", valid_604281
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604282 = header.getOrDefault("X-Amz-Date")
  valid_604282 = validateParameter(valid_604282, JString, required = false,
                                 default = nil)
  if valid_604282 != nil:
    section.add "X-Amz-Date", valid_604282
  var valid_604283 = header.getOrDefault("X-Amz-Security-Token")
  valid_604283 = validateParameter(valid_604283, JString, required = false,
                                 default = nil)
  if valid_604283 != nil:
    section.add "X-Amz-Security-Token", valid_604283
  var valid_604284 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604284 = validateParameter(valid_604284, JString, required = false,
                                 default = nil)
  if valid_604284 != nil:
    section.add "X-Amz-Content-Sha256", valid_604284
  var valid_604285 = header.getOrDefault("X-Amz-Algorithm")
  valid_604285 = validateParameter(valid_604285, JString, required = false,
                                 default = nil)
  if valid_604285 != nil:
    section.add "X-Amz-Algorithm", valid_604285
  var valid_604286 = header.getOrDefault("X-Amz-Signature")
  valid_604286 = validateParameter(valid_604286, JString, required = false,
                                 default = nil)
  if valid_604286 != nil:
    section.add "X-Amz-Signature", valid_604286
  var valid_604287 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604287 = validateParameter(valid_604287, JString, required = false,
                                 default = nil)
  if valid_604287 != nil:
    section.add "X-Amz-SignedHeaders", valid_604287
  var valid_604288 = header.getOrDefault("X-Amz-Credential")
  valid_604288 = validateParameter(valid_604288, JString, required = false,
                                 default = nil)
  if valid_604288 != nil:
    section.add "X-Amz-Credential", valid_604288
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604290: Call_ReplaceTopicRule_604278; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  let valid = call_604290.validator(path, query, header, formData, body)
  let scheme = call_604290.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604290.url(scheme.get, call_604290.host, call_604290.base,
                         call_604290.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604290, url, valid)

proc call*(call_604291: Call_ReplaceTopicRule_604278; ruleName: string;
          body: JsonNode): Recallable =
  ## replaceTopicRule
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  ##   body: JObject (required)
  var path_604292 = newJObject()
  var body_604293 = newJObject()
  add(path_604292, "ruleName", newJString(ruleName))
  if body != nil:
    body_604293 = body
  result = call_604291.call(path_604292, nil, nil, nil, body_604293)

var replaceTopicRule* = Call_ReplaceTopicRule_604278(name: "replaceTopicRule",
    meth: HttpMethod.HttpPatch, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_ReplaceTopicRule_604279,
    base: "/", url: url_ReplaceTopicRule_604280,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteTopicRule_604264 = ref object of OpenApiRestCall_602466
proc url_DeleteTopicRule_604266(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteTopicRule_604265(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_604267 = path.getOrDefault("ruleName")
  valid_604267 = validateParameter(valid_604267, JString, required = true,
                                 default = nil)
  if valid_604267 != nil:
    section.add "ruleName", valid_604267
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604268 = header.getOrDefault("X-Amz-Date")
  valid_604268 = validateParameter(valid_604268, JString, required = false,
                                 default = nil)
  if valid_604268 != nil:
    section.add "X-Amz-Date", valid_604268
  var valid_604269 = header.getOrDefault("X-Amz-Security-Token")
  valid_604269 = validateParameter(valid_604269, JString, required = false,
                                 default = nil)
  if valid_604269 != nil:
    section.add "X-Amz-Security-Token", valid_604269
  var valid_604270 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604270 = validateParameter(valid_604270, JString, required = false,
                                 default = nil)
  if valid_604270 != nil:
    section.add "X-Amz-Content-Sha256", valid_604270
  var valid_604271 = header.getOrDefault("X-Amz-Algorithm")
  valid_604271 = validateParameter(valid_604271, JString, required = false,
                                 default = nil)
  if valid_604271 != nil:
    section.add "X-Amz-Algorithm", valid_604271
  var valid_604272 = header.getOrDefault("X-Amz-Signature")
  valid_604272 = validateParameter(valid_604272, JString, required = false,
                                 default = nil)
  if valid_604272 != nil:
    section.add "X-Amz-Signature", valid_604272
  var valid_604273 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604273 = validateParameter(valid_604273, JString, required = false,
                                 default = nil)
  if valid_604273 != nil:
    section.add "X-Amz-SignedHeaders", valid_604273
  var valid_604274 = header.getOrDefault("X-Amz-Credential")
  valid_604274 = validateParameter(valid_604274, JString, required = false,
                                 default = nil)
  if valid_604274 != nil:
    section.add "X-Amz-Credential", valid_604274
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604275: Call_DeleteTopicRule_604264; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the rule.
  ## 
  let valid = call_604275.validator(path, query, header, formData, body)
  let scheme = call_604275.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604275.url(scheme.get, call_604275.host, call_604275.base,
                         call_604275.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604275, url, valid)

proc call*(call_604276: Call_DeleteTopicRule_604264; ruleName: string): Recallable =
  ## deleteTopicRule
  ## Deletes the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  var path_604277 = newJObject()
  add(path_604277, "ruleName", newJString(ruleName))
  result = call_604276.call(path_604277, nil, nil, nil, nil)

var deleteTopicRule* = Call_DeleteTopicRule_604264(name: "deleteTopicRule",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_DeleteTopicRule_604265,
    base: "/", url: url_DeleteTopicRule_604266, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAccountAuditConfiguration_604294 = ref object of OpenApiRestCall_602466
proc url_DescribeAccountAuditConfiguration_604296(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DescribeAccountAuditConfiguration_604295(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604297 = header.getOrDefault("X-Amz-Date")
  valid_604297 = validateParameter(valid_604297, JString, required = false,
                                 default = nil)
  if valid_604297 != nil:
    section.add "X-Amz-Date", valid_604297
  var valid_604298 = header.getOrDefault("X-Amz-Security-Token")
  valid_604298 = validateParameter(valid_604298, JString, required = false,
                                 default = nil)
  if valid_604298 != nil:
    section.add "X-Amz-Security-Token", valid_604298
  var valid_604299 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604299 = validateParameter(valid_604299, JString, required = false,
                                 default = nil)
  if valid_604299 != nil:
    section.add "X-Amz-Content-Sha256", valid_604299
  var valid_604300 = header.getOrDefault("X-Amz-Algorithm")
  valid_604300 = validateParameter(valid_604300, JString, required = false,
                                 default = nil)
  if valid_604300 != nil:
    section.add "X-Amz-Algorithm", valid_604300
  var valid_604301 = header.getOrDefault("X-Amz-Signature")
  valid_604301 = validateParameter(valid_604301, JString, required = false,
                                 default = nil)
  if valid_604301 != nil:
    section.add "X-Amz-Signature", valid_604301
  var valid_604302 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604302 = validateParameter(valid_604302, JString, required = false,
                                 default = nil)
  if valid_604302 != nil:
    section.add "X-Amz-SignedHeaders", valid_604302
  var valid_604303 = header.getOrDefault("X-Amz-Credential")
  valid_604303 = validateParameter(valid_604303, JString, required = false,
                                 default = nil)
  if valid_604303 != nil:
    section.add "X-Amz-Credential", valid_604303
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604304: Call_DescribeAccountAuditConfiguration_604294;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  let valid = call_604304.validator(path, query, header, formData, body)
  let scheme = call_604304.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604304.url(scheme.get, call_604304.host, call_604304.base,
                         call_604304.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604304, url, valid)

proc call*(call_604305: Call_DescribeAccountAuditConfiguration_604294): Recallable =
  ## describeAccountAuditConfiguration
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  result = call_604305.call(nil, nil, nil, nil, nil)

var describeAccountAuditConfiguration* = Call_DescribeAccountAuditConfiguration_604294(
    name: "describeAccountAuditConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_DescribeAccountAuditConfiguration_604295, base: "/",
    url: url_DescribeAccountAuditConfiguration_604296,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateAccountAuditConfiguration_604320 = ref object of OpenApiRestCall_602466
proc url_UpdateAccountAuditConfiguration_604322(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateAccountAuditConfiguration_604321(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604323 = header.getOrDefault("X-Amz-Date")
  valid_604323 = validateParameter(valid_604323, JString, required = false,
                                 default = nil)
  if valid_604323 != nil:
    section.add "X-Amz-Date", valid_604323
  var valid_604324 = header.getOrDefault("X-Amz-Security-Token")
  valid_604324 = validateParameter(valid_604324, JString, required = false,
                                 default = nil)
  if valid_604324 != nil:
    section.add "X-Amz-Security-Token", valid_604324
  var valid_604325 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604325 = validateParameter(valid_604325, JString, required = false,
                                 default = nil)
  if valid_604325 != nil:
    section.add "X-Amz-Content-Sha256", valid_604325
  var valid_604326 = header.getOrDefault("X-Amz-Algorithm")
  valid_604326 = validateParameter(valid_604326, JString, required = false,
                                 default = nil)
  if valid_604326 != nil:
    section.add "X-Amz-Algorithm", valid_604326
  var valid_604327 = header.getOrDefault("X-Amz-Signature")
  valid_604327 = validateParameter(valid_604327, JString, required = false,
                                 default = nil)
  if valid_604327 != nil:
    section.add "X-Amz-Signature", valid_604327
  var valid_604328 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604328 = validateParameter(valid_604328, JString, required = false,
                                 default = nil)
  if valid_604328 != nil:
    section.add "X-Amz-SignedHeaders", valid_604328
  var valid_604329 = header.getOrDefault("X-Amz-Credential")
  valid_604329 = validateParameter(valid_604329, JString, required = false,
                                 default = nil)
  if valid_604329 != nil:
    section.add "X-Amz-Credential", valid_604329
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604331: Call_UpdateAccountAuditConfiguration_604320;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  let valid = call_604331.validator(path, query, header, formData, body)
  let scheme = call_604331.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604331.url(scheme.get, call_604331.host, call_604331.base,
                         call_604331.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604331, url, valid)

proc call*(call_604332: Call_UpdateAccountAuditConfiguration_604320; body: JsonNode): Recallable =
  ## updateAccountAuditConfiguration
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ##   body: JObject (required)
  var body_604333 = newJObject()
  if body != nil:
    body_604333 = body
  result = call_604332.call(nil, nil, nil, nil, body_604333)

var updateAccountAuditConfiguration* = Call_UpdateAccountAuditConfiguration_604320(
    name: "updateAccountAuditConfiguration", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_UpdateAccountAuditConfiguration_604321, base: "/",
    url: url_UpdateAccountAuditConfiguration_604322,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteAccountAuditConfiguration_604306 = ref object of OpenApiRestCall_602466
proc url_DeleteAccountAuditConfiguration_604308(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DeleteAccountAuditConfiguration_604307(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   deleteScheduledAudits: JBool
  ##                        : If true, all scheduled audits are deleted.
  section = newJObject()
  var valid_604309 = query.getOrDefault("deleteScheduledAudits")
  valid_604309 = validateParameter(valid_604309, JBool, required = false, default = nil)
  if valid_604309 != nil:
    section.add "deleteScheduledAudits", valid_604309
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604310 = header.getOrDefault("X-Amz-Date")
  valid_604310 = validateParameter(valid_604310, JString, required = false,
                                 default = nil)
  if valid_604310 != nil:
    section.add "X-Amz-Date", valid_604310
  var valid_604311 = header.getOrDefault("X-Amz-Security-Token")
  valid_604311 = validateParameter(valid_604311, JString, required = false,
                                 default = nil)
  if valid_604311 != nil:
    section.add "X-Amz-Security-Token", valid_604311
  var valid_604312 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604312 = validateParameter(valid_604312, JString, required = false,
                                 default = nil)
  if valid_604312 != nil:
    section.add "X-Amz-Content-Sha256", valid_604312
  var valid_604313 = header.getOrDefault("X-Amz-Algorithm")
  valid_604313 = validateParameter(valid_604313, JString, required = false,
                                 default = nil)
  if valid_604313 != nil:
    section.add "X-Amz-Algorithm", valid_604313
  var valid_604314 = header.getOrDefault("X-Amz-Signature")
  valid_604314 = validateParameter(valid_604314, JString, required = false,
                                 default = nil)
  if valid_604314 != nil:
    section.add "X-Amz-Signature", valid_604314
  var valid_604315 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604315 = validateParameter(valid_604315, JString, required = false,
                                 default = nil)
  if valid_604315 != nil:
    section.add "X-Amz-SignedHeaders", valid_604315
  var valid_604316 = header.getOrDefault("X-Amz-Credential")
  valid_604316 = validateParameter(valid_604316, JString, required = false,
                                 default = nil)
  if valid_604316 != nil:
    section.add "X-Amz-Credential", valid_604316
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604317: Call_DeleteAccountAuditConfiguration_604306;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ## 
  let valid = call_604317.validator(path, query, header, formData, body)
  let scheme = call_604317.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604317.url(scheme.get, call_604317.host, call_604317.base,
                         call_604317.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604317, url, valid)

proc call*(call_604318: Call_DeleteAccountAuditConfiguration_604306;
          deleteScheduledAudits: bool = false): Recallable =
  ## deleteAccountAuditConfiguration
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ##   deleteScheduledAudits: bool
  ##                        : If true, all scheduled audits are deleted.
  var query_604319 = newJObject()
  add(query_604319, "deleteScheduledAudits", newJBool(deleteScheduledAudits))
  result = call_604318.call(nil, query_604319, nil, nil, nil)

var deleteAccountAuditConfiguration* = Call_DeleteAccountAuditConfiguration_604306(
    name: "deleteAccountAuditConfiguration", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_DeleteAccountAuditConfiguration_604307, base: "/",
    url: url_DeleteAccountAuditConfiguration_604308,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateCACertificate_604348 = ref object of OpenApiRestCall_602466
proc url_UpdateCACertificate_604350(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateCACertificate_604349(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Updates a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The CA certificate identifier.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_604351 = path.getOrDefault("caCertificateId")
  valid_604351 = validateParameter(valid_604351, JString, required = true,
                                 default = nil)
  if valid_604351 != nil:
    section.add "caCertificateId", valid_604351
  result.add "path", section
  ## parameters in `query` object:
  ##   newStatus: JString
  ##            : <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  ##   newAutoRegistrationStatus: JString
  ##                            : The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
  section = newJObject()
  var valid_604365 = query.getOrDefault("newStatus")
  valid_604365 = validateParameter(valid_604365, JString, required = false,
                                 default = newJString("ACTIVE"))
  if valid_604365 != nil:
    section.add "newStatus", valid_604365
  var valid_604366 = query.getOrDefault("newAutoRegistrationStatus")
  valid_604366 = validateParameter(valid_604366, JString, required = false,
                                 default = newJString("ENABLE"))
  if valid_604366 != nil:
    section.add "newAutoRegistrationStatus", valid_604366
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604367 = header.getOrDefault("X-Amz-Date")
  valid_604367 = validateParameter(valid_604367, JString, required = false,
                                 default = nil)
  if valid_604367 != nil:
    section.add "X-Amz-Date", valid_604367
  var valid_604368 = header.getOrDefault("X-Amz-Security-Token")
  valid_604368 = validateParameter(valid_604368, JString, required = false,
                                 default = nil)
  if valid_604368 != nil:
    section.add "X-Amz-Security-Token", valid_604368
  var valid_604369 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604369 = validateParameter(valid_604369, JString, required = false,
                                 default = nil)
  if valid_604369 != nil:
    section.add "X-Amz-Content-Sha256", valid_604369
  var valid_604370 = header.getOrDefault("X-Amz-Algorithm")
  valid_604370 = validateParameter(valid_604370, JString, required = false,
                                 default = nil)
  if valid_604370 != nil:
    section.add "X-Amz-Algorithm", valid_604370
  var valid_604371 = header.getOrDefault("X-Amz-Signature")
  valid_604371 = validateParameter(valid_604371, JString, required = false,
                                 default = nil)
  if valid_604371 != nil:
    section.add "X-Amz-Signature", valid_604371
  var valid_604372 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604372 = validateParameter(valid_604372, JString, required = false,
                                 default = nil)
  if valid_604372 != nil:
    section.add "X-Amz-SignedHeaders", valid_604372
  var valid_604373 = header.getOrDefault("X-Amz-Credential")
  valid_604373 = validateParameter(valid_604373, JString, required = false,
                                 default = nil)
  if valid_604373 != nil:
    section.add "X-Amz-Credential", valid_604373
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604375: Call_UpdateCACertificate_604348; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a registered CA certificate.
  ## 
  let valid = call_604375.validator(path, query, header, formData, body)
  let scheme = call_604375.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604375.url(scheme.get, call_604375.host, call_604375.base,
                         call_604375.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604375, url, valid)

proc call*(call_604376: Call_UpdateCACertificate_604348; caCertificateId: string;
          body: JsonNode; newStatus: string = "ACTIVE";
          newAutoRegistrationStatus: string = "ENABLE"): Recallable =
  ## updateCACertificate
  ## Updates a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The CA certificate identifier.
  ##   body: JObject (required)
  ##   newStatus: string
  ##            : <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  ##   newAutoRegistrationStatus: string
  ##                            : The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
  var path_604377 = newJObject()
  var query_604378 = newJObject()
  var body_604379 = newJObject()
  add(path_604377, "caCertificateId", newJString(caCertificateId))
  if body != nil:
    body_604379 = body
  add(query_604378, "newStatus", newJString(newStatus))
  add(query_604378, "newAutoRegistrationStatus",
      newJString(newAutoRegistrationStatus))
  result = call_604376.call(path_604377, query_604378, nil, nil, body_604379)

var updateCACertificate* = Call_UpdateCACertificate_604348(
    name: "updateCACertificate", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_UpdateCACertificate_604349, base: "/",
    url: url_UpdateCACertificate_604350, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeCACertificate_604334 = ref object of OpenApiRestCall_602466
proc url_DescribeCACertificate_604336(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeCACertificate_604335(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The CA certificate identifier.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_604337 = path.getOrDefault("caCertificateId")
  valid_604337 = validateParameter(valid_604337, JString, required = true,
                                 default = nil)
  if valid_604337 != nil:
    section.add "caCertificateId", valid_604337
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604338 = header.getOrDefault("X-Amz-Date")
  valid_604338 = validateParameter(valid_604338, JString, required = false,
                                 default = nil)
  if valid_604338 != nil:
    section.add "X-Amz-Date", valid_604338
  var valid_604339 = header.getOrDefault("X-Amz-Security-Token")
  valid_604339 = validateParameter(valid_604339, JString, required = false,
                                 default = nil)
  if valid_604339 != nil:
    section.add "X-Amz-Security-Token", valid_604339
  var valid_604340 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604340 = validateParameter(valid_604340, JString, required = false,
                                 default = nil)
  if valid_604340 != nil:
    section.add "X-Amz-Content-Sha256", valid_604340
  var valid_604341 = header.getOrDefault("X-Amz-Algorithm")
  valid_604341 = validateParameter(valid_604341, JString, required = false,
                                 default = nil)
  if valid_604341 != nil:
    section.add "X-Amz-Algorithm", valid_604341
  var valid_604342 = header.getOrDefault("X-Amz-Signature")
  valid_604342 = validateParameter(valid_604342, JString, required = false,
                                 default = nil)
  if valid_604342 != nil:
    section.add "X-Amz-Signature", valid_604342
  var valid_604343 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604343 = validateParameter(valid_604343, JString, required = false,
                                 default = nil)
  if valid_604343 != nil:
    section.add "X-Amz-SignedHeaders", valid_604343
  var valid_604344 = header.getOrDefault("X-Amz-Credential")
  valid_604344 = validateParameter(valid_604344, JString, required = false,
                                 default = nil)
  if valid_604344 != nil:
    section.add "X-Amz-Credential", valid_604344
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604345: Call_DescribeCACertificate_604334; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a registered CA certificate.
  ## 
  let valid = call_604345.validator(path, query, header, formData, body)
  let scheme = call_604345.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604345.url(scheme.get, call_604345.host, call_604345.base,
                         call_604345.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604345, url, valid)

proc call*(call_604346: Call_DescribeCACertificate_604334; caCertificateId: string): Recallable =
  ## describeCACertificate
  ## Describes a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The CA certificate identifier.
  var path_604347 = newJObject()
  add(path_604347, "caCertificateId", newJString(caCertificateId))
  result = call_604346.call(path_604347, nil, nil, nil, nil)

var describeCACertificate* = Call_DescribeCACertificate_604334(
    name: "describeCACertificate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_DescribeCACertificate_604335, base: "/",
    url: url_DescribeCACertificate_604336, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteCACertificate_604380 = ref object of OpenApiRestCall_602466
proc url_DeleteCACertificate_604382(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteCACertificate_604381(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Deletes a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_604383 = path.getOrDefault("caCertificateId")
  valid_604383 = validateParameter(valid_604383, JString, required = true,
                                 default = nil)
  if valid_604383 != nil:
    section.add "caCertificateId", valid_604383
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604384 = header.getOrDefault("X-Amz-Date")
  valid_604384 = validateParameter(valid_604384, JString, required = false,
                                 default = nil)
  if valid_604384 != nil:
    section.add "X-Amz-Date", valid_604384
  var valid_604385 = header.getOrDefault("X-Amz-Security-Token")
  valid_604385 = validateParameter(valid_604385, JString, required = false,
                                 default = nil)
  if valid_604385 != nil:
    section.add "X-Amz-Security-Token", valid_604385
  var valid_604386 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604386 = validateParameter(valid_604386, JString, required = false,
                                 default = nil)
  if valid_604386 != nil:
    section.add "X-Amz-Content-Sha256", valid_604386
  var valid_604387 = header.getOrDefault("X-Amz-Algorithm")
  valid_604387 = validateParameter(valid_604387, JString, required = false,
                                 default = nil)
  if valid_604387 != nil:
    section.add "X-Amz-Algorithm", valid_604387
  var valid_604388 = header.getOrDefault("X-Amz-Signature")
  valid_604388 = validateParameter(valid_604388, JString, required = false,
                                 default = nil)
  if valid_604388 != nil:
    section.add "X-Amz-Signature", valid_604388
  var valid_604389 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604389 = validateParameter(valid_604389, JString, required = false,
                                 default = nil)
  if valid_604389 != nil:
    section.add "X-Amz-SignedHeaders", valid_604389
  var valid_604390 = header.getOrDefault("X-Amz-Credential")
  valid_604390 = validateParameter(valid_604390, JString, required = false,
                                 default = nil)
  if valid_604390 != nil:
    section.add "X-Amz-Credential", valid_604390
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604391: Call_DeleteCACertificate_604380; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a registered CA certificate.
  ## 
  let valid = call_604391.validator(path, query, header, formData, body)
  let scheme = call_604391.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604391.url(scheme.get, call_604391.host, call_604391.base,
                         call_604391.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604391, url, valid)

proc call*(call_604392: Call_DeleteCACertificate_604380; caCertificateId: string): Recallable =
  ## deleteCACertificate
  ## Deletes a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
  var path_604393 = newJObject()
  add(path_604393, "caCertificateId", newJString(caCertificateId))
  result = call_604392.call(path_604393, nil, nil, nil, nil)

var deleteCACertificate* = Call_DeleteCACertificate_604380(
    name: "deleteCACertificate", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_DeleteCACertificate_604381, base: "/",
    url: url_DeleteCACertificate_604382, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeCertificate_604394 = ref object of OpenApiRestCall_602466
proc url_DescribeCertificate_604396(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeCertificate_604395(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets information about the specified certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_604397 = path.getOrDefault("certificateId")
  valid_604397 = validateParameter(valid_604397, JString, required = true,
                                 default = nil)
  if valid_604397 != nil:
    section.add "certificateId", valid_604397
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604398 = header.getOrDefault("X-Amz-Date")
  valid_604398 = validateParameter(valid_604398, JString, required = false,
                                 default = nil)
  if valid_604398 != nil:
    section.add "X-Amz-Date", valid_604398
  var valid_604399 = header.getOrDefault("X-Amz-Security-Token")
  valid_604399 = validateParameter(valid_604399, JString, required = false,
                                 default = nil)
  if valid_604399 != nil:
    section.add "X-Amz-Security-Token", valid_604399
  var valid_604400 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604400 = validateParameter(valid_604400, JString, required = false,
                                 default = nil)
  if valid_604400 != nil:
    section.add "X-Amz-Content-Sha256", valid_604400
  var valid_604401 = header.getOrDefault("X-Amz-Algorithm")
  valid_604401 = validateParameter(valid_604401, JString, required = false,
                                 default = nil)
  if valid_604401 != nil:
    section.add "X-Amz-Algorithm", valid_604401
  var valid_604402 = header.getOrDefault("X-Amz-Signature")
  valid_604402 = validateParameter(valid_604402, JString, required = false,
                                 default = nil)
  if valid_604402 != nil:
    section.add "X-Amz-Signature", valid_604402
  var valid_604403 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604403 = validateParameter(valid_604403, JString, required = false,
                                 default = nil)
  if valid_604403 != nil:
    section.add "X-Amz-SignedHeaders", valid_604403
  var valid_604404 = header.getOrDefault("X-Amz-Credential")
  valid_604404 = validateParameter(valid_604404, JString, required = false,
                                 default = nil)
  if valid_604404 != nil:
    section.add "X-Amz-Credential", valid_604404
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604405: Call_DescribeCertificate_604394; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified certificate.
  ## 
  let valid = call_604405.validator(path, query, header, formData, body)
  let scheme = call_604405.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604405.url(scheme.get, call_604405.host, call_604405.base,
                         call_604405.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604405, url, valid)

proc call*(call_604406: Call_DescribeCertificate_604394; certificateId: string): Recallable =
  ## describeCertificate
  ## Gets information about the specified certificate.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_604407 = newJObject()
  add(path_604407, "certificateId", newJString(certificateId))
  result = call_604406.call(path_604407, nil, nil, nil, nil)

var describeCertificate* = Call_DescribeCertificate_604394(
    name: "describeCertificate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates/{certificateId}",
    validator: validate_DescribeCertificate_604395, base: "/",
    url: url_DescribeCertificate_604396, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteCertificate_604408 = ref object of OpenApiRestCall_602466
proc url_DeleteCertificate_604410(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteCertificate_604409(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_604411 = path.getOrDefault("certificateId")
  valid_604411 = validateParameter(valid_604411, JString, required = true,
                                 default = nil)
  if valid_604411 != nil:
    section.add "certificateId", valid_604411
  result.add "path", section
  ## parameters in `query` object:
  ##   forceDelete: JBool
  ##              : Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
  section = newJObject()
  var valid_604412 = query.getOrDefault("forceDelete")
  valid_604412 = validateParameter(valid_604412, JBool, required = false, default = nil)
  if valid_604412 != nil:
    section.add "forceDelete", valid_604412
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604413 = header.getOrDefault("X-Amz-Date")
  valid_604413 = validateParameter(valid_604413, JString, required = false,
                                 default = nil)
  if valid_604413 != nil:
    section.add "X-Amz-Date", valid_604413
  var valid_604414 = header.getOrDefault("X-Amz-Security-Token")
  valid_604414 = validateParameter(valid_604414, JString, required = false,
                                 default = nil)
  if valid_604414 != nil:
    section.add "X-Amz-Security-Token", valid_604414
  var valid_604415 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604415 = validateParameter(valid_604415, JString, required = false,
                                 default = nil)
  if valid_604415 != nil:
    section.add "X-Amz-Content-Sha256", valid_604415
  var valid_604416 = header.getOrDefault("X-Amz-Algorithm")
  valid_604416 = validateParameter(valid_604416, JString, required = false,
                                 default = nil)
  if valid_604416 != nil:
    section.add "X-Amz-Algorithm", valid_604416
  var valid_604417 = header.getOrDefault("X-Amz-Signature")
  valid_604417 = validateParameter(valid_604417, JString, required = false,
                                 default = nil)
  if valid_604417 != nil:
    section.add "X-Amz-Signature", valid_604417
  var valid_604418 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604418 = validateParameter(valid_604418, JString, required = false,
                                 default = nil)
  if valid_604418 != nil:
    section.add "X-Amz-SignedHeaders", valid_604418
  var valid_604419 = header.getOrDefault("X-Amz-Credential")
  valid_604419 = validateParameter(valid_604419, JString, required = false,
                                 default = nil)
  if valid_604419 != nil:
    section.add "X-Amz-Credential", valid_604419
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604420: Call_DeleteCertificate_604408; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ## 
  let valid = call_604420.validator(path, query, header, formData, body)
  let scheme = call_604420.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604420.url(scheme.get, call_604420.host, call_604420.base,
                         call_604420.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604420, url, valid)

proc call*(call_604421: Call_DeleteCertificate_604408; certificateId: string;
          forceDelete: bool = false): Recallable =
  ## deleteCertificate
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ##   forceDelete: bool
  ##              : Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_604422 = newJObject()
  var query_604423 = newJObject()
  add(query_604423, "forceDelete", newJBool(forceDelete))
  add(path_604422, "certificateId", newJString(certificateId))
  result = call_604421.call(path_604422, query_604423, nil, nil, nil)

var deleteCertificate* = Call_DeleteCertificate_604408(name: "deleteCertificate",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/certificates/{certificateId}", validator: validate_DeleteCertificate_604409,
    base: "/", url: url_DeleteCertificate_604410,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteJobExecution_604424 = ref object of OpenApiRestCall_602466
proc url_DeleteJobExecution_604426(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  assert "executionNumber" in path, "`executionNumber` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/executionNumber/"),
               (kind: VariableSegment, value: "executionNumber")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteJobExecution_604425(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deletes a job execution.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing whose job execution will be deleted.
  ##   jobId: JString (required)
  ##        : The ID of the job whose execution on a particular device will be deleted.
  ##   executionNumber: JInt (required)
  ##                  : <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_604427 = path.getOrDefault("thingName")
  valid_604427 = validateParameter(valid_604427, JString, required = true,
                                 default = nil)
  if valid_604427 != nil:
    section.add "thingName", valid_604427
  var valid_604428 = path.getOrDefault("jobId")
  valid_604428 = validateParameter(valid_604428, JString, required = true,
                                 default = nil)
  if valid_604428 != nil:
    section.add "jobId", valid_604428
  var valid_604429 = path.getOrDefault("executionNumber")
  valid_604429 = validateParameter(valid_604429, JInt, required = true, default = nil)
  if valid_604429 != nil:
    section.add "executionNumber", valid_604429
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
  section = newJObject()
  var valid_604430 = query.getOrDefault("force")
  valid_604430 = validateParameter(valid_604430, JBool, required = false, default = nil)
  if valid_604430 != nil:
    section.add "force", valid_604430
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604431 = header.getOrDefault("X-Amz-Date")
  valid_604431 = validateParameter(valid_604431, JString, required = false,
                                 default = nil)
  if valid_604431 != nil:
    section.add "X-Amz-Date", valid_604431
  var valid_604432 = header.getOrDefault("X-Amz-Security-Token")
  valid_604432 = validateParameter(valid_604432, JString, required = false,
                                 default = nil)
  if valid_604432 != nil:
    section.add "X-Amz-Security-Token", valid_604432
  var valid_604433 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604433 = validateParameter(valid_604433, JString, required = false,
                                 default = nil)
  if valid_604433 != nil:
    section.add "X-Amz-Content-Sha256", valid_604433
  var valid_604434 = header.getOrDefault("X-Amz-Algorithm")
  valid_604434 = validateParameter(valid_604434, JString, required = false,
                                 default = nil)
  if valid_604434 != nil:
    section.add "X-Amz-Algorithm", valid_604434
  var valid_604435 = header.getOrDefault("X-Amz-Signature")
  valid_604435 = validateParameter(valid_604435, JString, required = false,
                                 default = nil)
  if valid_604435 != nil:
    section.add "X-Amz-Signature", valid_604435
  var valid_604436 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604436 = validateParameter(valid_604436, JString, required = false,
                                 default = nil)
  if valid_604436 != nil:
    section.add "X-Amz-SignedHeaders", valid_604436
  var valid_604437 = header.getOrDefault("X-Amz-Credential")
  valid_604437 = validateParameter(valid_604437, JString, required = false,
                                 default = nil)
  if valid_604437 != nil:
    section.add "X-Amz-Credential", valid_604437
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604438: Call_DeleteJobExecution_604424; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a job execution.
  ## 
  let valid = call_604438.validator(path, query, header, formData, body)
  let scheme = call_604438.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604438.url(scheme.get, call_604438.host, call_604438.base,
                         call_604438.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604438, url, valid)

proc call*(call_604439: Call_DeleteJobExecution_604424; thingName: string;
          jobId: string; executionNumber: int; force: bool = false): Recallable =
  ## deleteJobExecution
  ## Deletes a job execution.
  ##   force: bool
  ##        : <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing whose job execution will be deleted.
  ##   jobId: string (required)
  ##        : The ID of the job whose execution on a particular device will be deleted.
  ##   executionNumber: int (required)
  ##                  : <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
  var path_604440 = newJObject()
  var query_604441 = newJObject()
  add(query_604441, "force", newJBool(force))
  add(path_604440, "thingName", newJString(thingName))
  add(path_604440, "jobId", newJString(jobId))
  add(path_604440, "executionNumber", newJInt(executionNumber))
  result = call_604439.call(path_604440, query_604441, nil, nil, nil)

var deleteJobExecution* = Call_DeleteJobExecution_604424(
    name: "deleteJobExecution", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}",
    validator: validate_DeleteJobExecution_604425, base: "/",
    url: url_DeleteJobExecution_604426, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPolicyVersion_604442 = ref object of OpenApiRestCall_602466
proc url_GetPolicyVersion_604444(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPolicyVersion_604443(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets information about the specified policy version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_604445 = path.getOrDefault("policyName")
  valid_604445 = validateParameter(valid_604445, JString, required = true,
                                 default = nil)
  if valid_604445 != nil:
    section.add "policyName", valid_604445
  var valid_604446 = path.getOrDefault("policyVersionId")
  valid_604446 = validateParameter(valid_604446, JString, required = true,
                                 default = nil)
  if valid_604446 != nil:
    section.add "policyVersionId", valid_604446
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604447 = header.getOrDefault("X-Amz-Date")
  valid_604447 = validateParameter(valid_604447, JString, required = false,
                                 default = nil)
  if valid_604447 != nil:
    section.add "X-Amz-Date", valid_604447
  var valid_604448 = header.getOrDefault("X-Amz-Security-Token")
  valid_604448 = validateParameter(valid_604448, JString, required = false,
                                 default = nil)
  if valid_604448 != nil:
    section.add "X-Amz-Security-Token", valid_604448
  var valid_604449 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604449 = validateParameter(valid_604449, JString, required = false,
                                 default = nil)
  if valid_604449 != nil:
    section.add "X-Amz-Content-Sha256", valid_604449
  var valid_604450 = header.getOrDefault("X-Amz-Algorithm")
  valid_604450 = validateParameter(valid_604450, JString, required = false,
                                 default = nil)
  if valid_604450 != nil:
    section.add "X-Amz-Algorithm", valid_604450
  var valid_604451 = header.getOrDefault("X-Amz-Signature")
  valid_604451 = validateParameter(valid_604451, JString, required = false,
                                 default = nil)
  if valid_604451 != nil:
    section.add "X-Amz-Signature", valid_604451
  var valid_604452 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604452 = validateParameter(valid_604452, JString, required = false,
                                 default = nil)
  if valid_604452 != nil:
    section.add "X-Amz-SignedHeaders", valid_604452
  var valid_604453 = header.getOrDefault("X-Amz-Credential")
  valid_604453 = validateParameter(valid_604453, JString, required = false,
                                 default = nil)
  if valid_604453 != nil:
    section.add "X-Amz-Credential", valid_604453
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604454: Call_GetPolicyVersion_604442; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified policy version.
  ## 
  let valid = call_604454.validator(path, query, header, formData, body)
  let scheme = call_604454.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604454.url(scheme.get, call_604454.host, call_604454.base,
                         call_604454.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604454, url, valid)

proc call*(call_604455: Call_GetPolicyVersion_604442; policyName: string;
          policyVersionId: string): Recallable =
  ## getPolicyVersion
  ## Gets information about the specified policy version.
  ##   policyName: string (required)
  ##             : The name of the policy.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_604456 = newJObject()
  add(path_604456, "policyName", newJString(policyName))
  add(path_604456, "policyVersionId", newJString(policyVersionId))
  result = call_604455.call(path_604456, nil, nil, nil, nil)

var getPolicyVersion* = Call_GetPolicyVersion_604442(name: "getPolicyVersion",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_GetPolicyVersion_604443, base: "/",
    url: url_GetPolicyVersion_604444, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetDefaultPolicyVersion_604472 = ref object of OpenApiRestCall_602466
proc url_SetDefaultPolicyVersion_604474(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_SetDefaultPolicyVersion_604473(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_604475 = path.getOrDefault("policyName")
  valid_604475 = validateParameter(valid_604475, JString, required = true,
                                 default = nil)
  if valid_604475 != nil:
    section.add "policyName", valid_604475
  var valid_604476 = path.getOrDefault("policyVersionId")
  valid_604476 = validateParameter(valid_604476, JString, required = true,
                                 default = nil)
  if valid_604476 != nil:
    section.add "policyVersionId", valid_604476
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604477 = header.getOrDefault("X-Amz-Date")
  valid_604477 = validateParameter(valid_604477, JString, required = false,
                                 default = nil)
  if valid_604477 != nil:
    section.add "X-Amz-Date", valid_604477
  var valid_604478 = header.getOrDefault("X-Amz-Security-Token")
  valid_604478 = validateParameter(valid_604478, JString, required = false,
                                 default = nil)
  if valid_604478 != nil:
    section.add "X-Amz-Security-Token", valid_604478
  var valid_604479 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604479 = validateParameter(valid_604479, JString, required = false,
                                 default = nil)
  if valid_604479 != nil:
    section.add "X-Amz-Content-Sha256", valid_604479
  var valid_604480 = header.getOrDefault("X-Amz-Algorithm")
  valid_604480 = validateParameter(valid_604480, JString, required = false,
                                 default = nil)
  if valid_604480 != nil:
    section.add "X-Amz-Algorithm", valid_604480
  var valid_604481 = header.getOrDefault("X-Amz-Signature")
  valid_604481 = validateParameter(valid_604481, JString, required = false,
                                 default = nil)
  if valid_604481 != nil:
    section.add "X-Amz-Signature", valid_604481
  var valid_604482 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604482 = validateParameter(valid_604482, JString, required = false,
                                 default = nil)
  if valid_604482 != nil:
    section.add "X-Amz-SignedHeaders", valid_604482
  var valid_604483 = header.getOrDefault("X-Amz-Credential")
  valid_604483 = validateParameter(valid_604483, JString, required = false,
                                 default = nil)
  if valid_604483 != nil:
    section.add "X-Amz-Credential", valid_604483
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604484: Call_SetDefaultPolicyVersion_604472; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ## 
  let valid = call_604484.validator(path, query, header, formData, body)
  let scheme = call_604484.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604484.url(scheme.get, call_604484.host, call_604484.base,
                         call_604484.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604484, url, valid)

proc call*(call_604485: Call_SetDefaultPolicyVersion_604472; policyName: string;
          policyVersionId: string): Recallable =
  ## setDefaultPolicyVersion
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ##   policyName: string (required)
  ##             : The policy name.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_604486 = newJObject()
  add(path_604486, "policyName", newJString(policyName))
  add(path_604486, "policyVersionId", newJString(policyVersionId))
  result = call_604485.call(path_604486, nil, nil, nil, nil)

var setDefaultPolicyVersion* = Call_SetDefaultPolicyVersion_604472(
    name: "setDefaultPolicyVersion", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_SetDefaultPolicyVersion_604473, base: "/",
    url: url_SetDefaultPolicyVersion_604474, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeletePolicyVersion_604457 = ref object of OpenApiRestCall_602466
proc url_DeletePolicyVersion_604459(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeletePolicyVersion_604458(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_604460 = path.getOrDefault("policyName")
  valid_604460 = validateParameter(valid_604460, JString, required = true,
                                 default = nil)
  if valid_604460 != nil:
    section.add "policyName", valid_604460
  var valid_604461 = path.getOrDefault("policyVersionId")
  valid_604461 = validateParameter(valid_604461, JString, required = true,
                                 default = nil)
  if valid_604461 != nil:
    section.add "policyVersionId", valid_604461
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604462 = header.getOrDefault("X-Amz-Date")
  valid_604462 = validateParameter(valid_604462, JString, required = false,
                                 default = nil)
  if valid_604462 != nil:
    section.add "X-Amz-Date", valid_604462
  var valid_604463 = header.getOrDefault("X-Amz-Security-Token")
  valid_604463 = validateParameter(valid_604463, JString, required = false,
                                 default = nil)
  if valid_604463 != nil:
    section.add "X-Amz-Security-Token", valid_604463
  var valid_604464 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604464 = validateParameter(valid_604464, JString, required = false,
                                 default = nil)
  if valid_604464 != nil:
    section.add "X-Amz-Content-Sha256", valid_604464
  var valid_604465 = header.getOrDefault("X-Amz-Algorithm")
  valid_604465 = validateParameter(valid_604465, JString, required = false,
                                 default = nil)
  if valid_604465 != nil:
    section.add "X-Amz-Algorithm", valid_604465
  var valid_604466 = header.getOrDefault("X-Amz-Signature")
  valid_604466 = validateParameter(valid_604466, JString, required = false,
                                 default = nil)
  if valid_604466 != nil:
    section.add "X-Amz-Signature", valid_604466
  var valid_604467 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604467 = validateParameter(valid_604467, JString, required = false,
                                 default = nil)
  if valid_604467 != nil:
    section.add "X-Amz-SignedHeaders", valid_604467
  var valid_604468 = header.getOrDefault("X-Amz-Credential")
  valid_604468 = validateParameter(valid_604468, JString, required = false,
                                 default = nil)
  if valid_604468 != nil:
    section.add "X-Amz-Credential", valid_604468
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604469: Call_DeletePolicyVersion_604457; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ## 
  let valid = call_604469.validator(path, query, header, formData, body)
  let scheme = call_604469.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604469.url(scheme.get, call_604469.host, call_604469.base,
                         call_604469.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604469, url, valid)

proc call*(call_604470: Call_DeletePolicyVersion_604457; policyName: string;
          policyVersionId: string): Recallable =
  ## deletePolicyVersion
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ##   policyName: string (required)
  ##             : The name of the policy.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_604471 = newJObject()
  add(path_604471, "policyName", newJString(policyName))
  add(path_604471, "policyVersionId", newJString(policyVersionId))
  result = call_604470.call(path_604471, nil, nil, nil, nil)

var deletePolicyVersion* = Call_DeletePolicyVersion_604457(
    name: "deletePolicyVersion", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_DeletePolicyVersion_604458, base: "/",
    url: url_DeletePolicyVersion_604459, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRegistrationCode_604487 = ref object of OpenApiRestCall_602466
proc url_GetRegistrationCode_604489(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRegistrationCode_604488(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604490 = header.getOrDefault("X-Amz-Date")
  valid_604490 = validateParameter(valid_604490, JString, required = false,
                                 default = nil)
  if valid_604490 != nil:
    section.add "X-Amz-Date", valid_604490
  var valid_604491 = header.getOrDefault("X-Amz-Security-Token")
  valid_604491 = validateParameter(valid_604491, JString, required = false,
                                 default = nil)
  if valid_604491 != nil:
    section.add "X-Amz-Security-Token", valid_604491
  var valid_604492 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604492 = validateParameter(valid_604492, JString, required = false,
                                 default = nil)
  if valid_604492 != nil:
    section.add "X-Amz-Content-Sha256", valid_604492
  var valid_604493 = header.getOrDefault("X-Amz-Algorithm")
  valid_604493 = validateParameter(valid_604493, JString, required = false,
                                 default = nil)
  if valid_604493 != nil:
    section.add "X-Amz-Algorithm", valid_604493
  var valid_604494 = header.getOrDefault("X-Amz-Signature")
  valid_604494 = validateParameter(valid_604494, JString, required = false,
                                 default = nil)
  if valid_604494 != nil:
    section.add "X-Amz-Signature", valid_604494
  var valid_604495 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604495 = validateParameter(valid_604495, JString, required = false,
                                 default = nil)
  if valid_604495 != nil:
    section.add "X-Amz-SignedHeaders", valid_604495
  var valid_604496 = header.getOrDefault("X-Amz-Credential")
  valid_604496 = validateParameter(valid_604496, JString, required = false,
                                 default = nil)
  if valid_604496 != nil:
    section.add "X-Amz-Credential", valid_604496
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604497: Call_GetRegistrationCode_604487; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  ## 
  let valid = call_604497.validator(path, query, header, formData, body)
  let scheme = call_604497.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604497.url(scheme.get, call_604497.host, call_604497.base,
                         call_604497.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604497, url, valid)

proc call*(call_604498: Call_GetRegistrationCode_604487): Recallable =
  ## getRegistrationCode
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  result = call_604498.call(nil, nil, nil, nil, nil)

var getRegistrationCode* = Call_GetRegistrationCode_604487(
    name: "getRegistrationCode", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/registrationcode",
    validator: validate_GetRegistrationCode_604488, base: "/",
    url: url_GetRegistrationCode_604489, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRegistrationCode_604499 = ref object of OpenApiRestCall_602466
proc url_DeleteRegistrationCode_604501(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DeleteRegistrationCode_604500(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a CA certificate registration code.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604502 = header.getOrDefault("X-Amz-Date")
  valid_604502 = validateParameter(valid_604502, JString, required = false,
                                 default = nil)
  if valid_604502 != nil:
    section.add "X-Amz-Date", valid_604502
  var valid_604503 = header.getOrDefault("X-Amz-Security-Token")
  valid_604503 = validateParameter(valid_604503, JString, required = false,
                                 default = nil)
  if valid_604503 != nil:
    section.add "X-Amz-Security-Token", valid_604503
  var valid_604504 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604504 = validateParameter(valid_604504, JString, required = false,
                                 default = nil)
  if valid_604504 != nil:
    section.add "X-Amz-Content-Sha256", valid_604504
  var valid_604505 = header.getOrDefault("X-Amz-Algorithm")
  valid_604505 = validateParameter(valid_604505, JString, required = false,
                                 default = nil)
  if valid_604505 != nil:
    section.add "X-Amz-Algorithm", valid_604505
  var valid_604506 = header.getOrDefault("X-Amz-Signature")
  valid_604506 = validateParameter(valid_604506, JString, required = false,
                                 default = nil)
  if valid_604506 != nil:
    section.add "X-Amz-Signature", valid_604506
  var valid_604507 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604507 = validateParameter(valid_604507, JString, required = false,
                                 default = nil)
  if valid_604507 != nil:
    section.add "X-Amz-SignedHeaders", valid_604507
  var valid_604508 = header.getOrDefault("X-Amz-Credential")
  valid_604508 = validateParameter(valid_604508, JString, required = false,
                                 default = nil)
  if valid_604508 != nil:
    section.add "X-Amz-Credential", valid_604508
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604509: Call_DeleteRegistrationCode_604499; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a CA certificate registration code.
  ## 
  let valid = call_604509.validator(path, query, header, formData, body)
  let scheme = call_604509.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604509.url(scheme.get, call_604509.host, call_604509.base,
                         call_604509.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604509, url, valid)

proc call*(call_604510: Call_DeleteRegistrationCode_604499): Recallable =
  ## deleteRegistrationCode
  ## Deletes a CA certificate registration code.
  result = call_604510.call(nil, nil, nil, nil, nil)

var deleteRegistrationCode* = Call_DeleteRegistrationCode_604499(
    name: "deleteRegistrationCode", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/registrationcode",
    validator: validate_DeleteRegistrationCode_604500, base: "/",
    url: url_DeleteRegistrationCode_604501, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteV2LoggingLevel_604511 = ref object of OpenApiRestCall_602466
proc url_DeleteV2LoggingLevel_604513(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DeleteV2LoggingLevel_604512(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a logging level.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   targetType: JString (required)
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   targetName: JString (required)
  ##             : The name of the resource for which you are configuring logging.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `targetType` field"
  var valid_604514 = query.getOrDefault("targetType")
  valid_604514 = validateParameter(valid_604514, JString, required = true,
                                 default = newJString("DEFAULT"))
  if valid_604514 != nil:
    section.add "targetType", valid_604514
  var valid_604515 = query.getOrDefault("targetName")
  valid_604515 = validateParameter(valid_604515, JString, required = true,
                                 default = nil)
  if valid_604515 != nil:
    section.add "targetName", valid_604515
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604516 = header.getOrDefault("X-Amz-Date")
  valid_604516 = validateParameter(valid_604516, JString, required = false,
                                 default = nil)
  if valid_604516 != nil:
    section.add "X-Amz-Date", valid_604516
  var valid_604517 = header.getOrDefault("X-Amz-Security-Token")
  valid_604517 = validateParameter(valid_604517, JString, required = false,
                                 default = nil)
  if valid_604517 != nil:
    section.add "X-Amz-Security-Token", valid_604517
  var valid_604518 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604518 = validateParameter(valid_604518, JString, required = false,
                                 default = nil)
  if valid_604518 != nil:
    section.add "X-Amz-Content-Sha256", valid_604518
  var valid_604519 = header.getOrDefault("X-Amz-Algorithm")
  valid_604519 = validateParameter(valid_604519, JString, required = false,
                                 default = nil)
  if valid_604519 != nil:
    section.add "X-Amz-Algorithm", valid_604519
  var valid_604520 = header.getOrDefault("X-Amz-Signature")
  valid_604520 = validateParameter(valid_604520, JString, required = false,
                                 default = nil)
  if valid_604520 != nil:
    section.add "X-Amz-Signature", valid_604520
  var valid_604521 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604521 = validateParameter(valid_604521, JString, required = false,
                                 default = nil)
  if valid_604521 != nil:
    section.add "X-Amz-SignedHeaders", valid_604521
  var valid_604522 = header.getOrDefault("X-Amz-Credential")
  valid_604522 = validateParameter(valid_604522, JString, required = false,
                                 default = nil)
  if valid_604522 != nil:
    section.add "X-Amz-Credential", valid_604522
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604523: Call_DeleteV2LoggingLevel_604511; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a logging level.
  ## 
  let valid = call_604523.validator(path, query, header, formData, body)
  let scheme = call_604523.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604523.url(scheme.get, call_604523.host, call_604523.base,
                         call_604523.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604523, url, valid)

proc call*(call_604524: Call_DeleteV2LoggingLevel_604511; targetName: string;
          targetType: string = "DEFAULT"): Recallable =
  ## deleteV2LoggingLevel
  ## Deletes a logging level.
  ##   targetType: string (required)
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   targetName: string (required)
  ##             : The name of the resource for which you are configuring logging.
  var query_604525 = newJObject()
  add(query_604525, "targetType", newJString(targetType))
  add(query_604525, "targetName", newJString(targetName))
  result = call_604524.call(nil, query_604525, nil, nil, nil)

var deleteV2LoggingLevel* = Call_DeleteV2LoggingLevel_604511(
    name: "deleteV2LoggingLevel", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/v2LoggingLevel#targetType&targetName",
    validator: validate_DeleteV2LoggingLevel_604512, base: "/",
    url: url_DeleteV2LoggingLevel_604513, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeprecateThingType_604526 = ref object of OpenApiRestCall_602466
proc url_DeprecateThingType_604528(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName"),
               (kind: ConstantSegment, value: "/deprecate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeprecateThingType_604527(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type to deprecate.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_604529 = path.getOrDefault("thingTypeName")
  valid_604529 = validateParameter(valid_604529, JString, required = true,
                                 default = nil)
  if valid_604529 != nil:
    section.add "thingTypeName", valid_604529
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604530 = header.getOrDefault("X-Amz-Date")
  valid_604530 = validateParameter(valid_604530, JString, required = false,
                                 default = nil)
  if valid_604530 != nil:
    section.add "X-Amz-Date", valid_604530
  var valid_604531 = header.getOrDefault("X-Amz-Security-Token")
  valid_604531 = validateParameter(valid_604531, JString, required = false,
                                 default = nil)
  if valid_604531 != nil:
    section.add "X-Amz-Security-Token", valid_604531
  var valid_604532 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604532 = validateParameter(valid_604532, JString, required = false,
                                 default = nil)
  if valid_604532 != nil:
    section.add "X-Amz-Content-Sha256", valid_604532
  var valid_604533 = header.getOrDefault("X-Amz-Algorithm")
  valid_604533 = validateParameter(valid_604533, JString, required = false,
                                 default = nil)
  if valid_604533 != nil:
    section.add "X-Amz-Algorithm", valid_604533
  var valid_604534 = header.getOrDefault("X-Amz-Signature")
  valid_604534 = validateParameter(valid_604534, JString, required = false,
                                 default = nil)
  if valid_604534 != nil:
    section.add "X-Amz-Signature", valid_604534
  var valid_604535 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604535 = validateParameter(valid_604535, JString, required = false,
                                 default = nil)
  if valid_604535 != nil:
    section.add "X-Amz-SignedHeaders", valid_604535
  var valid_604536 = header.getOrDefault("X-Amz-Credential")
  valid_604536 = validateParameter(valid_604536, JString, required = false,
                                 default = nil)
  if valid_604536 != nil:
    section.add "X-Amz-Credential", valid_604536
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604538: Call_DeprecateThingType_604526; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ## 
  let valid = call_604538.validator(path, query, header, formData, body)
  let scheme = call_604538.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604538.url(scheme.get, call_604538.host, call_604538.base,
                         call_604538.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604538, url, valid)

proc call*(call_604539: Call_DeprecateThingType_604526; body: JsonNode;
          thingTypeName: string): Recallable =
  ## deprecateThingType
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ##   body: JObject (required)
  ##   thingTypeName: string (required)
  ##                : The name of the thing type to deprecate.
  var path_604540 = newJObject()
  var body_604541 = newJObject()
  if body != nil:
    body_604541 = body
  add(path_604540, "thingTypeName", newJString(thingTypeName))
  result = call_604539.call(path_604540, nil, nil, nil, body_604541)

var deprecateThingType* = Call_DeprecateThingType_604526(
    name: "deprecateThingType", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/thing-types/{thingTypeName}/deprecate",
    validator: validate_DeprecateThingType_604527, base: "/",
    url: url_DeprecateThingType_604528, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditFinding_604542 = ref object of OpenApiRestCall_602466
proc url_DescribeAuditFinding_604544(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "findingId" in path, "`findingId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/findings/"),
               (kind: VariableSegment, value: "findingId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeAuditFinding_604543(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   findingId: JString (required)
  ##            : A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `findingId` field"
  var valid_604545 = path.getOrDefault("findingId")
  valid_604545 = validateParameter(valid_604545, JString, required = true,
                                 default = nil)
  if valid_604545 != nil:
    section.add "findingId", valid_604545
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604546 = header.getOrDefault("X-Amz-Date")
  valid_604546 = validateParameter(valid_604546, JString, required = false,
                                 default = nil)
  if valid_604546 != nil:
    section.add "X-Amz-Date", valid_604546
  var valid_604547 = header.getOrDefault("X-Amz-Security-Token")
  valid_604547 = validateParameter(valid_604547, JString, required = false,
                                 default = nil)
  if valid_604547 != nil:
    section.add "X-Amz-Security-Token", valid_604547
  var valid_604548 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604548 = validateParameter(valid_604548, JString, required = false,
                                 default = nil)
  if valid_604548 != nil:
    section.add "X-Amz-Content-Sha256", valid_604548
  var valid_604549 = header.getOrDefault("X-Amz-Algorithm")
  valid_604549 = validateParameter(valid_604549, JString, required = false,
                                 default = nil)
  if valid_604549 != nil:
    section.add "X-Amz-Algorithm", valid_604549
  var valid_604550 = header.getOrDefault("X-Amz-Signature")
  valid_604550 = validateParameter(valid_604550, JString, required = false,
                                 default = nil)
  if valid_604550 != nil:
    section.add "X-Amz-Signature", valid_604550
  var valid_604551 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604551 = validateParameter(valid_604551, JString, required = false,
                                 default = nil)
  if valid_604551 != nil:
    section.add "X-Amz-SignedHeaders", valid_604551
  var valid_604552 = header.getOrDefault("X-Amz-Credential")
  valid_604552 = validateParameter(valid_604552, JString, required = false,
                                 default = nil)
  if valid_604552 != nil:
    section.add "X-Amz-Credential", valid_604552
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604553: Call_DescribeAuditFinding_604542; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ## 
  let valid = call_604553.validator(path, query, header, formData, body)
  let scheme = call_604553.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604553.url(scheme.get, call_604553.host, call_604553.base,
                         call_604553.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604553, url, valid)

proc call*(call_604554: Call_DescribeAuditFinding_604542; findingId: string): Recallable =
  ## describeAuditFinding
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ##   findingId: string (required)
  ##            : A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
  var path_604555 = newJObject()
  add(path_604555, "findingId", newJString(findingId))
  result = call_604554.call(path_604555, nil, nil, nil, nil)

var describeAuditFinding* = Call_DescribeAuditFinding_604542(
    name: "describeAuditFinding", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/findings/{findingId}",
    validator: validate_DescribeAuditFinding_604543, base: "/",
    url: url_DescribeAuditFinding_604544, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartAuditMitigationActionsTask_604570 = ref object of OpenApiRestCall_602466
proc url_StartAuditMitigationActionsTask_604572(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartAuditMitigationActionsTask_604571(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_604573 = path.getOrDefault("taskId")
  valid_604573 = validateParameter(valid_604573, JString, required = true,
                                 default = nil)
  if valid_604573 != nil:
    section.add "taskId", valid_604573
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604574 = header.getOrDefault("X-Amz-Date")
  valid_604574 = validateParameter(valid_604574, JString, required = false,
                                 default = nil)
  if valid_604574 != nil:
    section.add "X-Amz-Date", valid_604574
  var valid_604575 = header.getOrDefault("X-Amz-Security-Token")
  valid_604575 = validateParameter(valid_604575, JString, required = false,
                                 default = nil)
  if valid_604575 != nil:
    section.add "X-Amz-Security-Token", valid_604575
  var valid_604576 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604576 = validateParameter(valid_604576, JString, required = false,
                                 default = nil)
  if valid_604576 != nil:
    section.add "X-Amz-Content-Sha256", valid_604576
  var valid_604577 = header.getOrDefault("X-Amz-Algorithm")
  valid_604577 = validateParameter(valid_604577, JString, required = false,
                                 default = nil)
  if valid_604577 != nil:
    section.add "X-Amz-Algorithm", valid_604577
  var valid_604578 = header.getOrDefault("X-Amz-Signature")
  valid_604578 = validateParameter(valid_604578, JString, required = false,
                                 default = nil)
  if valid_604578 != nil:
    section.add "X-Amz-Signature", valid_604578
  var valid_604579 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604579 = validateParameter(valid_604579, JString, required = false,
                                 default = nil)
  if valid_604579 != nil:
    section.add "X-Amz-SignedHeaders", valid_604579
  var valid_604580 = header.getOrDefault("X-Amz-Credential")
  valid_604580 = validateParameter(valid_604580, JString, required = false,
                                 default = nil)
  if valid_604580 != nil:
    section.add "X-Amz-Credential", valid_604580
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604582: Call_StartAuditMitigationActionsTask_604570;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ## 
  let valid = call_604582.validator(path, query, header, formData, body)
  let scheme = call_604582.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604582.url(scheme.get, call_604582.host, call_604582.base,
                         call_604582.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604582, url, valid)

proc call*(call_604583: Call_StartAuditMitigationActionsTask_604570;
          body: JsonNode; taskId: string): Recallable =
  ## startAuditMitigationActionsTask
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ##   body: JObject (required)
  ##   taskId: string (required)
  ##         : A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
  var path_604584 = newJObject()
  var body_604585 = newJObject()
  if body != nil:
    body_604585 = body
  add(path_604584, "taskId", newJString(taskId))
  result = call_604583.call(path_604584, nil, nil, nil, body_604585)

var startAuditMitigationActionsTask* = Call_StartAuditMitigationActionsTask_604570(
    name: "startAuditMitigationActionsTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/audit/mitigationactions/tasks/{taskId}",
    validator: validate_StartAuditMitigationActionsTask_604571, base: "/",
    url: url_StartAuditMitigationActionsTask_604572,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditMitigationActionsTask_604556 = ref object of OpenApiRestCall_602466
proc url_DescribeAuditMitigationActionsTask_604558(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeAuditMitigationActionsTask_604557(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The unique identifier for the audit mitigation task.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_604559 = path.getOrDefault("taskId")
  valid_604559 = validateParameter(valid_604559, JString, required = true,
                                 default = nil)
  if valid_604559 != nil:
    section.add "taskId", valid_604559
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604560 = header.getOrDefault("X-Amz-Date")
  valid_604560 = validateParameter(valid_604560, JString, required = false,
                                 default = nil)
  if valid_604560 != nil:
    section.add "X-Amz-Date", valid_604560
  var valid_604561 = header.getOrDefault("X-Amz-Security-Token")
  valid_604561 = validateParameter(valid_604561, JString, required = false,
                                 default = nil)
  if valid_604561 != nil:
    section.add "X-Amz-Security-Token", valid_604561
  var valid_604562 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604562 = validateParameter(valid_604562, JString, required = false,
                                 default = nil)
  if valid_604562 != nil:
    section.add "X-Amz-Content-Sha256", valid_604562
  var valid_604563 = header.getOrDefault("X-Amz-Algorithm")
  valid_604563 = validateParameter(valid_604563, JString, required = false,
                                 default = nil)
  if valid_604563 != nil:
    section.add "X-Amz-Algorithm", valid_604563
  var valid_604564 = header.getOrDefault("X-Amz-Signature")
  valid_604564 = validateParameter(valid_604564, JString, required = false,
                                 default = nil)
  if valid_604564 != nil:
    section.add "X-Amz-Signature", valid_604564
  var valid_604565 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604565 = validateParameter(valid_604565, JString, required = false,
                                 default = nil)
  if valid_604565 != nil:
    section.add "X-Amz-SignedHeaders", valid_604565
  var valid_604566 = header.getOrDefault("X-Amz-Credential")
  valid_604566 = validateParameter(valid_604566, JString, required = false,
                                 default = nil)
  if valid_604566 != nil:
    section.add "X-Amz-Credential", valid_604566
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604567: Call_DescribeAuditMitigationActionsTask_604556;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ## 
  let valid = call_604567.validator(path, query, header, formData, body)
  let scheme = call_604567.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604567.url(scheme.get, call_604567.host, call_604567.base,
                         call_604567.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604567, url, valid)

proc call*(call_604568: Call_DescribeAuditMitigationActionsTask_604556;
          taskId: string): Recallable =
  ## describeAuditMitigationActionsTask
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ##   taskId: string (required)
  ##         : The unique identifier for the audit mitigation task.
  var path_604569 = newJObject()
  add(path_604569, "taskId", newJString(taskId))
  result = call_604568.call(path_604569, nil, nil, nil, nil)

var describeAuditMitigationActionsTask* = Call_DescribeAuditMitigationActionsTask_604556(
    name: "describeAuditMitigationActionsTask", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/mitigationactions/tasks/{taskId}",
    validator: validate_DescribeAuditMitigationActionsTask_604557, base: "/",
    url: url_DescribeAuditMitigationActionsTask_604558,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditTask_604586 = ref object of OpenApiRestCall_602466
proc url_DescribeAuditTask_604588(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeAuditTask_604587(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Gets information about a Device Defender audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The ID of the audit whose information you want to get.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_604589 = path.getOrDefault("taskId")
  valid_604589 = validateParameter(valid_604589, JString, required = true,
                                 default = nil)
  if valid_604589 != nil:
    section.add "taskId", valid_604589
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604590 = header.getOrDefault("X-Amz-Date")
  valid_604590 = validateParameter(valid_604590, JString, required = false,
                                 default = nil)
  if valid_604590 != nil:
    section.add "X-Amz-Date", valid_604590
  var valid_604591 = header.getOrDefault("X-Amz-Security-Token")
  valid_604591 = validateParameter(valid_604591, JString, required = false,
                                 default = nil)
  if valid_604591 != nil:
    section.add "X-Amz-Security-Token", valid_604591
  var valid_604592 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604592 = validateParameter(valid_604592, JString, required = false,
                                 default = nil)
  if valid_604592 != nil:
    section.add "X-Amz-Content-Sha256", valid_604592
  var valid_604593 = header.getOrDefault("X-Amz-Algorithm")
  valid_604593 = validateParameter(valid_604593, JString, required = false,
                                 default = nil)
  if valid_604593 != nil:
    section.add "X-Amz-Algorithm", valid_604593
  var valid_604594 = header.getOrDefault("X-Amz-Signature")
  valid_604594 = validateParameter(valid_604594, JString, required = false,
                                 default = nil)
  if valid_604594 != nil:
    section.add "X-Amz-Signature", valid_604594
  var valid_604595 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604595 = validateParameter(valid_604595, JString, required = false,
                                 default = nil)
  if valid_604595 != nil:
    section.add "X-Amz-SignedHeaders", valid_604595
  var valid_604596 = header.getOrDefault("X-Amz-Credential")
  valid_604596 = validateParameter(valid_604596, JString, required = false,
                                 default = nil)
  if valid_604596 != nil:
    section.add "X-Amz-Credential", valid_604596
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604597: Call_DescribeAuditTask_604586; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a Device Defender audit.
  ## 
  let valid = call_604597.validator(path, query, header, formData, body)
  let scheme = call_604597.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604597.url(scheme.get, call_604597.host, call_604597.base,
                         call_604597.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604597, url, valid)

proc call*(call_604598: Call_DescribeAuditTask_604586; taskId: string): Recallable =
  ## describeAuditTask
  ## Gets information about a Device Defender audit.
  ##   taskId: string (required)
  ##         : The ID of the audit whose information you want to get.
  var path_604599 = newJObject()
  add(path_604599, "taskId", newJString(taskId))
  result = call_604598.call(path_604599, nil, nil, nil, nil)

var describeAuditTask* = Call_DescribeAuditTask_604586(name: "describeAuditTask",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/audit/tasks/{taskId}", validator: validate_DescribeAuditTask_604587,
    base: "/", url: url_DescribeAuditTask_604588,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeEndpoint_604600 = ref object of OpenApiRestCall_602466
proc url_DescribeEndpoint_604602(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DescribeEndpoint_604601(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Returns a unique endpoint specific to the AWS account making the call.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endpointType: JString
  ##               : <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
  section = newJObject()
  var valid_604603 = query.getOrDefault("endpointType")
  valid_604603 = validateParameter(valid_604603, JString, required = false,
                                 default = nil)
  if valid_604603 != nil:
    section.add "endpointType", valid_604603
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604604 = header.getOrDefault("X-Amz-Date")
  valid_604604 = validateParameter(valid_604604, JString, required = false,
                                 default = nil)
  if valid_604604 != nil:
    section.add "X-Amz-Date", valid_604604
  var valid_604605 = header.getOrDefault("X-Amz-Security-Token")
  valid_604605 = validateParameter(valid_604605, JString, required = false,
                                 default = nil)
  if valid_604605 != nil:
    section.add "X-Amz-Security-Token", valid_604605
  var valid_604606 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604606 = validateParameter(valid_604606, JString, required = false,
                                 default = nil)
  if valid_604606 != nil:
    section.add "X-Amz-Content-Sha256", valid_604606
  var valid_604607 = header.getOrDefault("X-Amz-Algorithm")
  valid_604607 = validateParameter(valid_604607, JString, required = false,
                                 default = nil)
  if valid_604607 != nil:
    section.add "X-Amz-Algorithm", valid_604607
  var valid_604608 = header.getOrDefault("X-Amz-Signature")
  valid_604608 = validateParameter(valid_604608, JString, required = false,
                                 default = nil)
  if valid_604608 != nil:
    section.add "X-Amz-Signature", valid_604608
  var valid_604609 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604609 = validateParameter(valid_604609, JString, required = false,
                                 default = nil)
  if valid_604609 != nil:
    section.add "X-Amz-SignedHeaders", valid_604609
  var valid_604610 = header.getOrDefault("X-Amz-Credential")
  valid_604610 = validateParameter(valid_604610, JString, required = false,
                                 default = nil)
  if valid_604610 != nil:
    section.add "X-Amz-Credential", valid_604610
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604611: Call_DescribeEndpoint_604600; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a unique endpoint specific to the AWS account making the call.
  ## 
  let valid = call_604611.validator(path, query, header, formData, body)
  let scheme = call_604611.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604611.url(scheme.get, call_604611.host, call_604611.base,
                         call_604611.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604611, url, valid)

proc call*(call_604612: Call_DescribeEndpoint_604600; endpointType: string = ""): Recallable =
  ## describeEndpoint
  ## Returns a unique endpoint specific to the AWS account making the call.
  ##   endpointType: string
  ##               : <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
  var query_604613 = newJObject()
  add(query_604613, "endpointType", newJString(endpointType))
  result = call_604612.call(nil, query_604613, nil, nil, nil)

var describeEndpoint* = Call_DescribeEndpoint_604600(name: "describeEndpoint",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/endpoint",
    validator: validate_DescribeEndpoint_604601, base: "/",
    url: url_DescribeEndpoint_604602, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeEventConfigurations_604614 = ref object of OpenApiRestCall_602466
proc url_DescribeEventConfigurations_604616(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DescribeEventConfigurations_604615(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes event configurations.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604617 = header.getOrDefault("X-Amz-Date")
  valid_604617 = validateParameter(valid_604617, JString, required = false,
                                 default = nil)
  if valid_604617 != nil:
    section.add "X-Amz-Date", valid_604617
  var valid_604618 = header.getOrDefault("X-Amz-Security-Token")
  valid_604618 = validateParameter(valid_604618, JString, required = false,
                                 default = nil)
  if valid_604618 != nil:
    section.add "X-Amz-Security-Token", valid_604618
  var valid_604619 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604619 = validateParameter(valid_604619, JString, required = false,
                                 default = nil)
  if valid_604619 != nil:
    section.add "X-Amz-Content-Sha256", valid_604619
  var valid_604620 = header.getOrDefault("X-Amz-Algorithm")
  valid_604620 = validateParameter(valid_604620, JString, required = false,
                                 default = nil)
  if valid_604620 != nil:
    section.add "X-Amz-Algorithm", valid_604620
  var valid_604621 = header.getOrDefault("X-Amz-Signature")
  valid_604621 = validateParameter(valid_604621, JString, required = false,
                                 default = nil)
  if valid_604621 != nil:
    section.add "X-Amz-Signature", valid_604621
  var valid_604622 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604622 = validateParameter(valid_604622, JString, required = false,
                                 default = nil)
  if valid_604622 != nil:
    section.add "X-Amz-SignedHeaders", valid_604622
  var valid_604623 = header.getOrDefault("X-Amz-Credential")
  valid_604623 = validateParameter(valid_604623, JString, required = false,
                                 default = nil)
  if valid_604623 != nil:
    section.add "X-Amz-Credential", valid_604623
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604624: Call_DescribeEventConfigurations_604614; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes event configurations.
  ## 
  let valid = call_604624.validator(path, query, header, formData, body)
  let scheme = call_604624.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604624.url(scheme.get, call_604624.host, call_604624.base,
                         call_604624.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604624, url, valid)

proc call*(call_604625: Call_DescribeEventConfigurations_604614): Recallable =
  ## describeEventConfigurations
  ## Describes event configurations.
  result = call_604625.call(nil, nil, nil, nil, nil)

var describeEventConfigurations* = Call_DescribeEventConfigurations_604614(
    name: "describeEventConfigurations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/event-configurations",
    validator: validate_DescribeEventConfigurations_604615, base: "/",
    url: url_DescribeEventConfigurations_604616,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateEventConfigurations_604626 = ref object of OpenApiRestCall_602466
proc url_UpdateEventConfigurations_604628(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateEventConfigurations_604627(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the event configurations.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604629 = header.getOrDefault("X-Amz-Date")
  valid_604629 = validateParameter(valid_604629, JString, required = false,
                                 default = nil)
  if valid_604629 != nil:
    section.add "X-Amz-Date", valid_604629
  var valid_604630 = header.getOrDefault("X-Amz-Security-Token")
  valid_604630 = validateParameter(valid_604630, JString, required = false,
                                 default = nil)
  if valid_604630 != nil:
    section.add "X-Amz-Security-Token", valid_604630
  var valid_604631 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604631 = validateParameter(valid_604631, JString, required = false,
                                 default = nil)
  if valid_604631 != nil:
    section.add "X-Amz-Content-Sha256", valid_604631
  var valid_604632 = header.getOrDefault("X-Amz-Algorithm")
  valid_604632 = validateParameter(valid_604632, JString, required = false,
                                 default = nil)
  if valid_604632 != nil:
    section.add "X-Amz-Algorithm", valid_604632
  var valid_604633 = header.getOrDefault("X-Amz-Signature")
  valid_604633 = validateParameter(valid_604633, JString, required = false,
                                 default = nil)
  if valid_604633 != nil:
    section.add "X-Amz-Signature", valid_604633
  var valid_604634 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604634 = validateParameter(valid_604634, JString, required = false,
                                 default = nil)
  if valid_604634 != nil:
    section.add "X-Amz-SignedHeaders", valid_604634
  var valid_604635 = header.getOrDefault("X-Amz-Credential")
  valid_604635 = validateParameter(valid_604635, JString, required = false,
                                 default = nil)
  if valid_604635 != nil:
    section.add "X-Amz-Credential", valid_604635
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604637: Call_UpdateEventConfigurations_604626; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the event configurations.
  ## 
  let valid = call_604637.validator(path, query, header, formData, body)
  let scheme = call_604637.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604637.url(scheme.get, call_604637.host, call_604637.base,
                         call_604637.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604637, url, valid)

proc call*(call_604638: Call_UpdateEventConfigurations_604626; body: JsonNode): Recallable =
  ## updateEventConfigurations
  ## Updates the event configurations.
  ##   body: JObject (required)
  var body_604639 = newJObject()
  if body != nil:
    body_604639 = body
  result = call_604638.call(nil, nil, nil, nil, body_604639)

var updateEventConfigurations* = Call_UpdateEventConfigurations_604626(
    name: "updateEventConfigurations", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/event-configurations",
    validator: validate_UpdateEventConfigurations_604627, base: "/",
    url: url_UpdateEventConfigurations_604628,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeIndex_604640 = ref object of OpenApiRestCall_602466
proc url_DescribeIndex_604642(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "indexName" in path, "`indexName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/indices/"),
               (kind: VariableSegment, value: "indexName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeIndex_604641(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a search index.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   indexName: JString (required)
  ##            : The index name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `indexName` field"
  var valid_604643 = path.getOrDefault("indexName")
  valid_604643 = validateParameter(valid_604643, JString, required = true,
                                 default = nil)
  if valid_604643 != nil:
    section.add "indexName", valid_604643
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604644 = header.getOrDefault("X-Amz-Date")
  valid_604644 = validateParameter(valid_604644, JString, required = false,
                                 default = nil)
  if valid_604644 != nil:
    section.add "X-Amz-Date", valid_604644
  var valid_604645 = header.getOrDefault("X-Amz-Security-Token")
  valid_604645 = validateParameter(valid_604645, JString, required = false,
                                 default = nil)
  if valid_604645 != nil:
    section.add "X-Amz-Security-Token", valid_604645
  var valid_604646 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604646 = validateParameter(valid_604646, JString, required = false,
                                 default = nil)
  if valid_604646 != nil:
    section.add "X-Amz-Content-Sha256", valid_604646
  var valid_604647 = header.getOrDefault("X-Amz-Algorithm")
  valid_604647 = validateParameter(valid_604647, JString, required = false,
                                 default = nil)
  if valid_604647 != nil:
    section.add "X-Amz-Algorithm", valid_604647
  var valid_604648 = header.getOrDefault("X-Amz-Signature")
  valid_604648 = validateParameter(valid_604648, JString, required = false,
                                 default = nil)
  if valid_604648 != nil:
    section.add "X-Amz-Signature", valid_604648
  var valid_604649 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604649 = validateParameter(valid_604649, JString, required = false,
                                 default = nil)
  if valid_604649 != nil:
    section.add "X-Amz-SignedHeaders", valid_604649
  var valid_604650 = header.getOrDefault("X-Amz-Credential")
  valid_604650 = validateParameter(valid_604650, JString, required = false,
                                 default = nil)
  if valid_604650 != nil:
    section.add "X-Amz-Credential", valid_604650
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604651: Call_DescribeIndex_604640; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a search index.
  ## 
  let valid = call_604651.validator(path, query, header, formData, body)
  let scheme = call_604651.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604651.url(scheme.get, call_604651.host, call_604651.base,
                         call_604651.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604651, url, valid)

proc call*(call_604652: Call_DescribeIndex_604640; indexName: string): Recallable =
  ## describeIndex
  ## Describes a search index.
  ##   indexName: string (required)
  ##            : The index name.
  var path_604653 = newJObject()
  add(path_604653, "indexName", newJString(indexName))
  result = call_604652.call(path_604653, nil, nil, nil, nil)

var describeIndex* = Call_DescribeIndex_604640(name: "describeIndex",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/indices/{indexName}", validator: validate_DescribeIndex_604641,
    base: "/", url: url_DescribeIndex_604642, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeJobExecution_604654 = ref object of OpenApiRestCall_602466
proc url_DescribeJobExecution_604656(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeJobExecution_604655(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a job execution.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing on which the job execution is running.
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_604657 = path.getOrDefault("thingName")
  valid_604657 = validateParameter(valid_604657, JString, required = true,
                                 default = nil)
  if valid_604657 != nil:
    section.add "thingName", valid_604657
  var valid_604658 = path.getOrDefault("jobId")
  valid_604658 = validateParameter(valid_604658, JString, required = true,
                                 default = nil)
  if valid_604658 != nil:
    section.add "jobId", valid_604658
  result.add "path", section
  ## parameters in `query` object:
  ##   executionNumber: JInt
  ##                  : A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
  section = newJObject()
  var valid_604659 = query.getOrDefault("executionNumber")
  valid_604659 = validateParameter(valid_604659, JInt, required = false, default = nil)
  if valid_604659 != nil:
    section.add "executionNumber", valid_604659
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604660 = header.getOrDefault("X-Amz-Date")
  valid_604660 = validateParameter(valid_604660, JString, required = false,
                                 default = nil)
  if valid_604660 != nil:
    section.add "X-Amz-Date", valid_604660
  var valid_604661 = header.getOrDefault("X-Amz-Security-Token")
  valid_604661 = validateParameter(valid_604661, JString, required = false,
                                 default = nil)
  if valid_604661 != nil:
    section.add "X-Amz-Security-Token", valid_604661
  var valid_604662 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604662 = validateParameter(valid_604662, JString, required = false,
                                 default = nil)
  if valid_604662 != nil:
    section.add "X-Amz-Content-Sha256", valid_604662
  var valid_604663 = header.getOrDefault("X-Amz-Algorithm")
  valid_604663 = validateParameter(valid_604663, JString, required = false,
                                 default = nil)
  if valid_604663 != nil:
    section.add "X-Amz-Algorithm", valid_604663
  var valid_604664 = header.getOrDefault("X-Amz-Signature")
  valid_604664 = validateParameter(valid_604664, JString, required = false,
                                 default = nil)
  if valid_604664 != nil:
    section.add "X-Amz-Signature", valid_604664
  var valid_604665 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604665 = validateParameter(valid_604665, JString, required = false,
                                 default = nil)
  if valid_604665 != nil:
    section.add "X-Amz-SignedHeaders", valid_604665
  var valid_604666 = header.getOrDefault("X-Amz-Credential")
  valid_604666 = validateParameter(valid_604666, JString, required = false,
                                 default = nil)
  if valid_604666 != nil:
    section.add "X-Amz-Credential", valid_604666
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604667: Call_DescribeJobExecution_604654; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a job execution.
  ## 
  let valid = call_604667.validator(path, query, header, formData, body)
  let scheme = call_604667.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604667.url(scheme.get, call_604667.host, call_604667.base,
                         call_604667.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604667, url, valid)

proc call*(call_604668: Call_DescribeJobExecution_604654; thingName: string;
          jobId: string; executionNumber: int = 0): Recallable =
  ## describeJobExecution
  ## Describes a job execution.
  ##   thingName: string (required)
  ##            : The name of the thing on which the job execution is running.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   executionNumber: int
  ##                  : A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
  var path_604669 = newJObject()
  var query_604670 = newJObject()
  add(path_604669, "thingName", newJString(thingName))
  add(path_604669, "jobId", newJString(jobId))
  add(query_604670, "executionNumber", newJInt(executionNumber))
  result = call_604668.call(path_604669, query_604670, nil, nil, nil)

var describeJobExecution* = Call_DescribeJobExecution_604654(
    name: "describeJobExecution", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs/{jobId}",
    validator: validate_DescribeJobExecution_604655, base: "/",
    url: url_DescribeJobExecution_604656, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingRegistrationTask_604671 = ref object of OpenApiRestCall_602466
proc url_DescribeThingRegistrationTask_604673(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DescribeThingRegistrationTask_604672(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The task ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_604674 = path.getOrDefault("taskId")
  valid_604674 = validateParameter(valid_604674, JString, required = true,
                                 default = nil)
  if valid_604674 != nil:
    section.add "taskId", valid_604674
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604675 = header.getOrDefault("X-Amz-Date")
  valid_604675 = validateParameter(valid_604675, JString, required = false,
                                 default = nil)
  if valid_604675 != nil:
    section.add "X-Amz-Date", valid_604675
  var valid_604676 = header.getOrDefault("X-Amz-Security-Token")
  valid_604676 = validateParameter(valid_604676, JString, required = false,
                                 default = nil)
  if valid_604676 != nil:
    section.add "X-Amz-Security-Token", valid_604676
  var valid_604677 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604677 = validateParameter(valid_604677, JString, required = false,
                                 default = nil)
  if valid_604677 != nil:
    section.add "X-Amz-Content-Sha256", valid_604677
  var valid_604678 = header.getOrDefault("X-Amz-Algorithm")
  valid_604678 = validateParameter(valid_604678, JString, required = false,
                                 default = nil)
  if valid_604678 != nil:
    section.add "X-Amz-Algorithm", valid_604678
  var valid_604679 = header.getOrDefault("X-Amz-Signature")
  valid_604679 = validateParameter(valid_604679, JString, required = false,
                                 default = nil)
  if valid_604679 != nil:
    section.add "X-Amz-Signature", valid_604679
  var valid_604680 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604680 = validateParameter(valid_604680, JString, required = false,
                                 default = nil)
  if valid_604680 != nil:
    section.add "X-Amz-SignedHeaders", valid_604680
  var valid_604681 = header.getOrDefault("X-Amz-Credential")
  valid_604681 = validateParameter(valid_604681, JString, required = false,
                                 default = nil)
  if valid_604681 != nil:
    section.add "X-Amz-Credential", valid_604681
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604682: Call_DescribeThingRegistrationTask_604671; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a bulk thing provisioning task.
  ## 
  let valid = call_604682.validator(path, query, header, formData, body)
  let scheme = call_604682.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604682.url(scheme.get, call_604682.host, call_604682.base,
                         call_604682.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604682, url, valid)

proc call*(call_604683: Call_DescribeThingRegistrationTask_604671; taskId: string): Recallable =
  ## describeThingRegistrationTask
  ## Describes a bulk thing provisioning task.
  ##   taskId: string (required)
  ##         : The task ID.
  var path_604684 = newJObject()
  add(path_604684, "taskId", newJString(taskId))
  result = call_604683.call(path_604684, nil, nil, nil, nil)

var describeThingRegistrationTask* = Call_DescribeThingRegistrationTask_604671(
    name: "describeThingRegistrationTask", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks/{taskId}",
    validator: validate_DescribeThingRegistrationTask_604672, base: "/",
    url: url_DescribeThingRegistrationTask_604673,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DisableTopicRule_604685 = ref object of OpenApiRestCall_602466
proc url_DisableTopicRule_604687(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName"),
               (kind: ConstantSegment, value: "/disable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DisableTopicRule_604686(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Disables the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule to disable.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_604688 = path.getOrDefault("ruleName")
  valid_604688 = validateParameter(valid_604688, JString, required = true,
                                 default = nil)
  if valid_604688 != nil:
    section.add "ruleName", valid_604688
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604689 = header.getOrDefault("X-Amz-Date")
  valid_604689 = validateParameter(valid_604689, JString, required = false,
                                 default = nil)
  if valid_604689 != nil:
    section.add "X-Amz-Date", valid_604689
  var valid_604690 = header.getOrDefault("X-Amz-Security-Token")
  valid_604690 = validateParameter(valid_604690, JString, required = false,
                                 default = nil)
  if valid_604690 != nil:
    section.add "X-Amz-Security-Token", valid_604690
  var valid_604691 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604691 = validateParameter(valid_604691, JString, required = false,
                                 default = nil)
  if valid_604691 != nil:
    section.add "X-Amz-Content-Sha256", valid_604691
  var valid_604692 = header.getOrDefault("X-Amz-Algorithm")
  valid_604692 = validateParameter(valid_604692, JString, required = false,
                                 default = nil)
  if valid_604692 != nil:
    section.add "X-Amz-Algorithm", valid_604692
  var valid_604693 = header.getOrDefault("X-Amz-Signature")
  valid_604693 = validateParameter(valid_604693, JString, required = false,
                                 default = nil)
  if valid_604693 != nil:
    section.add "X-Amz-Signature", valid_604693
  var valid_604694 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604694 = validateParameter(valid_604694, JString, required = false,
                                 default = nil)
  if valid_604694 != nil:
    section.add "X-Amz-SignedHeaders", valid_604694
  var valid_604695 = header.getOrDefault("X-Amz-Credential")
  valid_604695 = validateParameter(valid_604695, JString, required = false,
                                 default = nil)
  if valid_604695 != nil:
    section.add "X-Amz-Credential", valid_604695
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604696: Call_DisableTopicRule_604685; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Disables the rule.
  ## 
  let valid = call_604696.validator(path, query, header, formData, body)
  let scheme = call_604696.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604696.url(scheme.get, call_604696.host, call_604696.base,
                         call_604696.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604696, url, valid)

proc call*(call_604697: Call_DisableTopicRule_604685; ruleName: string): Recallable =
  ## disableTopicRule
  ## Disables the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule to disable.
  var path_604698 = newJObject()
  add(path_604698, "ruleName", newJString(ruleName))
  result = call_604697.call(path_604698, nil, nil, nil, nil)

var disableTopicRule* = Call_DisableTopicRule_604685(name: "disableTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}/disable", validator: validate_DisableTopicRule_604686,
    base: "/", url: url_DisableTopicRule_604687,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_EnableTopicRule_604699 = ref object of OpenApiRestCall_602466
proc url_EnableTopicRule_604701(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName"),
               (kind: ConstantSegment, value: "/enable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_EnableTopicRule_604700(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Enables the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the topic rule to enable.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_604702 = path.getOrDefault("ruleName")
  valid_604702 = validateParameter(valid_604702, JString, required = true,
                                 default = nil)
  if valid_604702 != nil:
    section.add "ruleName", valid_604702
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604703 = header.getOrDefault("X-Amz-Date")
  valid_604703 = validateParameter(valid_604703, JString, required = false,
                                 default = nil)
  if valid_604703 != nil:
    section.add "X-Amz-Date", valid_604703
  var valid_604704 = header.getOrDefault("X-Amz-Security-Token")
  valid_604704 = validateParameter(valid_604704, JString, required = false,
                                 default = nil)
  if valid_604704 != nil:
    section.add "X-Amz-Security-Token", valid_604704
  var valid_604705 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604705 = validateParameter(valid_604705, JString, required = false,
                                 default = nil)
  if valid_604705 != nil:
    section.add "X-Amz-Content-Sha256", valid_604705
  var valid_604706 = header.getOrDefault("X-Amz-Algorithm")
  valid_604706 = validateParameter(valid_604706, JString, required = false,
                                 default = nil)
  if valid_604706 != nil:
    section.add "X-Amz-Algorithm", valid_604706
  var valid_604707 = header.getOrDefault("X-Amz-Signature")
  valid_604707 = validateParameter(valid_604707, JString, required = false,
                                 default = nil)
  if valid_604707 != nil:
    section.add "X-Amz-Signature", valid_604707
  var valid_604708 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604708 = validateParameter(valid_604708, JString, required = false,
                                 default = nil)
  if valid_604708 != nil:
    section.add "X-Amz-SignedHeaders", valid_604708
  var valid_604709 = header.getOrDefault("X-Amz-Credential")
  valid_604709 = validateParameter(valid_604709, JString, required = false,
                                 default = nil)
  if valid_604709 != nil:
    section.add "X-Amz-Credential", valid_604709
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604710: Call_EnableTopicRule_604699; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the rule.
  ## 
  let valid = call_604710.validator(path, query, header, formData, body)
  let scheme = call_604710.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604710.url(scheme.get, call_604710.host, call_604710.base,
                         call_604710.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604710, url, valid)

proc call*(call_604711: Call_EnableTopicRule_604699; ruleName: string): Recallable =
  ## enableTopicRule
  ## Enables the rule.
  ##   ruleName: string (required)
  ##           : The name of the topic rule to enable.
  var path_604712 = newJObject()
  add(path_604712, "ruleName", newJString(ruleName))
  result = call_604711.call(path_604712, nil, nil, nil, nil)

var enableTopicRule* = Call_EnableTopicRule_604699(name: "enableTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}/enable", validator: validate_EnableTopicRule_604700,
    base: "/", url: url_EnableTopicRule_604701, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEffectivePolicies_604713 = ref object of OpenApiRestCall_602466
proc url_GetEffectivePolicies_604715(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetEffectivePolicies_604714(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingName: JString
  ##            : The thing name.
  section = newJObject()
  var valid_604716 = query.getOrDefault("thingName")
  valid_604716 = validateParameter(valid_604716, JString, required = false,
                                 default = nil)
  if valid_604716 != nil:
    section.add "thingName", valid_604716
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604717 = header.getOrDefault("X-Amz-Date")
  valid_604717 = validateParameter(valid_604717, JString, required = false,
                                 default = nil)
  if valid_604717 != nil:
    section.add "X-Amz-Date", valid_604717
  var valid_604718 = header.getOrDefault("X-Amz-Security-Token")
  valid_604718 = validateParameter(valid_604718, JString, required = false,
                                 default = nil)
  if valid_604718 != nil:
    section.add "X-Amz-Security-Token", valid_604718
  var valid_604719 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604719 = validateParameter(valid_604719, JString, required = false,
                                 default = nil)
  if valid_604719 != nil:
    section.add "X-Amz-Content-Sha256", valid_604719
  var valid_604720 = header.getOrDefault("X-Amz-Algorithm")
  valid_604720 = validateParameter(valid_604720, JString, required = false,
                                 default = nil)
  if valid_604720 != nil:
    section.add "X-Amz-Algorithm", valid_604720
  var valid_604721 = header.getOrDefault("X-Amz-Signature")
  valid_604721 = validateParameter(valid_604721, JString, required = false,
                                 default = nil)
  if valid_604721 != nil:
    section.add "X-Amz-Signature", valid_604721
  var valid_604722 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604722 = validateParameter(valid_604722, JString, required = false,
                                 default = nil)
  if valid_604722 != nil:
    section.add "X-Amz-SignedHeaders", valid_604722
  var valid_604723 = header.getOrDefault("X-Amz-Credential")
  valid_604723 = validateParameter(valid_604723, JString, required = false,
                                 default = nil)
  if valid_604723 != nil:
    section.add "X-Amz-Credential", valid_604723
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604725: Call_GetEffectivePolicies_604713; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ## 
  let valid = call_604725.validator(path, query, header, formData, body)
  let scheme = call_604725.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604725.url(scheme.get, call_604725.host, call_604725.base,
                         call_604725.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604725, url, valid)

proc call*(call_604726: Call_GetEffectivePolicies_604713; body: JsonNode;
          thingName: string = ""): Recallable =
  ## getEffectivePolicies
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ##   thingName: string
  ##            : The thing name.
  ##   body: JObject (required)
  var query_604727 = newJObject()
  var body_604728 = newJObject()
  add(query_604727, "thingName", newJString(thingName))
  if body != nil:
    body_604728 = body
  result = call_604726.call(nil, query_604727, nil, nil, body_604728)

var getEffectivePolicies* = Call_GetEffectivePolicies_604713(
    name: "getEffectivePolicies", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/effective-policies",
    validator: validate_GetEffectivePolicies_604714, base: "/",
    url: url_GetEffectivePolicies_604715, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateIndexingConfiguration_604741 = ref object of OpenApiRestCall_602466
proc url_UpdateIndexingConfiguration_604743(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateIndexingConfiguration_604742(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the search configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604744 = header.getOrDefault("X-Amz-Date")
  valid_604744 = validateParameter(valid_604744, JString, required = false,
                                 default = nil)
  if valid_604744 != nil:
    section.add "X-Amz-Date", valid_604744
  var valid_604745 = header.getOrDefault("X-Amz-Security-Token")
  valid_604745 = validateParameter(valid_604745, JString, required = false,
                                 default = nil)
  if valid_604745 != nil:
    section.add "X-Amz-Security-Token", valid_604745
  var valid_604746 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604746 = validateParameter(valid_604746, JString, required = false,
                                 default = nil)
  if valid_604746 != nil:
    section.add "X-Amz-Content-Sha256", valid_604746
  var valid_604747 = header.getOrDefault("X-Amz-Algorithm")
  valid_604747 = validateParameter(valid_604747, JString, required = false,
                                 default = nil)
  if valid_604747 != nil:
    section.add "X-Amz-Algorithm", valid_604747
  var valid_604748 = header.getOrDefault("X-Amz-Signature")
  valid_604748 = validateParameter(valid_604748, JString, required = false,
                                 default = nil)
  if valid_604748 != nil:
    section.add "X-Amz-Signature", valid_604748
  var valid_604749 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604749 = validateParameter(valid_604749, JString, required = false,
                                 default = nil)
  if valid_604749 != nil:
    section.add "X-Amz-SignedHeaders", valid_604749
  var valid_604750 = header.getOrDefault("X-Amz-Credential")
  valid_604750 = validateParameter(valid_604750, JString, required = false,
                                 default = nil)
  if valid_604750 != nil:
    section.add "X-Amz-Credential", valid_604750
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604752: Call_UpdateIndexingConfiguration_604741; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the search configuration.
  ## 
  let valid = call_604752.validator(path, query, header, formData, body)
  let scheme = call_604752.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604752.url(scheme.get, call_604752.host, call_604752.base,
                         call_604752.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604752, url, valid)

proc call*(call_604753: Call_UpdateIndexingConfiguration_604741; body: JsonNode): Recallable =
  ## updateIndexingConfiguration
  ## Updates the search configuration.
  ##   body: JObject (required)
  var body_604754 = newJObject()
  if body != nil:
    body_604754 = body
  result = call_604753.call(nil, nil, nil, nil, body_604754)

var updateIndexingConfiguration* = Call_UpdateIndexingConfiguration_604741(
    name: "updateIndexingConfiguration", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/indexing/config",
    validator: validate_UpdateIndexingConfiguration_604742, base: "/",
    url: url_UpdateIndexingConfiguration_604743,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetIndexingConfiguration_604729 = ref object of OpenApiRestCall_602466
proc url_GetIndexingConfiguration_604731(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetIndexingConfiguration_604730(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the search configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604732 = header.getOrDefault("X-Amz-Date")
  valid_604732 = validateParameter(valid_604732, JString, required = false,
                                 default = nil)
  if valid_604732 != nil:
    section.add "X-Amz-Date", valid_604732
  var valid_604733 = header.getOrDefault("X-Amz-Security-Token")
  valid_604733 = validateParameter(valid_604733, JString, required = false,
                                 default = nil)
  if valid_604733 != nil:
    section.add "X-Amz-Security-Token", valid_604733
  var valid_604734 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604734 = validateParameter(valid_604734, JString, required = false,
                                 default = nil)
  if valid_604734 != nil:
    section.add "X-Amz-Content-Sha256", valid_604734
  var valid_604735 = header.getOrDefault("X-Amz-Algorithm")
  valid_604735 = validateParameter(valid_604735, JString, required = false,
                                 default = nil)
  if valid_604735 != nil:
    section.add "X-Amz-Algorithm", valid_604735
  var valid_604736 = header.getOrDefault("X-Amz-Signature")
  valid_604736 = validateParameter(valid_604736, JString, required = false,
                                 default = nil)
  if valid_604736 != nil:
    section.add "X-Amz-Signature", valid_604736
  var valid_604737 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604737 = validateParameter(valid_604737, JString, required = false,
                                 default = nil)
  if valid_604737 != nil:
    section.add "X-Amz-SignedHeaders", valid_604737
  var valid_604738 = header.getOrDefault("X-Amz-Credential")
  valid_604738 = validateParameter(valid_604738, JString, required = false,
                                 default = nil)
  if valid_604738 != nil:
    section.add "X-Amz-Credential", valid_604738
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604739: Call_GetIndexingConfiguration_604729; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the search configuration.
  ## 
  let valid = call_604739.validator(path, query, header, formData, body)
  let scheme = call_604739.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604739.url(scheme.get, call_604739.host, call_604739.base,
                         call_604739.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604739, url, valid)

proc call*(call_604740: Call_GetIndexingConfiguration_604729): Recallable =
  ## getIndexingConfiguration
  ## Gets the search configuration.
  result = call_604740.call(nil, nil, nil, nil, nil)

var getIndexingConfiguration* = Call_GetIndexingConfiguration_604729(
    name: "getIndexingConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/indexing/config",
    validator: validate_GetIndexingConfiguration_604730, base: "/",
    url: url_GetIndexingConfiguration_604731, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetJobDocument_604755 = ref object of OpenApiRestCall_602466
proc url_GetJobDocument_604757(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/job-document")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetJobDocument_604756(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets a job document.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_604758 = path.getOrDefault("jobId")
  valid_604758 = validateParameter(valid_604758, JString, required = true,
                                 default = nil)
  if valid_604758 != nil:
    section.add "jobId", valid_604758
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604759 = header.getOrDefault("X-Amz-Date")
  valid_604759 = validateParameter(valid_604759, JString, required = false,
                                 default = nil)
  if valid_604759 != nil:
    section.add "X-Amz-Date", valid_604759
  var valid_604760 = header.getOrDefault("X-Amz-Security-Token")
  valid_604760 = validateParameter(valid_604760, JString, required = false,
                                 default = nil)
  if valid_604760 != nil:
    section.add "X-Amz-Security-Token", valid_604760
  var valid_604761 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604761 = validateParameter(valid_604761, JString, required = false,
                                 default = nil)
  if valid_604761 != nil:
    section.add "X-Amz-Content-Sha256", valid_604761
  var valid_604762 = header.getOrDefault("X-Amz-Algorithm")
  valid_604762 = validateParameter(valid_604762, JString, required = false,
                                 default = nil)
  if valid_604762 != nil:
    section.add "X-Amz-Algorithm", valid_604762
  var valid_604763 = header.getOrDefault("X-Amz-Signature")
  valid_604763 = validateParameter(valid_604763, JString, required = false,
                                 default = nil)
  if valid_604763 != nil:
    section.add "X-Amz-Signature", valid_604763
  var valid_604764 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604764 = validateParameter(valid_604764, JString, required = false,
                                 default = nil)
  if valid_604764 != nil:
    section.add "X-Amz-SignedHeaders", valid_604764
  var valid_604765 = header.getOrDefault("X-Amz-Credential")
  valid_604765 = validateParameter(valid_604765, JString, required = false,
                                 default = nil)
  if valid_604765 != nil:
    section.add "X-Amz-Credential", valid_604765
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604766: Call_GetJobDocument_604755; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a job document.
  ## 
  let valid = call_604766.validator(path, query, header, formData, body)
  let scheme = call_604766.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604766.url(scheme.get, call_604766.host, call_604766.base,
                         call_604766.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604766, url, valid)

proc call*(call_604767: Call_GetJobDocument_604755; jobId: string): Recallable =
  ## getJobDocument
  ## Gets a job document.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  var path_604768 = newJObject()
  add(path_604768, "jobId", newJString(jobId))
  result = call_604767.call(path_604768, nil, nil, nil, nil)

var getJobDocument* = Call_GetJobDocument_604755(name: "getJobDocument",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/jobs/{jobId}/job-document", validator: validate_GetJobDocument_604756,
    base: "/", url: url_GetJobDocument_604757, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetLoggingOptions_604781 = ref object of OpenApiRestCall_602466
proc url_SetLoggingOptions_604783(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_SetLoggingOptions_604782(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604784 = header.getOrDefault("X-Amz-Date")
  valid_604784 = validateParameter(valid_604784, JString, required = false,
                                 default = nil)
  if valid_604784 != nil:
    section.add "X-Amz-Date", valid_604784
  var valid_604785 = header.getOrDefault("X-Amz-Security-Token")
  valid_604785 = validateParameter(valid_604785, JString, required = false,
                                 default = nil)
  if valid_604785 != nil:
    section.add "X-Amz-Security-Token", valid_604785
  var valid_604786 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604786 = validateParameter(valid_604786, JString, required = false,
                                 default = nil)
  if valid_604786 != nil:
    section.add "X-Amz-Content-Sha256", valid_604786
  var valid_604787 = header.getOrDefault("X-Amz-Algorithm")
  valid_604787 = validateParameter(valid_604787, JString, required = false,
                                 default = nil)
  if valid_604787 != nil:
    section.add "X-Amz-Algorithm", valid_604787
  var valid_604788 = header.getOrDefault("X-Amz-Signature")
  valid_604788 = validateParameter(valid_604788, JString, required = false,
                                 default = nil)
  if valid_604788 != nil:
    section.add "X-Amz-Signature", valid_604788
  var valid_604789 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604789 = validateParameter(valid_604789, JString, required = false,
                                 default = nil)
  if valid_604789 != nil:
    section.add "X-Amz-SignedHeaders", valid_604789
  var valid_604790 = header.getOrDefault("X-Amz-Credential")
  valid_604790 = validateParameter(valid_604790, JString, required = false,
                                 default = nil)
  if valid_604790 != nil:
    section.add "X-Amz-Credential", valid_604790
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604792: Call_SetLoggingOptions_604781; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ## 
  let valid = call_604792.validator(path, query, header, formData, body)
  let scheme = call_604792.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604792.url(scheme.get, call_604792.host, call_604792.base,
                         call_604792.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604792, url, valid)

proc call*(call_604793: Call_SetLoggingOptions_604781; body: JsonNode): Recallable =
  ## setLoggingOptions
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ##   body: JObject (required)
  var body_604794 = newJObject()
  if body != nil:
    body_604794 = body
  result = call_604793.call(nil, nil, nil, nil, body_604794)

var setLoggingOptions* = Call_SetLoggingOptions_604781(name: "setLoggingOptions",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/loggingOptions",
    validator: validate_SetLoggingOptions_604782, base: "/",
    url: url_SetLoggingOptions_604783, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetLoggingOptions_604769 = ref object of OpenApiRestCall_602466
proc url_GetLoggingOptions_604771(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetLoggingOptions_604770(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604772 = header.getOrDefault("X-Amz-Date")
  valid_604772 = validateParameter(valid_604772, JString, required = false,
                                 default = nil)
  if valid_604772 != nil:
    section.add "X-Amz-Date", valid_604772
  var valid_604773 = header.getOrDefault("X-Amz-Security-Token")
  valid_604773 = validateParameter(valid_604773, JString, required = false,
                                 default = nil)
  if valid_604773 != nil:
    section.add "X-Amz-Security-Token", valid_604773
  var valid_604774 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604774 = validateParameter(valid_604774, JString, required = false,
                                 default = nil)
  if valid_604774 != nil:
    section.add "X-Amz-Content-Sha256", valid_604774
  var valid_604775 = header.getOrDefault("X-Amz-Algorithm")
  valid_604775 = validateParameter(valid_604775, JString, required = false,
                                 default = nil)
  if valid_604775 != nil:
    section.add "X-Amz-Algorithm", valid_604775
  var valid_604776 = header.getOrDefault("X-Amz-Signature")
  valid_604776 = validateParameter(valid_604776, JString, required = false,
                                 default = nil)
  if valid_604776 != nil:
    section.add "X-Amz-Signature", valid_604776
  var valid_604777 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604777 = validateParameter(valid_604777, JString, required = false,
                                 default = nil)
  if valid_604777 != nil:
    section.add "X-Amz-SignedHeaders", valid_604777
  var valid_604778 = header.getOrDefault("X-Amz-Credential")
  valid_604778 = validateParameter(valid_604778, JString, required = false,
                                 default = nil)
  if valid_604778 != nil:
    section.add "X-Amz-Credential", valid_604778
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604779: Call_GetLoggingOptions_604769; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  ## 
  let valid = call_604779.validator(path, query, header, formData, body)
  let scheme = call_604779.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604779.url(scheme.get, call_604779.host, call_604779.base,
                         call_604779.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604779, url, valid)

proc call*(call_604780: Call_GetLoggingOptions_604769): Recallable =
  ## getLoggingOptions
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  result = call_604780.call(nil, nil, nil, nil, nil)

var getLoggingOptions* = Call_GetLoggingOptions_604769(name: "getLoggingOptions",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/loggingOptions",
    validator: validate_GetLoggingOptions_604770, base: "/",
    url: url_GetLoggingOptions_604771, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetStatistics_604795 = ref object of OpenApiRestCall_602466
proc url_GetStatistics_604797(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetStatistics_604796(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets statistics about things that match the specified query.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604798 = header.getOrDefault("X-Amz-Date")
  valid_604798 = validateParameter(valid_604798, JString, required = false,
                                 default = nil)
  if valid_604798 != nil:
    section.add "X-Amz-Date", valid_604798
  var valid_604799 = header.getOrDefault("X-Amz-Security-Token")
  valid_604799 = validateParameter(valid_604799, JString, required = false,
                                 default = nil)
  if valid_604799 != nil:
    section.add "X-Amz-Security-Token", valid_604799
  var valid_604800 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604800 = validateParameter(valid_604800, JString, required = false,
                                 default = nil)
  if valid_604800 != nil:
    section.add "X-Amz-Content-Sha256", valid_604800
  var valid_604801 = header.getOrDefault("X-Amz-Algorithm")
  valid_604801 = validateParameter(valid_604801, JString, required = false,
                                 default = nil)
  if valid_604801 != nil:
    section.add "X-Amz-Algorithm", valid_604801
  var valid_604802 = header.getOrDefault("X-Amz-Signature")
  valid_604802 = validateParameter(valid_604802, JString, required = false,
                                 default = nil)
  if valid_604802 != nil:
    section.add "X-Amz-Signature", valid_604802
  var valid_604803 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604803 = validateParameter(valid_604803, JString, required = false,
                                 default = nil)
  if valid_604803 != nil:
    section.add "X-Amz-SignedHeaders", valid_604803
  var valid_604804 = header.getOrDefault("X-Amz-Credential")
  valid_604804 = validateParameter(valid_604804, JString, required = false,
                                 default = nil)
  if valid_604804 != nil:
    section.add "X-Amz-Credential", valid_604804
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604806: Call_GetStatistics_604795; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets statistics about things that match the specified query.
  ## 
  let valid = call_604806.validator(path, query, header, formData, body)
  let scheme = call_604806.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604806.url(scheme.get, call_604806.host, call_604806.base,
                         call_604806.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604806, url, valid)

proc call*(call_604807: Call_GetStatistics_604795; body: JsonNode): Recallable =
  ## getStatistics
  ## Gets statistics about things that match the specified query.
  ##   body: JObject (required)
  var body_604808 = newJObject()
  if body != nil:
    body_604808 = body
  result = call_604807.call(nil, nil, nil, nil, body_604808)

var getStatistics* = Call_GetStatistics_604795(name: "getStatistics",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/statistics", validator: validate_GetStatistics_604796,
    base: "/", url: url_GetStatistics_604797, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetV2LoggingOptions_604821 = ref object of OpenApiRestCall_602466
proc url_SetV2LoggingOptions_604823(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_SetV2LoggingOptions_604822(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Sets the logging options for the V2 logging service.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604824 = header.getOrDefault("X-Amz-Date")
  valid_604824 = validateParameter(valid_604824, JString, required = false,
                                 default = nil)
  if valid_604824 != nil:
    section.add "X-Amz-Date", valid_604824
  var valid_604825 = header.getOrDefault("X-Amz-Security-Token")
  valid_604825 = validateParameter(valid_604825, JString, required = false,
                                 default = nil)
  if valid_604825 != nil:
    section.add "X-Amz-Security-Token", valid_604825
  var valid_604826 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604826 = validateParameter(valid_604826, JString, required = false,
                                 default = nil)
  if valid_604826 != nil:
    section.add "X-Amz-Content-Sha256", valid_604826
  var valid_604827 = header.getOrDefault("X-Amz-Algorithm")
  valid_604827 = validateParameter(valid_604827, JString, required = false,
                                 default = nil)
  if valid_604827 != nil:
    section.add "X-Amz-Algorithm", valid_604827
  var valid_604828 = header.getOrDefault("X-Amz-Signature")
  valid_604828 = validateParameter(valid_604828, JString, required = false,
                                 default = nil)
  if valid_604828 != nil:
    section.add "X-Amz-Signature", valid_604828
  var valid_604829 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604829 = validateParameter(valid_604829, JString, required = false,
                                 default = nil)
  if valid_604829 != nil:
    section.add "X-Amz-SignedHeaders", valid_604829
  var valid_604830 = header.getOrDefault("X-Amz-Credential")
  valid_604830 = validateParameter(valid_604830, JString, required = false,
                                 default = nil)
  if valid_604830 != nil:
    section.add "X-Amz-Credential", valid_604830
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604832: Call_SetV2LoggingOptions_604821; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the logging options for the V2 logging service.
  ## 
  let valid = call_604832.validator(path, query, header, formData, body)
  let scheme = call_604832.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604832.url(scheme.get, call_604832.host, call_604832.base,
                         call_604832.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604832, url, valid)

proc call*(call_604833: Call_SetV2LoggingOptions_604821; body: JsonNode): Recallable =
  ## setV2LoggingOptions
  ## Sets the logging options for the V2 logging service.
  ##   body: JObject (required)
  var body_604834 = newJObject()
  if body != nil:
    body_604834 = body
  result = call_604833.call(nil, nil, nil, nil, body_604834)

var setV2LoggingOptions* = Call_SetV2LoggingOptions_604821(
    name: "setV2LoggingOptions", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/v2LoggingOptions",
    validator: validate_SetV2LoggingOptions_604822, base: "/",
    url: url_SetV2LoggingOptions_604823, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetV2LoggingOptions_604809 = ref object of OpenApiRestCall_602466
proc url_GetV2LoggingOptions_604811(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetV2LoggingOptions_604810(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets the fine grained logging options.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604812 = header.getOrDefault("X-Amz-Date")
  valid_604812 = validateParameter(valid_604812, JString, required = false,
                                 default = nil)
  if valid_604812 != nil:
    section.add "X-Amz-Date", valid_604812
  var valid_604813 = header.getOrDefault("X-Amz-Security-Token")
  valid_604813 = validateParameter(valid_604813, JString, required = false,
                                 default = nil)
  if valid_604813 != nil:
    section.add "X-Amz-Security-Token", valid_604813
  var valid_604814 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604814 = validateParameter(valid_604814, JString, required = false,
                                 default = nil)
  if valid_604814 != nil:
    section.add "X-Amz-Content-Sha256", valid_604814
  var valid_604815 = header.getOrDefault("X-Amz-Algorithm")
  valid_604815 = validateParameter(valid_604815, JString, required = false,
                                 default = nil)
  if valid_604815 != nil:
    section.add "X-Amz-Algorithm", valid_604815
  var valid_604816 = header.getOrDefault("X-Amz-Signature")
  valid_604816 = validateParameter(valid_604816, JString, required = false,
                                 default = nil)
  if valid_604816 != nil:
    section.add "X-Amz-Signature", valid_604816
  var valid_604817 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604817 = validateParameter(valid_604817, JString, required = false,
                                 default = nil)
  if valid_604817 != nil:
    section.add "X-Amz-SignedHeaders", valid_604817
  var valid_604818 = header.getOrDefault("X-Amz-Credential")
  valid_604818 = validateParameter(valid_604818, JString, required = false,
                                 default = nil)
  if valid_604818 != nil:
    section.add "X-Amz-Credential", valid_604818
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604819: Call_GetV2LoggingOptions_604809; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the fine grained logging options.
  ## 
  let valid = call_604819.validator(path, query, header, formData, body)
  let scheme = call_604819.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604819.url(scheme.get, call_604819.host, call_604819.base,
                         call_604819.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604819, url, valid)

proc call*(call_604820: Call_GetV2LoggingOptions_604809): Recallable =
  ## getV2LoggingOptions
  ## Gets the fine grained logging options.
  result = call_604820.call(nil, nil, nil, nil, nil)

var getV2LoggingOptions* = Call_GetV2LoggingOptions_604809(
    name: "getV2LoggingOptions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/v2LoggingOptions",
    validator: validate_GetV2LoggingOptions_604810, base: "/",
    url: url_GetV2LoggingOptions_604811, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListActiveViolations_604835 = ref object of OpenApiRestCall_602466
proc url_ListActiveViolations_604837(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListActiveViolations_604836(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the active violations for a given Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingName: JString
  ##            : The name of the thing whose active violations are listed.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   securityProfileName: JString
  ##                      : The name of the Device Defender security profile for which violations are listed.
  section = newJObject()
  var valid_604838 = query.getOrDefault("thingName")
  valid_604838 = validateParameter(valid_604838, JString, required = false,
                                 default = nil)
  if valid_604838 != nil:
    section.add "thingName", valid_604838
  var valid_604839 = query.getOrDefault("maxResults")
  valid_604839 = validateParameter(valid_604839, JInt, required = false, default = nil)
  if valid_604839 != nil:
    section.add "maxResults", valid_604839
  var valid_604840 = query.getOrDefault("nextToken")
  valid_604840 = validateParameter(valid_604840, JString, required = false,
                                 default = nil)
  if valid_604840 != nil:
    section.add "nextToken", valid_604840
  var valid_604841 = query.getOrDefault("securityProfileName")
  valid_604841 = validateParameter(valid_604841, JString, required = false,
                                 default = nil)
  if valid_604841 != nil:
    section.add "securityProfileName", valid_604841
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604842 = header.getOrDefault("X-Amz-Date")
  valid_604842 = validateParameter(valid_604842, JString, required = false,
                                 default = nil)
  if valid_604842 != nil:
    section.add "X-Amz-Date", valid_604842
  var valid_604843 = header.getOrDefault("X-Amz-Security-Token")
  valid_604843 = validateParameter(valid_604843, JString, required = false,
                                 default = nil)
  if valid_604843 != nil:
    section.add "X-Amz-Security-Token", valid_604843
  var valid_604844 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604844 = validateParameter(valid_604844, JString, required = false,
                                 default = nil)
  if valid_604844 != nil:
    section.add "X-Amz-Content-Sha256", valid_604844
  var valid_604845 = header.getOrDefault("X-Amz-Algorithm")
  valid_604845 = validateParameter(valid_604845, JString, required = false,
                                 default = nil)
  if valid_604845 != nil:
    section.add "X-Amz-Algorithm", valid_604845
  var valid_604846 = header.getOrDefault("X-Amz-Signature")
  valid_604846 = validateParameter(valid_604846, JString, required = false,
                                 default = nil)
  if valid_604846 != nil:
    section.add "X-Amz-Signature", valid_604846
  var valid_604847 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604847 = validateParameter(valid_604847, JString, required = false,
                                 default = nil)
  if valid_604847 != nil:
    section.add "X-Amz-SignedHeaders", valid_604847
  var valid_604848 = header.getOrDefault("X-Amz-Credential")
  valid_604848 = validateParameter(valid_604848, JString, required = false,
                                 default = nil)
  if valid_604848 != nil:
    section.add "X-Amz-Credential", valid_604848
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604849: Call_ListActiveViolations_604835; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the active violations for a given Device Defender security profile.
  ## 
  let valid = call_604849.validator(path, query, header, formData, body)
  let scheme = call_604849.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604849.url(scheme.get, call_604849.host, call_604849.base,
                         call_604849.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604849, url, valid)

proc call*(call_604850: Call_ListActiveViolations_604835; thingName: string = "";
          maxResults: int = 0; nextToken: string = ""; securityProfileName: string = ""): Recallable =
  ## listActiveViolations
  ## Lists the active violations for a given Device Defender security profile.
  ##   thingName: string
  ##            : The name of the thing whose active violations are listed.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string
  ##                      : The name of the Device Defender security profile for which violations are listed.
  var query_604851 = newJObject()
  add(query_604851, "thingName", newJString(thingName))
  add(query_604851, "maxResults", newJInt(maxResults))
  add(query_604851, "nextToken", newJString(nextToken))
  add(query_604851, "securityProfileName", newJString(securityProfileName))
  result = call_604850.call(nil, query_604851, nil, nil, nil)

var listActiveViolations* = Call_ListActiveViolations_604835(
    name: "listActiveViolations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/active-violations",
    validator: validate_ListActiveViolations_604836, base: "/",
    url: url_ListActiveViolations_604837, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAttachedPolicies_604852 = ref object of OpenApiRestCall_602466
proc url_ListAttachedPolicies_604854(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "target" in path, "`target` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/attached-policies/"),
               (kind: VariableSegment, value: "target")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListAttachedPolicies_604853(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the policies attached to the specified thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   target: JString (required)
  ##         : The group or principal for which the policies will be listed.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `target` field"
  var valid_604855 = path.getOrDefault("target")
  valid_604855 = validateParameter(valid_604855, JString, required = true,
                                 default = nil)
  if valid_604855 != nil:
    section.add "target", valid_604855
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The token to retrieve the next set of results.
  ##   pageSize: JInt
  ##           : The maximum number of results to be returned per request.
  ##   recursive: JBool
  ##            : When true, recursively list attached policies.
  section = newJObject()
  var valid_604856 = query.getOrDefault("marker")
  valid_604856 = validateParameter(valid_604856, JString, required = false,
                                 default = nil)
  if valid_604856 != nil:
    section.add "marker", valid_604856
  var valid_604857 = query.getOrDefault("pageSize")
  valid_604857 = validateParameter(valid_604857, JInt, required = false, default = nil)
  if valid_604857 != nil:
    section.add "pageSize", valid_604857
  var valid_604858 = query.getOrDefault("recursive")
  valid_604858 = validateParameter(valid_604858, JBool, required = false, default = nil)
  if valid_604858 != nil:
    section.add "recursive", valid_604858
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604859 = header.getOrDefault("X-Amz-Date")
  valid_604859 = validateParameter(valid_604859, JString, required = false,
                                 default = nil)
  if valid_604859 != nil:
    section.add "X-Amz-Date", valid_604859
  var valid_604860 = header.getOrDefault("X-Amz-Security-Token")
  valid_604860 = validateParameter(valid_604860, JString, required = false,
                                 default = nil)
  if valid_604860 != nil:
    section.add "X-Amz-Security-Token", valid_604860
  var valid_604861 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604861 = validateParameter(valid_604861, JString, required = false,
                                 default = nil)
  if valid_604861 != nil:
    section.add "X-Amz-Content-Sha256", valid_604861
  var valid_604862 = header.getOrDefault("X-Amz-Algorithm")
  valid_604862 = validateParameter(valid_604862, JString, required = false,
                                 default = nil)
  if valid_604862 != nil:
    section.add "X-Amz-Algorithm", valid_604862
  var valid_604863 = header.getOrDefault("X-Amz-Signature")
  valid_604863 = validateParameter(valid_604863, JString, required = false,
                                 default = nil)
  if valid_604863 != nil:
    section.add "X-Amz-Signature", valid_604863
  var valid_604864 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604864 = validateParameter(valid_604864, JString, required = false,
                                 default = nil)
  if valid_604864 != nil:
    section.add "X-Amz-SignedHeaders", valid_604864
  var valid_604865 = header.getOrDefault("X-Amz-Credential")
  valid_604865 = validateParameter(valid_604865, JString, required = false,
                                 default = nil)
  if valid_604865 != nil:
    section.add "X-Amz-Credential", valid_604865
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604866: Call_ListAttachedPolicies_604852; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the policies attached to the specified thing group.
  ## 
  let valid = call_604866.validator(path, query, header, formData, body)
  let scheme = call_604866.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604866.url(scheme.get, call_604866.host, call_604866.base,
                         call_604866.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604866, url, valid)

proc call*(call_604867: Call_ListAttachedPolicies_604852; target: string;
          marker: string = ""; pageSize: int = 0; recursive: bool = false): Recallable =
  ## listAttachedPolicies
  ## Lists the policies attached to the specified thing group.
  ##   marker: string
  ##         : The token to retrieve the next set of results.
  ##   pageSize: int
  ##           : The maximum number of results to be returned per request.
  ##   recursive: bool
  ##            : When true, recursively list attached policies.
  ##   target: string (required)
  ##         : The group or principal for which the policies will be listed.
  var path_604868 = newJObject()
  var query_604869 = newJObject()
  add(query_604869, "marker", newJString(marker))
  add(query_604869, "pageSize", newJInt(pageSize))
  add(query_604869, "recursive", newJBool(recursive))
  add(path_604868, "target", newJString(target))
  result = call_604867.call(path_604868, query_604869, nil, nil, nil)

var listAttachedPolicies* = Call_ListAttachedPolicies_604852(
    name: "listAttachedPolicies", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/attached-policies/{target}",
    validator: validate_ListAttachedPolicies_604853, base: "/",
    url: url_ListAttachedPolicies_604854, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditFindings_604870 = ref object of OpenApiRestCall_602466
proc url_ListAuditFindings_604872(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListAuditFindings_604871(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604873 = header.getOrDefault("X-Amz-Date")
  valid_604873 = validateParameter(valid_604873, JString, required = false,
                                 default = nil)
  if valid_604873 != nil:
    section.add "X-Amz-Date", valid_604873
  var valid_604874 = header.getOrDefault("X-Amz-Security-Token")
  valid_604874 = validateParameter(valid_604874, JString, required = false,
                                 default = nil)
  if valid_604874 != nil:
    section.add "X-Amz-Security-Token", valid_604874
  var valid_604875 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604875 = validateParameter(valid_604875, JString, required = false,
                                 default = nil)
  if valid_604875 != nil:
    section.add "X-Amz-Content-Sha256", valid_604875
  var valid_604876 = header.getOrDefault("X-Amz-Algorithm")
  valid_604876 = validateParameter(valid_604876, JString, required = false,
                                 default = nil)
  if valid_604876 != nil:
    section.add "X-Amz-Algorithm", valid_604876
  var valid_604877 = header.getOrDefault("X-Amz-Signature")
  valid_604877 = validateParameter(valid_604877, JString, required = false,
                                 default = nil)
  if valid_604877 != nil:
    section.add "X-Amz-Signature", valid_604877
  var valid_604878 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604878 = validateParameter(valid_604878, JString, required = false,
                                 default = nil)
  if valid_604878 != nil:
    section.add "X-Amz-SignedHeaders", valid_604878
  var valid_604879 = header.getOrDefault("X-Amz-Credential")
  valid_604879 = validateParameter(valid_604879, JString, required = false,
                                 default = nil)
  if valid_604879 != nil:
    section.add "X-Amz-Credential", valid_604879
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_604881: Call_ListAuditFindings_604870; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ## 
  let valid = call_604881.validator(path, query, header, formData, body)
  let scheme = call_604881.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604881.url(scheme.get, call_604881.host, call_604881.base,
                         call_604881.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604881, url, valid)

proc call*(call_604882: Call_ListAuditFindings_604870; body: JsonNode): Recallable =
  ## listAuditFindings
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ##   body: JObject (required)
  var body_604883 = newJObject()
  if body != nil:
    body_604883 = body
  result = call_604882.call(nil, nil, nil, nil, body_604883)

var listAuditFindings* = Call_ListAuditFindings_604870(name: "listAuditFindings",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/audit/findings",
    validator: validate_ListAuditFindings_604871, base: "/",
    url: url_ListAuditFindings_604872, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditMitigationActionsExecutions_604884 = ref object of OpenApiRestCall_602466
proc url_ListAuditMitigationActionsExecutions_604886(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListAuditMitigationActionsExecutions_604885(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the status of audit mitigation action tasks that were executed.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   findingId: JString (required)
  ##            : Specify this filter to limit results to those that were applied to a specific audit finding.
  ##   taskId: JString (required)
  ##         : Specify this filter to limit results to actions for a specific audit mitigation actions task.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   actionStatus: JString
  ##               : Specify this filter to limit results to those with a specific status.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `findingId` field"
  var valid_604887 = query.getOrDefault("findingId")
  valid_604887 = validateParameter(valid_604887, JString, required = true,
                                 default = nil)
  if valid_604887 != nil:
    section.add "findingId", valid_604887
  var valid_604888 = query.getOrDefault("taskId")
  valid_604888 = validateParameter(valid_604888, JString, required = true,
                                 default = nil)
  if valid_604888 != nil:
    section.add "taskId", valid_604888
  var valid_604889 = query.getOrDefault("maxResults")
  valid_604889 = validateParameter(valid_604889, JInt, required = false, default = nil)
  if valid_604889 != nil:
    section.add "maxResults", valid_604889
  var valid_604890 = query.getOrDefault("nextToken")
  valid_604890 = validateParameter(valid_604890, JString, required = false,
                                 default = nil)
  if valid_604890 != nil:
    section.add "nextToken", valid_604890
  var valid_604891 = query.getOrDefault("actionStatus")
  valid_604891 = validateParameter(valid_604891, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_604891 != nil:
    section.add "actionStatus", valid_604891
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604892 = header.getOrDefault("X-Amz-Date")
  valid_604892 = validateParameter(valid_604892, JString, required = false,
                                 default = nil)
  if valid_604892 != nil:
    section.add "X-Amz-Date", valid_604892
  var valid_604893 = header.getOrDefault("X-Amz-Security-Token")
  valid_604893 = validateParameter(valid_604893, JString, required = false,
                                 default = nil)
  if valid_604893 != nil:
    section.add "X-Amz-Security-Token", valid_604893
  var valid_604894 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604894 = validateParameter(valid_604894, JString, required = false,
                                 default = nil)
  if valid_604894 != nil:
    section.add "X-Amz-Content-Sha256", valid_604894
  var valid_604895 = header.getOrDefault("X-Amz-Algorithm")
  valid_604895 = validateParameter(valid_604895, JString, required = false,
                                 default = nil)
  if valid_604895 != nil:
    section.add "X-Amz-Algorithm", valid_604895
  var valid_604896 = header.getOrDefault("X-Amz-Signature")
  valid_604896 = validateParameter(valid_604896, JString, required = false,
                                 default = nil)
  if valid_604896 != nil:
    section.add "X-Amz-Signature", valid_604896
  var valid_604897 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604897 = validateParameter(valid_604897, JString, required = false,
                                 default = nil)
  if valid_604897 != nil:
    section.add "X-Amz-SignedHeaders", valid_604897
  var valid_604898 = header.getOrDefault("X-Amz-Credential")
  valid_604898 = validateParameter(valid_604898, JString, required = false,
                                 default = nil)
  if valid_604898 != nil:
    section.add "X-Amz-Credential", valid_604898
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604899: Call_ListAuditMitigationActionsExecutions_604884;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the status of audit mitigation action tasks that were executed.
  ## 
  let valid = call_604899.validator(path, query, header, formData, body)
  let scheme = call_604899.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604899.url(scheme.get, call_604899.host, call_604899.base,
                         call_604899.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604899, url, valid)

proc call*(call_604900: Call_ListAuditMitigationActionsExecutions_604884;
          findingId: string; taskId: string; maxResults: int = 0;
          nextToken: string = ""; actionStatus: string = "IN_PROGRESS"): Recallable =
  ## listAuditMitigationActionsExecutions
  ## Gets the status of audit mitigation action tasks that were executed.
  ##   findingId: string (required)
  ##            : Specify this filter to limit results to those that were applied to a specific audit finding.
  ##   taskId: string (required)
  ##         : Specify this filter to limit results to actions for a specific audit mitigation actions task.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   actionStatus: string
  ##               : Specify this filter to limit results to those with a specific status.
  var query_604901 = newJObject()
  add(query_604901, "findingId", newJString(findingId))
  add(query_604901, "taskId", newJString(taskId))
  add(query_604901, "maxResults", newJInt(maxResults))
  add(query_604901, "nextToken", newJString(nextToken))
  add(query_604901, "actionStatus", newJString(actionStatus))
  result = call_604900.call(nil, query_604901, nil, nil, nil)

var listAuditMitigationActionsExecutions* = Call_ListAuditMitigationActionsExecutions_604884(
    name: "listAuditMitigationActionsExecutions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/executions#taskId&findingId",
    validator: validate_ListAuditMitigationActionsExecutions_604885, base: "/",
    url: url_ListAuditMitigationActionsExecutions_604886,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditMitigationActionsTasks_604902 = ref object of OpenApiRestCall_602466
proc url_ListAuditMitigationActionsTasks_604904(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListAuditMitigationActionsTasks_604903(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   findingId: JString
  ##            : Specify this filter to limit results to tasks that were applied to a specific audit finding.
  ##   taskStatus: JString
  ##             : Specify this filter to limit results to tasks that are in a specific state.
  ##   auditTaskId: JString
  ##              : Specify this filter to limit results to tasks that were applied to results for a specific audit.
  ##   endTime: JString (required)
  ##          : Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : Specify this filter to limit results to tasks that began on or after a specific date and time.
  section = newJObject()
  var valid_604905 = query.getOrDefault("findingId")
  valid_604905 = validateParameter(valid_604905, JString, required = false,
                                 default = nil)
  if valid_604905 != nil:
    section.add "findingId", valid_604905
  var valid_604906 = query.getOrDefault("taskStatus")
  valid_604906 = validateParameter(valid_604906, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_604906 != nil:
    section.add "taskStatus", valid_604906
  var valid_604907 = query.getOrDefault("auditTaskId")
  valid_604907 = validateParameter(valid_604907, JString, required = false,
                                 default = nil)
  if valid_604907 != nil:
    section.add "auditTaskId", valid_604907
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_604908 = query.getOrDefault("endTime")
  valid_604908 = validateParameter(valid_604908, JString, required = true,
                                 default = nil)
  if valid_604908 != nil:
    section.add "endTime", valid_604908
  var valid_604909 = query.getOrDefault("maxResults")
  valid_604909 = validateParameter(valid_604909, JInt, required = false, default = nil)
  if valid_604909 != nil:
    section.add "maxResults", valid_604909
  var valid_604910 = query.getOrDefault("nextToken")
  valid_604910 = validateParameter(valid_604910, JString, required = false,
                                 default = nil)
  if valid_604910 != nil:
    section.add "nextToken", valid_604910
  var valid_604911 = query.getOrDefault("startTime")
  valid_604911 = validateParameter(valid_604911, JString, required = true,
                                 default = nil)
  if valid_604911 != nil:
    section.add "startTime", valid_604911
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604912 = header.getOrDefault("X-Amz-Date")
  valid_604912 = validateParameter(valid_604912, JString, required = false,
                                 default = nil)
  if valid_604912 != nil:
    section.add "X-Amz-Date", valid_604912
  var valid_604913 = header.getOrDefault("X-Amz-Security-Token")
  valid_604913 = validateParameter(valid_604913, JString, required = false,
                                 default = nil)
  if valid_604913 != nil:
    section.add "X-Amz-Security-Token", valid_604913
  var valid_604914 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604914 = validateParameter(valid_604914, JString, required = false,
                                 default = nil)
  if valid_604914 != nil:
    section.add "X-Amz-Content-Sha256", valid_604914
  var valid_604915 = header.getOrDefault("X-Amz-Algorithm")
  valid_604915 = validateParameter(valid_604915, JString, required = false,
                                 default = nil)
  if valid_604915 != nil:
    section.add "X-Amz-Algorithm", valid_604915
  var valid_604916 = header.getOrDefault("X-Amz-Signature")
  valid_604916 = validateParameter(valid_604916, JString, required = false,
                                 default = nil)
  if valid_604916 != nil:
    section.add "X-Amz-Signature", valid_604916
  var valid_604917 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604917 = validateParameter(valid_604917, JString, required = false,
                                 default = nil)
  if valid_604917 != nil:
    section.add "X-Amz-SignedHeaders", valid_604917
  var valid_604918 = header.getOrDefault("X-Amz-Credential")
  valid_604918 = validateParameter(valid_604918, JString, required = false,
                                 default = nil)
  if valid_604918 != nil:
    section.add "X-Amz-Credential", valid_604918
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604919: Call_ListAuditMitigationActionsTasks_604902;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ## 
  let valid = call_604919.validator(path, query, header, formData, body)
  let scheme = call_604919.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604919.url(scheme.get, call_604919.host, call_604919.base,
                         call_604919.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604919, url, valid)

proc call*(call_604920: Call_ListAuditMitigationActionsTasks_604902;
          endTime: string; startTime: string; findingId: string = "";
          taskStatus: string = "IN_PROGRESS"; auditTaskId: string = "";
          maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listAuditMitigationActionsTasks
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ##   findingId: string
  ##            : Specify this filter to limit results to tasks that were applied to a specific audit finding.
  ##   taskStatus: string
  ##             : Specify this filter to limit results to tasks that are in a specific state.
  ##   auditTaskId: string
  ##              : Specify this filter to limit results to tasks that were applied to results for a specific audit.
  ##   endTime: string (required)
  ##          : Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : Specify this filter to limit results to tasks that began on or after a specific date and time.
  var query_604921 = newJObject()
  add(query_604921, "findingId", newJString(findingId))
  add(query_604921, "taskStatus", newJString(taskStatus))
  add(query_604921, "auditTaskId", newJString(auditTaskId))
  add(query_604921, "endTime", newJString(endTime))
  add(query_604921, "maxResults", newJInt(maxResults))
  add(query_604921, "nextToken", newJString(nextToken))
  add(query_604921, "startTime", newJString(startTime))
  result = call_604920.call(nil, query_604921, nil, nil, nil)

var listAuditMitigationActionsTasks* = Call_ListAuditMitigationActionsTasks_604902(
    name: "listAuditMitigationActionsTasks", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/tasks#startTime&endTime",
    validator: validate_ListAuditMitigationActionsTasks_604903, base: "/",
    url: url_ListAuditMitigationActionsTasks_604904,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditTasks_604922 = ref object of OpenApiRestCall_602466
proc url_ListAuditTasks_604924(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListAuditTasks_604923(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the Device Defender audits that have been performed during a given time period.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   taskType: JString
  ##           : A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
  ##   taskStatus: JString
  ##             : A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
  ##   endTime: JString (required)
  ##          : The end of the time period.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
  section = newJObject()
  var valid_604925 = query.getOrDefault("taskType")
  valid_604925 = validateParameter(valid_604925, JString, required = false,
                                 default = newJString("ON_DEMAND_AUDIT_TASK"))
  if valid_604925 != nil:
    section.add "taskType", valid_604925
  var valid_604926 = query.getOrDefault("taskStatus")
  valid_604926 = validateParameter(valid_604926, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_604926 != nil:
    section.add "taskStatus", valid_604926
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_604927 = query.getOrDefault("endTime")
  valid_604927 = validateParameter(valid_604927, JString, required = true,
                                 default = nil)
  if valid_604927 != nil:
    section.add "endTime", valid_604927
  var valid_604928 = query.getOrDefault("maxResults")
  valid_604928 = validateParameter(valid_604928, JInt, required = false, default = nil)
  if valid_604928 != nil:
    section.add "maxResults", valid_604928
  var valid_604929 = query.getOrDefault("nextToken")
  valid_604929 = validateParameter(valid_604929, JString, required = false,
                                 default = nil)
  if valid_604929 != nil:
    section.add "nextToken", valid_604929
  var valid_604930 = query.getOrDefault("startTime")
  valid_604930 = validateParameter(valid_604930, JString, required = true,
                                 default = nil)
  if valid_604930 != nil:
    section.add "startTime", valid_604930
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604931 = header.getOrDefault("X-Amz-Date")
  valid_604931 = validateParameter(valid_604931, JString, required = false,
                                 default = nil)
  if valid_604931 != nil:
    section.add "X-Amz-Date", valid_604931
  var valid_604932 = header.getOrDefault("X-Amz-Security-Token")
  valid_604932 = validateParameter(valid_604932, JString, required = false,
                                 default = nil)
  if valid_604932 != nil:
    section.add "X-Amz-Security-Token", valid_604932
  var valid_604933 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604933 = validateParameter(valid_604933, JString, required = false,
                                 default = nil)
  if valid_604933 != nil:
    section.add "X-Amz-Content-Sha256", valid_604933
  var valid_604934 = header.getOrDefault("X-Amz-Algorithm")
  valid_604934 = validateParameter(valid_604934, JString, required = false,
                                 default = nil)
  if valid_604934 != nil:
    section.add "X-Amz-Algorithm", valid_604934
  var valid_604935 = header.getOrDefault("X-Amz-Signature")
  valid_604935 = validateParameter(valid_604935, JString, required = false,
                                 default = nil)
  if valid_604935 != nil:
    section.add "X-Amz-Signature", valid_604935
  var valid_604936 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604936 = validateParameter(valid_604936, JString, required = false,
                                 default = nil)
  if valid_604936 != nil:
    section.add "X-Amz-SignedHeaders", valid_604936
  var valid_604937 = header.getOrDefault("X-Amz-Credential")
  valid_604937 = validateParameter(valid_604937, JString, required = false,
                                 default = nil)
  if valid_604937 != nil:
    section.add "X-Amz-Credential", valid_604937
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604938: Call_ListAuditTasks_604922; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender audits that have been performed during a given time period.
  ## 
  let valid = call_604938.validator(path, query, header, formData, body)
  let scheme = call_604938.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604938.url(scheme.get, call_604938.host, call_604938.base,
                         call_604938.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604938, url, valid)

proc call*(call_604939: Call_ListAuditTasks_604922; endTime: string;
          startTime: string; taskType: string = "ON_DEMAND_AUDIT_TASK";
          taskStatus: string = "IN_PROGRESS"; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listAuditTasks
  ## Lists the Device Defender audits that have been performed during a given time period.
  ##   taskType: string
  ##           : A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
  ##   taskStatus: string
  ##             : A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
  ##   endTime: string (required)
  ##          : The end of the time period.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
  var query_604940 = newJObject()
  add(query_604940, "taskType", newJString(taskType))
  add(query_604940, "taskStatus", newJString(taskStatus))
  add(query_604940, "endTime", newJString(endTime))
  add(query_604940, "maxResults", newJInt(maxResults))
  add(query_604940, "nextToken", newJString(nextToken))
  add(query_604940, "startTime", newJString(startTime))
  result = call_604939.call(nil, query_604940, nil, nil, nil)

var listAuditTasks* = Call_ListAuditTasks_604922(name: "listAuditTasks",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/audit/tasks#startTime&endTime", validator: validate_ListAuditTasks_604923,
    base: "/", url: url_ListAuditTasks_604924, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuthorizers_604941 = ref object of OpenApiRestCall_602466
proc url_ListAuthorizers_604943(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListAuthorizers_604942(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Lists the authorizers registered in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   status: JString
  ##         : The status of the list authorizers request.
  ##   isAscendingOrder: JBool
  ##                   : Return the list of authorizers in ascending alphabetical order.
  section = newJObject()
  var valid_604944 = query.getOrDefault("marker")
  valid_604944 = validateParameter(valid_604944, JString, required = false,
                                 default = nil)
  if valid_604944 != nil:
    section.add "marker", valid_604944
  var valid_604945 = query.getOrDefault("pageSize")
  valid_604945 = validateParameter(valid_604945, JInt, required = false, default = nil)
  if valid_604945 != nil:
    section.add "pageSize", valid_604945
  var valid_604946 = query.getOrDefault("status")
  valid_604946 = validateParameter(valid_604946, JString, required = false,
                                 default = newJString("ACTIVE"))
  if valid_604946 != nil:
    section.add "status", valid_604946
  var valid_604947 = query.getOrDefault("isAscendingOrder")
  valid_604947 = validateParameter(valid_604947, JBool, required = false, default = nil)
  if valid_604947 != nil:
    section.add "isAscendingOrder", valid_604947
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604948 = header.getOrDefault("X-Amz-Date")
  valid_604948 = validateParameter(valid_604948, JString, required = false,
                                 default = nil)
  if valid_604948 != nil:
    section.add "X-Amz-Date", valid_604948
  var valid_604949 = header.getOrDefault("X-Amz-Security-Token")
  valid_604949 = validateParameter(valid_604949, JString, required = false,
                                 default = nil)
  if valid_604949 != nil:
    section.add "X-Amz-Security-Token", valid_604949
  var valid_604950 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604950 = validateParameter(valid_604950, JString, required = false,
                                 default = nil)
  if valid_604950 != nil:
    section.add "X-Amz-Content-Sha256", valid_604950
  var valid_604951 = header.getOrDefault("X-Amz-Algorithm")
  valid_604951 = validateParameter(valid_604951, JString, required = false,
                                 default = nil)
  if valid_604951 != nil:
    section.add "X-Amz-Algorithm", valid_604951
  var valid_604952 = header.getOrDefault("X-Amz-Signature")
  valid_604952 = validateParameter(valid_604952, JString, required = false,
                                 default = nil)
  if valid_604952 != nil:
    section.add "X-Amz-Signature", valid_604952
  var valid_604953 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604953 = validateParameter(valid_604953, JString, required = false,
                                 default = nil)
  if valid_604953 != nil:
    section.add "X-Amz-SignedHeaders", valid_604953
  var valid_604954 = header.getOrDefault("X-Amz-Credential")
  valid_604954 = validateParameter(valid_604954, JString, required = false,
                                 default = nil)
  if valid_604954 != nil:
    section.add "X-Amz-Credential", valid_604954
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604955: Call_ListAuthorizers_604941; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the authorizers registered in your account.
  ## 
  let valid = call_604955.validator(path, query, header, formData, body)
  let scheme = call_604955.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604955.url(scheme.get, call_604955.host, call_604955.base,
                         call_604955.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604955, url, valid)

proc call*(call_604956: Call_ListAuthorizers_604941; marker: string = "";
          pageSize: int = 0; status: string = "ACTIVE"; isAscendingOrder: bool = false): Recallable =
  ## listAuthorizers
  ## Lists the authorizers registered in your account.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   status: string
  ##         : The status of the list authorizers request.
  ##   isAscendingOrder: bool
  ##                   : Return the list of authorizers in ascending alphabetical order.
  var query_604957 = newJObject()
  add(query_604957, "marker", newJString(marker))
  add(query_604957, "pageSize", newJInt(pageSize))
  add(query_604957, "status", newJString(status))
  add(query_604957, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_604956.call(nil, query_604957, nil, nil, nil)

var listAuthorizers* = Call_ListAuthorizers_604941(name: "listAuthorizers",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/authorizers/",
    validator: validate_ListAuthorizers_604942, base: "/", url: url_ListAuthorizers_604943,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListBillingGroups_604958 = ref object of OpenApiRestCall_602466
proc url_ListBillingGroups_604960(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListBillingGroups_604959(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Lists the billing groups you have created.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   namePrefixFilter: JString
  ##                   : Limit the results to billing groups whose names have the given prefix.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  var valid_604961 = query.getOrDefault("namePrefixFilter")
  valid_604961 = validateParameter(valid_604961, JString, required = false,
                                 default = nil)
  if valid_604961 != nil:
    section.add "namePrefixFilter", valid_604961
  var valid_604962 = query.getOrDefault("maxResults")
  valid_604962 = validateParameter(valid_604962, JInt, required = false, default = nil)
  if valid_604962 != nil:
    section.add "maxResults", valid_604962
  var valid_604963 = query.getOrDefault("nextToken")
  valid_604963 = validateParameter(valid_604963, JString, required = false,
                                 default = nil)
  if valid_604963 != nil:
    section.add "nextToken", valid_604963
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604964 = header.getOrDefault("X-Amz-Date")
  valid_604964 = validateParameter(valid_604964, JString, required = false,
                                 default = nil)
  if valid_604964 != nil:
    section.add "X-Amz-Date", valid_604964
  var valid_604965 = header.getOrDefault("X-Amz-Security-Token")
  valid_604965 = validateParameter(valid_604965, JString, required = false,
                                 default = nil)
  if valid_604965 != nil:
    section.add "X-Amz-Security-Token", valid_604965
  var valid_604966 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604966 = validateParameter(valid_604966, JString, required = false,
                                 default = nil)
  if valid_604966 != nil:
    section.add "X-Amz-Content-Sha256", valid_604966
  var valid_604967 = header.getOrDefault("X-Amz-Algorithm")
  valid_604967 = validateParameter(valid_604967, JString, required = false,
                                 default = nil)
  if valid_604967 != nil:
    section.add "X-Amz-Algorithm", valid_604967
  var valid_604968 = header.getOrDefault("X-Amz-Signature")
  valid_604968 = validateParameter(valid_604968, JString, required = false,
                                 default = nil)
  if valid_604968 != nil:
    section.add "X-Amz-Signature", valid_604968
  var valid_604969 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604969 = validateParameter(valid_604969, JString, required = false,
                                 default = nil)
  if valid_604969 != nil:
    section.add "X-Amz-SignedHeaders", valid_604969
  var valid_604970 = header.getOrDefault("X-Amz-Credential")
  valid_604970 = validateParameter(valid_604970, JString, required = false,
                                 default = nil)
  if valid_604970 != nil:
    section.add "X-Amz-Credential", valid_604970
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604971: Call_ListBillingGroups_604958; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the billing groups you have created.
  ## 
  let valid = call_604971.validator(path, query, header, formData, body)
  let scheme = call_604971.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604971.url(scheme.get, call_604971.host, call_604971.base,
                         call_604971.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604971, url, valid)

proc call*(call_604972: Call_ListBillingGroups_604958;
          namePrefixFilter: string = ""; maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listBillingGroups
  ## Lists the billing groups you have created.
  ##   namePrefixFilter: string
  ##                   : Limit the results to billing groups whose names have the given prefix.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var query_604973 = newJObject()
  add(query_604973, "namePrefixFilter", newJString(namePrefixFilter))
  add(query_604973, "maxResults", newJInt(maxResults))
  add(query_604973, "nextToken", newJString(nextToken))
  result = call_604972.call(nil, query_604973, nil, nil, nil)

var listBillingGroups* = Call_ListBillingGroups_604958(name: "listBillingGroups",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/billing-groups",
    validator: validate_ListBillingGroups_604959, base: "/",
    url: url_ListBillingGroups_604960, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCACertificates_604974 = ref object of OpenApiRestCall_602466
proc url_ListCACertificates_604976(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListCACertificates_604975(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Determines the order of the results.
  section = newJObject()
  var valid_604977 = query.getOrDefault("marker")
  valid_604977 = validateParameter(valid_604977, JString, required = false,
                                 default = nil)
  if valid_604977 != nil:
    section.add "marker", valid_604977
  var valid_604978 = query.getOrDefault("pageSize")
  valid_604978 = validateParameter(valid_604978, JInt, required = false, default = nil)
  if valid_604978 != nil:
    section.add "pageSize", valid_604978
  var valid_604979 = query.getOrDefault("isAscendingOrder")
  valid_604979 = validateParameter(valid_604979, JBool, required = false, default = nil)
  if valid_604979 != nil:
    section.add "isAscendingOrder", valid_604979
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604980 = header.getOrDefault("X-Amz-Date")
  valid_604980 = validateParameter(valid_604980, JString, required = false,
                                 default = nil)
  if valid_604980 != nil:
    section.add "X-Amz-Date", valid_604980
  var valid_604981 = header.getOrDefault("X-Amz-Security-Token")
  valid_604981 = validateParameter(valid_604981, JString, required = false,
                                 default = nil)
  if valid_604981 != nil:
    section.add "X-Amz-Security-Token", valid_604981
  var valid_604982 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604982 = validateParameter(valid_604982, JString, required = false,
                                 default = nil)
  if valid_604982 != nil:
    section.add "X-Amz-Content-Sha256", valid_604982
  var valid_604983 = header.getOrDefault("X-Amz-Algorithm")
  valid_604983 = validateParameter(valid_604983, JString, required = false,
                                 default = nil)
  if valid_604983 != nil:
    section.add "X-Amz-Algorithm", valid_604983
  var valid_604984 = header.getOrDefault("X-Amz-Signature")
  valid_604984 = validateParameter(valid_604984, JString, required = false,
                                 default = nil)
  if valid_604984 != nil:
    section.add "X-Amz-Signature", valid_604984
  var valid_604985 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604985 = validateParameter(valid_604985, JString, required = false,
                                 default = nil)
  if valid_604985 != nil:
    section.add "X-Amz-SignedHeaders", valid_604985
  var valid_604986 = header.getOrDefault("X-Amz-Credential")
  valid_604986 = validateParameter(valid_604986, JString, required = false,
                                 default = nil)
  if valid_604986 != nil:
    section.add "X-Amz-Credential", valid_604986
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604987: Call_ListCACertificates_604974; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  let valid = call_604987.validator(path, query, header, formData, body)
  let scheme = call_604987.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604987.url(scheme.get, call_604987.host, call_604987.base,
                         call_604987.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_604987, url, valid)

proc call*(call_604988: Call_ListCACertificates_604974; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listCACertificates
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Determines the order of the results.
  var query_604989 = newJObject()
  add(query_604989, "marker", newJString(marker))
  add(query_604989, "pageSize", newJInt(pageSize))
  add(query_604989, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_604988.call(nil, query_604989, nil, nil, nil)

var listCACertificates* = Call_ListCACertificates_604974(
    name: "listCACertificates", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/cacertificates", validator: validate_ListCACertificates_604975,
    base: "/", url: url_ListCACertificates_604976,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCertificatesByCA_604990 = ref object of OpenApiRestCall_602466
proc url_ListCertificatesByCA_604992(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates-by-ca/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListCertificatesByCA_604991(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List the device certificates signed by the specified CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_604993 = path.getOrDefault("caCertificateId")
  valid_604993 = validateParameter(valid_604993, JString, required = true,
                                 default = nil)
  if valid_604993 != nil:
    section.add "caCertificateId", valid_604993
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  section = newJObject()
  var valid_604994 = query.getOrDefault("marker")
  valid_604994 = validateParameter(valid_604994, JString, required = false,
                                 default = nil)
  if valid_604994 != nil:
    section.add "marker", valid_604994
  var valid_604995 = query.getOrDefault("pageSize")
  valid_604995 = validateParameter(valid_604995, JInt, required = false, default = nil)
  if valid_604995 != nil:
    section.add "pageSize", valid_604995
  var valid_604996 = query.getOrDefault("isAscendingOrder")
  valid_604996 = validateParameter(valid_604996, JBool, required = false, default = nil)
  if valid_604996 != nil:
    section.add "isAscendingOrder", valid_604996
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_604997 = header.getOrDefault("X-Amz-Date")
  valid_604997 = validateParameter(valid_604997, JString, required = false,
                                 default = nil)
  if valid_604997 != nil:
    section.add "X-Amz-Date", valid_604997
  var valid_604998 = header.getOrDefault("X-Amz-Security-Token")
  valid_604998 = validateParameter(valid_604998, JString, required = false,
                                 default = nil)
  if valid_604998 != nil:
    section.add "X-Amz-Security-Token", valid_604998
  var valid_604999 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604999 = validateParameter(valid_604999, JString, required = false,
                                 default = nil)
  if valid_604999 != nil:
    section.add "X-Amz-Content-Sha256", valid_604999
  var valid_605000 = header.getOrDefault("X-Amz-Algorithm")
  valid_605000 = validateParameter(valid_605000, JString, required = false,
                                 default = nil)
  if valid_605000 != nil:
    section.add "X-Amz-Algorithm", valid_605000
  var valid_605001 = header.getOrDefault("X-Amz-Signature")
  valid_605001 = validateParameter(valid_605001, JString, required = false,
                                 default = nil)
  if valid_605001 != nil:
    section.add "X-Amz-Signature", valid_605001
  var valid_605002 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605002 = validateParameter(valid_605002, JString, required = false,
                                 default = nil)
  if valid_605002 != nil:
    section.add "X-Amz-SignedHeaders", valid_605002
  var valid_605003 = header.getOrDefault("X-Amz-Credential")
  valid_605003 = validateParameter(valid_605003, JString, required = false,
                                 default = nil)
  if valid_605003 != nil:
    section.add "X-Amz-Credential", valid_605003
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605004: Call_ListCertificatesByCA_604990; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the device certificates signed by the specified CA certificate.
  ## 
  let valid = call_605004.validator(path, query, header, formData, body)
  let scheme = call_605004.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605004.url(scheme.get, call_605004.host, call_605004.base,
                         call_605004.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605004, url, valid)

proc call*(call_605005: Call_ListCertificatesByCA_604990; caCertificateId: string;
          marker: string = ""; pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listCertificatesByCA
  ## List the device certificates signed by the specified CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  var path_605006 = newJObject()
  var query_605007 = newJObject()
  add(path_605006, "caCertificateId", newJString(caCertificateId))
  add(query_605007, "marker", newJString(marker))
  add(query_605007, "pageSize", newJInt(pageSize))
  add(query_605007, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_605005.call(path_605006, query_605007, nil, nil, nil)

var listCertificatesByCA* = Call_ListCertificatesByCA_604990(
    name: "listCertificatesByCA", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates-by-ca/{caCertificateId}",
    validator: validate_ListCertificatesByCA_604991, base: "/",
    url: url_ListCertificatesByCA_604992, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListIndices_605008 = ref object of OpenApiRestCall_602466
proc url_ListIndices_605010(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListIndices_605009(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the search indices.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token used to get the next set of results, or null if there are no additional results.
  section = newJObject()
  var valid_605011 = query.getOrDefault("maxResults")
  valid_605011 = validateParameter(valid_605011, JInt, required = false, default = nil)
  if valid_605011 != nil:
    section.add "maxResults", valid_605011
  var valid_605012 = query.getOrDefault("nextToken")
  valid_605012 = validateParameter(valid_605012, JString, required = false,
                                 default = nil)
  if valid_605012 != nil:
    section.add "nextToken", valid_605012
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605013 = header.getOrDefault("X-Amz-Date")
  valid_605013 = validateParameter(valid_605013, JString, required = false,
                                 default = nil)
  if valid_605013 != nil:
    section.add "X-Amz-Date", valid_605013
  var valid_605014 = header.getOrDefault("X-Amz-Security-Token")
  valid_605014 = validateParameter(valid_605014, JString, required = false,
                                 default = nil)
  if valid_605014 != nil:
    section.add "X-Amz-Security-Token", valid_605014
  var valid_605015 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605015 = validateParameter(valid_605015, JString, required = false,
                                 default = nil)
  if valid_605015 != nil:
    section.add "X-Amz-Content-Sha256", valid_605015
  var valid_605016 = header.getOrDefault("X-Amz-Algorithm")
  valid_605016 = validateParameter(valid_605016, JString, required = false,
                                 default = nil)
  if valid_605016 != nil:
    section.add "X-Amz-Algorithm", valid_605016
  var valid_605017 = header.getOrDefault("X-Amz-Signature")
  valid_605017 = validateParameter(valid_605017, JString, required = false,
                                 default = nil)
  if valid_605017 != nil:
    section.add "X-Amz-Signature", valid_605017
  var valid_605018 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605018 = validateParameter(valid_605018, JString, required = false,
                                 default = nil)
  if valid_605018 != nil:
    section.add "X-Amz-SignedHeaders", valid_605018
  var valid_605019 = header.getOrDefault("X-Amz-Credential")
  valid_605019 = validateParameter(valid_605019, JString, required = false,
                                 default = nil)
  if valid_605019 != nil:
    section.add "X-Amz-Credential", valid_605019
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605020: Call_ListIndices_605008; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the search indices.
  ## 
  let valid = call_605020.validator(path, query, header, formData, body)
  let scheme = call_605020.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605020.url(scheme.get, call_605020.host, call_605020.base,
                         call_605020.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605020, url, valid)

proc call*(call_605021: Call_ListIndices_605008; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listIndices
  ## Lists the search indices.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token used to get the next set of results, or null if there are no additional results.
  var query_605022 = newJObject()
  add(query_605022, "maxResults", newJInt(maxResults))
  add(query_605022, "nextToken", newJString(nextToken))
  result = call_605021.call(nil, query_605022, nil, nil, nil)

var listIndices* = Call_ListIndices_605008(name: "listIndices",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/indices",
                                        validator: validate_ListIndices_605009,
                                        base: "/", url: url_ListIndices_605010,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobExecutionsForJob_605023 = ref object of OpenApiRestCall_602466
proc url_ListJobExecutionsForJob_605025(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListJobExecutionsForJob_605024(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the job executions for a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_605026 = path.getOrDefault("jobId")
  valid_605026 = validateParameter(valid_605026, JString, required = true,
                                 default = nil)
  if valid_605026 != nil:
    section.add "jobId", valid_605026
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to be returned per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : The status of the job.
  section = newJObject()
  var valid_605027 = query.getOrDefault("maxResults")
  valid_605027 = validateParameter(valid_605027, JInt, required = false, default = nil)
  if valid_605027 != nil:
    section.add "maxResults", valid_605027
  var valid_605028 = query.getOrDefault("nextToken")
  valid_605028 = validateParameter(valid_605028, JString, required = false,
                                 default = nil)
  if valid_605028 != nil:
    section.add "nextToken", valid_605028
  var valid_605029 = query.getOrDefault("status")
  valid_605029 = validateParameter(valid_605029, JString, required = false,
                                 default = newJString("QUEUED"))
  if valid_605029 != nil:
    section.add "status", valid_605029
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605030 = header.getOrDefault("X-Amz-Date")
  valid_605030 = validateParameter(valid_605030, JString, required = false,
                                 default = nil)
  if valid_605030 != nil:
    section.add "X-Amz-Date", valid_605030
  var valid_605031 = header.getOrDefault("X-Amz-Security-Token")
  valid_605031 = validateParameter(valid_605031, JString, required = false,
                                 default = nil)
  if valid_605031 != nil:
    section.add "X-Amz-Security-Token", valid_605031
  var valid_605032 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605032 = validateParameter(valid_605032, JString, required = false,
                                 default = nil)
  if valid_605032 != nil:
    section.add "X-Amz-Content-Sha256", valid_605032
  var valid_605033 = header.getOrDefault("X-Amz-Algorithm")
  valid_605033 = validateParameter(valid_605033, JString, required = false,
                                 default = nil)
  if valid_605033 != nil:
    section.add "X-Amz-Algorithm", valid_605033
  var valid_605034 = header.getOrDefault("X-Amz-Signature")
  valid_605034 = validateParameter(valid_605034, JString, required = false,
                                 default = nil)
  if valid_605034 != nil:
    section.add "X-Amz-Signature", valid_605034
  var valid_605035 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605035 = validateParameter(valid_605035, JString, required = false,
                                 default = nil)
  if valid_605035 != nil:
    section.add "X-Amz-SignedHeaders", valid_605035
  var valid_605036 = header.getOrDefault("X-Amz-Credential")
  valid_605036 = validateParameter(valid_605036, JString, required = false,
                                 default = nil)
  if valid_605036 != nil:
    section.add "X-Amz-Credential", valid_605036
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605037: Call_ListJobExecutionsForJob_605023; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the job executions for a job.
  ## 
  let valid = call_605037.validator(path, query, header, formData, body)
  let scheme = call_605037.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605037.url(scheme.get, call_605037.host, call_605037.base,
                         call_605037.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605037, url, valid)

proc call*(call_605038: Call_ListJobExecutionsForJob_605023; jobId: string;
          maxResults: int = 0; nextToken: string = ""; status: string = "QUEUED"): Recallable =
  ## listJobExecutionsForJob
  ## Lists the job executions for a job.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   maxResults: int
  ##             : The maximum number of results to be returned per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : The status of the job.
  var path_605039 = newJObject()
  var query_605040 = newJObject()
  add(path_605039, "jobId", newJString(jobId))
  add(query_605040, "maxResults", newJInt(maxResults))
  add(query_605040, "nextToken", newJString(nextToken))
  add(query_605040, "status", newJString(status))
  result = call_605038.call(path_605039, query_605040, nil, nil, nil)

var listJobExecutionsForJob* = Call_ListJobExecutionsForJob_605023(
    name: "listJobExecutionsForJob", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/jobs/{jobId}/things",
    validator: validate_ListJobExecutionsForJob_605024, base: "/",
    url: url_ListJobExecutionsForJob_605025, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobExecutionsForThing_605041 = ref object of OpenApiRestCall_602466
proc url_ListJobExecutionsForThing_605043(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListJobExecutionsForThing_605042(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the job executions for the specified thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The thing name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_605044 = path.getOrDefault("thingName")
  valid_605044 = validateParameter(valid_605044, JString, required = true,
                                 default = nil)
  if valid_605044 != nil:
    section.add "thingName", valid_605044
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to be returned per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : An optional filter that lets you search for jobs that have the specified status.
  section = newJObject()
  var valid_605045 = query.getOrDefault("maxResults")
  valid_605045 = validateParameter(valid_605045, JInt, required = false, default = nil)
  if valid_605045 != nil:
    section.add "maxResults", valid_605045
  var valid_605046 = query.getOrDefault("nextToken")
  valid_605046 = validateParameter(valid_605046, JString, required = false,
                                 default = nil)
  if valid_605046 != nil:
    section.add "nextToken", valid_605046
  var valid_605047 = query.getOrDefault("status")
  valid_605047 = validateParameter(valid_605047, JString, required = false,
                                 default = newJString("QUEUED"))
  if valid_605047 != nil:
    section.add "status", valid_605047
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605048 = header.getOrDefault("X-Amz-Date")
  valid_605048 = validateParameter(valid_605048, JString, required = false,
                                 default = nil)
  if valid_605048 != nil:
    section.add "X-Amz-Date", valid_605048
  var valid_605049 = header.getOrDefault("X-Amz-Security-Token")
  valid_605049 = validateParameter(valid_605049, JString, required = false,
                                 default = nil)
  if valid_605049 != nil:
    section.add "X-Amz-Security-Token", valid_605049
  var valid_605050 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605050 = validateParameter(valid_605050, JString, required = false,
                                 default = nil)
  if valid_605050 != nil:
    section.add "X-Amz-Content-Sha256", valid_605050
  var valid_605051 = header.getOrDefault("X-Amz-Algorithm")
  valid_605051 = validateParameter(valid_605051, JString, required = false,
                                 default = nil)
  if valid_605051 != nil:
    section.add "X-Amz-Algorithm", valid_605051
  var valid_605052 = header.getOrDefault("X-Amz-Signature")
  valid_605052 = validateParameter(valid_605052, JString, required = false,
                                 default = nil)
  if valid_605052 != nil:
    section.add "X-Amz-Signature", valid_605052
  var valid_605053 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605053 = validateParameter(valid_605053, JString, required = false,
                                 default = nil)
  if valid_605053 != nil:
    section.add "X-Amz-SignedHeaders", valid_605053
  var valid_605054 = header.getOrDefault("X-Amz-Credential")
  valid_605054 = validateParameter(valid_605054, JString, required = false,
                                 default = nil)
  if valid_605054 != nil:
    section.add "X-Amz-Credential", valid_605054
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605055: Call_ListJobExecutionsForThing_605041; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the job executions for the specified thing.
  ## 
  let valid = call_605055.validator(path, query, header, formData, body)
  let scheme = call_605055.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605055.url(scheme.get, call_605055.host, call_605055.base,
                         call_605055.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605055, url, valid)

proc call*(call_605056: Call_ListJobExecutionsForThing_605041; thingName: string;
          maxResults: int = 0; nextToken: string = ""; status: string = "QUEUED"): Recallable =
  ## listJobExecutionsForThing
  ## Lists the job executions for the specified thing.
  ##   thingName: string (required)
  ##            : The thing name.
  ##   maxResults: int
  ##             : The maximum number of results to be returned per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : An optional filter that lets you search for jobs that have the specified status.
  var path_605057 = newJObject()
  var query_605058 = newJObject()
  add(path_605057, "thingName", newJString(thingName))
  add(query_605058, "maxResults", newJInt(maxResults))
  add(query_605058, "nextToken", newJString(nextToken))
  add(query_605058, "status", newJString(status))
  result = call_605056.call(path_605057, query_605058, nil, nil, nil)

var listJobExecutionsForThing* = Call_ListJobExecutionsForThing_605041(
    name: "listJobExecutionsForThing", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs",
    validator: validate_ListJobExecutionsForThing_605042, base: "/",
    url: url_ListJobExecutionsForThing_605043,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobs_605059 = ref object of OpenApiRestCall_602466
proc url_ListJobs_605061(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListJobs_605060(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists jobs.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingGroupName: JString
  ##                 : A filter that limits the returned jobs to those for the specified group.
  ##   targetSelection: JString
  ##                  : Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. 
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   thingGroupId: JString
  ##               : A filter that limits the returned jobs to those for the specified group.
  section = newJObject()
  var valid_605062 = query.getOrDefault("thingGroupName")
  valid_605062 = validateParameter(valid_605062, JString, required = false,
                                 default = nil)
  if valid_605062 != nil:
    section.add "thingGroupName", valid_605062
  var valid_605063 = query.getOrDefault("targetSelection")
  valid_605063 = validateParameter(valid_605063, JString, required = false,
                                 default = newJString("CONTINUOUS"))
  if valid_605063 != nil:
    section.add "targetSelection", valid_605063
  var valid_605064 = query.getOrDefault("maxResults")
  valid_605064 = validateParameter(valid_605064, JInt, required = false, default = nil)
  if valid_605064 != nil:
    section.add "maxResults", valid_605064
  var valid_605065 = query.getOrDefault("nextToken")
  valid_605065 = validateParameter(valid_605065, JString, required = false,
                                 default = nil)
  if valid_605065 != nil:
    section.add "nextToken", valid_605065
  var valid_605066 = query.getOrDefault("status")
  valid_605066 = validateParameter(valid_605066, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_605066 != nil:
    section.add "status", valid_605066
  var valid_605067 = query.getOrDefault("thingGroupId")
  valid_605067 = validateParameter(valid_605067, JString, required = false,
                                 default = nil)
  if valid_605067 != nil:
    section.add "thingGroupId", valid_605067
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605068 = header.getOrDefault("X-Amz-Date")
  valid_605068 = validateParameter(valid_605068, JString, required = false,
                                 default = nil)
  if valid_605068 != nil:
    section.add "X-Amz-Date", valid_605068
  var valid_605069 = header.getOrDefault("X-Amz-Security-Token")
  valid_605069 = validateParameter(valid_605069, JString, required = false,
                                 default = nil)
  if valid_605069 != nil:
    section.add "X-Amz-Security-Token", valid_605069
  var valid_605070 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605070 = validateParameter(valid_605070, JString, required = false,
                                 default = nil)
  if valid_605070 != nil:
    section.add "X-Amz-Content-Sha256", valid_605070
  var valid_605071 = header.getOrDefault("X-Amz-Algorithm")
  valid_605071 = validateParameter(valid_605071, JString, required = false,
                                 default = nil)
  if valid_605071 != nil:
    section.add "X-Amz-Algorithm", valid_605071
  var valid_605072 = header.getOrDefault("X-Amz-Signature")
  valid_605072 = validateParameter(valid_605072, JString, required = false,
                                 default = nil)
  if valid_605072 != nil:
    section.add "X-Amz-Signature", valid_605072
  var valid_605073 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605073 = validateParameter(valid_605073, JString, required = false,
                                 default = nil)
  if valid_605073 != nil:
    section.add "X-Amz-SignedHeaders", valid_605073
  var valid_605074 = header.getOrDefault("X-Amz-Credential")
  valid_605074 = validateParameter(valid_605074, JString, required = false,
                                 default = nil)
  if valid_605074 != nil:
    section.add "X-Amz-Credential", valid_605074
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605075: Call_ListJobs_605059; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists jobs.
  ## 
  let valid = call_605075.validator(path, query, header, formData, body)
  let scheme = call_605075.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605075.url(scheme.get, call_605075.host, call_605075.base,
                         call_605075.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605075, url, valid)

proc call*(call_605076: Call_ListJobs_605059; thingGroupName: string = "";
          targetSelection: string = "CONTINUOUS"; maxResults: int = 0;
          nextToken: string = ""; status: string = "IN_PROGRESS";
          thingGroupId: string = ""): Recallable =
  ## listJobs
  ## Lists jobs.
  ##   thingGroupName: string
  ##                 : A filter that limits the returned jobs to those for the specified group.
  ##   targetSelection: string
  ##                  : Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. 
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   thingGroupId: string
  ##               : A filter that limits the returned jobs to those for the specified group.
  var query_605077 = newJObject()
  add(query_605077, "thingGroupName", newJString(thingGroupName))
  add(query_605077, "targetSelection", newJString(targetSelection))
  add(query_605077, "maxResults", newJInt(maxResults))
  add(query_605077, "nextToken", newJString(nextToken))
  add(query_605077, "status", newJString(status))
  add(query_605077, "thingGroupId", newJString(thingGroupId))
  result = call_605076.call(nil, query_605077, nil, nil, nil)

var listJobs* = Call_ListJobs_605059(name: "listJobs", meth: HttpMethod.HttpGet,
                                  host: "iot.amazonaws.com", route: "/jobs",
                                  validator: validate_ListJobs_605060, base: "/",
                                  url: url_ListJobs_605061,
                                  schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListMitigationActions_605078 = ref object of OpenApiRestCall_602466
proc url_ListMitigationActions_605080(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListMitigationActions_605079(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   actionType: JString
  ##             : Specify a value to limit the result to mitigation actions with a specific action type.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  section = newJObject()
  var valid_605081 = query.getOrDefault("actionType")
  valid_605081 = validateParameter(valid_605081, JString, required = false, default = newJString(
      "UPDATE_DEVICE_CERTIFICATE"))
  if valid_605081 != nil:
    section.add "actionType", valid_605081
  var valid_605082 = query.getOrDefault("maxResults")
  valid_605082 = validateParameter(valid_605082, JInt, required = false, default = nil)
  if valid_605082 != nil:
    section.add "maxResults", valid_605082
  var valid_605083 = query.getOrDefault("nextToken")
  valid_605083 = validateParameter(valid_605083, JString, required = false,
                                 default = nil)
  if valid_605083 != nil:
    section.add "nextToken", valid_605083
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605084 = header.getOrDefault("X-Amz-Date")
  valid_605084 = validateParameter(valid_605084, JString, required = false,
                                 default = nil)
  if valid_605084 != nil:
    section.add "X-Amz-Date", valid_605084
  var valid_605085 = header.getOrDefault("X-Amz-Security-Token")
  valid_605085 = validateParameter(valid_605085, JString, required = false,
                                 default = nil)
  if valid_605085 != nil:
    section.add "X-Amz-Security-Token", valid_605085
  var valid_605086 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605086 = validateParameter(valid_605086, JString, required = false,
                                 default = nil)
  if valid_605086 != nil:
    section.add "X-Amz-Content-Sha256", valid_605086
  var valid_605087 = header.getOrDefault("X-Amz-Algorithm")
  valid_605087 = validateParameter(valid_605087, JString, required = false,
                                 default = nil)
  if valid_605087 != nil:
    section.add "X-Amz-Algorithm", valid_605087
  var valid_605088 = header.getOrDefault("X-Amz-Signature")
  valid_605088 = validateParameter(valid_605088, JString, required = false,
                                 default = nil)
  if valid_605088 != nil:
    section.add "X-Amz-Signature", valid_605088
  var valid_605089 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605089 = validateParameter(valid_605089, JString, required = false,
                                 default = nil)
  if valid_605089 != nil:
    section.add "X-Amz-SignedHeaders", valid_605089
  var valid_605090 = header.getOrDefault("X-Amz-Credential")
  valid_605090 = validateParameter(valid_605090, JString, required = false,
                                 default = nil)
  if valid_605090 != nil:
    section.add "X-Amz-Credential", valid_605090
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605091: Call_ListMitigationActions_605078; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ## 
  let valid = call_605091.validator(path, query, header, formData, body)
  let scheme = call_605091.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605091.url(scheme.get, call_605091.host, call_605091.base,
                         call_605091.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605091, url, valid)

proc call*(call_605092: Call_ListMitigationActions_605078;
          actionType: string = "UPDATE_DEVICE_CERTIFICATE"; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listMitigationActions
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ##   actionType: string
  ##             : Specify a value to limit the result to mitigation actions with a specific action type.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: string
  ##            : The token for the next set of results.
  var query_605093 = newJObject()
  add(query_605093, "actionType", newJString(actionType))
  add(query_605093, "maxResults", newJInt(maxResults))
  add(query_605093, "nextToken", newJString(nextToken))
  result = call_605092.call(nil, query_605093, nil, nil, nil)

var listMitigationActions* = Call_ListMitigationActions_605078(
    name: "listMitigationActions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions",
    validator: validate_ListMitigationActions_605079, base: "/",
    url: url_ListMitigationActions_605080, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListOTAUpdates_605094 = ref object of OpenApiRestCall_602466
proc url_ListOTAUpdates_605096(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListOTAUpdates_605095(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists OTA updates.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   otaUpdateStatus: JString
  ##                  : The OTA update job status.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : A token used to retrieve the next set of results.
  section = newJObject()
  var valid_605097 = query.getOrDefault("otaUpdateStatus")
  valid_605097 = validateParameter(valid_605097, JString, required = false,
                                 default = newJString("CREATE_PENDING"))
  if valid_605097 != nil:
    section.add "otaUpdateStatus", valid_605097
  var valid_605098 = query.getOrDefault("maxResults")
  valid_605098 = validateParameter(valid_605098, JInt, required = false, default = nil)
  if valid_605098 != nil:
    section.add "maxResults", valid_605098
  var valid_605099 = query.getOrDefault("nextToken")
  valid_605099 = validateParameter(valid_605099, JString, required = false,
                                 default = nil)
  if valid_605099 != nil:
    section.add "nextToken", valid_605099
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605100 = header.getOrDefault("X-Amz-Date")
  valid_605100 = validateParameter(valid_605100, JString, required = false,
                                 default = nil)
  if valid_605100 != nil:
    section.add "X-Amz-Date", valid_605100
  var valid_605101 = header.getOrDefault("X-Amz-Security-Token")
  valid_605101 = validateParameter(valid_605101, JString, required = false,
                                 default = nil)
  if valid_605101 != nil:
    section.add "X-Amz-Security-Token", valid_605101
  var valid_605102 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605102 = validateParameter(valid_605102, JString, required = false,
                                 default = nil)
  if valid_605102 != nil:
    section.add "X-Amz-Content-Sha256", valid_605102
  var valid_605103 = header.getOrDefault("X-Amz-Algorithm")
  valid_605103 = validateParameter(valid_605103, JString, required = false,
                                 default = nil)
  if valid_605103 != nil:
    section.add "X-Amz-Algorithm", valid_605103
  var valid_605104 = header.getOrDefault("X-Amz-Signature")
  valid_605104 = validateParameter(valid_605104, JString, required = false,
                                 default = nil)
  if valid_605104 != nil:
    section.add "X-Amz-Signature", valid_605104
  var valid_605105 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605105 = validateParameter(valid_605105, JString, required = false,
                                 default = nil)
  if valid_605105 != nil:
    section.add "X-Amz-SignedHeaders", valid_605105
  var valid_605106 = header.getOrDefault("X-Amz-Credential")
  valid_605106 = validateParameter(valid_605106, JString, required = false,
                                 default = nil)
  if valid_605106 != nil:
    section.add "X-Amz-Credential", valid_605106
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605107: Call_ListOTAUpdates_605094; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists OTA updates.
  ## 
  let valid = call_605107.validator(path, query, header, formData, body)
  let scheme = call_605107.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605107.url(scheme.get, call_605107.host, call_605107.base,
                         call_605107.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605107, url, valid)

proc call*(call_605108: Call_ListOTAUpdates_605094;
          otaUpdateStatus: string = "CREATE_PENDING"; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listOTAUpdates
  ## Lists OTA updates.
  ##   otaUpdateStatus: string
  ##                  : The OTA update job status.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : A token used to retrieve the next set of results.
  var query_605109 = newJObject()
  add(query_605109, "otaUpdateStatus", newJString(otaUpdateStatus))
  add(query_605109, "maxResults", newJInt(maxResults))
  add(query_605109, "nextToken", newJString(nextToken))
  result = call_605108.call(nil, query_605109, nil, nil, nil)

var listOTAUpdates* = Call_ListOTAUpdates_605094(name: "listOTAUpdates",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/otaUpdates",
    validator: validate_ListOTAUpdates_605095, base: "/", url: url_ListOTAUpdates_605096,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListOutgoingCertificates_605110 = ref object of OpenApiRestCall_602466
proc url_ListOutgoingCertificates_605112(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListOutgoingCertificates_605111(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists certificates that are being transferred but not yet accepted.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  section = newJObject()
  var valid_605113 = query.getOrDefault("marker")
  valid_605113 = validateParameter(valid_605113, JString, required = false,
                                 default = nil)
  if valid_605113 != nil:
    section.add "marker", valid_605113
  var valid_605114 = query.getOrDefault("pageSize")
  valid_605114 = validateParameter(valid_605114, JInt, required = false, default = nil)
  if valid_605114 != nil:
    section.add "pageSize", valid_605114
  var valid_605115 = query.getOrDefault("isAscendingOrder")
  valid_605115 = validateParameter(valid_605115, JBool, required = false, default = nil)
  if valid_605115 != nil:
    section.add "isAscendingOrder", valid_605115
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605116 = header.getOrDefault("X-Amz-Date")
  valid_605116 = validateParameter(valid_605116, JString, required = false,
                                 default = nil)
  if valid_605116 != nil:
    section.add "X-Amz-Date", valid_605116
  var valid_605117 = header.getOrDefault("X-Amz-Security-Token")
  valid_605117 = validateParameter(valid_605117, JString, required = false,
                                 default = nil)
  if valid_605117 != nil:
    section.add "X-Amz-Security-Token", valid_605117
  var valid_605118 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605118 = validateParameter(valid_605118, JString, required = false,
                                 default = nil)
  if valid_605118 != nil:
    section.add "X-Amz-Content-Sha256", valid_605118
  var valid_605119 = header.getOrDefault("X-Amz-Algorithm")
  valid_605119 = validateParameter(valid_605119, JString, required = false,
                                 default = nil)
  if valid_605119 != nil:
    section.add "X-Amz-Algorithm", valid_605119
  var valid_605120 = header.getOrDefault("X-Amz-Signature")
  valid_605120 = validateParameter(valid_605120, JString, required = false,
                                 default = nil)
  if valid_605120 != nil:
    section.add "X-Amz-Signature", valid_605120
  var valid_605121 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605121 = validateParameter(valid_605121, JString, required = false,
                                 default = nil)
  if valid_605121 != nil:
    section.add "X-Amz-SignedHeaders", valid_605121
  var valid_605122 = header.getOrDefault("X-Amz-Credential")
  valid_605122 = validateParameter(valid_605122, JString, required = false,
                                 default = nil)
  if valid_605122 != nil:
    section.add "X-Amz-Credential", valid_605122
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605123: Call_ListOutgoingCertificates_605110; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists certificates that are being transferred but not yet accepted.
  ## 
  let valid = call_605123.validator(path, query, header, formData, body)
  let scheme = call_605123.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605123.url(scheme.get, call_605123.host, call_605123.base,
                         call_605123.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605123, url, valid)

proc call*(call_605124: Call_ListOutgoingCertificates_605110; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listOutgoingCertificates
  ## Lists certificates that are being transferred but not yet accepted.
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  var query_605125 = newJObject()
  add(query_605125, "marker", newJString(marker))
  add(query_605125, "pageSize", newJInt(pageSize))
  add(query_605125, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_605124.call(nil, query_605125, nil, nil, nil)

var listOutgoingCertificates* = Call_ListOutgoingCertificates_605110(
    name: "listOutgoingCertificates", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates-out-going",
    validator: validate_ListOutgoingCertificates_605111, base: "/",
    url: url_ListOutgoingCertificates_605112, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicies_605126 = ref object of OpenApiRestCall_602466
proc url_ListPolicies_605128(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListPolicies_605127(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists your policies.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  section = newJObject()
  var valid_605129 = query.getOrDefault("marker")
  valid_605129 = validateParameter(valid_605129, JString, required = false,
                                 default = nil)
  if valid_605129 != nil:
    section.add "marker", valid_605129
  var valid_605130 = query.getOrDefault("pageSize")
  valid_605130 = validateParameter(valid_605130, JInt, required = false, default = nil)
  if valid_605130 != nil:
    section.add "pageSize", valid_605130
  var valid_605131 = query.getOrDefault("isAscendingOrder")
  valid_605131 = validateParameter(valid_605131, JBool, required = false, default = nil)
  if valid_605131 != nil:
    section.add "isAscendingOrder", valid_605131
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605132 = header.getOrDefault("X-Amz-Date")
  valid_605132 = validateParameter(valid_605132, JString, required = false,
                                 default = nil)
  if valid_605132 != nil:
    section.add "X-Amz-Date", valid_605132
  var valid_605133 = header.getOrDefault("X-Amz-Security-Token")
  valid_605133 = validateParameter(valid_605133, JString, required = false,
                                 default = nil)
  if valid_605133 != nil:
    section.add "X-Amz-Security-Token", valid_605133
  var valid_605134 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605134 = validateParameter(valid_605134, JString, required = false,
                                 default = nil)
  if valid_605134 != nil:
    section.add "X-Amz-Content-Sha256", valid_605134
  var valid_605135 = header.getOrDefault("X-Amz-Algorithm")
  valid_605135 = validateParameter(valid_605135, JString, required = false,
                                 default = nil)
  if valid_605135 != nil:
    section.add "X-Amz-Algorithm", valid_605135
  var valid_605136 = header.getOrDefault("X-Amz-Signature")
  valid_605136 = validateParameter(valid_605136, JString, required = false,
                                 default = nil)
  if valid_605136 != nil:
    section.add "X-Amz-Signature", valid_605136
  var valid_605137 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605137 = validateParameter(valid_605137, JString, required = false,
                                 default = nil)
  if valid_605137 != nil:
    section.add "X-Amz-SignedHeaders", valid_605137
  var valid_605138 = header.getOrDefault("X-Amz-Credential")
  valid_605138 = validateParameter(valid_605138, JString, required = false,
                                 default = nil)
  if valid_605138 != nil:
    section.add "X-Amz-Credential", valid_605138
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605139: Call_ListPolicies_605126; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists your policies.
  ## 
  let valid = call_605139.validator(path, query, header, formData, body)
  let scheme = call_605139.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605139.url(scheme.get, call_605139.host, call_605139.base,
                         call_605139.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605139, url, valid)

proc call*(call_605140: Call_ListPolicies_605126; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listPolicies
  ## Lists your policies.
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  var query_605141 = newJObject()
  add(query_605141, "marker", newJString(marker))
  add(query_605141, "pageSize", newJInt(pageSize))
  add(query_605141, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_605140.call(nil, query_605141, nil, nil, nil)

var listPolicies* = Call_ListPolicies_605126(name: "listPolicies",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/policies",
    validator: validate_ListPolicies_605127, base: "/", url: url_ListPolicies_605128,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicyPrincipals_605142 = ref object of OpenApiRestCall_602466
proc url_ListPolicyPrincipals_605144(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListPolicyPrincipals_605143(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  section = newJObject()
  var valid_605145 = query.getOrDefault("marker")
  valid_605145 = validateParameter(valid_605145, JString, required = false,
                                 default = nil)
  if valid_605145 != nil:
    section.add "marker", valid_605145
  var valid_605146 = query.getOrDefault("pageSize")
  valid_605146 = validateParameter(valid_605146, JInt, required = false, default = nil)
  if valid_605146 != nil:
    section.add "pageSize", valid_605146
  var valid_605147 = query.getOrDefault("isAscendingOrder")
  valid_605147 = validateParameter(valid_605147, JBool, required = false, default = nil)
  if valid_605147 != nil:
    section.add "isAscendingOrder", valid_605147
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   x-amzn-iot-policy: JString (required)
  ##                    : The policy name.
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605148 = header.getOrDefault("X-Amz-Date")
  valid_605148 = validateParameter(valid_605148, JString, required = false,
                                 default = nil)
  if valid_605148 != nil:
    section.add "X-Amz-Date", valid_605148
  var valid_605149 = header.getOrDefault("X-Amz-Security-Token")
  valid_605149 = validateParameter(valid_605149, JString, required = false,
                                 default = nil)
  if valid_605149 != nil:
    section.add "X-Amz-Security-Token", valid_605149
  var valid_605150 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605150 = validateParameter(valid_605150, JString, required = false,
                                 default = nil)
  if valid_605150 != nil:
    section.add "X-Amz-Content-Sha256", valid_605150
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-policy` field"
  var valid_605151 = header.getOrDefault("x-amzn-iot-policy")
  valid_605151 = validateParameter(valid_605151, JString, required = true,
                                 default = nil)
  if valid_605151 != nil:
    section.add "x-amzn-iot-policy", valid_605151
  var valid_605152 = header.getOrDefault("X-Amz-Algorithm")
  valid_605152 = validateParameter(valid_605152, JString, required = false,
                                 default = nil)
  if valid_605152 != nil:
    section.add "X-Amz-Algorithm", valid_605152
  var valid_605153 = header.getOrDefault("X-Amz-Signature")
  valid_605153 = validateParameter(valid_605153, JString, required = false,
                                 default = nil)
  if valid_605153 != nil:
    section.add "X-Amz-Signature", valid_605153
  var valid_605154 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605154 = validateParameter(valid_605154, JString, required = false,
                                 default = nil)
  if valid_605154 != nil:
    section.add "X-Amz-SignedHeaders", valid_605154
  var valid_605155 = header.getOrDefault("X-Amz-Credential")
  valid_605155 = validateParameter(valid_605155, JString, required = false,
                                 default = nil)
  if valid_605155 != nil:
    section.add "X-Amz-Credential", valid_605155
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605156: Call_ListPolicyPrincipals_605142; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ## 
  let valid = call_605156.validator(path, query, header, formData, body)
  let scheme = call_605156.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605156.url(scheme.get, call_605156.host, call_605156.base,
                         call_605156.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605156, url, valid)

proc call*(call_605157: Call_ListPolicyPrincipals_605142; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listPolicyPrincipals
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  var query_605158 = newJObject()
  add(query_605158, "marker", newJString(marker))
  add(query_605158, "pageSize", newJInt(pageSize))
  add(query_605158, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_605157.call(nil, query_605158, nil, nil, nil)

var listPolicyPrincipals* = Call_ListPolicyPrincipals_605142(
    name: "listPolicyPrincipals", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/policy-principals#x-amzn-iot-policy",
    validator: validate_ListPolicyPrincipals_605143, base: "/",
    url: url_ListPolicyPrincipals_605144, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPrincipalPolicies_605159 = ref object of OpenApiRestCall_602466
proc url_ListPrincipalPolicies_605161(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListPrincipalPolicies_605160(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : The marker for the next set of results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, results are returned in ascending creation order.
  section = newJObject()
  var valid_605162 = query.getOrDefault("marker")
  valid_605162 = validateParameter(valid_605162, JString, required = false,
                                 default = nil)
  if valid_605162 != nil:
    section.add "marker", valid_605162
  var valid_605163 = query.getOrDefault("pageSize")
  valid_605163 = validateParameter(valid_605163, JInt, required = false, default = nil)
  if valid_605163 != nil:
    section.add "pageSize", valid_605163
  var valid_605164 = query.getOrDefault("isAscendingOrder")
  valid_605164 = validateParameter(valid_605164, JBool, required = false, default = nil)
  if valid_605164 != nil:
    section.add "isAscendingOrder", valid_605164
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : The principal.
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605165 = header.getOrDefault("X-Amz-Date")
  valid_605165 = validateParameter(valid_605165, JString, required = false,
                                 default = nil)
  if valid_605165 != nil:
    section.add "X-Amz-Date", valid_605165
  var valid_605166 = header.getOrDefault("X-Amz-Security-Token")
  valid_605166 = validateParameter(valid_605166, JString, required = false,
                                 default = nil)
  if valid_605166 != nil:
    section.add "X-Amz-Security-Token", valid_605166
  var valid_605167 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605167 = validateParameter(valid_605167, JString, required = false,
                                 default = nil)
  if valid_605167 != nil:
    section.add "X-Amz-Content-Sha256", valid_605167
  var valid_605168 = header.getOrDefault("X-Amz-Algorithm")
  valid_605168 = validateParameter(valid_605168, JString, required = false,
                                 default = nil)
  if valid_605168 != nil:
    section.add "X-Amz-Algorithm", valid_605168
  var valid_605169 = header.getOrDefault("X-Amz-Signature")
  valid_605169 = validateParameter(valid_605169, JString, required = false,
                                 default = nil)
  if valid_605169 != nil:
    section.add "X-Amz-Signature", valid_605169
  var valid_605170 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605170 = validateParameter(valid_605170, JString, required = false,
                                 default = nil)
  if valid_605170 != nil:
    section.add "X-Amz-SignedHeaders", valid_605170
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_605171 = header.getOrDefault("x-amzn-iot-principal")
  valid_605171 = validateParameter(valid_605171, JString, required = true,
                                 default = nil)
  if valid_605171 != nil:
    section.add "x-amzn-iot-principal", valid_605171
  var valid_605172 = header.getOrDefault("X-Amz-Credential")
  valid_605172 = validateParameter(valid_605172, JString, required = false,
                                 default = nil)
  if valid_605172 != nil:
    section.add "X-Amz-Credential", valid_605172
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605173: Call_ListPrincipalPolicies_605159; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ## 
  let valid = call_605173.validator(path, query, header, formData, body)
  let scheme = call_605173.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605173.url(scheme.get, call_605173.host, call_605173.base,
                         call_605173.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605173, url, valid)

proc call*(call_605174: Call_ListPrincipalPolicies_605159; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listPrincipalPolicies
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ##   marker: string
  ##         : The marker for the next set of results.
  ##   pageSize: int
  ##           : The result page size.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, results are returned in ascending creation order.
  var query_605175 = newJObject()
  add(query_605175, "marker", newJString(marker))
  add(query_605175, "pageSize", newJInt(pageSize))
  add(query_605175, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_605174.call(nil, query_605175, nil, nil, nil)

var listPrincipalPolicies* = Call_ListPrincipalPolicies_605159(
    name: "listPrincipalPolicies", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/principal-policies#x-amzn-iot-principal",
    validator: validate_ListPrincipalPolicies_605160, base: "/",
    url: url_ListPrincipalPolicies_605161, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPrincipalThings_605176 = ref object of OpenApiRestCall_602466
proc url_ListPrincipalThings_605178(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListPrincipalThings_605177(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  var valid_605179 = query.getOrDefault("maxResults")
  valid_605179 = validateParameter(valid_605179, JInt, required = false, default = nil)
  if valid_605179 != nil:
    section.add "maxResults", valid_605179
  var valid_605180 = query.getOrDefault("nextToken")
  valid_605180 = validateParameter(valid_605180, JString, required = false,
                                 default = nil)
  if valid_605180 != nil:
    section.add "nextToken", valid_605180
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : The principal.
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605181 = header.getOrDefault("X-Amz-Date")
  valid_605181 = validateParameter(valid_605181, JString, required = false,
                                 default = nil)
  if valid_605181 != nil:
    section.add "X-Amz-Date", valid_605181
  var valid_605182 = header.getOrDefault("X-Amz-Security-Token")
  valid_605182 = validateParameter(valid_605182, JString, required = false,
                                 default = nil)
  if valid_605182 != nil:
    section.add "X-Amz-Security-Token", valid_605182
  var valid_605183 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605183 = validateParameter(valid_605183, JString, required = false,
                                 default = nil)
  if valid_605183 != nil:
    section.add "X-Amz-Content-Sha256", valid_605183
  var valid_605184 = header.getOrDefault("X-Amz-Algorithm")
  valid_605184 = validateParameter(valid_605184, JString, required = false,
                                 default = nil)
  if valid_605184 != nil:
    section.add "X-Amz-Algorithm", valid_605184
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_605185 = header.getOrDefault("x-amzn-principal")
  valid_605185 = validateParameter(valid_605185, JString, required = true,
                                 default = nil)
  if valid_605185 != nil:
    section.add "x-amzn-principal", valid_605185
  var valid_605186 = header.getOrDefault("X-Amz-Signature")
  valid_605186 = validateParameter(valid_605186, JString, required = false,
                                 default = nil)
  if valid_605186 != nil:
    section.add "X-Amz-Signature", valid_605186
  var valid_605187 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605187 = validateParameter(valid_605187, JString, required = false,
                                 default = nil)
  if valid_605187 != nil:
    section.add "X-Amz-SignedHeaders", valid_605187
  var valid_605188 = header.getOrDefault("X-Amz-Credential")
  valid_605188 = validateParameter(valid_605188, JString, required = false,
                                 default = nil)
  if valid_605188 != nil:
    section.add "X-Amz-Credential", valid_605188
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605189: Call_ListPrincipalThings_605176; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ## 
  let valid = call_605189.validator(path, query, header, formData, body)
  let scheme = call_605189.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605189.url(scheme.get, call_605189.host, call_605189.base,
                         call_605189.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605189, url, valid)

proc call*(call_605190: Call_ListPrincipalThings_605176; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listPrincipalThings
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var query_605191 = newJObject()
  add(query_605191, "maxResults", newJInt(maxResults))
  add(query_605191, "nextToken", newJString(nextToken))
  result = call_605190.call(nil, query_605191, nil, nil, nil)

var listPrincipalThings* = Call_ListPrincipalThings_605176(
    name: "listPrincipalThings", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/principals/things#x-amzn-principal",
    validator: validate_ListPrincipalThings_605177, base: "/",
    url: url_ListPrincipalThings_605178, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListRoleAliases_605192 = ref object of OpenApiRestCall_602466
proc url_ListRoleAliases_605194(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListRoleAliases_605193(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Lists the role aliases registered in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   isAscendingOrder: JBool
  ##                   : Return the list of role aliases in ascending alphabetical order.
  section = newJObject()
  var valid_605195 = query.getOrDefault("marker")
  valid_605195 = validateParameter(valid_605195, JString, required = false,
                                 default = nil)
  if valid_605195 != nil:
    section.add "marker", valid_605195
  var valid_605196 = query.getOrDefault("pageSize")
  valid_605196 = validateParameter(valid_605196, JInt, required = false, default = nil)
  if valid_605196 != nil:
    section.add "pageSize", valid_605196
  var valid_605197 = query.getOrDefault("isAscendingOrder")
  valid_605197 = validateParameter(valid_605197, JBool, required = false, default = nil)
  if valid_605197 != nil:
    section.add "isAscendingOrder", valid_605197
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605198 = header.getOrDefault("X-Amz-Date")
  valid_605198 = validateParameter(valid_605198, JString, required = false,
                                 default = nil)
  if valid_605198 != nil:
    section.add "X-Amz-Date", valid_605198
  var valid_605199 = header.getOrDefault("X-Amz-Security-Token")
  valid_605199 = validateParameter(valid_605199, JString, required = false,
                                 default = nil)
  if valid_605199 != nil:
    section.add "X-Amz-Security-Token", valid_605199
  var valid_605200 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605200 = validateParameter(valid_605200, JString, required = false,
                                 default = nil)
  if valid_605200 != nil:
    section.add "X-Amz-Content-Sha256", valid_605200
  var valid_605201 = header.getOrDefault("X-Amz-Algorithm")
  valid_605201 = validateParameter(valid_605201, JString, required = false,
                                 default = nil)
  if valid_605201 != nil:
    section.add "X-Amz-Algorithm", valid_605201
  var valid_605202 = header.getOrDefault("X-Amz-Signature")
  valid_605202 = validateParameter(valid_605202, JString, required = false,
                                 default = nil)
  if valid_605202 != nil:
    section.add "X-Amz-Signature", valid_605202
  var valid_605203 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605203 = validateParameter(valid_605203, JString, required = false,
                                 default = nil)
  if valid_605203 != nil:
    section.add "X-Amz-SignedHeaders", valid_605203
  var valid_605204 = header.getOrDefault("X-Amz-Credential")
  valid_605204 = validateParameter(valid_605204, JString, required = false,
                                 default = nil)
  if valid_605204 != nil:
    section.add "X-Amz-Credential", valid_605204
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605205: Call_ListRoleAliases_605192; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the role aliases registered in your account.
  ## 
  let valid = call_605205.validator(path, query, header, formData, body)
  let scheme = call_605205.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605205.url(scheme.get, call_605205.host, call_605205.base,
                         call_605205.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605205, url, valid)

proc call*(call_605206: Call_ListRoleAliases_605192; marker: string = "";
          pageSize: int = 0; isAscendingOrder: bool = false): Recallable =
  ## listRoleAliases
  ## Lists the role aliases registered in your account.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   isAscendingOrder: bool
  ##                   : Return the list of role aliases in ascending alphabetical order.
  var query_605207 = newJObject()
  add(query_605207, "marker", newJString(marker))
  add(query_605207, "pageSize", newJInt(pageSize))
  add(query_605207, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_605206.call(nil, query_605207, nil, nil, nil)

var listRoleAliases* = Call_ListRoleAliases_605192(name: "listRoleAliases",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/role-aliases",
    validator: validate_ListRoleAliases_605193, base: "/", url: url_ListRoleAliases_605194,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListScheduledAudits_605208 = ref object of OpenApiRestCall_602466
proc url_ListScheduledAudits_605210(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListScheduledAudits_605209(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists all of your scheduled audits.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  section = newJObject()
  var valid_605211 = query.getOrDefault("maxResults")
  valid_605211 = validateParameter(valid_605211, JInt, required = false, default = nil)
  if valid_605211 != nil:
    section.add "maxResults", valid_605211
  var valid_605212 = query.getOrDefault("nextToken")
  valid_605212 = validateParameter(valid_605212, JString, required = false,
                                 default = nil)
  if valid_605212 != nil:
    section.add "nextToken", valid_605212
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605213 = header.getOrDefault("X-Amz-Date")
  valid_605213 = validateParameter(valid_605213, JString, required = false,
                                 default = nil)
  if valid_605213 != nil:
    section.add "X-Amz-Date", valid_605213
  var valid_605214 = header.getOrDefault("X-Amz-Security-Token")
  valid_605214 = validateParameter(valid_605214, JString, required = false,
                                 default = nil)
  if valid_605214 != nil:
    section.add "X-Amz-Security-Token", valid_605214
  var valid_605215 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605215 = validateParameter(valid_605215, JString, required = false,
                                 default = nil)
  if valid_605215 != nil:
    section.add "X-Amz-Content-Sha256", valid_605215
  var valid_605216 = header.getOrDefault("X-Amz-Algorithm")
  valid_605216 = validateParameter(valid_605216, JString, required = false,
                                 default = nil)
  if valid_605216 != nil:
    section.add "X-Amz-Algorithm", valid_605216
  var valid_605217 = header.getOrDefault("X-Amz-Signature")
  valid_605217 = validateParameter(valid_605217, JString, required = false,
                                 default = nil)
  if valid_605217 != nil:
    section.add "X-Amz-Signature", valid_605217
  var valid_605218 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605218 = validateParameter(valid_605218, JString, required = false,
                                 default = nil)
  if valid_605218 != nil:
    section.add "X-Amz-SignedHeaders", valid_605218
  var valid_605219 = header.getOrDefault("X-Amz-Credential")
  valid_605219 = validateParameter(valid_605219, JString, required = false,
                                 default = nil)
  if valid_605219 != nil:
    section.add "X-Amz-Credential", valid_605219
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605220: Call_ListScheduledAudits_605208; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all of your scheduled audits.
  ## 
  let valid = call_605220.validator(path, query, header, formData, body)
  let scheme = call_605220.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605220.url(scheme.get, call_605220.host, call_605220.base,
                         call_605220.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605220, url, valid)

proc call*(call_605221: Call_ListScheduledAudits_605208; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listScheduledAudits
  ## Lists all of your scheduled audits.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  ##   nextToken: string
  ##            : The token for the next set of results.
  var query_605222 = newJObject()
  add(query_605222, "maxResults", newJInt(maxResults))
  add(query_605222, "nextToken", newJString(nextToken))
  result = call_605221.call(nil, query_605222, nil, nil, nil)

var listScheduledAudits* = Call_ListScheduledAudits_605208(
    name: "listScheduledAudits", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/scheduledaudits",
    validator: validate_ListScheduledAudits_605209, base: "/",
    url: url_ListScheduledAudits_605210, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListSecurityProfiles_605223 = ref object of OpenApiRestCall_602466
proc url_ListSecurityProfiles_605225(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListSecurityProfiles_605224(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  section = newJObject()
  var valid_605226 = query.getOrDefault("maxResults")
  valid_605226 = validateParameter(valid_605226, JInt, required = false, default = nil)
  if valid_605226 != nil:
    section.add "maxResults", valid_605226
  var valid_605227 = query.getOrDefault("nextToken")
  valid_605227 = validateParameter(valid_605227, JString, required = false,
                                 default = nil)
  if valid_605227 != nil:
    section.add "nextToken", valid_605227
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605228 = header.getOrDefault("X-Amz-Date")
  valid_605228 = validateParameter(valid_605228, JString, required = false,
                                 default = nil)
  if valid_605228 != nil:
    section.add "X-Amz-Date", valid_605228
  var valid_605229 = header.getOrDefault("X-Amz-Security-Token")
  valid_605229 = validateParameter(valid_605229, JString, required = false,
                                 default = nil)
  if valid_605229 != nil:
    section.add "X-Amz-Security-Token", valid_605229
  var valid_605230 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605230 = validateParameter(valid_605230, JString, required = false,
                                 default = nil)
  if valid_605230 != nil:
    section.add "X-Amz-Content-Sha256", valid_605230
  var valid_605231 = header.getOrDefault("X-Amz-Algorithm")
  valid_605231 = validateParameter(valid_605231, JString, required = false,
                                 default = nil)
  if valid_605231 != nil:
    section.add "X-Amz-Algorithm", valid_605231
  var valid_605232 = header.getOrDefault("X-Amz-Signature")
  valid_605232 = validateParameter(valid_605232, JString, required = false,
                                 default = nil)
  if valid_605232 != nil:
    section.add "X-Amz-Signature", valid_605232
  var valid_605233 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605233 = validateParameter(valid_605233, JString, required = false,
                                 default = nil)
  if valid_605233 != nil:
    section.add "X-Amz-SignedHeaders", valid_605233
  var valid_605234 = header.getOrDefault("X-Amz-Credential")
  valid_605234 = validateParameter(valid_605234, JString, required = false,
                                 default = nil)
  if valid_605234 != nil:
    section.add "X-Amz-Credential", valid_605234
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605235: Call_ListSecurityProfiles_605223; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ## 
  let valid = call_605235.validator(path, query, header, formData, body)
  let scheme = call_605235.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605235.url(scheme.get, call_605235.host, call_605235.base,
                         call_605235.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605235, url, valid)

proc call*(call_605236: Call_ListSecurityProfiles_605223; maxResults: int = 0;
          nextToken: string = ""): Recallable =
  ## listSecurityProfiles
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  var query_605237 = newJObject()
  add(query_605237, "maxResults", newJInt(maxResults))
  add(query_605237, "nextToken", newJString(nextToken))
  result = call_605236.call(nil, query_605237, nil, nil, nil)

var listSecurityProfiles* = Call_ListSecurityProfiles_605223(
    name: "listSecurityProfiles", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/security-profiles",
    validator: validate_ListSecurityProfiles_605224, base: "/",
    url: url_ListSecurityProfiles_605225, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListSecurityProfilesForTarget_605238 = ref object of OpenApiRestCall_602466
proc url_ListSecurityProfilesForTarget_605240(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListSecurityProfilesForTarget_605239(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the target (thing group) whose attached security profiles you want to get.
  ##   recursive: JBool
  ##            : If true, return child groups too.
  section = newJObject()
  var valid_605241 = query.getOrDefault("maxResults")
  valid_605241 = validateParameter(valid_605241, JInt, required = false, default = nil)
  if valid_605241 != nil:
    section.add "maxResults", valid_605241
  var valid_605242 = query.getOrDefault("nextToken")
  valid_605242 = validateParameter(valid_605242, JString, required = false,
                                 default = nil)
  if valid_605242 != nil:
    section.add "nextToken", valid_605242
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_605243 = query.getOrDefault("securityProfileTargetArn")
  valid_605243 = validateParameter(valid_605243, JString, required = true,
                                 default = nil)
  if valid_605243 != nil:
    section.add "securityProfileTargetArn", valid_605243
  var valid_605244 = query.getOrDefault("recursive")
  valid_605244 = validateParameter(valid_605244, JBool, required = false, default = nil)
  if valid_605244 != nil:
    section.add "recursive", valid_605244
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605245 = header.getOrDefault("X-Amz-Date")
  valid_605245 = validateParameter(valid_605245, JString, required = false,
                                 default = nil)
  if valid_605245 != nil:
    section.add "X-Amz-Date", valid_605245
  var valid_605246 = header.getOrDefault("X-Amz-Security-Token")
  valid_605246 = validateParameter(valid_605246, JString, required = false,
                                 default = nil)
  if valid_605246 != nil:
    section.add "X-Amz-Security-Token", valid_605246
  var valid_605247 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605247 = validateParameter(valid_605247, JString, required = false,
                                 default = nil)
  if valid_605247 != nil:
    section.add "X-Amz-Content-Sha256", valid_605247
  var valid_605248 = header.getOrDefault("X-Amz-Algorithm")
  valid_605248 = validateParameter(valid_605248, JString, required = false,
                                 default = nil)
  if valid_605248 != nil:
    section.add "X-Amz-Algorithm", valid_605248
  var valid_605249 = header.getOrDefault("X-Amz-Signature")
  valid_605249 = validateParameter(valid_605249, JString, required = false,
                                 default = nil)
  if valid_605249 != nil:
    section.add "X-Amz-Signature", valid_605249
  var valid_605250 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605250 = validateParameter(valid_605250, JString, required = false,
                                 default = nil)
  if valid_605250 != nil:
    section.add "X-Amz-SignedHeaders", valid_605250
  var valid_605251 = header.getOrDefault("X-Amz-Credential")
  valid_605251 = validateParameter(valid_605251, JString, required = false,
                                 default = nil)
  if valid_605251 != nil:
    section.add "X-Amz-Credential", valid_605251
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605252: Call_ListSecurityProfilesForTarget_605238; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ## 
  let valid = call_605252.validator(path, query, header, formData, body)
  let scheme = call_605252.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605252.url(scheme.get, call_605252.host, call_605252.base,
                         call_605252.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605252, url, valid)

proc call*(call_605253: Call_ListSecurityProfilesForTarget_605238;
          securityProfileTargetArn: string; maxResults: int = 0;
          nextToken: string = ""; recursive: bool = false): Recallable =
  ## listSecurityProfilesForTarget
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the target (thing group) whose attached security profiles you want to get.
  ##   recursive: bool
  ##            : If true, return child groups too.
  var query_605254 = newJObject()
  add(query_605254, "maxResults", newJInt(maxResults))
  add(query_605254, "nextToken", newJString(nextToken))
  add(query_605254, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(query_605254, "recursive", newJBool(recursive))
  result = call_605253.call(nil, query_605254, nil, nil, nil)

var listSecurityProfilesForTarget* = Call_ListSecurityProfilesForTarget_605238(
    name: "listSecurityProfilesForTarget", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/security-profiles-for-target#securityProfileTargetArn",
    validator: validate_ListSecurityProfilesForTarget_605239, base: "/",
    url: url_ListSecurityProfilesForTarget_605240,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListStreams_605255 = ref object of OpenApiRestCall_602466
proc url_ListStreams_605257(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListStreams_605256(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all of the streams in your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at a time.
  ##   nextToken: JString
  ##            : A token used to get the next set of results.
  ##   isAscendingOrder: JBool
  ##                   : Set to true to return the list of streams in ascending order.
  section = newJObject()
  var valid_605258 = query.getOrDefault("maxResults")
  valid_605258 = validateParameter(valid_605258, JInt, required = false, default = nil)
  if valid_605258 != nil:
    section.add "maxResults", valid_605258
  var valid_605259 = query.getOrDefault("nextToken")
  valid_605259 = validateParameter(valid_605259, JString, required = false,
                                 default = nil)
  if valid_605259 != nil:
    section.add "nextToken", valid_605259
  var valid_605260 = query.getOrDefault("isAscendingOrder")
  valid_605260 = validateParameter(valid_605260, JBool, required = false, default = nil)
  if valid_605260 != nil:
    section.add "isAscendingOrder", valid_605260
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605261 = header.getOrDefault("X-Amz-Date")
  valid_605261 = validateParameter(valid_605261, JString, required = false,
                                 default = nil)
  if valid_605261 != nil:
    section.add "X-Amz-Date", valid_605261
  var valid_605262 = header.getOrDefault("X-Amz-Security-Token")
  valid_605262 = validateParameter(valid_605262, JString, required = false,
                                 default = nil)
  if valid_605262 != nil:
    section.add "X-Amz-Security-Token", valid_605262
  var valid_605263 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605263 = validateParameter(valid_605263, JString, required = false,
                                 default = nil)
  if valid_605263 != nil:
    section.add "X-Amz-Content-Sha256", valid_605263
  var valid_605264 = header.getOrDefault("X-Amz-Algorithm")
  valid_605264 = validateParameter(valid_605264, JString, required = false,
                                 default = nil)
  if valid_605264 != nil:
    section.add "X-Amz-Algorithm", valid_605264
  var valid_605265 = header.getOrDefault("X-Amz-Signature")
  valid_605265 = validateParameter(valid_605265, JString, required = false,
                                 default = nil)
  if valid_605265 != nil:
    section.add "X-Amz-Signature", valid_605265
  var valid_605266 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605266 = validateParameter(valid_605266, JString, required = false,
                                 default = nil)
  if valid_605266 != nil:
    section.add "X-Amz-SignedHeaders", valid_605266
  var valid_605267 = header.getOrDefault("X-Amz-Credential")
  valid_605267 = validateParameter(valid_605267, JString, required = false,
                                 default = nil)
  if valid_605267 != nil:
    section.add "X-Amz-Credential", valid_605267
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605268: Call_ListStreams_605255; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all of the streams in your AWS account.
  ## 
  let valid = call_605268.validator(path, query, header, formData, body)
  let scheme = call_605268.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605268.url(scheme.get, call_605268.host, call_605268.base,
                         call_605268.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605268, url, valid)

proc call*(call_605269: Call_ListStreams_605255; maxResults: int = 0;
          nextToken: string = ""; isAscendingOrder: bool = false): Recallable =
  ## listStreams
  ## Lists all of the streams in your AWS account.
  ##   maxResults: int
  ##             : The maximum number of results to return at a time.
  ##   nextToken: string
  ##            : A token used to get the next set of results.
  ##   isAscendingOrder: bool
  ##                   : Set to true to return the list of streams in ascending order.
  var query_605270 = newJObject()
  add(query_605270, "maxResults", newJInt(maxResults))
  add(query_605270, "nextToken", newJString(nextToken))
  add(query_605270, "isAscendingOrder", newJBool(isAscendingOrder))
  result = call_605269.call(nil, query_605270, nil, nil, nil)

var listStreams* = Call_ListStreams_605255(name: "listStreams",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/streams",
                                        validator: validate_ListStreams_605256,
                                        base: "/", url: url_ListStreams_605257,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTagsForResource_605271 = ref object of OpenApiRestCall_602466
proc url_ListTagsForResource_605273(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListTagsForResource_605272(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the tags (metadata) you have assigned to the resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   resourceArn: JString (required)
  ##              : The ARN of the resource.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `resourceArn` field"
  var valid_605274 = query.getOrDefault("resourceArn")
  valid_605274 = validateParameter(valid_605274, JString, required = true,
                                 default = nil)
  if valid_605274 != nil:
    section.add "resourceArn", valid_605274
  var valid_605275 = query.getOrDefault("nextToken")
  valid_605275 = validateParameter(valid_605275, JString, required = false,
                                 default = nil)
  if valid_605275 != nil:
    section.add "nextToken", valid_605275
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605276 = header.getOrDefault("X-Amz-Date")
  valid_605276 = validateParameter(valid_605276, JString, required = false,
                                 default = nil)
  if valid_605276 != nil:
    section.add "X-Amz-Date", valid_605276
  var valid_605277 = header.getOrDefault("X-Amz-Security-Token")
  valid_605277 = validateParameter(valid_605277, JString, required = false,
                                 default = nil)
  if valid_605277 != nil:
    section.add "X-Amz-Security-Token", valid_605277
  var valid_605278 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605278 = validateParameter(valid_605278, JString, required = false,
                                 default = nil)
  if valid_605278 != nil:
    section.add "X-Amz-Content-Sha256", valid_605278
  var valid_605279 = header.getOrDefault("X-Amz-Algorithm")
  valid_605279 = validateParameter(valid_605279, JString, required = false,
                                 default = nil)
  if valid_605279 != nil:
    section.add "X-Amz-Algorithm", valid_605279
  var valid_605280 = header.getOrDefault("X-Amz-Signature")
  valid_605280 = validateParameter(valid_605280, JString, required = false,
                                 default = nil)
  if valid_605280 != nil:
    section.add "X-Amz-Signature", valid_605280
  var valid_605281 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605281 = validateParameter(valid_605281, JString, required = false,
                                 default = nil)
  if valid_605281 != nil:
    section.add "X-Amz-SignedHeaders", valid_605281
  var valid_605282 = header.getOrDefault("X-Amz-Credential")
  valid_605282 = validateParameter(valid_605282, JString, required = false,
                                 default = nil)
  if valid_605282 != nil:
    section.add "X-Amz-Credential", valid_605282
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605283: Call_ListTagsForResource_605271; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the tags (metadata) you have assigned to the resource.
  ## 
  let valid = call_605283.validator(path, query, header, formData, body)
  let scheme = call_605283.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605283.url(scheme.get, call_605283.host, call_605283.base,
                         call_605283.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605283, url, valid)

proc call*(call_605284: Call_ListTagsForResource_605271; resourceArn: string;
          nextToken: string = ""): Recallable =
  ## listTagsForResource
  ## Lists the tags (metadata) you have assigned to the resource.
  ##   resourceArn: string (required)
  ##              : The ARN of the resource.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var query_605285 = newJObject()
  add(query_605285, "resourceArn", newJString(resourceArn))
  add(query_605285, "nextToken", newJString(nextToken))
  result = call_605284.call(nil, query_605285, nil, nil, nil)

var listTagsForResource* = Call_ListTagsForResource_605271(
    name: "listTagsForResource", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/tags#resourceArn",
    validator: validate_ListTagsForResource_605272, base: "/",
    url: url_ListTagsForResource_605273, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTargetsForPolicy_605286 = ref object of OpenApiRestCall_602466
proc url_ListTargetsForPolicy_605288(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policy-targets/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListTargetsForPolicy_605287(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List targets for the specified policy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_605289 = path.getOrDefault("policyName")
  valid_605289 = validateParameter(valid_605289, JString, required = true,
                                 default = nil)
  if valid_605289 != nil:
    section.add "policyName", valid_605289
  result.add "path", section
  ## parameters in `query` object:
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  section = newJObject()
  var valid_605290 = query.getOrDefault("marker")
  valid_605290 = validateParameter(valid_605290, JString, required = false,
                                 default = nil)
  if valid_605290 != nil:
    section.add "marker", valid_605290
  var valid_605291 = query.getOrDefault("pageSize")
  valid_605291 = validateParameter(valid_605291, JInt, required = false, default = nil)
  if valid_605291 != nil:
    section.add "pageSize", valid_605291
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605292 = header.getOrDefault("X-Amz-Date")
  valid_605292 = validateParameter(valid_605292, JString, required = false,
                                 default = nil)
  if valid_605292 != nil:
    section.add "X-Amz-Date", valid_605292
  var valid_605293 = header.getOrDefault("X-Amz-Security-Token")
  valid_605293 = validateParameter(valid_605293, JString, required = false,
                                 default = nil)
  if valid_605293 != nil:
    section.add "X-Amz-Security-Token", valid_605293
  var valid_605294 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605294 = validateParameter(valid_605294, JString, required = false,
                                 default = nil)
  if valid_605294 != nil:
    section.add "X-Amz-Content-Sha256", valid_605294
  var valid_605295 = header.getOrDefault("X-Amz-Algorithm")
  valid_605295 = validateParameter(valid_605295, JString, required = false,
                                 default = nil)
  if valid_605295 != nil:
    section.add "X-Amz-Algorithm", valid_605295
  var valid_605296 = header.getOrDefault("X-Amz-Signature")
  valid_605296 = validateParameter(valid_605296, JString, required = false,
                                 default = nil)
  if valid_605296 != nil:
    section.add "X-Amz-Signature", valid_605296
  var valid_605297 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605297 = validateParameter(valid_605297, JString, required = false,
                                 default = nil)
  if valid_605297 != nil:
    section.add "X-Amz-SignedHeaders", valid_605297
  var valid_605298 = header.getOrDefault("X-Amz-Credential")
  valid_605298 = validateParameter(valid_605298, JString, required = false,
                                 default = nil)
  if valid_605298 != nil:
    section.add "X-Amz-Credential", valid_605298
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605299: Call_ListTargetsForPolicy_605286; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List targets for the specified policy.
  ## 
  let valid = call_605299.validator(path, query, header, formData, body)
  let scheme = call_605299.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605299.url(scheme.get, call_605299.host, call_605299.base,
                         call_605299.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605299, url, valid)

proc call*(call_605300: Call_ListTargetsForPolicy_605286; policyName: string;
          marker: string = ""; pageSize: int = 0): Recallable =
  ## listTargetsForPolicy
  ## List targets for the specified policy.
  ##   policyName: string (required)
  ##             : The policy name.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  var path_605301 = newJObject()
  var query_605302 = newJObject()
  add(path_605301, "policyName", newJString(policyName))
  add(query_605302, "marker", newJString(marker))
  add(query_605302, "pageSize", newJInt(pageSize))
  result = call_605300.call(path_605301, query_605302, nil, nil, nil)

var listTargetsForPolicy* = Call_ListTargetsForPolicy_605286(
    name: "listTargetsForPolicy", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/policy-targets/{policyName}",
    validator: validate_ListTargetsForPolicy_605287, base: "/",
    url: url_ListTargetsForPolicy_605288, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTargetsForSecurityProfile_605303 = ref object of OpenApiRestCall_602466
proc url_ListTargetsForSecurityProfile_605305(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"),
               (kind: ConstantSegment, value: "/targets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListTargetsForSecurityProfile_605304(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_605306 = path.getOrDefault("securityProfileName")
  valid_605306 = validateParameter(valid_605306, JString, required = true,
                                 default = nil)
  if valid_605306 != nil:
    section.add "securityProfileName", valid_605306
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  section = newJObject()
  var valid_605307 = query.getOrDefault("maxResults")
  valid_605307 = validateParameter(valid_605307, JInt, required = false, default = nil)
  if valid_605307 != nil:
    section.add "maxResults", valid_605307
  var valid_605308 = query.getOrDefault("nextToken")
  valid_605308 = validateParameter(valid_605308, JString, required = false,
                                 default = nil)
  if valid_605308 != nil:
    section.add "nextToken", valid_605308
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605309 = header.getOrDefault("X-Amz-Date")
  valid_605309 = validateParameter(valid_605309, JString, required = false,
                                 default = nil)
  if valid_605309 != nil:
    section.add "X-Amz-Date", valid_605309
  var valid_605310 = header.getOrDefault("X-Amz-Security-Token")
  valid_605310 = validateParameter(valid_605310, JString, required = false,
                                 default = nil)
  if valid_605310 != nil:
    section.add "X-Amz-Security-Token", valid_605310
  var valid_605311 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605311 = validateParameter(valid_605311, JString, required = false,
                                 default = nil)
  if valid_605311 != nil:
    section.add "X-Amz-Content-Sha256", valid_605311
  var valid_605312 = header.getOrDefault("X-Amz-Algorithm")
  valid_605312 = validateParameter(valid_605312, JString, required = false,
                                 default = nil)
  if valid_605312 != nil:
    section.add "X-Amz-Algorithm", valid_605312
  var valid_605313 = header.getOrDefault("X-Amz-Signature")
  valid_605313 = validateParameter(valid_605313, JString, required = false,
                                 default = nil)
  if valid_605313 != nil:
    section.add "X-Amz-Signature", valid_605313
  var valid_605314 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605314 = validateParameter(valid_605314, JString, required = false,
                                 default = nil)
  if valid_605314 != nil:
    section.add "X-Amz-SignedHeaders", valid_605314
  var valid_605315 = header.getOrDefault("X-Amz-Credential")
  valid_605315 = validateParameter(valid_605315, JString, required = false,
                                 default = nil)
  if valid_605315 != nil:
    section.add "X-Amz-Credential", valid_605315
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605316: Call_ListTargetsForSecurityProfile_605303; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ## 
  let valid = call_605316.validator(path, query, header, formData, body)
  let scheme = call_605316.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605316.url(scheme.get, call_605316.host, call_605316.base,
                         call_605316.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605316, url, valid)

proc call*(call_605317: Call_ListTargetsForSecurityProfile_605303;
          securityProfileName: string; maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listTargetsForSecurityProfile
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string (required)
  ##                      : The security profile.
  var path_605318 = newJObject()
  var query_605319 = newJObject()
  add(query_605319, "maxResults", newJInt(maxResults))
  add(query_605319, "nextToken", newJString(nextToken))
  add(path_605318, "securityProfileName", newJString(securityProfileName))
  result = call_605317.call(path_605318, query_605319, nil, nil, nil)

var listTargetsForSecurityProfile* = Call_ListTargetsForSecurityProfile_605303(
    name: "listTargetsForSecurityProfile", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/security-profiles/{securityProfileName}/targets",
    validator: validate_ListTargetsForSecurityProfile_605304, base: "/",
    url: url_ListTargetsForSecurityProfile_605305,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingGroups_605320 = ref object of OpenApiRestCall_602466
proc url_ListThingGroups_605322(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListThingGroups_605321(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List the thing groups in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   namePrefixFilter: JString
  ##                   : A filter that limits the results to those with the specified name prefix.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   recursive: JBool
  ##            : If true, return child groups as well.
  ##   parentGroup: JString
  ##              : A filter that limits the results to those with the specified parent group.
  section = newJObject()
  var valid_605323 = query.getOrDefault("namePrefixFilter")
  valid_605323 = validateParameter(valid_605323, JString, required = false,
                                 default = nil)
  if valid_605323 != nil:
    section.add "namePrefixFilter", valid_605323
  var valid_605324 = query.getOrDefault("maxResults")
  valid_605324 = validateParameter(valid_605324, JInt, required = false, default = nil)
  if valid_605324 != nil:
    section.add "maxResults", valid_605324
  var valid_605325 = query.getOrDefault("nextToken")
  valid_605325 = validateParameter(valid_605325, JString, required = false,
                                 default = nil)
  if valid_605325 != nil:
    section.add "nextToken", valid_605325
  var valid_605326 = query.getOrDefault("recursive")
  valid_605326 = validateParameter(valid_605326, JBool, required = false, default = nil)
  if valid_605326 != nil:
    section.add "recursive", valid_605326
  var valid_605327 = query.getOrDefault("parentGroup")
  valid_605327 = validateParameter(valid_605327, JString, required = false,
                                 default = nil)
  if valid_605327 != nil:
    section.add "parentGroup", valid_605327
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605328 = header.getOrDefault("X-Amz-Date")
  valid_605328 = validateParameter(valid_605328, JString, required = false,
                                 default = nil)
  if valid_605328 != nil:
    section.add "X-Amz-Date", valid_605328
  var valid_605329 = header.getOrDefault("X-Amz-Security-Token")
  valid_605329 = validateParameter(valid_605329, JString, required = false,
                                 default = nil)
  if valid_605329 != nil:
    section.add "X-Amz-Security-Token", valid_605329
  var valid_605330 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605330 = validateParameter(valid_605330, JString, required = false,
                                 default = nil)
  if valid_605330 != nil:
    section.add "X-Amz-Content-Sha256", valid_605330
  var valid_605331 = header.getOrDefault("X-Amz-Algorithm")
  valid_605331 = validateParameter(valid_605331, JString, required = false,
                                 default = nil)
  if valid_605331 != nil:
    section.add "X-Amz-Algorithm", valid_605331
  var valid_605332 = header.getOrDefault("X-Amz-Signature")
  valid_605332 = validateParameter(valid_605332, JString, required = false,
                                 default = nil)
  if valid_605332 != nil:
    section.add "X-Amz-Signature", valid_605332
  var valid_605333 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605333 = validateParameter(valid_605333, JString, required = false,
                                 default = nil)
  if valid_605333 != nil:
    section.add "X-Amz-SignedHeaders", valid_605333
  var valid_605334 = header.getOrDefault("X-Amz-Credential")
  valid_605334 = validateParameter(valid_605334, JString, required = false,
                                 default = nil)
  if valid_605334 != nil:
    section.add "X-Amz-Credential", valid_605334
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605335: Call_ListThingGroups_605320; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the thing groups in your account.
  ## 
  let valid = call_605335.validator(path, query, header, formData, body)
  let scheme = call_605335.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605335.url(scheme.get, call_605335.host, call_605335.base,
                         call_605335.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605335, url, valid)

proc call*(call_605336: Call_ListThingGroups_605320; namePrefixFilter: string = "";
          maxResults: int = 0; nextToken: string = ""; recursive: bool = false;
          parentGroup: string = ""): Recallable =
  ## listThingGroups
  ## List the thing groups in your account.
  ##   namePrefixFilter: string
  ##                   : A filter that limits the results to those with the specified name prefix.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   recursive: bool
  ##            : If true, return child groups as well.
  ##   parentGroup: string
  ##              : A filter that limits the results to those with the specified parent group.
  var query_605337 = newJObject()
  add(query_605337, "namePrefixFilter", newJString(namePrefixFilter))
  add(query_605337, "maxResults", newJInt(maxResults))
  add(query_605337, "nextToken", newJString(nextToken))
  add(query_605337, "recursive", newJBool(recursive))
  add(query_605337, "parentGroup", newJString(parentGroup))
  result = call_605336.call(nil, query_605337, nil, nil, nil)

var listThingGroups* = Call_ListThingGroups_605320(name: "listThingGroups",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/thing-groups",
    validator: validate_ListThingGroups_605321, base: "/", url: url_ListThingGroups_605322,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingGroupsForThing_605338 = ref object of OpenApiRestCall_602466
proc url_ListThingGroupsForThing_605340(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/thing-groups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListThingGroupsForThing_605339(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List the thing groups to which the specified thing belongs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The thing name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_605341 = path.getOrDefault("thingName")
  valid_605341 = validateParameter(valid_605341, JString, required = true,
                                 default = nil)
  if valid_605341 != nil:
    section.add "thingName", valid_605341
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  var valid_605342 = query.getOrDefault("maxResults")
  valid_605342 = validateParameter(valid_605342, JInt, required = false, default = nil)
  if valid_605342 != nil:
    section.add "maxResults", valid_605342
  var valid_605343 = query.getOrDefault("nextToken")
  valid_605343 = validateParameter(valid_605343, JString, required = false,
                                 default = nil)
  if valid_605343 != nil:
    section.add "nextToken", valid_605343
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605344 = header.getOrDefault("X-Amz-Date")
  valid_605344 = validateParameter(valid_605344, JString, required = false,
                                 default = nil)
  if valid_605344 != nil:
    section.add "X-Amz-Date", valid_605344
  var valid_605345 = header.getOrDefault("X-Amz-Security-Token")
  valid_605345 = validateParameter(valid_605345, JString, required = false,
                                 default = nil)
  if valid_605345 != nil:
    section.add "X-Amz-Security-Token", valid_605345
  var valid_605346 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605346 = validateParameter(valid_605346, JString, required = false,
                                 default = nil)
  if valid_605346 != nil:
    section.add "X-Amz-Content-Sha256", valid_605346
  var valid_605347 = header.getOrDefault("X-Amz-Algorithm")
  valid_605347 = validateParameter(valid_605347, JString, required = false,
                                 default = nil)
  if valid_605347 != nil:
    section.add "X-Amz-Algorithm", valid_605347
  var valid_605348 = header.getOrDefault("X-Amz-Signature")
  valid_605348 = validateParameter(valid_605348, JString, required = false,
                                 default = nil)
  if valid_605348 != nil:
    section.add "X-Amz-Signature", valid_605348
  var valid_605349 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605349 = validateParameter(valid_605349, JString, required = false,
                                 default = nil)
  if valid_605349 != nil:
    section.add "X-Amz-SignedHeaders", valid_605349
  var valid_605350 = header.getOrDefault("X-Amz-Credential")
  valid_605350 = validateParameter(valid_605350, JString, required = false,
                                 default = nil)
  if valid_605350 != nil:
    section.add "X-Amz-Credential", valid_605350
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605351: Call_ListThingGroupsForThing_605338; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the thing groups to which the specified thing belongs.
  ## 
  let valid = call_605351.validator(path, query, header, formData, body)
  let scheme = call_605351.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605351.url(scheme.get, call_605351.host, call_605351.base,
                         call_605351.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605351, url, valid)

proc call*(call_605352: Call_ListThingGroupsForThing_605338; thingName: string;
          maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listThingGroupsForThing
  ## List the thing groups to which the specified thing belongs.
  ##   thingName: string (required)
  ##            : The thing name.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var path_605353 = newJObject()
  var query_605354 = newJObject()
  add(path_605353, "thingName", newJString(thingName))
  add(query_605354, "maxResults", newJInt(maxResults))
  add(query_605354, "nextToken", newJString(nextToken))
  result = call_605352.call(path_605353, query_605354, nil, nil, nil)

var listThingGroupsForThing* = Call_ListThingGroupsForThing_605338(
    name: "listThingGroupsForThing", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/thing-groups",
    validator: validate_ListThingGroupsForThing_605339, base: "/",
    url: url_ListThingGroupsForThing_605340, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingPrincipals_605355 = ref object of OpenApiRestCall_602466
proc url_ListThingPrincipals_605357(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListThingPrincipals_605356(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_605358 = path.getOrDefault("thingName")
  valid_605358 = validateParameter(valid_605358, JString, required = true,
                                 default = nil)
  if valid_605358 != nil:
    section.add "thingName", valid_605358
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605359 = header.getOrDefault("X-Amz-Date")
  valid_605359 = validateParameter(valid_605359, JString, required = false,
                                 default = nil)
  if valid_605359 != nil:
    section.add "X-Amz-Date", valid_605359
  var valid_605360 = header.getOrDefault("X-Amz-Security-Token")
  valid_605360 = validateParameter(valid_605360, JString, required = false,
                                 default = nil)
  if valid_605360 != nil:
    section.add "X-Amz-Security-Token", valid_605360
  var valid_605361 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605361 = validateParameter(valid_605361, JString, required = false,
                                 default = nil)
  if valid_605361 != nil:
    section.add "X-Amz-Content-Sha256", valid_605361
  var valid_605362 = header.getOrDefault("X-Amz-Algorithm")
  valid_605362 = validateParameter(valid_605362, JString, required = false,
                                 default = nil)
  if valid_605362 != nil:
    section.add "X-Amz-Algorithm", valid_605362
  var valid_605363 = header.getOrDefault("X-Amz-Signature")
  valid_605363 = validateParameter(valid_605363, JString, required = false,
                                 default = nil)
  if valid_605363 != nil:
    section.add "X-Amz-Signature", valid_605363
  var valid_605364 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605364 = validateParameter(valid_605364, JString, required = false,
                                 default = nil)
  if valid_605364 != nil:
    section.add "X-Amz-SignedHeaders", valid_605364
  var valid_605365 = header.getOrDefault("X-Amz-Credential")
  valid_605365 = validateParameter(valid_605365, JString, required = false,
                                 default = nil)
  if valid_605365 != nil:
    section.add "X-Amz-Credential", valid_605365
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605366: Call_ListThingPrincipals_605355; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  let valid = call_605366.validator(path, query, header, formData, body)
  let scheme = call_605366.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605366.url(scheme.get, call_605366.host, call_605366.base,
                         call_605366.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605366, url, valid)

proc call*(call_605367: Call_ListThingPrincipals_605355; thingName: string): Recallable =
  ## listThingPrincipals
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_605368 = newJObject()
  add(path_605368, "thingName", newJString(thingName))
  result = call_605367.call(path_605368, nil, nil, nil, nil)

var listThingPrincipals* = Call_ListThingPrincipals_605355(
    name: "listThingPrincipals", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/principals",
    validator: validate_ListThingPrincipals_605356, base: "/",
    url: url_ListThingPrincipals_605357, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingRegistrationTaskReports_605369 = ref object of OpenApiRestCall_602466
proc url_ListThingRegistrationTaskReports_605371(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/reports#reportType")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListThingRegistrationTaskReports_605370(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Information about the thing registration tasks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The id of the task.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_605372 = path.getOrDefault("taskId")
  valid_605372 = validateParameter(valid_605372, JString, required = true,
                                 default = nil)
  if valid_605372 != nil:
    section.add "taskId", valid_605372
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   reportType: JString (required)
  ##             : The type of task report.
  section = newJObject()
  var valid_605373 = query.getOrDefault("maxResults")
  valid_605373 = validateParameter(valid_605373, JInt, required = false, default = nil)
  if valid_605373 != nil:
    section.add "maxResults", valid_605373
  var valid_605374 = query.getOrDefault("nextToken")
  valid_605374 = validateParameter(valid_605374, JString, required = false,
                                 default = nil)
  if valid_605374 != nil:
    section.add "nextToken", valid_605374
  assert query != nil,
        "query argument is necessary due to required `reportType` field"
  var valid_605375 = query.getOrDefault("reportType")
  valid_605375 = validateParameter(valid_605375, JString, required = true,
                                 default = newJString("ERRORS"))
  if valid_605375 != nil:
    section.add "reportType", valid_605375
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605376 = header.getOrDefault("X-Amz-Date")
  valid_605376 = validateParameter(valid_605376, JString, required = false,
                                 default = nil)
  if valid_605376 != nil:
    section.add "X-Amz-Date", valid_605376
  var valid_605377 = header.getOrDefault("X-Amz-Security-Token")
  valid_605377 = validateParameter(valid_605377, JString, required = false,
                                 default = nil)
  if valid_605377 != nil:
    section.add "X-Amz-Security-Token", valid_605377
  var valid_605378 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605378 = validateParameter(valid_605378, JString, required = false,
                                 default = nil)
  if valid_605378 != nil:
    section.add "X-Amz-Content-Sha256", valid_605378
  var valid_605379 = header.getOrDefault("X-Amz-Algorithm")
  valid_605379 = validateParameter(valid_605379, JString, required = false,
                                 default = nil)
  if valid_605379 != nil:
    section.add "X-Amz-Algorithm", valid_605379
  var valid_605380 = header.getOrDefault("X-Amz-Signature")
  valid_605380 = validateParameter(valid_605380, JString, required = false,
                                 default = nil)
  if valid_605380 != nil:
    section.add "X-Amz-Signature", valid_605380
  var valid_605381 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605381 = validateParameter(valid_605381, JString, required = false,
                                 default = nil)
  if valid_605381 != nil:
    section.add "X-Amz-SignedHeaders", valid_605381
  var valid_605382 = header.getOrDefault("X-Amz-Credential")
  valid_605382 = validateParameter(valid_605382, JString, required = false,
                                 default = nil)
  if valid_605382 != nil:
    section.add "X-Amz-Credential", valid_605382
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605383: Call_ListThingRegistrationTaskReports_605369;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Information about the thing registration tasks.
  ## 
  let valid = call_605383.validator(path, query, header, formData, body)
  let scheme = call_605383.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605383.url(scheme.get, call_605383.host, call_605383.base,
                         call_605383.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605383, url, valid)

proc call*(call_605384: Call_ListThingRegistrationTaskReports_605369;
          taskId: string; maxResults: int = 0; nextToken: string = "";
          reportType: string = "ERRORS"): Recallable =
  ## listThingRegistrationTaskReports
  ## Information about the thing registration tasks.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   reportType: string (required)
  ##             : The type of task report.
  ##   taskId: string (required)
  ##         : The id of the task.
  var path_605385 = newJObject()
  var query_605386 = newJObject()
  add(query_605386, "maxResults", newJInt(maxResults))
  add(query_605386, "nextToken", newJString(nextToken))
  add(query_605386, "reportType", newJString(reportType))
  add(path_605385, "taskId", newJString(taskId))
  result = call_605384.call(path_605385, query_605386, nil, nil, nil)

var listThingRegistrationTaskReports* = Call_ListThingRegistrationTaskReports_605369(
    name: "listThingRegistrationTaskReports", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/thing-registration-tasks/{taskId}/reports#reportType",
    validator: validate_ListThingRegistrationTaskReports_605370, base: "/",
    url: url_ListThingRegistrationTaskReports_605371,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartThingRegistrationTask_605403 = ref object of OpenApiRestCall_602466
proc url_StartThingRegistrationTask_605405(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_StartThingRegistrationTask_605404(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605406 = header.getOrDefault("X-Amz-Date")
  valid_605406 = validateParameter(valid_605406, JString, required = false,
                                 default = nil)
  if valid_605406 != nil:
    section.add "X-Amz-Date", valid_605406
  var valid_605407 = header.getOrDefault("X-Amz-Security-Token")
  valid_605407 = validateParameter(valid_605407, JString, required = false,
                                 default = nil)
  if valid_605407 != nil:
    section.add "X-Amz-Security-Token", valid_605407
  var valid_605408 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605408 = validateParameter(valid_605408, JString, required = false,
                                 default = nil)
  if valid_605408 != nil:
    section.add "X-Amz-Content-Sha256", valid_605408
  var valid_605409 = header.getOrDefault("X-Amz-Algorithm")
  valid_605409 = validateParameter(valid_605409, JString, required = false,
                                 default = nil)
  if valid_605409 != nil:
    section.add "X-Amz-Algorithm", valid_605409
  var valid_605410 = header.getOrDefault("X-Amz-Signature")
  valid_605410 = validateParameter(valid_605410, JString, required = false,
                                 default = nil)
  if valid_605410 != nil:
    section.add "X-Amz-Signature", valid_605410
  var valid_605411 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605411 = validateParameter(valid_605411, JString, required = false,
                                 default = nil)
  if valid_605411 != nil:
    section.add "X-Amz-SignedHeaders", valid_605411
  var valid_605412 = header.getOrDefault("X-Amz-Credential")
  valid_605412 = validateParameter(valid_605412, JString, required = false,
                                 default = nil)
  if valid_605412 != nil:
    section.add "X-Amz-Credential", valid_605412
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605414: Call_StartThingRegistrationTask_605403; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a bulk thing provisioning task.
  ## 
  let valid = call_605414.validator(path, query, header, formData, body)
  let scheme = call_605414.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605414.url(scheme.get, call_605414.host, call_605414.base,
                         call_605414.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605414, url, valid)

proc call*(call_605415: Call_StartThingRegistrationTask_605403; body: JsonNode): Recallable =
  ## startThingRegistrationTask
  ## Creates a bulk thing provisioning task.
  ##   body: JObject (required)
  var body_605416 = newJObject()
  if body != nil:
    body_605416 = body
  result = call_605415.call(nil, nil, nil, nil, body_605416)

var startThingRegistrationTask* = Call_StartThingRegistrationTask_605403(
    name: "startThingRegistrationTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks",
    validator: validate_StartThingRegistrationTask_605404, base: "/",
    url: url_StartThingRegistrationTask_605405,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingRegistrationTasks_605387 = ref object of OpenApiRestCall_602466
proc url_ListThingRegistrationTasks_605389(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListThingRegistrationTasks_605388(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List bulk thing provisioning tasks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : The status of the bulk thing provisioning task.
  section = newJObject()
  var valid_605390 = query.getOrDefault("maxResults")
  valid_605390 = validateParameter(valid_605390, JInt, required = false, default = nil)
  if valid_605390 != nil:
    section.add "maxResults", valid_605390
  var valid_605391 = query.getOrDefault("nextToken")
  valid_605391 = validateParameter(valid_605391, JString, required = false,
                                 default = nil)
  if valid_605391 != nil:
    section.add "nextToken", valid_605391
  var valid_605392 = query.getOrDefault("status")
  valid_605392 = validateParameter(valid_605392, JString, required = false,
                                 default = newJString("InProgress"))
  if valid_605392 != nil:
    section.add "status", valid_605392
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605393 = header.getOrDefault("X-Amz-Date")
  valid_605393 = validateParameter(valid_605393, JString, required = false,
                                 default = nil)
  if valid_605393 != nil:
    section.add "X-Amz-Date", valid_605393
  var valid_605394 = header.getOrDefault("X-Amz-Security-Token")
  valid_605394 = validateParameter(valid_605394, JString, required = false,
                                 default = nil)
  if valid_605394 != nil:
    section.add "X-Amz-Security-Token", valid_605394
  var valid_605395 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605395 = validateParameter(valid_605395, JString, required = false,
                                 default = nil)
  if valid_605395 != nil:
    section.add "X-Amz-Content-Sha256", valid_605395
  var valid_605396 = header.getOrDefault("X-Amz-Algorithm")
  valid_605396 = validateParameter(valid_605396, JString, required = false,
                                 default = nil)
  if valid_605396 != nil:
    section.add "X-Amz-Algorithm", valid_605396
  var valid_605397 = header.getOrDefault("X-Amz-Signature")
  valid_605397 = validateParameter(valid_605397, JString, required = false,
                                 default = nil)
  if valid_605397 != nil:
    section.add "X-Amz-Signature", valid_605397
  var valid_605398 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605398 = validateParameter(valid_605398, JString, required = false,
                                 default = nil)
  if valid_605398 != nil:
    section.add "X-Amz-SignedHeaders", valid_605398
  var valid_605399 = header.getOrDefault("X-Amz-Credential")
  valid_605399 = validateParameter(valid_605399, JString, required = false,
                                 default = nil)
  if valid_605399 != nil:
    section.add "X-Amz-Credential", valid_605399
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605400: Call_ListThingRegistrationTasks_605387; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List bulk thing provisioning tasks.
  ## 
  let valid = call_605400.validator(path, query, header, formData, body)
  let scheme = call_605400.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605400.url(scheme.get, call_605400.host, call_605400.base,
                         call_605400.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605400, url, valid)

proc call*(call_605401: Call_ListThingRegistrationTasks_605387;
          maxResults: int = 0; nextToken: string = ""; status: string = "InProgress"): Recallable =
  ## listThingRegistrationTasks
  ## List bulk thing provisioning tasks.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : The status of the bulk thing provisioning task.
  var query_605402 = newJObject()
  add(query_605402, "maxResults", newJInt(maxResults))
  add(query_605402, "nextToken", newJString(nextToken))
  add(query_605402, "status", newJString(status))
  result = call_605401.call(nil, query_605402, nil, nil, nil)

var listThingRegistrationTasks* = Call_ListThingRegistrationTasks_605387(
    name: "listThingRegistrationTasks", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks",
    validator: validate_ListThingRegistrationTasks_605388, base: "/",
    url: url_ListThingRegistrationTasks_605389,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingTypes_605417 = ref object of OpenApiRestCall_602466
proc url_ListThingTypes_605419(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListThingTypes_605418(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the existing thing types.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingTypeName: JString
  ##                : The name of the thing type.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  var valid_605420 = query.getOrDefault("thingTypeName")
  valid_605420 = validateParameter(valid_605420, JString, required = false,
                                 default = nil)
  if valid_605420 != nil:
    section.add "thingTypeName", valid_605420
  var valid_605421 = query.getOrDefault("maxResults")
  valid_605421 = validateParameter(valid_605421, JInt, required = false, default = nil)
  if valid_605421 != nil:
    section.add "maxResults", valid_605421
  var valid_605422 = query.getOrDefault("nextToken")
  valid_605422 = validateParameter(valid_605422, JString, required = false,
                                 default = nil)
  if valid_605422 != nil:
    section.add "nextToken", valid_605422
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605423 = header.getOrDefault("X-Amz-Date")
  valid_605423 = validateParameter(valid_605423, JString, required = false,
                                 default = nil)
  if valid_605423 != nil:
    section.add "X-Amz-Date", valid_605423
  var valid_605424 = header.getOrDefault("X-Amz-Security-Token")
  valid_605424 = validateParameter(valid_605424, JString, required = false,
                                 default = nil)
  if valid_605424 != nil:
    section.add "X-Amz-Security-Token", valid_605424
  var valid_605425 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605425 = validateParameter(valid_605425, JString, required = false,
                                 default = nil)
  if valid_605425 != nil:
    section.add "X-Amz-Content-Sha256", valid_605425
  var valid_605426 = header.getOrDefault("X-Amz-Algorithm")
  valid_605426 = validateParameter(valid_605426, JString, required = false,
                                 default = nil)
  if valid_605426 != nil:
    section.add "X-Amz-Algorithm", valid_605426
  var valid_605427 = header.getOrDefault("X-Amz-Signature")
  valid_605427 = validateParameter(valid_605427, JString, required = false,
                                 default = nil)
  if valid_605427 != nil:
    section.add "X-Amz-Signature", valid_605427
  var valid_605428 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605428 = validateParameter(valid_605428, JString, required = false,
                                 default = nil)
  if valid_605428 != nil:
    section.add "X-Amz-SignedHeaders", valid_605428
  var valid_605429 = header.getOrDefault("X-Amz-Credential")
  valid_605429 = validateParameter(valid_605429, JString, required = false,
                                 default = nil)
  if valid_605429 != nil:
    section.add "X-Amz-Credential", valid_605429
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605430: Call_ListThingTypes_605417; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the existing thing types.
  ## 
  let valid = call_605430.validator(path, query, header, formData, body)
  let scheme = call_605430.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605430.url(scheme.get, call_605430.host, call_605430.base,
                         call_605430.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605430, url, valid)

proc call*(call_605431: Call_ListThingTypes_605417; thingTypeName: string = "";
          maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listThingTypes
  ## Lists the existing thing types.
  ##   thingTypeName: string
  ##                : The name of the thing type.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var query_605432 = newJObject()
  add(query_605432, "thingTypeName", newJString(thingTypeName))
  add(query_605432, "maxResults", newJInt(maxResults))
  add(query_605432, "nextToken", newJString(nextToken))
  result = call_605431.call(nil, query_605432, nil, nil, nil)

var listThingTypes* = Call_ListThingTypes_605417(name: "listThingTypes",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/thing-types",
    validator: validate_ListThingTypes_605418, base: "/", url: url_ListThingTypes_605419,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterThing_605451 = ref object of OpenApiRestCall_602466
proc url_RegisterThing_605453(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RegisterThing_605452(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Provisions a thing.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605454 = header.getOrDefault("X-Amz-Date")
  valid_605454 = validateParameter(valid_605454, JString, required = false,
                                 default = nil)
  if valid_605454 != nil:
    section.add "X-Amz-Date", valid_605454
  var valid_605455 = header.getOrDefault("X-Amz-Security-Token")
  valid_605455 = validateParameter(valid_605455, JString, required = false,
                                 default = nil)
  if valid_605455 != nil:
    section.add "X-Amz-Security-Token", valid_605455
  var valid_605456 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605456 = validateParameter(valid_605456, JString, required = false,
                                 default = nil)
  if valid_605456 != nil:
    section.add "X-Amz-Content-Sha256", valid_605456
  var valid_605457 = header.getOrDefault("X-Amz-Algorithm")
  valid_605457 = validateParameter(valid_605457, JString, required = false,
                                 default = nil)
  if valid_605457 != nil:
    section.add "X-Amz-Algorithm", valid_605457
  var valid_605458 = header.getOrDefault("X-Amz-Signature")
  valid_605458 = validateParameter(valid_605458, JString, required = false,
                                 default = nil)
  if valid_605458 != nil:
    section.add "X-Amz-Signature", valid_605458
  var valid_605459 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605459 = validateParameter(valid_605459, JString, required = false,
                                 default = nil)
  if valid_605459 != nil:
    section.add "X-Amz-SignedHeaders", valid_605459
  var valid_605460 = header.getOrDefault("X-Amz-Credential")
  valid_605460 = validateParameter(valid_605460, JString, required = false,
                                 default = nil)
  if valid_605460 != nil:
    section.add "X-Amz-Credential", valid_605460
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605462: Call_RegisterThing_605451; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Provisions a thing.
  ## 
  let valid = call_605462.validator(path, query, header, formData, body)
  let scheme = call_605462.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605462.url(scheme.get, call_605462.host, call_605462.base,
                         call_605462.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605462, url, valid)

proc call*(call_605463: Call_RegisterThing_605451; body: JsonNode): Recallable =
  ## registerThing
  ## Provisions a thing.
  ##   body: JObject (required)
  var body_605464 = newJObject()
  if body != nil:
    body_605464 = body
  result = call_605463.call(nil, nil, nil, nil, body_605464)

var registerThing* = Call_RegisterThing_605451(name: "registerThing",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/things",
    validator: validate_RegisterThing_605452, base: "/", url: url_RegisterThing_605453,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThings_605433 = ref object of OpenApiRestCall_602466
proc url_ListThings_605435(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListThings_605434(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingTypeName: JString
  ##                : The name of the thing type used to search for things.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   attributeValue: JString
  ##                 : The attribute value used to search for things.
  ##   attributeName: JString
  ##                : The attribute name used to search for things.
  section = newJObject()
  var valid_605436 = query.getOrDefault("thingTypeName")
  valid_605436 = validateParameter(valid_605436, JString, required = false,
                                 default = nil)
  if valid_605436 != nil:
    section.add "thingTypeName", valid_605436
  var valid_605437 = query.getOrDefault("maxResults")
  valid_605437 = validateParameter(valid_605437, JInt, required = false, default = nil)
  if valid_605437 != nil:
    section.add "maxResults", valid_605437
  var valid_605438 = query.getOrDefault("nextToken")
  valid_605438 = validateParameter(valid_605438, JString, required = false,
                                 default = nil)
  if valid_605438 != nil:
    section.add "nextToken", valid_605438
  var valid_605439 = query.getOrDefault("attributeValue")
  valid_605439 = validateParameter(valid_605439, JString, required = false,
                                 default = nil)
  if valid_605439 != nil:
    section.add "attributeValue", valid_605439
  var valid_605440 = query.getOrDefault("attributeName")
  valid_605440 = validateParameter(valid_605440, JString, required = false,
                                 default = nil)
  if valid_605440 != nil:
    section.add "attributeName", valid_605440
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605441 = header.getOrDefault("X-Amz-Date")
  valid_605441 = validateParameter(valid_605441, JString, required = false,
                                 default = nil)
  if valid_605441 != nil:
    section.add "X-Amz-Date", valid_605441
  var valid_605442 = header.getOrDefault("X-Amz-Security-Token")
  valid_605442 = validateParameter(valid_605442, JString, required = false,
                                 default = nil)
  if valid_605442 != nil:
    section.add "X-Amz-Security-Token", valid_605442
  var valid_605443 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605443 = validateParameter(valid_605443, JString, required = false,
                                 default = nil)
  if valid_605443 != nil:
    section.add "X-Amz-Content-Sha256", valid_605443
  var valid_605444 = header.getOrDefault("X-Amz-Algorithm")
  valid_605444 = validateParameter(valid_605444, JString, required = false,
                                 default = nil)
  if valid_605444 != nil:
    section.add "X-Amz-Algorithm", valid_605444
  var valid_605445 = header.getOrDefault("X-Amz-Signature")
  valid_605445 = validateParameter(valid_605445, JString, required = false,
                                 default = nil)
  if valid_605445 != nil:
    section.add "X-Amz-Signature", valid_605445
  var valid_605446 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605446 = validateParameter(valid_605446, JString, required = false,
                                 default = nil)
  if valid_605446 != nil:
    section.add "X-Amz-SignedHeaders", valid_605446
  var valid_605447 = header.getOrDefault("X-Amz-Credential")
  valid_605447 = validateParameter(valid_605447, JString, required = false,
                                 default = nil)
  if valid_605447 != nil:
    section.add "X-Amz-Credential", valid_605447
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605448: Call_ListThings_605433; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ## 
  let valid = call_605448.validator(path, query, header, formData, body)
  let scheme = call_605448.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605448.url(scheme.get, call_605448.host, call_605448.base,
                         call_605448.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605448, url, valid)

proc call*(call_605449: Call_ListThings_605433; thingTypeName: string = "";
          maxResults: int = 0; nextToken: string = ""; attributeValue: string = "";
          attributeName: string = ""): Recallable =
  ## listThings
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ##   thingTypeName: string
  ##                : The name of the thing type used to search for things.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   attributeValue: string
  ##                 : The attribute value used to search for things.
  ##   attributeName: string
  ##                : The attribute name used to search for things.
  var query_605450 = newJObject()
  add(query_605450, "thingTypeName", newJString(thingTypeName))
  add(query_605450, "maxResults", newJInt(maxResults))
  add(query_605450, "nextToken", newJString(nextToken))
  add(query_605450, "attributeValue", newJString(attributeValue))
  add(query_605450, "attributeName", newJString(attributeName))
  result = call_605449.call(nil, query_605450, nil, nil, nil)

var listThings* = Call_ListThings_605433(name: "listThings",
                                      meth: HttpMethod.HttpGet,
                                      host: "iot.amazonaws.com", route: "/things",
                                      validator: validate_ListThings_605434,
                                      base: "/", url: url_ListThings_605435,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingsInBillingGroup_605465 = ref object of OpenApiRestCall_602466
proc url_ListThingsInBillingGroup_605467(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListThingsInBillingGroup_605466(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the things you have added to the given billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_605468 = path.getOrDefault("billingGroupName")
  valid_605468 = validateParameter(valid_605468, JString, required = true,
                                 default = nil)
  if valid_605468 != nil:
    section.add "billingGroupName", valid_605468
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  section = newJObject()
  var valid_605469 = query.getOrDefault("maxResults")
  valid_605469 = validateParameter(valid_605469, JInt, required = false, default = nil)
  if valid_605469 != nil:
    section.add "maxResults", valid_605469
  var valid_605470 = query.getOrDefault("nextToken")
  valid_605470 = validateParameter(valid_605470, JString, required = false,
                                 default = nil)
  if valid_605470 != nil:
    section.add "nextToken", valid_605470
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605471 = header.getOrDefault("X-Amz-Date")
  valid_605471 = validateParameter(valid_605471, JString, required = false,
                                 default = nil)
  if valid_605471 != nil:
    section.add "X-Amz-Date", valid_605471
  var valid_605472 = header.getOrDefault("X-Amz-Security-Token")
  valid_605472 = validateParameter(valid_605472, JString, required = false,
                                 default = nil)
  if valid_605472 != nil:
    section.add "X-Amz-Security-Token", valid_605472
  var valid_605473 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605473 = validateParameter(valid_605473, JString, required = false,
                                 default = nil)
  if valid_605473 != nil:
    section.add "X-Amz-Content-Sha256", valid_605473
  var valid_605474 = header.getOrDefault("X-Amz-Algorithm")
  valid_605474 = validateParameter(valid_605474, JString, required = false,
                                 default = nil)
  if valid_605474 != nil:
    section.add "X-Amz-Algorithm", valid_605474
  var valid_605475 = header.getOrDefault("X-Amz-Signature")
  valid_605475 = validateParameter(valid_605475, JString, required = false,
                                 default = nil)
  if valid_605475 != nil:
    section.add "X-Amz-Signature", valid_605475
  var valid_605476 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605476 = validateParameter(valid_605476, JString, required = false,
                                 default = nil)
  if valid_605476 != nil:
    section.add "X-Amz-SignedHeaders", valid_605476
  var valid_605477 = header.getOrDefault("X-Amz-Credential")
  valid_605477 = validateParameter(valid_605477, JString, required = false,
                                 default = nil)
  if valid_605477 != nil:
    section.add "X-Amz-Credential", valid_605477
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605478: Call_ListThingsInBillingGroup_605465; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things you have added to the given billing group.
  ## 
  let valid = call_605478.validator(path, query, header, formData, body)
  let scheme = call_605478.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605478.url(scheme.get, call_605478.host, call_605478.base,
                         call_605478.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605478, url, valid)

proc call*(call_605479: Call_ListThingsInBillingGroup_605465;
          billingGroupName: string; maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listThingsInBillingGroup
  ## Lists the things you have added to the given billing group.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  var path_605480 = newJObject()
  var query_605481 = newJObject()
  add(path_605480, "billingGroupName", newJString(billingGroupName))
  add(query_605481, "maxResults", newJInt(maxResults))
  add(query_605481, "nextToken", newJString(nextToken))
  result = call_605479.call(path_605480, query_605481, nil, nil, nil)

var listThingsInBillingGroup* = Call_ListThingsInBillingGroup_605465(
    name: "listThingsInBillingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}/things",
    validator: validate_ListThingsInBillingGroup_605466, base: "/",
    url: url_ListThingsInBillingGroup_605467, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingsInThingGroup_605482 = ref object of OpenApiRestCall_602466
proc url_ListThingsInThingGroup_605484(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ListThingsInThingGroup_605483(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the things in the specified group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_605485 = path.getOrDefault("thingGroupName")
  valid_605485 = validateParameter(valid_605485, JString, required = true,
                                 default = nil)
  if valid_605485 != nil:
    section.add "thingGroupName", valid_605485
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   recursive: JBool
  ##            : When true, list things in this thing group and in all child groups as well.
  section = newJObject()
  var valid_605486 = query.getOrDefault("maxResults")
  valid_605486 = validateParameter(valid_605486, JInt, required = false, default = nil)
  if valid_605486 != nil:
    section.add "maxResults", valid_605486
  var valid_605487 = query.getOrDefault("nextToken")
  valid_605487 = validateParameter(valid_605487, JString, required = false,
                                 default = nil)
  if valid_605487 != nil:
    section.add "nextToken", valid_605487
  var valid_605488 = query.getOrDefault("recursive")
  valid_605488 = validateParameter(valid_605488, JBool, required = false, default = nil)
  if valid_605488 != nil:
    section.add "recursive", valid_605488
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605489 = header.getOrDefault("X-Amz-Date")
  valid_605489 = validateParameter(valid_605489, JString, required = false,
                                 default = nil)
  if valid_605489 != nil:
    section.add "X-Amz-Date", valid_605489
  var valid_605490 = header.getOrDefault("X-Amz-Security-Token")
  valid_605490 = validateParameter(valid_605490, JString, required = false,
                                 default = nil)
  if valid_605490 != nil:
    section.add "X-Amz-Security-Token", valid_605490
  var valid_605491 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605491 = validateParameter(valid_605491, JString, required = false,
                                 default = nil)
  if valid_605491 != nil:
    section.add "X-Amz-Content-Sha256", valid_605491
  var valid_605492 = header.getOrDefault("X-Amz-Algorithm")
  valid_605492 = validateParameter(valid_605492, JString, required = false,
                                 default = nil)
  if valid_605492 != nil:
    section.add "X-Amz-Algorithm", valid_605492
  var valid_605493 = header.getOrDefault("X-Amz-Signature")
  valid_605493 = validateParameter(valid_605493, JString, required = false,
                                 default = nil)
  if valid_605493 != nil:
    section.add "X-Amz-Signature", valid_605493
  var valid_605494 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605494 = validateParameter(valid_605494, JString, required = false,
                                 default = nil)
  if valid_605494 != nil:
    section.add "X-Amz-SignedHeaders", valid_605494
  var valid_605495 = header.getOrDefault("X-Amz-Credential")
  valid_605495 = validateParameter(valid_605495, JString, required = false,
                                 default = nil)
  if valid_605495 != nil:
    section.add "X-Amz-Credential", valid_605495
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605496: Call_ListThingsInThingGroup_605482; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things in the specified group.
  ## 
  let valid = call_605496.validator(path, query, header, formData, body)
  let scheme = call_605496.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605496.url(scheme.get, call_605496.host, call_605496.base,
                         call_605496.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605496, url, valid)

proc call*(call_605497: Call_ListThingsInThingGroup_605482; thingGroupName: string;
          maxResults: int = 0; nextToken: string = ""; recursive: bool = false): Recallable =
  ## listThingsInThingGroup
  ## Lists the things in the specified group.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: string (required)
  ##                 : The thing group name.
  ##   recursive: bool
  ##            : When true, list things in this thing group and in all child groups as well.
  var path_605498 = newJObject()
  var query_605499 = newJObject()
  add(query_605499, "maxResults", newJInt(maxResults))
  add(query_605499, "nextToken", newJString(nextToken))
  add(path_605498, "thingGroupName", newJString(thingGroupName))
  add(query_605499, "recursive", newJBool(recursive))
  result = call_605497.call(path_605498, query_605499, nil, nil, nil)

var listThingsInThingGroup* = Call_ListThingsInThingGroup_605482(
    name: "listThingsInThingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-groups/{thingGroupName}/things",
    validator: validate_ListThingsInThingGroup_605483, base: "/",
    url: url_ListThingsInThingGroup_605484, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTopicRules_605500 = ref object of OpenApiRestCall_602466
proc url_ListTopicRules_605502(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListTopicRules_605501(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the rules for the specific topic.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   maxResults: JInt
  ##             : The maximum number of results to return.
  ##   nextToken: JString
  ##            : A token used to retrieve the next value.
  ##   topic: JString
  ##        : The topic.
  ##   ruleDisabled: JBool
  ##               : Specifies whether the rule is disabled.
  section = newJObject()
  var valid_605503 = query.getOrDefault("maxResults")
  valid_605503 = validateParameter(valid_605503, JInt, required = false, default = nil)
  if valid_605503 != nil:
    section.add "maxResults", valid_605503
  var valid_605504 = query.getOrDefault("nextToken")
  valid_605504 = validateParameter(valid_605504, JString, required = false,
                                 default = nil)
  if valid_605504 != nil:
    section.add "nextToken", valid_605504
  var valid_605505 = query.getOrDefault("topic")
  valid_605505 = validateParameter(valid_605505, JString, required = false,
                                 default = nil)
  if valid_605505 != nil:
    section.add "topic", valid_605505
  var valid_605506 = query.getOrDefault("ruleDisabled")
  valid_605506 = validateParameter(valid_605506, JBool, required = false, default = nil)
  if valid_605506 != nil:
    section.add "ruleDisabled", valid_605506
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605507 = header.getOrDefault("X-Amz-Date")
  valid_605507 = validateParameter(valid_605507, JString, required = false,
                                 default = nil)
  if valid_605507 != nil:
    section.add "X-Amz-Date", valid_605507
  var valid_605508 = header.getOrDefault("X-Amz-Security-Token")
  valid_605508 = validateParameter(valid_605508, JString, required = false,
                                 default = nil)
  if valid_605508 != nil:
    section.add "X-Amz-Security-Token", valid_605508
  var valid_605509 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605509 = validateParameter(valid_605509, JString, required = false,
                                 default = nil)
  if valid_605509 != nil:
    section.add "X-Amz-Content-Sha256", valid_605509
  var valid_605510 = header.getOrDefault("X-Amz-Algorithm")
  valid_605510 = validateParameter(valid_605510, JString, required = false,
                                 default = nil)
  if valid_605510 != nil:
    section.add "X-Amz-Algorithm", valid_605510
  var valid_605511 = header.getOrDefault("X-Amz-Signature")
  valid_605511 = validateParameter(valid_605511, JString, required = false,
                                 default = nil)
  if valid_605511 != nil:
    section.add "X-Amz-Signature", valid_605511
  var valid_605512 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605512 = validateParameter(valid_605512, JString, required = false,
                                 default = nil)
  if valid_605512 != nil:
    section.add "X-Amz-SignedHeaders", valid_605512
  var valid_605513 = header.getOrDefault("X-Amz-Credential")
  valid_605513 = validateParameter(valid_605513, JString, required = false,
                                 default = nil)
  if valid_605513 != nil:
    section.add "X-Amz-Credential", valid_605513
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605514: Call_ListTopicRules_605500; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the rules for the specific topic.
  ## 
  let valid = call_605514.validator(path, query, header, formData, body)
  let scheme = call_605514.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605514.url(scheme.get, call_605514.host, call_605514.base,
                         call_605514.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605514, url, valid)

proc call*(call_605515: Call_ListTopicRules_605500; maxResults: int = 0;
          nextToken: string = ""; topic: string = ""; ruleDisabled: bool = false): Recallable =
  ## listTopicRules
  ## Lists the rules for the specific topic.
  ##   maxResults: int
  ##             : The maximum number of results to return.
  ##   nextToken: string
  ##            : A token used to retrieve the next value.
  ##   topic: string
  ##        : The topic.
  ##   ruleDisabled: bool
  ##               : Specifies whether the rule is disabled.
  var query_605516 = newJObject()
  add(query_605516, "maxResults", newJInt(maxResults))
  add(query_605516, "nextToken", newJString(nextToken))
  add(query_605516, "topic", newJString(topic))
  add(query_605516, "ruleDisabled", newJBool(ruleDisabled))
  result = call_605515.call(nil, query_605516, nil, nil, nil)

var listTopicRules* = Call_ListTopicRules_605500(name: "listTopicRules",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/rules",
    validator: validate_ListTopicRules_605501, base: "/", url: url_ListTopicRules_605502,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetV2LoggingLevel_605533 = ref object of OpenApiRestCall_602466
proc url_SetV2LoggingLevel_605535(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_SetV2LoggingLevel_605534(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Sets the logging level.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605536 = header.getOrDefault("X-Amz-Date")
  valid_605536 = validateParameter(valid_605536, JString, required = false,
                                 default = nil)
  if valid_605536 != nil:
    section.add "X-Amz-Date", valid_605536
  var valid_605537 = header.getOrDefault("X-Amz-Security-Token")
  valid_605537 = validateParameter(valid_605537, JString, required = false,
                                 default = nil)
  if valid_605537 != nil:
    section.add "X-Amz-Security-Token", valid_605537
  var valid_605538 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605538 = validateParameter(valid_605538, JString, required = false,
                                 default = nil)
  if valid_605538 != nil:
    section.add "X-Amz-Content-Sha256", valid_605538
  var valid_605539 = header.getOrDefault("X-Amz-Algorithm")
  valid_605539 = validateParameter(valid_605539, JString, required = false,
                                 default = nil)
  if valid_605539 != nil:
    section.add "X-Amz-Algorithm", valid_605539
  var valid_605540 = header.getOrDefault("X-Amz-Signature")
  valid_605540 = validateParameter(valid_605540, JString, required = false,
                                 default = nil)
  if valid_605540 != nil:
    section.add "X-Amz-Signature", valid_605540
  var valid_605541 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605541 = validateParameter(valid_605541, JString, required = false,
                                 default = nil)
  if valid_605541 != nil:
    section.add "X-Amz-SignedHeaders", valid_605541
  var valid_605542 = header.getOrDefault("X-Amz-Credential")
  valid_605542 = validateParameter(valid_605542, JString, required = false,
                                 default = nil)
  if valid_605542 != nil:
    section.add "X-Amz-Credential", valid_605542
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605544: Call_SetV2LoggingLevel_605533; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the logging level.
  ## 
  let valid = call_605544.validator(path, query, header, formData, body)
  let scheme = call_605544.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605544.url(scheme.get, call_605544.host, call_605544.base,
                         call_605544.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605544, url, valid)

proc call*(call_605545: Call_SetV2LoggingLevel_605533; body: JsonNode): Recallable =
  ## setV2LoggingLevel
  ## Sets the logging level.
  ##   body: JObject (required)
  var body_605546 = newJObject()
  if body != nil:
    body_605546 = body
  result = call_605545.call(nil, nil, nil, nil, body_605546)

var setV2LoggingLevel* = Call_SetV2LoggingLevel_605533(name: "setV2LoggingLevel",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/v2LoggingLevel",
    validator: validate_SetV2LoggingLevel_605534, base: "/",
    url: url_SetV2LoggingLevel_605535, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListV2LoggingLevels_605517 = ref object of OpenApiRestCall_602466
proc url_ListV2LoggingLevels_605519(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListV2LoggingLevels_605518(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists logging levels.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   targetType: JString
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token used to get the next set of results, or <b>null</b> if there are no additional results.
  section = newJObject()
  var valid_605520 = query.getOrDefault("targetType")
  valid_605520 = validateParameter(valid_605520, JString, required = false,
                                 default = newJString("DEFAULT"))
  if valid_605520 != nil:
    section.add "targetType", valid_605520
  var valid_605521 = query.getOrDefault("maxResults")
  valid_605521 = validateParameter(valid_605521, JInt, required = false, default = nil)
  if valid_605521 != nil:
    section.add "maxResults", valid_605521
  var valid_605522 = query.getOrDefault("nextToken")
  valid_605522 = validateParameter(valid_605522, JString, required = false,
                                 default = nil)
  if valid_605522 != nil:
    section.add "nextToken", valid_605522
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605523 = header.getOrDefault("X-Amz-Date")
  valid_605523 = validateParameter(valid_605523, JString, required = false,
                                 default = nil)
  if valid_605523 != nil:
    section.add "X-Amz-Date", valid_605523
  var valid_605524 = header.getOrDefault("X-Amz-Security-Token")
  valid_605524 = validateParameter(valid_605524, JString, required = false,
                                 default = nil)
  if valid_605524 != nil:
    section.add "X-Amz-Security-Token", valid_605524
  var valid_605525 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605525 = validateParameter(valid_605525, JString, required = false,
                                 default = nil)
  if valid_605525 != nil:
    section.add "X-Amz-Content-Sha256", valid_605525
  var valid_605526 = header.getOrDefault("X-Amz-Algorithm")
  valid_605526 = validateParameter(valid_605526, JString, required = false,
                                 default = nil)
  if valid_605526 != nil:
    section.add "X-Amz-Algorithm", valid_605526
  var valid_605527 = header.getOrDefault("X-Amz-Signature")
  valid_605527 = validateParameter(valid_605527, JString, required = false,
                                 default = nil)
  if valid_605527 != nil:
    section.add "X-Amz-Signature", valid_605527
  var valid_605528 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605528 = validateParameter(valid_605528, JString, required = false,
                                 default = nil)
  if valid_605528 != nil:
    section.add "X-Amz-SignedHeaders", valid_605528
  var valid_605529 = header.getOrDefault("X-Amz-Credential")
  valid_605529 = validateParameter(valid_605529, JString, required = false,
                                 default = nil)
  if valid_605529 != nil:
    section.add "X-Amz-Credential", valid_605529
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605530: Call_ListV2LoggingLevels_605517; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists logging levels.
  ## 
  let valid = call_605530.validator(path, query, header, formData, body)
  let scheme = call_605530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605530.url(scheme.get, call_605530.host, call_605530.base,
                         call_605530.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605530, url, valid)

proc call*(call_605531: Call_ListV2LoggingLevels_605517;
          targetType: string = "DEFAULT"; maxResults: int = 0; nextToken: string = ""): Recallable =
  ## listV2LoggingLevels
  ## Lists logging levels.
  ##   targetType: string
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token used to get the next set of results, or <b>null</b> if there are no additional results.
  var query_605532 = newJObject()
  add(query_605532, "targetType", newJString(targetType))
  add(query_605532, "maxResults", newJInt(maxResults))
  add(query_605532, "nextToken", newJString(nextToken))
  result = call_605531.call(nil, query_605532, nil, nil, nil)

var listV2LoggingLevels* = Call_ListV2LoggingLevels_605517(
    name: "listV2LoggingLevels", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/v2LoggingLevel",
    validator: validate_ListV2LoggingLevels_605518, base: "/",
    url: url_ListV2LoggingLevels_605519, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListViolationEvents_605547 = ref object of OpenApiRestCall_602466
proc url_ListViolationEvents_605549(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ListViolationEvents_605548(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingName: JString
  ##            : A filter to limit results to those alerts caused by the specified thing.
  ##   endTime: JString (required)
  ##          : The end time for the alerts to be listed.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   securityProfileName: JString
  ##                      : A filter to limit results to those alerts generated by the specified security profile.
  ##   startTime: JString (required)
  ##            : The start time for the alerts to be listed.
  section = newJObject()
  var valid_605550 = query.getOrDefault("thingName")
  valid_605550 = validateParameter(valid_605550, JString, required = false,
                                 default = nil)
  if valid_605550 != nil:
    section.add "thingName", valid_605550
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_605551 = query.getOrDefault("endTime")
  valid_605551 = validateParameter(valid_605551, JString, required = true,
                                 default = nil)
  if valid_605551 != nil:
    section.add "endTime", valid_605551
  var valid_605552 = query.getOrDefault("maxResults")
  valid_605552 = validateParameter(valid_605552, JInt, required = false, default = nil)
  if valid_605552 != nil:
    section.add "maxResults", valid_605552
  var valid_605553 = query.getOrDefault("nextToken")
  valid_605553 = validateParameter(valid_605553, JString, required = false,
                                 default = nil)
  if valid_605553 != nil:
    section.add "nextToken", valid_605553
  var valid_605554 = query.getOrDefault("securityProfileName")
  valid_605554 = validateParameter(valid_605554, JString, required = false,
                                 default = nil)
  if valid_605554 != nil:
    section.add "securityProfileName", valid_605554
  var valid_605555 = query.getOrDefault("startTime")
  valid_605555 = validateParameter(valid_605555, JString, required = true,
                                 default = nil)
  if valid_605555 != nil:
    section.add "startTime", valid_605555
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605556 = header.getOrDefault("X-Amz-Date")
  valid_605556 = validateParameter(valid_605556, JString, required = false,
                                 default = nil)
  if valid_605556 != nil:
    section.add "X-Amz-Date", valid_605556
  var valid_605557 = header.getOrDefault("X-Amz-Security-Token")
  valid_605557 = validateParameter(valid_605557, JString, required = false,
                                 default = nil)
  if valid_605557 != nil:
    section.add "X-Amz-Security-Token", valid_605557
  var valid_605558 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605558 = validateParameter(valid_605558, JString, required = false,
                                 default = nil)
  if valid_605558 != nil:
    section.add "X-Amz-Content-Sha256", valid_605558
  var valid_605559 = header.getOrDefault("X-Amz-Algorithm")
  valid_605559 = validateParameter(valid_605559, JString, required = false,
                                 default = nil)
  if valid_605559 != nil:
    section.add "X-Amz-Algorithm", valid_605559
  var valid_605560 = header.getOrDefault("X-Amz-Signature")
  valid_605560 = validateParameter(valid_605560, JString, required = false,
                                 default = nil)
  if valid_605560 != nil:
    section.add "X-Amz-Signature", valid_605560
  var valid_605561 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605561 = validateParameter(valid_605561, JString, required = false,
                                 default = nil)
  if valid_605561 != nil:
    section.add "X-Amz-SignedHeaders", valid_605561
  var valid_605562 = header.getOrDefault("X-Amz-Credential")
  valid_605562 = validateParameter(valid_605562, JString, required = false,
                                 default = nil)
  if valid_605562 != nil:
    section.add "X-Amz-Credential", valid_605562
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605563: Call_ListViolationEvents_605547; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ## 
  let valid = call_605563.validator(path, query, header, formData, body)
  let scheme = call_605563.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605563.url(scheme.get, call_605563.host, call_605563.base,
                         call_605563.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605563, url, valid)

proc call*(call_605564: Call_ListViolationEvents_605547; endTime: string;
          startTime: string; thingName: string = ""; maxResults: int = 0;
          nextToken: string = ""; securityProfileName: string = ""): Recallable =
  ## listViolationEvents
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ##   thingName: string
  ##            : A filter to limit results to those alerts caused by the specified thing.
  ##   endTime: string (required)
  ##          : The end time for the alerts to be listed.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string
  ##                      : A filter to limit results to those alerts generated by the specified security profile.
  ##   startTime: string (required)
  ##            : The start time for the alerts to be listed.
  var query_605565 = newJObject()
  add(query_605565, "thingName", newJString(thingName))
  add(query_605565, "endTime", newJString(endTime))
  add(query_605565, "maxResults", newJInt(maxResults))
  add(query_605565, "nextToken", newJString(nextToken))
  add(query_605565, "securityProfileName", newJString(securityProfileName))
  add(query_605565, "startTime", newJString(startTime))
  result = call_605564.call(nil, query_605565, nil, nil, nil)

var listViolationEvents* = Call_ListViolationEvents_605547(
    name: "listViolationEvents", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/violation-events#startTime&endTime",
    validator: validate_ListViolationEvents_605548, base: "/",
    url: url_ListViolationEvents_605549, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterCACertificate_605566 = ref object of OpenApiRestCall_602466
proc url_RegisterCACertificate_605568(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RegisterCACertificate_605567(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : A boolean value that specifies if the CA certificate is set to active.
  ##   allowAutoRegistration: JBool
  ##                        : Allows this CA certificate to be used for auto registration of device certificates.
  section = newJObject()
  var valid_605569 = query.getOrDefault("setAsActive")
  valid_605569 = validateParameter(valid_605569, JBool, required = false, default = nil)
  if valid_605569 != nil:
    section.add "setAsActive", valid_605569
  var valid_605570 = query.getOrDefault("allowAutoRegistration")
  valid_605570 = validateParameter(valid_605570, JBool, required = false, default = nil)
  if valid_605570 != nil:
    section.add "allowAutoRegistration", valid_605570
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605571 = header.getOrDefault("X-Amz-Date")
  valid_605571 = validateParameter(valid_605571, JString, required = false,
                                 default = nil)
  if valid_605571 != nil:
    section.add "X-Amz-Date", valid_605571
  var valid_605572 = header.getOrDefault("X-Amz-Security-Token")
  valid_605572 = validateParameter(valid_605572, JString, required = false,
                                 default = nil)
  if valid_605572 != nil:
    section.add "X-Amz-Security-Token", valid_605572
  var valid_605573 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605573 = validateParameter(valid_605573, JString, required = false,
                                 default = nil)
  if valid_605573 != nil:
    section.add "X-Amz-Content-Sha256", valid_605573
  var valid_605574 = header.getOrDefault("X-Amz-Algorithm")
  valid_605574 = validateParameter(valid_605574, JString, required = false,
                                 default = nil)
  if valid_605574 != nil:
    section.add "X-Amz-Algorithm", valid_605574
  var valid_605575 = header.getOrDefault("X-Amz-Signature")
  valid_605575 = validateParameter(valid_605575, JString, required = false,
                                 default = nil)
  if valid_605575 != nil:
    section.add "X-Amz-Signature", valid_605575
  var valid_605576 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605576 = validateParameter(valid_605576, JString, required = false,
                                 default = nil)
  if valid_605576 != nil:
    section.add "X-Amz-SignedHeaders", valid_605576
  var valid_605577 = header.getOrDefault("X-Amz-Credential")
  valid_605577 = validateParameter(valid_605577, JString, required = false,
                                 default = nil)
  if valid_605577 != nil:
    section.add "X-Amz-Credential", valid_605577
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605579: Call_RegisterCACertificate_605566; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ## 
  let valid = call_605579.validator(path, query, header, formData, body)
  let scheme = call_605579.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605579.url(scheme.get, call_605579.host, call_605579.base,
                         call_605579.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605579, url, valid)

proc call*(call_605580: Call_RegisterCACertificate_605566; body: JsonNode;
          setAsActive: bool = false; allowAutoRegistration: bool = false): Recallable =
  ## registerCACertificate
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ##   setAsActive: bool
  ##              : A boolean value that specifies if the CA certificate is set to active.
  ##   body: JObject (required)
  ##   allowAutoRegistration: bool
  ##                        : Allows this CA certificate to be used for auto registration of device certificates.
  var query_605581 = newJObject()
  var body_605582 = newJObject()
  add(query_605581, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_605582 = body
  add(query_605581, "allowAutoRegistration", newJBool(allowAutoRegistration))
  result = call_605580.call(nil, query_605581, nil, nil, body_605582)

var registerCACertificate* = Call_RegisterCACertificate_605566(
    name: "registerCACertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/cacertificate",
    validator: validate_RegisterCACertificate_605567, base: "/",
    url: url_RegisterCACertificate_605568, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterCertificate_605583 = ref object of OpenApiRestCall_602466
proc url_RegisterCertificate_605585(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RegisterCertificate_605584(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : A boolean value that specifies if the certificate is set to active.
  section = newJObject()
  var valid_605586 = query.getOrDefault("setAsActive")
  valid_605586 = validateParameter(valid_605586, JBool, required = false, default = nil)
  if valid_605586 != nil:
    section.add "setAsActive", valid_605586
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605587 = header.getOrDefault("X-Amz-Date")
  valid_605587 = validateParameter(valid_605587, JString, required = false,
                                 default = nil)
  if valid_605587 != nil:
    section.add "X-Amz-Date", valid_605587
  var valid_605588 = header.getOrDefault("X-Amz-Security-Token")
  valid_605588 = validateParameter(valid_605588, JString, required = false,
                                 default = nil)
  if valid_605588 != nil:
    section.add "X-Amz-Security-Token", valid_605588
  var valid_605589 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605589 = validateParameter(valid_605589, JString, required = false,
                                 default = nil)
  if valid_605589 != nil:
    section.add "X-Amz-Content-Sha256", valid_605589
  var valid_605590 = header.getOrDefault("X-Amz-Algorithm")
  valid_605590 = validateParameter(valid_605590, JString, required = false,
                                 default = nil)
  if valid_605590 != nil:
    section.add "X-Amz-Algorithm", valid_605590
  var valid_605591 = header.getOrDefault("X-Amz-Signature")
  valid_605591 = validateParameter(valid_605591, JString, required = false,
                                 default = nil)
  if valid_605591 != nil:
    section.add "X-Amz-Signature", valid_605591
  var valid_605592 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605592 = validateParameter(valid_605592, JString, required = false,
                                 default = nil)
  if valid_605592 != nil:
    section.add "X-Amz-SignedHeaders", valid_605592
  var valid_605593 = header.getOrDefault("X-Amz-Credential")
  valid_605593 = validateParameter(valid_605593, JString, required = false,
                                 default = nil)
  if valid_605593 != nil:
    section.add "X-Amz-Credential", valid_605593
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605595: Call_RegisterCertificate_605583; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ## 
  let valid = call_605595.validator(path, query, header, formData, body)
  let scheme = call_605595.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605595.url(scheme.get, call_605595.host, call_605595.base,
                         call_605595.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605595, url, valid)

proc call*(call_605596: Call_RegisterCertificate_605583; body: JsonNode;
          setAsActive: bool = false): Recallable =
  ## registerCertificate
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ##   setAsActive: bool
  ##              : A boolean value that specifies if the certificate is set to active.
  ##   body: JObject (required)
  var query_605597 = newJObject()
  var body_605598 = newJObject()
  add(query_605597, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_605598 = body
  result = call_605596.call(nil, query_605597, nil, nil, body_605598)

var registerCertificate* = Call_RegisterCertificate_605583(
    name: "registerCertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/certificate/register",
    validator: validate_RegisterCertificate_605584, base: "/",
    url: url_RegisterCertificate_605585, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RejectCertificateTransfer_605599 = ref object of OpenApiRestCall_602466
proc url_RejectCertificateTransfer_605601(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/reject-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RejectCertificateTransfer_605600(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_605602 = path.getOrDefault("certificateId")
  valid_605602 = validateParameter(valid_605602, JString, required = true,
                                 default = nil)
  if valid_605602 != nil:
    section.add "certificateId", valid_605602
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605603 = header.getOrDefault("X-Amz-Date")
  valid_605603 = validateParameter(valid_605603, JString, required = false,
                                 default = nil)
  if valid_605603 != nil:
    section.add "X-Amz-Date", valid_605603
  var valid_605604 = header.getOrDefault("X-Amz-Security-Token")
  valid_605604 = validateParameter(valid_605604, JString, required = false,
                                 default = nil)
  if valid_605604 != nil:
    section.add "X-Amz-Security-Token", valid_605604
  var valid_605605 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605605 = validateParameter(valid_605605, JString, required = false,
                                 default = nil)
  if valid_605605 != nil:
    section.add "X-Amz-Content-Sha256", valid_605605
  var valid_605606 = header.getOrDefault("X-Amz-Algorithm")
  valid_605606 = validateParameter(valid_605606, JString, required = false,
                                 default = nil)
  if valid_605606 != nil:
    section.add "X-Amz-Algorithm", valid_605606
  var valid_605607 = header.getOrDefault("X-Amz-Signature")
  valid_605607 = validateParameter(valid_605607, JString, required = false,
                                 default = nil)
  if valid_605607 != nil:
    section.add "X-Amz-Signature", valid_605607
  var valid_605608 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605608 = validateParameter(valid_605608, JString, required = false,
                                 default = nil)
  if valid_605608 != nil:
    section.add "X-Amz-SignedHeaders", valid_605608
  var valid_605609 = header.getOrDefault("X-Amz-Credential")
  valid_605609 = validateParameter(valid_605609, JString, required = false,
                                 default = nil)
  if valid_605609 != nil:
    section.add "X-Amz-Credential", valid_605609
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605611: Call_RejectCertificateTransfer_605599; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ## 
  let valid = call_605611.validator(path, query, header, formData, body)
  let scheme = call_605611.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605611.url(scheme.get, call_605611.host, call_605611.base,
                         call_605611.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605611, url, valid)

proc call*(call_605612: Call_RejectCertificateTransfer_605599;
          certificateId: string; body: JsonNode): Recallable =
  ## rejectCertificateTransfer
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   body: JObject (required)
  var path_605613 = newJObject()
  var body_605614 = newJObject()
  add(path_605613, "certificateId", newJString(certificateId))
  if body != nil:
    body_605614 = body
  result = call_605612.call(path_605613, nil, nil, nil, body_605614)

var rejectCertificateTransfer* = Call_RejectCertificateTransfer_605599(
    name: "rejectCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/reject-certificate-transfer/{certificateId}",
    validator: validate_RejectCertificateTransfer_605600, base: "/",
    url: url_RejectCertificateTransfer_605601,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveThingFromBillingGroup_605615 = ref object of OpenApiRestCall_602466
proc url_RemoveThingFromBillingGroup_605617(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RemoveThingFromBillingGroup_605616(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes the given thing from the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605618 = header.getOrDefault("X-Amz-Date")
  valid_605618 = validateParameter(valid_605618, JString, required = false,
                                 default = nil)
  if valid_605618 != nil:
    section.add "X-Amz-Date", valid_605618
  var valid_605619 = header.getOrDefault("X-Amz-Security-Token")
  valid_605619 = validateParameter(valid_605619, JString, required = false,
                                 default = nil)
  if valid_605619 != nil:
    section.add "X-Amz-Security-Token", valid_605619
  var valid_605620 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605620 = validateParameter(valid_605620, JString, required = false,
                                 default = nil)
  if valid_605620 != nil:
    section.add "X-Amz-Content-Sha256", valid_605620
  var valid_605621 = header.getOrDefault("X-Amz-Algorithm")
  valid_605621 = validateParameter(valid_605621, JString, required = false,
                                 default = nil)
  if valid_605621 != nil:
    section.add "X-Amz-Algorithm", valid_605621
  var valid_605622 = header.getOrDefault("X-Amz-Signature")
  valid_605622 = validateParameter(valid_605622, JString, required = false,
                                 default = nil)
  if valid_605622 != nil:
    section.add "X-Amz-Signature", valid_605622
  var valid_605623 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605623 = validateParameter(valid_605623, JString, required = false,
                                 default = nil)
  if valid_605623 != nil:
    section.add "X-Amz-SignedHeaders", valid_605623
  var valid_605624 = header.getOrDefault("X-Amz-Credential")
  valid_605624 = validateParameter(valid_605624, JString, required = false,
                                 default = nil)
  if valid_605624 != nil:
    section.add "X-Amz-Credential", valid_605624
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605626: Call_RemoveThingFromBillingGroup_605615; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes the given thing from the billing group.
  ## 
  let valid = call_605626.validator(path, query, header, formData, body)
  let scheme = call_605626.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605626.url(scheme.get, call_605626.host, call_605626.base,
                         call_605626.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605626, url, valid)

proc call*(call_605627: Call_RemoveThingFromBillingGroup_605615; body: JsonNode): Recallable =
  ## removeThingFromBillingGroup
  ## Removes the given thing from the billing group.
  ##   body: JObject (required)
  var body_605628 = newJObject()
  if body != nil:
    body_605628 = body
  result = call_605627.call(nil, nil, nil, nil, body_605628)

var removeThingFromBillingGroup* = Call_RemoveThingFromBillingGroup_605615(
    name: "removeThingFromBillingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/billing-groups/removeThingFromBillingGroup",
    validator: validate_RemoveThingFromBillingGroup_605616, base: "/",
    url: url_RemoveThingFromBillingGroup_605617,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveThingFromThingGroup_605629 = ref object of OpenApiRestCall_602466
proc url_RemoveThingFromThingGroup_605631(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RemoveThingFromThingGroup_605630(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove the specified thing from the specified group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605632 = header.getOrDefault("X-Amz-Date")
  valid_605632 = validateParameter(valid_605632, JString, required = false,
                                 default = nil)
  if valid_605632 != nil:
    section.add "X-Amz-Date", valid_605632
  var valid_605633 = header.getOrDefault("X-Amz-Security-Token")
  valid_605633 = validateParameter(valid_605633, JString, required = false,
                                 default = nil)
  if valid_605633 != nil:
    section.add "X-Amz-Security-Token", valid_605633
  var valid_605634 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605634 = validateParameter(valid_605634, JString, required = false,
                                 default = nil)
  if valid_605634 != nil:
    section.add "X-Amz-Content-Sha256", valid_605634
  var valid_605635 = header.getOrDefault("X-Amz-Algorithm")
  valid_605635 = validateParameter(valid_605635, JString, required = false,
                                 default = nil)
  if valid_605635 != nil:
    section.add "X-Amz-Algorithm", valid_605635
  var valid_605636 = header.getOrDefault("X-Amz-Signature")
  valid_605636 = validateParameter(valid_605636, JString, required = false,
                                 default = nil)
  if valid_605636 != nil:
    section.add "X-Amz-Signature", valid_605636
  var valid_605637 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605637 = validateParameter(valid_605637, JString, required = false,
                                 default = nil)
  if valid_605637 != nil:
    section.add "X-Amz-SignedHeaders", valid_605637
  var valid_605638 = header.getOrDefault("X-Amz-Credential")
  valid_605638 = validateParameter(valid_605638, JString, required = false,
                                 default = nil)
  if valid_605638 != nil:
    section.add "X-Amz-Credential", valid_605638
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605640: Call_RemoveThingFromThingGroup_605629; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Remove the specified thing from the specified group.
  ## 
  let valid = call_605640.validator(path, query, header, formData, body)
  let scheme = call_605640.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605640.url(scheme.get, call_605640.host, call_605640.base,
                         call_605640.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605640, url, valid)

proc call*(call_605641: Call_RemoveThingFromThingGroup_605629; body: JsonNode): Recallable =
  ## removeThingFromThingGroup
  ## Remove the specified thing from the specified group.
  ##   body: JObject (required)
  var body_605642 = newJObject()
  if body != nil:
    body_605642 = body
  result = call_605641.call(nil, nil, nil, nil, body_605642)

var removeThingFromThingGroup* = Call_RemoveThingFromThingGroup_605629(
    name: "removeThingFromThingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/removeThingFromThingGroup",
    validator: validate_RemoveThingFromThingGroup_605630, base: "/",
    url: url_RemoveThingFromThingGroup_605631,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_SearchIndex_605643 = ref object of OpenApiRestCall_602466
proc url_SearchIndex_605645(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_SearchIndex_605644(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## The query search index.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605646 = header.getOrDefault("X-Amz-Date")
  valid_605646 = validateParameter(valid_605646, JString, required = false,
                                 default = nil)
  if valid_605646 != nil:
    section.add "X-Amz-Date", valid_605646
  var valid_605647 = header.getOrDefault("X-Amz-Security-Token")
  valid_605647 = validateParameter(valid_605647, JString, required = false,
                                 default = nil)
  if valid_605647 != nil:
    section.add "X-Amz-Security-Token", valid_605647
  var valid_605648 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605648 = validateParameter(valid_605648, JString, required = false,
                                 default = nil)
  if valid_605648 != nil:
    section.add "X-Amz-Content-Sha256", valid_605648
  var valid_605649 = header.getOrDefault("X-Amz-Algorithm")
  valid_605649 = validateParameter(valid_605649, JString, required = false,
                                 default = nil)
  if valid_605649 != nil:
    section.add "X-Amz-Algorithm", valid_605649
  var valid_605650 = header.getOrDefault("X-Amz-Signature")
  valid_605650 = validateParameter(valid_605650, JString, required = false,
                                 default = nil)
  if valid_605650 != nil:
    section.add "X-Amz-Signature", valid_605650
  var valid_605651 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605651 = validateParameter(valid_605651, JString, required = false,
                                 default = nil)
  if valid_605651 != nil:
    section.add "X-Amz-SignedHeaders", valid_605651
  var valid_605652 = header.getOrDefault("X-Amz-Credential")
  valid_605652 = validateParameter(valid_605652, JString, required = false,
                                 default = nil)
  if valid_605652 != nil:
    section.add "X-Amz-Credential", valid_605652
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605654: Call_SearchIndex_605643; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The query search index.
  ## 
  let valid = call_605654.validator(path, query, header, formData, body)
  let scheme = call_605654.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605654.url(scheme.get, call_605654.host, call_605654.base,
                         call_605654.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605654, url, valid)

proc call*(call_605655: Call_SearchIndex_605643; body: JsonNode): Recallable =
  ## searchIndex
  ## The query search index.
  ##   body: JObject (required)
  var body_605656 = newJObject()
  if body != nil:
    body_605656 = body
  result = call_605655.call(nil, nil, nil, nil, body_605656)

var searchIndex* = Call_SearchIndex_605643(name: "searchIndex",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com",
                                        route: "/indices/search",
                                        validator: validate_SearchIndex_605644,
                                        base: "/", url: url_SearchIndex_605645,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartOnDemandAuditTask_605657 = ref object of OpenApiRestCall_602466
proc url_StartOnDemandAuditTask_605659(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_StartOnDemandAuditTask_605658(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts an on-demand Device Defender audit.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605660 = header.getOrDefault("X-Amz-Date")
  valid_605660 = validateParameter(valid_605660, JString, required = false,
                                 default = nil)
  if valid_605660 != nil:
    section.add "X-Amz-Date", valid_605660
  var valid_605661 = header.getOrDefault("X-Amz-Security-Token")
  valid_605661 = validateParameter(valid_605661, JString, required = false,
                                 default = nil)
  if valid_605661 != nil:
    section.add "X-Amz-Security-Token", valid_605661
  var valid_605662 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605662 = validateParameter(valid_605662, JString, required = false,
                                 default = nil)
  if valid_605662 != nil:
    section.add "X-Amz-Content-Sha256", valid_605662
  var valid_605663 = header.getOrDefault("X-Amz-Algorithm")
  valid_605663 = validateParameter(valid_605663, JString, required = false,
                                 default = nil)
  if valid_605663 != nil:
    section.add "X-Amz-Algorithm", valid_605663
  var valid_605664 = header.getOrDefault("X-Amz-Signature")
  valid_605664 = validateParameter(valid_605664, JString, required = false,
                                 default = nil)
  if valid_605664 != nil:
    section.add "X-Amz-Signature", valid_605664
  var valid_605665 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605665 = validateParameter(valid_605665, JString, required = false,
                                 default = nil)
  if valid_605665 != nil:
    section.add "X-Amz-SignedHeaders", valid_605665
  var valid_605666 = header.getOrDefault("X-Amz-Credential")
  valid_605666 = validateParameter(valid_605666, JString, required = false,
                                 default = nil)
  if valid_605666 != nil:
    section.add "X-Amz-Credential", valid_605666
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605668: Call_StartOnDemandAuditTask_605657; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts an on-demand Device Defender audit.
  ## 
  let valid = call_605668.validator(path, query, header, formData, body)
  let scheme = call_605668.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605668.url(scheme.get, call_605668.host, call_605668.base,
                         call_605668.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605668, url, valid)

proc call*(call_605669: Call_StartOnDemandAuditTask_605657; body: JsonNode): Recallable =
  ## startOnDemandAuditTask
  ## Starts an on-demand Device Defender audit.
  ##   body: JObject (required)
  var body_605670 = newJObject()
  if body != nil:
    body_605670 = body
  result = call_605669.call(nil, nil, nil, nil, body_605670)

var startOnDemandAuditTask* = Call_StartOnDemandAuditTask_605657(
    name: "startOnDemandAuditTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/audit/tasks",
    validator: validate_StartOnDemandAuditTask_605658, base: "/",
    url: url_StartOnDemandAuditTask_605659, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StopThingRegistrationTask_605671 = ref object of OpenApiRestCall_602466
proc url_StopThingRegistrationTask_605673(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StopThingRegistrationTask_605672(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The bulk thing provisioning task ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_605674 = path.getOrDefault("taskId")
  valid_605674 = validateParameter(valid_605674, JString, required = true,
                                 default = nil)
  if valid_605674 != nil:
    section.add "taskId", valid_605674
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605675 = header.getOrDefault("X-Amz-Date")
  valid_605675 = validateParameter(valid_605675, JString, required = false,
                                 default = nil)
  if valid_605675 != nil:
    section.add "X-Amz-Date", valid_605675
  var valid_605676 = header.getOrDefault("X-Amz-Security-Token")
  valid_605676 = validateParameter(valid_605676, JString, required = false,
                                 default = nil)
  if valid_605676 != nil:
    section.add "X-Amz-Security-Token", valid_605676
  var valid_605677 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605677 = validateParameter(valid_605677, JString, required = false,
                                 default = nil)
  if valid_605677 != nil:
    section.add "X-Amz-Content-Sha256", valid_605677
  var valid_605678 = header.getOrDefault("X-Amz-Algorithm")
  valid_605678 = validateParameter(valid_605678, JString, required = false,
                                 default = nil)
  if valid_605678 != nil:
    section.add "X-Amz-Algorithm", valid_605678
  var valid_605679 = header.getOrDefault("X-Amz-Signature")
  valid_605679 = validateParameter(valid_605679, JString, required = false,
                                 default = nil)
  if valid_605679 != nil:
    section.add "X-Amz-Signature", valid_605679
  var valid_605680 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605680 = validateParameter(valid_605680, JString, required = false,
                                 default = nil)
  if valid_605680 != nil:
    section.add "X-Amz-SignedHeaders", valid_605680
  var valid_605681 = header.getOrDefault("X-Amz-Credential")
  valid_605681 = validateParameter(valid_605681, JString, required = false,
                                 default = nil)
  if valid_605681 != nil:
    section.add "X-Amz-Credential", valid_605681
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605682: Call_StopThingRegistrationTask_605671; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a bulk thing provisioning task.
  ## 
  let valid = call_605682.validator(path, query, header, formData, body)
  let scheme = call_605682.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605682.url(scheme.get, call_605682.host, call_605682.base,
                         call_605682.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605682, url, valid)

proc call*(call_605683: Call_StopThingRegistrationTask_605671; taskId: string): Recallable =
  ## stopThingRegistrationTask
  ## Cancels a bulk thing provisioning task.
  ##   taskId: string (required)
  ##         : The bulk thing provisioning task ID.
  var path_605684 = newJObject()
  add(path_605684, "taskId", newJString(taskId))
  result = call_605683.call(path_605684, nil, nil, nil, nil)

var stopThingRegistrationTask* = Call_StopThingRegistrationTask_605671(
    name: "stopThingRegistrationTask", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks/{taskId}/cancel",
    validator: validate_StopThingRegistrationTask_605672, base: "/",
    url: url_StopThingRegistrationTask_605673,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_TagResource_605685 = ref object of OpenApiRestCall_602466
proc url_TagResource_605687(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_TagResource_605686(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605688 = header.getOrDefault("X-Amz-Date")
  valid_605688 = validateParameter(valid_605688, JString, required = false,
                                 default = nil)
  if valid_605688 != nil:
    section.add "X-Amz-Date", valid_605688
  var valid_605689 = header.getOrDefault("X-Amz-Security-Token")
  valid_605689 = validateParameter(valid_605689, JString, required = false,
                                 default = nil)
  if valid_605689 != nil:
    section.add "X-Amz-Security-Token", valid_605689
  var valid_605690 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605690 = validateParameter(valid_605690, JString, required = false,
                                 default = nil)
  if valid_605690 != nil:
    section.add "X-Amz-Content-Sha256", valid_605690
  var valid_605691 = header.getOrDefault("X-Amz-Algorithm")
  valid_605691 = validateParameter(valid_605691, JString, required = false,
                                 default = nil)
  if valid_605691 != nil:
    section.add "X-Amz-Algorithm", valid_605691
  var valid_605692 = header.getOrDefault("X-Amz-Signature")
  valid_605692 = validateParameter(valid_605692, JString, required = false,
                                 default = nil)
  if valid_605692 != nil:
    section.add "X-Amz-Signature", valid_605692
  var valid_605693 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605693 = validateParameter(valid_605693, JString, required = false,
                                 default = nil)
  if valid_605693 != nil:
    section.add "X-Amz-SignedHeaders", valid_605693
  var valid_605694 = header.getOrDefault("X-Amz-Credential")
  valid_605694 = validateParameter(valid_605694, JString, required = false,
                                 default = nil)
  if valid_605694 != nil:
    section.add "X-Amz-Credential", valid_605694
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605696: Call_TagResource_605685; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ## 
  let valid = call_605696.validator(path, query, header, formData, body)
  let scheme = call_605696.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605696.url(scheme.get, call_605696.host, call_605696.base,
                         call_605696.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605696, url, valid)

proc call*(call_605697: Call_TagResource_605685; body: JsonNode): Recallable =
  ## tagResource
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ##   body: JObject (required)
  var body_605698 = newJObject()
  if body != nil:
    body_605698 = body
  result = call_605697.call(nil, nil, nil, nil, body_605698)

var tagResource* = Call_TagResource_605685(name: "tagResource",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com", route: "/tags",
                                        validator: validate_TagResource_605686,
                                        base: "/", url: url_TagResource_605687,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_TestAuthorization_605699 = ref object of OpenApiRestCall_602466
proc url_TestAuthorization_605701(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_TestAuthorization_605700(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   clientId: JString
  ##           : The MQTT client ID.
  section = newJObject()
  var valid_605702 = query.getOrDefault("clientId")
  valid_605702 = validateParameter(valid_605702, JString, required = false,
                                 default = nil)
  if valid_605702 != nil:
    section.add "clientId", valid_605702
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605703 = header.getOrDefault("X-Amz-Date")
  valid_605703 = validateParameter(valid_605703, JString, required = false,
                                 default = nil)
  if valid_605703 != nil:
    section.add "X-Amz-Date", valid_605703
  var valid_605704 = header.getOrDefault("X-Amz-Security-Token")
  valid_605704 = validateParameter(valid_605704, JString, required = false,
                                 default = nil)
  if valid_605704 != nil:
    section.add "X-Amz-Security-Token", valid_605704
  var valid_605705 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605705 = validateParameter(valid_605705, JString, required = false,
                                 default = nil)
  if valid_605705 != nil:
    section.add "X-Amz-Content-Sha256", valid_605705
  var valid_605706 = header.getOrDefault("X-Amz-Algorithm")
  valid_605706 = validateParameter(valid_605706, JString, required = false,
                                 default = nil)
  if valid_605706 != nil:
    section.add "X-Amz-Algorithm", valid_605706
  var valid_605707 = header.getOrDefault("X-Amz-Signature")
  valid_605707 = validateParameter(valid_605707, JString, required = false,
                                 default = nil)
  if valid_605707 != nil:
    section.add "X-Amz-Signature", valid_605707
  var valid_605708 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605708 = validateParameter(valid_605708, JString, required = false,
                                 default = nil)
  if valid_605708 != nil:
    section.add "X-Amz-SignedHeaders", valid_605708
  var valid_605709 = header.getOrDefault("X-Amz-Credential")
  valid_605709 = validateParameter(valid_605709, JString, required = false,
                                 default = nil)
  if valid_605709 != nil:
    section.add "X-Amz-Credential", valid_605709
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605711: Call_TestAuthorization_605699; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  let valid = call_605711.validator(path, query, header, formData, body)
  let scheme = call_605711.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605711.url(scheme.get, call_605711.host, call_605711.base,
                         call_605711.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605711, url, valid)

proc call*(call_605712: Call_TestAuthorization_605699; body: JsonNode;
          clientId: string = ""): Recallable =
  ## testAuthorization
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ##   clientId: string
  ##           : The MQTT client ID.
  ##   body: JObject (required)
  var query_605713 = newJObject()
  var body_605714 = newJObject()
  add(query_605713, "clientId", newJString(clientId))
  if body != nil:
    body_605714 = body
  result = call_605712.call(nil, query_605713, nil, nil, body_605714)

var testAuthorization* = Call_TestAuthorization_605699(name: "testAuthorization",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/test-authorization", validator: validate_TestAuthorization_605700,
    base: "/", url: url_TestAuthorization_605701,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_TestInvokeAuthorizer_605715 = ref object of OpenApiRestCall_602466
proc url_TestInvokeAuthorizer_605717(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName"),
               (kind: ConstantSegment, value: "/test")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_TestInvokeAuthorizer_605716(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The custom authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_605718 = path.getOrDefault("authorizerName")
  valid_605718 = validateParameter(valid_605718, JString, required = true,
                                 default = nil)
  if valid_605718 != nil:
    section.add "authorizerName", valid_605718
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605719 = header.getOrDefault("X-Amz-Date")
  valid_605719 = validateParameter(valid_605719, JString, required = false,
                                 default = nil)
  if valid_605719 != nil:
    section.add "X-Amz-Date", valid_605719
  var valid_605720 = header.getOrDefault("X-Amz-Security-Token")
  valid_605720 = validateParameter(valid_605720, JString, required = false,
                                 default = nil)
  if valid_605720 != nil:
    section.add "X-Amz-Security-Token", valid_605720
  var valid_605721 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605721 = validateParameter(valid_605721, JString, required = false,
                                 default = nil)
  if valid_605721 != nil:
    section.add "X-Amz-Content-Sha256", valid_605721
  var valid_605722 = header.getOrDefault("X-Amz-Algorithm")
  valid_605722 = validateParameter(valid_605722, JString, required = false,
                                 default = nil)
  if valid_605722 != nil:
    section.add "X-Amz-Algorithm", valid_605722
  var valid_605723 = header.getOrDefault("X-Amz-Signature")
  valid_605723 = validateParameter(valid_605723, JString, required = false,
                                 default = nil)
  if valid_605723 != nil:
    section.add "X-Amz-Signature", valid_605723
  var valid_605724 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605724 = validateParameter(valid_605724, JString, required = false,
                                 default = nil)
  if valid_605724 != nil:
    section.add "X-Amz-SignedHeaders", valid_605724
  var valid_605725 = header.getOrDefault("X-Amz-Credential")
  valid_605725 = validateParameter(valid_605725, JString, required = false,
                                 default = nil)
  if valid_605725 != nil:
    section.add "X-Amz-Credential", valid_605725
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605727: Call_TestInvokeAuthorizer_605715; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  let valid = call_605727.validator(path, query, header, formData, body)
  let scheme = call_605727.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605727.url(scheme.get, call_605727.host, call_605727.base,
                         call_605727.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605727, url, valid)

proc call*(call_605728: Call_TestInvokeAuthorizer_605715; authorizerName: string;
          body: JsonNode): Recallable =
  ## testInvokeAuthorizer
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ##   authorizerName: string (required)
  ##                 : The custom authorizer name.
  ##   body: JObject (required)
  var path_605729 = newJObject()
  var body_605730 = newJObject()
  add(path_605729, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_605730 = body
  result = call_605728.call(path_605729, nil, nil, nil, body_605730)

var testInvokeAuthorizer* = Call_TestInvokeAuthorizer_605715(
    name: "testInvokeAuthorizer", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/authorizer/{authorizerName}/test",
    validator: validate_TestInvokeAuthorizer_605716, base: "/",
    url: url_TestInvokeAuthorizer_605717, schemes: {Scheme.Https, Scheme.Http})
type
  Call_TransferCertificate_605731 = ref object of OpenApiRestCall_602466
proc url_TransferCertificate_605733(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/transfer-certificate/"),
               (kind: VariableSegment, value: "certificateId"),
               (kind: ConstantSegment, value: "#targetAwsAccount")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_TransferCertificate_605732(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_605734 = path.getOrDefault("certificateId")
  valid_605734 = validateParameter(valid_605734, JString, required = true,
                                 default = nil)
  if valid_605734 != nil:
    section.add "certificateId", valid_605734
  result.add "path", section
  ## parameters in `query` object:
  ##   targetAwsAccount: JString (required)
  ##                   : The AWS account.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `targetAwsAccount` field"
  var valid_605735 = query.getOrDefault("targetAwsAccount")
  valid_605735 = validateParameter(valid_605735, JString, required = true,
                                 default = nil)
  if valid_605735 != nil:
    section.add "targetAwsAccount", valid_605735
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605736 = header.getOrDefault("X-Amz-Date")
  valid_605736 = validateParameter(valid_605736, JString, required = false,
                                 default = nil)
  if valid_605736 != nil:
    section.add "X-Amz-Date", valid_605736
  var valid_605737 = header.getOrDefault("X-Amz-Security-Token")
  valid_605737 = validateParameter(valid_605737, JString, required = false,
                                 default = nil)
  if valid_605737 != nil:
    section.add "X-Amz-Security-Token", valid_605737
  var valid_605738 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605738 = validateParameter(valid_605738, JString, required = false,
                                 default = nil)
  if valid_605738 != nil:
    section.add "X-Amz-Content-Sha256", valid_605738
  var valid_605739 = header.getOrDefault("X-Amz-Algorithm")
  valid_605739 = validateParameter(valid_605739, JString, required = false,
                                 default = nil)
  if valid_605739 != nil:
    section.add "X-Amz-Algorithm", valid_605739
  var valid_605740 = header.getOrDefault("X-Amz-Signature")
  valid_605740 = validateParameter(valid_605740, JString, required = false,
                                 default = nil)
  if valid_605740 != nil:
    section.add "X-Amz-Signature", valid_605740
  var valid_605741 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605741 = validateParameter(valid_605741, JString, required = false,
                                 default = nil)
  if valid_605741 != nil:
    section.add "X-Amz-SignedHeaders", valid_605741
  var valid_605742 = header.getOrDefault("X-Amz-Credential")
  valid_605742 = validateParameter(valid_605742, JString, required = false,
                                 default = nil)
  if valid_605742 != nil:
    section.add "X-Amz-Credential", valid_605742
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605744: Call_TransferCertificate_605731; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ## 
  let valid = call_605744.validator(path, query, header, formData, body)
  let scheme = call_605744.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605744.url(scheme.get, call_605744.host, call_605744.base,
                         call_605744.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605744, url, valid)

proc call*(call_605745: Call_TransferCertificate_605731; certificateId: string;
          targetAwsAccount: string; body: JsonNode): Recallable =
  ## transferCertificate
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   targetAwsAccount: string (required)
  ##                   : The AWS account.
  ##   body: JObject (required)
  var path_605746 = newJObject()
  var query_605747 = newJObject()
  var body_605748 = newJObject()
  add(path_605746, "certificateId", newJString(certificateId))
  add(query_605747, "targetAwsAccount", newJString(targetAwsAccount))
  if body != nil:
    body_605748 = body
  result = call_605745.call(path_605746, query_605747, nil, nil, body_605748)

var transferCertificate* = Call_TransferCertificate_605731(
    name: "transferCertificate", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/transfer-certificate/{certificateId}#targetAwsAccount",
    validator: validate_TransferCertificate_605732, base: "/",
    url: url_TransferCertificate_605733, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UntagResource_605749 = ref object of OpenApiRestCall_602466
proc url_UntagResource_605751(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UntagResource_605750(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes the given tags (metadata) from the resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605752 = header.getOrDefault("X-Amz-Date")
  valid_605752 = validateParameter(valid_605752, JString, required = false,
                                 default = nil)
  if valid_605752 != nil:
    section.add "X-Amz-Date", valid_605752
  var valid_605753 = header.getOrDefault("X-Amz-Security-Token")
  valid_605753 = validateParameter(valid_605753, JString, required = false,
                                 default = nil)
  if valid_605753 != nil:
    section.add "X-Amz-Security-Token", valid_605753
  var valid_605754 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605754 = validateParameter(valid_605754, JString, required = false,
                                 default = nil)
  if valid_605754 != nil:
    section.add "X-Amz-Content-Sha256", valid_605754
  var valid_605755 = header.getOrDefault("X-Amz-Algorithm")
  valid_605755 = validateParameter(valid_605755, JString, required = false,
                                 default = nil)
  if valid_605755 != nil:
    section.add "X-Amz-Algorithm", valid_605755
  var valid_605756 = header.getOrDefault("X-Amz-Signature")
  valid_605756 = validateParameter(valid_605756, JString, required = false,
                                 default = nil)
  if valid_605756 != nil:
    section.add "X-Amz-Signature", valid_605756
  var valid_605757 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605757 = validateParameter(valid_605757, JString, required = false,
                                 default = nil)
  if valid_605757 != nil:
    section.add "X-Amz-SignedHeaders", valid_605757
  var valid_605758 = header.getOrDefault("X-Amz-Credential")
  valid_605758 = validateParameter(valid_605758, JString, required = false,
                                 default = nil)
  if valid_605758 != nil:
    section.add "X-Amz-Credential", valid_605758
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605760: Call_UntagResource_605749; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes the given tags (metadata) from the resource.
  ## 
  let valid = call_605760.validator(path, query, header, formData, body)
  let scheme = call_605760.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605760.url(scheme.get, call_605760.host, call_605760.base,
                         call_605760.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605760, url, valid)

proc call*(call_605761: Call_UntagResource_605749; body: JsonNode): Recallable =
  ## untagResource
  ## Removes the given tags (metadata) from the resource.
  ##   body: JObject (required)
  var body_605762 = newJObject()
  if body != nil:
    body_605762 = body
  result = call_605761.call(nil, nil, nil, nil, body_605762)

var untagResource* = Call_UntagResource_605749(name: "untagResource",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/untag",
    validator: validate_UntagResource_605750, base: "/", url: url_UntagResource_605751,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateCertificate_605763 = ref object of OpenApiRestCall_602466
proc url_UpdateCertificate_605765(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId"),
               (kind: ConstantSegment, value: "#newStatus")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateCertificate_605764(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_605766 = path.getOrDefault("certificateId")
  valid_605766 = validateParameter(valid_605766, JString, required = true,
                                 default = nil)
  if valid_605766 != nil:
    section.add "certificateId", valid_605766
  result.add "path", section
  ## parameters in `query` object:
  ##   newStatus: JString (required)
  ##            : <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `newStatus` field"
  var valid_605767 = query.getOrDefault("newStatus")
  valid_605767 = validateParameter(valid_605767, JString, required = true,
                                 default = newJString("ACTIVE"))
  if valid_605767 != nil:
    section.add "newStatus", valid_605767
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605768 = header.getOrDefault("X-Amz-Date")
  valid_605768 = validateParameter(valid_605768, JString, required = false,
                                 default = nil)
  if valid_605768 != nil:
    section.add "X-Amz-Date", valid_605768
  var valid_605769 = header.getOrDefault("X-Amz-Security-Token")
  valid_605769 = validateParameter(valid_605769, JString, required = false,
                                 default = nil)
  if valid_605769 != nil:
    section.add "X-Amz-Security-Token", valid_605769
  var valid_605770 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605770 = validateParameter(valid_605770, JString, required = false,
                                 default = nil)
  if valid_605770 != nil:
    section.add "X-Amz-Content-Sha256", valid_605770
  var valid_605771 = header.getOrDefault("X-Amz-Algorithm")
  valid_605771 = validateParameter(valid_605771, JString, required = false,
                                 default = nil)
  if valid_605771 != nil:
    section.add "X-Amz-Algorithm", valid_605771
  var valid_605772 = header.getOrDefault("X-Amz-Signature")
  valid_605772 = validateParameter(valid_605772, JString, required = false,
                                 default = nil)
  if valid_605772 != nil:
    section.add "X-Amz-Signature", valid_605772
  var valid_605773 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605773 = validateParameter(valid_605773, JString, required = false,
                                 default = nil)
  if valid_605773 != nil:
    section.add "X-Amz-SignedHeaders", valid_605773
  var valid_605774 = header.getOrDefault("X-Amz-Credential")
  valid_605774 = validateParameter(valid_605774, JString, required = false,
                                 default = nil)
  if valid_605774 != nil:
    section.add "X-Amz-Credential", valid_605774
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605775: Call_UpdateCertificate_605763; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ## 
  let valid = call_605775.validator(path, query, header, formData, body)
  let scheme = call_605775.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605775.url(scheme.get, call_605775.host, call_605775.base,
                         call_605775.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605775, url, valid)

proc call*(call_605776: Call_UpdateCertificate_605763; certificateId: string;
          newStatus: string = "ACTIVE"): Recallable =
  ## updateCertificate
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   newStatus: string (required)
  ##            : <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  var path_605777 = newJObject()
  var query_605778 = newJObject()
  add(path_605777, "certificateId", newJString(certificateId))
  add(query_605778, "newStatus", newJString(newStatus))
  result = call_605776.call(path_605777, query_605778, nil, nil, nil)

var updateCertificate* = Call_UpdateCertificate_605763(name: "updateCertificate",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/certificates/{certificateId}#newStatus",
    validator: validate_UpdateCertificate_605764, base: "/",
    url: url_UpdateCertificate_605765, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThingGroupsForThing_605779 = ref object of OpenApiRestCall_602466
proc url_UpdateThingGroupsForThing_605781(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateThingGroupsForThing_605780(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the groups to which the thing belongs.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605782 = header.getOrDefault("X-Amz-Date")
  valid_605782 = validateParameter(valid_605782, JString, required = false,
                                 default = nil)
  if valid_605782 != nil:
    section.add "X-Amz-Date", valid_605782
  var valid_605783 = header.getOrDefault("X-Amz-Security-Token")
  valid_605783 = validateParameter(valid_605783, JString, required = false,
                                 default = nil)
  if valid_605783 != nil:
    section.add "X-Amz-Security-Token", valid_605783
  var valid_605784 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605784 = validateParameter(valid_605784, JString, required = false,
                                 default = nil)
  if valid_605784 != nil:
    section.add "X-Amz-Content-Sha256", valid_605784
  var valid_605785 = header.getOrDefault("X-Amz-Algorithm")
  valid_605785 = validateParameter(valid_605785, JString, required = false,
                                 default = nil)
  if valid_605785 != nil:
    section.add "X-Amz-Algorithm", valid_605785
  var valid_605786 = header.getOrDefault("X-Amz-Signature")
  valid_605786 = validateParameter(valid_605786, JString, required = false,
                                 default = nil)
  if valid_605786 != nil:
    section.add "X-Amz-Signature", valid_605786
  var valid_605787 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605787 = validateParameter(valid_605787, JString, required = false,
                                 default = nil)
  if valid_605787 != nil:
    section.add "X-Amz-SignedHeaders", valid_605787
  var valid_605788 = header.getOrDefault("X-Amz-Credential")
  valid_605788 = validateParameter(valid_605788, JString, required = false,
                                 default = nil)
  if valid_605788 != nil:
    section.add "X-Amz-Credential", valid_605788
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605790: Call_UpdateThingGroupsForThing_605779; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the groups to which the thing belongs.
  ## 
  let valid = call_605790.validator(path, query, header, formData, body)
  let scheme = call_605790.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605790.url(scheme.get, call_605790.host, call_605790.base,
                         call_605790.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605790, url, valid)

proc call*(call_605791: Call_UpdateThingGroupsForThing_605779; body: JsonNode): Recallable =
  ## updateThingGroupsForThing
  ## Updates the groups to which the thing belongs.
  ##   body: JObject (required)
  var body_605792 = newJObject()
  if body != nil:
    body_605792 = body
  result = call_605791.call(nil, nil, nil, nil, body_605792)

var updateThingGroupsForThing* = Call_UpdateThingGroupsForThing_605779(
    name: "updateThingGroupsForThing", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/updateThingGroupsForThing",
    validator: validate_UpdateThingGroupsForThing_605780, base: "/",
    url: url_UpdateThingGroupsForThing_605781,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ValidateSecurityProfileBehaviors_605793 = ref object of OpenApiRestCall_602466
proc url_ValidateSecurityProfileBehaviors_605795(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ValidateSecurityProfileBehaviors_605794(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validates a Device Defender security profile behaviors specification.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_605796 = header.getOrDefault("X-Amz-Date")
  valid_605796 = validateParameter(valid_605796, JString, required = false,
                                 default = nil)
  if valid_605796 != nil:
    section.add "X-Amz-Date", valid_605796
  var valid_605797 = header.getOrDefault("X-Amz-Security-Token")
  valid_605797 = validateParameter(valid_605797, JString, required = false,
                                 default = nil)
  if valid_605797 != nil:
    section.add "X-Amz-Security-Token", valid_605797
  var valid_605798 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605798 = validateParameter(valid_605798, JString, required = false,
                                 default = nil)
  if valid_605798 != nil:
    section.add "X-Amz-Content-Sha256", valid_605798
  var valid_605799 = header.getOrDefault("X-Amz-Algorithm")
  valid_605799 = validateParameter(valid_605799, JString, required = false,
                                 default = nil)
  if valid_605799 != nil:
    section.add "X-Amz-Algorithm", valid_605799
  var valid_605800 = header.getOrDefault("X-Amz-Signature")
  valid_605800 = validateParameter(valid_605800, JString, required = false,
                                 default = nil)
  if valid_605800 != nil:
    section.add "X-Amz-Signature", valid_605800
  var valid_605801 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605801 = validateParameter(valid_605801, JString, required = false,
                                 default = nil)
  if valid_605801 != nil:
    section.add "X-Amz-SignedHeaders", valid_605801
  var valid_605802 = header.getOrDefault("X-Amz-Credential")
  valid_605802 = validateParameter(valid_605802, JString, required = false,
                                 default = nil)
  if valid_605802 != nil:
    section.add "X-Amz-Credential", valid_605802
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_605804: Call_ValidateSecurityProfileBehaviors_605793;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Validates a Device Defender security profile behaviors specification.
  ## 
  let valid = call_605804.validator(path, query, header, formData, body)
  let scheme = call_605804.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605804.url(scheme.get, call_605804.host, call_605804.base,
                         call_605804.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_605804, url, valid)

proc call*(call_605805: Call_ValidateSecurityProfileBehaviors_605793;
          body: JsonNode): Recallable =
  ## validateSecurityProfileBehaviors
  ## Validates a Device Defender security profile behaviors specification.
  ##   body: JObject (required)
  var body_605806 = newJObject()
  if body != nil:
    body_605806 = body
  result = call_605805.call(nil, nil, nil, nil, body_605806)

var validateSecurityProfileBehaviors* = Call_ValidateSecurityProfileBehaviors_605793(
    name: "validateSecurityProfileBehaviors", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/security-profile-behaviors/validate",
    validator: validate_ValidateSecurityProfileBehaviors_605794, base: "/",
    url: url_ValidateSecurityProfileBehaviors_605795,
    schemes: {Scheme.Https, Scheme.Http})
export
  rest

proc sign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", "")
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", "")
    region = os.getEnv("AWS_REGION", "")
  assert secret != "", "need secret key in env"
  assert access != "", "need access key in env"
  assert region != "", "need region in env"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  recall.headers.del "Host"
  recall.url = $url

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  let headers = massageHeaders(input.getOrDefault("header"))
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
  result.sign(input.getOrDefault("query"), SHA256)
