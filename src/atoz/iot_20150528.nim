
import
  json, options, hashes, uri, strutils, tables, rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: AWS IoT
## version: 2015-05-28
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>AWS IoT</fullname> <p>AWS IoT provides secure, bi-directional communication between Internet-connected devices (such as sensors, actuators, embedded devices, or smart appliances) and the AWS cloud. You can discover your custom IoT-Data endpoint to communicate with, configure rules for data processing and integration with other services, organize resources associated with each device (Registry), configure logging, and create and manage policies and credentials to authenticate devices.</p> <p>For more information about how AWS IoT works, see the <a href="https://docs.aws.amazon.com/iot/latest/developerguide/aws-iot-how-it-works.html">Developer Guide</a>.</p> <p>For information about how to use the credentials provider for AWS IoT, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorizing-direct-aws.html">Authorizing Direct Calls to AWS Services</a>.</p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/iot/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_605589 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_605589](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_605589): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "iot.ap-northeast-1.amazonaws.com", "ap-southeast-1": "iot.ap-southeast-1.amazonaws.com",
                           "us-west-2": "iot.us-west-2.amazonaws.com",
                           "eu-west-2": "iot.eu-west-2.amazonaws.com", "ap-northeast-3": "iot.ap-northeast-3.amazonaws.com",
                           "eu-central-1": "iot.eu-central-1.amazonaws.com",
                           "us-east-2": "iot.us-east-2.amazonaws.com",
                           "us-east-1": "iot.us-east-1.amazonaws.com", "cn-northwest-1": "iot.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "iot.ap-south-1.amazonaws.com",
                           "eu-north-1": "iot.eu-north-1.amazonaws.com", "ap-northeast-2": "iot.ap-northeast-2.amazonaws.com",
                           "us-west-1": "iot.us-west-1.amazonaws.com",
                           "us-gov-east-1": "iot.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "iot.eu-west-3.amazonaws.com",
                           "cn-north-1": "iot.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "iot.sa-east-1.amazonaws.com",
                           "eu-west-1": "iot.eu-west-1.amazonaws.com",
                           "us-gov-west-1": "iot.us-gov-west-1.amazonaws.com", "ap-southeast-2": "iot.ap-southeast-2.amazonaws.com",
                           "ca-central-1": "iot.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "iot.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "iot.ap-southeast-1.amazonaws.com",
      "us-west-2": "iot.us-west-2.amazonaws.com",
      "eu-west-2": "iot.eu-west-2.amazonaws.com",
      "ap-northeast-3": "iot.ap-northeast-3.amazonaws.com",
      "eu-central-1": "iot.eu-central-1.amazonaws.com",
      "us-east-2": "iot.us-east-2.amazonaws.com",
      "us-east-1": "iot.us-east-1.amazonaws.com",
      "cn-northwest-1": "iot.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "iot.ap-south-1.amazonaws.com",
      "eu-north-1": "iot.eu-north-1.amazonaws.com",
      "ap-northeast-2": "iot.ap-northeast-2.amazonaws.com",
      "us-west-1": "iot.us-west-1.amazonaws.com",
      "us-gov-east-1": "iot.us-gov-east-1.amazonaws.com",
      "eu-west-3": "iot.eu-west-3.amazonaws.com",
      "cn-north-1": "iot.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "iot.sa-east-1.amazonaws.com",
      "eu-west-1": "iot.eu-west-1.amazonaws.com",
      "us-gov-west-1": "iot.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "iot.ap-southeast-2.amazonaws.com",
      "ca-central-1": "iot.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "iot"
method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_AcceptCertificateTransfer_605927 = ref object of OpenApiRestCall_605589
proc url_AcceptCertificateTransfer_605929(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/accept-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AcceptCertificateTransfer_605928(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_606055 = path.getOrDefault("certificateId")
  valid_606055 = validateParameter(valid_606055, JString, required = true,
                                 default = nil)
  if valid_606055 != nil:
    section.add "certificateId", valid_606055
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_606056 = query.getOrDefault("setAsActive")
  valid_606056 = validateParameter(valid_606056, JBool, required = false, default = nil)
  if valid_606056 != nil:
    section.add "setAsActive", valid_606056
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606057 = header.getOrDefault("X-Amz-Signature")
  valid_606057 = validateParameter(valid_606057, JString, required = false,
                                 default = nil)
  if valid_606057 != nil:
    section.add "X-Amz-Signature", valid_606057
  var valid_606058 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606058 = validateParameter(valid_606058, JString, required = false,
                                 default = nil)
  if valid_606058 != nil:
    section.add "X-Amz-Content-Sha256", valid_606058
  var valid_606059 = header.getOrDefault("X-Amz-Date")
  valid_606059 = validateParameter(valid_606059, JString, required = false,
                                 default = nil)
  if valid_606059 != nil:
    section.add "X-Amz-Date", valid_606059
  var valid_606060 = header.getOrDefault("X-Amz-Credential")
  valid_606060 = validateParameter(valid_606060, JString, required = false,
                                 default = nil)
  if valid_606060 != nil:
    section.add "X-Amz-Credential", valid_606060
  var valid_606061 = header.getOrDefault("X-Amz-Security-Token")
  valid_606061 = validateParameter(valid_606061, JString, required = false,
                                 default = nil)
  if valid_606061 != nil:
    section.add "X-Amz-Security-Token", valid_606061
  var valid_606062 = header.getOrDefault("X-Amz-Algorithm")
  valid_606062 = validateParameter(valid_606062, JString, required = false,
                                 default = nil)
  if valid_606062 != nil:
    section.add "X-Amz-Algorithm", valid_606062
  var valid_606063 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606063 = validateParameter(valid_606063, JString, required = false,
                                 default = nil)
  if valid_606063 != nil:
    section.add "X-Amz-SignedHeaders", valid_606063
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606086: Call_AcceptCertificateTransfer_605927; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ## 
  let valid = call_606086.validator(path, query, header, formData, body)
  let scheme = call_606086.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606086.url(scheme.get, call_606086.host, call_606086.base,
                         call_606086.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606086, url, valid)

proc call*(call_606157: Call_AcceptCertificateTransfer_605927;
          certificateId: string; setAsActive: bool = false): Recallable =
  ## acceptCertificateTransfer
  ## <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_606158 = newJObject()
  var query_606160 = newJObject()
  add(query_606160, "setAsActive", newJBool(setAsActive))
  add(path_606158, "certificateId", newJString(certificateId))
  result = call_606157.call(path_606158, query_606160, nil, nil, nil)

var acceptCertificateTransfer* = Call_AcceptCertificateTransfer_605927(
    name: "acceptCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/accept-certificate-transfer/{certificateId}",
    validator: validate_AcceptCertificateTransfer_605928, base: "/",
    url: url_AcceptCertificateTransfer_605929,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_AddThingToBillingGroup_606199 = ref object of OpenApiRestCall_605589
proc url_AddThingToBillingGroup_606201(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_AddThingToBillingGroup_606200(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a thing to a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606202 = header.getOrDefault("X-Amz-Signature")
  valid_606202 = validateParameter(valid_606202, JString, required = false,
                                 default = nil)
  if valid_606202 != nil:
    section.add "X-Amz-Signature", valid_606202
  var valid_606203 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606203 = validateParameter(valid_606203, JString, required = false,
                                 default = nil)
  if valid_606203 != nil:
    section.add "X-Amz-Content-Sha256", valid_606203
  var valid_606204 = header.getOrDefault("X-Amz-Date")
  valid_606204 = validateParameter(valid_606204, JString, required = false,
                                 default = nil)
  if valid_606204 != nil:
    section.add "X-Amz-Date", valid_606204
  var valid_606205 = header.getOrDefault("X-Amz-Credential")
  valid_606205 = validateParameter(valid_606205, JString, required = false,
                                 default = nil)
  if valid_606205 != nil:
    section.add "X-Amz-Credential", valid_606205
  var valid_606206 = header.getOrDefault("X-Amz-Security-Token")
  valid_606206 = validateParameter(valid_606206, JString, required = false,
                                 default = nil)
  if valid_606206 != nil:
    section.add "X-Amz-Security-Token", valid_606206
  var valid_606207 = header.getOrDefault("X-Amz-Algorithm")
  valid_606207 = validateParameter(valid_606207, JString, required = false,
                                 default = nil)
  if valid_606207 != nil:
    section.add "X-Amz-Algorithm", valid_606207
  var valid_606208 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606208 = validateParameter(valid_606208, JString, required = false,
                                 default = nil)
  if valid_606208 != nil:
    section.add "X-Amz-SignedHeaders", valid_606208
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606210: Call_AddThingToBillingGroup_606199; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a thing to a billing group.
  ## 
  let valid = call_606210.validator(path, query, header, formData, body)
  let scheme = call_606210.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606210.url(scheme.get, call_606210.host, call_606210.base,
                         call_606210.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606210, url, valid)

proc call*(call_606211: Call_AddThingToBillingGroup_606199; body: JsonNode): Recallable =
  ## addThingToBillingGroup
  ## Adds a thing to a billing group.
  ##   body: JObject (required)
  var body_606212 = newJObject()
  if body != nil:
    body_606212 = body
  result = call_606211.call(nil, nil, nil, nil, body_606212)

var addThingToBillingGroup* = Call_AddThingToBillingGroup_606199(
    name: "addThingToBillingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/billing-groups/addThingToBillingGroup",
    validator: validate_AddThingToBillingGroup_606200, base: "/",
    url: url_AddThingToBillingGroup_606201, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AddThingToThingGroup_606213 = ref object of OpenApiRestCall_605589
proc url_AddThingToThingGroup_606215(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_AddThingToThingGroup_606214(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds a thing to a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606216 = header.getOrDefault("X-Amz-Signature")
  valid_606216 = validateParameter(valid_606216, JString, required = false,
                                 default = nil)
  if valid_606216 != nil:
    section.add "X-Amz-Signature", valid_606216
  var valid_606217 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606217 = validateParameter(valid_606217, JString, required = false,
                                 default = nil)
  if valid_606217 != nil:
    section.add "X-Amz-Content-Sha256", valid_606217
  var valid_606218 = header.getOrDefault("X-Amz-Date")
  valid_606218 = validateParameter(valid_606218, JString, required = false,
                                 default = nil)
  if valid_606218 != nil:
    section.add "X-Amz-Date", valid_606218
  var valid_606219 = header.getOrDefault("X-Amz-Credential")
  valid_606219 = validateParameter(valid_606219, JString, required = false,
                                 default = nil)
  if valid_606219 != nil:
    section.add "X-Amz-Credential", valid_606219
  var valid_606220 = header.getOrDefault("X-Amz-Security-Token")
  valid_606220 = validateParameter(valid_606220, JString, required = false,
                                 default = nil)
  if valid_606220 != nil:
    section.add "X-Amz-Security-Token", valid_606220
  var valid_606221 = header.getOrDefault("X-Amz-Algorithm")
  valid_606221 = validateParameter(valid_606221, JString, required = false,
                                 default = nil)
  if valid_606221 != nil:
    section.add "X-Amz-Algorithm", valid_606221
  var valid_606222 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606222 = validateParameter(valid_606222, JString, required = false,
                                 default = nil)
  if valid_606222 != nil:
    section.add "X-Amz-SignedHeaders", valid_606222
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606224: Call_AddThingToThingGroup_606213; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds a thing to a thing group.
  ## 
  let valid = call_606224.validator(path, query, header, formData, body)
  let scheme = call_606224.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606224.url(scheme.get, call_606224.host, call_606224.base,
                         call_606224.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606224, url, valid)

proc call*(call_606225: Call_AddThingToThingGroup_606213; body: JsonNode): Recallable =
  ## addThingToThingGroup
  ## Adds a thing to a thing group.
  ##   body: JObject (required)
  var body_606226 = newJObject()
  if body != nil:
    body_606226 = body
  result = call_606225.call(nil, nil, nil, nil, body_606226)

var addThingToThingGroup* = Call_AddThingToThingGroup_606213(
    name: "addThingToThingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/addThingToThingGroup",
    validator: validate_AddThingToThingGroup_606214, base: "/",
    url: url_AddThingToThingGroup_606215, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AssociateTargetsWithJob_606227 = ref object of OpenApiRestCall_605589
proc url_AssociateTargetsWithJob_606229(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/targets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AssociateTargetsWithJob_606228(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_606230 = path.getOrDefault("jobId")
  valid_606230 = validateParameter(valid_606230, JString, required = true,
                                 default = nil)
  if valid_606230 != nil:
    section.add "jobId", valid_606230
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606231 = header.getOrDefault("X-Amz-Signature")
  valid_606231 = validateParameter(valid_606231, JString, required = false,
                                 default = nil)
  if valid_606231 != nil:
    section.add "X-Amz-Signature", valid_606231
  var valid_606232 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606232 = validateParameter(valid_606232, JString, required = false,
                                 default = nil)
  if valid_606232 != nil:
    section.add "X-Amz-Content-Sha256", valid_606232
  var valid_606233 = header.getOrDefault("X-Amz-Date")
  valid_606233 = validateParameter(valid_606233, JString, required = false,
                                 default = nil)
  if valid_606233 != nil:
    section.add "X-Amz-Date", valid_606233
  var valid_606234 = header.getOrDefault("X-Amz-Credential")
  valid_606234 = validateParameter(valid_606234, JString, required = false,
                                 default = nil)
  if valid_606234 != nil:
    section.add "X-Amz-Credential", valid_606234
  var valid_606235 = header.getOrDefault("X-Amz-Security-Token")
  valid_606235 = validateParameter(valid_606235, JString, required = false,
                                 default = nil)
  if valid_606235 != nil:
    section.add "X-Amz-Security-Token", valid_606235
  var valid_606236 = header.getOrDefault("X-Amz-Algorithm")
  valid_606236 = validateParameter(valid_606236, JString, required = false,
                                 default = nil)
  if valid_606236 != nil:
    section.add "X-Amz-Algorithm", valid_606236
  var valid_606237 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606237 = validateParameter(valid_606237, JString, required = false,
                                 default = nil)
  if valid_606237 != nil:
    section.add "X-Amz-SignedHeaders", valid_606237
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606239: Call_AssociateTargetsWithJob_606227; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ## 
  let valid = call_606239.validator(path, query, header, formData, body)
  let scheme = call_606239.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606239.url(scheme.get, call_606239.host, call_606239.base,
                         call_606239.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606239, url, valid)

proc call*(call_606240: Call_AssociateTargetsWithJob_606227; jobId: string;
          body: JsonNode): Recallable =
  ## associateTargetsWithJob
  ## <p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to "CONTINUOUS".</p> </li> <li> <p>The job status must currently be "IN_PROGRESS".</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul>
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   body: JObject (required)
  var path_606241 = newJObject()
  var body_606242 = newJObject()
  add(path_606241, "jobId", newJString(jobId))
  if body != nil:
    body_606242 = body
  result = call_606240.call(path_606241, nil, nil, nil, body_606242)

var associateTargetsWithJob* = Call_AssociateTargetsWithJob_606227(
    name: "associateTargetsWithJob", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/jobs/{jobId}/targets",
    validator: validate_AssociateTargetsWithJob_606228, base: "/",
    url: url_AssociateTargetsWithJob_606229, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachPolicy_606243 = ref object of OpenApiRestCall_605589
proc url_AttachPolicy_606245(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/target-policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachPolicy_606244(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Attaches a policy to the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to attach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_606246 = path.getOrDefault("policyName")
  valid_606246 = validateParameter(valid_606246, JString, required = true,
                                 default = nil)
  if valid_606246 != nil:
    section.add "policyName", valid_606246
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606247 = header.getOrDefault("X-Amz-Signature")
  valid_606247 = validateParameter(valid_606247, JString, required = false,
                                 default = nil)
  if valid_606247 != nil:
    section.add "X-Amz-Signature", valid_606247
  var valid_606248 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606248 = validateParameter(valid_606248, JString, required = false,
                                 default = nil)
  if valid_606248 != nil:
    section.add "X-Amz-Content-Sha256", valid_606248
  var valid_606249 = header.getOrDefault("X-Amz-Date")
  valid_606249 = validateParameter(valid_606249, JString, required = false,
                                 default = nil)
  if valid_606249 != nil:
    section.add "X-Amz-Date", valid_606249
  var valid_606250 = header.getOrDefault("X-Amz-Credential")
  valid_606250 = validateParameter(valid_606250, JString, required = false,
                                 default = nil)
  if valid_606250 != nil:
    section.add "X-Amz-Credential", valid_606250
  var valid_606251 = header.getOrDefault("X-Amz-Security-Token")
  valid_606251 = validateParameter(valid_606251, JString, required = false,
                                 default = nil)
  if valid_606251 != nil:
    section.add "X-Amz-Security-Token", valid_606251
  var valid_606252 = header.getOrDefault("X-Amz-Algorithm")
  valid_606252 = validateParameter(valid_606252, JString, required = false,
                                 default = nil)
  if valid_606252 != nil:
    section.add "X-Amz-Algorithm", valid_606252
  var valid_606253 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606253 = validateParameter(valid_606253, JString, required = false,
                                 default = nil)
  if valid_606253 != nil:
    section.add "X-Amz-SignedHeaders", valid_606253
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606255: Call_AttachPolicy_606243; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Attaches a policy to the specified target.
  ## 
  let valid = call_606255.validator(path, query, header, formData, body)
  let scheme = call_606255.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606255.url(scheme.get, call_606255.host, call_606255.base,
                         call_606255.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606255, url, valid)

proc call*(call_606256: Call_AttachPolicy_606243; policyName: string; body: JsonNode): Recallable =
  ## attachPolicy
  ## Attaches a policy to the specified target.
  ##   policyName: string (required)
  ##             : The name of the policy to attach.
  ##   body: JObject (required)
  var path_606257 = newJObject()
  var body_606258 = newJObject()
  add(path_606257, "policyName", newJString(policyName))
  if body != nil:
    body_606258 = body
  result = call_606256.call(path_606257, nil, nil, nil, body_606258)

var attachPolicy* = Call_AttachPolicy_606243(name: "attachPolicy",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/target-policies/{policyName}", validator: validate_AttachPolicy_606244,
    base: "/", url: url_AttachPolicy_606245, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachPolicy_606259 = ref object of OpenApiRestCall_605589
proc url_DetachPolicy_606261(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/target-policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachPolicy_606260(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Detaches a policy from the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy to detach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_606262 = path.getOrDefault("policyName")
  valid_606262 = validateParameter(valid_606262, JString, required = true,
                                 default = nil)
  if valid_606262 != nil:
    section.add "policyName", valid_606262
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606263 = header.getOrDefault("X-Amz-Signature")
  valid_606263 = validateParameter(valid_606263, JString, required = false,
                                 default = nil)
  if valid_606263 != nil:
    section.add "X-Amz-Signature", valid_606263
  var valid_606264 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606264 = validateParameter(valid_606264, JString, required = false,
                                 default = nil)
  if valid_606264 != nil:
    section.add "X-Amz-Content-Sha256", valid_606264
  var valid_606265 = header.getOrDefault("X-Amz-Date")
  valid_606265 = validateParameter(valid_606265, JString, required = false,
                                 default = nil)
  if valid_606265 != nil:
    section.add "X-Amz-Date", valid_606265
  var valid_606266 = header.getOrDefault("X-Amz-Credential")
  valid_606266 = validateParameter(valid_606266, JString, required = false,
                                 default = nil)
  if valid_606266 != nil:
    section.add "X-Amz-Credential", valid_606266
  var valid_606267 = header.getOrDefault("X-Amz-Security-Token")
  valid_606267 = validateParameter(valid_606267, JString, required = false,
                                 default = nil)
  if valid_606267 != nil:
    section.add "X-Amz-Security-Token", valid_606267
  var valid_606268 = header.getOrDefault("X-Amz-Algorithm")
  valid_606268 = validateParameter(valid_606268, JString, required = false,
                                 default = nil)
  if valid_606268 != nil:
    section.add "X-Amz-Algorithm", valid_606268
  var valid_606269 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606269 = validateParameter(valid_606269, JString, required = false,
                                 default = nil)
  if valid_606269 != nil:
    section.add "X-Amz-SignedHeaders", valid_606269
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606271: Call_DetachPolicy_606259; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Detaches a policy from the specified target.
  ## 
  let valid = call_606271.validator(path, query, header, formData, body)
  let scheme = call_606271.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606271.url(scheme.get, call_606271.host, call_606271.base,
                         call_606271.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606271, url, valid)

proc call*(call_606272: Call_DetachPolicy_606259; policyName: string; body: JsonNode): Recallable =
  ## detachPolicy
  ## Detaches a policy from the specified target.
  ##   policyName: string (required)
  ##             : The policy to detach.
  ##   body: JObject (required)
  var path_606273 = newJObject()
  var body_606274 = newJObject()
  add(path_606273, "policyName", newJString(policyName))
  if body != nil:
    body_606274 = body
  result = call_606272.call(path_606273, nil, nil, nil, body_606274)

var detachPolicy* = Call_DetachPolicy_606259(name: "detachPolicy",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/target-policies/{policyName}", validator: validate_DetachPolicy_606260,
    base: "/", url: url_DetachPolicy_606261, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachPrincipalPolicy_606275 = ref object of OpenApiRestCall_605589
proc url_AttachPrincipalPolicy_606277(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/principal-policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "#x-amzn-iot-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachPrincipalPolicy_606276(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_606278 = path.getOrDefault("policyName")
  valid_606278 = validateParameter(valid_606278, JString, required = true,
                                 default = nil)
  if valid_606278 != nil:
    section.add "policyName", valid_606278
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606279 = header.getOrDefault("X-Amz-Signature")
  valid_606279 = validateParameter(valid_606279, JString, required = false,
                                 default = nil)
  if valid_606279 != nil:
    section.add "X-Amz-Signature", valid_606279
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_606280 = header.getOrDefault("x-amzn-iot-principal")
  valid_606280 = validateParameter(valid_606280, JString, required = true,
                                 default = nil)
  if valid_606280 != nil:
    section.add "x-amzn-iot-principal", valid_606280
  var valid_606281 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606281 = validateParameter(valid_606281, JString, required = false,
                                 default = nil)
  if valid_606281 != nil:
    section.add "X-Amz-Content-Sha256", valid_606281
  var valid_606282 = header.getOrDefault("X-Amz-Date")
  valid_606282 = validateParameter(valid_606282, JString, required = false,
                                 default = nil)
  if valid_606282 != nil:
    section.add "X-Amz-Date", valid_606282
  var valid_606283 = header.getOrDefault("X-Amz-Credential")
  valid_606283 = validateParameter(valid_606283, JString, required = false,
                                 default = nil)
  if valid_606283 != nil:
    section.add "X-Amz-Credential", valid_606283
  var valid_606284 = header.getOrDefault("X-Amz-Security-Token")
  valid_606284 = validateParameter(valid_606284, JString, required = false,
                                 default = nil)
  if valid_606284 != nil:
    section.add "X-Amz-Security-Token", valid_606284
  var valid_606285 = header.getOrDefault("X-Amz-Algorithm")
  valid_606285 = validateParameter(valid_606285, JString, required = false,
                                 default = nil)
  if valid_606285 != nil:
    section.add "X-Amz-Algorithm", valid_606285
  var valid_606286 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606286 = validateParameter(valid_606286, JString, required = false,
                                 default = nil)
  if valid_606286 != nil:
    section.add "X-Amz-SignedHeaders", valid_606286
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606287: Call_AttachPrincipalPolicy_606275; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ## 
  let valid = call_606287.validator(path, query, header, formData, body)
  let scheme = call_606287.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606287.url(scheme.get, call_606287.host, call_606287.base,
                         call_606287.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606287, url, valid)

proc call*(call_606288: Call_AttachPrincipalPolicy_606275; policyName: string): Recallable =
  ## attachPrincipalPolicy
  ## <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
  ##   policyName: string (required)
  ##             : The policy name.
  var path_606289 = newJObject()
  add(path_606289, "policyName", newJString(policyName))
  result = call_606288.call(path_606289, nil, nil, nil, nil)

var attachPrincipalPolicy* = Call_AttachPrincipalPolicy_606275(
    name: "attachPrincipalPolicy", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/principal-policies/{policyName}#x-amzn-iot-principal",
    validator: validate_AttachPrincipalPolicy_606276, base: "/",
    url: url_AttachPrincipalPolicy_606277, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachPrincipalPolicy_606290 = ref object of OpenApiRestCall_605589
proc url_DetachPrincipalPolicy_606292(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/principal-policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "#x-amzn-iot-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachPrincipalPolicy_606291(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to detach.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_606293 = path.getOrDefault("policyName")
  valid_606293 = validateParameter(valid_606293, JString, required = true,
                                 default = nil)
  if valid_606293 != nil:
    section.add "policyName", valid_606293
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : <p>The principal.</p> <p>If the principal is a certificate, specify the certificate ARN. If the principal is an Amazon Cognito identity, specify the identity ID.</p>
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606294 = header.getOrDefault("X-Amz-Signature")
  valid_606294 = validateParameter(valid_606294, JString, required = false,
                                 default = nil)
  if valid_606294 != nil:
    section.add "X-Amz-Signature", valid_606294
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_606295 = header.getOrDefault("x-amzn-iot-principal")
  valid_606295 = validateParameter(valid_606295, JString, required = true,
                                 default = nil)
  if valid_606295 != nil:
    section.add "x-amzn-iot-principal", valid_606295
  var valid_606296 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606296 = validateParameter(valid_606296, JString, required = false,
                                 default = nil)
  if valid_606296 != nil:
    section.add "X-Amz-Content-Sha256", valid_606296
  var valid_606297 = header.getOrDefault("X-Amz-Date")
  valid_606297 = validateParameter(valid_606297, JString, required = false,
                                 default = nil)
  if valid_606297 != nil:
    section.add "X-Amz-Date", valid_606297
  var valid_606298 = header.getOrDefault("X-Amz-Credential")
  valid_606298 = validateParameter(valid_606298, JString, required = false,
                                 default = nil)
  if valid_606298 != nil:
    section.add "X-Amz-Credential", valid_606298
  var valid_606299 = header.getOrDefault("X-Amz-Security-Token")
  valid_606299 = validateParameter(valid_606299, JString, required = false,
                                 default = nil)
  if valid_606299 != nil:
    section.add "X-Amz-Security-Token", valid_606299
  var valid_606300 = header.getOrDefault("X-Amz-Algorithm")
  valid_606300 = validateParameter(valid_606300, JString, required = false,
                                 default = nil)
  if valid_606300 != nil:
    section.add "X-Amz-Algorithm", valid_606300
  var valid_606301 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606301 = validateParameter(valid_606301, JString, required = false,
                                 default = nil)
  if valid_606301 != nil:
    section.add "X-Amz-SignedHeaders", valid_606301
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606302: Call_DetachPrincipalPolicy_606290; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ## 
  let valid = call_606302.validator(path, query, header, formData, body)
  let scheme = call_606302.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606302.url(scheme.get, call_606302.host, call_606302.base,
                         call_606302.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606302, url, valid)

proc call*(call_606303: Call_DetachPrincipalPolicy_606290; policyName: string): Recallable =
  ## detachPrincipalPolicy
  ## <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
  ##   policyName: string (required)
  ##             : The name of the policy to detach.
  var path_606304 = newJObject()
  add(path_606304, "policyName", newJString(policyName))
  result = call_606303.call(path_606304, nil, nil, nil, nil)

var detachPrincipalPolicy* = Call_DetachPrincipalPolicy_606290(
    name: "detachPrincipalPolicy", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/principal-policies/{policyName}#x-amzn-iot-principal",
    validator: validate_DetachPrincipalPolicy_606291, base: "/",
    url: url_DetachPrincipalPolicy_606292, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachSecurityProfile_606305 = ref object of OpenApiRestCall_605589
proc url_AttachSecurityProfile_606307(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"), (
        kind: ConstantSegment, value: "/targets#securityProfileTargetArn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachSecurityProfile_606306(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile that is attached.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_606308 = path.getOrDefault("securityProfileName")
  valid_606308 = validateParameter(valid_606308, JString, required = true,
                                 default = nil)
  if valid_606308 != nil:
    section.add "securityProfileName", valid_606308
  result.add "path", section
  ## parameters in `query` object:
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the target (thing group) to which the security profile is attached.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_606309 = query.getOrDefault("securityProfileTargetArn")
  valid_606309 = validateParameter(valid_606309, JString, required = true,
                                 default = nil)
  if valid_606309 != nil:
    section.add "securityProfileTargetArn", valid_606309
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606310 = header.getOrDefault("X-Amz-Signature")
  valid_606310 = validateParameter(valid_606310, JString, required = false,
                                 default = nil)
  if valid_606310 != nil:
    section.add "X-Amz-Signature", valid_606310
  var valid_606311 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606311 = validateParameter(valid_606311, JString, required = false,
                                 default = nil)
  if valid_606311 != nil:
    section.add "X-Amz-Content-Sha256", valid_606311
  var valid_606312 = header.getOrDefault("X-Amz-Date")
  valid_606312 = validateParameter(valid_606312, JString, required = false,
                                 default = nil)
  if valid_606312 != nil:
    section.add "X-Amz-Date", valid_606312
  var valid_606313 = header.getOrDefault("X-Amz-Credential")
  valid_606313 = validateParameter(valid_606313, JString, required = false,
                                 default = nil)
  if valid_606313 != nil:
    section.add "X-Amz-Credential", valid_606313
  var valid_606314 = header.getOrDefault("X-Amz-Security-Token")
  valid_606314 = validateParameter(valid_606314, JString, required = false,
                                 default = nil)
  if valid_606314 != nil:
    section.add "X-Amz-Security-Token", valid_606314
  var valid_606315 = header.getOrDefault("X-Amz-Algorithm")
  valid_606315 = validateParameter(valid_606315, JString, required = false,
                                 default = nil)
  if valid_606315 != nil:
    section.add "X-Amz-Algorithm", valid_606315
  var valid_606316 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606316 = validateParameter(valid_606316, JString, required = false,
                                 default = nil)
  if valid_606316 != nil:
    section.add "X-Amz-SignedHeaders", valid_606316
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606317: Call_AttachSecurityProfile_606305; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ## 
  let valid = call_606317.validator(path, query, header, formData, body)
  let scheme = call_606317.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606317.url(scheme.get, call_606317.host, call_606317.base,
                         call_606317.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606317, url, valid)

proc call*(call_606318: Call_AttachSecurityProfile_606305;
          securityProfileTargetArn: string; securityProfileName: string): Recallable =
  ## attachSecurityProfile
  ## Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the target (thing group) to which the security profile is attached.
  ##   securityProfileName: string (required)
  ##                      : The security profile that is attached.
  var path_606319 = newJObject()
  var query_606320 = newJObject()
  add(query_606320, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(path_606319, "securityProfileName", newJString(securityProfileName))
  result = call_606318.call(path_606319, query_606320, nil, nil, nil)

var attachSecurityProfile* = Call_AttachSecurityProfile_606305(
    name: "attachSecurityProfile", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}/targets#securityProfileTargetArn",
    validator: validate_AttachSecurityProfile_606306, base: "/",
    url: url_AttachSecurityProfile_606307, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachSecurityProfile_606321 = ref object of OpenApiRestCall_605589
proc url_DetachSecurityProfile_606323(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"), (
        kind: ConstantSegment, value: "/targets#securityProfileTargetArn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachSecurityProfile_606322(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile that is detached.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_606324 = path.getOrDefault("securityProfileName")
  valid_606324 = validateParameter(valid_606324, JString, required = true,
                                 default = nil)
  if valid_606324 != nil:
    section.add "securityProfileName", valid_606324
  result.add "path", section
  ## parameters in `query` object:
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the thing group from which the security profile is detached.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_606325 = query.getOrDefault("securityProfileTargetArn")
  valid_606325 = validateParameter(valid_606325, JString, required = true,
                                 default = nil)
  if valid_606325 != nil:
    section.add "securityProfileTargetArn", valid_606325
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606326 = header.getOrDefault("X-Amz-Signature")
  valid_606326 = validateParameter(valid_606326, JString, required = false,
                                 default = nil)
  if valid_606326 != nil:
    section.add "X-Amz-Signature", valid_606326
  var valid_606327 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606327 = validateParameter(valid_606327, JString, required = false,
                                 default = nil)
  if valid_606327 != nil:
    section.add "X-Amz-Content-Sha256", valid_606327
  var valid_606328 = header.getOrDefault("X-Amz-Date")
  valid_606328 = validateParameter(valid_606328, JString, required = false,
                                 default = nil)
  if valid_606328 != nil:
    section.add "X-Amz-Date", valid_606328
  var valid_606329 = header.getOrDefault("X-Amz-Credential")
  valid_606329 = validateParameter(valid_606329, JString, required = false,
                                 default = nil)
  if valid_606329 != nil:
    section.add "X-Amz-Credential", valid_606329
  var valid_606330 = header.getOrDefault("X-Amz-Security-Token")
  valid_606330 = validateParameter(valid_606330, JString, required = false,
                                 default = nil)
  if valid_606330 != nil:
    section.add "X-Amz-Security-Token", valid_606330
  var valid_606331 = header.getOrDefault("X-Amz-Algorithm")
  valid_606331 = validateParameter(valid_606331, JString, required = false,
                                 default = nil)
  if valid_606331 != nil:
    section.add "X-Amz-Algorithm", valid_606331
  var valid_606332 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606332 = validateParameter(valid_606332, JString, required = false,
                                 default = nil)
  if valid_606332 != nil:
    section.add "X-Amz-SignedHeaders", valid_606332
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606333: Call_DetachSecurityProfile_606321; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ## 
  let valid = call_606333.validator(path, query, header, formData, body)
  let scheme = call_606333.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606333.url(scheme.get, call_606333.host, call_606333.base,
                         call_606333.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606333, url, valid)

proc call*(call_606334: Call_DetachSecurityProfile_606321;
          securityProfileTargetArn: string; securityProfileName: string): Recallable =
  ## detachSecurityProfile
  ## Disassociates a Device Defender security profile from a thing group or from this account.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the thing group from which the security profile is detached.
  ##   securityProfileName: string (required)
  ##                      : The security profile that is detached.
  var path_606335 = newJObject()
  var query_606336 = newJObject()
  add(query_606336, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(path_606335, "securityProfileName", newJString(securityProfileName))
  result = call_606334.call(path_606335, query_606336, nil, nil, nil)

var detachSecurityProfile* = Call_DetachSecurityProfile_606321(
    name: "detachSecurityProfile", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}/targets#securityProfileTargetArn",
    validator: validate_DetachSecurityProfile_606322, base: "/",
    url: url_DetachSecurityProfile_606323, schemes: {Scheme.Https, Scheme.Http})
type
  Call_AttachThingPrincipal_606337 = ref object of OpenApiRestCall_605589
proc url_AttachThingPrincipal_606339(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals#x-amzn-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_AttachThingPrincipal_606338(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_606340 = path.getOrDefault("thingName")
  valid_606340 = validateParameter(valid_606340, JString, required = true,
                                 default = nil)
  if valid_606340 != nil:
    section.add "thingName", valid_606340
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606341 = header.getOrDefault("X-Amz-Signature")
  valid_606341 = validateParameter(valid_606341, JString, required = false,
                                 default = nil)
  if valid_606341 != nil:
    section.add "X-Amz-Signature", valid_606341
  var valid_606342 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606342 = validateParameter(valid_606342, JString, required = false,
                                 default = nil)
  if valid_606342 != nil:
    section.add "X-Amz-Content-Sha256", valid_606342
  var valid_606343 = header.getOrDefault("X-Amz-Date")
  valid_606343 = validateParameter(valid_606343, JString, required = false,
                                 default = nil)
  if valid_606343 != nil:
    section.add "X-Amz-Date", valid_606343
  var valid_606344 = header.getOrDefault("X-Amz-Credential")
  valid_606344 = validateParameter(valid_606344, JString, required = false,
                                 default = nil)
  if valid_606344 != nil:
    section.add "X-Amz-Credential", valid_606344
  var valid_606345 = header.getOrDefault("X-Amz-Security-Token")
  valid_606345 = validateParameter(valid_606345, JString, required = false,
                                 default = nil)
  if valid_606345 != nil:
    section.add "X-Amz-Security-Token", valid_606345
  var valid_606346 = header.getOrDefault("X-Amz-Algorithm")
  valid_606346 = validateParameter(valid_606346, JString, required = false,
                                 default = nil)
  if valid_606346 != nil:
    section.add "X-Amz-Algorithm", valid_606346
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_606347 = header.getOrDefault("x-amzn-principal")
  valid_606347 = validateParameter(valid_606347, JString, required = true,
                                 default = nil)
  if valid_606347 != nil:
    section.add "x-amzn-principal", valid_606347
  var valid_606348 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606348 = validateParameter(valid_606348, JString, required = false,
                                 default = nil)
  if valid_606348 != nil:
    section.add "X-Amz-SignedHeaders", valid_606348
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606349: Call_AttachThingPrincipal_606337; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  let valid = call_606349.validator(path, query, header, formData, body)
  let scheme = call_606349.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606349.url(scheme.get, call_606349.host, call_606349.base,
                         call_606349.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606349, url, valid)

proc call*(call_606350: Call_AttachThingPrincipal_606337; thingName: string): Recallable =
  ## attachThingPrincipal
  ## Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_606351 = newJObject()
  add(path_606351, "thingName", newJString(thingName))
  result = call_606350.call(path_606351, nil, nil, nil, nil)

var attachThingPrincipal* = Call_AttachThingPrincipal_606337(
    name: "attachThingPrincipal", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/things/{thingName}/principals#x-amzn-principal",
    validator: validate_AttachThingPrincipal_606338, base: "/",
    url: url_AttachThingPrincipal_606339, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DetachThingPrincipal_606352 = ref object of OpenApiRestCall_605589
proc url_DetachThingPrincipal_606354(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals#x-amzn-principal")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DetachThingPrincipal_606353(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_606355 = path.getOrDefault("thingName")
  valid_606355 = validateParameter(valid_606355, JString, required = true,
                                 default = nil)
  if valid_606355 != nil:
    section.add "thingName", valid_606355
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606356 = header.getOrDefault("X-Amz-Signature")
  valid_606356 = validateParameter(valid_606356, JString, required = false,
                                 default = nil)
  if valid_606356 != nil:
    section.add "X-Amz-Signature", valid_606356
  var valid_606357 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606357 = validateParameter(valid_606357, JString, required = false,
                                 default = nil)
  if valid_606357 != nil:
    section.add "X-Amz-Content-Sha256", valid_606357
  var valid_606358 = header.getOrDefault("X-Amz-Date")
  valid_606358 = validateParameter(valid_606358, JString, required = false,
                                 default = nil)
  if valid_606358 != nil:
    section.add "X-Amz-Date", valid_606358
  var valid_606359 = header.getOrDefault("X-Amz-Credential")
  valid_606359 = validateParameter(valid_606359, JString, required = false,
                                 default = nil)
  if valid_606359 != nil:
    section.add "X-Amz-Credential", valid_606359
  var valid_606360 = header.getOrDefault("X-Amz-Security-Token")
  valid_606360 = validateParameter(valid_606360, JString, required = false,
                                 default = nil)
  if valid_606360 != nil:
    section.add "X-Amz-Security-Token", valid_606360
  var valid_606361 = header.getOrDefault("X-Amz-Algorithm")
  valid_606361 = validateParameter(valid_606361, JString, required = false,
                                 default = nil)
  if valid_606361 != nil:
    section.add "X-Amz-Algorithm", valid_606361
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_606362 = header.getOrDefault("x-amzn-principal")
  valid_606362 = validateParameter(valid_606362, JString, required = true,
                                 default = nil)
  if valid_606362 != nil:
    section.add "x-amzn-principal", valid_606362
  var valid_606363 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606363 = validateParameter(valid_606363, JString, required = false,
                                 default = nil)
  if valid_606363 != nil:
    section.add "X-Amz-SignedHeaders", valid_606363
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606364: Call_DetachThingPrincipal_606352; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ## 
  let valid = call_606364.validator(path, query, header, formData, body)
  let scheme = call_606364.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606364.url(scheme.get, call_606364.host, call_606364.base,
                         call_606364.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606364, url, valid)

proc call*(call_606365: Call_DetachThingPrincipal_606352; thingName: string): Recallable =
  ## detachThingPrincipal
  ## <p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_606366 = newJObject()
  add(path_606366, "thingName", newJString(thingName))
  result = call_606365.call(path_606366, nil, nil, nil, nil)

var detachThingPrincipal* = Call_DetachThingPrincipal_606352(
    name: "detachThingPrincipal", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/things/{thingName}/principals#x-amzn-principal",
    validator: validate_DetachThingPrincipal_606353, base: "/",
    url: url_DetachThingPrincipal_606354, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelAuditMitigationActionsTask_606367 = ref object of OpenApiRestCall_605589
proc url_CancelAuditMitigationActionsTask_606369(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelAuditMitigationActionsTask_606368(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The unique identifier for the task that you want to cancel. 
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_606370 = path.getOrDefault("taskId")
  valid_606370 = validateParameter(valid_606370, JString, required = true,
                                 default = nil)
  if valid_606370 != nil:
    section.add "taskId", valid_606370
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606371 = header.getOrDefault("X-Amz-Signature")
  valid_606371 = validateParameter(valid_606371, JString, required = false,
                                 default = nil)
  if valid_606371 != nil:
    section.add "X-Amz-Signature", valid_606371
  var valid_606372 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606372 = validateParameter(valid_606372, JString, required = false,
                                 default = nil)
  if valid_606372 != nil:
    section.add "X-Amz-Content-Sha256", valid_606372
  var valid_606373 = header.getOrDefault("X-Amz-Date")
  valid_606373 = validateParameter(valid_606373, JString, required = false,
                                 default = nil)
  if valid_606373 != nil:
    section.add "X-Amz-Date", valid_606373
  var valid_606374 = header.getOrDefault("X-Amz-Credential")
  valid_606374 = validateParameter(valid_606374, JString, required = false,
                                 default = nil)
  if valid_606374 != nil:
    section.add "X-Amz-Credential", valid_606374
  var valid_606375 = header.getOrDefault("X-Amz-Security-Token")
  valid_606375 = validateParameter(valid_606375, JString, required = false,
                                 default = nil)
  if valid_606375 != nil:
    section.add "X-Amz-Security-Token", valid_606375
  var valid_606376 = header.getOrDefault("X-Amz-Algorithm")
  valid_606376 = validateParameter(valid_606376, JString, required = false,
                                 default = nil)
  if valid_606376 != nil:
    section.add "X-Amz-Algorithm", valid_606376
  var valid_606377 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606377 = validateParameter(valid_606377, JString, required = false,
                                 default = nil)
  if valid_606377 != nil:
    section.add "X-Amz-SignedHeaders", valid_606377
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606378: Call_CancelAuditMitigationActionsTask_606367;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ## 
  let valid = call_606378.validator(path, query, header, formData, body)
  let scheme = call_606378.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606378.url(scheme.get, call_606378.host, call_606378.base,
                         call_606378.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606378, url, valid)

proc call*(call_606379: Call_CancelAuditMitigationActionsTask_606367;
          taskId: string): Recallable =
  ## cancelAuditMitigationActionsTask
  ## Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.
  ##   taskId: string (required)
  ##         : The unique identifier for the task that you want to cancel. 
  var path_606380 = newJObject()
  add(path_606380, "taskId", newJString(taskId))
  result = call_606379.call(path_606380, nil, nil, nil, nil)

var cancelAuditMitigationActionsTask* = Call_CancelAuditMitigationActionsTask_606367(
    name: "cancelAuditMitigationActionsTask", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/tasks/{taskId}/cancel",
    validator: validate_CancelAuditMitigationActionsTask_606368, base: "/",
    url: url_CancelAuditMitigationActionsTask_606369,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelAuditTask_606381 = ref object of OpenApiRestCall_605589
proc url_CancelAuditTask_606383(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelAuditTask_606382(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_606384 = path.getOrDefault("taskId")
  valid_606384 = validateParameter(valid_606384, JString, required = true,
                                 default = nil)
  if valid_606384 != nil:
    section.add "taskId", valid_606384
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606385 = header.getOrDefault("X-Amz-Signature")
  valid_606385 = validateParameter(valid_606385, JString, required = false,
                                 default = nil)
  if valid_606385 != nil:
    section.add "X-Amz-Signature", valid_606385
  var valid_606386 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606386 = validateParameter(valid_606386, JString, required = false,
                                 default = nil)
  if valid_606386 != nil:
    section.add "X-Amz-Content-Sha256", valid_606386
  var valid_606387 = header.getOrDefault("X-Amz-Date")
  valid_606387 = validateParameter(valid_606387, JString, required = false,
                                 default = nil)
  if valid_606387 != nil:
    section.add "X-Amz-Date", valid_606387
  var valid_606388 = header.getOrDefault("X-Amz-Credential")
  valid_606388 = validateParameter(valid_606388, JString, required = false,
                                 default = nil)
  if valid_606388 != nil:
    section.add "X-Amz-Credential", valid_606388
  var valid_606389 = header.getOrDefault("X-Amz-Security-Token")
  valid_606389 = validateParameter(valid_606389, JString, required = false,
                                 default = nil)
  if valid_606389 != nil:
    section.add "X-Amz-Security-Token", valid_606389
  var valid_606390 = header.getOrDefault("X-Amz-Algorithm")
  valid_606390 = validateParameter(valid_606390, JString, required = false,
                                 default = nil)
  if valid_606390 != nil:
    section.add "X-Amz-Algorithm", valid_606390
  var valid_606391 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606391 = validateParameter(valid_606391, JString, required = false,
                                 default = nil)
  if valid_606391 != nil:
    section.add "X-Amz-SignedHeaders", valid_606391
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606392: Call_CancelAuditTask_606381; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ## 
  let valid = call_606392.validator(path, query, header, formData, body)
  let scheme = call_606392.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606392.url(scheme.get, call_606392.host, call_606392.base,
                         call_606392.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606392, url, valid)

proc call*(call_606393: Call_CancelAuditTask_606381; taskId: string): Recallable =
  ## cancelAuditTask
  ## Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.
  ##   taskId: string (required)
  ##         : The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
  var path_606394 = newJObject()
  add(path_606394, "taskId", newJString(taskId))
  result = call_606393.call(path_606394, nil, nil, nil, nil)

var cancelAuditTask* = Call_CancelAuditTask_606381(name: "cancelAuditTask",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/audit/tasks/{taskId}/cancel", validator: validate_CancelAuditTask_606382,
    base: "/", url: url_CancelAuditTask_606383, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelCertificateTransfer_606395 = ref object of OpenApiRestCall_605589
proc url_CancelCertificateTransfer_606397(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cancel-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelCertificateTransfer_606396(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_606398 = path.getOrDefault("certificateId")
  valid_606398 = validateParameter(valid_606398, JString, required = true,
                                 default = nil)
  if valid_606398 != nil:
    section.add "certificateId", valid_606398
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606399 = header.getOrDefault("X-Amz-Signature")
  valid_606399 = validateParameter(valid_606399, JString, required = false,
                                 default = nil)
  if valid_606399 != nil:
    section.add "X-Amz-Signature", valid_606399
  var valid_606400 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606400 = validateParameter(valid_606400, JString, required = false,
                                 default = nil)
  if valid_606400 != nil:
    section.add "X-Amz-Content-Sha256", valid_606400
  var valid_606401 = header.getOrDefault("X-Amz-Date")
  valid_606401 = validateParameter(valid_606401, JString, required = false,
                                 default = nil)
  if valid_606401 != nil:
    section.add "X-Amz-Date", valid_606401
  var valid_606402 = header.getOrDefault("X-Amz-Credential")
  valid_606402 = validateParameter(valid_606402, JString, required = false,
                                 default = nil)
  if valid_606402 != nil:
    section.add "X-Amz-Credential", valid_606402
  var valid_606403 = header.getOrDefault("X-Amz-Security-Token")
  valid_606403 = validateParameter(valid_606403, JString, required = false,
                                 default = nil)
  if valid_606403 != nil:
    section.add "X-Amz-Security-Token", valid_606403
  var valid_606404 = header.getOrDefault("X-Amz-Algorithm")
  valid_606404 = validateParameter(valid_606404, JString, required = false,
                                 default = nil)
  if valid_606404 != nil:
    section.add "X-Amz-Algorithm", valid_606404
  var valid_606405 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606405 = validateParameter(valid_606405, JString, required = false,
                                 default = nil)
  if valid_606405 != nil:
    section.add "X-Amz-SignedHeaders", valid_606405
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606406: Call_CancelCertificateTransfer_606395; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ## 
  let valid = call_606406.validator(path, query, header, formData, body)
  let scheme = call_606406.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606406.url(scheme.get, call_606406.host, call_606406.base,
                         call_606406.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606406, url, valid)

proc call*(call_606407: Call_CancelCertificateTransfer_606395;
          certificateId: string): Recallable =
  ## cancelCertificateTransfer
  ## <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_606408 = newJObject()
  add(path_606408, "certificateId", newJString(certificateId))
  result = call_606407.call(path_606408, nil, nil, nil, nil)

var cancelCertificateTransfer* = Call_CancelCertificateTransfer_606395(
    name: "cancelCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/cancel-certificate-transfer/{certificateId}",
    validator: validate_CancelCertificateTransfer_606396, base: "/",
    url: url_CancelCertificateTransfer_606397,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelJob_606409 = ref object of OpenApiRestCall_605589
proc url_CancelJob_606411(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelJob_606410(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_606412 = path.getOrDefault("jobId")
  valid_606412 = validateParameter(valid_606412, JString, required = true,
                                 default = nil)
  if valid_606412 != nil:
    section.add "jobId", valid_606412
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
  section = newJObject()
  var valid_606413 = query.getOrDefault("force")
  valid_606413 = validateParameter(valid_606413, JBool, required = false, default = nil)
  if valid_606413 != nil:
    section.add "force", valid_606413
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606414 = header.getOrDefault("X-Amz-Signature")
  valid_606414 = validateParameter(valid_606414, JString, required = false,
                                 default = nil)
  if valid_606414 != nil:
    section.add "X-Amz-Signature", valid_606414
  var valid_606415 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606415 = validateParameter(valid_606415, JString, required = false,
                                 default = nil)
  if valid_606415 != nil:
    section.add "X-Amz-Content-Sha256", valid_606415
  var valid_606416 = header.getOrDefault("X-Amz-Date")
  valid_606416 = validateParameter(valid_606416, JString, required = false,
                                 default = nil)
  if valid_606416 != nil:
    section.add "X-Amz-Date", valid_606416
  var valid_606417 = header.getOrDefault("X-Amz-Credential")
  valid_606417 = validateParameter(valid_606417, JString, required = false,
                                 default = nil)
  if valid_606417 != nil:
    section.add "X-Amz-Credential", valid_606417
  var valid_606418 = header.getOrDefault("X-Amz-Security-Token")
  valid_606418 = validateParameter(valid_606418, JString, required = false,
                                 default = nil)
  if valid_606418 != nil:
    section.add "X-Amz-Security-Token", valid_606418
  var valid_606419 = header.getOrDefault("X-Amz-Algorithm")
  valid_606419 = validateParameter(valid_606419, JString, required = false,
                                 default = nil)
  if valid_606419 != nil:
    section.add "X-Amz-Algorithm", valid_606419
  var valid_606420 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606420 = validateParameter(valid_606420, JString, required = false,
                                 default = nil)
  if valid_606420 != nil:
    section.add "X-Amz-SignedHeaders", valid_606420
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606422: Call_CancelJob_606409; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a job.
  ## 
  let valid = call_606422.validator(path, query, header, formData, body)
  let scheme = call_606422.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606422.url(scheme.get, call_606422.host, call_606422.base,
                         call_606422.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606422, url, valid)

proc call*(call_606423: Call_CancelJob_606409; jobId: string; body: JsonNode;
          force: bool = false): Recallable =
  ## cancelJob
  ## Cancels a job.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   force: bool
  ##        : <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
  ##   body: JObject (required)
  var path_606424 = newJObject()
  var query_606425 = newJObject()
  var body_606426 = newJObject()
  add(path_606424, "jobId", newJString(jobId))
  add(query_606425, "force", newJBool(force))
  if body != nil:
    body_606426 = body
  result = call_606423.call(path_606424, query_606425, nil, nil, body_606426)

var cancelJob* = Call_CancelJob_606409(name: "cancelJob", meth: HttpMethod.HttpPut,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}/cancel",
                                    validator: validate_CancelJob_606410,
                                    base: "/", url: url_CancelJob_606411,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelJobExecution_606427 = ref object of OpenApiRestCall_605589
proc url_CancelJobExecution_606429(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CancelJobExecution_606428(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Cancels the execution of a job for a given thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The ID of the job to be canceled.
  ##   thingName: JString (required)
  ##            : The name of the thing whose execution of the job will be canceled.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_606430 = path.getOrDefault("jobId")
  valid_606430 = validateParameter(valid_606430, JString, required = true,
                                 default = nil)
  if valid_606430 != nil:
    section.add "jobId", valid_606430
  var valid_606431 = path.getOrDefault("thingName")
  valid_606431 = validateParameter(valid_606431, JString, required = true,
                                 default = nil)
  if valid_606431 != nil:
    section.add "thingName", valid_606431
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
  section = newJObject()
  var valid_606432 = query.getOrDefault("force")
  valid_606432 = validateParameter(valid_606432, JBool, required = false, default = nil)
  if valid_606432 != nil:
    section.add "force", valid_606432
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606433 = header.getOrDefault("X-Amz-Signature")
  valid_606433 = validateParameter(valid_606433, JString, required = false,
                                 default = nil)
  if valid_606433 != nil:
    section.add "X-Amz-Signature", valid_606433
  var valid_606434 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606434 = validateParameter(valid_606434, JString, required = false,
                                 default = nil)
  if valid_606434 != nil:
    section.add "X-Amz-Content-Sha256", valid_606434
  var valid_606435 = header.getOrDefault("X-Amz-Date")
  valid_606435 = validateParameter(valid_606435, JString, required = false,
                                 default = nil)
  if valid_606435 != nil:
    section.add "X-Amz-Date", valid_606435
  var valid_606436 = header.getOrDefault("X-Amz-Credential")
  valid_606436 = validateParameter(valid_606436, JString, required = false,
                                 default = nil)
  if valid_606436 != nil:
    section.add "X-Amz-Credential", valid_606436
  var valid_606437 = header.getOrDefault("X-Amz-Security-Token")
  valid_606437 = validateParameter(valid_606437, JString, required = false,
                                 default = nil)
  if valid_606437 != nil:
    section.add "X-Amz-Security-Token", valid_606437
  var valid_606438 = header.getOrDefault("X-Amz-Algorithm")
  valid_606438 = validateParameter(valid_606438, JString, required = false,
                                 default = nil)
  if valid_606438 != nil:
    section.add "X-Amz-Algorithm", valid_606438
  var valid_606439 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606439 = validateParameter(valid_606439, JString, required = false,
                                 default = nil)
  if valid_606439 != nil:
    section.add "X-Amz-SignedHeaders", valid_606439
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606441: Call_CancelJobExecution_606427; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels the execution of a job for a given thing.
  ## 
  let valid = call_606441.validator(path, query, header, formData, body)
  let scheme = call_606441.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606441.url(scheme.get, call_606441.host, call_606441.base,
                         call_606441.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606441, url, valid)

proc call*(call_606442: Call_CancelJobExecution_606427; jobId: string;
          thingName: string; body: JsonNode; force: bool = false): Recallable =
  ## cancelJobExecution
  ## Cancels the execution of a job for a given thing.
  ##   jobId: string (required)
  ##        : The ID of the job to be canceled.
  ##   thingName: string (required)
  ##            : The name of the thing whose execution of the job will be canceled.
  ##   force: bool
  ##        : <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
  ##   body: JObject (required)
  var path_606443 = newJObject()
  var query_606444 = newJObject()
  var body_606445 = newJObject()
  add(path_606443, "jobId", newJString(jobId))
  add(path_606443, "thingName", newJString(thingName))
  add(query_606444, "force", newJBool(force))
  if body != nil:
    body_606445 = body
  result = call_606442.call(path_606443, query_606444, nil, nil, body_606445)

var cancelJobExecution* = Call_CancelJobExecution_606427(
    name: "cancelJobExecution", meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/things/{thingName}/jobs/{jobId}/cancel",
    validator: validate_CancelJobExecution_606428, base: "/",
    url: url_CancelJobExecution_606429, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetDefaultAuthorizer_606458 = ref object of OpenApiRestCall_605589
proc url_SetDefaultAuthorizer_606460(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetDefaultAuthorizer_606459(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606461 = header.getOrDefault("X-Amz-Signature")
  valid_606461 = validateParameter(valid_606461, JString, required = false,
                                 default = nil)
  if valid_606461 != nil:
    section.add "X-Amz-Signature", valid_606461
  var valid_606462 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606462 = validateParameter(valid_606462, JString, required = false,
                                 default = nil)
  if valid_606462 != nil:
    section.add "X-Amz-Content-Sha256", valid_606462
  var valid_606463 = header.getOrDefault("X-Amz-Date")
  valid_606463 = validateParameter(valid_606463, JString, required = false,
                                 default = nil)
  if valid_606463 != nil:
    section.add "X-Amz-Date", valid_606463
  var valid_606464 = header.getOrDefault("X-Amz-Credential")
  valid_606464 = validateParameter(valid_606464, JString, required = false,
                                 default = nil)
  if valid_606464 != nil:
    section.add "X-Amz-Credential", valid_606464
  var valid_606465 = header.getOrDefault("X-Amz-Security-Token")
  valid_606465 = validateParameter(valid_606465, JString, required = false,
                                 default = nil)
  if valid_606465 != nil:
    section.add "X-Amz-Security-Token", valid_606465
  var valid_606466 = header.getOrDefault("X-Amz-Algorithm")
  valid_606466 = validateParameter(valid_606466, JString, required = false,
                                 default = nil)
  if valid_606466 != nil:
    section.add "X-Amz-Algorithm", valid_606466
  var valid_606467 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606467 = validateParameter(valid_606467, JString, required = false,
                                 default = nil)
  if valid_606467 != nil:
    section.add "X-Amz-SignedHeaders", valid_606467
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606469: Call_SetDefaultAuthorizer_606458; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ## 
  let valid = call_606469.validator(path, query, header, formData, body)
  let scheme = call_606469.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606469.url(scheme.get, call_606469.host, call_606469.base,
                         call_606469.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606469, url, valid)

proc call*(call_606470: Call_SetDefaultAuthorizer_606458; body: JsonNode): Recallable =
  ## setDefaultAuthorizer
  ## Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.
  ##   body: JObject (required)
  var body_606471 = newJObject()
  if body != nil:
    body_606471 = body
  result = call_606470.call(nil, nil, nil, nil, body_606471)

var setDefaultAuthorizer* = Call_SetDefaultAuthorizer_606458(
    name: "setDefaultAuthorizer", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_SetDefaultAuthorizer_606459, base: "/",
    url: url_SetDefaultAuthorizer_606460, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeDefaultAuthorizer_606446 = ref object of OpenApiRestCall_605589
proc url_DescribeDefaultAuthorizer_606448(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeDefaultAuthorizer_606447(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes the default authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606449 = header.getOrDefault("X-Amz-Signature")
  valid_606449 = validateParameter(valid_606449, JString, required = false,
                                 default = nil)
  if valid_606449 != nil:
    section.add "X-Amz-Signature", valid_606449
  var valid_606450 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606450 = validateParameter(valid_606450, JString, required = false,
                                 default = nil)
  if valid_606450 != nil:
    section.add "X-Amz-Content-Sha256", valid_606450
  var valid_606451 = header.getOrDefault("X-Amz-Date")
  valid_606451 = validateParameter(valid_606451, JString, required = false,
                                 default = nil)
  if valid_606451 != nil:
    section.add "X-Amz-Date", valid_606451
  var valid_606452 = header.getOrDefault("X-Amz-Credential")
  valid_606452 = validateParameter(valid_606452, JString, required = false,
                                 default = nil)
  if valid_606452 != nil:
    section.add "X-Amz-Credential", valid_606452
  var valid_606453 = header.getOrDefault("X-Amz-Security-Token")
  valid_606453 = validateParameter(valid_606453, JString, required = false,
                                 default = nil)
  if valid_606453 != nil:
    section.add "X-Amz-Security-Token", valid_606453
  var valid_606454 = header.getOrDefault("X-Amz-Algorithm")
  valid_606454 = validateParameter(valid_606454, JString, required = false,
                                 default = nil)
  if valid_606454 != nil:
    section.add "X-Amz-Algorithm", valid_606454
  var valid_606455 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606455 = validateParameter(valid_606455, JString, required = false,
                                 default = nil)
  if valid_606455 != nil:
    section.add "X-Amz-SignedHeaders", valid_606455
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606456: Call_DescribeDefaultAuthorizer_606446; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes the default authorizer.
  ## 
  let valid = call_606456.validator(path, query, header, formData, body)
  let scheme = call_606456.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606456.url(scheme.get, call_606456.host, call_606456.base,
                         call_606456.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606456, url, valid)

proc call*(call_606457: Call_DescribeDefaultAuthorizer_606446): Recallable =
  ## describeDefaultAuthorizer
  ## Describes the default authorizer.
  result = call_606457.call(nil, nil, nil, nil, nil)

var describeDefaultAuthorizer* = Call_DescribeDefaultAuthorizer_606446(
    name: "describeDefaultAuthorizer", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_DescribeDefaultAuthorizer_606447, base: "/",
    url: url_DescribeDefaultAuthorizer_606448,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ClearDefaultAuthorizer_606472 = ref object of OpenApiRestCall_605589
proc url_ClearDefaultAuthorizer_606474(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ClearDefaultAuthorizer_606473(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Clears the default authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606475 = header.getOrDefault("X-Amz-Signature")
  valid_606475 = validateParameter(valid_606475, JString, required = false,
                                 default = nil)
  if valid_606475 != nil:
    section.add "X-Amz-Signature", valid_606475
  var valid_606476 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606476 = validateParameter(valid_606476, JString, required = false,
                                 default = nil)
  if valid_606476 != nil:
    section.add "X-Amz-Content-Sha256", valid_606476
  var valid_606477 = header.getOrDefault("X-Amz-Date")
  valid_606477 = validateParameter(valid_606477, JString, required = false,
                                 default = nil)
  if valid_606477 != nil:
    section.add "X-Amz-Date", valid_606477
  var valid_606478 = header.getOrDefault("X-Amz-Credential")
  valid_606478 = validateParameter(valid_606478, JString, required = false,
                                 default = nil)
  if valid_606478 != nil:
    section.add "X-Amz-Credential", valid_606478
  var valid_606479 = header.getOrDefault("X-Amz-Security-Token")
  valid_606479 = validateParameter(valid_606479, JString, required = false,
                                 default = nil)
  if valid_606479 != nil:
    section.add "X-Amz-Security-Token", valid_606479
  var valid_606480 = header.getOrDefault("X-Amz-Algorithm")
  valid_606480 = validateParameter(valid_606480, JString, required = false,
                                 default = nil)
  if valid_606480 != nil:
    section.add "X-Amz-Algorithm", valid_606480
  var valid_606481 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606481 = validateParameter(valid_606481, JString, required = false,
                                 default = nil)
  if valid_606481 != nil:
    section.add "X-Amz-SignedHeaders", valid_606481
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606482: Call_ClearDefaultAuthorizer_606472; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Clears the default authorizer.
  ## 
  let valid = call_606482.validator(path, query, header, formData, body)
  let scheme = call_606482.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606482.url(scheme.get, call_606482.host, call_606482.base,
                         call_606482.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606482, url, valid)

proc call*(call_606483: Call_ClearDefaultAuthorizer_606472): Recallable =
  ## clearDefaultAuthorizer
  ## Clears the default authorizer.
  result = call_606483.call(nil, nil, nil, nil, nil)

var clearDefaultAuthorizer* = Call_ClearDefaultAuthorizer_606472(
    name: "clearDefaultAuthorizer", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/default-authorizer",
    validator: validate_ClearDefaultAuthorizer_606473, base: "/",
    url: url_ClearDefaultAuthorizer_606474, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ConfirmTopicRuleDestination_606484 = ref object of OpenApiRestCall_605589
proc url_ConfirmTopicRuleDestination_606486(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "confirmationToken" in path,
        "`confirmationToken` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/confirmdestination/"),
               (kind: VariableSegment, value: "confirmationToken")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ConfirmTopicRuleDestination_606485(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Confirms a topic rule destination. When you create a rule requiring a destination, AWS IoT sends a confirmation message to the endpoint or base address you specify. The message includes a token which you pass back when calling <code>ConfirmTopicRuleDestination</code> to confirm that you own or have access to the endpoint.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   confirmationToken: JString (required)
  ##                    : The token used to confirm ownership or access to the topic rule confirmation URL.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `confirmationToken` field"
  var valid_606487 = path.getOrDefault("confirmationToken")
  valid_606487 = validateParameter(valid_606487, JString, required = true,
                                 default = nil)
  if valid_606487 != nil:
    section.add "confirmationToken", valid_606487
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606488 = header.getOrDefault("X-Amz-Signature")
  valid_606488 = validateParameter(valid_606488, JString, required = false,
                                 default = nil)
  if valid_606488 != nil:
    section.add "X-Amz-Signature", valid_606488
  var valid_606489 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606489 = validateParameter(valid_606489, JString, required = false,
                                 default = nil)
  if valid_606489 != nil:
    section.add "X-Amz-Content-Sha256", valid_606489
  var valid_606490 = header.getOrDefault("X-Amz-Date")
  valid_606490 = validateParameter(valid_606490, JString, required = false,
                                 default = nil)
  if valid_606490 != nil:
    section.add "X-Amz-Date", valid_606490
  var valid_606491 = header.getOrDefault("X-Amz-Credential")
  valid_606491 = validateParameter(valid_606491, JString, required = false,
                                 default = nil)
  if valid_606491 != nil:
    section.add "X-Amz-Credential", valid_606491
  var valid_606492 = header.getOrDefault("X-Amz-Security-Token")
  valid_606492 = validateParameter(valid_606492, JString, required = false,
                                 default = nil)
  if valid_606492 != nil:
    section.add "X-Amz-Security-Token", valid_606492
  var valid_606493 = header.getOrDefault("X-Amz-Algorithm")
  valid_606493 = validateParameter(valid_606493, JString, required = false,
                                 default = nil)
  if valid_606493 != nil:
    section.add "X-Amz-Algorithm", valid_606493
  var valid_606494 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606494 = validateParameter(valid_606494, JString, required = false,
                                 default = nil)
  if valid_606494 != nil:
    section.add "X-Amz-SignedHeaders", valid_606494
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606495: Call_ConfirmTopicRuleDestination_606484; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Confirms a topic rule destination. When you create a rule requiring a destination, AWS IoT sends a confirmation message to the endpoint or base address you specify. The message includes a token which you pass back when calling <code>ConfirmTopicRuleDestination</code> to confirm that you own or have access to the endpoint.
  ## 
  let valid = call_606495.validator(path, query, header, formData, body)
  let scheme = call_606495.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606495.url(scheme.get, call_606495.host, call_606495.base,
                         call_606495.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606495, url, valid)

proc call*(call_606496: Call_ConfirmTopicRuleDestination_606484;
          confirmationToken: string): Recallable =
  ## confirmTopicRuleDestination
  ## Confirms a topic rule destination. When you create a rule requiring a destination, AWS IoT sends a confirmation message to the endpoint or base address you specify. The message includes a token which you pass back when calling <code>ConfirmTopicRuleDestination</code> to confirm that you own or have access to the endpoint.
  ##   confirmationToken: string (required)
  ##                    : The token used to confirm ownership or access to the topic rule confirmation URL.
  var path_606497 = newJObject()
  add(path_606497, "confirmationToken", newJString(confirmationToken))
  result = call_606496.call(path_606497, nil, nil, nil, nil)

var confirmTopicRuleDestination* = Call_ConfirmTopicRuleDestination_606484(
    name: "confirmTopicRuleDestination", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/confirmdestination/{confirmationToken}",
    validator: validate_ConfirmTopicRuleDestination_606485, base: "/",
    url: url_ConfirmTopicRuleDestination_606486,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateAuthorizer_606512 = ref object of OpenApiRestCall_605589
proc url_UpdateAuthorizer_606514(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateAuthorizer_606513(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Updates an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_606515 = path.getOrDefault("authorizerName")
  valid_606515 = validateParameter(valid_606515, JString, required = true,
                                 default = nil)
  if valid_606515 != nil:
    section.add "authorizerName", valid_606515
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606516 = header.getOrDefault("X-Amz-Signature")
  valid_606516 = validateParameter(valid_606516, JString, required = false,
                                 default = nil)
  if valid_606516 != nil:
    section.add "X-Amz-Signature", valid_606516
  var valid_606517 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606517 = validateParameter(valid_606517, JString, required = false,
                                 default = nil)
  if valid_606517 != nil:
    section.add "X-Amz-Content-Sha256", valid_606517
  var valid_606518 = header.getOrDefault("X-Amz-Date")
  valid_606518 = validateParameter(valid_606518, JString, required = false,
                                 default = nil)
  if valid_606518 != nil:
    section.add "X-Amz-Date", valid_606518
  var valid_606519 = header.getOrDefault("X-Amz-Credential")
  valid_606519 = validateParameter(valid_606519, JString, required = false,
                                 default = nil)
  if valid_606519 != nil:
    section.add "X-Amz-Credential", valid_606519
  var valid_606520 = header.getOrDefault("X-Amz-Security-Token")
  valid_606520 = validateParameter(valid_606520, JString, required = false,
                                 default = nil)
  if valid_606520 != nil:
    section.add "X-Amz-Security-Token", valid_606520
  var valid_606521 = header.getOrDefault("X-Amz-Algorithm")
  valid_606521 = validateParameter(valid_606521, JString, required = false,
                                 default = nil)
  if valid_606521 != nil:
    section.add "X-Amz-Algorithm", valid_606521
  var valid_606522 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606522 = validateParameter(valid_606522, JString, required = false,
                                 default = nil)
  if valid_606522 != nil:
    section.add "X-Amz-SignedHeaders", valid_606522
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606524: Call_UpdateAuthorizer_606512; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an authorizer.
  ## 
  let valid = call_606524.validator(path, query, header, formData, body)
  let scheme = call_606524.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606524.url(scheme.get, call_606524.host, call_606524.base,
                         call_606524.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606524, url, valid)

proc call*(call_606525: Call_UpdateAuthorizer_606512; authorizerName: string;
          body: JsonNode): Recallable =
  ## updateAuthorizer
  ## Updates an authorizer.
  ##   authorizerName: string (required)
  ##                 : The authorizer name.
  ##   body: JObject (required)
  var path_606526 = newJObject()
  var body_606527 = newJObject()
  add(path_606526, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_606527 = body
  result = call_606525.call(path_606526, nil, nil, nil, body_606527)

var updateAuthorizer* = Call_UpdateAuthorizer_606512(name: "updateAuthorizer",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_UpdateAuthorizer_606513,
    base: "/", url: url_UpdateAuthorizer_606514,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateAuthorizer_606528 = ref object of OpenApiRestCall_605589
proc url_CreateAuthorizer_606530(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateAuthorizer_606529(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Creates an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_606531 = path.getOrDefault("authorizerName")
  valid_606531 = validateParameter(valid_606531, JString, required = true,
                                 default = nil)
  if valid_606531 != nil:
    section.add "authorizerName", valid_606531
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606532 = header.getOrDefault("X-Amz-Signature")
  valid_606532 = validateParameter(valid_606532, JString, required = false,
                                 default = nil)
  if valid_606532 != nil:
    section.add "X-Amz-Signature", valid_606532
  var valid_606533 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606533 = validateParameter(valid_606533, JString, required = false,
                                 default = nil)
  if valid_606533 != nil:
    section.add "X-Amz-Content-Sha256", valid_606533
  var valid_606534 = header.getOrDefault("X-Amz-Date")
  valid_606534 = validateParameter(valid_606534, JString, required = false,
                                 default = nil)
  if valid_606534 != nil:
    section.add "X-Amz-Date", valid_606534
  var valid_606535 = header.getOrDefault("X-Amz-Credential")
  valid_606535 = validateParameter(valid_606535, JString, required = false,
                                 default = nil)
  if valid_606535 != nil:
    section.add "X-Amz-Credential", valid_606535
  var valid_606536 = header.getOrDefault("X-Amz-Security-Token")
  valid_606536 = validateParameter(valid_606536, JString, required = false,
                                 default = nil)
  if valid_606536 != nil:
    section.add "X-Amz-Security-Token", valid_606536
  var valid_606537 = header.getOrDefault("X-Amz-Algorithm")
  valid_606537 = validateParameter(valid_606537, JString, required = false,
                                 default = nil)
  if valid_606537 != nil:
    section.add "X-Amz-Algorithm", valid_606537
  var valid_606538 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606538 = validateParameter(valid_606538, JString, required = false,
                                 default = nil)
  if valid_606538 != nil:
    section.add "X-Amz-SignedHeaders", valid_606538
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606540: Call_CreateAuthorizer_606528; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates an authorizer.
  ## 
  let valid = call_606540.validator(path, query, header, formData, body)
  let scheme = call_606540.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606540.url(scheme.get, call_606540.host, call_606540.base,
                         call_606540.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606540, url, valid)

proc call*(call_606541: Call_CreateAuthorizer_606528; authorizerName: string;
          body: JsonNode): Recallable =
  ## createAuthorizer
  ## Creates an authorizer.
  ##   authorizerName: string (required)
  ##                 : The authorizer name.
  ##   body: JObject (required)
  var path_606542 = newJObject()
  var body_606543 = newJObject()
  add(path_606542, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_606543 = body
  result = call_606541.call(path_606542, nil, nil, nil, body_606543)

var createAuthorizer* = Call_CreateAuthorizer_606528(name: "createAuthorizer",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_CreateAuthorizer_606529,
    base: "/", url: url_CreateAuthorizer_606530,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuthorizer_606498 = ref object of OpenApiRestCall_605589
proc url_DescribeAuthorizer_606500(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuthorizer_606499(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Describes an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The name of the authorizer to describe.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_606501 = path.getOrDefault("authorizerName")
  valid_606501 = validateParameter(valid_606501, JString, required = true,
                                 default = nil)
  if valid_606501 != nil:
    section.add "authorizerName", valid_606501
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606502 = header.getOrDefault("X-Amz-Signature")
  valid_606502 = validateParameter(valid_606502, JString, required = false,
                                 default = nil)
  if valid_606502 != nil:
    section.add "X-Amz-Signature", valid_606502
  var valid_606503 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606503 = validateParameter(valid_606503, JString, required = false,
                                 default = nil)
  if valid_606503 != nil:
    section.add "X-Amz-Content-Sha256", valid_606503
  var valid_606504 = header.getOrDefault("X-Amz-Date")
  valid_606504 = validateParameter(valid_606504, JString, required = false,
                                 default = nil)
  if valid_606504 != nil:
    section.add "X-Amz-Date", valid_606504
  var valid_606505 = header.getOrDefault("X-Amz-Credential")
  valid_606505 = validateParameter(valid_606505, JString, required = false,
                                 default = nil)
  if valid_606505 != nil:
    section.add "X-Amz-Credential", valid_606505
  var valid_606506 = header.getOrDefault("X-Amz-Security-Token")
  valid_606506 = validateParameter(valid_606506, JString, required = false,
                                 default = nil)
  if valid_606506 != nil:
    section.add "X-Amz-Security-Token", valid_606506
  var valid_606507 = header.getOrDefault("X-Amz-Algorithm")
  valid_606507 = validateParameter(valid_606507, JString, required = false,
                                 default = nil)
  if valid_606507 != nil:
    section.add "X-Amz-Algorithm", valid_606507
  var valid_606508 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606508 = validateParameter(valid_606508, JString, required = false,
                                 default = nil)
  if valid_606508 != nil:
    section.add "X-Amz-SignedHeaders", valid_606508
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606509: Call_DescribeAuthorizer_606498; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes an authorizer.
  ## 
  let valid = call_606509.validator(path, query, header, formData, body)
  let scheme = call_606509.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606509.url(scheme.get, call_606509.host, call_606509.base,
                         call_606509.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606509, url, valid)

proc call*(call_606510: Call_DescribeAuthorizer_606498; authorizerName: string): Recallable =
  ## describeAuthorizer
  ## Describes an authorizer.
  ##   authorizerName: string (required)
  ##                 : The name of the authorizer to describe.
  var path_606511 = newJObject()
  add(path_606511, "authorizerName", newJString(authorizerName))
  result = call_606510.call(path_606511, nil, nil, nil, nil)

var describeAuthorizer* = Call_DescribeAuthorizer_606498(
    name: "describeAuthorizer", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_DescribeAuthorizer_606499,
    base: "/", url: url_DescribeAuthorizer_606500,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteAuthorizer_606544 = ref object of OpenApiRestCall_605589
proc url_DeleteAuthorizer_606546(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteAuthorizer_606545(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Deletes an authorizer.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The name of the authorizer to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_606547 = path.getOrDefault("authorizerName")
  valid_606547 = validateParameter(valid_606547, JString, required = true,
                                 default = nil)
  if valid_606547 != nil:
    section.add "authorizerName", valid_606547
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606548 = header.getOrDefault("X-Amz-Signature")
  valid_606548 = validateParameter(valid_606548, JString, required = false,
                                 default = nil)
  if valid_606548 != nil:
    section.add "X-Amz-Signature", valid_606548
  var valid_606549 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606549 = validateParameter(valid_606549, JString, required = false,
                                 default = nil)
  if valid_606549 != nil:
    section.add "X-Amz-Content-Sha256", valid_606549
  var valid_606550 = header.getOrDefault("X-Amz-Date")
  valid_606550 = validateParameter(valid_606550, JString, required = false,
                                 default = nil)
  if valid_606550 != nil:
    section.add "X-Amz-Date", valid_606550
  var valid_606551 = header.getOrDefault("X-Amz-Credential")
  valid_606551 = validateParameter(valid_606551, JString, required = false,
                                 default = nil)
  if valid_606551 != nil:
    section.add "X-Amz-Credential", valid_606551
  var valid_606552 = header.getOrDefault("X-Amz-Security-Token")
  valid_606552 = validateParameter(valid_606552, JString, required = false,
                                 default = nil)
  if valid_606552 != nil:
    section.add "X-Amz-Security-Token", valid_606552
  var valid_606553 = header.getOrDefault("X-Amz-Algorithm")
  valid_606553 = validateParameter(valid_606553, JString, required = false,
                                 default = nil)
  if valid_606553 != nil:
    section.add "X-Amz-Algorithm", valid_606553
  var valid_606554 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606554 = validateParameter(valid_606554, JString, required = false,
                                 default = nil)
  if valid_606554 != nil:
    section.add "X-Amz-SignedHeaders", valid_606554
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606555: Call_DeleteAuthorizer_606544; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an authorizer.
  ## 
  let valid = call_606555.validator(path, query, header, formData, body)
  let scheme = call_606555.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606555.url(scheme.get, call_606555.host, call_606555.base,
                         call_606555.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606555, url, valid)

proc call*(call_606556: Call_DeleteAuthorizer_606544; authorizerName: string): Recallable =
  ## deleteAuthorizer
  ## Deletes an authorizer.
  ##   authorizerName: string (required)
  ##                 : The name of the authorizer to delete.
  var path_606557 = newJObject()
  add(path_606557, "authorizerName", newJString(authorizerName))
  result = call_606556.call(path_606557, nil, nil, nil, nil)

var deleteAuthorizer* = Call_DeleteAuthorizer_606544(name: "deleteAuthorizer",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/authorizer/{authorizerName}", validator: validate_DeleteAuthorizer_606545,
    base: "/", url: url_DeleteAuthorizer_606546,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateBillingGroup_606572 = ref object of OpenApiRestCall_605589
proc url_CreateBillingGroup_606574(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateBillingGroup_606573(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Creates a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name you wish to give to the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_606575 = path.getOrDefault("billingGroupName")
  valid_606575 = validateParameter(valid_606575, JString, required = true,
                                 default = nil)
  if valid_606575 != nil:
    section.add "billingGroupName", valid_606575
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606576 = header.getOrDefault("X-Amz-Signature")
  valid_606576 = validateParameter(valid_606576, JString, required = false,
                                 default = nil)
  if valid_606576 != nil:
    section.add "X-Amz-Signature", valid_606576
  var valid_606577 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606577 = validateParameter(valid_606577, JString, required = false,
                                 default = nil)
  if valid_606577 != nil:
    section.add "X-Amz-Content-Sha256", valid_606577
  var valid_606578 = header.getOrDefault("X-Amz-Date")
  valid_606578 = validateParameter(valid_606578, JString, required = false,
                                 default = nil)
  if valid_606578 != nil:
    section.add "X-Amz-Date", valid_606578
  var valid_606579 = header.getOrDefault("X-Amz-Credential")
  valid_606579 = validateParameter(valid_606579, JString, required = false,
                                 default = nil)
  if valid_606579 != nil:
    section.add "X-Amz-Credential", valid_606579
  var valid_606580 = header.getOrDefault("X-Amz-Security-Token")
  valid_606580 = validateParameter(valid_606580, JString, required = false,
                                 default = nil)
  if valid_606580 != nil:
    section.add "X-Amz-Security-Token", valid_606580
  var valid_606581 = header.getOrDefault("X-Amz-Algorithm")
  valid_606581 = validateParameter(valid_606581, JString, required = false,
                                 default = nil)
  if valid_606581 != nil:
    section.add "X-Amz-Algorithm", valid_606581
  var valid_606582 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606582 = validateParameter(valid_606582, JString, required = false,
                                 default = nil)
  if valid_606582 != nil:
    section.add "X-Amz-SignedHeaders", valid_606582
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606584: Call_CreateBillingGroup_606572; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a billing group.
  ## 
  let valid = call_606584.validator(path, query, header, formData, body)
  let scheme = call_606584.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606584.url(scheme.get, call_606584.host, call_606584.base,
                         call_606584.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606584, url, valid)

proc call*(call_606585: Call_CreateBillingGroup_606572; body: JsonNode;
          billingGroupName: string): Recallable =
  ## createBillingGroup
  ## Creates a billing group.
  ##   body: JObject (required)
  ##   billingGroupName: string (required)
  ##                   : The name you wish to give to the billing group.
  var path_606586 = newJObject()
  var body_606587 = newJObject()
  if body != nil:
    body_606587 = body
  add(path_606586, "billingGroupName", newJString(billingGroupName))
  result = call_606585.call(path_606586, nil, nil, nil, body_606587)

var createBillingGroup* = Call_CreateBillingGroup_606572(
    name: "createBillingGroup", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_CreateBillingGroup_606573, base: "/",
    url: url_CreateBillingGroup_606574, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeBillingGroup_606558 = ref object of OpenApiRestCall_605589
proc url_DescribeBillingGroup_606560(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeBillingGroup_606559(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about a billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_606561 = path.getOrDefault("billingGroupName")
  valid_606561 = validateParameter(valid_606561, JString, required = true,
                                 default = nil)
  if valid_606561 != nil:
    section.add "billingGroupName", valid_606561
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606562 = header.getOrDefault("X-Amz-Signature")
  valid_606562 = validateParameter(valid_606562, JString, required = false,
                                 default = nil)
  if valid_606562 != nil:
    section.add "X-Amz-Signature", valid_606562
  var valid_606563 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606563 = validateParameter(valid_606563, JString, required = false,
                                 default = nil)
  if valid_606563 != nil:
    section.add "X-Amz-Content-Sha256", valid_606563
  var valid_606564 = header.getOrDefault("X-Amz-Date")
  valid_606564 = validateParameter(valid_606564, JString, required = false,
                                 default = nil)
  if valid_606564 != nil:
    section.add "X-Amz-Date", valid_606564
  var valid_606565 = header.getOrDefault("X-Amz-Credential")
  valid_606565 = validateParameter(valid_606565, JString, required = false,
                                 default = nil)
  if valid_606565 != nil:
    section.add "X-Amz-Credential", valid_606565
  var valid_606566 = header.getOrDefault("X-Amz-Security-Token")
  valid_606566 = validateParameter(valid_606566, JString, required = false,
                                 default = nil)
  if valid_606566 != nil:
    section.add "X-Amz-Security-Token", valid_606566
  var valid_606567 = header.getOrDefault("X-Amz-Algorithm")
  valid_606567 = validateParameter(valid_606567, JString, required = false,
                                 default = nil)
  if valid_606567 != nil:
    section.add "X-Amz-Algorithm", valid_606567
  var valid_606568 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606568 = validateParameter(valid_606568, JString, required = false,
                                 default = nil)
  if valid_606568 != nil:
    section.add "X-Amz-SignedHeaders", valid_606568
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606569: Call_DescribeBillingGroup_606558; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about a billing group.
  ## 
  let valid = call_606569.validator(path, query, header, formData, body)
  let scheme = call_606569.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606569.url(scheme.get, call_606569.host, call_606569.base,
                         call_606569.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606569, url, valid)

proc call*(call_606570: Call_DescribeBillingGroup_606558; billingGroupName: string): Recallable =
  ## describeBillingGroup
  ## Returns information about a billing group.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_606571 = newJObject()
  add(path_606571, "billingGroupName", newJString(billingGroupName))
  result = call_606570.call(path_606571, nil, nil, nil, nil)

var describeBillingGroup* = Call_DescribeBillingGroup_606558(
    name: "describeBillingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_DescribeBillingGroup_606559, base: "/",
    url: url_DescribeBillingGroup_606560, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateBillingGroup_606604 = ref object of OpenApiRestCall_605589
proc url_UpdateBillingGroup_606606(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateBillingGroup_606605(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Updates information about the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_606607 = path.getOrDefault("billingGroupName")
  valid_606607 = validateParameter(valid_606607, JString, required = true,
                                 default = nil)
  if valid_606607 != nil:
    section.add "billingGroupName", valid_606607
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606608 = header.getOrDefault("X-Amz-Signature")
  valid_606608 = validateParameter(valid_606608, JString, required = false,
                                 default = nil)
  if valid_606608 != nil:
    section.add "X-Amz-Signature", valid_606608
  var valid_606609 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606609 = validateParameter(valid_606609, JString, required = false,
                                 default = nil)
  if valid_606609 != nil:
    section.add "X-Amz-Content-Sha256", valid_606609
  var valid_606610 = header.getOrDefault("X-Amz-Date")
  valid_606610 = validateParameter(valid_606610, JString, required = false,
                                 default = nil)
  if valid_606610 != nil:
    section.add "X-Amz-Date", valid_606610
  var valid_606611 = header.getOrDefault("X-Amz-Credential")
  valid_606611 = validateParameter(valid_606611, JString, required = false,
                                 default = nil)
  if valid_606611 != nil:
    section.add "X-Amz-Credential", valid_606611
  var valid_606612 = header.getOrDefault("X-Amz-Security-Token")
  valid_606612 = validateParameter(valid_606612, JString, required = false,
                                 default = nil)
  if valid_606612 != nil:
    section.add "X-Amz-Security-Token", valid_606612
  var valid_606613 = header.getOrDefault("X-Amz-Algorithm")
  valid_606613 = validateParameter(valid_606613, JString, required = false,
                                 default = nil)
  if valid_606613 != nil:
    section.add "X-Amz-Algorithm", valid_606613
  var valid_606614 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606614 = validateParameter(valid_606614, JString, required = false,
                                 default = nil)
  if valid_606614 != nil:
    section.add "X-Amz-SignedHeaders", valid_606614
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606616: Call_UpdateBillingGroup_606604; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates information about the billing group.
  ## 
  let valid = call_606616.validator(path, query, header, formData, body)
  let scheme = call_606616.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606616.url(scheme.get, call_606616.host, call_606616.base,
                         call_606616.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606616, url, valid)

proc call*(call_606617: Call_UpdateBillingGroup_606604; body: JsonNode;
          billingGroupName: string): Recallable =
  ## updateBillingGroup
  ## Updates information about the billing group.
  ##   body: JObject (required)
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_606618 = newJObject()
  var body_606619 = newJObject()
  if body != nil:
    body_606619 = body
  add(path_606618, "billingGroupName", newJString(billingGroupName))
  result = call_606617.call(path_606618, nil, nil, nil, body_606619)

var updateBillingGroup* = Call_UpdateBillingGroup_606604(
    name: "updateBillingGroup", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_UpdateBillingGroup_606605, base: "/",
    url: url_UpdateBillingGroup_606606, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteBillingGroup_606588 = ref object of OpenApiRestCall_605589
proc url_DeleteBillingGroup_606590(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteBillingGroup_606589(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deletes the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_606591 = path.getOrDefault("billingGroupName")
  valid_606591 = validateParameter(valid_606591, JString, required = true,
                                 default = nil)
  if valid_606591 != nil:
    section.add "billingGroupName", valid_606591
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.
  section = newJObject()
  var valid_606592 = query.getOrDefault("expectedVersion")
  valid_606592 = validateParameter(valid_606592, JInt, required = false, default = nil)
  if valid_606592 != nil:
    section.add "expectedVersion", valid_606592
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606593 = header.getOrDefault("X-Amz-Signature")
  valid_606593 = validateParameter(valid_606593, JString, required = false,
                                 default = nil)
  if valid_606593 != nil:
    section.add "X-Amz-Signature", valid_606593
  var valid_606594 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606594 = validateParameter(valid_606594, JString, required = false,
                                 default = nil)
  if valid_606594 != nil:
    section.add "X-Amz-Content-Sha256", valid_606594
  var valid_606595 = header.getOrDefault("X-Amz-Date")
  valid_606595 = validateParameter(valid_606595, JString, required = false,
                                 default = nil)
  if valid_606595 != nil:
    section.add "X-Amz-Date", valid_606595
  var valid_606596 = header.getOrDefault("X-Amz-Credential")
  valid_606596 = validateParameter(valid_606596, JString, required = false,
                                 default = nil)
  if valid_606596 != nil:
    section.add "X-Amz-Credential", valid_606596
  var valid_606597 = header.getOrDefault("X-Amz-Security-Token")
  valid_606597 = validateParameter(valid_606597, JString, required = false,
                                 default = nil)
  if valid_606597 != nil:
    section.add "X-Amz-Security-Token", valid_606597
  var valid_606598 = header.getOrDefault("X-Amz-Algorithm")
  valid_606598 = validateParameter(valid_606598, JString, required = false,
                                 default = nil)
  if valid_606598 != nil:
    section.add "X-Amz-Algorithm", valid_606598
  var valid_606599 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606599 = validateParameter(valid_606599, JString, required = false,
                                 default = nil)
  if valid_606599 != nil:
    section.add "X-Amz-SignedHeaders", valid_606599
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606600: Call_DeleteBillingGroup_606588; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the billing group.
  ## 
  let valid = call_606600.validator(path, query, header, formData, body)
  let scheme = call_606600.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606600.url(scheme.get, call_606600.host, call_606600.base,
                         call_606600.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606600, url, valid)

proc call*(call_606601: Call_DeleteBillingGroup_606588; billingGroupName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteBillingGroup
  ## Deletes the billing group.
  ##   expectedVersion: int
  ##                  : The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  var path_606602 = newJObject()
  var query_606603 = newJObject()
  add(query_606603, "expectedVersion", newJInt(expectedVersion))
  add(path_606602, "billingGroupName", newJString(billingGroupName))
  result = call_606601.call(path_606602, query_606603, nil, nil, nil)

var deleteBillingGroup* = Call_DeleteBillingGroup_606588(
    name: "deleteBillingGroup", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}",
    validator: validate_DeleteBillingGroup_606589, base: "/",
    url: url_DeleteBillingGroup_606590, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateCertificateFromCsr_606636 = ref object of OpenApiRestCall_605589
proc url_CreateCertificateFromCsr_606638(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateCertificateFromCsr_606637(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_606639 = query.getOrDefault("setAsActive")
  valid_606639 = validateParameter(valid_606639, JBool, required = false, default = nil)
  if valid_606639 != nil:
    section.add "setAsActive", valid_606639
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606640 = header.getOrDefault("X-Amz-Signature")
  valid_606640 = validateParameter(valid_606640, JString, required = false,
                                 default = nil)
  if valid_606640 != nil:
    section.add "X-Amz-Signature", valid_606640
  var valid_606641 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606641 = validateParameter(valid_606641, JString, required = false,
                                 default = nil)
  if valid_606641 != nil:
    section.add "X-Amz-Content-Sha256", valid_606641
  var valid_606642 = header.getOrDefault("X-Amz-Date")
  valid_606642 = validateParameter(valid_606642, JString, required = false,
                                 default = nil)
  if valid_606642 != nil:
    section.add "X-Amz-Date", valid_606642
  var valid_606643 = header.getOrDefault("X-Amz-Credential")
  valid_606643 = validateParameter(valid_606643, JString, required = false,
                                 default = nil)
  if valid_606643 != nil:
    section.add "X-Amz-Credential", valid_606643
  var valid_606644 = header.getOrDefault("X-Amz-Security-Token")
  valid_606644 = validateParameter(valid_606644, JString, required = false,
                                 default = nil)
  if valid_606644 != nil:
    section.add "X-Amz-Security-Token", valid_606644
  var valid_606645 = header.getOrDefault("X-Amz-Algorithm")
  valid_606645 = validateParameter(valid_606645, JString, required = false,
                                 default = nil)
  if valid_606645 != nil:
    section.add "X-Amz-Algorithm", valid_606645
  var valid_606646 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606646 = validateParameter(valid_606646, JString, required = false,
                                 default = nil)
  if valid_606646 != nil:
    section.add "X-Amz-SignedHeaders", valid_606646
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606648: Call_CreateCertificateFromCsr_606636; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ## 
  let valid = call_606648.validator(path, query, header, formData, body)
  let scheme = call_606648.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606648.url(scheme.get, call_606648.host, call_606648.base,
                         call_606648.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606648, url, valid)

proc call*(call_606649: Call_CreateCertificateFromCsr_606636; body: JsonNode;
          setAsActive: bool = false): Recallable =
  ## createCertificateFromCsr
  ## <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  ##   body: JObject (required)
  var query_606650 = newJObject()
  var body_606651 = newJObject()
  add(query_606650, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_606651 = body
  result = call_606649.call(nil, query_606650, nil, nil, body_606651)

var createCertificateFromCsr* = Call_CreateCertificateFromCsr_606636(
    name: "createCertificateFromCsr", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/certificates",
    validator: validate_CreateCertificateFromCsr_606637, base: "/",
    url: url_CreateCertificateFromCsr_606638, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCertificates_606620 = ref object of OpenApiRestCall_605589
proc url_ListCertificates_606622(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListCertificates_606621(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_606623 = query.getOrDefault("isAscendingOrder")
  valid_606623 = validateParameter(valid_606623, JBool, required = false, default = nil)
  if valid_606623 != nil:
    section.add "isAscendingOrder", valid_606623
  var valid_606624 = query.getOrDefault("pageSize")
  valid_606624 = validateParameter(valid_606624, JInt, required = false, default = nil)
  if valid_606624 != nil:
    section.add "pageSize", valid_606624
  var valid_606625 = query.getOrDefault("marker")
  valid_606625 = validateParameter(valid_606625, JString, required = false,
                                 default = nil)
  if valid_606625 != nil:
    section.add "marker", valid_606625
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606626 = header.getOrDefault("X-Amz-Signature")
  valid_606626 = validateParameter(valid_606626, JString, required = false,
                                 default = nil)
  if valid_606626 != nil:
    section.add "X-Amz-Signature", valid_606626
  var valid_606627 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606627 = validateParameter(valid_606627, JString, required = false,
                                 default = nil)
  if valid_606627 != nil:
    section.add "X-Amz-Content-Sha256", valid_606627
  var valid_606628 = header.getOrDefault("X-Amz-Date")
  valid_606628 = validateParameter(valid_606628, JString, required = false,
                                 default = nil)
  if valid_606628 != nil:
    section.add "X-Amz-Date", valid_606628
  var valid_606629 = header.getOrDefault("X-Amz-Credential")
  valid_606629 = validateParameter(valid_606629, JString, required = false,
                                 default = nil)
  if valid_606629 != nil:
    section.add "X-Amz-Credential", valid_606629
  var valid_606630 = header.getOrDefault("X-Amz-Security-Token")
  valid_606630 = validateParameter(valid_606630, JString, required = false,
                                 default = nil)
  if valid_606630 != nil:
    section.add "X-Amz-Security-Token", valid_606630
  var valid_606631 = header.getOrDefault("X-Amz-Algorithm")
  valid_606631 = validateParameter(valid_606631, JString, required = false,
                                 default = nil)
  if valid_606631 != nil:
    section.add "X-Amz-Algorithm", valid_606631
  var valid_606632 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606632 = validateParameter(valid_606632, JString, required = false,
                                 default = nil)
  if valid_606632 != nil:
    section.add "X-Amz-SignedHeaders", valid_606632
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606633: Call_ListCertificates_606620; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  let valid = call_606633.validator(path, query, header, formData, body)
  let scheme = call_606633.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606633.url(scheme.get, call_606633.host, call_606633.base,
                         call_606633.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606633, url, valid)

proc call*(call_606634: Call_ListCertificates_606620;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listCertificates
  ## <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_606635 = newJObject()
  add(query_606635, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_606635, "pageSize", newJInt(pageSize))
  add(query_606635, "marker", newJString(marker))
  result = call_606634.call(nil, query_606635, nil, nil, nil)

var listCertificates* = Call_ListCertificates_606620(name: "listCertificates",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/certificates",
    validator: validate_ListCertificates_606621, base: "/",
    url: url_ListCertificates_606622, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateDomainConfiguration_606666 = ref object of OpenApiRestCall_605589
proc url_UpdateDomainConfiguration_606668(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "domainConfigurationName" in path,
        "`domainConfigurationName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/domainConfigurations/"),
               (kind: VariableSegment, value: "domainConfigurationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateDomainConfiguration_606667(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Updates values stored in the domain configuration. Domain configurations for default endpoints can't be updated.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   domainConfigurationName: JString (required)
  ##                          : The name of the domain configuration to be updated.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `domainConfigurationName` field"
  var valid_606669 = path.getOrDefault("domainConfigurationName")
  valid_606669 = validateParameter(valid_606669, JString, required = true,
                                 default = nil)
  if valid_606669 != nil:
    section.add "domainConfigurationName", valid_606669
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606670 = header.getOrDefault("X-Amz-Signature")
  valid_606670 = validateParameter(valid_606670, JString, required = false,
                                 default = nil)
  if valid_606670 != nil:
    section.add "X-Amz-Signature", valid_606670
  var valid_606671 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606671 = validateParameter(valid_606671, JString, required = false,
                                 default = nil)
  if valid_606671 != nil:
    section.add "X-Amz-Content-Sha256", valid_606671
  var valid_606672 = header.getOrDefault("X-Amz-Date")
  valid_606672 = validateParameter(valid_606672, JString, required = false,
                                 default = nil)
  if valid_606672 != nil:
    section.add "X-Amz-Date", valid_606672
  var valid_606673 = header.getOrDefault("X-Amz-Credential")
  valid_606673 = validateParameter(valid_606673, JString, required = false,
                                 default = nil)
  if valid_606673 != nil:
    section.add "X-Amz-Credential", valid_606673
  var valid_606674 = header.getOrDefault("X-Amz-Security-Token")
  valid_606674 = validateParameter(valid_606674, JString, required = false,
                                 default = nil)
  if valid_606674 != nil:
    section.add "X-Amz-Security-Token", valid_606674
  var valid_606675 = header.getOrDefault("X-Amz-Algorithm")
  valid_606675 = validateParameter(valid_606675, JString, required = false,
                                 default = nil)
  if valid_606675 != nil:
    section.add "X-Amz-Algorithm", valid_606675
  var valid_606676 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606676 = validateParameter(valid_606676, JString, required = false,
                                 default = nil)
  if valid_606676 != nil:
    section.add "X-Amz-SignedHeaders", valid_606676
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606678: Call_UpdateDomainConfiguration_606666; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Updates values stored in the domain configuration. Domain configurations for default endpoints can't be updated.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_606678.validator(path, query, header, formData, body)
  let scheme = call_606678.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606678.url(scheme.get, call_606678.host, call_606678.base,
                         call_606678.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606678, url, valid)

proc call*(call_606679: Call_UpdateDomainConfiguration_606666; body: JsonNode;
          domainConfigurationName: string): Recallable =
  ## updateDomainConfiguration
  ## <p>Updates values stored in the domain configuration. Domain configurations for default endpoints can't be updated.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   body: JObject (required)
  ##   domainConfigurationName: string (required)
  ##                          : The name of the domain configuration to be updated.
  var path_606680 = newJObject()
  var body_606681 = newJObject()
  if body != nil:
    body_606681 = body
  add(path_606680, "domainConfigurationName", newJString(domainConfigurationName))
  result = call_606679.call(path_606680, nil, nil, nil, body_606681)

var updateDomainConfiguration* = Call_UpdateDomainConfiguration_606666(
    name: "updateDomainConfiguration", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/domainConfigurations/{domainConfigurationName}",
    validator: validate_UpdateDomainConfiguration_606667, base: "/",
    url: url_UpdateDomainConfiguration_606668,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateDomainConfiguration_606682 = ref object of OpenApiRestCall_605589
proc url_CreateDomainConfiguration_606684(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "domainConfigurationName" in path,
        "`domainConfigurationName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/domainConfigurations/"),
               (kind: VariableSegment, value: "domainConfigurationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateDomainConfiguration_606683(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   domainConfigurationName: JString (required)
  ##                          : The name of the domain configuration. This value must be unique to a region.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `domainConfigurationName` field"
  var valid_606685 = path.getOrDefault("domainConfigurationName")
  valid_606685 = validateParameter(valid_606685, JString, required = true,
                                 default = nil)
  if valid_606685 != nil:
    section.add "domainConfigurationName", valid_606685
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606686 = header.getOrDefault("X-Amz-Signature")
  valid_606686 = validateParameter(valid_606686, JString, required = false,
                                 default = nil)
  if valid_606686 != nil:
    section.add "X-Amz-Signature", valid_606686
  var valid_606687 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606687 = validateParameter(valid_606687, JString, required = false,
                                 default = nil)
  if valid_606687 != nil:
    section.add "X-Amz-Content-Sha256", valid_606687
  var valid_606688 = header.getOrDefault("X-Amz-Date")
  valid_606688 = validateParameter(valid_606688, JString, required = false,
                                 default = nil)
  if valid_606688 != nil:
    section.add "X-Amz-Date", valid_606688
  var valid_606689 = header.getOrDefault("X-Amz-Credential")
  valid_606689 = validateParameter(valid_606689, JString, required = false,
                                 default = nil)
  if valid_606689 != nil:
    section.add "X-Amz-Credential", valid_606689
  var valid_606690 = header.getOrDefault("X-Amz-Security-Token")
  valid_606690 = validateParameter(valid_606690, JString, required = false,
                                 default = nil)
  if valid_606690 != nil:
    section.add "X-Amz-Security-Token", valid_606690
  var valid_606691 = header.getOrDefault("X-Amz-Algorithm")
  valid_606691 = validateParameter(valid_606691, JString, required = false,
                                 default = nil)
  if valid_606691 != nil:
    section.add "X-Amz-Algorithm", valid_606691
  var valid_606692 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606692 = validateParameter(valid_606692, JString, required = false,
                                 default = nil)
  if valid_606692 != nil:
    section.add "X-Amz-SignedHeaders", valid_606692
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606694: Call_CreateDomainConfiguration_606682; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_606694.validator(path, query, header, formData, body)
  let scheme = call_606694.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606694.url(scheme.get, call_606694.host, call_606694.base,
                         call_606694.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606694, url, valid)

proc call*(call_606695: Call_CreateDomainConfiguration_606682; body: JsonNode;
          domainConfigurationName: string): Recallable =
  ## createDomainConfiguration
  ## <p>Creates a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   body: JObject (required)
  ##   domainConfigurationName: string (required)
  ##                          : The name of the domain configuration. This value must be unique to a region.
  var path_606696 = newJObject()
  var body_606697 = newJObject()
  if body != nil:
    body_606697 = body
  add(path_606696, "domainConfigurationName", newJString(domainConfigurationName))
  result = call_606695.call(path_606696, nil, nil, nil, body_606697)

var createDomainConfiguration* = Call_CreateDomainConfiguration_606682(
    name: "createDomainConfiguration", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/domainConfigurations/{domainConfigurationName}",
    validator: validate_CreateDomainConfiguration_606683, base: "/",
    url: url_CreateDomainConfiguration_606684,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeDomainConfiguration_606652 = ref object of OpenApiRestCall_605589
proc url_DescribeDomainConfiguration_606654(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "domainConfigurationName" in path,
        "`domainConfigurationName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/domainConfigurations/"),
               (kind: VariableSegment, value: "domainConfigurationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeDomainConfiguration_606653(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Gets summary information about a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   domainConfigurationName: JString (required)
  ##                          : The name of the domain configuration.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `domainConfigurationName` field"
  var valid_606655 = path.getOrDefault("domainConfigurationName")
  valid_606655 = validateParameter(valid_606655, JString, required = true,
                                 default = nil)
  if valid_606655 != nil:
    section.add "domainConfigurationName", valid_606655
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606656 = header.getOrDefault("X-Amz-Signature")
  valid_606656 = validateParameter(valid_606656, JString, required = false,
                                 default = nil)
  if valid_606656 != nil:
    section.add "X-Amz-Signature", valid_606656
  var valid_606657 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606657 = validateParameter(valid_606657, JString, required = false,
                                 default = nil)
  if valid_606657 != nil:
    section.add "X-Amz-Content-Sha256", valid_606657
  var valid_606658 = header.getOrDefault("X-Amz-Date")
  valid_606658 = validateParameter(valid_606658, JString, required = false,
                                 default = nil)
  if valid_606658 != nil:
    section.add "X-Amz-Date", valid_606658
  var valid_606659 = header.getOrDefault("X-Amz-Credential")
  valid_606659 = validateParameter(valid_606659, JString, required = false,
                                 default = nil)
  if valid_606659 != nil:
    section.add "X-Amz-Credential", valid_606659
  var valid_606660 = header.getOrDefault("X-Amz-Security-Token")
  valid_606660 = validateParameter(valid_606660, JString, required = false,
                                 default = nil)
  if valid_606660 != nil:
    section.add "X-Amz-Security-Token", valid_606660
  var valid_606661 = header.getOrDefault("X-Amz-Algorithm")
  valid_606661 = validateParameter(valid_606661, JString, required = false,
                                 default = nil)
  if valid_606661 != nil:
    section.add "X-Amz-Algorithm", valid_606661
  var valid_606662 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606662 = validateParameter(valid_606662, JString, required = false,
                                 default = nil)
  if valid_606662 != nil:
    section.add "X-Amz-SignedHeaders", valid_606662
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606663: Call_DescribeDomainConfiguration_606652; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Gets summary information about a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_606663.validator(path, query, header, formData, body)
  let scheme = call_606663.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606663.url(scheme.get, call_606663.host, call_606663.base,
                         call_606663.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606663, url, valid)

proc call*(call_606664: Call_DescribeDomainConfiguration_606652;
          domainConfigurationName: string): Recallable =
  ## describeDomainConfiguration
  ## <p>Gets summary information about a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   domainConfigurationName: string (required)
  ##                          : The name of the domain configuration.
  var path_606665 = newJObject()
  add(path_606665, "domainConfigurationName", newJString(domainConfigurationName))
  result = call_606664.call(path_606665, nil, nil, nil, nil)

var describeDomainConfiguration* = Call_DescribeDomainConfiguration_606652(
    name: "describeDomainConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/domainConfigurations/{domainConfigurationName}",
    validator: validate_DescribeDomainConfiguration_606653, base: "/",
    url: url_DescribeDomainConfiguration_606654,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteDomainConfiguration_606698 = ref object of OpenApiRestCall_605589
proc url_DeleteDomainConfiguration_606700(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "domainConfigurationName" in path,
        "`domainConfigurationName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/domainConfigurations/"),
               (kind: VariableSegment, value: "domainConfigurationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteDomainConfiguration_606699(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   domainConfigurationName: JString (required)
  ##                          : The name of the domain configuration to be deleted.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `domainConfigurationName` field"
  var valid_606701 = path.getOrDefault("domainConfigurationName")
  valid_606701 = validateParameter(valid_606701, JString, required = true,
                                 default = nil)
  if valid_606701 != nil:
    section.add "domainConfigurationName", valid_606701
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606702 = header.getOrDefault("X-Amz-Signature")
  valid_606702 = validateParameter(valid_606702, JString, required = false,
                                 default = nil)
  if valid_606702 != nil:
    section.add "X-Amz-Signature", valid_606702
  var valid_606703 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606703 = validateParameter(valid_606703, JString, required = false,
                                 default = nil)
  if valid_606703 != nil:
    section.add "X-Amz-Content-Sha256", valid_606703
  var valid_606704 = header.getOrDefault("X-Amz-Date")
  valid_606704 = validateParameter(valid_606704, JString, required = false,
                                 default = nil)
  if valid_606704 != nil:
    section.add "X-Amz-Date", valid_606704
  var valid_606705 = header.getOrDefault("X-Amz-Credential")
  valid_606705 = validateParameter(valid_606705, JString, required = false,
                                 default = nil)
  if valid_606705 != nil:
    section.add "X-Amz-Credential", valid_606705
  var valid_606706 = header.getOrDefault("X-Amz-Security-Token")
  valid_606706 = validateParameter(valid_606706, JString, required = false,
                                 default = nil)
  if valid_606706 != nil:
    section.add "X-Amz-Security-Token", valid_606706
  var valid_606707 = header.getOrDefault("X-Amz-Algorithm")
  valid_606707 = validateParameter(valid_606707, JString, required = false,
                                 default = nil)
  if valid_606707 != nil:
    section.add "X-Amz-Algorithm", valid_606707
  var valid_606708 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606708 = validateParameter(valid_606708, JString, required = false,
                                 default = nil)
  if valid_606708 != nil:
    section.add "X-Amz-SignedHeaders", valid_606708
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606709: Call_DeleteDomainConfiguration_606698; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_606709.validator(path, query, header, formData, body)
  let scheme = call_606709.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606709.url(scheme.get, call_606709.host, call_606709.base,
                         call_606709.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606709, url, valid)

proc call*(call_606710: Call_DeleteDomainConfiguration_606698;
          domainConfigurationName: string): Recallable =
  ## deleteDomainConfiguration
  ## <p>Deletes the specified domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   domainConfigurationName: string (required)
  ##                          : The name of the domain configuration to be deleted.
  var path_606711 = newJObject()
  add(path_606711, "domainConfigurationName", newJString(domainConfigurationName))
  result = call_606710.call(path_606711, nil, nil, nil, nil)

var deleteDomainConfiguration* = Call_DeleteDomainConfiguration_606698(
    name: "deleteDomainConfiguration", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/domainConfigurations/{domainConfigurationName}",
    validator: validate_DeleteDomainConfiguration_606699, base: "/",
    url: url_DeleteDomainConfiguration_606700,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateDynamicThingGroup_606712 = ref object of OpenApiRestCall_605589
proc url_CreateDynamicThingGroup_606714(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateDynamicThingGroup_606713(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The dynamic thing group name to create.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_606715 = path.getOrDefault("thingGroupName")
  valid_606715 = validateParameter(valid_606715, JString, required = true,
                                 default = nil)
  if valid_606715 != nil:
    section.add "thingGroupName", valid_606715
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606716 = header.getOrDefault("X-Amz-Signature")
  valid_606716 = validateParameter(valid_606716, JString, required = false,
                                 default = nil)
  if valid_606716 != nil:
    section.add "X-Amz-Signature", valid_606716
  var valid_606717 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606717 = validateParameter(valid_606717, JString, required = false,
                                 default = nil)
  if valid_606717 != nil:
    section.add "X-Amz-Content-Sha256", valid_606717
  var valid_606718 = header.getOrDefault("X-Amz-Date")
  valid_606718 = validateParameter(valid_606718, JString, required = false,
                                 default = nil)
  if valid_606718 != nil:
    section.add "X-Amz-Date", valid_606718
  var valid_606719 = header.getOrDefault("X-Amz-Credential")
  valid_606719 = validateParameter(valid_606719, JString, required = false,
                                 default = nil)
  if valid_606719 != nil:
    section.add "X-Amz-Credential", valid_606719
  var valid_606720 = header.getOrDefault("X-Amz-Security-Token")
  valid_606720 = validateParameter(valid_606720, JString, required = false,
                                 default = nil)
  if valid_606720 != nil:
    section.add "X-Amz-Security-Token", valid_606720
  var valid_606721 = header.getOrDefault("X-Amz-Algorithm")
  valid_606721 = validateParameter(valid_606721, JString, required = false,
                                 default = nil)
  if valid_606721 != nil:
    section.add "X-Amz-Algorithm", valid_606721
  var valid_606722 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606722 = validateParameter(valid_606722, JString, required = false,
                                 default = nil)
  if valid_606722 != nil:
    section.add "X-Amz-SignedHeaders", valid_606722
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606724: Call_CreateDynamicThingGroup_606712; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a dynamic thing group.
  ## 
  let valid = call_606724.validator(path, query, header, formData, body)
  let scheme = call_606724.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606724.url(scheme.get, call_606724.host, call_606724.base,
                         call_606724.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606724, url, valid)

proc call*(call_606725: Call_CreateDynamicThingGroup_606712;
          thingGroupName: string; body: JsonNode): Recallable =
  ## createDynamicThingGroup
  ## Creates a dynamic thing group.
  ##   thingGroupName: string (required)
  ##                 : The dynamic thing group name to create.
  ##   body: JObject (required)
  var path_606726 = newJObject()
  var body_606727 = newJObject()
  add(path_606726, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_606727 = body
  result = call_606725.call(path_606726, nil, nil, nil, body_606727)

var createDynamicThingGroup* = Call_CreateDynamicThingGroup_606712(
    name: "createDynamicThingGroup", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_CreateDynamicThingGroup_606713, base: "/",
    url: url_CreateDynamicThingGroup_606714, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateDynamicThingGroup_606744 = ref object of OpenApiRestCall_605589
proc url_UpdateDynamicThingGroup_606746(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateDynamicThingGroup_606745(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the dynamic thing group to update.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_606747 = path.getOrDefault("thingGroupName")
  valid_606747 = validateParameter(valid_606747, JString, required = true,
                                 default = nil)
  if valid_606747 != nil:
    section.add "thingGroupName", valid_606747
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606748 = header.getOrDefault("X-Amz-Signature")
  valid_606748 = validateParameter(valid_606748, JString, required = false,
                                 default = nil)
  if valid_606748 != nil:
    section.add "X-Amz-Signature", valid_606748
  var valid_606749 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606749 = validateParameter(valid_606749, JString, required = false,
                                 default = nil)
  if valid_606749 != nil:
    section.add "X-Amz-Content-Sha256", valid_606749
  var valid_606750 = header.getOrDefault("X-Amz-Date")
  valid_606750 = validateParameter(valid_606750, JString, required = false,
                                 default = nil)
  if valid_606750 != nil:
    section.add "X-Amz-Date", valid_606750
  var valid_606751 = header.getOrDefault("X-Amz-Credential")
  valid_606751 = validateParameter(valid_606751, JString, required = false,
                                 default = nil)
  if valid_606751 != nil:
    section.add "X-Amz-Credential", valid_606751
  var valid_606752 = header.getOrDefault("X-Amz-Security-Token")
  valid_606752 = validateParameter(valid_606752, JString, required = false,
                                 default = nil)
  if valid_606752 != nil:
    section.add "X-Amz-Security-Token", valid_606752
  var valid_606753 = header.getOrDefault("X-Amz-Algorithm")
  valid_606753 = validateParameter(valid_606753, JString, required = false,
                                 default = nil)
  if valid_606753 != nil:
    section.add "X-Amz-Algorithm", valid_606753
  var valid_606754 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606754 = validateParameter(valid_606754, JString, required = false,
                                 default = nil)
  if valid_606754 != nil:
    section.add "X-Amz-SignedHeaders", valid_606754
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606756: Call_UpdateDynamicThingGroup_606744; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a dynamic thing group.
  ## 
  let valid = call_606756.validator(path, query, header, formData, body)
  let scheme = call_606756.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606756.url(scheme.get, call_606756.host, call_606756.base,
                         call_606756.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606756, url, valid)

proc call*(call_606757: Call_UpdateDynamicThingGroup_606744;
          thingGroupName: string; body: JsonNode): Recallable =
  ## updateDynamicThingGroup
  ## Updates a dynamic thing group.
  ##   thingGroupName: string (required)
  ##                 : The name of the dynamic thing group to update.
  ##   body: JObject (required)
  var path_606758 = newJObject()
  var body_606759 = newJObject()
  add(path_606758, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_606759 = body
  result = call_606757.call(path_606758, nil, nil, nil, body_606759)

var updateDynamicThingGroup* = Call_UpdateDynamicThingGroup_606744(
    name: "updateDynamicThingGroup", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_UpdateDynamicThingGroup_606745, base: "/",
    url: url_UpdateDynamicThingGroup_606746, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteDynamicThingGroup_606728 = ref object of OpenApiRestCall_605589
proc url_DeleteDynamicThingGroup_606730(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/dynamic-thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteDynamicThingGroup_606729(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a dynamic thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the dynamic thing group to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_606731 = path.getOrDefault("thingGroupName")
  valid_606731 = validateParameter(valid_606731, JString, required = true,
                                 default = nil)
  if valid_606731 != nil:
    section.add "thingGroupName", valid_606731
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the dynamic thing group to delete.
  section = newJObject()
  var valid_606732 = query.getOrDefault("expectedVersion")
  valid_606732 = validateParameter(valid_606732, JInt, required = false, default = nil)
  if valid_606732 != nil:
    section.add "expectedVersion", valid_606732
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606733 = header.getOrDefault("X-Amz-Signature")
  valid_606733 = validateParameter(valid_606733, JString, required = false,
                                 default = nil)
  if valid_606733 != nil:
    section.add "X-Amz-Signature", valid_606733
  var valid_606734 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606734 = validateParameter(valid_606734, JString, required = false,
                                 default = nil)
  if valid_606734 != nil:
    section.add "X-Amz-Content-Sha256", valid_606734
  var valid_606735 = header.getOrDefault("X-Amz-Date")
  valid_606735 = validateParameter(valid_606735, JString, required = false,
                                 default = nil)
  if valid_606735 != nil:
    section.add "X-Amz-Date", valid_606735
  var valid_606736 = header.getOrDefault("X-Amz-Credential")
  valid_606736 = validateParameter(valid_606736, JString, required = false,
                                 default = nil)
  if valid_606736 != nil:
    section.add "X-Amz-Credential", valid_606736
  var valid_606737 = header.getOrDefault("X-Amz-Security-Token")
  valid_606737 = validateParameter(valid_606737, JString, required = false,
                                 default = nil)
  if valid_606737 != nil:
    section.add "X-Amz-Security-Token", valid_606737
  var valid_606738 = header.getOrDefault("X-Amz-Algorithm")
  valid_606738 = validateParameter(valid_606738, JString, required = false,
                                 default = nil)
  if valid_606738 != nil:
    section.add "X-Amz-Algorithm", valid_606738
  var valid_606739 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606739 = validateParameter(valid_606739, JString, required = false,
                                 default = nil)
  if valid_606739 != nil:
    section.add "X-Amz-SignedHeaders", valid_606739
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606740: Call_DeleteDynamicThingGroup_606728; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a dynamic thing group.
  ## 
  let valid = call_606740.validator(path, query, header, formData, body)
  let scheme = call_606740.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606740.url(scheme.get, call_606740.host, call_606740.base,
                         call_606740.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606740, url, valid)

proc call*(call_606741: Call_DeleteDynamicThingGroup_606728;
          thingGroupName: string; expectedVersion: int = 0): Recallable =
  ## deleteDynamicThingGroup
  ## Deletes a dynamic thing group.
  ##   expectedVersion: int
  ##                  : The expected version of the dynamic thing group to delete.
  ##   thingGroupName: string (required)
  ##                 : The name of the dynamic thing group to delete.
  var path_606742 = newJObject()
  var query_606743 = newJObject()
  add(query_606743, "expectedVersion", newJInt(expectedVersion))
  add(path_606742, "thingGroupName", newJString(thingGroupName))
  result = call_606741.call(path_606742, query_606743, nil, nil, nil)

var deleteDynamicThingGroup* = Call_DeleteDynamicThingGroup_606728(
    name: "deleteDynamicThingGroup", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/dynamic-thing-groups/{thingGroupName}",
    validator: validate_DeleteDynamicThingGroup_606729, base: "/",
    url: url_DeleteDynamicThingGroup_606730, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateJob_606774 = ref object of OpenApiRestCall_605589
proc url_CreateJob_606776(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateJob_606775(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_606777 = path.getOrDefault("jobId")
  valid_606777 = validateParameter(valid_606777, JString, required = true,
                                 default = nil)
  if valid_606777 != nil:
    section.add "jobId", valid_606777
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606778 = header.getOrDefault("X-Amz-Signature")
  valid_606778 = validateParameter(valid_606778, JString, required = false,
                                 default = nil)
  if valid_606778 != nil:
    section.add "X-Amz-Signature", valid_606778
  var valid_606779 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606779 = validateParameter(valid_606779, JString, required = false,
                                 default = nil)
  if valid_606779 != nil:
    section.add "X-Amz-Content-Sha256", valid_606779
  var valid_606780 = header.getOrDefault("X-Amz-Date")
  valid_606780 = validateParameter(valid_606780, JString, required = false,
                                 default = nil)
  if valid_606780 != nil:
    section.add "X-Amz-Date", valid_606780
  var valid_606781 = header.getOrDefault("X-Amz-Credential")
  valid_606781 = validateParameter(valid_606781, JString, required = false,
                                 default = nil)
  if valid_606781 != nil:
    section.add "X-Amz-Credential", valid_606781
  var valid_606782 = header.getOrDefault("X-Amz-Security-Token")
  valid_606782 = validateParameter(valid_606782, JString, required = false,
                                 default = nil)
  if valid_606782 != nil:
    section.add "X-Amz-Security-Token", valid_606782
  var valid_606783 = header.getOrDefault("X-Amz-Algorithm")
  valid_606783 = validateParameter(valid_606783, JString, required = false,
                                 default = nil)
  if valid_606783 != nil:
    section.add "X-Amz-Algorithm", valid_606783
  var valid_606784 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606784 = validateParameter(valid_606784, JString, required = false,
                                 default = nil)
  if valid_606784 != nil:
    section.add "X-Amz-SignedHeaders", valid_606784
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606786: Call_CreateJob_606774; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a job.
  ## 
  let valid = call_606786.validator(path, query, header, formData, body)
  let scheme = call_606786.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606786.url(scheme.get, call_606786.host, call_606786.base,
                         call_606786.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606786, url, valid)

proc call*(call_606787: Call_CreateJob_606774; jobId: string; body: JsonNode): Recallable =
  ## createJob
  ## Creates a job.
  ##   jobId: string (required)
  ##        : A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
  ##   body: JObject (required)
  var path_606788 = newJObject()
  var body_606789 = newJObject()
  add(path_606788, "jobId", newJString(jobId))
  if body != nil:
    body_606789 = body
  result = call_606787.call(path_606788, nil, nil, nil, body_606789)

var createJob* = Call_CreateJob_606774(name: "createJob", meth: HttpMethod.HttpPut,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_CreateJob_606775,
                                    base: "/", url: url_CreateJob_606776,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeJob_606760 = ref object of OpenApiRestCall_605589
proc url_DescribeJob_606762(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeJob_606761(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_606763 = path.getOrDefault("jobId")
  valid_606763 = validateParameter(valid_606763, JString, required = true,
                                 default = nil)
  if valid_606763 != nil:
    section.add "jobId", valid_606763
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606764 = header.getOrDefault("X-Amz-Signature")
  valid_606764 = validateParameter(valid_606764, JString, required = false,
                                 default = nil)
  if valid_606764 != nil:
    section.add "X-Amz-Signature", valid_606764
  var valid_606765 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606765 = validateParameter(valid_606765, JString, required = false,
                                 default = nil)
  if valid_606765 != nil:
    section.add "X-Amz-Content-Sha256", valid_606765
  var valid_606766 = header.getOrDefault("X-Amz-Date")
  valid_606766 = validateParameter(valid_606766, JString, required = false,
                                 default = nil)
  if valid_606766 != nil:
    section.add "X-Amz-Date", valid_606766
  var valid_606767 = header.getOrDefault("X-Amz-Credential")
  valid_606767 = validateParameter(valid_606767, JString, required = false,
                                 default = nil)
  if valid_606767 != nil:
    section.add "X-Amz-Credential", valid_606767
  var valid_606768 = header.getOrDefault("X-Amz-Security-Token")
  valid_606768 = validateParameter(valid_606768, JString, required = false,
                                 default = nil)
  if valid_606768 != nil:
    section.add "X-Amz-Security-Token", valid_606768
  var valid_606769 = header.getOrDefault("X-Amz-Algorithm")
  valid_606769 = validateParameter(valid_606769, JString, required = false,
                                 default = nil)
  if valid_606769 != nil:
    section.add "X-Amz-Algorithm", valid_606769
  var valid_606770 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606770 = validateParameter(valid_606770, JString, required = false,
                                 default = nil)
  if valid_606770 != nil:
    section.add "X-Amz-SignedHeaders", valid_606770
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606771: Call_DescribeJob_606760; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a job.
  ## 
  let valid = call_606771.validator(path, query, header, formData, body)
  let scheme = call_606771.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606771.url(scheme.get, call_606771.host, call_606771.base,
                         call_606771.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606771, url, valid)

proc call*(call_606772: Call_DescribeJob_606760; jobId: string): Recallable =
  ## describeJob
  ## Describes a job.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  var path_606773 = newJObject()
  add(path_606773, "jobId", newJString(jobId))
  result = call_606772.call(path_606773, nil, nil, nil, nil)

var describeJob* = Call_DescribeJob_606760(name: "describeJob",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/jobs/{jobId}",
                                        validator: validate_DescribeJob_606761,
                                        base: "/", url: url_DescribeJob_606762,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateJob_606806 = ref object of OpenApiRestCall_605589
proc url_UpdateJob_606808(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateJob_606807(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates supported fields of the specified job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The ID of the job to be updated.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_606809 = path.getOrDefault("jobId")
  valid_606809 = validateParameter(valid_606809, JString, required = true,
                                 default = nil)
  if valid_606809 != nil:
    section.add "jobId", valid_606809
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606810 = header.getOrDefault("X-Amz-Signature")
  valid_606810 = validateParameter(valid_606810, JString, required = false,
                                 default = nil)
  if valid_606810 != nil:
    section.add "X-Amz-Signature", valid_606810
  var valid_606811 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606811 = validateParameter(valid_606811, JString, required = false,
                                 default = nil)
  if valid_606811 != nil:
    section.add "X-Amz-Content-Sha256", valid_606811
  var valid_606812 = header.getOrDefault("X-Amz-Date")
  valid_606812 = validateParameter(valid_606812, JString, required = false,
                                 default = nil)
  if valid_606812 != nil:
    section.add "X-Amz-Date", valid_606812
  var valid_606813 = header.getOrDefault("X-Amz-Credential")
  valid_606813 = validateParameter(valid_606813, JString, required = false,
                                 default = nil)
  if valid_606813 != nil:
    section.add "X-Amz-Credential", valid_606813
  var valid_606814 = header.getOrDefault("X-Amz-Security-Token")
  valid_606814 = validateParameter(valid_606814, JString, required = false,
                                 default = nil)
  if valid_606814 != nil:
    section.add "X-Amz-Security-Token", valid_606814
  var valid_606815 = header.getOrDefault("X-Amz-Algorithm")
  valid_606815 = validateParameter(valid_606815, JString, required = false,
                                 default = nil)
  if valid_606815 != nil:
    section.add "X-Amz-Algorithm", valid_606815
  var valid_606816 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606816 = validateParameter(valid_606816, JString, required = false,
                                 default = nil)
  if valid_606816 != nil:
    section.add "X-Amz-SignedHeaders", valid_606816
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606818: Call_UpdateJob_606806; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates supported fields of the specified job.
  ## 
  let valid = call_606818.validator(path, query, header, formData, body)
  let scheme = call_606818.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606818.url(scheme.get, call_606818.host, call_606818.base,
                         call_606818.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606818, url, valid)

proc call*(call_606819: Call_UpdateJob_606806; jobId: string; body: JsonNode): Recallable =
  ## updateJob
  ## Updates supported fields of the specified job.
  ##   jobId: string (required)
  ##        : The ID of the job to be updated.
  ##   body: JObject (required)
  var path_606820 = newJObject()
  var body_606821 = newJObject()
  add(path_606820, "jobId", newJString(jobId))
  if body != nil:
    body_606821 = body
  result = call_606819.call(path_606820, nil, nil, nil, body_606821)

var updateJob* = Call_UpdateJob_606806(name: "updateJob", meth: HttpMethod.HttpPatch,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_UpdateJob_606807,
                                    base: "/", url: url_UpdateJob_606808,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteJob_606790 = ref object of OpenApiRestCall_605589
proc url_DeleteJob_606792(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteJob_606791(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_606793 = path.getOrDefault("jobId")
  valid_606793 = validateParameter(valid_606793, JString, required = true,
                                 default = nil)
  if valid_606793 != nil:
    section.add "jobId", valid_606793
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
  section = newJObject()
  var valid_606794 = query.getOrDefault("force")
  valid_606794 = validateParameter(valid_606794, JBool, required = false, default = nil)
  if valid_606794 != nil:
    section.add "force", valid_606794
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606795 = header.getOrDefault("X-Amz-Signature")
  valid_606795 = validateParameter(valid_606795, JString, required = false,
                                 default = nil)
  if valid_606795 != nil:
    section.add "X-Amz-Signature", valid_606795
  var valid_606796 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606796 = validateParameter(valid_606796, JString, required = false,
                                 default = nil)
  if valid_606796 != nil:
    section.add "X-Amz-Content-Sha256", valid_606796
  var valid_606797 = header.getOrDefault("X-Amz-Date")
  valid_606797 = validateParameter(valid_606797, JString, required = false,
                                 default = nil)
  if valid_606797 != nil:
    section.add "X-Amz-Date", valid_606797
  var valid_606798 = header.getOrDefault("X-Amz-Credential")
  valid_606798 = validateParameter(valid_606798, JString, required = false,
                                 default = nil)
  if valid_606798 != nil:
    section.add "X-Amz-Credential", valid_606798
  var valid_606799 = header.getOrDefault("X-Amz-Security-Token")
  valid_606799 = validateParameter(valid_606799, JString, required = false,
                                 default = nil)
  if valid_606799 != nil:
    section.add "X-Amz-Security-Token", valid_606799
  var valid_606800 = header.getOrDefault("X-Amz-Algorithm")
  valid_606800 = validateParameter(valid_606800, JString, required = false,
                                 default = nil)
  if valid_606800 != nil:
    section.add "X-Amz-Algorithm", valid_606800
  var valid_606801 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606801 = validateParameter(valid_606801, JString, required = false,
                                 default = nil)
  if valid_606801 != nil:
    section.add "X-Amz-SignedHeaders", valid_606801
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606802: Call_DeleteJob_606790; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ## 
  let valid = call_606802.validator(path, query, header, formData, body)
  let scheme = call_606802.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606802.url(scheme.get, call_606802.host, call_606802.base,
                         call_606802.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606802, url, valid)

proc call*(call_606803: Call_DeleteJob_606790; jobId: string; force: bool = false): Recallable =
  ## deleteJob
  ## <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
  ##   jobId: string (required)
  ##        : <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
  ##   force: bool
  ##        : <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
  var path_606804 = newJObject()
  var query_606805 = newJObject()
  add(path_606804, "jobId", newJString(jobId))
  add(query_606805, "force", newJBool(force))
  result = call_606803.call(path_606804, query_606805, nil, nil, nil)

var deleteJob* = Call_DeleteJob_606790(name: "deleteJob",
                                    meth: HttpMethod.HttpDelete,
                                    host: "iot.amazonaws.com",
                                    route: "/jobs/{jobId}",
                                    validator: validate_DeleteJob_606791,
                                    base: "/", url: url_DeleteJob_606792,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateKeysAndCertificate_606822 = ref object of OpenApiRestCall_605589
proc url_CreateKeysAndCertificate_606824(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateKeysAndCertificate_606823(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key. You can also call <code>CreateKeysAndCertificate</code> over MQTT from a device, for more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-wo-cert.html#provision-mqtt-api">Provisioning MQTT API</a>.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : Specifies whether the certificate is active.
  section = newJObject()
  var valid_606825 = query.getOrDefault("setAsActive")
  valid_606825 = validateParameter(valid_606825, JBool, required = false, default = nil)
  if valid_606825 != nil:
    section.add "setAsActive", valid_606825
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606826 = header.getOrDefault("X-Amz-Signature")
  valid_606826 = validateParameter(valid_606826, JString, required = false,
                                 default = nil)
  if valid_606826 != nil:
    section.add "X-Amz-Signature", valid_606826
  var valid_606827 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606827 = validateParameter(valid_606827, JString, required = false,
                                 default = nil)
  if valid_606827 != nil:
    section.add "X-Amz-Content-Sha256", valid_606827
  var valid_606828 = header.getOrDefault("X-Amz-Date")
  valid_606828 = validateParameter(valid_606828, JString, required = false,
                                 default = nil)
  if valid_606828 != nil:
    section.add "X-Amz-Date", valid_606828
  var valid_606829 = header.getOrDefault("X-Amz-Credential")
  valid_606829 = validateParameter(valid_606829, JString, required = false,
                                 default = nil)
  if valid_606829 != nil:
    section.add "X-Amz-Credential", valid_606829
  var valid_606830 = header.getOrDefault("X-Amz-Security-Token")
  valid_606830 = validateParameter(valid_606830, JString, required = false,
                                 default = nil)
  if valid_606830 != nil:
    section.add "X-Amz-Security-Token", valid_606830
  var valid_606831 = header.getOrDefault("X-Amz-Algorithm")
  valid_606831 = validateParameter(valid_606831, JString, required = false,
                                 default = nil)
  if valid_606831 != nil:
    section.add "X-Amz-Algorithm", valid_606831
  var valid_606832 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606832 = validateParameter(valid_606832, JString, required = false,
                                 default = nil)
  if valid_606832 != nil:
    section.add "X-Amz-SignedHeaders", valid_606832
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606833: Call_CreateKeysAndCertificate_606822; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key. You can also call <code>CreateKeysAndCertificate</code> over MQTT from a device, for more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-wo-cert.html#provision-mqtt-api">Provisioning MQTT API</a>.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ## 
  let valid = call_606833.validator(path, query, header, formData, body)
  let scheme = call_606833.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606833.url(scheme.get, call_606833.host, call_606833.base,
                         call_606833.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606833, url, valid)

proc call*(call_606834: Call_CreateKeysAndCertificate_606822;
          setAsActive: bool = false): Recallable =
  ## createKeysAndCertificate
  ## <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key. You can also call <code>CreateKeysAndCertificate</code> over MQTT from a device, for more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-wo-cert.html#provision-mqtt-api">Provisioning MQTT API</a>.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
  ##   setAsActive: bool
  ##              : Specifies whether the certificate is active.
  var query_606835 = newJObject()
  add(query_606835, "setAsActive", newJBool(setAsActive))
  result = call_606834.call(nil, query_606835, nil, nil, nil)

var createKeysAndCertificate* = Call_CreateKeysAndCertificate_606822(
    name: "createKeysAndCertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/keys-and-certificate",
    validator: validate_CreateKeysAndCertificate_606823, base: "/",
    url: url_CreateKeysAndCertificate_606824, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateMitigationAction_606850 = ref object of OpenApiRestCall_605589
proc url_CreateMitigationAction_606852(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateMitigationAction_606851(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_606853 = path.getOrDefault("actionName")
  valid_606853 = validateParameter(valid_606853, JString, required = true,
                                 default = nil)
  if valid_606853 != nil:
    section.add "actionName", valid_606853
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606854 = header.getOrDefault("X-Amz-Signature")
  valid_606854 = validateParameter(valid_606854, JString, required = false,
                                 default = nil)
  if valid_606854 != nil:
    section.add "X-Amz-Signature", valid_606854
  var valid_606855 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606855 = validateParameter(valid_606855, JString, required = false,
                                 default = nil)
  if valid_606855 != nil:
    section.add "X-Amz-Content-Sha256", valid_606855
  var valid_606856 = header.getOrDefault("X-Amz-Date")
  valid_606856 = validateParameter(valid_606856, JString, required = false,
                                 default = nil)
  if valid_606856 != nil:
    section.add "X-Amz-Date", valid_606856
  var valid_606857 = header.getOrDefault("X-Amz-Credential")
  valid_606857 = validateParameter(valid_606857, JString, required = false,
                                 default = nil)
  if valid_606857 != nil:
    section.add "X-Amz-Credential", valid_606857
  var valid_606858 = header.getOrDefault("X-Amz-Security-Token")
  valid_606858 = validateParameter(valid_606858, JString, required = false,
                                 default = nil)
  if valid_606858 != nil:
    section.add "X-Amz-Security-Token", valid_606858
  var valid_606859 = header.getOrDefault("X-Amz-Algorithm")
  valid_606859 = validateParameter(valid_606859, JString, required = false,
                                 default = nil)
  if valid_606859 != nil:
    section.add "X-Amz-Algorithm", valid_606859
  var valid_606860 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606860 = validateParameter(valid_606860, JString, required = false,
                                 default = nil)
  if valid_606860 != nil:
    section.add "X-Amz-SignedHeaders", valid_606860
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606862: Call_CreateMitigationAction_606850; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ## 
  let valid = call_606862.validator(path, query, header, formData, body)
  let scheme = call_606862.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606862.url(scheme.get, call_606862.host, call_606862.base,
                         call_606862.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606862, url, valid)

proc call*(call_606863: Call_CreateMitigationAction_606850; actionName: string;
          body: JsonNode): Recallable =
  ## createMitigationAction
  ## Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.
  ##   actionName: string (required)
  ##             : A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).
  ##   body: JObject (required)
  var path_606864 = newJObject()
  var body_606865 = newJObject()
  add(path_606864, "actionName", newJString(actionName))
  if body != nil:
    body_606865 = body
  result = call_606863.call(path_606864, nil, nil, nil, body_606865)

var createMitigationAction* = Call_CreateMitigationAction_606850(
    name: "createMitigationAction", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_CreateMitigationAction_606851, base: "/",
    url: url_CreateMitigationAction_606852, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeMitigationAction_606836 = ref object of OpenApiRestCall_605589
proc url_DescribeMitigationAction_606838(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeMitigationAction_606837(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a mitigation action.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The friendly name that uniquely identifies the mitigation action.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_606839 = path.getOrDefault("actionName")
  valid_606839 = validateParameter(valid_606839, JString, required = true,
                                 default = nil)
  if valid_606839 != nil:
    section.add "actionName", valid_606839
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606840 = header.getOrDefault("X-Amz-Signature")
  valid_606840 = validateParameter(valid_606840, JString, required = false,
                                 default = nil)
  if valid_606840 != nil:
    section.add "X-Amz-Signature", valid_606840
  var valid_606841 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606841 = validateParameter(valid_606841, JString, required = false,
                                 default = nil)
  if valid_606841 != nil:
    section.add "X-Amz-Content-Sha256", valid_606841
  var valid_606842 = header.getOrDefault("X-Amz-Date")
  valid_606842 = validateParameter(valid_606842, JString, required = false,
                                 default = nil)
  if valid_606842 != nil:
    section.add "X-Amz-Date", valid_606842
  var valid_606843 = header.getOrDefault("X-Amz-Credential")
  valid_606843 = validateParameter(valid_606843, JString, required = false,
                                 default = nil)
  if valid_606843 != nil:
    section.add "X-Amz-Credential", valid_606843
  var valid_606844 = header.getOrDefault("X-Amz-Security-Token")
  valid_606844 = validateParameter(valid_606844, JString, required = false,
                                 default = nil)
  if valid_606844 != nil:
    section.add "X-Amz-Security-Token", valid_606844
  var valid_606845 = header.getOrDefault("X-Amz-Algorithm")
  valid_606845 = validateParameter(valid_606845, JString, required = false,
                                 default = nil)
  if valid_606845 != nil:
    section.add "X-Amz-Algorithm", valid_606845
  var valid_606846 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606846 = validateParameter(valid_606846, JString, required = false,
                                 default = nil)
  if valid_606846 != nil:
    section.add "X-Amz-SignedHeaders", valid_606846
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606847: Call_DescribeMitigationAction_606836; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a mitigation action.
  ## 
  let valid = call_606847.validator(path, query, header, formData, body)
  let scheme = call_606847.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606847.url(scheme.get, call_606847.host, call_606847.base,
                         call_606847.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606847, url, valid)

proc call*(call_606848: Call_DescribeMitigationAction_606836; actionName: string): Recallable =
  ## describeMitigationAction
  ## Gets information about a mitigation action.
  ##   actionName: string (required)
  ##             : The friendly name that uniquely identifies the mitigation action.
  var path_606849 = newJObject()
  add(path_606849, "actionName", newJString(actionName))
  result = call_606848.call(path_606849, nil, nil, nil, nil)

var describeMitigationAction* = Call_DescribeMitigationAction_606836(
    name: "describeMitigationAction", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_DescribeMitigationAction_606837, base: "/",
    url: url_DescribeMitigationAction_606838, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateMitigationAction_606880 = ref object of OpenApiRestCall_605589
proc url_UpdateMitigationAction_606882(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateMitigationAction_606881(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the definition for the specified mitigation action.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_606883 = path.getOrDefault("actionName")
  valid_606883 = validateParameter(valid_606883, JString, required = true,
                                 default = nil)
  if valid_606883 != nil:
    section.add "actionName", valid_606883
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606884 = header.getOrDefault("X-Amz-Signature")
  valid_606884 = validateParameter(valid_606884, JString, required = false,
                                 default = nil)
  if valid_606884 != nil:
    section.add "X-Amz-Signature", valid_606884
  var valid_606885 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606885 = validateParameter(valid_606885, JString, required = false,
                                 default = nil)
  if valid_606885 != nil:
    section.add "X-Amz-Content-Sha256", valid_606885
  var valid_606886 = header.getOrDefault("X-Amz-Date")
  valid_606886 = validateParameter(valid_606886, JString, required = false,
                                 default = nil)
  if valid_606886 != nil:
    section.add "X-Amz-Date", valid_606886
  var valid_606887 = header.getOrDefault("X-Amz-Credential")
  valid_606887 = validateParameter(valid_606887, JString, required = false,
                                 default = nil)
  if valid_606887 != nil:
    section.add "X-Amz-Credential", valid_606887
  var valid_606888 = header.getOrDefault("X-Amz-Security-Token")
  valid_606888 = validateParameter(valid_606888, JString, required = false,
                                 default = nil)
  if valid_606888 != nil:
    section.add "X-Amz-Security-Token", valid_606888
  var valid_606889 = header.getOrDefault("X-Amz-Algorithm")
  valid_606889 = validateParameter(valid_606889, JString, required = false,
                                 default = nil)
  if valid_606889 != nil:
    section.add "X-Amz-Algorithm", valid_606889
  var valid_606890 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606890 = validateParameter(valid_606890, JString, required = false,
                                 default = nil)
  if valid_606890 != nil:
    section.add "X-Amz-SignedHeaders", valid_606890
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606892: Call_UpdateMitigationAction_606880; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the definition for the specified mitigation action.
  ## 
  let valid = call_606892.validator(path, query, header, formData, body)
  let scheme = call_606892.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606892.url(scheme.get, call_606892.host, call_606892.base,
                         call_606892.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606892, url, valid)

proc call*(call_606893: Call_UpdateMitigationAction_606880; actionName: string;
          body: JsonNode): Recallable =
  ## updateMitigationAction
  ## Updates the definition for the specified mitigation action.
  ##   actionName: string (required)
  ##             : The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.
  ##   body: JObject (required)
  var path_606894 = newJObject()
  var body_606895 = newJObject()
  add(path_606894, "actionName", newJString(actionName))
  if body != nil:
    body_606895 = body
  result = call_606893.call(path_606894, nil, nil, nil, body_606895)

var updateMitigationAction* = Call_UpdateMitigationAction_606880(
    name: "updateMitigationAction", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_UpdateMitigationAction_606881, base: "/",
    url: url_UpdateMitigationAction_606882, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteMitigationAction_606866 = ref object of OpenApiRestCall_605589
proc url_DeleteMitigationAction_606868(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "actionName" in path, "`actionName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/mitigationactions/actions/"),
               (kind: VariableSegment, value: "actionName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteMitigationAction_606867(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a defined mitigation action from your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   actionName: JString (required)
  ##             : The name of the mitigation action that you want to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `actionName` field"
  var valid_606869 = path.getOrDefault("actionName")
  valid_606869 = validateParameter(valid_606869, JString, required = true,
                                 default = nil)
  if valid_606869 != nil:
    section.add "actionName", valid_606869
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606870 = header.getOrDefault("X-Amz-Signature")
  valid_606870 = validateParameter(valid_606870, JString, required = false,
                                 default = nil)
  if valid_606870 != nil:
    section.add "X-Amz-Signature", valid_606870
  var valid_606871 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606871 = validateParameter(valid_606871, JString, required = false,
                                 default = nil)
  if valid_606871 != nil:
    section.add "X-Amz-Content-Sha256", valid_606871
  var valid_606872 = header.getOrDefault("X-Amz-Date")
  valid_606872 = validateParameter(valid_606872, JString, required = false,
                                 default = nil)
  if valid_606872 != nil:
    section.add "X-Amz-Date", valid_606872
  var valid_606873 = header.getOrDefault("X-Amz-Credential")
  valid_606873 = validateParameter(valid_606873, JString, required = false,
                                 default = nil)
  if valid_606873 != nil:
    section.add "X-Amz-Credential", valid_606873
  var valid_606874 = header.getOrDefault("X-Amz-Security-Token")
  valid_606874 = validateParameter(valid_606874, JString, required = false,
                                 default = nil)
  if valid_606874 != nil:
    section.add "X-Amz-Security-Token", valid_606874
  var valid_606875 = header.getOrDefault("X-Amz-Algorithm")
  valid_606875 = validateParameter(valid_606875, JString, required = false,
                                 default = nil)
  if valid_606875 != nil:
    section.add "X-Amz-Algorithm", valid_606875
  var valid_606876 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606876 = validateParameter(valid_606876, JString, required = false,
                                 default = nil)
  if valid_606876 != nil:
    section.add "X-Amz-SignedHeaders", valid_606876
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606877: Call_DeleteMitigationAction_606866; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a defined mitigation action from your AWS account.
  ## 
  let valid = call_606877.validator(path, query, header, formData, body)
  let scheme = call_606877.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606877.url(scheme.get, call_606877.host, call_606877.base,
                         call_606877.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606877, url, valid)

proc call*(call_606878: Call_DeleteMitigationAction_606866; actionName: string): Recallable =
  ## deleteMitigationAction
  ## Deletes a defined mitigation action from your AWS account.
  ##   actionName: string (required)
  ##             : The name of the mitigation action that you want to delete.
  var path_606879 = newJObject()
  add(path_606879, "actionName", newJString(actionName))
  result = call_606878.call(path_606879, nil, nil, nil, nil)

var deleteMitigationAction* = Call_DeleteMitigationAction_606866(
    name: "deleteMitigationAction", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions/{actionName}",
    validator: validate_DeleteMitigationAction_606867, base: "/",
    url: url_DeleteMitigationAction_606868, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateOTAUpdate_606910 = ref object of OpenApiRestCall_605589
proc url_CreateOTAUpdate_606912(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateOTAUpdate_606911(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The ID of the OTA update to be created.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_606913 = path.getOrDefault("otaUpdateId")
  valid_606913 = validateParameter(valid_606913, JString, required = true,
                                 default = nil)
  if valid_606913 != nil:
    section.add "otaUpdateId", valid_606913
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606914 = header.getOrDefault("X-Amz-Signature")
  valid_606914 = validateParameter(valid_606914, JString, required = false,
                                 default = nil)
  if valid_606914 != nil:
    section.add "X-Amz-Signature", valid_606914
  var valid_606915 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606915 = validateParameter(valid_606915, JString, required = false,
                                 default = nil)
  if valid_606915 != nil:
    section.add "X-Amz-Content-Sha256", valid_606915
  var valid_606916 = header.getOrDefault("X-Amz-Date")
  valid_606916 = validateParameter(valid_606916, JString, required = false,
                                 default = nil)
  if valid_606916 != nil:
    section.add "X-Amz-Date", valid_606916
  var valid_606917 = header.getOrDefault("X-Amz-Credential")
  valid_606917 = validateParameter(valid_606917, JString, required = false,
                                 default = nil)
  if valid_606917 != nil:
    section.add "X-Amz-Credential", valid_606917
  var valid_606918 = header.getOrDefault("X-Amz-Security-Token")
  valid_606918 = validateParameter(valid_606918, JString, required = false,
                                 default = nil)
  if valid_606918 != nil:
    section.add "X-Amz-Security-Token", valid_606918
  var valid_606919 = header.getOrDefault("X-Amz-Algorithm")
  valid_606919 = validateParameter(valid_606919, JString, required = false,
                                 default = nil)
  if valid_606919 != nil:
    section.add "X-Amz-Algorithm", valid_606919
  var valid_606920 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606920 = validateParameter(valid_606920, JString, required = false,
                                 default = nil)
  if valid_606920 != nil:
    section.add "X-Amz-SignedHeaders", valid_606920
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606922: Call_CreateOTAUpdate_606910; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ## 
  let valid = call_606922.validator(path, query, header, formData, body)
  let scheme = call_606922.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606922.url(scheme.get, call_606922.host, call_606922.base,
                         call_606922.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606922, url, valid)

proc call*(call_606923: Call_CreateOTAUpdate_606910; body: JsonNode;
          otaUpdateId: string): Recallable =
  ## createOTAUpdate
  ## Creates an AWS IoT OTAUpdate on a target group of things or groups.
  ##   body: JObject (required)
  ##   otaUpdateId: string (required)
  ##              : The ID of the OTA update to be created.
  var path_606924 = newJObject()
  var body_606925 = newJObject()
  if body != nil:
    body_606925 = body
  add(path_606924, "otaUpdateId", newJString(otaUpdateId))
  result = call_606923.call(path_606924, nil, nil, nil, body_606925)

var createOTAUpdate* = Call_CreateOTAUpdate_606910(name: "createOTAUpdate",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_CreateOTAUpdate_606911,
    base: "/", url: url_CreateOTAUpdate_606912, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetOTAUpdate_606896 = ref object of OpenApiRestCall_605589
proc url_GetOTAUpdate_606898(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOTAUpdate_606897(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets an OTA update.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The OTA update ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_606899 = path.getOrDefault("otaUpdateId")
  valid_606899 = validateParameter(valid_606899, JString, required = true,
                                 default = nil)
  if valid_606899 != nil:
    section.add "otaUpdateId", valid_606899
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606900 = header.getOrDefault("X-Amz-Signature")
  valid_606900 = validateParameter(valid_606900, JString, required = false,
                                 default = nil)
  if valid_606900 != nil:
    section.add "X-Amz-Signature", valid_606900
  var valid_606901 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606901 = validateParameter(valid_606901, JString, required = false,
                                 default = nil)
  if valid_606901 != nil:
    section.add "X-Amz-Content-Sha256", valid_606901
  var valid_606902 = header.getOrDefault("X-Amz-Date")
  valid_606902 = validateParameter(valid_606902, JString, required = false,
                                 default = nil)
  if valid_606902 != nil:
    section.add "X-Amz-Date", valid_606902
  var valid_606903 = header.getOrDefault("X-Amz-Credential")
  valid_606903 = validateParameter(valid_606903, JString, required = false,
                                 default = nil)
  if valid_606903 != nil:
    section.add "X-Amz-Credential", valid_606903
  var valid_606904 = header.getOrDefault("X-Amz-Security-Token")
  valid_606904 = validateParameter(valid_606904, JString, required = false,
                                 default = nil)
  if valid_606904 != nil:
    section.add "X-Amz-Security-Token", valid_606904
  var valid_606905 = header.getOrDefault("X-Amz-Algorithm")
  valid_606905 = validateParameter(valid_606905, JString, required = false,
                                 default = nil)
  if valid_606905 != nil:
    section.add "X-Amz-Algorithm", valid_606905
  var valid_606906 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606906 = validateParameter(valid_606906, JString, required = false,
                                 default = nil)
  if valid_606906 != nil:
    section.add "X-Amz-SignedHeaders", valid_606906
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606907: Call_GetOTAUpdate_606896; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets an OTA update.
  ## 
  let valid = call_606907.validator(path, query, header, formData, body)
  let scheme = call_606907.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606907.url(scheme.get, call_606907.host, call_606907.base,
                         call_606907.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606907, url, valid)

proc call*(call_606908: Call_GetOTAUpdate_606896; otaUpdateId: string): Recallable =
  ## getOTAUpdate
  ## Gets an OTA update.
  ##   otaUpdateId: string (required)
  ##              : The OTA update ID.
  var path_606909 = newJObject()
  add(path_606909, "otaUpdateId", newJString(otaUpdateId))
  result = call_606908.call(path_606909, nil, nil, nil, nil)

var getOTAUpdate* = Call_GetOTAUpdate_606896(name: "getOTAUpdate",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_GetOTAUpdate_606897,
    base: "/", url: url_GetOTAUpdate_606898, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteOTAUpdate_606926 = ref object of OpenApiRestCall_605589
proc url_DeleteOTAUpdate_606928(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "otaUpdateId" in path, "`otaUpdateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/otaUpdates/"),
               (kind: VariableSegment, value: "otaUpdateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOTAUpdate_606927(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Delete an OTA update.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   otaUpdateId: JString (required)
  ##              : The OTA update ID to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `otaUpdateId` field"
  var valid_606929 = path.getOrDefault("otaUpdateId")
  valid_606929 = validateParameter(valid_606929, JString, required = true,
                                 default = nil)
  if valid_606929 != nil:
    section.add "otaUpdateId", valid_606929
  result.add "path", section
  ## parameters in `query` object:
  ##   deleteStream: JBool
  ##               : Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.
  ##   forceDeleteAWSJob: JBool
  ##                    : Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.
  section = newJObject()
  var valid_606930 = query.getOrDefault("deleteStream")
  valid_606930 = validateParameter(valid_606930, JBool, required = false, default = nil)
  if valid_606930 != nil:
    section.add "deleteStream", valid_606930
  var valid_606931 = query.getOrDefault("forceDeleteAWSJob")
  valid_606931 = validateParameter(valid_606931, JBool, required = false, default = nil)
  if valid_606931 != nil:
    section.add "forceDeleteAWSJob", valid_606931
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606932 = header.getOrDefault("X-Amz-Signature")
  valid_606932 = validateParameter(valid_606932, JString, required = false,
                                 default = nil)
  if valid_606932 != nil:
    section.add "X-Amz-Signature", valid_606932
  var valid_606933 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606933 = validateParameter(valid_606933, JString, required = false,
                                 default = nil)
  if valid_606933 != nil:
    section.add "X-Amz-Content-Sha256", valid_606933
  var valid_606934 = header.getOrDefault("X-Amz-Date")
  valid_606934 = validateParameter(valid_606934, JString, required = false,
                                 default = nil)
  if valid_606934 != nil:
    section.add "X-Amz-Date", valid_606934
  var valid_606935 = header.getOrDefault("X-Amz-Credential")
  valid_606935 = validateParameter(valid_606935, JString, required = false,
                                 default = nil)
  if valid_606935 != nil:
    section.add "X-Amz-Credential", valid_606935
  var valid_606936 = header.getOrDefault("X-Amz-Security-Token")
  valid_606936 = validateParameter(valid_606936, JString, required = false,
                                 default = nil)
  if valid_606936 != nil:
    section.add "X-Amz-Security-Token", valid_606936
  var valid_606937 = header.getOrDefault("X-Amz-Algorithm")
  valid_606937 = validateParameter(valid_606937, JString, required = false,
                                 default = nil)
  if valid_606937 != nil:
    section.add "X-Amz-Algorithm", valid_606937
  var valid_606938 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606938 = validateParameter(valid_606938, JString, required = false,
                                 default = nil)
  if valid_606938 != nil:
    section.add "X-Amz-SignedHeaders", valid_606938
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606939: Call_DeleteOTAUpdate_606926; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete an OTA update.
  ## 
  let valid = call_606939.validator(path, query, header, formData, body)
  let scheme = call_606939.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606939.url(scheme.get, call_606939.host, call_606939.base,
                         call_606939.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606939, url, valid)

proc call*(call_606940: Call_DeleteOTAUpdate_606926; otaUpdateId: string;
          deleteStream: bool = false; forceDeleteAWSJob: bool = false): Recallable =
  ## deleteOTAUpdate
  ## Delete an OTA update.
  ##   deleteStream: bool
  ##               : Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.
  ##   otaUpdateId: string (required)
  ##              : The OTA update ID to delete.
  ##   forceDeleteAWSJob: bool
  ##                    : Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.
  var path_606941 = newJObject()
  var query_606942 = newJObject()
  add(query_606942, "deleteStream", newJBool(deleteStream))
  add(path_606941, "otaUpdateId", newJString(otaUpdateId))
  add(query_606942, "forceDeleteAWSJob", newJBool(forceDeleteAWSJob))
  result = call_606940.call(path_606941, query_606942, nil, nil, nil)

var deleteOTAUpdate* = Call_DeleteOTAUpdate_606926(name: "deleteOTAUpdate",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/otaUpdates/{otaUpdateId}", validator: validate_DeleteOTAUpdate_606927,
    base: "/", url: url_DeleteOTAUpdate_606928, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreatePolicy_606957 = ref object of OpenApiRestCall_605589
proc url_CreatePolicy_606959(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreatePolicy_606958(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_606960 = path.getOrDefault("policyName")
  valid_606960 = validateParameter(valid_606960, JString, required = true,
                                 default = nil)
  if valid_606960 != nil:
    section.add "policyName", valid_606960
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606961 = header.getOrDefault("X-Amz-Signature")
  valid_606961 = validateParameter(valid_606961, JString, required = false,
                                 default = nil)
  if valid_606961 != nil:
    section.add "X-Amz-Signature", valid_606961
  var valid_606962 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606962 = validateParameter(valid_606962, JString, required = false,
                                 default = nil)
  if valid_606962 != nil:
    section.add "X-Amz-Content-Sha256", valid_606962
  var valid_606963 = header.getOrDefault("X-Amz-Date")
  valid_606963 = validateParameter(valid_606963, JString, required = false,
                                 default = nil)
  if valid_606963 != nil:
    section.add "X-Amz-Date", valid_606963
  var valid_606964 = header.getOrDefault("X-Amz-Credential")
  valid_606964 = validateParameter(valid_606964, JString, required = false,
                                 default = nil)
  if valid_606964 != nil:
    section.add "X-Amz-Credential", valid_606964
  var valid_606965 = header.getOrDefault("X-Amz-Security-Token")
  valid_606965 = validateParameter(valid_606965, JString, required = false,
                                 default = nil)
  if valid_606965 != nil:
    section.add "X-Amz-Security-Token", valid_606965
  var valid_606966 = header.getOrDefault("X-Amz-Algorithm")
  valid_606966 = validateParameter(valid_606966, JString, required = false,
                                 default = nil)
  if valid_606966 != nil:
    section.add "X-Amz-Algorithm", valid_606966
  var valid_606967 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606967 = validateParameter(valid_606967, JString, required = false,
                                 default = nil)
  if valid_606967 != nil:
    section.add "X-Amz-SignedHeaders", valid_606967
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_606969: Call_CreatePolicy_606957; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ## 
  let valid = call_606969.validator(path, query, header, formData, body)
  let scheme = call_606969.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606969.url(scheme.get, call_606969.host, call_606969.base,
                         call_606969.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606969, url, valid)

proc call*(call_606970: Call_CreatePolicy_606957; policyName: string; body: JsonNode): Recallable =
  ## createPolicy
  ## <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
  ##   policyName: string (required)
  ##             : The policy name.
  ##   body: JObject (required)
  var path_606971 = newJObject()
  var body_606972 = newJObject()
  add(path_606971, "policyName", newJString(policyName))
  if body != nil:
    body_606972 = body
  result = call_606970.call(path_606971, nil, nil, nil, body_606972)

var createPolicy* = Call_CreatePolicy_606957(name: "createPolicy",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/policies/{policyName}", validator: validate_CreatePolicy_606958,
    base: "/", url: url_CreatePolicy_606959, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPolicy_606943 = ref object of OpenApiRestCall_605589
proc url_GetPolicy_606945(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetPolicy_606944(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the specified policy with the policy document of the default version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_606946 = path.getOrDefault("policyName")
  valid_606946 = validateParameter(valid_606946, JString, required = true,
                                 default = nil)
  if valid_606946 != nil:
    section.add "policyName", valid_606946
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606947 = header.getOrDefault("X-Amz-Signature")
  valid_606947 = validateParameter(valid_606947, JString, required = false,
                                 default = nil)
  if valid_606947 != nil:
    section.add "X-Amz-Signature", valid_606947
  var valid_606948 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606948 = validateParameter(valid_606948, JString, required = false,
                                 default = nil)
  if valid_606948 != nil:
    section.add "X-Amz-Content-Sha256", valid_606948
  var valid_606949 = header.getOrDefault("X-Amz-Date")
  valid_606949 = validateParameter(valid_606949, JString, required = false,
                                 default = nil)
  if valid_606949 != nil:
    section.add "X-Amz-Date", valid_606949
  var valid_606950 = header.getOrDefault("X-Amz-Credential")
  valid_606950 = validateParameter(valid_606950, JString, required = false,
                                 default = nil)
  if valid_606950 != nil:
    section.add "X-Amz-Credential", valid_606950
  var valid_606951 = header.getOrDefault("X-Amz-Security-Token")
  valid_606951 = validateParameter(valid_606951, JString, required = false,
                                 default = nil)
  if valid_606951 != nil:
    section.add "X-Amz-Security-Token", valid_606951
  var valid_606952 = header.getOrDefault("X-Amz-Algorithm")
  valid_606952 = validateParameter(valid_606952, JString, required = false,
                                 default = nil)
  if valid_606952 != nil:
    section.add "X-Amz-Algorithm", valid_606952
  var valid_606953 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606953 = validateParameter(valid_606953, JString, required = false,
                                 default = nil)
  if valid_606953 != nil:
    section.add "X-Amz-SignedHeaders", valid_606953
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606954: Call_GetPolicy_606943; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified policy with the policy document of the default version.
  ## 
  let valid = call_606954.validator(path, query, header, formData, body)
  let scheme = call_606954.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606954.url(scheme.get, call_606954.host, call_606954.base,
                         call_606954.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606954, url, valid)

proc call*(call_606955: Call_GetPolicy_606943; policyName: string): Recallable =
  ## getPolicy
  ## Gets information about the specified policy with the policy document of the default version.
  ##   policyName: string (required)
  ##             : The name of the policy.
  var path_606956 = newJObject()
  add(path_606956, "policyName", newJString(policyName))
  result = call_606955.call(path_606956, nil, nil, nil, nil)

var getPolicy* = Call_GetPolicy_606943(name: "getPolicy", meth: HttpMethod.HttpGet,
                                    host: "iot.amazonaws.com",
                                    route: "/policies/{policyName}",
                                    validator: validate_GetPolicy_606944,
                                    base: "/", url: url_GetPolicy_606945,
                                    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeletePolicy_606973 = ref object of OpenApiRestCall_605589
proc url_DeletePolicy_606975(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeletePolicy_606974(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_606976 = path.getOrDefault("policyName")
  valid_606976 = validateParameter(valid_606976, JString, required = true,
                                 default = nil)
  if valid_606976 != nil:
    section.add "policyName", valid_606976
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606977 = header.getOrDefault("X-Amz-Signature")
  valid_606977 = validateParameter(valid_606977, JString, required = false,
                                 default = nil)
  if valid_606977 != nil:
    section.add "X-Amz-Signature", valid_606977
  var valid_606978 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606978 = validateParameter(valid_606978, JString, required = false,
                                 default = nil)
  if valid_606978 != nil:
    section.add "X-Amz-Content-Sha256", valid_606978
  var valid_606979 = header.getOrDefault("X-Amz-Date")
  valid_606979 = validateParameter(valid_606979, JString, required = false,
                                 default = nil)
  if valid_606979 != nil:
    section.add "X-Amz-Date", valid_606979
  var valid_606980 = header.getOrDefault("X-Amz-Credential")
  valid_606980 = validateParameter(valid_606980, JString, required = false,
                                 default = nil)
  if valid_606980 != nil:
    section.add "X-Amz-Credential", valid_606980
  var valid_606981 = header.getOrDefault("X-Amz-Security-Token")
  valid_606981 = validateParameter(valid_606981, JString, required = false,
                                 default = nil)
  if valid_606981 != nil:
    section.add "X-Amz-Security-Token", valid_606981
  var valid_606982 = header.getOrDefault("X-Amz-Algorithm")
  valid_606982 = validateParameter(valid_606982, JString, required = false,
                                 default = nil)
  if valid_606982 != nil:
    section.add "X-Amz-Algorithm", valid_606982
  var valid_606983 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606983 = validateParameter(valid_606983, JString, required = false,
                                 default = nil)
  if valid_606983 != nil:
    section.add "X-Amz-SignedHeaders", valid_606983
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606984: Call_DeletePolicy_606973; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ## 
  let valid = call_606984.validator(path, query, header, formData, body)
  let scheme = call_606984.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606984.url(scheme.get, call_606984.host, call_606984.base,
                         call_606984.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606984, url, valid)

proc call*(call_606985: Call_DeletePolicy_606973; policyName: string): Recallable =
  ## deletePolicy
  ## <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
  ##   policyName: string (required)
  ##             : The name of the policy to delete.
  var path_606986 = newJObject()
  add(path_606986, "policyName", newJString(policyName))
  result = call_606985.call(path_606986, nil, nil, nil, nil)

var deletePolicy* = Call_DeletePolicy_606973(name: "deletePolicy",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/policies/{policyName}", validator: validate_DeletePolicy_606974,
    base: "/", url: url_DeletePolicy_606975, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreatePolicyVersion_607001 = ref object of OpenApiRestCall_605589
proc url_CreatePolicyVersion_607003(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreatePolicyVersion_607002(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_607004 = path.getOrDefault("policyName")
  valid_607004 = validateParameter(valid_607004, JString, required = true,
                                 default = nil)
  if valid_607004 != nil:
    section.add "policyName", valid_607004
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsDefault: JBool
  ##               : Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
  section = newJObject()
  var valid_607005 = query.getOrDefault("setAsDefault")
  valid_607005 = validateParameter(valid_607005, JBool, required = false, default = nil)
  if valid_607005 != nil:
    section.add "setAsDefault", valid_607005
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607006 = header.getOrDefault("X-Amz-Signature")
  valid_607006 = validateParameter(valid_607006, JString, required = false,
                                 default = nil)
  if valid_607006 != nil:
    section.add "X-Amz-Signature", valid_607006
  var valid_607007 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607007 = validateParameter(valid_607007, JString, required = false,
                                 default = nil)
  if valid_607007 != nil:
    section.add "X-Amz-Content-Sha256", valid_607007
  var valid_607008 = header.getOrDefault("X-Amz-Date")
  valid_607008 = validateParameter(valid_607008, JString, required = false,
                                 default = nil)
  if valid_607008 != nil:
    section.add "X-Amz-Date", valid_607008
  var valid_607009 = header.getOrDefault("X-Amz-Credential")
  valid_607009 = validateParameter(valid_607009, JString, required = false,
                                 default = nil)
  if valid_607009 != nil:
    section.add "X-Amz-Credential", valid_607009
  var valid_607010 = header.getOrDefault("X-Amz-Security-Token")
  valid_607010 = validateParameter(valid_607010, JString, required = false,
                                 default = nil)
  if valid_607010 != nil:
    section.add "X-Amz-Security-Token", valid_607010
  var valid_607011 = header.getOrDefault("X-Amz-Algorithm")
  valid_607011 = validateParameter(valid_607011, JString, required = false,
                                 default = nil)
  if valid_607011 != nil:
    section.add "X-Amz-Algorithm", valid_607011
  var valid_607012 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607012 = validateParameter(valid_607012, JString, required = false,
                                 default = nil)
  if valid_607012 != nil:
    section.add "X-Amz-SignedHeaders", valid_607012
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607014: Call_CreatePolicyVersion_607001; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ## 
  let valid = call_607014.validator(path, query, header, formData, body)
  let scheme = call_607014.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607014.url(scheme.get, call_607014.host, call_607014.base,
                         call_607014.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607014, url, valid)

proc call*(call_607015: Call_CreatePolicyVersion_607001; policyName: string;
          body: JsonNode; setAsDefault: bool = false): Recallable =
  ## createPolicyVersion
  ## <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
  ##   policyName: string (required)
  ##             : The policy name.
  ##   setAsDefault: bool
  ##               : Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
  ##   body: JObject (required)
  var path_607016 = newJObject()
  var query_607017 = newJObject()
  var body_607018 = newJObject()
  add(path_607016, "policyName", newJString(policyName))
  add(query_607017, "setAsDefault", newJBool(setAsDefault))
  if body != nil:
    body_607018 = body
  result = call_607015.call(path_607016, query_607017, nil, nil, body_607018)

var createPolicyVersion* = Call_CreatePolicyVersion_607001(
    name: "createPolicyVersion", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/policies/{policyName}/version",
    validator: validate_CreatePolicyVersion_607002, base: "/",
    url: url_CreatePolicyVersion_607003, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicyVersions_606987 = ref object of OpenApiRestCall_605589
proc url_ListPolicyVersions_606989(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListPolicyVersions_606988(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Lists the versions of the specified policy and identifies the default version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_606990 = path.getOrDefault("policyName")
  valid_606990 = validateParameter(valid_606990, JString, required = true,
                                 default = nil)
  if valid_606990 != nil:
    section.add "policyName", valid_606990
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_606991 = header.getOrDefault("X-Amz-Signature")
  valid_606991 = validateParameter(valid_606991, JString, required = false,
                                 default = nil)
  if valid_606991 != nil:
    section.add "X-Amz-Signature", valid_606991
  var valid_606992 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_606992 = validateParameter(valid_606992, JString, required = false,
                                 default = nil)
  if valid_606992 != nil:
    section.add "X-Amz-Content-Sha256", valid_606992
  var valid_606993 = header.getOrDefault("X-Amz-Date")
  valid_606993 = validateParameter(valid_606993, JString, required = false,
                                 default = nil)
  if valid_606993 != nil:
    section.add "X-Amz-Date", valid_606993
  var valid_606994 = header.getOrDefault("X-Amz-Credential")
  valid_606994 = validateParameter(valid_606994, JString, required = false,
                                 default = nil)
  if valid_606994 != nil:
    section.add "X-Amz-Credential", valid_606994
  var valid_606995 = header.getOrDefault("X-Amz-Security-Token")
  valid_606995 = validateParameter(valid_606995, JString, required = false,
                                 default = nil)
  if valid_606995 != nil:
    section.add "X-Amz-Security-Token", valid_606995
  var valid_606996 = header.getOrDefault("X-Amz-Algorithm")
  valid_606996 = validateParameter(valid_606996, JString, required = false,
                                 default = nil)
  if valid_606996 != nil:
    section.add "X-Amz-Algorithm", valid_606996
  var valid_606997 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_606997 = validateParameter(valid_606997, JString, required = false,
                                 default = nil)
  if valid_606997 != nil:
    section.add "X-Amz-SignedHeaders", valid_606997
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_606998: Call_ListPolicyVersions_606987; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the versions of the specified policy and identifies the default version.
  ## 
  let valid = call_606998.validator(path, query, header, formData, body)
  let scheme = call_606998.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_606998.url(scheme.get, call_606998.host, call_606998.base,
                         call_606998.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_606998, url, valid)

proc call*(call_606999: Call_ListPolicyVersions_606987; policyName: string): Recallable =
  ## listPolicyVersions
  ## Lists the versions of the specified policy and identifies the default version.
  ##   policyName: string (required)
  ##             : The policy name.
  var path_607000 = newJObject()
  add(path_607000, "policyName", newJString(policyName))
  result = call_606999.call(path_607000, nil, nil, nil, nil)

var listPolicyVersions* = Call_ListPolicyVersions_606987(
    name: "listPolicyVersions", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version",
    validator: validate_ListPolicyVersions_606988, base: "/",
    url: url_ListPolicyVersions_606989, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateProvisioningClaim_607019 = ref object of OpenApiRestCall_605589
proc url_CreateProvisioningClaim_607021(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/provisioning-claim")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateProvisioningClaim_607020(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a provisioning claim.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the provisioning template to use.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_607022 = path.getOrDefault("templateName")
  valid_607022 = validateParameter(valid_607022, JString, required = true,
                                 default = nil)
  if valid_607022 != nil:
    section.add "templateName", valid_607022
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607023 = header.getOrDefault("X-Amz-Signature")
  valid_607023 = validateParameter(valid_607023, JString, required = false,
                                 default = nil)
  if valid_607023 != nil:
    section.add "X-Amz-Signature", valid_607023
  var valid_607024 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607024 = validateParameter(valid_607024, JString, required = false,
                                 default = nil)
  if valid_607024 != nil:
    section.add "X-Amz-Content-Sha256", valid_607024
  var valid_607025 = header.getOrDefault("X-Amz-Date")
  valid_607025 = validateParameter(valid_607025, JString, required = false,
                                 default = nil)
  if valid_607025 != nil:
    section.add "X-Amz-Date", valid_607025
  var valid_607026 = header.getOrDefault("X-Amz-Credential")
  valid_607026 = validateParameter(valid_607026, JString, required = false,
                                 default = nil)
  if valid_607026 != nil:
    section.add "X-Amz-Credential", valid_607026
  var valid_607027 = header.getOrDefault("X-Amz-Security-Token")
  valid_607027 = validateParameter(valid_607027, JString, required = false,
                                 default = nil)
  if valid_607027 != nil:
    section.add "X-Amz-Security-Token", valid_607027
  var valid_607028 = header.getOrDefault("X-Amz-Algorithm")
  valid_607028 = validateParameter(valid_607028, JString, required = false,
                                 default = nil)
  if valid_607028 != nil:
    section.add "X-Amz-Algorithm", valid_607028
  var valid_607029 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607029 = validateParameter(valid_607029, JString, required = false,
                                 default = nil)
  if valid_607029 != nil:
    section.add "X-Amz-SignedHeaders", valid_607029
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607030: Call_CreateProvisioningClaim_607019; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a provisioning claim.
  ## 
  let valid = call_607030.validator(path, query, header, formData, body)
  let scheme = call_607030.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607030.url(scheme.get, call_607030.host, call_607030.base,
                         call_607030.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607030, url, valid)

proc call*(call_607031: Call_CreateProvisioningClaim_607019; templateName: string): Recallable =
  ## createProvisioningClaim
  ## Creates a provisioning claim.
  ##   templateName: string (required)
  ##               : The name of the provisioning template to use.
  var path_607032 = newJObject()
  add(path_607032, "templateName", newJString(templateName))
  result = call_607031.call(path_607032, nil, nil, nil, nil)

var createProvisioningClaim* = Call_CreateProvisioningClaim_607019(
    name: "createProvisioningClaim", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/provisioning-claim",
    validator: validate_CreateProvisioningClaim_607020, base: "/",
    url: url_CreateProvisioningClaim_607021, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateProvisioningTemplate_607048 = ref object of OpenApiRestCall_605589
proc url_CreateProvisioningTemplate_607050(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateProvisioningTemplate_607049(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607051 = header.getOrDefault("X-Amz-Signature")
  valid_607051 = validateParameter(valid_607051, JString, required = false,
                                 default = nil)
  if valid_607051 != nil:
    section.add "X-Amz-Signature", valid_607051
  var valid_607052 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607052 = validateParameter(valid_607052, JString, required = false,
                                 default = nil)
  if valid_607052 != nil:
    section.add "X-Amz-Content-Sha256", valid_607052
  var valid_607053 = header.getOrDefault("X-Amz-Date")
  valid_607053 = validateParameter(valid_607053, JString, required = false,
                                 default = nil)
  if valid_607053 != nil:
    section.add "X-Amz-Date", valid_607053
  var valid_607054 = header.getOrDefault("X-Amz-Credential")
  valid_607054 = validateParameter(valid_607054, JString, required = false,
                                 default = nil)
  if valid_607054 != nil:
    section.add "X-Amz-Credential", valid_607054
  var valid_607055 = header.getOrDefault("X-Amz-Security-Token")
  valid_607055 = validateParameter(valid_607055, JString, required = false,
                                 default = nil)
  if valid_607055 != nil:
    section.add "X-Amz-Security-Token", valid_607055
  var valid_607056 = header.getOrDefault("X-Amz-Algorithm")
  valid_607056 = validateParameter(valid_607056, JString, required = false,
                                 default = nil)
  if valid_607056 != nil:
    section.add "X-Amz-Algorithm", valid_607056
  var valid_607057 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607057 = validateParameter(valid_607057, JString, required = false,
                                 default = nil)
  if valid_607057 != nil:
    section.add "X-Amz-SignedHeaders", valid_607057
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607059: Call_CreateProvisioningTemplate_607048; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a fleet provisioning template.
  ## 
  let valid = call_607059.validator(path, query, header, formData, body)
  let scheme = call_607059.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607059.url(scheme.get, call_607059.host, call_607059.base,
                         call_607059.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607059, url, valid)

proc call*(call_607060: Call_CreateProvisioningTemplate_607048; body: JsonNode): Recallable =
  ## createProvisioningTemplate
  ## Creates a fleet provisioning template.
  ##   body: JObject (required)
  var body_607061 = newJObject()
  if body != nil:
    body_607061 = body
  result = call_607060.call(nil, nil, nil, nil, body_607061)

var createProvisioningTemplate* = Call_CreateProvisioningTemplate_607048(
    name: "createProvisioningTemplate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/provisioning-templates",
    validator: validate_CreateProvisioningTemplate_607049, base: "/",
    url: url_CreateProvisioningTemplate_607050,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListProvisioningTemplates_607033 = ref object of OpenApiRestCall_605589
proc url_ListProvisioningTemplates_607035(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListProvisioningTemplates_607034(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the fleet provisioning templates in your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_607036 = query.getOrDefault("nextToken")
  valid_607036 = validateParameter(valid_607036, JString, required = false,
                                 default = nil)
  if valid_607036 != nil:
    section.add "nextToken", valid_607036
  var valid_607037 = query.getOrDefault("maxResults")
  valid_607037 = validateParameter(valid_607037, JInt, required = false, default = nil)
  if valid_607037 != nil:
    section.add "maxResults", valid_607037
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607038 = header.getOrDefault("X-Amz-Signature")
  valid_607038 = validateParameter(valid_607038, JString, required = false,
                                 default = nil)
  if valid_607038 != nil:
    section.add "X-Amz-Signature", valid_607038
  var valid_607039 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607039 = validateParameter(valid_607039, JString, required = false,
                                 default = nil)
  if valid_607039 != nil:
    section.add "X-Amz-Content-Sha256", valid_607039
  var valid_607040 = header.getOrDefault("X-Amz-Date")
  valid_607040 = validateParameter(valid_607040, JString, required = false,
                                 default = nil)
  if valid_607040 != nil:
    section.add "X-Amz-Date", valid_607040
  var valid_607041 = header.getOrDefault("X-Amz-Credential")
  valid_607041 = validateParameter(valid_607041, JString, required = false,
                                 default = nil)
  if valid_607041 != nil:
    section.add "X-Amz-Credential", valid_607041
  var valid_607042 = header.getOrDefault("X-Amz-Security-Token")
  valid_607042 = validateParameter(valid_607042, JString, required = false,
                                 default = nil)
  if valid_607042 != nil:
    section.add "X-Amz-Security-Token", valid_607042
  var valid_607043 = header.getOrDefault("X-Amz-Algorithm")
  valid_607043 = validateParameter(valid_607043, JString, required = false,
                                 default = nil)
  if valid_607043 != nil:
    section.add "X-Amz-Algorithm", valid_607043
  var valid_607044 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607044 = validateParameter(valid_607044, JString, required = false,
                                 default = nil)
  if valid_607044 != nil:
    section.add "X-Amz-SignedHeaders", valid_607044
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607045: Call_ListProvisioningTemplates_607033; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the fleet provisioning templates in your AWS account.
  ## 
  let valid = call_607045.validator(path, query, header, formData, body)
  let scheme = call_607045.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607045.url(scheme.get, call_607045.host, call_607045.base,
                         call_607045.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607045, url, valid)

proc call*(call_607046: Call_ListProvisioningTemplates_607033;
          nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listProvisioningTemplates
  ## Lists the fleet provisioning templates in your AWS account.
  ##   nextToken: string
  ##            : A token to retrieve the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_607047 = newJObject()
  add(query_607047, "nextToken", newJString(nextToken))
  add(query_607047, "maxResults", newJInt(maxResults))
  result = call_607046.call(nil, query_607047, nil, nil, nil)

var listProvisioningTemplates* = Call_ListProvisioningTemplates_607033(
    name: "listProvisioningTemplates", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/provisioning-templates",
    validator: validate_ListProvisioningTemplates_607034, base: "/",
    url: url_ListProvisioningTemplates_607035,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateProvisioningTemplateVersion_607079 = ref object of OpenApiRestCall_605589
proc url_CreateProvisioningTemplateVersion_607081(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/versions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateProvisioningTemplateVersion_607080(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new version of a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_607082 = path.getOrDefault("templateName")
  valid_607082 = validateParameter(valid_607082, JString, required = true,
                                 default = nil)
  if valid_607082 != nil:
    section.add "templateName", valid_607082
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsDefault: JBool
  ##               : Sets a fleet provision template version as the default version.
  section = newJObject()
  var valid_607083 = query.getOrDefault("setAsDefault")
  valid_607083 = validateParameter(valid_607083, JBool, required = false, default = nil)
  if valid_607083 != nil:
    section.add "setAsDefault", valid_607083
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607084 = header.getOrDefault("X-Amz-Signature")
  valid_607084 = validateParameter(valid_607084, JString, required = false,
                                 default = nil)
  if valid_607084 != nil:
    section.add "X-Amz-Signature", valid_607084
  var valid_607085 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607085 = validateParameter(valid_607085, JString, required = false,
                                 default = nil)
  if valid_607085 != nil:
    section.add "X-Amz-Content-Sha256", valid_607085
  var valid_607086 = header.getOrDefault("X-Amz-Date")
  valid_607086 = validateParameter(valid_607086, JString, required = false,
                                 default = nil)
  if valid_607086 != nil:
    section.add "X-Amz-Date", valid_607086
  var valid_607087 = header.getOrDefault("X-Amz-Credential")
  valid_607087 = validateParameter(valid_607087, JString, required = false,
                                 default = nil)
  if valid_607087 != nil:
    section.add "X-Amz-Credential", valid_607087
  var valid_607088 = header.getOrDefault("X-Amz-Security-Token")
  valid_607088 = validateParameter(valid_607088, JString, required = false,
                                 default = nil)
  if valid_607088 != nil:
    section.add "X-Amz-Security-Token", valid_607088
  var valid_607089 = header.getOrDefault("X-Amz-Algorithm")
  valid_607089 = validateParameter(valid_607089, JString, required = false,
                                 default = nil)
  if valid_607089 != nil:
    section.add "X-Amz-Algorithm", valid_607089
  var valid_607090 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607090 = validateParameter(valid_607090, JString, required = false,
                                 default = nil)
  if valid_607090 != nil:
    section.add "X-Amz-SignedHeaders", valid_607090
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607092: Call_CreateProvisioningTemplateVersion_607079;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Creates a new version of a fleet provisioning template.
  ## 
  let valid = call_607092.validator(path, query, header, formData, body)
  let scheme = call_607092.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607092.url(scheme.get, call_607092.host, call_607092.base,
                         call_607092.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607092, url, valid)

proc call*(call_607093: Call_CreateProvisioningTemplateVersion_607079;
          body: JsonNode; templateName: string; setAsDefault: bool = false): Recallable =
  ## createProvisioningTemplateVersion
  ## Creates a new version of a fleet provisioning template.
  ##   setAsDefault: bool
  ##               : Sets a fleet provision template version as the default version.
  ##   body: JObject (required)
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template.
  var path_607094 = newJObject()
  var query_607095 = newJObject()
  var body_607096 = newJObject()
  add(query_607095, "setAsDefault", newJBool(setAsDefault))
  if body != nil:
    body_607096 = body
  add(path_607094, "templateName", newJString(templateName))
  result = call_607093.call(path_607094, query_607095, nil, nil, body_607096)

var createProvisioningTemplateVersion* = Call_CreateProvisioningTemplateVersion_607079(
    name: "createProvisioningTemplateVersion", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/versions",
    validator: validate_CreateProvisioningTemplateVersion_607080, base: "/",
    url: url_CreateProvisioningTemplateVersion_607081,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListProvisioningTemplateVersions_607062 = ref object of OpenApiRestCall_605589
proc url_ListProvisioningTemplateVersions_607064(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/versions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListProvisioningTemplateVersions_607063(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## A list of fleet provisioning template versions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_607065 = path.getOrDefault("templateName")
  valid_607065 = validateParameter(valid_607065, JString, required = true,
                                 default = nil)
  if valid_607065 != nil:
    section.add "templateName", valid_607065
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_607066 = query.getOrDefault("nextToken")
  valid_607066 = validateParameter(valid_607066, JString, required = false,
                                 default = nil)
  if valid_607066 != nil:
    section.add "nextToken", valid_607066
  var valid_607067 = query.getOrDefault("maxResults")
  valid_607067 = validateParameter(valid_607067, JInt, required = false, default = nil)
  if valid_607067 != nil:
    section.add "maxResults", valid_607067
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607068 = header.getOrDefault("X-Amz-Signature")
  valid_607068 = validateParameter(valid_607068, JString, required = false,
                                 default = nil)
  if valid_607068 != nil:
    section.add "X-Amz-Signature", valid_607068
  var valid_607069 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607069 = validateParameter(valid_607069, JString, required = false,
                                 default = nil)
  if valid_607069 != nil:
    section.add "X-Amz-Content-Sha256", valid_607069
  var valid_607070 = header.getOrDefault("X-Amz-Date")
  valid_607070 = validateParameter(valid_607070, JString, required = false,
                                 default = nil)
  if valid_607070 != nil:
    section.add "X-Amz-Date", valid_607070
  var valid_607071 = header.getOrDefault("X-Amz-Credential")
  valid_607071 = validateParameter(valid_607071, JString, required = false,
                                 default = nil)
  if valid_607071 != nil:
    section.add "X-Amz-Credential", valid_607071
  var valid_607072 = header.getOrDefault("X-Amz-Security-Token")
  valid_607072 = validateParameter(valid_607072, JString, required = false,
                                 default = nil)
  if valid_607072 != nil:
    section.add "X-Amz-Security-Token", valid_607072
  var valid_607073 = header.getOrDefault("X-Amz-Algorithm")
  valid_607073 = validateParameter(valid_607073, JString, required = false,
                                 default = nil)
  if valid_607073 != nil:
    section.add "X-Amz-Algorithm", valid_607073
  var valid_607074 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607074 = validateParameter(valid_607074, JString, required = false,
                                 default = nil)
  if valid_607074 != nil:
    section.add "X-Amz-SignedHeaders", valid_607074
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607075: Call_ListProvisioningTemplateVersions_607062;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## A list of fleet provisioning template versions.
  ## 
  let valid = call_607075.validator(path, query, header, formData, body)
  let scheme = call_607075.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607075.url(scheme.get, call_607075.host, call_607075.base,
                         call_607075.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607075, url, valid)

proc call*(call_607076: Call_ListProvisioningTemplateVersions_607062;
          templateName: string; nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listProvisioningTemplateVersions
  ## A list of fleet provisioning template versions.
  ##   nextToken: string
  ##            : A token to retrieve the next set of results.
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_607077 = newJObject()
  var query_607078 = newJObject()
  add(query_607078, "nextToken", newJString(nextToken))
  add(path_607077, "templateName", newJString(templateName))
  add(query_607078, "maxResults", newJInt(maxResults))
  result = call_607076.call(path_607077, query_607078, nil, nil, nil)

var listProvisioningTemplateVersions* = Call_ListProvisioningTemplateVersions_607062(
    name: "listProvisioningTemplateVersions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/versions",
    validator: validate_ListProvisioningTemplateVersions_607063, base: "/",
    url: url_ListProvisioningTemplateVersions_607064,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateRoleAlias_607111 = ref object of OpenApiRestCall_605589
proc url_UpdateRoleAlias_607113(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateRoleAlias_607112(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Updates a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_607114 = path.getOrDefault("roleAlias")
  valid_607114 = validateParameter(valid_607114, JString, required = true,
                                 default = nil)
  if valid_607114 != nil:
    section.add "roleAlias", valid_607114
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607115 = header.getOrDefault("X-Amz-Signature")
  valid_607115 = validateParameter(valid_607115, JString, required = false,
                                 default = nil)
  if valid_607115 != nil:
    section.add "X-Amz-Signature", valid_607115
  var valid_607116 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607116 = validateParameter(valid_607116, JString, required = false,
                                 default = nil)
  if valid_607116 != nil:
    section.add "X-Amz-Content-Sha256", valid_607116
  var valid_607117 = header.getOrDefault("X-Amz-Date")
  valid_607117 = validateParameter(valid_607117, JString, required = false,
                                 default = nil)
  if valid_607117 != nil:
    section.add "X-Amz-Date", valid_607117
  var valid_607118 = header.getOrDefault("X-Amz-Credential")
  valid_607118 = validateParameter(valid_607118, JString, required = false,
                                 default = nil)
  if valid_607118 != nil:
    section.add "X-Amz-Credential", valid_607118
  var valid_607119 = header.getOrDefault("X-Amz-Security-Token")
  valid_607119 = validateParameter(valid_607119, JString, required = false,
                                 default = nil)
  if valid_607119 != nil:
    section.add "X-Amz-Security-Token", valid_607119
  var valid_607120 = header.getOrDefault("X-Amz-Algorithm")
  valid_607120 = validateParameter(valid_607120, JString, required = false,
                                 default = nil)
  if valid_607120 != nil:
    section.add "X-Amz-Algorithm", valid_607120
  var valid_607121 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607121 = validateParameter(valid_607121, JString, required = false,
                                 default = nil)
  if valid_607121 != nil:
    section.add "X-Amz-SignedHeaders", valid_607121
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607123: Call_UpdateRoleAlias_607111; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a role alias.
  ## 
  let valid = call_607123.validator(path, query, header, formData, body)
  let scheme = call_607123.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607123.url(scheme.get, call_607123.host, call_607123.base,
                         call_607123.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607123, url, valid)

proc call*(call_607124: Call_UpdateRoleAlias_607111; roleAlias: string;
          body: JsonNode): Recallable =
  ## updateRoleAlias
  ## Updates a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias to update.
  ##   body: JObject (required)
  var path_607125 = newJObject()
  var body_607126 = newJObject()
  add(path_607125, "roleAlias", newJString(roleAlias))
  if body != nil:
    body_607126 = body
  result = call_607124.call(path_607125, nil, nil, nil, body_607126)

var updateRoleAlias* = Call_UpdateRoleAlias_607111(name: "updateRoleAlias",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_UpdateRoleAlias_607112,
    base: "/", url: url_UpdateRoleAlias_607113, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateRoleAlias_607127 = ref object of OpenApiRestCall_605589
proc url_CreateRoleAlias_607129(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateRoleAlias_607128(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias that points to a role ARN. This allows you to change the role without having to update the device.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_607130 = path.getOrDefault("roleAlias")
  valid_607130 = validateParameter(valid_607130, JString, required = true,
                                 default = nil)
  if valid_607130 != nil:
    section.add "roleAlias", valid_607130
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607131 = header.getOrDefault("X-Amz-Signature")
  valid_607131 = validateParameter(valid_607131, JString, required = false,
                                 default = nil)
  if valid_607131 != nil:
    section.add "X-Amz-Signature", valid_607131
  var valid_607132 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607132 = validateParameter(valid_607132, JString, required = false,
                                 default = nil)
  if valid_607132 != nil:
    section.add "X-Amz-Content-Sha256", valid_607132
  var valid_607133 = header.getOrDefault("X-Amz-Date")
  valid_607133 = validateParameter(valid_607133, JString, required = false,
                                 default = nil)
  if valid_607133 != nil:
    section.add "X-Amz-Date", valid_607133
  var valid_607134 = header.getOrDefault("X-Amz-Credential")
  valid_607134 = validateParameter(valid_607134, JString, required = false,
                                 default = nil)
  if valid_607134 != nil:
    section.add "X-Amz-Credential", valid_607134
  var valid_607135 = header.getOrDefault("X-Amz-Security-Token")
  valid_607135 = validateParameter(valid_607135, JString, required = false,
                                 default = nil)
  if valid_607135 != nil:
    section.add "X-Amz-Security-Token", valid_607135
  var valid_607136 = header.getOrDefault("X-Amz-Algorithm")
  valid_607136 = validateParameter(valid_607136, JString, required = false,
                                 default = nil)
  if valid_607136 != nil:
    section.add "X-Amz-Algorithm", valid_607136
  var valid_607137 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607137 = validateParameter(valid_607137, JString, required = false,
                                 default = nil)
  if valid_607137 != nil:
    section.add "X-Amz-SignedHeaders", valid_607137
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607139: Call_CreateRoleAlias_607127; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a role alias.
  ## 
  let valid = call_607139.validator(path, query, header, formData, body)
  let scheme = call_607139.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607139.url(scheme.get, call_607139.host, call_607139.base,
                         call_607139.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607139, url, valid)

proc call*(call_607140: Call_CreateRoleAlias_607127; roleAlias: string;
          body: JsonNode): Recallable =
  ## createRoleAlias
  ## Creates a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias that points to a role ARN. This allows you to change the role without having to update the device.
  ##   body: JObject (required)
  var path_607141 = newJObject()
  var body_607142 = newJObject()
  add(path_607141, "roleAlias", newJString(roleAlias))
  if body != nil:
    body_607142 = body
  result = call_607140.call(path_607141, nil, nil, nil, body_607142)

var createRoleAlias* = Call_CreateRoleAlias_607127(name: "createRoleAlias",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_CreateRoleAlias_607128,
    base: "/", url: url_CreateRoleAlias_607129, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeRoleAlias_607097 = ref object of OpenApiRestCall_605589
proc url_DescribeRoleAlias_607099(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeRoleAlias_607098(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Describes a role alias.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to describe.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_607100 = path.getOrDefault("roleAlias")
  valid_607100 = validateParameter(valid_607100, JString, required = true,
                                 default = nil)
  if valid_607100 != nil:
    section.add "roleAlias", valid_607100
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607101 = header.getOrDefault("X-Amz-Signature")
  valid_607101 = validateParameter(valid_607101, JString, required = false,
                                 default = nil)
  if valid_607101 != nil:
    section.add "X-Amz-Signature", valid_607101
  var valid_607102 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607102 = validateParameter(valid_607102, JString, required = false,
                                 default = nil)
  if valid_607102 != nil:
    section.add "X-Amz-Content-Sha256", valid_607102
  var valid_607103 = header.getOrDefault("X-Amz-Date")
  valid_607103 = validateParameter(valid_607103, JString, required = false,
                                 default = nil)
  if valid_607103 != nil:
    section.add "X-Amz-Date", valid_607103
  var valid_607104 = header.getOrDefault("X-Amz-Credential")
  valid_607104 = validateParameter(valid_607104, JString, required = false,
                                 default = nil)
  if valid_607104 != nil:
    section.add "X-Amz-Credential", valid_607104
  var valid_607105 = header.getOrDefault("X-Amz-Security-Token")
  valid_607105 = validateParameter(valid_607105, JString, required = false,
                                 default = nil)
  if valid_607105 != nil:
    section.add "X-Amz-Security-Token", valid_607105
  var valid_607106 = header.getOrDefault("X-Amz-Algorithm")
  valid_607106 = validateParameter(valid_607106, JString, required = false,
                                 default = nil)
  if valid_607106 != nil:
    section.add "X-Amz-Algorithm", valid_607106
  var valid_607107 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607107 = validateParameter(valid_607107, JString, required = false,
                                 default = nil)
  if valid_607107 != nil:
    section.add "X-Amz-SignedHeaders", valid_607107
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607108: Call_DescribeRoleAlias_607097; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a role alias.
  ## 
  let valid = call_607108.validator(path, query, header, formData, body)
  let scheme = call_607108.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607108.url(scheme.get, call_607108.host, call_607108.base,
                         call_607108.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607108, url, valid)

proc call*(call_607109: Call_DescribeRoleAlias_607097; roleAlias: string): Recallable =
  ## describeRoleAlias
  ## Describes a role alias.
  ##   roleAlias: string (required)
  ##            : The role alias to describe.
  var path_607110 = newJObject()
  add(path_607110, "roleAlias", newJString(roleAlias))
  result = call_607109.call(path_607110, nil, nil, nil, nil)

var describeRoleAlias* = Call_DescribeRoleAlias_607097(name: "describeRoleAlias",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_DescribeRoleAlias_607098,
    base: "/", url: url_DescribeRoleAlias_607099,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRoleAlias_607143 = ref object of OpenApiRestCall_605589
proc url_DeleteRoleAlias_607145(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "roleAlias" in path, "`roleAlias` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/role-aliases/"),
               (kind: VariableSegment, value: "roleAlias")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteRoleAlias_607144(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes a role alias
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   roleAlias: JString (required)
  ##            : The role alias to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `roleAlias` field"
  var valid_607146 = path.getOrDefault("roleAlias")
  valid_607146 = validateParameter(valid_607146, JString, required = true,
                                 default = nil)
  if valid_607146 != nil:
    section.add "roleAlias", valid_607146
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607147 = header.getOrDefault("X-Amz-Signature")
  valid_607147 = validateParameter(valid_607147, JString, required = false,
                                 default = nil)
  if valid_607147 != nil:
    section.add "X-Amz-Signature", valid_607147
  var valid_607148 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607148 = validateParameter(valid_607148, JString, required = false,
                                 default = nil)
  if valid_607148 != nil:
    section.add "X-Amz-Content-Sha256", valid_607148
  var valid_607149 = header.getOrDefault("X-Amz-Date")
  valid_607149 = validateParameter(valid_607149, JString, required = false,
                                 default = nil)
  if valid_607149 != nil:
    section.add "X-Amz-Date", valid_607149
  var valid_607150 = header.getOrDefault("X-Amz-Credential")
  valid_607150 = validateParameter(valid_607150, JString, required = false,
                                 default = nil)
  if valid_607150 != nil:
    section.add "X-Amz-Credential", valid_607150
  var valid_607151 = header.getOrDefault("X-Amz-Security-Token")
  valid_607151 = validateParameter(valid_607151, JString, required = false,
                                 default = nil)
  if valid_607151 != nil:
    section.add "X-Amz-Security-Token", valid_607151
  var valid_607152 = header.getOrDefault("X-Amz-Algorithm")
  valid_607152 = validateParameter(valid_607152, JString, required = false,
                                 default = nil)
  if valid_607152 != nil:
    section.add "X-Amz-Algorithm", valid_607152
  var valid_607153 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607153 = validateParameter(valid_607153, JString, required = false,
                                 default = nil)
  if valid_607153 != nil:
    section.add "X-Amz-SignedHeaders", valid_607153
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607154: Call_DeleteRoleAlias_607143; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a role alias
  ## 
  let valid = call_607154.validator(path, query, header, formData, body)
  let scheme = call_607154.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607154.url(scheme.get, call_607154.host, call_607154.base,
                         call_607154.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607154, url, valid)

proc call*(call_607155: Call_DeleteRoleAlias_607143; roleAlias: string): Recallable =
  ## deleteRoleAlias
  ## Deletes a role alias
  ##   roleAlias: string (required)
  ##            : The role alias to delete.
  var path_607156 = newJObject()
  add(path_607156, "roleAlias", newJString(roleAlias))
  result = call_607155.call(path_607156, nil, nil, nil, nil)

var deleteRoleAlias* = Call_DeleteRoleAlias_607143(name: "deleteRoleAlias",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/role-aliases/{roleAlias}", validator: validate_DeleteRoleAlias_607144,
    base: "/", url: url_DeleteRoleAlias_607145, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateScheduledAudit_607171 = ref object of OpenApiRestCall_605589
proc url_CreateScheduledAudit_607173(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateScheduledAudit_607172(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled audit that is run at a specified time interval.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name you want to give to the scheduled audit. (Max. 128 chars)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_607174 = path.getOrDefault("scheduledAuditName")
  valid_607174 = validateParameter(valid_607174, JString, required = true,
                                 default = nil)
  if valid_607174 != nil:
    section.add "scheduledAuditName", valid_607174
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607175 = header.getOrDefault("X-Amz-Signature")
  valid_607175 = validateParameter(valid_607175, JString, required = false,
                                 default = nil)
  if valid_607175 != nil:
    section.add "X-Amz-Signature", valid_607175
  var valid_607176 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607176 = validateParameter(valid_607176, JString, required = false,
                                 default = nil)
  if valid_607176 != nil:
    section.add "X-Amz-Content-Sha256", valid_607176
  var valid_607177 = header.getOrDefault("X-Amz-Date")
  valid_607177 = validateParameter(valid_607177, JString, required = false,
                                 default = nil)
  if valid_607177 != nil:
    section.add "X-Amz-Date", valid_607177
  var valid_607178 = header.getOrDefault("X-Amz-Credential")
  valid_607178 = validateParameter(valid_607178, JString, required = false,
                                 default = nil)
  if valid_607178 != nil:
    section.add "X-Amz-Credential", valid_607178
  var valid_607179 = header.getOrDefault("X-Amz-Security-Token")
  valid_607179 = validateParameter(valid_607179, JString, required = false,
                                 default = nil)
  if valid_607179 != nil:
    section.add "X-Amz-Security-Token", valid_607179
  var valid_607180 = header.getOrDefault("X-Amz-Algorithm")
  valid_607180 = validateParameter(valid_607180, JString, required = false,
                                 default = nil)
  if valid_607180 != nil:
    section.add "X-Amz-Algorithm", valid_607180
  var valid_607181 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607181 = validateParameter(valid_607181, JString, required = false,
                                 default = nil)
  if valid_607181 != nil:
    section.add "X-Amz-SignedHeaders", valid_607181
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607183: Call_CreateScheduledAudit_607171; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled audit that is run at a specified time interval.
  ## 
  let valid = call_607183.validator(path, query, header, formData, body)
  let scheme = call_607183.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607183.url(scheme.get, call_607183.host, call_607183.base,
                         call_607183.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607183, url, valid)

proc call*(call_607184: Call_CreateScheduledAudit_607171;
          scheduledAuditName: string; body: JsonNode): Recallable =
  ## createScheduledAudit
  ## Creates a scheduled audit that is run at a specified time interval.
  ##   scheduledAuditName: string (required)
  ##                     : The name you want to give to the scheduled audit. (Max. 128 chars)
  ##   body: JObject (required)
  var path_607185 = newJObject()
  var body_607186 = newJObject()
  add(path_607185, "scheduledAuditName", newJString(scheduledAuditName))
  if body != nil:
    body_607186 = body
  result = call_607184.call(path_607185, nil, nil, nil, body_607186)

var createScheduledAudit* = Call_CreateScheduledAudit_607171(
    name: "createScheduledAudit", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_CreateScheduledAudit_607172, base: "/",
    url: url_CreateScheduledAudit_607173, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeScheduledAudit_607157 = ref object of OpenApiRestCall_605589
proc url_DescribeScheduledAudit_607159(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeScheduledAudit_607158(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a scheduled audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit whose information you want to get.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_607160 = path.getOrDefault("scheduledAuditName")
  valid_607160 = validateParameter(valid_607160, JString, required = true,
                                 default = nil)
  if valid_607160 != nil:
    section.add "scheduledAuditName", valid_607160
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607161 = header.getOrDefault("X-Amz-Signature")
  valid_607161 = validateParameter(valid_607161, JString, required = false,
                                 default = nil)
  if valid_607161 != nil:
    section.add "X-Amz-Signature", valid_607161
  var valid_607162 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607162 = validateParameter(valid_607162, JString, required = false,
                                 default = nil)
  if valid_607162 != nil:
    section.add "X-Amz-Content-Sha256", valid_607162
  var valid_607163 = header.getOrDefault("X-Amz-Date")
  valid_607163 = validateParameter(valid_607163, JString, required = false,
                                 default = nil)
  if valid_607163 != nil:
    section.add "X-Amz-Date", valid_607163
  var valid_607164 = header.getOrDefault("X-Amz-Credential")
  valid_607164 = validateParameter(valid_607164, JString, required = false,
                                 default = nil)
  if valid_607164 != nil:
    section.add "X-Amz-Credential", valid_607164
  var valid_607165 = header.getOrDefault("X-Amz-Security-Token")
  valid_607165 = validateParameter(valid_607165, JString, required = false,
                                 default = nil)
  if valid_607165 != nil:
    section.add "X-Amz-Security-Token", valid_607165
  var valid_607166 = header.getOrDefault("X-Amz-Algorithm")
  valid_607166 = validateParameter(valid_607166, JString, required = false,
                                 default = nil)
  if valid_607166 != nil:
    section.add "X-Amz-Algorithm", valid_607166
  var valid_607167 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607167 = validateParameter(valid_607167, JString, required = false,
                                 default = nil)
  if valid_607167 != nil:
    section.add "X-Amz-SignedHeaders", valid_607167
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607168: Call_DescribeScheduledAudit_607157; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a scheduled audit.
  ## 
  let valid = call_607168.validator(path, query, header, formData, body)
  let scheme = call_607168.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607168.url(scheme.get, call_607168.host, call_607168.base,
                         call_607168.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607168, url, valid)

proc call*(call_607169: Call_DescribeScheduledAudit_607157;
          scheduledAuditName: string): Recallable =
  ## describeScheduledAudit
  ## Gets information about a scheduled audit.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit whose information you want to get.
  var path_607170 = newJObject()
  add(path_607170, "scheduledAuditName", newJString(scheduledAuditName))
  result = call_607169.call(path_607170, nil, nil, nil, nil)

var describeScheduledAudit* = Call_DescribeScheduledAudit_607157(
    name: "describeScheduledAudit", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_DescribeScheduledAudit_607158, base: "/",
    url: url_DescribeScheduledAudit_607159, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateScheduledAudit_607201 = ref object of OpenApiRestCall_605589
proc url_UpdateScheduledAudit_607203(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateScheduledAudit_607202(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit. (Max. 128 chars)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_607204 = path.getOrDefault("scheduledAuditName")
  valid_607204 = validateParameter(valid_607204, JString, required = true,
                                 default = nil)
  if valid_607204 != nil:
    section.add "scheduledAuditName", valid_607204
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607205 = header.getOrDefault("X-Amz-Signature")
  valid_607205 = validateParameter(valid_607205, JString, required = false,
                                 default = nil)
  if valid_607205 != nil:
    section.add "X-Amz-Signature", valid_607205
  var valid_607206 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607206 = validateParameter(valid_607206, JString, required = false,
                                 default = nil)
  if valid_607206 != nil:
    section.add "X-Amz-Content-Sha256", valid_607206
  var valid_607207 = header.getOrDefault("X-Amz-Date")
  valid_607207 = validateParameter(valid_607207, JString, required = false,
                                 default = nil)
  if valid_607207 != nil:
    section.add "X-Amz-Date", valid_607207
  var valid_607208 = header.getOrDefault("X-Amz-Credential")
  valid_607208 = validateParameter(valid_607208, JString, required = false,
                                 default = nil)
  if valid_607208 != nil:
    section.add "X-Amz-Credential", valid_607208
  var valid_607209 = header.getOrDefault("X-Amz-Security-Token")
  valid_607209 = validateParameter(valid_607209, JString, required = false,
                                 default = nil)
  if valid_607209 != nil:
    section.add "X-Amz-Security-Token", valid_607209
  var valid_607210 = header.getOrDefault("X-Amz-Algorithm")
  valid_607210 = validateParameter(valid_607210, JString, required = false,
                                 default = nil)
  if valid_607210 != nil:
    section.add "X-Amz-Algorithm", valid_607210
  var valid_607211 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607211 = validateParameter(valid_607211, JString, required = false,
                                 default = nil)
  if valid_607211 != nil:
    section.add "X-Amz-SignedHeaders", valid_607211
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607213: Call_UpdateScheduledAudit_607201; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ## 
  let valid = call_607213.validator(path, query, header, formData, body)
  let scheme = call_607213.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607213.url(scheme.get, call_607213.host, call_607213.base,
                         call_607213.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607213, url, valid)

proc call*(call_607214: Call_UpdateScheduledAudit_607201;
          scheduledAuditName: string; body: JsonNode): Recallable =
  ## updateScheduledAudit
  ## Updates a scheduled audit, including which checks are performed and how often the audit takes place.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit. (Max. 128 chars)
  ##   body: JObject (required)
  var path_607215 = newJObject()
  var body_607216 = newJObject()
  add(path_607215, "scheduledAuditName", newJString(scheduledAuditName))
  if body != nil:
    body_607216 = body
  result = call_607214.call(path_607215, nil, nil, nil, body_607216)

var updateScheduledAudit* = Call_UpdateScheduledAudit_607201(
    name: "updateScheduledAudit", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_UpdateScheduledAudit_607202, base: "/",
    url: url_UpdateScheduledAudit_607203, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteScheduledAudit_607187 = ref object of OpenApiRestCall_605589
proc url_DeleteScheduledAudit_607189(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "scheduledAuditName" in path,
        "`scheduledAuditName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/scheduledaudits/"),
               (kind: VariableSegment, value: "scheduledAuditName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteScheduledAudit_607188(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   scheduledAuditName: JString (required)
  ##                     : The name of the scheduled audit you want to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `scheduledAuditName` field"
  var valid_607190 = path.getOrDefault("scheduledAuditName")
  valid_607190 = validateParameter(valid_607190, JString, required = true,
                                 default = nil)
  if valid_607190 != nil:
    section.add "scheduledAuditName", valid_607190
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607191 = header.getOrDefault("X-Amz-Signature")
  valid_607191 = validateParameter(valid_607191, JString, required = false,
                                 default = nil)
  if valid_607191 != nil:
    section.add "X-Amz-Signature", valid_607191
  var valid_607192 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607192 = validateParameter(valid_607192, JString, required = false,
                                 default = nil)
  if valid_607192 != nil:
    section.add "X-Amz-Content-Sha256", valid_607192
  var valid_607193 = header.getOrDefault("X-Amz-Date")
  valid_607193 = validateParameter(valid_607193, JString, required = false,
                                 default = nil)
  if valid_607193 != nil:
    section.add "X-Amz-Date", valid_607193
  var valid_607194 = header.getOrDefault("X-Amz-Credential")
  valid_607194 = validateParameter(valid_607194, JString, required = false,
                                 default = nil)
  if valid_607194 != nil:
    section.add "X-Amz-Credential", valid_607194
  var valid_607195 = header.getOrDefault("X-Amz-Security-Token")
  valid_607195 = validateParameter(valid_607195, JString, required = false,
                                 default = nil)
  if valid_607195 != nil:
    section.add "X-Amz-Security-Token", valid_607195
  var valid_607196 = header.getOrDefault("X-Amz-Algorithm")
  valid_607196 = validateParameter(valid_607196, JString, required = false,
                                 default = nil)
  if valid_607196 != nil:
    section.add "X-Amz-Algorithm", valid_607196
  var valid_607197 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607197 = validateParameter(valid_607197, JString, required = false,
                                 default = nil)
  if valid_607197 != nil:
    section.add "X-Amz-SignedHeaders", valid_607197
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607198: Call_DeleteScheduledAudit_607187; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled audit.
  ## 
  let valid = call_607198.validator(path, query, header, formData, body)
  let scheme = call_607198.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607198.url(scheme.get, call_607198.host, call_607198.base,
                         call_607198.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607198, url, valid)

proc call*(call_607199: Call_DeleteScheduledAudit_607187;
          scheduledAuditName: string): Recallable =
  ## deleteScheduledAudit
  ## Deletes a scheduled audit.
  ##   scheduledAuditName: string (required)
  ##                     : The name of the scheduled audit you want to delete.
  var path_607200 = newJObject()
  add(path_607200, "scheduledAuditName", newJString(scheduledAuditName))
  result = call_607199.call(path_607200, nil, nil, nil, nil)

var deleteScheduledAudit* = Call_DeleteScheduledAudit_607187(
    name: "deleteScheduledAudit", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/audit/scheduledaudits/{scheduledAuditName}",
    validator: validate_DeleteScheduledAudit_607188, base: "/",
    url: url_DeleteScheduledAudit_607189, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateSecurityProfile_607231 = ref object of OpenApiRestCall_605589
proc url_CreateSecurityProfile_607233(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateSecurityProfile_607232(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name you are giving to the security profile.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_607234 = path.getOrDefault("securityProfileName")
  valid_607234 = validateParameter(valid_607234, JString, required = true,
                                 default = nil)
  if valid_607234 != nil:
    section.add "securityProfileName", valid_607234
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607235 = header.getOrDefault("X-Amz-Signature")
  valid_607235 = validateParameter(valid_607235, JString, required = false,
                                 default = nil)
  if valid_607235 != nil:
    section.add "X-Amz-Signature", valid_607235
  var valid_607236 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607236 = validateParameter(valid_607236, JString, required = false,
                                 default = nil)
  if valid_607236 != nil:
    section.add "X-Amz-Content-Sha256", valid_607236
  var valid_607237 = header.getOrDefault("X-Amz-Date")
  valid_607237 = validateParameter(valid_607237, JString, required = false,
                                 default = nil)
  if valid_607237 != nil:
    section.add "X-Amz-Date", valid_607237
  var valid_607238 = header.getOrDefault("X-Amz-Credential")
  valid_607238 = validateParameter(valid_607238, JString, required = false,
                                 default = nil)
  if valid_607238 != nil:
    section.add "X-Amz-Credential", valid_607238
  var valid_607239 = header.getOrDefault("X-Amz-Security-Token")
  valid_607239 = validateParameter(valid_607239, JString, required = false,
                                 default = nil)
  if valid_607239 != nil:
    section.add "X-Amz-Security-Token", valid_607239
  var valid_607240 = header.getOrDefault("X-Amz-Algorithm")
  valid_607240 = validateParameter(valid_607240, JString, required = false,
                                 default = nil)
  if valid_607240 != nil:
    section.add "X-Amz-Algorithm", valid_607240
  var valid_607241 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607241 = validateParameter(valid_607241, JString, required = false,
                                 default = nil)
  if valid_607241 != nil:
    section.add "X-Amz-SignedHeaders", valid_607241
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607243: Call_CreateSecurityProfile_607231; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Device Defender security profile.
  ## 
  let valid = call_607243.validator(path, query, header, formData, body)
  let scheme = call_607243.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607243.url(scheme.get, call_607243.host, call_607243.base,
                         call_607243.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607243, url, valid)

proc call*(call_607244: Call_CreateSecurityProfile_607231; body: JsonNode;
          securityProfileName: string): Recallable =
  ## createSecurityProfile
  ## Creates a Device Defender security profile.
  ##   body: JObject (required)
  ##   securityProfileName: string (required)
  ##                      : The name you are giving to the security profile.
  var path_607245 = newJObject()
  var body_607246 = newJObject()
  if body != nil:
    body_607246 = body
  add(path_607245, "securityProfileName", newJString(securityProfileName))
  result = call_607244.call(path_607245, nil, nil, nil, body_607246)

var createSecurityProfile* = Call_CreateSecurityProfile_607231(
    name: "createSecurityProfile", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_CreateSecurityProfile_607232, base: "/",
    url: url_CreateSecurityProfile_607233, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeSecurityProfile_607217 = ref object of OpenApiRestCall_605589
proc url_DescribeSecurityProfile_607219(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeSecurityProfile_607218(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile whose information you want to get.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_607220 = path.getOrDefault("securityProfileName")
  valid_607220 = validateParameter(valid_607220, JString, required = true,
                                 default = nil)
  if valid_607220 != nil:
    section.add "securityProfileName", valid_607220
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607221 = header.getOrDefault("X-Amz-Signature")
  valid_607221 = validateParameter(valid_607221, JString, required = false,
                                 default = nil)
  if valid_607221 != nil:
    section.add "X-Amz-Signature", valid_607221
  var valid_607222 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607222 = validateParameter(valid_607222, JString, required = false,
                                 default = nil)
  if valid_607222 != nil:
    section.add "X-Amz-Content-Sha256", valid_607222
  var valid_607223 = header.getOrDefault("X-Amz-Date")
  valid_607223 = validateParameter(valid_607223, JString, required = false,
                                 default = nil)
  if valid_607223 != nil:
    section.add "X-Amz-Date", valid_607223
  var valid_607224 = header.getOrDefault("X-Amz-Credential")
  valid_607224 = validateParameter(valid_607224, JString, required = false,
                                 default = nil)
  if valid_607224 != nil:
    section.add "X-Amz-Credential", valid_607224
  var valid_607225 = header.getOrDefault("X-Amz-Security-Token")
  valid_607225 = validateParameter(valid_607225, JString, required = false,
                                 default = nil)
  if valid_607225 != nil:
    section.add "X-Amz-Security-Token", valid_607225
  var valid_607226 = header.getOrDefault("X-Amz-Algorithm")
  valid_607226 = validateParameter(valid_607226, JString, required = false,
                                 default = nil)
  if valid_607226 != nil:
    section.add "X-Amz-Algorithm", valid_607226
  var valid_607227 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607227 = validateParameter(valid_607227, JString, required = false,
                                 default = nil)
  if valid_607227 != nil:
    section.add "X-Amz-SignedHeaders", valid_607227
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607228: Call_DescribeSecurityProfile_607217; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a Device Defender security profile.
  ## 
  let valid = call_607228.validator(path, query, header, formData, body)
  let scheme = call_607228.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607228.url(scheme.get, call_607228.host, call_607228.base,
                         call_607228.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607228, url, valid)

proc call*(call_607229: Call_DescribeSecurityProfile_607217;
          securityProfileName: string): Recallable =
  ## describeSecurityProfile
  ## Gets information about a Device Defender security profile.
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile whose information you want to get.
  var path_607230 = newJObject()
  add(path_607230, "securityProfileName", newJString(securityProfileName))
  result = call_607229.call(path_607230, nil, nil, nil, nil)

var describeSecurityProfile* = Call_DescribeSecurityProfile_607217(
    name: "describeSecurityProfile", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_DescribeSecurityProfile_607218, base: "/",
    url: url_DescribeSecurityProfile_607219, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateSecurityProfile_607263 = ref object of OpenApiRestCall_605589
proc url_UpdateSecurityProfile_607265(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateSecurityProfile_607264(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile you want to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_607266 = path.getOrDefault("securityProfileName")
  valid_607266 = validateParameter(valid_607266, JString, required = true,
                                 default = nil)
  if valid_607266 != nil:
    section.add "securityProfileName", valid_607266
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  section = newJObject()
  var valid_607267 = query.getOrDefault("expectedVersion")
  valid_607267 = validateParameter(valid_607267, JInt, required = false, default = nil)
  if valid_607267 != nil:
    section.add "expectedVersion", valid_607267
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607268 = header.getOrDefault("X-Amz-Signature")
  valid_607268 = validateParameter(valid_607268, JString, required = false,
                                 default = nil)
  if valid_607268 != nil:
    section.add "X-Amz-Signature", valid_607268
  var valid_607269 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607269 = validateParameter(valid_607269, JString, required = false,
                                 default = nil)
  if valid_607269 != nil:
    section.add "X-Amz-Content-Sha256", valid_607269
  var valid_607270 = header.getOrDefault("X-Amz-Date")
  valid_607270 = validateParameter(valid_607270, JString, required = false,
                                 default = nil)
  if valid_607270 != nil:
    section.add "X-Amz-Date", valid_607270
  var valid_607271 = header.getOrDefault("X-Amz-Credential")
  valid_607271 = validateParameter(valid_607271, JString, required = false,
                                 default = nil)
  if valid_607271 != nil:
    section.add "X-Amz-Credential", valid_607271
  var valid_607272 = header.getOrDefault("X-Amz-Security-Token")
  valid_607272 = validateParameter(valid_607272, JString, required = false,
                                 default = nil)
  if valid_607272 != nil:
    section.add "X-Amz-Security-Token", valid_607272
  var valid_607273 = header.getOrDefault("X-Amz-Algorithm")
  valid_607273 = validateParameter(valid_607273, JString, required = false,
                                 default = nil)
  if valid_607273 != nil:
    section.add "X-Amz-Algorithm", valid_607273
  var valid_607274 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607274 = validateParameter(valid_607274, JString, required = false,
                                 default = nil)
  if valid_607274 != nil:
    section.add "X-Amz-SignedHeaders", valid_607274
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607276: Call_UpdateSecurityProfile_607263; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a Device Defender security profile.
  ## 
  let valid = call_607276.validator(path, query, header, formData, body)
  let scheme = call_607276.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607276.url(scheme.get, call_607276.host, call_607276.base,
                         call_607276.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607276, url, valid)

proc call*(call_607277: Call_UpdateSecurityProfile_607263; body: JsonNode;
          securityProfileName: string; expectedVersion: int = 0): Recallable =
  ## updateSecurityProfile
  ## Updates a Device Defender security profile.
  ##   expectedVersion: int
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  ##   body: JObject (required)
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile you want to update.
  var path_607278 = newJObject()
  var query_607279 = newJObject()
  var body_607280 = newJObject()
  add(query_607279, "expectedVersion", newJInt(expectedVersion))
  if body != nil:
    body_607280 = body
  add(path_607278, "securityProfileName", newJString(securityProfileName))
  result = call_607277.call(path_607278, query_607279, nil, nil, body_607280)

var updateSecurityProfile* = Call_UpdateSecurityProfile_607263(
    name: "updateSecurityProfile", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_UpdateSecurityProfile_607264, base: "/",
    url: url_UpdateSecurityProfile_607265, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteSecurityProfile_607247 = ref object of OpenApiRestCall_605589
proc url_DeleteSecurityProfile_607249(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteSecurityProfile_607248(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The name of the security profile to be deleted.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_607250 = path.getOrDefault("securityProfileName")
  valid_607250 = validateParameter(valid_607250, JString, required = true,
                                 default = nil)
  if valid_607250 != nil:
    section.add "securityProfileName", valid_607250
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  section = newJObject()
  var valid_607251 = query.getOrDefault("expectedVersion")
  valid_607251 = validateParameter(valid_607251, JInt, required = false, default = nil)
  if valid_607251 != nil:
    section.add "expectedVersion", valid_607251
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607252 = header.getOrDefault("X-Amz-Signature")
  valid_607252 = validateParameter(valid_607252, JString, required = false,
                                 default = nil)
  if valid_607252 != nil:
    section.add "X-Amz-Signature", valid_607252
  var valid_607253 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607253 = validateParameter(valid_607253, JString, required = false,
                                 default = nil)
  if valid_607253 != nil:
    section.add "X-Amz-Content-Sha256", valid_607253
  var valid_607254 = header.getOrDefault("X-Amz-Date")
  valid_607254 = validateParameter(valid_607254, JString, required = false,
                                 default = nil)
  if valid_607254 != nil:
    section.add "X-Amz-Date", valid_607254
  var valid_607255 = header.getOrDefault("X-Amz-Credential")
  valid_607255 = validateParameter(valid_607255, JString, required = false,
                                 default = nil)
  if valid_607255 != nil:
    section.add "X-Amz-Credential", valid_607255
  var valid_607256 = header.getOrDefault("X-Amz-Security-Token")
  valid_607256 = validateParameter(valid_607256, JString, required = false,
                                 default = nil)
  if valid_607256 != nil:
    section.add "X-Amz-Security-Token", valid_607256
  var valid_607257 = header.getOrDefault("X-Amz-Algorithm")
  valid_607257 = validateParameter(valid_607257, JString, required = false,
                                 default = nil)
  if valid_607257 != nil:
    section.add "X-Amz-Algorithm", valid_607257
  var valid_607258 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607258 = validateParameter(valid_607258, JString, required = false,
                                 default = nil)
  if valid_607258 != nil:
    section.add "X-Amz-SignedHeaders", valid_607258
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607259: Call_DeleteSecurityProfile_607247; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a Device Defender security profile.
  ## 
  let valid = call_607259.validator(path, query, header, formData, body)
  let scheme = call_607259.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607259.url(scheme.get, call_607259.host, call_607259.base,
                         call_607259.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607259, url, valid)

proc call*(call_607260: Call_DeleteSecurityProfile_607247;
          securityProfileName: string; expectedVersion: int = 0): Recallable =
  ## deleteSecurityProfile
  ## Deletes a Device Defender security profile.
  ##   expectedVersion: int
  ##                  : The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.
  ##   securityProfileName: string (required)
  ##                      : The name of the security profile to be deleted.
  var path_607261 = newJObject()
  var query_607262 = newJObject()
  add(query_607262, "expectedVersion", newJInt(expectedVersion))
  add(path_607261, "securityProfileName", newJString(securityProfileName))
  result = call_607260.call(path_607261, query_607262, nil, nil, nil)

var deleteSecurityProfile* = Call_DeleteSecurityProfile_607247(
    name: "deleteSecurityProfile", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/security-profiles/{securityProfileName}",
    validator: validate_DeleteSecurityProfile_607248, base: "/",
    url: url_DeleteSecurityProfile_607249, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateStream_607295 = ref object of OpenApiRestCall_605589
proc url_UpdateStream_607297(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateStream_607296(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates an existing stream. The stream version will be incremented by one.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_607298 = path.getOrDefault("streamId")
  valid_607298 = validateParameter(valid_607298, JString, required = true,
                                 default = nil)
  if valid_607298 != nil:
    section.add "streamId", valid_607298
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607299 = header.getOrDefault("X-Amz-Signature")
  valid_607299 = validateParameter(valid_607299, JString, required = false,
                                 default = nil)
  if valid_607299 != nil:
    section.add "X-Amz-Signature", valid_607299
  var valid_607300 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607300 = validateParameter(valid_607300, JString, required = false,
                                 default = nil)
  if valid_607300 != nil:
    section.add "X-Amz-Content-Sha256", valid_607300
  var valid_607301 = header.getOrDefault("X-Amz-Date")
  valid_607301 = validateParameter(valid_607301, JString, required = false,
                                 default = nil)
  if valid_607301 != nil:
    section.add "X-Amz-Date", valid_607301
  var valid_607302 = header.getOrDefault("X-Amz-Credential")
  valid_607302 = validateParameter(valid_607302, JString, required = false,
                                 default = nil)
  if valid_607302 != nil:
    section.add "X-Amz-Credential", valid_607302
  var valid_607303 = header.getOrDefault("X-Amz-Security-Token")
  valid_607303 = validateParameter(valid_607303, JString, required = false,
                                 default = nil)
  if valid_607303 != nil:
    section.add "X-Amz-Security-Token", valid_607303
  var valid_607304 = header.getOrDefault("X-Amz-Algorithm")
  valid_607304 = validateParameter(valid_607304, JString, required = false,
                                 default = nil)
  if valid_607304 != nil:
    section.add "X-Amz-Algorithm", valid_607304
  var valid_607305 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607305 = validateParameter(valid_607305, JString, required = false,
                                 default = nil)
  if valid_607305 != nil:
    section.add "X-Amz-SignedHeaders", valid_607305
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607307: Call_UpdateStream_607295; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates an existing stream. The stream version will be incremented by one.
  ## 
  let valid = call_607307.validator(path, query, header, formData, body)
  let scheme = call_607307.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607307.url(scheme.get, call_607307.host, call_607307.base,
                         call_607307.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607307, url, valid)

proc call*(call_607308: Call_UpdateStream_607295; streamId: string; body: JsonNode): Recallable =
  ## updateStream
  ## Updates an existing stream. The stream version will be incremented by one.
  ##   streamId: string (required)
  ##           : The stream ID.
  ##   body: JObject (required)
  var path_607309 = newJObject()
  var body_607310 = newJObject()
  add(path_607309, "streamId", newJString(streamId))
  if body != nil:
    body_607310 = body
  result = call_607308.call(path_607309, nil, nil, nil, body_607310)

var updateStream* = Call_UpdateStream_607295(name: "updateStream",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_UpdateStream_607296,
    base: "/", url: url_UpdateStream_607297, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateStream_607311 = ref object of OpenApiRestCall_605589
proc url_CreateStream_607313(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateStream_607312(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_607314 = path.getOrDefault("streamId")
  valid_607314 = validateParameter(valid_607314, JString, required = true,
                                 default = nil)
  if valid_607314 != nil:
    section.add "streamId", valid_607314
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607315 = header.getOrDefault("X-Amz-Signature")
  valid_607315 = validateParameter(valid_607315, JString, required = false,
                                 default = nil)
  if valid_607315 != nil:
    section.add "X-Amz-Signature", valid_607315
  var valid_607316 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607316 = validateParameter(valid_607316, JString, required = false,
                                 default = nil)
  if valid_607316 != nil:
    section.add "X-Amz-Content-Sha256", valid_607316
  var valid_607317 = header.getOrDefault("X-Amz-Date")
  valid_607317 = validateParameter(valid_607317, JString, required = false,
                                 default = nil)
  if valid_607317 != nil:
    section.add "X-Amz-Date", valid_607317
  var valid_607318 = header.getOrDefault("X-Amz-Credential")
  valid_607318 = validateParameter(valid_607318, JString, required = false,
                                 default = nil)
  if valid_607318 != nil:
    section.add "X-Amz-Credential", valid_607318
  var valid_607319 = header.getOrDefault("X-Amz-Security-Token")
  valid_607319 = validateParameter(valid_607319, JString, required = false,
                                 default = nil)
  if valid_607319 != nil:
    section.add "X-Amz-Security-Token", valid_607319
  var valid_607320 = header.getOrDefault("X-Amz-Algorithm")
  valid_607320 = validateParameter(valid_607320, JString, required = false,
                                 default = nil)
  if valid_607320 != nil:
    section.add "X-Amz-Algorithm", valid_607320
  var valid_607321 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607321 = validateParameter(valid_607321, JString, required = false,
                                 default = nil)
  if valid_607321 != nil:
    section.add "X-Amz-SignedHeaders", valid_607321
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607323: Call_CreateStream_607311; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.
  ## 
  let valid = call_607323.validator(path, query, header, formData, body)
  let scheme = call_607323.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607323.url(scheme.get, call_607323.host, call_607323.base,
                         call_607323.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607323, url, valid)

proc call*(call_607324: Call_CreateStream_607311; streamId: string; body: JsonNode): Recallable =
  ## createStream
  ## Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  ##   body: JObject (required)
  var path_607325 = newJObject()
  var body_607326 = newJObject()
  add(path_607325, "streamId", newJString(streamId))
  if body != nil:
    body_607326 = body
  result = call_607324.call(path_607325, nil, nil, nil, body_607326)

var createStream* = Call_CreateStream_607311(name: "createStream",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_CreateStream_607312,
    base: "/", url: url_CreateStream_607313, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeStream_607281 = ref object of OpenApiRestCall_605589
proc url_DescribeStream_607283(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeStream_607282(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets information about a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_607284 = path.getOrDefault("streamId")
  valid_607284 = validateParameter(valid_607284, JString, required = true,
                                 default = nil)
  if valid_607284 != nil:
    section.add "streamId", valid_607284
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607285 = header.getOrDefault("X-Amz-Signature")
  valid_607285 = validateParameter(valid_607285, JString, required = false,
                                 default = nil)
  if valid_607285 != nil:
    section.add "X-Amz-Signature", valid_607285
  var valid_607286 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607286 = validateParameter(valid_607286, JString, required = false,
                                 default = nil)
  if valid_607286 != nil:
    section.add "X-Amz-Content-Sha256", valid_607286
  var valid_607287 = header.getOrDefault("X-Amz-Date")
  valid_607287 = validateParameter(valid_607287, JString, required = false,
                                 default = nil)
  if valid_607287 != nil:
    section.add "X-Amz-Date", valid_607287
  var valid_607288 = header.getOrDefault("X-Amz-Credential")
  valid_607288 = validateParameter(valid_607288, JString, required = false,
                                 default = nil)
  if valid_607288 != nil:
    section.add "X-Amz-Credential", valid_607288
  var valid_607289 = header.getOrDefault("X-Amz-Security-Token")
  valid_607289 = validateParameter(valid_607289, JString, required = false,
                                 default = nil)
  if valid_607289 != nil:
    section.add "X-Amz-Security-Token", valid_607289
  var valid_607290 = header.getOrDefault("X-Amz-Algorithm")
  valid_607290 = validateParameter(valid_607290, JString, required = false,
                                 default = nil)
  if valid_607290 != nil:
    section.add "X-Amz-Algorithm", valid_607290
  var valid_607291 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607291 = validateParameter(valid_607291, JString, required = false,
                                 default = nil)
  if valid_607291 != nil:
    section.add "X-Amz-SignedHeaders", valid_607291
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607292: Call_DescribeStream_607281; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a stream.
  ## 
  let valid = call_607292.validator(path, query, header, formData, body)
  let scheme = call_607292.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607292.url(scheme.get, call_607292.host, call_607292.base,
                         call_607292.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607292, url, valid)

proc call*(call_607293: Call_DescribeStream_607281; streamId: string): Recallable =
  ## describeStream
  ## Gets information about a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_607294 = newJObject()
  add(path_607294, "streamId", newJString(streamId))
  result = call_607293.call(path_607294, nil, nil, nil, nil)

var describeStream* = Call_DescribeStream_607281(name: "describeStream",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_DescribeStream_607282,
    base: "/", url: url_DescribeStream_607283, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteStream_607327 = ref object of OpenApiRestCall_605589
proc url_DeleteStream_607329(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "streamId" in path, "`streamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/streams/"),
               (kind: VariableSegment, value: "streamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteStream_607328(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a stream.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   streamId: JString (required)
  ##           : The stream ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `streamId` field"
  var valid_607330 = path.getOrDefault("streamId")
  valid_607330 = validateParameter(valid_607330, JString, required = true,
                                 default = nil)
  if valid_607330 != nil:
    section.add "streamId", valid_607330
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607331 = header.getOrDefault("X-Amz-Signature")
  valid_607331 = validateParameter(valid_607331, JString, required = false,
                                 default = nil)
  if valid_607331 != nil:
    section.add "X-Amz-Signature", valid_607331
  var valid_607332 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607332 = validateParameter(valid_607332, JString, required = false,
                                 default = nil)
  if valid_607332 != nil:
    section.add "X-Amz-Content-Sha256", valid_607332
  var valid_607333 = header.getOrDefault("X-Amz-Date")
  valid_607333 = validateParameter(valid_607333, JString, required = false,
                                 default = nil)
  if valid_607333 != nil:
    section.add "X-Amz-Date", valid_607333
  var valid_607334 = header.getOrDefault("X-Amz-Credential")
  valid_607334 = validateParameter(valid_607334, JString, required = false,
                                 default = nil)
  if valid_607334 != nil:
    section.add "X-Amz-Credential", valid_607334
  var valid_607335 = header.getOrDefault("X-Amz-Security-Token")
  valid_607335 = validateParameter(valid_607335, JString, required = false,
                                 default = nil)
  if valid_607335 != nil:
    section.add "X-Amz-Security-Token", valid_607335
  var valid_607336 = header.getOrDefault("X-Amz-Algorithm")
  valid_607336 = validateParameter(valid_607336, JString, required = false,
                                 default = nil)
  if valid_607336 != nil:
    section.add "X-Amz-Algorithm", valid_607336
  var valid_607337 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607337 = validateParameter(valid_607337, JString, required = false,
                                 default = nil)
  if valid_607337 != nil:
    section.add "X-Amz-SignedHeaders", valid_607337
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607338: Call_DeleteStream_607327; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a stream.
  ## 
  let valid = call_607338.validator(path, query, header, formData, body)
  let scheme = call_607338.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607338.url(scheme.get, call_607338.host, call_607338.base,
                         call_607338.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607338, url, valid)

proc call*(call_607339: Call_DeleteStream_607327; streamId: string): Recallable =
  ## deleteStream
  ## Deletes a stream.
  ##   streamId: string (required)
  ##           : The stream ID.
  var path_607340 = newJObject()
  add(path_607340, "streamId", newJString(streamId))
  result = call_607339.call(path_607340, nil, nil, nil, nil)

var deleteStream* = Call_DeleteStream_607327(name: "deleteStream",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/streams/{streamId}", validator: validate_DeleteStream_607328,
    base: "/", url: url_DeleteStream_607329, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThing_607355 = ref object of OpenApiRestCall_605589
proc url_CreateThing_607357(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateThing_607356(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to create.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_607358 = path.getOrDefault("thingName")
  valid_607358 = validateParameter(valid_607358, JString, required = true,
                                 default = nil)
  if valid_607358 != nil:
    section.add "thingName", valid_607358
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607359 = header.getOrDefault("X-Amz-Signature")
  valid_607359 = validateParameter(valid_607359, JString, required = false,
                                 default = nil)
  if valid_607359 != nil:
    section.add "X-Amz-Signature", valid_607359
  var valid_607360 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607360 = validateParameter(valid_607360, JString, required = false,
                                 default = nil)
  if valid_607360 != nil:
    section.add "X-Amz-Content-Sha256", valid_607360
  var valid_607361 = header.getOrDefault("X-Amz-Date")
  valid_607361 = validateParameter(valid_607361, JString, required = false,
                                 default = nil)
  if valid_607361 != nil:
    section.add "X-Amz-Date", valid_607361
  var valid_607362 = header.getOrDefault("X-Amz-Credential")
  valid_607362 = validateParameter(valid_607362, JString, required = false,
                                 default = nil)
  if valid_607362 != nil:
    section.add "X-Amz-Credential", valid_607362
  var valid_607363 = header.getOrDefault("X-Amz-Security-Token")
  valid_607363 = validateParameter(valid_607363, JString, required = false,
                                 default = nil)
  if valid_607363 != nil:
    section.add "X-Amz-Security-Token", valid_607363
  var valid_607364 = header.getOrDefault("X-Amz-Algorithm")
  valid_607364 = validateParameter(valid_607364, JString, required = false,
                                 default = nil)
  if valid_607364 != nil:
    section.add "X-Amz-Algorithm", valid_607364
  var valid_607365 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607365 = validateParameter(valid_607365, JString, required = false,
                                 default = nil)
  if valid_607365 != nil:
    section.add "X-Amz-SignedHeaders", valid_607365
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607367: Call_CreateThing_607355; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  let valid = call_607367.validator(path, query, header, formData, body)
  let scheme = call_607367.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607367.url(scheme.get, call_607367.host, call_607367.base,
                         call_607367.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607367, url, valid)

proc call*(call_607368: Call_CreateThing_607355; thingName: string; body: JsonNode): Recallable =
  ## createThing
  ## <p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ##   thingName: string (required)
  ##            : The name of the thing to create.
  ##   body: JObject (required)
  var path_607369 = newJObject()
  var body_607370 = newJObject()
  add(path_607369, "thingName", newJString(thingName))
  if body != nil:
    body_607370 = body
  result = call_607368.call(path_607369, nil, nil, nil, body_607370)

var createThing* = Call_CreateThing_607355(name: "createThing",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_CreateThing_607356,
                                        base: "/", url: url_CreateThing_607357,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThing_607341 = ref object of OpenApiRestCall_605589
proc url_DescribeThing_607343(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThing_607342(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the specified thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_607344 = path.getOrDefault("thingName")
  valid_607344 = validateParameter(valid_607344, JString, required = true,
                                 default = nil)
  if valid_607344 != nil:
    section.add "thingName", valid_607344
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607345 = header.getOrDefault("X-Amz-Signature")
  valid_607345 = validateParameter(valid_607345, JString, required = false,
                                 default = nil)
  if valid_607345 != nil:
    section.add "X-Amz-Signature", valid_607345
  var valid_607346 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607346 = validateParameter(valid_607346, JString, required = false,
                                 default = nil)
  if valid_607346 != nil:
    section.add "X-Amz-Content-Sha256", valid_607346
  var valid_607347 = header.getOrDefault("X-Amz-Date")
  valid_607347 = validateParameter(valid_607347, JString, required = false,
                                 default = nil)
  if valid_607347 != nil:
    section.add "X-Amz-Date", valid_607347
  var valid_607348 = header.getOrDefault("X-Amz-Credential")
  valid_607348 = validateParameter(valid_607348, JString, required = false,
                                 default = nil)
  if valid_607348 != nil:
    section.add "X-Amz-Credential", valid_607348
  var valid_607349 = header.getOrDefault("X-Amz-Security-Token")
  valid_607349 = validateParameter(valid_607349, JString, required = false,
                                 default = nil)
  if valid_607349 != nil:
    section.add "X-Amz-Security-Token", valid_607349
  var valid_607350 = header.getOrDefault("X-Amz-Algorithm")
  valid_607350 = validateParameter(valid_607350, JString, required = false,
                                 default = nil)
  if valid_607350 != nil:
    section.add "X-Amz-Algorithm", valid_607350
  var valid_607351 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607351 = validateParameter(valid_607351, JString, required = false,
                                 default = nil)
  if valid_607351 != nil:
    section.add "X-Amz-SignedHeaders", valid_607351
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607352: Call_DescribeThing_607341; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified thing.
  ## 
  let valid = call_607352.validator(path, query, header, formData, body)
  let scheme = call_607352.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607352.url(scheme.get, call_607352.host, call_607352.base,
                         call_607352.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607352, url, valid)

proc call*(call_607353: Call_DescribeThing_607341; thingName: string): Recallable =
  ## describeThing
  ## Gets information about the specified thing.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_607354 = newJObject()
  add(path_607354, "thingName", newJString(thingName))
  result = call_607353.call(path_607354, nil, nil, nil, nil)

var describeThing* = Call_DescribeThing_607341(name: "describeThing",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/things/{thingName}", validator: validate_DescribeThing_607342,
    base: "/", url: url_DescribeThing_607343, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThing_607387 = ref object of OpenApiRestCall_605589
proc url_UpdateThing_607389(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateThing_607388(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the data for a thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to update.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_607390 = path.getOrDefault("thingName")
  valid_607390 = validateParameter(valid_607390, JString, required = true,
                                 default = nil)
  if valid_607390 != nil:
    section.add "thingName", valid_607390
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607391 = header.getOrDefault("X-Amz-Signature")
  valid_607391 = validateParameter(valid_607391, JString, required = false,
                                 default = nil)
  if valid_607391 != nil:
    section.add "X-Amz-Signature", valid_607391
  var valid_607392 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607392 = validateParameter(valid_607392, JString, required = false,
                                 default = nil)
  if valid_607392 != nil:
    section.add "X-Amz-Content-Sha256", valid_607392
  var valid_607393 = header.getOrDefault("X-Amz-Date")
  valid_607393 = validateParameter(valid_607393, JString, required = false,
                                 default = nil)
  if valid_607393 != nil:
    section.add "X-Amz-Date", valid_607393
  var valid_607394 = header.getOrDefault("X-Amz-Credential")
  valid_607394 = validateParameter(valid_607394, JString, required = false,
                                 default = nil)
  if valid_607394 != nil:
    section.add "X-Amz-Credential", valid_607394
  var valid_607395 = header.getOrDefault("X-Amz-Security-Token")
  valid_607395 = validateParameter(valid_607395, JString, required = false,
                                 default = nil)
  if valid_607395 != nil:
    section.add "X-Amz-Security-Token", valid_607395
  var valid_607396 = header.getOrDefault("X-Amz-Algorithm")
  valid_607396 = validateParameter(valid_607396, JString, required = false,
                                 default = nil)
  if valid_607396 != nil:
    section.add "X-Amz-Algorithm", valid_607396
  var valid_607397 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607397 = validateParameter(valid_607397, JString, required = false,
                                 default = nil)
  if valid_607397 != nil:
    section.add "X-Amz-SignedHeaders", valid_607397
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607399: Call_UpdateThing_607387; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the data for a thing.
  ## 
  let valid = call_607399.validator(path, query, header, formData, body)
  let scheme = call_607399.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607399.url(scheme.get, call_607399.host, call_607399.base,
                         call_607399.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607399, url, valid)

proc call*(call_607400: Call_UpdateThing_607387; thingName: string; body: JsonNode): Recallable =
  ## updateThing
  ## Updates the data for a thing.
  ##   thingName: string (required)
  ##            : The name of the thing to update.
  ##   body: JObject (required)
  var path_607401 = newJObject()
  var body_607402 = newJObject()
  add(path_607401, "thingName", newJString(thingName))
  if body != nil:
    body_607402 = body
  result = call_607400.call(path_607401, nil, nil, nil, body_607402)

var updateThing* = Call_UpdateThing_607387(name: "updateThing",
                                        meth: HttpMethod.HttpPatch,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_UpdateThing_607388,
                                        base: "/", url: url_UpdateThing_607389,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThing_607371 = ref object of OpenApiRestCall_605589
proc url_DeleteThing_607373(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteThing_607372(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_607374 = path.getOrDefault("thingName")
  valid_607374 = validateParameter(valid_607374, JString, required = true,
                                 default = nil)
  if valid_607374 != nil:
    section.add "thingName", valid_607374
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.
  section = newJObject()
  var valid_607375 = query.getOrDefault("expectedVersion")
  valid_607375 = validateParameter(valid_607375, JInt, required = false, default = nil)
  if valid_607375 != nil:
    section.add "expectedVersion", valid_607375
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607376 = header.getOrDefault("X-Amz-Signature")
  valid_607376 = validateParameter(valid_607376, JString, required = false,
                                 default = nil)
  if valid_607376 != nil:
    section.add "X-Amz-Signature", valid_607376
  var valid_607377 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607377 = validateParameter(valid_607377, JString, required = false,
                                 default = nil)
  if valid_607377 != nil:
    section.add "X-Amz-Content-Sha256", valid_607377
  var valid_607378 = header.getOrDefault("X-Amz-Date")
  valid_607378 = validateParameter(valid_607378, JString, required = false,
                                 default = nil)
  if valid_607378 != nil:
    section.add "X-Amz-Date", valid_607378
  var valid_607379 = header.getOrDefault("X-Amz-Credential")
  valid_607379 = validateParameter(valid_607379, JString, required = false,
                                 default = nil)
  if valid_607379 != nil:
    section.add "X-Amz-Credential", valid_607379
  var valid_607380 = header.getOrDefault("X-Amz-Security-Token")
  valid_607380 = validateParameter(valid_607380, JString, required = false,
                                 default = nil)
  if valid_607380 != nil:
    section.add "X-Amz-Security-Token", valid_607380
  var valid_607381 = header.getOrDefault("X-Amz-Algorithm")
  valid_607381 = validateParameter(valid_607381, JString, required = false,
                                 default = nil)
  if valid_607381 != nil:
    section.add "X-Amz-Algorithm", valid_607381
  var valid_607382 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607382 = validateParameter(valid_607382, JString, required = false,
                                 default = nil)
  if valid_607382 != nil:
    section.add "X-Amz-SignedHeaders", valid_607382
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607383: Call_DeleteThing_607371; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ## 
  let valid = call_607383.validator(path, query, header, formData, body)
  let scheme = call_607383.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607383.url(scheme.get, call_607383.host, call_607383.base,
                         call_607383.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607383, url, valid)

proc call*(call_607384: Call_DeleteThing_607371; thingName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteThing
  ## Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.
  ##   expectedVersion: int
  ##                  : The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.
  ##   thingName: string (required)
  ##            : The name of the thing to delete.
  var path_607385 = newJObject()
  var query_607386 = newJObject()
  add(query_607386, "expectedVersion", newJInt(expectedVersion))
  add(path_607385, "thingName", newJString(thingName))
  result = call_607384.call(path_607385, query_607386, nil, nil, nil)

var deleteThing* = Call_DeleteThing_607371(name: "deleteThing",
                                        meth: HttpMethod.HttpDelete,
                                        host: "iot.amazonaws.com",
                                        route: "/things/{thingName}",
                                        validator: validate_DeleteThing_607372,
                                        base: "/", url: url_DeleteThing_607373,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThingGroup_607417 = ref object of OpenApiRestCall_605589
proc url_CreateThingGroup_607419(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateThingGroup_607418(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group name to create.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_607420 = path.getOrDefault("thingGroupName")
  valid_607420 = validateParameter(valid_607420, JString, required = true,
                                 default = nil)
  if valid_607420 != nil:
    section.add "thingGroupName", valid_607420
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607421 = header.getOrDefault("X-Amz-Signature")
  valid_607421 = validateParameter(valid_607421, JString, required = false,
                                 default = nil)
  if valid_607421 != nil:
    section.add "X-Amz-Signature", valid_607421
  var valid_607422 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607422 = validateParameter(valid_607422, JString, required = false,
                                 default = nil)
  if valid_607422 != nil:
    section.add "X-Amz-Content-Sha256", valid_607422
  var valid_607423 = header.getOrDefault("X-Amz-Date")
  valid_607423 = validateParameter(valid_607423, JString, required = false,
                                 default = nil)
  if valid_607423 != nil:
    section.add "X-Amz-Date", valid_607423
  var valid_607424 = header.getOrDefault("X-Amz-Credential")
  valid_607424 = validateParameter(valid_607424, JString, required = false,
                                 default = nil)
  if valid_607424 != nil:
    section.add "X-Amz-Credential", valid_607424
  var valid_607425 = header.getOrDefault("X-Amz-Security-Token")
  valid_607425 = validateParameter(valid_607425, JString, required = false,
                                 default = nil)
  if valid_607425 != nil:
    section.add "X-Amz-Security-Token", valid_607425
  var valid_607426 = header.getOrDefault("X-Amz-Algorithm")
  valid_607426 = validateParameter(valid_607426, JString, required = false,
                                 default = nil)
  if valid_607426 != nil:
    section.add "X-Amz-Algorithm", valid_607426
  var valid_607427 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607427 = validateParameter(valid_607427, JString, required = false,
                                 default = nil)
  if valid_607427 != nil:
    section.add "X-Amz-SignedHeaders", valid_607427
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607429: Call_CreateThingGroup_607417; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ## 
  let valid = call_607429.validator(path, query, header, formData, body)
  let scheme = call_607429.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607429.url(scheme.get, call_607429.host, call_607429.base,
                         call_607429.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607429, url, valid)

proc call*(call_607430: Call_CreateThingGroup_607417; thingGroupName: string;
          body: JsonNode): Recallable =
  ## createThingGroup
  ## <p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note>
  ##   thingGroupName: string (required)
  ##                 : The thing group name to create.
  ##   body: JObject (required)
  var path_607431 = newJObject()
  var body_607432 = newJObject()
  add(path_607431, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_607432 = body
  result = call_607430.call(path_607431, nil, nil, nil, body_607432)

var createThingGroup* = Call_CreateThingGroup_607417(name: "createThingGroup",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_CreateThingGroup_607418,
    base: "/", url: url_CreateThingGroup_607419,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingGroup_607403 = ref object of OpenApiRestCall_605589
proc url_DescribeThingGroup_607405(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThingGroup_607404(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Describe a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the thing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_607406 = path.getOrDefault("thingGroupName")
  valid_607406 = validateParameter(valid_607406, JString, required = true,
                                 default = nil)
  if valid_607406 != nil:
    section.add "thingGroupName", valid_607406
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607407 = header.getOrDefault("X-Amz-Signature")
  valid_607407 = validateParameter(valid_607407, JString, required = false,
                                 default = nil)
  if valid_607407 != nil:
    section.add "X-Amz-Signature", valid_607407
  var valid_607408 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607408 = validateParameter(valid_607408, JString, required = false,
                                 default = nil)
  if valid_607408 != nil:
    section.add "X-Amz-Content-Sha256", valid_607408
  var valid_607409 = header.getOrDefault("X-Amz-Date")
  valid_607409 = validateParameter(valid_607409, JString, required = false,
                                 default = nil)
  if valid_607409 != nil:
    section.add "X-Amz-Date", valid_607409
  var valid_607410 = header.getOrDefault("X-Amz-Credential")
  valid_607410 = validateParameter(valid_607410, JString, required = false,
                                 default = nil)
  if valid_607410 != nil:
    section.add "X-Amz-Credential", valid_607410
  var valid_607411 = header.getOrDefault("X-Amz-Security-Token")
  valid_607411 = validateParameter(valid_607411, JString, required = false,
                                 default = nil)
  if valid_607411 != nil:
    section.add "X-Amz-Security-Token", valid_607411
  var valid_607412 = header.getOrDefault("X-Amz-Algorithm")
  valid_607412 = validateParameter(valid_607412, JString, required = false,
                                 default = nil)
  if valid_607412 != nil:
    section.add "X-Amz-Algorithm", valid_607412
  var valid_607413 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607413 = validateParameter(valid_607413, JString, required = false,
                                 default = nil)
  if valid_607413 != nil:
    section.add "X-Amz-SignedHeaders", valid_607413
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607414: Call_DescribeThingGroup_607403; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describe a thing group.
  ## 
  let valid = call_607414.validator(path, query, header, formData, body)
  let scheme = call_607414.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607414.url(scheme.get, call_607414.host, call_607414.base,
                         call_607414.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607414, url, valid)

proc call*(call_607415: Call_DescribeThingGroup_607403; thingGroupName: string): Recallable =
  ## describeThingGroup
  ## Describe a thing group.
  ##   thingGroupName: string (required)
  ##                 : The name of the thing group.
  var path_607416 = newJObject()
  add(path_607416, "thingGroupName", newJString(thingGroupName))
  result = call_607415.call(path_607416, nil, nil, nil, nil)

var describeThingGroup* = Call_DescribeThingGroup_607403(
    name: "describeThingGroup", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}",
    validator: validate_DescribeThingGroup_607404, base: "/",
    url: url_DescribeThingGroup_607405, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThingGroup_607449 = ref object of OpenApiRestCall_605589
proc url_UpdateThingGroup_607451(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateThingGroup_607450(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Update a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group to update.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_607452 = path.getOrDefault("thingGroupName")
  valid_607452 = validateParameter(valid_607452, JString, required = true,
                                 default = nil)
  if valid_607452 != nil:
    section.add "thingGroupName", valid_607452
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607453 = header.getOrDefault("X-Amz-Signature")
  valid_607453 = validateParameter(valid_607453, JString, required = false,
                                 default = nil)
  if valid_607453 != nil:
    section.add "X-Amz-Signature", valid_607453
  var valid_607454 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607454 = validateParameter(valid_607454, JString, required = false,
                                 default = nil)
  if valid_607454 != nil:
    section.add "X-Amz-Content-Sha256", valid_607454
  var valid_607455 = header.getOrDefault("X-Amz-Date")
  valid_607455 = validateParameter(valid_607455, JString, required = false,
                                 default = nil)
  if valid_607455 != nil:
    section.add "X-Amz-Date", valid_607455
  var valid_607456 = header.getOrDefault("X-Amz-Credential")
  valid_607456 = validateParameter(valid_607456, JString, required = false,
                                 default = nil)
  if valid_607456 != nil:
    section.add "X-Amz-Credential", valid_607456
  var valid_607457 = header.getOrDefault("X-Amz-Security-Token")
  valid_607457 = validateParameter(valid_607457, JString, required = false,
                                 default = nil)
  if valid_607457 != nil:
    section.add "X-Amz-Security-Token", valid_607457
  var valid_607458 = header.getOrDefault("X-Amz-Algorithm")
  valid_607458 = validateParameter(valid_607458, JString, required = false,
                                 default = nil)
  if valid_607458 != nil:
    section.add "X-Amz-Algorithm", valid_607458
  var valid_607459 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607459 = validateParameter(valid_607459, JString, required = false,
                                 default = nil)
  if valid_607459 != nil:
    section.add "X-Amz-SignedHeaders", valid_607459
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607461: Call_UpdateThingGroup_607449; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update a thing group.
  ## 
  let valid = call_607461.validator(path, query, header, formData, body)
  let scheme = call_607461.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607461.url(scheme.get, call_607461.host, call_607461.base,
                         call_607461.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607461, url, valid)

proc call*(call_607462: Call_UpdateThingGroup_607449; thingGroupName: string;
          body: JsonNode): Recallable =
  ## updateThingGroup
  ## Update a thing group.
  ##   thingGroupName: string (required)
  ##                 : The thing group to update.
  ##   body: JObject (required)
  var path_607463 = newJObject()
  var body_607464 = newJObject()
  add(path_607463, "thingGroupName", newJString(thingGroupName))
  if body != nil:
    body_607464 = body
  result = call_607462.call(path_607463, nil, nil, nil, body_607464)

var updateThingGroup* = Call_UpdateThingGroup_607449(name: "updateThingGroup",
    meth: HttpMethod.HttpPatch, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_UpdateThingGroup_607450,
    base: "/", url: url_UpdateThingGroup_607451,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThingGroup_607433 = ref object of OpenApiRestCall_605589
proc url_DeleteThingGroup_607435(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteThingGroup_607434(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Deletes a thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The name of the thing group to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_607436 = path.getOrDefault("thingGroupName")
  valid_607436 = validateParameter(valid_607436, JString, required = true,
                                 default = nil)
  if valid_607436 != nil:
    section.add "thingGroupName", valid_607436
  result.add "path", section
  ## parameters in `query` object:
  ##   expectedVersion: JInt
  ##                  : The expected version of the thing group to delete.
  section = newJObject()
  var valid_607437 = query.getOrDefault("expectedVersion")
  valid_607437 = validateParameter(valid_607437, JInt, required = false, default = nil)
  if valid_607437 != nil:
    section.add "expectedVersion", valid_607437
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607438 = header.getOrDefault("X-Amz-Signature")
  valid_607438 = validateParameter(valid_607438, JString, required = false,
                                 default = nil)
  if valid_607438 != nil:
    section.add "X-Amz-Signature", valid_607438
  var valid_607439 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607439 = validateParameter(valid_607439, JString, required = false,
                                 default = nil)
  if valid_607439 != nil:
    section.add "X-Amz-Content-Sha256", valid_607439
  var valid_607440 = header.getOrDefault("X-Amz-Date")
  valid_607440 = validateParameter(valid_607440, JString, required = false,
                                 default = nil)
  if valid_607440 != nil:
    section.add "X-Amz-Date", valid_607440
  var valid_607441 = header.getOrDefault("X-Amz-Credential")
  valid_607441 = validateParameter(valid_607441, JString, required = false,
                                 default = nil)
  if valid_607441 != nil:
    section.add "X-Amz-Credential", valid_607441
  var valid_607442 = header.getOrDefault("X-Amz-Security-Token")
  valid_607442 = validateParameter(valid_607442, JString, required = false,
                                 default = nil)
  if valid_607442 != nil:
    section.add "X-Amz-Security-Token", valid_607442
  var valid_607443 = header.getOrDefault("X-Amz-Algorithm")
  valid_607443 = validateParameter(valid_607443, JString, required = false,
                                 default = nil)
  if valid_607443 != nil:
    section.add "X-Amz-Algorithm", valid_607443
  var valid_607444 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607444 = validateParameter(valid_607444, JString, required = false,
                                 default = nil)
  if valid_607444 != nil:
    section.add "X-Amz-SignedHeaders", valid_607444
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607445: Call_DeleteThingGroup_607433; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a thing group.
  ## 
  let valid = call_607445.validator(path, query, header, formData, body)
  let scheme = call_607445.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607445.url(scheme.get, call_607445.host, call_607445.base,
                         call_607445.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607445, url, valid)

proc call*(call_607446: Call_DeleteThingGroup_607433; thingGroupName: string;
          expectedVersion: int = 0): Recallable =
  ## deleteThingGroup
  ## Deletes a thing group.
  ##   expectedVersion: int
  ##                  : The expected version of the thing group to delete.
  ##   thingGroupName: string (required)
  ##                 : The name of the thing group to delete.
  var path_607447 = newJObject()
  var query_607448 = newJObject()
  add(query_607448, "expectedVersion", newJInt(expectedVersion))
  add(path_607447, "thingGroupName", newJString(thingGroupName))
  result = call_607446.call(path_607447, query_607448, nil, nil, nil)

var deleteThingGroup* = Call_DeleteThingGroup_607433(name: "deleteThingGroup",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/thing-groups/{thingGroupName}", validator: validate_DeleteThingGroup_607434,
    base: "/", url: url_DeleteThingGroup_607435,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateThingType_607479 = ref object of OpenApiRestCall_605589
proc url_CreateThingType_607481(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateThingType_607480(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a new thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_607482 = path.getOrDefault("thingTypeName")
  valid_607482 = validateParameter(valid_607482, JString, required = true,
                                 default = nil)
  if valid_607482 != nil:
    section.add "thingTypeName", valid_607482
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607483 = header.getOrDefault("X-Amz-Signature")
  valid_607483 = validateParameter(valid_607483, JString, required = false,
                                 default = nil)
  if valid_607483 != nil:
    section.add "X-Amz-Signature", valid_607483
  var valid_607484 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607484 = validateParameter(valid_607484, JString, required = false,
                                 default = nil)
  if valid_607484 != nil:
    section.add "X-Amz-Content-Sha256", valid_607484
  var valid_607485 = header.getOrDefault("X-Amz-Date")
  valid_607485 = validateParameter(valid_607485, JString, required = false,
                                 default = nil)
  if valid_607485 != nil:
    section.add "X-Amz-Date", valid_607485
  var valid_607486 = header.getOrDefault("X-Amz-Credential")
  valid_607486 = validateParameter(valid_607486, JString, required = false,
                                 default = nil)
  if valid_607486 != nil:
    section.add "X-Amz-Credential", valid_607486
  var valid_607487 = header.getOrDefault("X-Amz-Security-Token")
  valid_607487 = validateParameter(valid_607487, JString, required = false,
                                 default = nil)
  if valid_607487 != nil:
    section.add "X-Amz-Security-Token", valid_607487
  var valid_607488 = header.getOrDefault("X-Amz-Algorithm")
  valid_607488 = validateParameter(valid_607488, JString, required = false,
                                 default = nil)
  if valid_607488 != nil:
    section.add "X-Amz-Algorithm", valid_607488
  var valid_607489 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607489 = validateParameter(valid_607489, JString, required = false,
                                 default = nil)
  if valid_607489 != nil:
    section.add "X-Amz-SignedHeaders", valid_607489
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607491: Call_CreateThingType_607479; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new thing type.
  ## 
  let valid = call_607491.validator(path, query, header, formData, body)
  let scheme = call_607491.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607491.url(scheme.get, call_607491.host, call_607491.base,
                         call_607491.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607491, url, valid)

proc call*(call_607492: Call_CreateThingType_607479; thingTypeName: string;
          body: JsonNode): Recallable =
  ## createThingType
  ## Creates a new thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  ##   body: JObject (required)
  var path_607493 = newJObject()
  var body_607494 = newJObject()
  add(path_607493, "thingTypeName", newJString(thingTypeName))
  if body != nil:
    body_607494 = body
  result = call_607492.call(path_607493, nil, nil, nil, body_607494)

var createThingType* = Call_CreateThingType_607479(name: "createThingType",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_CreateThingType_607480,
    base: "/", url: url_CreateThingType_607481, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingType_607465 = ref object of OpenApiRestCall_605589
proc url_DescribeThingType_607467(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThingType_607466(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Gets information about the specified thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_607468 = path.getOrDefault("thingTypeName")
  valid_607468 = validateParameter(valid_607468, JString, required = true,
                                 default = nil)
  if valid_607468 != nil:
    section.add "thingTypeName", valid_607468
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607469 = header.getOrDefault("X-Amz-Signature")
  valid_607469 = validateParameter(valid_607469, JString, required = false,
                                 default = nil)
  if valid_607469 != nil:
    section.add "X-Amz-Signature", valid_607469
  var valid_607470 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607470 = validateParameter(valid_607470, JString, required = false,
                                 default = nil)
  if valid_607470 != nil:
    section.add "X-Amz-Content-Sha256", valid_607470
  var valid_607471 = header.getOrDefault("X-Amz-Date")
  valid_607471 = validateParameter(valid_607471, JString, required = false,
                                 default = nil)
  if valid_607471 != nil:
    section.add "X-Amz-Date", valid_607471
  var valid_607472 = header.getOrDefault("X-Amz-Credential")
  valid_607472 = validateParameter(valid_607472, JString, required = false,
                                 default = nil)
  if valid_607472 != nil:
    section.add "X-Amz-Credential", valid_607472
  var valid_607473 = header.getOrDefault("X-Amz-Security-Token")
  valid_607473 = validateParameter(valid_607473, JString, required = false,
                                 default = nil)
  if valid_607473 != nil:
    section.add "X-Amz-Security-Token", valid_607473
  var valid_607474 = header.getOrDefault("X-Amz-Algorithm")
  valid_607474 = validateParameter(valid_607474, JString, required = false,
                                 default = nil)
  if valid_607474 != nil:
    section.add "X-Amz-Algorithm", valid_607474
  var valid_607475 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607475 = validateParameter(valid_607475, JString, required = false,
                                 default = nil)
  if valid_607475 != nil:
    section.add "X-Amz-SignedHeaders", valid_607475
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607476: Call_DescribeThingType_607465; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified thing type.
  ## 
  let valid = call_607476.validator(path, query, header, formData, body)
  let scheme = call_607476.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607476.url(scheme.get, call_607476.host, call_607476.base,
                         call_607476.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607476, url, valid)

proc call*(call_607477: Call_DescribeThingType_607465; thingTypeName: string): Recallable =
  ## describeThingType
  ## Gets information about the specified thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_607478 = newJObject()
  add(path_607478, "thingTypeName", newJString(thingTypeName))
  result = call_607477.call(path_607478, nil, nil, nil, nil)

var describeThingType* = Call_DescribeThingType_607465(name: "describeThingType",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_DescribeThingType_607466,
    base: "/", url: url_DescribeThingType_607467,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteThingType_607495 = ref object of OpenApiRestCall_605589
proc url_DeleteThingType_607497(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteThingType_607496(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_607498 = path.getOrDefault("thingTypeName")
  valid_607498 = validateParameter(valid_607498, JString, required = true,
                                 default = nil)
  if valid_607498 != nil:
    section.add "thingTypeName", valid_607498
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607499 = header.getOrDefault("X-Amz-Signature")
  valid_607499 = validateParameter(valid_607499, JString, required = false,
                                 default = nil)
  if valid_607499 != nil:
    section.add "X-Amz-Signature", valid_607499
  var valid_607500 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607500 = validateParameter(valid_607500, JString, required = false,
                                 default = nil)
  if valid_607500 != nil:
    section.add "X-Amz-Content-Sha256", valid_607500
  var valid_607501 = header.getOrDefault("X-Amz-Date")
  valid_607501 = validateParameter(valid_607501, JString, required = false,
                                 default = nil)
  if valid_607501 != nil:
    section.add "X-Amz-Date", valid_607501
  var valid_607502 = header.getOrDefault("X-Amz-Credential")
  valid_607502 = validateParameter(valid_607502, JString, required = false,
                                 default = nil)
  if valid_607502 != nil:
    section.add "X-Amz-Credential", valid_607502
  var valid_607503 = header.getOrDefault("X-Amz-Security-Token")
  valid_607503 = validateParameter(valid_607503, JString, required = false,
                                 default = nil)
  if valid_607503 != nil:
    section.add "X-Amz-Security-Token", valid_607503
  var valid_607504 = header.getOrDefault("X-Amz-Algorithm")
  valid_607504 = validateParameter(valid_607504, JString, required = false,
                                 default = nil)
  if valid_607504 != nil:
    section.add "X-Amz-Algorithm", valid_607504
  var valid_607505 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607505 = validateParameter(valid_607505, JString, required = false,
                                 default = nil)
  if valid_607505 != nil:
    section.add "X-Amz-SignedHeaders", valid_607505
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607506: Call_DeleteThingType_607495; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ## 
  let valid = call_607506.validator(path, query, header, formData, body)
  let scheme = call_607506.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607506.url(scheme.get, call_607506.host, call_607506.base,
                         call_607506.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607506, url, valid)

proc call*(call_607507: Call_DeleteThingType_607495; thingTypeName: string): Recallable =
  ## deleteThingType
  ## Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type.
  var path_607508 = newJObject()
  add(path_607508, "thingTypeName", newJString(thingTypeName))
  result = call_607507.call(path_607508, nil, nil, nil, nil)

var deleteThingType* = Call_DeleteThingType_607495(name: "deleteThingType",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/thing-types/{thingTypeName}", validator: validate_DeleteThingType_607496,
    base: "/", url: url_DeleteThingType_607497, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateTopicRule_607523 = ref object of OpenApiRestCall_605589
proc url_CreateTopicRule_607525(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_CreateTopicRule_607524(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_607526 = path.getOrDefault("ruleName")
  valid_607526 = validateParameter(valid_607526, JString, required = true,
                                 default = nil)
  if valid_607526 != nil:
    section.add "ruleName", valid_607526
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   x-amz-tagging: JString
  ##                : <p>Metadata which can be used to manage the topic rule.</p> <note> <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p> <p>For the CLI command-line parameter use format: --tags "key1=value1&amp;key2=value2..."</p> <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p> </note>
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607527 = header.getOrDefault("x-amz-tagging")
  valid_607527 = validateParameter(valid_607527, JString, required = false,
                                 default = nil)
  if valid_607527 != nil:
    section.add "x-amz-tagging", valid_607527
  var valid_607528 = header.getOrDefault("X-Amz-Signature")
  valid_607528 = validateParameter(valid_607528, JString, required = false,
                                 default = nil)
  if valid_607528 != nil:
    section.add "X-Amz-Signature", valid_607528
  var valid_607529 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607529 = validateParameter(valid_607529, JString, required = false,
                                 default = nil)
  if valid_607529 != nil:
    section.add "X-Amz-Content-Sha256", valid_607529
  var valid_607530 = header.getOrDefault("X-Amz-Date")
  valid_607530 = validateParameter(valid_607530, JString, required = false,
                                 default = nil)
  if valid_607530 != nil:
    section.add "X-Amz-Date", valid_607530
  var valid_607531 = header.getOrDefault("X-Amz-Credential")
  valid_607531 = validateParameter(valid_607531, JString, required = false,
                                 default = nil)
  if valid_607531 != nil:
    section.add "X-Amz-Credential", valid_607531
  var valid_607532 = header.getOrDefault("X-Amz-Security-Token")
  valid_607532 = validateParameter(valid_607532, JString, required = false,
                                 default = nil)
  if valid_607532 != nil:
    section.add "X-Amz-Security-Token", valid_607532
  var valid_607533 = header.getOrDefault("X-Amz-Algorithm")
  valid_607533 = validateParameter(valid_607533, JString, required = false,
                                 default = nil)
  if valid_607533 != nil:
    section.add "X-Amz-Algorithm", valid_607533
  var valid_607534 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607534 = validateParameter(valid_607534, JString, required = false,
                                 default = nil)
  if valid_607534 != nil:
    section.add "X-Amz-SignedHeaders", valid_607534
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607536: Call_CreateTopicRule_607523; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  let valid = call_607536.validator(path, query, header, formData, body)
  let scheme = call_607536.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607536.url(scheme.get, call_607536.host, call_607536.base,
                         call_607536.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607536, url, valid)

proc call*(call_607537: Call_CreateTopicRule_607523; ruleName: string; body: JsonNode): Recallable =
  ## createTopicRule
  ## Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  ##   body: JObject (required)
  var path_607538 = newJObject()
  var body_607539 = newJObject()
  add(path_607538, "ruleName", newJString(ruleName))
  if body != nil:
    body_607539 = body
  result = call_607537.call(path_607538, nil, nil, nil, body_607539)

var createTopicRule* = Call_CreateTopicRule_607523(name: "createTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_CreateTopicRule_607524,
    base: "/", url: url_CreateTopicRule_607525, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetTopicRule_607509 = ref object of OpenApiRestCall_605589
proc url_GetTopicRule_607511(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTopicRule_607510(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_607512 = path.getOrDefault("ruleName")
  valid_607512 = validateParameter(valid_607512, JString, required = true,
                                 default = nil)
  if valid_607512 != nil:
    section.add "ruleName", valid_607512
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607513 = header.getOrDefault("X-Amz-Signature")
  valid_607513 = validateParameter(valid_607513, JString, required = false,
                                 default = nil)
  if valid_607513 != nil:
    section.add "X-Amz-Signature", valid_607513
  var valid_607514 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607514 = validateParameter(valid_607514, JString, required = false,
                                 default = nil)
  if valid_607514 != nil:
    section.add "X-Amz-Content-Sha256", valid_607514
  var valid_607515 = header.getOrDefault("X-Amz-Date")
  valid_607515 = validateParameter(valid_607515, JString, required = false,
                                 default = nil)
  if valid_607515 != nil:
    section.add "X-Amz-Date", valid_607515
  var valid_607516 = header.getOrDefault("X-Amz-Credential")
  valid_607516 = validateParameter(valid_607516, JString, required = false,
                                 default = nil)
  if valid_607516 != nil:
    section.add "X-Amz-Credential", valid_607516
  var valid_607517 = header.getOrDefault("X-Amz-Security-Token")
  valid_607517 = validateParameter(valid_607517, JString, required = false,
                                 default = nil)
  if valid_607517 != nil:
    section.add "X-Amz-Security-Token", valid_607517
  var valid_607518 = header.getOrDefault("X-Amz-Algorithm")
  valid_607518 = validateParameter(valid_607518, JString, required = false,
                                 default = nil)
  if valid_607518 != nil:
    section.add "X-Amz-Algorithm", valid_607518
  var valid_607519 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607519 = validateParameter(valid_607519, JString, required = false,
                                 default = nil)
  if valid_607519 != nil:
    section.add "X-Amz-SignedHeaders", valid_607519
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607520: Call_GetTopicRule_607509; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the rule.
  ## 
  let valid = call_607520.validator(path, query, header, formData, body)
  let scheme = call_607520.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607520.url(scheme.get, call_607520.host, call_607520.base,
                         call_607520.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607520, url, valid)

proc call*(call_607521: Call_GetTopicRule_607509; ruleName: string): Recallable =
  ## getTopicRule
  ## Gets information about the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  var path_607522 = newJObject()
  add(path_607522, "ruleName", newJString(ruleName))
  result = call_607521.call(path_607522, nil, nil, nil, nil)

var getTopicRule* = Call_GetTopicRule_607509(name: "getTopicRule",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/rules/{ruleName}",
    validator: validate_GetTopicRule_607510, base: "/", url: url_GetTopicRule_607511,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReplaceTopicRule_607554 = ref object of OpenApiRestCall_605589
proc url_ReplaceTopicRule_607556(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ReplaceTopicRule_607555(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_607557 = path.getOrDefault("ruleName")
  valid_607557 = validateParameter(valid_607557, JString, required = true,
                                 default = nil)
  if valid_607557 != nil:
    section.add "ruleName", valid_607557
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607558 = header.getOrDefault("X-Amz-Signature")
  valid_607558 = validateParameter(valid_607558, JString, required = false,
                                 default = nil)
  if valid_607558 != nil:
    section.add "X-Amz-Signature", valid_607558
  var valid_607559 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607559 = validateParameter(valid_607559, JString, required = false,
                                 default = nil)
  if valid_607559 != nil:
    section.add "X-Amz-Content-Sha256", valid_607559
  var valid_607560 = header.getOrDefault("X-Amz-Date")
  valid_607560 = validateParameter(valid_607560, JString, required = false,
                                 default = nil)
  if valid_607560 != nil:
    section.add "X-Amz-Date", valid_607560
  var valid_607561 = header.getOrDefault("X-Amz-Credential")
  valid_607561 = validateParameter(valid_607561, JString, required = false,
                                 default = nil)
  if valid_607561 != nil:
    section.add "X-Amz-Credential", valid_607561
  var valid_607562 = header.getOrDefault("X-Amz-Security-Token")
  valid_607562 = validateParameter(valid_607562, JString, required = false,
                                 default = nil)
  if valid_607562 != nil:
    section.add "X-Amz-Security-Token", valid_607562
  var valid_607563 = header.getOrDefault("X-Amz-Algorithm")
  valid_607563 = validateParameter(valid_607563, JString, required = false,
                                 default = nil)
  if valid_607563 != nil:
    section.add "X-Amz-Algorithm", valid_607563
  var valid_607564 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607564 = validateParameter(valid_607564, JString, required = false,
                                 default = nil)
  if valid_607564 != nil:
    section.add "X-Amz-SignedHeaders", valid_607564
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607566: Call_ReplaceTopicRule_607554; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ## 
  let valid = call_607566.validator(path, query, header, formData, body)
  let scheme = call_607566.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607566.url(scheme.get, call_607566.host, call_607566.base,
                         call_607566.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607566, url, valid)

proc call*(call_607567: Call_ReplaceTopicRule_607554; ruleName: string;
          body: JsonNode): Recallable =
  ## replaceTopicRule
  ## Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  ##   body: JObject (required)
  var path_607568 = newJObject()
  var body_607569 = newJObject()
  add(path_607568, "ruleName", newJString(ruleName))
  if body != nil:
    body_607569 = body
  result = call_607567.call(path_607568, nil, nil, nil, body_607569)

var replaceTopicRule* = Call_ReplaceTopicRule_607554(name: "replaceTopicRule",
    meth: HttpMethod.HttpPatch, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_ReplaceTopicRule_607555,
    base: "/", url: url_ReplaceTopicRule_607556,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteTopicRule_607540 = ref object of OpenApiRestCall_605589
proc url_DeleteTopicRule_607542(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTopicRule_607541(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Deletes the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_607543 = path.getOrDefault("ruleName")
  valid_607543 = validateParameter(valid_607543, JString, required = true,
                                 default = nil)
  if valid_607543 != nil:
    section.add "ruleName", valid_607543
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607544 = header.getOrDefault("X-Amz-Signature")
  valid_607544 = validateParameter(valid_607544, JString, required = false,
                                 default = nil)
  if valid_607544 != nil:
    section.add "X-Amz-Signature", valid_607544
  var valid_607545 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607545 = validateParameter(valid_607545, JString, required = false,
                                 default = nil)
  if valid_607545 != nil:
    section.add "X-Amz-Content-Sha256", valid_607545
  var valid_607546 = header.getOrDefault("X-Amz-Date")
  valid_607546 = validateParameter(valid_607546, JString, required = false,
                                 default = nil)
  if valid_607546 != nil:
    section.add "X-Amz-Date", valid_607546
  var valid_607547 = header.getOrDefault("X-Amz-Credential")
  valid_607547 = validateParameter(valid_607547, JString, required = false,
                                 default = nil)
  if valid_607547 != nil:
    section.add "X-Amz-Credential", valid_607547
  var valid_607548 = header.getOrDefault("X-Amz-Security-Token")
  valid_607548 = validateParameter(valid_607548, JString, required = false,
                                 default = nil)
  if valid_607548 != nil:
    section.add "X-Amz-Security-Token", valid_607548
  var valid_607549 = header.getOrDefault("X-Amz-Algorithm")
  valid_607549 = validateParameter(valid_607549, JString, required = false,
                                 default = nil)
  if valid_607549 != nil:
    section.add "X-Amz-Algorithm", valid_607549
  var valid_607550 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607550 = validateParameter(valid_607550, JString, required = false,
                                 default = nil)
  if valid_607550 != nil:
    section.add "X-Amz-SignedHeaders", valid_607550
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607551: Call_DeleteTopicRule_607540; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the rule.
  ## 
  let valid = call_607551.validator(path, query, header, formData, body)
  let scheme = call_607551.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607551.url(scheme.get, call_607551.host, call_607551.base,
                         call_607551.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607551, url, valid)

proc call*(call_607552: Call_DeleteTopicRule_607540; ruleName: string): Recallable =
  ## deleteTopicRule
  ## Deletes the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule.
  var path_607553 = newJObject()
  add(path_607553, "ruleName", newJString(ruleName))
  result = call_607552.call(path_607553, nil, nil, nil, nil)

var deleteTopicRule* = Call_DeleteTopicRule_607540(name: "deleteTopicRule",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}", validator: validate_DeleteTopicRule_607541,
    base: "/", url: url_DeleteTopicRule_607542, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateTopicRuleDestination_607585 = ref object of OpenApiRestCall_605589
proc url_CreateTopicRuleDestination_607587(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_CreateTopicRuleDestination_607586(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a topic rule destination. The destination must be confirmed prior to use.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607588 = header.getOrDefault("X-Amz-Signature")
  valid_607588 = validateParameter(valid_607588, JString, required = false,
                                 default = nil)
  if valid_607588 != nil:
    section.add "X-Amz-Signature", valid_607588
  var valid_607589 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607589 = validateParameter(valid_607589, JString, required = false,
                                 default = nil)
  if valid_607589 != nil:
    section.add "X-Amz-Content-Sha256", valid_607589
  var valid_607590 = header.getOrDefault("X-Amz-Date")
  valid_607590 = validateParameter(valid_607590, JString, required = false,
                                 default = nil)
  if valid_607590 != nil:
    section.add "X-Amz-Date", valid_607590
  var valid_607591 = header.getOrDefault("X-Amz-Credential")
  valid_607591 = validateParameter(valid_607591, JString, required = false,
                                 default = nil)
  if valid_607591 != nil:
    section.add "X-Amz-Credential", valid_607591
  var valid_607592 = header.getOrDefault("X-Amz-Security-Token")
  valid_607592 = validateParameter(valid_607592, JString, required = false,
                                 default = nil)
  if valid_607592 != nil:
    section.add "X-Amz-Security-Token", valid_607592
  var valid_607593 = header.getOrDefault("X-Amz-Algorithm")
  valid_607593 = validateParameter(valid_607593, JString, required = false,
                                 default = nil)
  if valid_607593 != nil:
    section.add "X-Amz-Algorithm", valid_607593
  var valid_607594 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607594 = validateParameter(valid_607594, JString, required = false,
                                 default = nil)
  if valid_607594 != nil:
    section.add "X-Amz-SignedHeaders", valid_607594
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607596: Call_CreateTopicRuleDestination_607585; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a topic rule destination. The destination must be confirmed prior to use.
  ## 
  let valid = call_607596.validator(path, query, header, formData, body)
  let scheme = call_607596.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607596.url(scheme.get, call_607596.host, call_607596.base,
                         call_607596.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607596, url, valid)

proc call*(call_607597: Call_CreateTopicRuleDestination_607585; body: JsonNode): Recallable =
  ## createTopicRuleDestination
  ## Creates a topic rule destination. The destination must be confirmed prior to use.
  ##   body: JObject (required)
  var body_607598 = newJObject()
  if body != nil:
    body_607598 = body
  result = call_607597.call(nil, nil, nil, nil, body_607598)

var createTopicRuleDestination* = Call_CreateTopicRuleDestination_607585(
    name: "createTopicRuleDestination", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/destinations",
    validator: validate_CreateTopicRuleDestination_607586, base: "/",
    url: url_CreateTopicRuleDestination_607587,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTopicRuleDestinations_607570 = ref object of OpenApiRestCall_605589
proc url_ListTopicRuleDestinations_607572(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListTopicRuleDestinations_607571(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all the topic rule destinations in your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_607573 = query.getOrDefault("nextToken")
  valid_607573 = validateParameter(valid_607573, JString, required = false,
                                 default = nil)
  if valid_607573 != nil:
    section.add "nextToken", valid_607573
  var valid_607574 = query.getOrDefault("maxResults")
  valid_607574 = validateParameter(valid_607574, JInt, required = false, default = nil)
  if valid_607574 != nil:
    section.add "maxResults", valid_607574
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607575 = header.getOrDefault("X-Amz-Signature")
  valid_607575 = validateParameter(valid_607575, JString, required = false,
                                 default = nil)
  if valid_607575 != nil:
    section.add "X-Amz-Signature", valid_607575
  var valid_607576 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607576 = validateParameter(valid_607576, JString, required = false,
                                 default = nil)
  if valid_607576 != nil:
    section.add "X-Amz-Content-Sha256", valid_607576
  var valid_607577 = header.getOrDefault("X-Amz-Date")
  valid_607577 = validateParameter(valid_607577, JString, required = false,
                                 default = nil)
  if valid_607577 != nil:
    section.add "X-Amz-Date", valid_607577
  var valid_607578 = header.getOrDefault("X-Amz-Credential")
  valid_607578 = validateParameter(valid_607578, JString, required = false,
                                 default = nil)
  if valid_607578 != nil:
    section.add "X-Amz-Credential", valid_607578
  var valid_607579 = header.getOrDefault("X-Amz-Security-Token")
  valid_607579 = validateParameter(valid_607579, JString, required = false,
                                 default = nil)
  if valid_607579 != nil:
    section.add "X-Amz-Security-Token", valid_607579
  var valid_607580 = header.getOrDefault("X-Amz-Algorithm")
  valid_607580 = validateParameter(valid_607580, JString, required = false,
                                 default = nil)
  if valid_607580 != nil:
    section.add "X-Amz-Algorithm", valid_607580
  var valid_607581 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607581 = validateParameter(valid_607581, JString, required = false,
                                 default = nil)
  if valid_607581 != nil:
    section.add "X-Amz-SignedHeaders", valid_607581
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607582: Call_ListTopicRuleDestinations_607570; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all the topic rule destinations in your AWS account.
  ## 
  let valid = call_607582.validator(path, query, header, formData, body)
  let scheme = call_607582.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607582.url(scheme.get, call_607582.host, call_607582.base,
                         call_607582.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607582, url, valid)

proc call*(call_607583: Call_ListTopicRuleDestinations_607570;
          nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listTopicRuleDestinations
  ## Lists all the topic rule destinations in your AWS account.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_607584 = newJObject()
  add(query_607584, "nextToken", newJString(nextToken))
  add(query_607584, "maxResults", newJInt(maxResults))
  result = call_607583.call(nil, query_607584, nil, nil, nil)

var listTopicRuleDestinations* = Call_ListTopicRuleDestinations_607570(
    name: "listTopicRuleDestinations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/destinations",
    validator: validate_ListTopicRuleDestinations_607571, base: "/",
    url: url_ListTopicRuleDestinations_607572,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateTopicRuleDestination_607599 = ref object of OpenApiRestCall_605589
proc url_UpdateTopicRuleDestination_607601(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateTopicRuleDestination_607600(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a topic rule destination. You use this to change the status, endpoint URL, or confirmation URL of the destination.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607602 = header.getOrDefault("X-Amz-Signature")
  valid_607602 = validateParameter(valid_607602, JString, required = false,
                                 default = nil)
  if valid_607602 != nil:
    section.add "X-Amz-Signature", valid_607602
  var valid_607603 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607603 = validateParameter(valid_607603, JString, required = false,
                                 default = nil)
  if valid_607603 != nil:
    section.add "X-Amz-Content-Sha256", valid_607603
  var valid_607604 = header.getOrDefault("X-Amz-Date")
  valid_607604 = validateParameter(valid_607604, JString, required = false,
                                 default = nil)
  if valid_607604 != nil:
    section.add "X-Amz-Date", valid_607604
  var valid_607605 = header.getOrDefault("X-Amz-Credential")
  valid_607605 = validateParameter(valid_607605, JString, required = false,
                                 default = nil)
  if valid_607605 != nil:
    section.add "X-Amz-Credential", valid_607605
  var valid_607606 = header.getOrDefault("X-Amz-Security-Token")
  valid_607606 = validateParameter(valid_607606, JString, required = false,
                                 default = nil)
  if valid_607606 != nil:
    section.add "X-Amz-Security-Token", valid_607606
  var valid_607607 = header.getOrDefault("X-Amz-Algorithm")
  valid_607607 = validateParameter(valid_607607, JString, required = false,
                                 default = nil)
  if valid_607607 != nil:
    section.add "X-Amz-Algorithm", valid_607607
  var valid_607608 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607608 = validateParameter(valid_607608, JString, required = false,
                                 default = nil)
  if valid_607608 != nil:
    section.add "X-Amz-SignedHeaders", valid_607608
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607610: Call_UpdateTopicRuleDestination_607599; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a topic rule destination. You use this to change the status, endpoint URL, or confirmation URL of the destination.
  ## 
  let valid = call_607610.validator(path, query, header, formData, body)
  let scheme = call_607610.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607610.url(scheme.get, call_607610.host, call_607610.base,
                         call_607610.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607610, url, valid)

proc call*(call_607611: Call_UpdateTopicRuleDestination_607599; body: JsonNode): Recallable =
  ## updateTopicRuleDestination
  ## Updates a topic rule destination. You use this to change the status, endpoint URL, or confirmation URL of the destination.
  ##   body: JObject (required)
  var body_607612 = newJObject()
  if body != nil:
    body_607612 = body
  result = call_607611.call(nil, nil, nil, nil, body_607612)

var updateTopicRuleDestination* = Call_UpdateTopicRuleDestination_607599(
    name: "updateTopicRuleDestination", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/destinations",
    validator: validate_UpdateTopicRuleDestination_607600, base: "/",
    url: url_UpdateTopicRuleDestination_607601,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAccountAuditConfiguration_607613 = ref object of OpenApiRestCall_605589
proc url_DescribeAccountAuditConfiguration_607615(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeAccountAuditConfiguration_607614(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607616 = header.getOrDefault("X-Amz-Signature")
  valid_607616 = validateParameter(valid_607616, JString, required = false,
                                 default = nil)
  if valid_607616 != nil:
    section.add "X-Amz-Signature", valid_607616
  var valid_607617 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607617 = validateParameter(valid_607617, JString, required = false,
                                 default = nil)
  if valid_607617 != nil:
    section.add "X-Amz-Content-Sha256", valid_607617
  var valid_607618 = header.getOrDefault("X-Amz-Date")
  valid_607618 = validateParameter(valid_607618, JString, required = false,
                                 default = nil)
  if valid_607618 != nil:
    section.add "X-Amz-Date", valid_607618
  var valid_607619 = header.getOrDefault("X-Amz-Credential")
  valid_607619 = validateParameter(valid_607619, JString, required = false,
                                 default = nil)
  if valid_607619 != nil:
    section.add "X-Amz-Credential", valid_607619
  var valid_607620 = header.getOrDefault("X-Amz-Security-Token")
  valid_607620 = validateParameter(valid_607620, JString, required = false,
                                 default = nil)
  if valid_607620 != nil:
    section.add "X-Amz-Security-Token", valid_607620
  var valid_607621 = header.getOrDefault("X-Amz-Algorithm")
  valid_607621 = validateParameter(valid_607621, JString, required = false,
                                 default = nil)
  if valid_607621 != nil:
    section.add "X-Amz-Algorithm", valid_607621
  var valid_607622 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607622 = validateParameter(valid_607622, JString, required = false,
                                 default = nil)
  if valid_607622 != nil:
    section.add "X-Amz-SignedHeaders", valid_607622
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607623: Call_DescribeAccountAuditConfiguration_607613;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  let valid = call_607623.validator(path, query, header, formData, body)
  let scheme = call_607623.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607623.url(scheme.get, call_607623.host, call_607623.base,
                         call_607623.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607623, url, valid)

proc call*(call_607624: Call_DescribeAccountAuditConfiguration_607613): Recallable =
  ## describeAccountAuditConfiguration
  ## Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  result = call_607624.call(nil, nil, nil, nil, nil)

var describeAccountAuditConfiguration* = Call_DescribeAccountAuditConfiguration_607613(
    name: "describeAccountAuditConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_DescribeAccountAuditConfiguration_607614, base: "/",
    url: url_DescribeAccountAuditConfiguration_607615,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateAccountAuditConfiguration_607639 = ref object of OpenApiRestCall_605589
proc url_UpdateAccountAuditConfiguration_607641(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateAccountAuditConfiguration_607640(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607642 = header.getOrDefault("X-Amz-Signature")
  valid_607642 = validateParameter(valid_607642, JString, required = false,
                                 default = nil)
  if valid_607642 != nil:
    section.add "X-Amz-Signature", valid_607642
  var valid_607643 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607643 = validateParameter(valid_607643, JString, required = false,
                                 default = nil)
  if valid_607643 != nil:
    section.add "X-Amz-Content-Sha256", valid_607643
  var valid_607644 = header.getOrDefault("X-Amz-Date")
  valid_607644 = validateParameter(valid_607644, JString, required = false,
                                 default = nil)
  if valid_607644 != nil:
    section.add "X-Amz-Date", valid_607644
  var valid_607645 = header.getOrDefault("X-Amz-Credential")
  valid_607645 = validateParameter(valid_607645, JString, required = false,
                                 default = nil)
  if valid_607645 != nil:
    section.add "X-Amz-Credential", valid_607645
  var valid_607646 = header.getOrDefault("X-Amz-Security-Token")
  valid_607646 = validateParameter(valid_607646, JString, required = false,
                                 default = nil)
  if valid_607646 != nil:
    section.add "X-Amz-Security-Token", valid_607646
  var valid_607647 = header.getOrDefault("X-Amz-Algorithm")
  valid_607647 = validateParameter(valid_607647, JString, required = false,
                                 default = nil)
  if valid_607647 != nil:
    section.add "X-Amz-Algorithm", valid_607647
  var valid_607648 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607648 = validateParameter(valid_607648, JString, required = false,
                                 default = nil)
  if valid_607648 != nil:
    section.add "X-Amz-SignedHeaders", valid_607648
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607650: Call_UpdateAccountAuditConfiguration_607639;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ## 
  let valid = call_607650.validator(path, query, header, formData, body)
  let scheme = call_607650.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607650.url(scheme.get, call_607650.host, call_607650.base,
                         call_607650.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607650, url, valid)

proc call*(call_607651: Call_UpdateAccountAuditConfiguration_607639; body: JsonNode): Recallable =
  ## updateAccountAuditConfiguration
  ## Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.
  ##   body: JObject (required)
  var body_607652 = newJObject()
  if body != nil:
    body_607652 = body
  result = call_607651.call(nil, nil, nil, nil, body_607652)

var updateAccountAuditConfiguration* = Call_UpdateAccountAuditConfiguration_607639(
    name: "updateAccountAuditConfiguration", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_UpdateAccountAuditConfiguration_607640, base: "/",
    url: url_UpdateAccountAuditConfiguration_607641,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteAccountAuditConfiguration_607625 = ref object of OpenApiRestCall_605589
proc url_DeleteAccountAuditConfiguration_607627(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteAccountAuditConfiguration_607626(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   deleteScheduledAudits: JBool
  ##                        : If true, all scheduled audits are deleted.
  section = newJObject()
  var valid_607628 = query.getOrDefault("deleteScheduledAudits")
  valid_607628 = validateParameter(valid_607628, JBool, required = false, default = nil)
  if valid_607628 != nil:
    section.add "deleteScheduledAudits", valid_607628
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607629 = header.getOrDefault("X-Amz-Signature")
  valid_607629 = validateParameter(valid_607629, JString, required = false,
                                 default = nil)
  if valid_607629 != nil:
    section.add "X-Amz-Signature", valid_607629
  var valid_607630 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607630 = validateParameter(valid_607630, JString, required = false,
                                 default = nil)
  if valid_607630 != nil:
    section.add "X-Amz-Content-Sha256", valid_607630
  var valid_607631 = header.getOrDefault("X-Amz-Date")
  valid_607631 = validateParameter(valid_607631, JString, required = false,
                                 default = nil)
  if valid_607631 != nil:
    section.add "X-Amz-Date", valid_607631
  var valid_607632 = header.getOrDefault("X-Amz-Credential")
  valid_607632 = validateParameter(valid_607632, JString, required = false,
                                 default = nil)
  if valid_607632 != nil:
    section.add "X-Amz-Credential", valid_607632
  var valid_607633 = header.getOrDefault("X-Amz-Security-Token")
  valid_607633 = validateParameter(valid_607633, JString, required = false,
                                 default = nil)
  if valid_607633 != nil:
    section.add "X-Amz-Security-Token", valid_607633
  var valid_607634 = header.getOrDefault("X-Amz-Algorithm")
  valid_607634 = validateParameter(valid_607634, JString, required = false,
                                 default = nil)
  if valid_607634 != nil:
    section.add "X-Amz-Algorithm", valid_607634
  var valid_607635 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607635 = validateParameter(valid_607635, JString, required = false,
                                 default = nil)
  if valid_607635 != nil:
    section.add "X-Amz-SignedHeaders", valid_607635
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607636: Call_DeleteAccountAuditConfiguration_607625;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ## 
  let valid = call_607636.validator(path, query, header, formData, body)
  let scheme = call_607636.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607636.url(scheme.get, call_607636.host, call_607636.base,
                         call_607636.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607636, url, valid)

proc call*(call_607637: Call_DeleteAccountAuditConfiguration_607625;
          deleteScheduledAudits: bool = false): Recallable =
  ## deleteAccountAuditConfiguration
  ## Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. 
  ##   deleteScheduledAudits: bool
  ##                        : If true, all scheduled audits are deleted.
  var query_607638 = newJObject()
  add(query_607638, "deleteScheduledAudits", newJBool(deleteScheduledAudits))
  result = call_607637.call(nil, query_607638, nil, nil, nil)

var deleteAccountAuditConfiguration* = Call_DeleteAccountAuditConfiguration_607625(
    name: "deleteAccountAuditConfiguration", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/audit/configuration",
    validator: validate_DeleteAccountAuditConfiguration_607626, base: "/",
    url: url_DeleteAccountAuditConfiguration_607627,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateCACertificate_607667 = ref object of OpenApiRestCall_605589
proc url_UpdateCACertificate_607669(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateCACertificate_607668(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Updates a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The CA certificate identifier.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_607670 = path.getOrDefault("caCertificateId")
  valid_607670 = validateParameter(valid_607670, JString, required = true,
                                 default = nil)
  if valid_607670 != nil:
    section.add "caCertificateId", valid_607670
  result.add "path", section
  ## parameters in `query` object:
  ##   newAutoRegistrationStatus: JString
  ##                            : The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
  ##   newStatus: JString
  ##            : <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  section = newJObject()
  var valid_607684 = query.getOrDefault("newAutoRegistrationStatus")
  valid_607684 = validateParameter(valid_607684, JString, required = false,
                                 default = newJString("ENABLE"))
  if valid_607684 != nil:
    section.add "newAutoRegistrationStatus", valid_607684
  var valid_607685 = query.getOrDefault("newStatus")
  valid_607685 = validateParameter(valid_607685, JString, required = false,
                                 default = newJString("ACTIVE"))
  if valid_607685 != nil:
    section.add "newStatus", valid_607685
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607686 = header.getOrDefault("X-Amz-Signature")
  valid_607686 = validateParameter(valid_607686, JString, required = false,
                                 default = nil)
  if valid_607686 != nil:
    section.add "X-Amz-Signature", valid_607686
  var valid_607687 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607687 = validateParameter(valid_607687, JString, required = false,
                                 default = nil)
  if valid_607687 != nil:
    section.add "X-Amz-Content-Sha256", valid_607687
  var valid_607688 = header.getOrDefault("X-Amz-Date")
  valid_607688 = validateParameter(valid_607688, JString, required = false,
                                 default = nil)
  if valid_607688 != nil:
    section.add "X-Amz-Date", valid_607688
  var valid_607689 = header.getOrDefault("X-Amz-Credential")
  valid_607689 = validateParameter(valid_607689, JString, required = false,
                                 default = nil)
  if valid_607689 != nil:
    section.add "X-Amz-Credential", valid_607689
  var valid_607690 = header.getOrDefault("X-Amz-Security-Token")
  valid_607690 = validateParameter(valid_607690, JString, required = false,
                                 default = nil)
  if valid_607690 != nil:
    section.add "X-Amz-Security-Token", valid_607690
  var valid_607691 = header.getOrDefault("X-Amz-Algorithm")
  valid_607691 = validateParameter(valid_607691, JString, required = false,
                                 default = nil)
  if valid_607691 != nil:
    section.add "X-Amz-Algorithm", valid_607691
  var valid_607692 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607692 = validateParameter(valid_607692, JString, required = false,
                                 default = nil)
  if valid_607692 != nil:
    section.add "X-Amz-SignedHeaders", valid_607692
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607694: Call_UpdateCACertificate_607667; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a registered CA certificate.
  ## 
  let valid = call_607694.validator(path, query, header, formData, body)
  let scheme = call_607694.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607694.url(scheme.get, call_607694.host, call_607694.base,
                         call_607694.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607694, url, valid)

proc call*(call_607695: Call_UpdateCACertificate_607667; caCertificateId: string;
          body: JsonNode; newAutoRegistrationStatus: string = "ENABLE";
          newStatus: string = "ACTIVE"): Recallable =
  ## updateCACertificate
  ## Updates a registered CA certificate.
  ##   newAutoRegistrationStatus: string
  ##                            : The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
  ##   caCertificateId: string (required)
  ##                  : The CA certificate identifier.
  ##   newStatus: string
  ##            : <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  ##   body: JObject (required)
  var path_607696 = newJObject()
  var query_607697 = newJObject()
  var body_607698 = newJObject()
  add(query_607697, "newAutoRegistrationStatus",
      newJString(newAutoRegistrationStatus))
  add(path_607696, "caCertificateId", newJString(caCertificateId))
  add(query_607697, "newStatus", newJString(newStatus))
  if body != nil:
    body_607698 = body
  result = call_607695.call(path_607696, query_607697, nil, nil, body_607698)

var updateCACertificate* = Call_UpdateCACertificate_607667(
    name: "updateCACertificate", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_UpdateCACertificate_607668, base: "/",
    url: url_UpdateCACertificate_607669, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeCACertificate_607653 = ref object of OpenApiRestCall_605589
proc url_DescribeCACertificate_607655(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeCACertificate_607654(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The CA certificate identifier.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_607656 = path.getOrDefault("caCertificateId")
  valid_607656 = validateParameter(valid_607656, JString, required = true,
                                 default = nil)
  if valid_607656 != nil:
    section.add "caCertificateId", valid_607656
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607657 = header.getOrDefault("X-Amz-Signature")
  valid_607657 = validateParameter(valid_607657, JString, required = false,
                                 default = nil)
  if valid_607657 != nil:
    section.add "X-Amz-Signature", valid_607657
  var valid_607658 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607658 = validateParameter(valid_607658, JString, required = false,
                                 default = nil)
  if valid_607658 != nil:
    section.add "X-Amz-Content-Sha256", valid_607658
  var valid_607659 = header.getOrDefault("X-Amz-Date")
  valid_607659 = validateParameter(valid_607659, JString, required = false,
                                 default = nil)
  if valid_607659 != nil:
    section.add "X-Amz-Date", valid_607659
  var valid_607660 = header.getOrDefault("X-Amz-Credential")
  valid_607660 = validateParameter(valid_607660, JString, required = false,
                                 default = nil)
  if valid_607660 != nil:
    section.add "X-Amz-Credential", valid_607660
  var valid_607661 = header.getOrDefault("X-Amz-Security-Token")
  valid_607661 = validateParameter(valid_607661, JString, required = false,
                                 default = nil)
  if valid_607661 != nil:
    section.add "X-Amz-Security-Token", valid_607661
  var valid_607662 = header.getOrDefault("X-Amz-Algorithm")
  valid_607662 = validateParameter(valid_607662, JString, required = false,
                                 default = nil)
  if valid_607662 != nil:
    section.add "X-Amz-Algorithm", valid_607662
  var valid_607663 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607663 = validateParameter(valid_607663, JString, required = false,
                                 default = nil)
  if valid_607663 != nil:
    section.add "X-Amz-SignedHeaders", valid_607663
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607664: Call_DescribeCACertificate_607653; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a registered CA certificate.
  ## 
  let valid = call_607664.validator(path, query, header, formData, body)
  let scheme = call_607664.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607664.url(scheme.get, call_607664.host, call_607664.base,
                         call_607664.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607664, url, valid)

proc call*(call_607665: Call_DescribeCACertificate_607653; caCertificateId: string): Recallable =
  ## describeCACertificate
  ## Describes a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The CA certificate identifier.
  var path_607666 = newJObject()
  add(path_607666, "caCertificateId", newJString(caCertificateId))
  result = call_607665.call(path_607666, nil, nil, nil, nil)

var describeCACertificate* = Call_DescribeCACertificate_607653(
    name: "describeCACertificate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_DescribeCACertificate_607654, base: "/",
    url: url_DescribeCACertificate_607655, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteCACertificate_607699 = ref object of OpenApiRestCall_605589
proc url_DeleteCACertificate_607701(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/cacertificate/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteCACertificate_607700(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Deletes a registered CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_607702 = path.getOrDefault("caCertificateId")
  valid_607702 = validateParameter(valid_607702, JString, required = true,
                                 default = nil)
  if valid_607702 != nil:
    section.add "caCertificateId", valid_607702
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607703 = header.getOrDefault("X-Amz-Signature")
  valid_607703 = validateParameter(valid_607703, JString, required = false,
                                 default = nil)
  if valid_607703 != nil:
    section.add "X-Amz-Signature", valid_607703
  var valid_607704 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607704 = validateParameter(valid_607704, JString, required = false,
                                 default = nil)
  if valid_607704 != nil:
    section.add "X-Amz-Content-Sha256", valid_607704
  var valid_607705 = header.getOrDefault("X-Amz-Date")
  valid_607705 = validateParameter(valid_607705, JString, required = false,
                                 default = nil)
  if valid_607705 != nil:
    section.add "X-Amz-Date", valid_607705
  var valid_607706 = header.getOrDefault("X-Amz-Credential")
  valid_607706 = validateParameter(valid_607706, JString, required = false,
                                 default = nil)
  if valid_607706 != nil:
    section.add "X-Amz-Credential", valid_607706
  var valid_607707 = header.getOrDefault("X-Amz-Security-Token")
  valid_607707 = validateParameter(valid_607707, JString, required = false,
                                 default = nil)
  if valid_607707 != nil:
    section.add "X-Amz-Security-Token", valid_607707
  var valid_607708 = header.getOrDefault("X-Amz-Algorithm")
  valid_607708 = validateParameter(valid_607708, JString, required = false,
                                 default = nil)
  if valid_607708 != nil:
    section.add "X-Amz-Algorithm", valid_607708
  var valid_607709 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607709 = validateParameter(valid_607709, JString, required = false,
                                 default = nil)
  if valid_607709 != nil:
    section.add "X-Amz-SignedHeaders", valid_607709
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607710: Call_DeleteCACertificate_607699; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a registered CA certificate.
  ## 
  let valid = call_607710.validator(path, query, header, formData, body)
  let scheme = call_607710.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607710.url(scheme.get, call_607710.host, call_607710.base,
                         call_607710.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607710, url, valid)

proc call*(call_607711: Call_DeleteCACertificate_607699; caCertificateId: string): Recallable =
  ## deleteCACertificate
  ## Deletes a registered CA certificate.
  ##   caCertificateId: string (required)
  ##                  : The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
  var path_607712 = newJObject()
  add(path_607712, "caCertificateId", newJString(caCertificateId))
  result = call_607711.call(path_607712, nil, nil, nil, nil)

var deleteCACertificate* = Call_DeleteCACertificate_607699(
    name: "deleteCACertificate", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/cacertificate/{caCertificateId}",
    validator: validate_DeleteCACertificate_607700, base: "/",
    url: url_DeleteCACertificate_607701, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeCertificate_607713 = ref object of OpenApiRestCall_605589
proc url_DescribeCertificate_607715(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeCertificate_607714(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets information about the specified certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_607716 = path.getOrDefault("certificateId")
  valid_607716 = validateParameter(valid_607716, JString, required = true,
                                 default = nil)
  if valid_607716 != nil:
    section.add "certificateId", valid_607716
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607717 = header.getOrDefault("X-Amz-Signature")
  valid_607717 = validateParameter(valid_607717, JString, required = false,
                                 default = nil)
  if valid_607717 != nil:
    section.add "X-Amz-Signature", valid_607717
  var valid_607718 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607718 = validateParameter(valid_607718, JString, required = false,
                                 default = nil)
  if valid_607718 != nil:
    section.add "X-Amz-Content-Sha256", valid_607718
  var valid_607719 = header.getOrDefault("X-Amz-Date")
  valid_607719 = validateParameter(valid_607719, JString, required = false,
                                 default = nil)
  if valid_607719 != nil:
    section.add "X-Amz-Date", valid_607719
  var valid_607720 = header.getOrDefault("X-Amz-Credential")
  valid_607720 = validateParameter(valid_607720, JString, required = false,
                                 default = nil)
  if valid_607720 != nil:
    section.add "X-Amz-Credential", valid_607720
  var valid_607721 = header.getOrDefault("X-Amz-Security-Token")
  valid_607721 = validateParameter(valid_607721, JString, required = false,
                                 default = nil)
  if valid_607721 != nil:
    section.add "X-Amz-Security-Token", valid_607721
  var valid_607722 = header.getOrDefault("X-Amz-Algorithm")
  valid_607722 = validateParameter(valid_607722, JString, required = false,
                                 default = nil)
  if valid_607722 != nil:
    section.add "X-Amz-Algorithm", valid_607722
  var valid_607723 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607723 = validateParameter(valid_607723, JString, required = false,
                                 default = nil)
  if valid_607723 != nil:
    section.add "X-Amz-SignedHeaders", valid_607723
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607724: Call_DescribeCertificate_607713; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified certificate.
  ## 
  let valid = call_607724.validator(path, query, header, formData, body)
  let scheme = call_607724.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607724.url(scheme.get, call_607724.host, call_607724.base,
                         call_607724.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607724, url, valid)

proc call*(call_607725: Call_DescribeCertificate_607713; certificateId: string): Recallable =
  ## describeCertificate
  ## Gets information about the specified certificate.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_607726 = newJObject()
  add(path_607726, "certificateId", newJString(certificateId))
  result = call_607725.call(path_607726, nil, nil, nil, nil)

var describeCertificate* = Call_DescribeCertificate_607713(
    name: "describeCertificate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates/{certificateId}",
    validator: validate_DescribeCertificate_607714, base: "/",
    url: url_DescribeCertificate_607715, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteCertificate_607727 = ref object of OpenApiRestCall_605589
proc url_DeleteCertificate_607729(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteCertificate_607728(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_607730 = path.getOrDefault("certificateId")
  valid_607730 = validateParameter(valid_607730, JString, required = true,
                                 default = nil)
  if valid_607730 != nil:
    section.add "certificateId", valid_607730
  result.add "path", section
  ## parameters in `query` object:
  ##   forceDelete: JBool
  ##              : Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
  section = newJObject()
  var valid_607731 = query.getOrDefault("forceDelete")
  valid_607731 = validateParameter(valid_607731, JBool, required = false, default = nil)
  if valid_607731 != nil:
    section.add "forceDelete", valid_607731
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607732 = header.getOrDefault("X-Amz-Signature")
  valid_607732 = validateParameter(valid_607732, JString, required = false,
                                 default = nil)
  if valid_607732 != nil:
    section.add "X-Amz-Signature", valid_607732
  var valid_607733 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607733 = validateParameter(valid_607733, JString, required = false,
                                 default = nil)
  if valid_607733 != nil:
    section.add "X-Amz-Content-Sha256", valid_607733
  var valid_607734 = header.getOrDefault("X-Amz-Date")
  valid_607734 = validateParameter(valid_607734, JString, required = false,
                                 default = nil)
  if valid_607734 != nil:
    section.add "X-Amz-Date", valid_607734
  var valid_607735 = header.getOrDefault("X-Amz-Credential")
  valid_607735 = validateParameter(valid_607735, JString, required = false,
                                 default = nil)
  if valid_607735 != nil:
    section.add "X-Amz-Credential", valid_607735
  var valid_607736 = header.getOrDefault("X-Amz-Security-Token")
  valid_607736 = validateParameter(valid_607736, JString, required = false,
                                 default = nil)
  if valid_607736 != nil:
    section.add "X-Amz-Security-Token", valid_607736
  var valid_607737 = header.getOrDefault("X-Amz-Algorithm")
  valid_607737 = validateParameter(valid_607737, JString, required = false,
                                 default = nil)
  if valid_607737 != nil:
    section.add "X-Amz-Algorithm", valid_607737
  var valid_607738 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607738 = validateParameter(valid_607738, JString, required = false,
                                 default = nil)
  if valid_607738 != nil:
    section.add "X-Amz-SignedHeaders", valid_607738
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607739: Call_DeleteCertificate_607727; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ## 
  let valid = call_607739.validator(path, query, header, formData, body)
  let scheme = call_607739.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607739.url(scheme.get, call_607739.host, call_607739.base,
                         call_607739.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607739, url, valid)

proc call*(call_607740: Call_DeleteCertificate_607727; certificateId: string;
          forceDelete: bool = false): Recallable =
  ## deleteCertificate
  ## <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
  ##   forceDelete: bool
  ##              : Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_607741 = newJObject()
  var query_607742 = newJObject()
  add(query_607742, "forceDelete", newJBool(forceDelete))
  add(path_607741, "certificateId", newJString(certificateId))
  result = call_607740.call(path_607741, query_607742, nil, nil, nil)

var deleteCertificate* = Call_DeleteCertificate_607727(name: "deleteCertificate",
    meth: HttpMethod.HttpDelete, host: "iot.amazonaws.com",
    route: "/certificates/{certificateId}", validator: validate_DeleteCertificate_607728,
    base: "/", url: url_DeleteCertificate_607729,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteJobExecution_607743 = ref object of OpenApiRestCall_605589
proc url_DeleteJobExecution_607745(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  assert "executionNumber" in path, "`executionNumber` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/executionNumber/"),
               (kind: VariableSegment, value: "executionNumber")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteJobExecution_607744(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deletes a job execution.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   executionNumber: JInt (required)
  ##                  : <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
  ##   jobId: JString (required)
  ##        : The ID of the job whose execution on a particular device will be deleted.
  ##   thingName: JString (required)
  ##            : The name of the thing whose job execution will be deleted.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `executionNumber` field"
  var valid_607746 = path.getOrDefault("executionNumber")
  valid_607746 = validateParameter(valid_607746, JInt, required = true, default = nil)
  if valid_607746 != nil:
    section.add "executionNumber", valid_607746
  var valid_607747 = path.getOrDefault("jobId")
  valid_607747 = validateParameter(valid_607747, JString, required = true,
                                 default = nil)
  if valid_607747 != nil:
    section.add "jobId", valid_607747
  var valid_607748 = path.getOrDefault("thingName")
  valid_607748 = validateParameter(valid_607748, JString, required = true,
                                 default = nil)
  if valid_607748 != nil:
    section.add "thingName", valid_607748
  result.add "path", section
  ## parameters in `query` object:
  ##   force: JBool
  ##        : <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
  section = newJObject()
  var valid_607749 = query.getOrDefault("force")
  valid_607749 = validateParameter(valid_607749, JBool, required = false, default = nil)
  if valid_607749 != nil:
    section.add "force", valid_607749
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607750 = header.getOrDefault("X-Amz-Signature")
  valid_607750 = validateParameter(valid_607750, JString, required = false,
                                 default = nil)
  if valid_607750 != nil:
    section.add "X-Amz-Signature", valid_607750
  var valid_607751 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607751 = validateParameter(valid_607751, JString, required = false,
                                 default = nil)
  if valid_607751 != nil:
    section.add "X-Amz-Content-Sha256", valid_607751
  var valid_607752 = header.getOrDefault("X-Amz-Date")
  valid_607752 = validateParameter(valid_607752, JString, required = false,
                                 default = nil)
  if valid_607752 != nil:
    section.add "X-Amz-Date", valid_607752
  var valid_607753 = header.getOrDefault("X-Amz-Credential")
  valid_607753 = validateParameter(valid_607753, JString, required = false,
                                 default = nil)
  if valid_607753 != nil:
    section.add "X-Amz-Credential", valid_607753
  var valid_607754 = header.getOrDefault("X-Amz-Security-Token")
  valid_607754 = validateParameter(valid_607754, JString, required = false,
                                 default = nil)
  if valid_607754 != nil:
    section.add "X-Amz-Security-Token", valid_607754
  var valid_607755 = header.getOrDefault("X-Amz-Algorithm")
  valid_607755 = validateParameter(valid_607755, JString, required = false,
                                 default = nil)
  if valid_607755 != nil:
    section.add "X-Amz-Algorithm", valid_607755
  var valid_607756 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607756 = validateParameter(valid_607756, JString, required = false,
                                 default = nil)
  if valid_607756 != nil:
    section.add "X-Amz-SignedHeaders", valid_607756
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607757: Call_DeleteJobExecution_607743; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a job execution.
  ## 
  let valid = call_607757.validator(path, query, header, formData, body)
  let scheme = call_607757.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607757.url(scheme.get, call_607757.host, call_607757.base,
                         call_607757.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607757, url, valid)

proc call*(call_607758: Call_DeleteJobExecution_607743; executionNumber: int;
          jobId: string; thingName: string; force: bool = false): Recallable =
  ## deleteJobExecution
  ## Deletes a job execution.
  ##   executionNumber: int (required)
  ##                  : <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
  ##   jobId: string (required)
  ##        : The ID of the job whose execution on a particular device will be deleted.
  ##   thingName: string (required)
  ##            : The name of the thing whose job execution will be deleted.
  ##   force: bool
  ##        : <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
  var path_607759 = newJObject()
  var query_607760 = newJObject()
  add(path_607759, "executionNumber", newJInt(executionNumber))
  add(path_607759, "jobId", newJString(jobId))
  add(path_607759, "thingName", newJString(thingName))
  add(query_607760, "force", newJBool(force))
  result = call_607758.call(path_607759, query_607760, nil, nil, nil)

var deleteJobExecution* = Call_DeleteJobExecution_607743(
    name: "deleteJobExecution", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}",
    validator: validate_DeleteJobExecution_607744, base: "/",
    url: url_DeleteJobExecution_607745, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPolicyVersion_607761 = ref object of OpenApiRestCall_605589
proc url_GetPolicyVersion_607763(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetPolicyVersion_607762(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets information about the specified policy version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_607764 = path.getOrDefault("policyName")
  valid_607764 = validateParameter(valid_607764, JString, required = true,
                                 default = nil)
  if valid_607764 != nil:
    section.add "policyName", valid_607764
  var valid_607765 = path.getOrDefault("policyVersionId")
  valid_607765 = validateParameter(valid_607765, JString, required = true,
                                 default = nil)
  if valid_607765 != nil:
    section.add "policyVersionId", valid_607765
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607766 = header.getOrDefault("X-Amz-Signature")
  valid_607766 = validateParameter(valid_607766, JString, required = false,
                                 default = nil)
  if valid_607766 != nil:
    section.add "X-Amz-Signature", valid_607766
  var valid_607767 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607767 = validateParameter(valid_607767, JString, required = false,
                                 default = nil)
  if valid_607767 != nil:
    section.add "X-Amz-Content-Sha256", valid_607767
  var valid_607768 = header.getOrDefault("X-Amz-Date")
  valid_607768 = validateParameter(valid_607768, JString, required = false,
                                 default = nil)
  if valid_607768 != nil:
    section.add "X-Amz-Date", valid_607768
  var valid_607769 = header.getOrDefault("X-Amz-Credential")
  valid_607769 = validateParameter(valid_607769, JString, required = false,
                                 default = nil)
  if valid_607769 != nil:
    section.add "X-Amz-Credential", valid_607769
  var valid_607770 = header.getOrDefault("X-Amz-Security-Token")
  valid_607770 = validateParameter(valid_607770, JString, required = false,
                                 default = nil)
  if valid_607770 != nil:
    section.add "X-Amz-Security-Token", valid_607770
  var valid_607771 = header.getOrDefault("X-Amz-Algorithm")
  valid_607771 = validateParameter(valid_607771, JString, required = false,
                                 default = nil)
  if valid_607771 != nil:
    section.add "X-Amz-Algorithm", valid_607771
  var valid_607772 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607772 = validateParameter(valid_607772, JString, required = false,
                                 default = nil)
  if valid_607772 != nil:
    section.add "X-Amz-SignedHeaders", valid_607772
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607773: Call_GetPolicyVersion_607761; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about the specified policy version.
  ## 
  let valid = call_607773.validator(path, query, header, formData, body)
  let scheme = call_607773.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607773.url(scheme.get, call_607773.host, call_607773.base,
                         call_607773.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607773, url, valid)

proc call*(call_607774: Call_GetPolicyVersion_607761; policyName: string;
          policyVersionId: string): Recallable =
  ## getPolicyVersion
  ## Gets information about the specified policy version.
  ##   policyName: string (required)
  ##             : The name of the policy.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_607775 = newJObject()
  add(path_607775, "policyName", newJString(policyName))
  add(path_607775, "policyVersionId", newJString(policyVersionId))
  result = call_607774.call(path_607775, nil, nil, nil, nil)

var getPolicyVersion* = Call_GetPolicyVersion_607761(name: "getPolicyVersion",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_GetPolicyVersion_607762, base: "/",
    url: url_GetPolicyVersion_607763, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetDefaultPolicyVersion_607791 = ref object of OpenApiRestCall_605589
proc url_SetDefaultPolicyVersion_607793(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_SetDefaultPolicyVersion_607792(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_607794 = path.getOrDefault("policyName")
  valid_607794 = validateParameter(valid_607794, JString, required = true,
                                 default = nil)
  if valid_607794 != nil:
    section.add "policyName", valid_607794
  var valid_607795 = path.getOrDefault("policyVersionId")
  valid_607795 = validateParameter(valid_607795, JString, required = true,
                                 default = nil)
  if valid_607795 != nil:
    section.add "policyVersionId", valid_607795
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607796 = header.getOrDefault("X-Amz-Signature")
  valid_607796 = validateParameter(valid_607796, JString, required = false,
                                 default = nil)
  if valid_607796 != nil:
    section.add "X-Amz-Signature", valid_607796
  var valid_607797 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607797 = validateParameter(valid_607797, JString, required = false,
                                 default = nil)
  if valid_607797 != nil:
    section.add "X-Amz-Content-Sha256", valid_607797
  var valid_607798 = header.getOrDefault("X-Amz-Date")
  valid_607798 = validateParameter(valid_607798, JString, required = false,
                                 default = nil)
  if valid_607798 != nil:
    section.add "X-Amz-Date", valid_607798
  var valid_607799 = header.getOrDefault("X-Amz-Credential")
  valid_607799 = validateParameter(valid_607799, JString, required = false,
                                 default = nil)
  if valid_607799 != nil:
    section.add "X-Amz-Credential", valid_607799
  var valid_607800 = header.getOrDefault("X-Amz-Security-Token")
  valid_607800 = validateParameter(valid_607800, JString, required = false,
                                 default = nil)
  if valid_607800 != nil:
    section.add "X-Amz-Security-Token", valid_607800
  var valid_607801 = header.getOrDefault("X-Amz-Algorithm")
  valid_607801 = validateParameter(valid_607801, JString, required = false,
                                 default = nil)
  if valid_607801 != nil:
    section.add "X-Amz-Algorithm", valid_607801
  var valid_607802 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607802 = validateParameter(valid_607802, JString, required = false,
                                 default = nil)
  if valid_607802 != nil:
    section.add "X-Amz-SignedHeaders", valid_607802
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607803: Call_SetDefaultPolicyVersion_607791; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ## 
  let valid = call_607803.validator(path, query, header, formData, body)
  let scheme = call_607803.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607803.url(scheme.get, call_607803.host, call_607803.base,
                         call_607803.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607803, url, valid)

proc call*(call_607804: Call_SetDefaultPolicyVersion_607791; policyName: string;
          policyVersionId: string): Recallable =
  ## setDefaultPolicyVersion
  ## Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.
  ##   policyName: string (required)
  ##             : The policy name.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_607805 = newJObject()
  add(path_607805, "policyName", newJString(policyName))
  add(path_607805, "policyVersionId", newJString(policyVersionId))
  result = call_607804.call(path_607805, nil, nil, nil, nil)

var setDefaultPolicyVersion* = Call_SetDefaultPolicyVersion_607791(
    name: "setDefaultPolicyVersion", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_SetDefaultPolicyVersion_607792, base: "/",
    url: url_SetDefaultPolicyVersion_607793, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeletePolicyVersion_607776 = ref object of OpenApiRestCall_605589
proc url_DeletePolicyVersion_607778(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  assert "policyVersionId" in path, "`policyVersionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policies/"),
               (kind: VariableSegment, value: "policyName"),
               (kind: ConstantSegment, value: "/version/"),
               (kind: VariableSegment, value: "policyVersionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeletePolicyVersion_607777(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The name of the policy.
  ##   policyVersionId: JString (required)
  ##                  : The policy version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_607779 = path.getOrDefault("policyName")
  valid_607779 = validateParameter(valid_607779, JString, required = true,
                                 default = nil)
  if valid_607779 != nil:
    section.add "policyName", valid_607779
  var valid_607780 = path.getOrDefault("policyVersionId")
  valid_607780 = validateParameter(valid_607780, JString, required = true,
                                 default = nil)
  if valid_607780 != nil:
    section.add "policyVersionId", valid_607780
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607781 = header.getOrDefault("X-Amz-Signature")
  valid_607781 = validateParameter(valid_607781, JString, required = false,
                                 default = nil)
  if valid_607781 != nil:
    section.add "X-Amz-Signature", valid_607781
  var valid_607782 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607782 = validateParameter(valid_607782, JString, required = false,
                                 default = nil)
  if valid_607782 != nil:
    section.add "X-Amz-Content-Sha256", valid_607782
  var valid_607783 = header.getOrDefault("X-Amz-Date")
  valid_607783 = validateParameter(valid_607783, JString, required = false,
                                 default = nil)
  if valid_607783 != nil:
    section.add "X-Amz-Date", valid_607783
  var valid_607784 = header.getOrDefault("X-Amz-Credential")
  valid_607784 = validateParameter(valid_607784, JString, required = false,
                                 default = nil)
  if valid_607784 != nil:
    section.add "X-Amz-Credential", valid_607784
  var valid_607785 = header.getOrDefault("X-Amz-Security-Token")
  valid_607785 = validateParameter(valid_607785, JString, required = false,
                                 default = nil)
  if valid_607785 != nil:
    section.add "X-Amz-Security-Token", valid_607785
  var valid_607786 = header.getOrDefault("X-Amz-Algorithm")
  valid_607786 = validateParameter(valid_607786, JString, required = false,
                                 default = nil)
  if valid_607786 != nil:
    section.add "X-Amz-Algorithm", valid_607786
  var valid_607787 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607787 = validateParameter(valid_607787, JString, required = false,
                                 default = nil)
  if valid_607787 != nil:
    section.add "X-Amz-SignedHeaders", valid_607787
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607788: Call_DeletePolicyVersion_607776; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ## 
  let valid = call_607788.validator(path, query, header, formData, body)
  let scheme = call_607788.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607788.url(scheme.get, call_607788.host, call_607788.base,
                         call_607788.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607788, url, valid)

proc call*(call_607789: Call_DeletePolicyVersion_607776; policyName: string;
          policyVersionId: string): Recallable =
  ## deletePolicyVersion
  ## Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.
  ##   policyName: string (required)
  ##             : The name of the policy.
  ##   policyVersionId: string (required)
  ##                  : The policy version ID.
  var path_607790 = newJObject()
  add(path_607790, "policyName", newJString(policyName))
  add(path_607790, "policyVersionId", newJString(policyVersionId))
  result = call_607789.call(path_607790, nil, nil, nil, nil)

var deletePolicyVersion* = Call_DeletePolicyVersion_607776(
    name: "deletePolicyVersion", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/policies/{policyName}/version/{policyVersionId}",
    validator: validate_DeletePolicyVersion_607777, base: "/",
    url: url_DeletePolicyVersion_607778, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeProvisioningTemplate_607806 = ref object of OpenApiRestCall_605589
proc url_DescribeProvisioningTemplate_607808(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeProvisioningTemplate_607807(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_607809 = path.getOrDefault("templateName")
  valid_607809 = validateParameter(valid_607809, JString, required = true,
                                 default = nil)
  if valid_607809 != nil:
    section.add "templateName", valid_607809
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607810 = header.getOrDefault("X-Amz-Signature")
  valid_607810 = validateParameter(valid_607810, JString, required = false,
                                 default = nil)
  if valid_607810 != nil:
    section.add "X-Amz-Signature", valid_607810
  var valid_607811 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607811 = validateParameter(valid_607811, JString, required = false,
                                 default = nil)
  if valid_607811 != nil:
    section.add "X-Amz-Content-Sha256", valid_607811
  var valid_607812 = header.getOrDefault("X-Amz-Date")
  valid_607812 = validateParameter(valid_607812, JString, required = false,
                                 default = nil)
  if valid_607812 != nil:
    section.add "X-Amz-Date", valid_607812
  var valid_607813 = header.getOrDefault("X-Amz-Credential")
  valid_607813 = validateParameter(valid_607813, JString, required = false,
                                 default = nil)
  if valid_607813 != nil:
    section.add "X-Amz-Credential", valid_607813
  var valid_607814 = header.getOrDefault("X-Amz-Security-Token")
  valid_607814 = validateParameter(valid_607814, JString, required = false,
                                 default = nil)
  if valid_607814 != nil:
    section.add "X-Amz-Security-Token", valid_607814
  var valid_607815 = header.getOrDefault("X-Amz-Algorithm")
  valid_607815 = validateParameter(valid_607815, JString, required = false,
                                 default = nil)
  if valid_607815 != nil:
    section.add "X-Amz-Algorithm", valid_607815
  var valid_607816 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607816 = validateParameter(valid_607816, JString, required = false,
                                 default = nil)
  if valid_607816 != nil:
    section.add "X-Amz-SignedHeaders", valid_607816
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607817: Call_DescribeProvisioningTemplate_607806; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about a fleet provisioning template.
  ## 
  let valid = call_607817.validator(path, query, header, formData, body)
  let scheme = call_607817.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607817.url(scheme.get, call_607817.host, call_607817.base,
                         call_607817.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607817, url, valid)

proc call*(call_607818: Call_DescribeProvisioningTemplate_607806;
          templateName: string): Recallable =
  ## describeProvisioningTemplate
  ## Returns information about a fleet provisioning template.
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template.
  var path_607819 = newJObject()
  add(path_607819, "templateName", newJString(templateName))
  result = call_607818.call(path_607819, nil, nil, nil, nil)

var describeProvisioningTemplate* = Call_DescribeProvisioningTemplate_607806(
    name: "describeProvisioningTemplate", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/provisioning-templates/{templateName}",
    validator: validate_DescribeProvisioningTemplate_607807, base: "/",
    url: url_DescribeProvisioningTemplate_607808,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateProvisioningTemplate_607834 = ref object of OpenApiRestCall_605589
proc url_UpdateProvisioningTemplate_607836(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateProvisioningTemplate_607835(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_607837 = path.getOrDefault("templateName")
  valid_607837 = validateParameter(valid_607837, JString, required = true,
                                 default = nil)
  if valid_607837 != nil:
    section.add "templateName", valid_607837
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607838 = header.getOrDefault("X-Amz-Signature")
  valid_607838 = validateParameter(valid_607838, JString, required = false,
                                 default = nil)
  if valid_607838 != nil:
    section.add "X-Amz-Signature", valid_607838
  var valid_607839 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607839 = validateParameter(valid_607839, JString, required = false,
                                 default = nil)
  if valid_607839 != nil:
    section.add "X-Amz-Content-Sha256", valid_607839
  var valid_607840 = header.getOrDefault("X-Amz-Date")
  valid_607840 = validateParameter(valid_607840, JString, required = false,
                                 default = nil)
  if valid_607840 != nil:
    section.add "X-Amz-Date", valid_607840
  var valid_607841 = header.getOrDefault("X-Amz-Credential")
  valid_607841 = validateParameter(valid_607841, JString, required = false,
                                 default = nil)
  if valid_607841 != nil:
    section.add "X-Amz-Credential", valid_607841
  var valid_607842 = header.getOrDefault("X-Amz-Security-Token")
  valid_607842 = validateParameter(valid_607842, JString, required = false,
                                 default = nil)
  if valid_607842 != nil:
    section.add "X-Amz-Security-Token", valid_607842
  var valid_607843 = header.getOrDefault("X-Amz-Algorithm")
  valid_607843 = validateParameter(valid_607843, JString, required = false,
                                 default = nil)
  if valid_607843 != nil:
    section.add "X-Amz-Algorithm", valid_607843
  var valid_607844 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607844 = validateParameter(valid_607844, JString, required = false,
                                 default = nil)
  if valid_607844 != nil:
    section.add "X-Amz-SignedHeaders", valid_607844
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607846: Call_UpdateProvisioningTemplate_607834; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates a fleet provisioning template.
  ## 
  let valid = call_607846.validator(path, query, header, formData, body)
  let scheme = call_607846.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607846.url(scheme.get, call_607846.host, call_607846.base,
                         call_607846.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607846, url, valid)

proc call*(call_607847: Call_UpdateProvisioningTemplate_607834; body: JsonNode;
          templateName: string): Recallable =
  ## updateProvisioningTemplate
  ## Updates a fleet provisioning template.
  ##   body: JObject (required)
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template.
  var path_607848 = newJObject()
  var body_607849 = newJObject()
  if body != nil:
    body_607849 = body
  add(path_607848, "templateName", newJString(templateName))
  result = call_607847.call(path_607848, nil, nil, nil, body_607849)

var updateProvisioningTemplate* = Call_UpdateProvisioningTemplate_607834(
    name: "updateProvisioningTemplate", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/provisioning-templates/{templateName}",
    validator: validate_UpdateProvisioningTemplate_607835, base: "/",
    url: url_UpdateProvisioningTemplate_607836,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteProvisioningTemplate_607820 = ref object of OpenApiRestCall_605589
proc url_DeleteProvisioningTemplate_607822(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteProvisioningTemplate_607821(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a fleet provisioning template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provision template to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_607823 = path.getOrDefault("templateName")
  valid_607823 = validateParameter(valid_607823, JString, required = true,
                                 default = nil)
  if valid_607823 != nil:
    section.add "templateName", valid_607823
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607824 = header.getOrDefault("X-Amz-Signature")
  valid_607824 = validateParameter(valid_607824, JString, required = false,
                                 default = nil)
  if valid_607824 != nil:
    section.add "X-Amz-Signature", valid_607824
  var valid_607825 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607825 = validateParameter(valid_607825, JString, required = false,
                                 default = nil)
  if valid_607825 != nil:
    section.add "X-Amz-Content-Sha256", valid_607825
  var valid_607826 = header.getOrDefault("X-Amz-Date")
  valid_607826 = validateParameter(valid_607826, JString, required = false,
                                 default = nil)
  if valid_607826 != nil:
    section.add "X-Amz-Date", valid_607826
  var valid_607827 = header.getOrDefault("X-Amz-Credential")
  valid_607827 = validateParameter(valid_607827, JString, required = false,
                                 default = nil)
  if valid_607827 != nil:
    section.add "X-Amz-Credential", valid_607827
  var valid_607828 = header.getOrDefault("X-Amz-Security-Token")
  valid_607828 = validateParameter(valid_607828, JString, required = false,
                                 default = nil)
  if valid_607828 != nil:
    section.add "X-Amz-Security-Token", valid_607828
  var valid_607829 = header.getOrDefault("X-Amz-Algorithm")
  valid_607829 = validateParameter(valid_607829, JString, required = false,
                                 default = nil)
  if valid_607829 != nil:
    section.add "X-Amz-Algorithm", valid_607829
  var valid_607830 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607830 = validateParameter(valid_607830, JString, required = false,
                                 default = nil)
  if valid_607830 != nil:
    section.add "X-Amz-SignedHeaders", valid_607830
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607831: Call_DeleteProvisioningTemplate_607820; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a fleet provisioning template.
  ## 
  let valid = call_607831.validator(path, query, header, formData, body)
  let scheme = call_607831.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607831.url(scheme.get, call_607831.host, call_607831.base,
                         call_607831.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607831, url, valid)

proc call*(call_607832: Call_DeleteProvisioningTemplate_607820;
          templateName: string): Recallable =
  ## deleteProvisioningTemplate
  ## Deletes a fleet provisioning template.
  ##   templateName: string (required)
  ##               : The name of the fleet provision template to delete.
  var path_607833 = newJObject()
  add(path_607833, "templateName", newJString(templateName))
  result = call_607832.call(path_607833, nil, nil, nil, nil)

var deleteProvisioningTemplate* = Call_DeleteProvisioningTemplate_607820(
    name: "deleteProvisioningTemplate", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/provisioning-templates/{templateName}",
    validator: validate_DeleteProvisioningTemplate_607821, base: "/",
    url: url_DeleteProvisioningTemplate_607822,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeProvisioningTemplateVersion_607850 = ref object of OpenApiRestCall_605589
proc url_DescribeProvisioningTemplateVersion_607852(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  assert "versionId" in path, "`versionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/versions/"),
               (kind: VariableSegment, value: "versionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeProvisioningTemplateVersion_607851(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about a fleet provisioning template version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The template name.
  ##   versionId: JInt (required)
  ##            : The fleet provisioning template version ID.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_607853 = path.getOrDefault("templateName")
  valid_607853 = validateParameter(valid_607853, JString, required = true,
                                 default = nil)
  if valid_607853 != nil:
    section.add "templateName", valid_607853
  var valid_607854 = path.getOrDefault("versionId")
  valid_607854 = validateParameter(valid_607854, JInt, required = true, default = nil)
  if valid_607854 != nil:
    section.add "versionId", valid_607854
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607855 = header.getOrDefault("X-Amz-Signature")
  valid_607855 = validateParameter(valid_607855, JString, required = false,
                                 default = nil)
  if valid_607855 != nil:
    section.add "X-Amz-Signature", valid_607855
  var valid_607856 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607856 = validateParameter(valid_607856, JString, required = false,
                                 default = nil)
  if valid_607856 != nil:
    section.add "X-Amz-Content-Sha256", valid_607856
  var valid_607857 = header.getOrDefault("X-Amz-Date")
  valid_607857 = validateParameter(valid_607857, JString, required = false,
                                 default = nil)
  if valid_607857 != nil:
    section.add "X-Amz-Date", valid_607857
  var valid_607858 = header.getOrDefault("X-Amz-Credential")
  valid_607858 = validateParameter(valid_607858, JString, required = false,
                                 default = nil)
  if valid_607858 != nil:
    section.add "X-Amz-Credential", valid_607858
  var valid_607859 = header.getOrDefault("X-Amz-Security-Token")
  valid_607859 = validateParameter(valid_607859, JString, required = false,
                                 default = nil)
  if valid_607859 != nil:
    section.add "X-Amz-Security-Token", valid_607859
  var valid_607860 = header.getOrDefault("X-Amz-Algorithm")
  valid_607860 = validateParameter(valid_607860, JString, required = false,
                                 default = nil)
  if valid_607860 != nil:
    section.add "X-Amz-Algorithm", valid_607860
  var valid_607861 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607861 = validateParameter(valid_607861, JString, required = false,
                                 default = nil)
  if valid_607861 != nil:
    section.add "X-Amz-SignedHeaders", valid_607861
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607862: Call_DescribeProvisioningTemplateVersion_607850;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns information about a fleet provisioning template version.
  ## 
  let valid = call_607862.validator(path, query, header, formData, body)
  let scheme = call_607862.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607862.url(scheme.get, call_607862.host, call_607862.base,
                         call_607862.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607862, url, valid)

proc call*(call_607863: Call_DescribeProvisioningTemplateVersion_607850;
          templateName: string; versionId: int): Recallable =
  ## describeProvisioningTemplateVersion
  ## Returns information about a fleet provisioning template version.
  ##   templateName: string (required)
  ##               : The template name.
  ##   versionId: int (required)
  ##            : The fleet provisioning template version ID.
  var path_607864 = newJObject()
  add(path_607864, "templateName", newJString(templateName))
  add(path_607864, "versionId", newJInt(versionId))
  result = call_607863.call(path_607864, nil, nil, nil, nil)

var describeProvisioningTemplateVersion* = Call_DescribeProvisioningTemplateVersion_607850(
    name: "describeProvisioningTemplateVersion", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/versions/{versionId}",
    validator: validate_DescribeProvisioningTemplateVersion_607851, base: "/",
    url: url_DescribeProvisioningTemplateVersion_607852,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteProvisioningTemplateVersion_607865 = ref object of OpenApiRestCall_605589
proc url_DeleteProvisioningTemplateVersion_607867(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "templateName" in path, "`templateName` is a required path parameter"
  assert "versionId" in path, "`versionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/provisioning-templates/"),
               (kind: VariableSegment, value: "templateName"),
               (kind: ConstantSegment, value: "/versions/"),
               (kind: VariableSegment, value: "versionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteProvisioningTemplateVersion_607866(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a fleet provisioning template version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   templateName: JString (required)
  ##               : The name of the fleet provisioning template version to delete.
  ##   versionId: JInt (required)
  ##            : The fleet provisioning template version ID to delete.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `templateName` field"
  var valid_607868 = path.getOrDefault("templateName")
  valid_607868 = validateParameter(valid_607868, JString, required = true,
                                 default = nil)
  if valid_607868 != nil:
    section.add "templateName", valid_607868
  var valid_607869 = path.getOrDefault("versionId")
  valid_607869 = validateParameter(valid_607869, JInt, required = true, default = nil)
  if valid_607869 != nil:
    section.add "versionId", valid_607869
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607870 = header.getOrDefault("X-Amz-Signature")
  valid_607870 = validateParameter(valid_607870, JString, required = false,
                                 default = nil)
  if valid_607870 != nil:
    section.add "X-Amz-Signature", valid_607870
  var valid_607871 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607871 = validateParameter(valid_607871, JString, required = false,
                                 default = nil)
  if valid_607871 != nil:
    section.add "X-Amz-Content-Sha256", valid_607871
  var valid_607872 = header.getOrDefault("X-Amz-Date")
  valid_607872 = validateParameter(valid_607872, JString, required = false,
                                 default = nil)
  if valid_607872 != nil:
    section.add "X-Amz-Date", valid_607872
  var valid_607873 = header.getOrDefault("X-Amz-Credential")
  valid_607873 = validateParameter(valid_607873, JString, required = false,
                                 default = nil)
  if valid_607873 != nil:
    section.add "X-Amz-Credential", valid_607873
  var valid_607874 = header.getOrDefault("X-Amz-Security-Token")
  valid_607874 = validateParameter(valid_607874, JString, required = false,
                                 default = nil)
  if valid_607874 != nil:
    section.add "X-Amz-Security-Token", valid_607874
  var valid_607875 = header.getOrDefault("X-Amz-Algorithm")
  valid_607875 = validateParameter(valid_607875, JString, required = false,
                                 default = nil)
  if valid_607875 != nil:
    section.add "X-Amz-Algorithm", valid_607875
  var valid_607876 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607876 = validateParameter(valid_607876, JString, required = false,
                                 default = nil)
  if valid_607876 != nil:
    section.add "X-Amz-SignedHeaders", valid_607876
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607877: Call_DeleteProvisioningTemplateVersion_607865;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes a fleet provisioning template version.
  ## 
  let valid = call_607877.validator(path, query, header, formData, body)
  let scheme = call_607877.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607877.url(scheme.get, call_607877.host, call_607877.base,
                         call_607877.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607877, url, valid)

proc call*(call_607878: Call_DeleteProvisioningTemplateVersion_607865;
          templateName: string; versionId: int): Recallable =
  ## deleteProvisioningTemplateVersion
  ## Deletes a fleet provisioning template version.
  ##   templateName: string (required)
  ##               : The name of the fleet provisioning template version to delete.
  ##   versionId: int (required)
  ##            : The fleet provisioning template version ID to delete.
  var path_607879 = newJObject()
  add(path_607879, "templateName", newJString(templateName))
  add(path_607879, "versionId", newJInt(versionId))
  result = call_607878.call(path_607879, nil, nil, nil, nil)

var deleteProvisioningTemplateVersion* = Call_DeleteProvisioningTemplateVersion_607865(
    name: "deleteProvisioningTemplateVersion", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com",
    route: "/provisioning-templates/{templateName}/versions/{versionId}",
    validator: validate_DeleteProvisioningTemplateVersion_607866, base: "/",
    url: url_DeleteProvisioningTemplateVersion_607867,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRegistrationCode_607880 = ref object of OpenApiRestCall_605589
proc url_GetRegistrationCode_607882(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRegistrationCode_607881(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607883 = header.getOrDefault("X-Amz-Signature")
  valid_607883 = validateParameter(valid_607883, JString, required = false,
                                 default = nil)
  if valid_607883 != nil:
    section.add "X-Amz-Signature", valid_607883
  var valid_607884 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607884 = validateParameter(valid_607884, JString, required = false,
                                 default = nil)
  if valid_607884 != nil:
    section.add "X-Amz-Content-Sha256", valid_607884
  var valid_607885 = header.getOrDefault("X-Amz-Date")
  valid_607885 = validateParameter(valid_607885, JString, required = false,
                                 default = nil)
  if valid_607885 != nil:
    section.add "X-Amz-Date", valid_607885
  var valid_607886 = header.getOrDefault("X-Amz-Credential")
  valid_607886 = validateParameter(valid_607886, JString, required = false,
                                 default = nil)
  if valid_607886 != nil:
    section.add "X-Amz-Credential", valid_607886
  var valid_607887 = header.getOrDefault("X-Amz-Security-Token")
  valid_607887 = validateParameter(valid_607887, JString, required = false,
                                 default = nil)
  if valid_607887 != nil:
    section.add "X-Amz-Security-Token", valid_607887
  var valid_607888 = header.getOrDefault("X-Amz-Algorithm")
  valid_607888 = validateParameter(valid_607888, JString, required = false,
                                 default = nil)
  if valid_607888 != nil:
    section.add "X-Amz-Algorithm", valid_607888
  var valid_607889 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607889 = validateParameter(valid_607889, JString, required = false,
                                 default = nil)
  if valid_607889 != nil:
    section.add "X-Amz-SignedHeaders", valid_607889
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607890: Call_GetRegistrationCode_607880; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  ## 
  let valid = call_607890.validator(path, query, header, formData, body)
  let scheme = call_607890.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607890.url(scheme.get, call_607890.host, call_607890.base,
                         call_607890.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607890, url, valid)

proc call*(call_607891: Call_GetRegistrationCode_607880): Recallable =
  ## getRegistrationCode
  ## Gets a registration code used to register a CA certificate with AWS IoT.
  result = call_607891.call(nil, nil, nil, nil, nil)

var getRegistrationCode* = Call_GetRegistrationCode_607880(
    name: "getRegistrationCode", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/registrationcode",
    validator: validate_GetRegistrationCode_607881, base: "/",
    url: url_GetRegistrationCode_607882, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRegistrationCode_607892 = ref object of OpenApiRestCall_605589
proc url_DeleteRegistrationCode_607894(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteRegistrationCode_607893(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a CA certificate registration code.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607895 = header.getOrDefault("X-Amz-Signature")
  valid_607895 = validateParameter(valid_607895, JString, required = false,
                                 default = nil)
  if valid_607895 != nil:
    section.add "X-Amz-Signature", valid_607895
  var valid_607896 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607896 = validateParameter(valid_607896, JString, required = false,
                                 default = nil)
  if valid_607896 != nil:
    section.add "X-Amz-Content-Sha256", valid_607896
  var valid_607897 = header.getOrDefault("X-Amz-Date")
  valid_607897 = validateParameter(valid_607897, JString, required = false,
                                 default = nil)
  if valid_607897 != nil:
    section.add "X-Amz-Date", valid_607897
  var valid_607898 = header.getOrDefault("X-Amz-Credential")
  valid_607898 = validateParameter(valid_607898, JString, required = false,
                                 default = nil)
  if valid_607898 != nil:
    section.add "X-Amz-Credential", valid_607898
  var valid_607899 = header.getOrDefault("X-Amz-Security-Token")
  valid_607899 = validateParameter(valid_607899, JString, required = false,
                                 default = nil)
  if valid_607899 != nil:
    section.add "X-Amz-Security-Token", valid_607899
  var valid_607900 = header.getOrDefault("X-Amz-Algorithm")
  valid_607900 = validateParameter(valid_607900, JString, required = false,
                                 default = nil)
  if valid_607900 != nil:
    section.add "X-Amz-Algorithm", valid_607900
  var valid_607901 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607901 = validateParameter(valid_607901, JString, required = false,
                                 default = nil)
  if valid_607901 != nil:
    section.add "X-Amz-SignedHeaders", valid_607901
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607902: Call_DeleteRegistrationCode_607892; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a CA certificate registration code.
  ## 
  let valid = call_607902.validator(path, query, header, formData, body)
  let scheme = call_607902.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607902.url(scheme.get, call_607902.host, call_607902.base,
                         call_607902.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607902, url, valid)

proc call*(call_607903: Call_DeleteRegistrationCode_607892): Recallable =
  ## deleteRegistrationCode
  ## Deletes a CA certificate registration code.
  result = call_607903.call(nil, nil, nil, nil, nil)

var deleteRegistrationCode* = Call_DeleteRegistrationCode_607892(
    name: "deleteRegistrationCode", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/registrationcode",
    validator: validate_DeleteRegistrationCode_607893, base: "/",
    url: url_DeleteRegistrationCode_607894, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetTopicRuleDestination_607904 = ref object of OpenApiRestCall_605589
proc url_GetTopicRuleDestination_607906(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "arn" in path, "`arn` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/destinations/"),
               (kind: VariableSegment, value: "arn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTopicRuleDestination_607905(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a topic rule destination.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   arn: JString (required)
  ##      : The ARN of the topic rule destination.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `arn` field"
  var valid_607907 = path.getOrDefault("arn")
  valid_607907 = validateParameter(valid_607907, JString, required = true,
                                 default = nil)
  if valid_607907 != nil:
    section.add "arn", valid_607907
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607908 = header.getOrDefault("X-Amz-Signature")
  valid_607908 = validateParameter(valid_607908, JString, required = false,
                                 default = nil)
  if valid_607908 != nil:
    section.add "X-Amz-Signature", valid_607908
  var valid_607909 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607909 = validateParameter(valid_607909, JString, required = false,
                                 default = nil)
  if valid_607909 != nil:
    section.add "X-Amz-Content-Sha256", valid_607909
  var valid_607910 = header.getOrDefault("X-Amz-Date")
  valid_607910 = validateParameter(valid_607910, JString, required = false,
                                 default = nil)
  if valid_607910 != nil:
    section.add "X-Amz-Date", valid_607910
  var valid_607911 = header.getOrDefault("X-Amz-Credential")
  valid_607911 = validateParameter(valid_607911, JString, required = false,
                                 default = nil)
  if valid_607911 != nil:
    section.add "X-Amz-Credential", valid_607911
  var valid_607912 = header.getOrDefault("X-Amz-Security-Token")
  valid_607912 = validateParameter(valid_607912, JString, required = false,
                                 default = nil)
  if valid_607912 != nil:
    section.add "X-Amz-Security-Token", valid_607912
  var valid_607913 = header.getOrDefault("X-Amz-Algorithm")
  valid_607913 = validateParameter(valid_607913, JString, required = false,
                                 default = nil)
  if valid_607913 != nil:
    section.add "X-Amz-Algorithm", valid_607913
  var valid_607914 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607914 = validateParameter(valid_607914, JString, required = false,
                                 default = nil)
  if valid_607914 != nil:
    section.add "X-Amz-SignedHeaders", valid_607914
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607915: Call_GetTopicRuleDestination_607904; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a topic rule destination.
  ## 
  let valid = call_607915.validator(path, query, header, formData, body)
  let scheme = call_607915.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607915.url(scheme.get, call_607915.host, call_607915.base,
                         call_607915.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607915, url, valid)

proc call*(call_607916: Call_GetTopicRuleDestination_607904; arn: string): Recallable =
  ## getTopicRuleDestination
  ## Gets information about a topic rule destination.
  ##   arn: string (required)
  ##      : The ARN of the topic rule destination.
  var path_607917 = newJObject()
  add(path_607917, "arn", newJString(arn))
  result = call_607916.call(path_607917, nil, nil, nil, nil)

var getTopicRuleDestination* = Call_GetTopicRuleDestination_607904(
    name: "getTopicRuleDestination", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/destinations/{arn}",
    validator: validate_GetTopicRuleDestination_607905, base: "/",
    url: url_GetTopicRuleDestination_607906, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteTopicRuleDestination_607918 = ref object of OpenApiRestCall_605589
proc url_DeleteTopicRuleDestination_607920(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "arn" in path, "`arn` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/destinations/"),
               (kind: VariableSegment, value: "arn")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTopicRuleDestination_607919(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a topic rule destination.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   arn: JString (required)
  ##      : The ARN of the topic rule destination to delete.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `arn` field"
  var valid_607921 = path.getOrDefault("arn")
  valid_607921 = validateParameter(valid_607921, JString, required = true,
                                 default = nil)
  if valid_607921 != nil:
    section.add "arn", valid_607921
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607922 = header.getOrDefault("X-Amz-Signature")
  valid_607922 = validateParameter(valid_607922, JString, required = false,
                                 default = nil)
  if valid_607922 != nil:
    section.add "X-Amz-Signature", valid_607922
  var valid_607923 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607923 = validateParameter(valid_607923, JString, required = false,
                                 default = nil)
  if valid_607923 != nil:
    section.add "X-Amz-Content-Sha256", valid_607923
  var valid_607924 = header.getOrDefault("X-Amz-Date")
  valid_607924 = validateParameter(valid_607924, JString, required = false,
                                 default = nil)
  if valid_607924 != nil:
    section.add "X-Amz-Date", valid_607924
  var valid_607925 = header.getOrDefault("X-Amz-Credential")
  valid_607925 = validateParameter(valid_607925, JString, required = false,
                                 default = nil)
  if valid_607925 != nil:
    section.add "X-Amz-Credential", valid_607925
  var valid_607926 = header.getOrDefault("X-Amz-Security-Token")
  valid_607926 = validateParameter(valid_607926, JString, required = false,
                                 default = nil)
  if valid_607926 != nil:
    section.add "X-Amz-Security-Token", valid_607926
  var valid_607927 = header.getOrDefault("X-Amz-Algorithm")
  valid_607927 = validateParameter(valid_607927, JString, required = false,
                                 default = nil)
  if valid_607927 != nil:
    section.add "X-Amz-Algorithm", valid_607927
  var valid_607928 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607928 = validateParameter(valid_607928, JString, required = false,
                                 default = nil)
  if valid_607928 != nil:
    section.add "X-Amz-SignedHeaders", valid_607928
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607929: Call_DeleteTopicRuleDestination_607918; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a topic rule destination.
  ## 
  let valid = call_607929.validator(path, query, header, formData, body)
  let scheme = call_607929.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607929.url(scheme.get, call_607929.host, call_607929.base,
                         call_607929.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607929, url, valid)

proc call*(call_607930: Call_DeleteTopicRuleDestination_607918; arn: string): Recallable =
  ## deleteTopicRuleDestination
  ## Deletes a topic rule destination.
  ##   arn: string (required)
  ##      : The ARN of the topic rule destination to delete.
  var path_607931 = newJObject()
  add(path_607931, "arn", newJString(arn))
  result = call_607930.call(path_607931, nil, nil, nil, nil)

var deleteTopicRuleDestination* = Call_DeleteTopicRuleDestination_607918(
    name: "deleteTopicRuleDestination", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/destinations/{arn}",
    validator: validate_DeleteTopicRuleDestination_607919, base: "/",
    url: url_DeleteTopicRuleDestination_607920,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteV2LoggingLevel_607932 = ref object of OpenApiRestCall_605589
proc url_DeleteV2LoggingLevel_607934(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteV2LoggingLevel_607933(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a logging level.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   targetName: JString (required)
  ##             : The name of the resource for which you are configuring logging.
  ##   targetType: JString (required)
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `targetName` field"
  var valid_607935 = query.getOrDefault("targetName")
  valid_607935 = validateParameter(valid_607935, JString, required = true,
                                 default = nil)
  if valid_607935 != nil:
    section.add "targetName", valid_607935
  var valid_607936 = query.getOrDefault("targetType")
  valid_607936 = validateParameter(valid_607936, JString, required = true,
                                 default = newJString("DEFAULT"))
  if valid_607936 != nil:
    section.add "targetType", valid_607936
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607937 = header.getOrDefault("X-Amz-Signature")
  valid_607937 = validateParameter(valid_607937, JString, required = false,
                                 default = nil)
  if valid_607937 != nil:
    section.add "X-Amz-Signature", valid_607937
  var valid_607938 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607938 = validateParameter(valid_607938, JString, required = false,
                                 default = nil)
  if valid_607938 != nil:
    section.add "X-Amz-Content-Sha256", valid_607938
  var valid_607939 = header.getOrDefault("X-Amz-Date")
  valid_607939 = validateParameter(valid_607939, JString, required = false,
                                 default = nil)
  if valid_607939 != nil:
    section.add "X-Amz-Date", valid_607939
  var valid_607940 = header.getOrDefault("X-Amz-Credential")
  valid_607940 = validateParameter(valid_607940, JString, required = false,
                                 default = nil)
  if valid_607940 != nil:
    section.add "X-Amz-Credential", valid_607940
  var valid_607941 = header.getOrDefault("X-Amz-Security-Token")
  valid_607941 = validateParameter(valid_607941, JString, required = false,
                                 default = nil)
  if valid_607941 != nil:
    section.add "X-Amz-Security-Token", valid_607941
  var valid_607942 = header.getOrDefault("X-Amz-Algorithm")
  valid_607942 = validateParameter(valid_607942, JString, required = false,
                                 default = nil)
  if valid_607942 != nil:
    section.add "X-Amz-Algorithm", valid_607942
  var valid_607943 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607943 = validateParameter(valid_607943, JString, required = false,
                                 default = nil)
  if valid_607943 != nil:
    section.add "X-Amz-SignedHeaders", valid_607943
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607944: Call_DeleteV2LoggingLevel_607932; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a logging level.
  ## 
  let valid = call_607944.validator(path, query, header, formData, body)
  let scheme = call_607944.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607944.url(scheme.get, call_607944.host, call_607944.base,
                         call_607944.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607944, url, valid)

proc call*(call_607945: Call_DeleteV2LoggingLevel_607932; targetName: string;
          targetType: string = "DEFAULT"): Recallable =
  ## deleteV2LoggingLevel
  ## Deletes a logging level.
  ##   targetName: string (required)
  ##             : The name of the resource for which you are configuring logging.
  ##   targetType: string (required)
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  var query_607946 = newJObject()
  add(query_607946, "targetName", newJString(targetName))
  add(query_607946, "targetType", newJString(targetType))
  result = call_607945.call(nil, query_607946, nil, nil, nil)

var deleteV2LoggingLevel* = Call_DeleteV2LoggingLevel_607932(
    name: "deleteV2LoggingLevel", meth: HttpMethod.HttpDelete,
    host: "iot.amazonaws.com", route: "/v2LoggingLevel#targetType&targetName",
    validator: validate_DeleteV2LoggingLevel_607933, base: "/",
    url: url_DeleteV2LoggingLevel_607934, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeprecateThingType_607947 = ref object of OpenApiRestCall_605589
proc url_DeprecateThingType_607949(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingTypeName" in path, "`thingTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-types/"),
               (kind: VariableSegment, value: "thingTypeName"),
               (kind: ConstantSegment, value: "/deprecate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeprecateThingType_607948(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingTypeName: JString (required)
  ##                : The name of the thing type to deprecate.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingTypeName` field"
  var valid_607950 = path.getOrDefault("thingTypeName")
  valid_607950 = validateParameter(valid_607950, JString, required = true,
                                 default = nil)
  if valid_607950 != nil:
    section.add "thingTypeName", valid_607950
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607951 = header.getOrDefault("X-Amz-Signature")
  valid_607951 = validateParameter(valid_607951, JString, required = false,
                                 default = nil)
  if valid_607951 != nil:
    section.add "X-Amz-Signature", valid_607951
  var valid_607952 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607952 = validateParameter(valid_607952, JString, required = false,
                                 default = nil)
  if valid_607952 != nil:
    section.add "X-Amz-Content-Sha256", valid_607952
  var valid_607953 = header.getOrDefault("X-Amz-Date")
  valid_607953 = validateParameter(valid_607953, JString, required = false,
                                 default = nil)
  if valid_607953 != nil:
    section.add "X-Amz-Date", valid_607953
  var valid_607954 = header.getOrDefault("X-Amz-Credential")
  valid_607954 = validateParameter(valid_607954, JString, required = false,
                                 default = nil)
  if valid_607954 != nil:
    section.add "X-Amz-Credential", valid_607954
  var valid_607955 = header.getOrDefault("X-Amz-Security-Token")
  valid_607955 = validateParameter(valid_607955, JString, required = false,
                                 default = nil)
  if valid_607955 != nil:
    section.add "X-Amz-Security-Token", valid_607955
  var valid_607956 = header.getOrDefault("X-Amz-Algorithm")
  valid_607956 = validateParameter(valid_607956, JString, required = false,
                                 default = nil)
  if valid_607956 != nil:
    section.add "X-Amz-Algorithm", valid_607956
  var valid_607957 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607957 = validateParameter(valid_607957, JString, required = false,
                                 default = nil)
  if valid_607957 != nil:
    section.add "X-Amz-SignedHeaders", valid_607957
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_607959: Call_DeprecateThingType_607947; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ## 
  let valid = call_607959.validator(path, query, header, formData, body)
  let scheme = call_607959.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607959.url(scheme.get, call_607959.host, call_607959.base,
                         call_607959.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607959, url, valid)

proc call*(call_607960: Call_DeprecateThingType_607947; thingTypeName: string;
          body: JsonNode): Recallable =
  ## deprecateThingType
  ## Deprecates a thing type. You can not associate new things with deprecated thing type.
  ##   thingTypeName: string (required)
  ##                : The name of the thing type to deprecate.
  ##   body: JObject (required)
  var path_607961 = newJObject()
  var body_607962 = newJObject()
  add(path_607961, "thingTypeName", newJString(thingTypeName))
  if body != nil:
    body_607962 = body
  result = call_607960.call(path_607961, nil, nil, nil, body_607962)

var deprecateThingType* = Call_DeprecateThingType_607947(
    name: "deprecateThingType", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/thing-types/{thingTypeName}/deprecate",
    validator: validate_DeprecateThingType_607948, base: "/",
    url: url_DeprecateThingType_607949, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditFinding_607963 = ref object of OpenApiRestCall_605589
proc url_DescribeAuditFinding_607965(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "findingId" in path, "`findingId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/findings/"),
               (kind: VariableSegment, value: "findingId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuditFinding_607964(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   findingId: JString (required)
  ##            : A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `findingId` field"
  var valid_607966 = path.getOrDefault("findingId")
  valid_607966 = validateParameter(valid_607966, JString, required = true,
                                 default = nil)
  if valid_607966 != nil:
    section.add "findingId", valid_607966
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607967 = header.getOrDefault("X-Amz-Signature")
  valid_607967 = validateParameter(valid_607967, JString, required = false,
                                 default = nil)
  if valid_607967 != nil:
    section.add "X-Amz-Signature", valid_607967
  var valid_607968 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607968 = validateParameter(valid_607968, JString, required = false,
                                 default = nil)
  if valid_607968 != nil:
    section.add "X-Amz-Content-Sha256", valid_607968
  var valid_607969 = header.getOrDefault("X-Amz-Date")
  valid_607969 = validateParameter(valid_607969, JString, required = false,
                                 default = nil)
  if valid_607969 != nil:
    section.add "X-Amz-Date", valid_607969
  var valid_607970 = header.getOrDefault("X-Amz-Credential")
  valid_607970 = validateParameter(valid_607970, JString, required = false,
                                 default = nil)
  if valid_607970 != nil:
    section.add "X-Amz-Credential", valid_607970
  var valid_607971 = header.getOrDefault("X-Amz-Security-Token")
  valid_607971 = validateParameter(valid_607971, JString, required = false,
                                 default = nil)
  if valid_607971 != nil:
    section.add "X-Amz-Security-Token", valid_607971
  var valid_607972 = header.getOrDefault("X-Amz-Algorithm")
  valid_607972 = validateParameter(valid_607972, JString, required = false,
                                 default = nil)
  if valid_607972 != nil:
    section.add "X-Amz-Algorithm", valid_607972
  var valid_607973 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607973 = validateParameter(valid_607973, JString, required = false,
                                 default = nil)
  if valid_607973 != nil:
    section.add "X-Amz-SignedHeaders", valid_607973
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607974: Call_DescribeAuditFinding_607963; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ## 
  let valid = call_607974.validator(path, query, header, formData, body)
  let scheme = call_607974.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607974.url(scheme.get, call_607974.host, call_607974.base,
                         call_607974.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607974, url, valid)

proc call*(call_607975: Call_DescribeAuditFinding_607963; findingId: string): Recallable =
  ## describeAuditFinding
  ## Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.
  ##   findingId: string (required)
  ##            : A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
  var path_607976 = newJObject()
  add(path_607976, "findingId", newJString(findingId))
  result = call_607975.call(path_607976, nil, nil, nil, nil)

var describeAuditFinding* = Call_DescribeAuditFinding_607963(
    name: "describeAuditFinding", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/findings/{findingId}",
    validator: validate_DescribeAuditFinding_607964, base: "/",
    url: url_DescribeAuditFinding_607965, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartAuditMitigationActionsTask_607991 = ref object of OpenApiRestCall_605589
proc url_StartAuditMitigationActionsTask_607993(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_StartAuditMitigationActionsTask_607992(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_607994 = path.getOrDefault("taskId")
  valid_607994 = validateParameter(valid_607994, JString, required = true,
                                 default = nil)
  if valid_607994 != nil:
    section.add "taskId", valid_607994
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607995 = header.getOrDefault("X-Amz-Signature")
  valid_607995 = validateParameter(valid_607995, JString, required = false,
                                 default = nil)
  if valid_607995 != nil:
    section.add "X-Amz-Signature", valid_607995
  var valid_607996 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607996 = validateParameter(valid_607996, JString, required = false,
                                 default = nil)
  if valid_607996 != nil:
    section.add "X-Amz-Content-Sha256", valid_607996
  var valid_607997 = header.getOrDefault("X-Amz-Date")
  valid_607997 = validateParameter(valid_607997, JString, required = false,
                                 default = nil)
  if valid_607997 != nil:
    section.add "X-Amz-Date", valid_607997
  var valid_607998 = header.getOrDefault("X-Amz-Credential")
  valid_607998 = validateParameter(valid_607998, JString, required = false,
                                 default = nil)
  if valid_607998 != nil:
    section.add "X-Amz-Credential", valid_607998
  var valid_607999 = header.getOrDefault("X-Amz-Security-Token")
  valid_607999 = validateParameter(valid_607999, JString, required = false,
                                 default = nil)
  if valid_607999 != nil:
    section.add "X-Amz-Security-Token", valid_607999
  var valid_608000 = header.getOrDefault("X-Amz-Algorithm")
  valid_608000 = validateParameter(valid_608000, JString, required = false,
                                 default = nil)
  if valid_608000 != nil:
    section.add "X-Amz-Algorithm", valid_608000
  var valid_608001 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608001 = validateParameter(valid_608001, JString, required = false,
                                 default = nil)
  if valid_608001 != nil:
    section.add "X-Amz-SignedHeaders", valid_608001
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_608003: Call_StartAuditMitigationActionsTask_607991;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ## 
  let valid = call_608003.validator(path, query, header, formData, body)
  let scheme = call_608003.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608003.url(scheme.get, call_608003.host, call_608003.base,
                         call_608003.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608003, url, valid)

proc call*(call_608004: Call_StartAuditMitigationActionsTask_607991;
          body: JsonNode; taskId: string): Recallable =
  ## startAuditMitigationActionsTask
  ## Starts a task that applies a set of mitigation actions to the specified target.
  ##   body: JObject (required)
  ##   taskId: string (required)
  ##         : A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
  var path_608005 = newJObject()
  var body_608006 = newJObject()
  if body != nil:
    body_608006 = body
  add(path_608005, "taskId", newJString(taskId))
  result = call_608004.call(path_608005, nil, nil, nil, body_608006)

var startAuditMitigationActionsTask* = Call_StartAuditMitigationActionsTask_607991(
    name: "startAuditMitigationActionsTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/audit/mitigationactions/tasks/{taskId}",
    validator: validate_StartAuditMitigationActionsTask_607992, base: "/",
    url: url_StartAuditMitigationActionsTask_607993,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditMitigationActionsTask_607977 = ref object of OpenApiRestCall_605589
proc url_DescribeAuditMitigationActionsTask_607979(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/mitigationactions/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuditMitigationActionsTask_607978(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The unique identifier for the audit mitigation task.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_607980 = path.getOrDefault("taskId")
  valid_607980 = validateParameter(valid_607980, JString, required = true,
                                 default = nil)
  if valid_607980 != nil:
    section.add "taskId", valid_607980
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_607981 = header.getOrDefault("X-Amz-Signature")
  valid_607981 = validateParameter(valid_607981, JString, required = false,
                                 default = nil)
  if valid_607981 != nil:
    section.add "X-Amz-Signature", valid_607981
  var valid_607982 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_607982 = validateParameter(valid_607982, JString, required = false,
                                 default = nil)
  if valid_607982 != nil:
    section.add "X-Amz-Content-Sha256", valid_607982
  var valid_607983 = header.getOrDefault("X-Amz-Date")
  valid_607983 = validateParameter(valid_607983, JString, required = false,
                                 default = nil)
  if valid_607983 != nil:
    section.add "X-Amz-Date", valid_607983
  var valid_607984 = header.getOrDefault("X-Amz-Credential")
  valid_607984 = validateParameter(valid_607984, JString, required = false,
                                 default = nil)
  if valid_607984 != nil:
    section.add "X-Amz-Credential", valid_607984
  var valid_607985 = header.getOrDefault("X-Amz-Security-Token")
  valid_607985 = validateParameter(valid_607985, JString, required = false,
                                 default = nil)
  if valid_607985 != nil:
    section.add "X-Amz-Security-Token", valid_607985
  var valid_607986 = header.getOrDefault("X-Amz-Algorithm")
  valid_607986 = validateParameter(valid_607986, JString, required = false,
                                 default = nil)
  if valid_607986 != nil:
    section.add "X-Amz-Algorithm", valid_607986
  var valid_607987 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_607987 = validateParameter(valid_607987, JString, required = false,
                                 default = nil)
  if valid_607987 != nil:
    section.add "X-Amz-SignedHeaders", valid_607987
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_607988: Call_DescribeAuditMitigationActionsTask_607977;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ## 
  let valid = call_607988.validator(path, query, header, formData, body)
  let scheme = call_607988.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_607988.url(scheme.get, call_607988.host, call_607988.base,
                         call_607988.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_607988, url, valid)

proc call*(call_607989: Call_DescribeAuditMitigationActionsTask_607977;
          taskId: string): Recallable =
  ## describeAuditMitigationActionsTask
  ## Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.
  ##   taskId: string (required)
  ##         : The unique identifier for the audit mitigation task.
  var path_607990 = newJObject()
  add(path_607990, "taskId", newJString(taskId))
  result = call_607989.call(path_607990, nil, nil, nil, nil)

var describeAuditMitigationActionsTask* = Call_DescribeAuditMitigationActionsTask_607977(
    name: "describeAuditMitigationActionsTask", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/mitigationactions/tasks/{taskId}",
    validator: validate_DescribeAuditMitigationActionsTask_607978, base: "/",
    url: url_DescribeAuditMitigationActionsTask_607979,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeAuditTask_608007 = ref object of OpenApiRestCall_605589
proc url_DescribeAuditTask_608009(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/audit/tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeAuditTask_608008(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Gets information about a Device Defender audit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The ID of the audit whose information you want to get.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_608010 = path.getOrDefault("taskId")
  valid_608010 = validateParameter(valid_608010, JString, required = true,
                                 default = nil)
  if valid_608010 != nil:
    section.add "taskId", valid_608010
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608011 = header.getOrDefault("X-Amz-Signature")
  valid_608011 = validateParameter(valid_608011, JString, required = false,
                                 default = nil)
  if valid_608011 != nil:
    section.add "X-Amz-Signature", valid_608011
  var valid_608012 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608012 = validateParameter(valid_608012, JString, required = false,
                                 default = nil)
  if valid_608012 != nil:
    section.add "X-Amz-Content-Sha256", valid_608012
  var valid_608013 = header.getOrDefault("X-Amz-Date")
  valid_608013 = validateParameter(valid_608013, JString, required = false,
                                 default = nil)
  if valid_608013 != nil:
    section.add "X-Amz-Date", valid_608013
  var valid_608014 = header.getOrDefault("X-Amz-Credential")
  valid_608014 = validateParameter(valid_608014, JString, required = false,
                                 default = nil)
  if valid_608014 != nil:
    section.add "X-Amz-Credential", valid_608014
  var valid_608015 = header.getOrDefault("X-Amz-Security-Token")
  valid_608015 = validateParameter(valid_608015, JString, required = false,
                                 default = nil)
  if valid_608015 != nil:
    section.add "X-Amz-Security-Token", valid_608015
  var valid_608016 = header.getOrDefault("X-Amz-Algorithm")
  valid_608016 = validateParameter(valid_608016, JString, required = false,
                                 default = nil)
  if valid_608016 != nil:
    section.add "X-Amz-Algorithm", valid_608016
  var valid_608017 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608017 = validateParameter(valid_608017, JString, required = false,
                                 default = nil)
  if valid_608017 != nil:
    section.add "X-Amz-SignedHeaders", valid_608017
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608018: Call_DescribeAuditTask_608007; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information about a Device Defender audit.
  ## 
  let valid = call_608018.validator(path, query, header, formData, body)
  let scheme = call_608018.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608018.url(scheme.get, call_608018.host, call_608018.base,
                         call_608018.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608018, url, valid)

proc call*(call_608019: Call_DescribeAuditTask_608007; taskId: string): Recallable =
  ## describeAuditTask
  ## Gets information about a Device Defender audit.
  ##   taskId: string (required)
  ##         : The ID of the audit whose information you want to get.
  var path_608020 = newJObject()
  add(path_608020, "taskId", newJString(taskId))
  result = call_608019.call(path_608020, nil, nil, nil, nil)

var describeAuditTask* = Call_DescribeAuditTask_608007(name: "describeAuditTask",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/audit/tasks/{taskId}", validator: validate_DescribeAuditTask_608008,
    base: "/", url: url_DescribeAuditTask_608009,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeEndpoint_608021 = ref object of OpenApiRestCall_605589
proc url_DescribeEndpoint_608023(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeEndpoint_608022(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Returns a unique endpoint specific to the AWS account making the call.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endpointType: JString
  ##               : <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
  section = newJObject()
  var valid_608024 = query.getOrDefault("endpointType")
  valid_608024 = validateParameter(valid_608024, JString, required = false,
                                 default = nil)
  if valid_608024 != nil:
    section.add "endpointType", valid_608024
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608025 = header.getOrDefault("X-Amz-Signature")
  valid_608025 = validateParameter(valid_608025, JString, required = false,
                                 default = nil)
  if valid_608025 != nil:
    section.add "X-Amz-Signature", valid_608025
  var valid_608026 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608026 = validateParameter(valid_608026, JString, required = false,
                                 default = nil)
  if valid_608026 != nil:
    section.add "X-Amz-Content-Sha256", valid_608026
  var valid_608027 = header.getOrDefault("X-Amz-Date")
  valid_608027 = validateParameter(valid_608027, JString, required = false,
                                 default = nil)
  if valid_608027 != nil:
    section.add "X-Amz-Date", valid_608027
  var valid_608028 = header.getOrDefault("X-Amz-Credential")
  valid_608028 = validateParameter(valid_608028, JString, required = false,
                                 default = nil)
  if valid_608028 != nil:
    section.add "X-Amz-Credential", valid_608028
  var valid_608029 = header.getOrDefault("X-Amz-Security-Token")
  valid_608029 = validateParameter(valid_608029, JString, required = false,
                                 default = nil)
  if valid_608029 != nil:
    section.add "X-Amz-Security-Token", valid_608029
  var valid_608030 = header.getOrDefault("X-Amz-Algorithm")
  valid_608030 = validateParameter(valid_608030, JString, required = false,
                                 default = nil)
  if valid_608030 != nil:
    section.add "X-Amz-Algorithm", valid_608030
  var valid_608031 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608031 = validateParameter(valid_608031, JString, required = false,
                                 default = nil)
  if valid_608031 != nil:
    section.add "X-Amz-SignedHeaders", valid_608031
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608032: Call_DescribeEndpoint_608021; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a unique endpoint specific to the AWS account making the call.
  ## 
  let valid = call_608032.validator(path, query, header, formData, body)
  let scheme = call_608032.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608032.url(scheme.get, call_608032.host, call_608032.base,
                         call_608032.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608032, url, valid)

proc call*(call_608033: Call_DescribeEndpoint_608021; endpointType: string = ""): Recallable =
  ## describeEndpoint
  ## Returns a unique endpoint specific to the AWS account making the call.
  ##   endpointType: string
  ##               : <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
  var query_608034 = newJObject()
  add(query_608034, "endpointType", newJString(endpointType))
  result = call_608033.call(nil, query_608034, nil, nil, nil)

var describeEndpoint* = Call_DescribeEndpoint_608021(name: "describeEndpoint",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/endpoint",
    validator: validate_DescribeEndpoint_608022, base: "/",
    url: url_DescribeEndpoint_608023, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeEventConfigurations_608035 = ref object of OpenApiRestCall_605589
proc url_DescribeEventConfigurations_608037(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DescribeEventConfigurations_608036(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes event configurations.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608038 = header.getOrDefault("X-Amz-Signature")
  valid_608038 = validateParameter(valid_608038, JString, required = false,
                                 default = nil)
  if valid_608038 != nil:
    section.add "X-Amz-Signature", valid_608038
  var valid_608039 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608039 = validateParameter(valid_608039, JString, required = false,
                                 default = nil)
  if valid_608039 != nil:
    section.add "X-Amz-Content-Sha256", valid_608039
  var valid_608040 = header.getOrDefault("X-Amz-Date")
  valid_608040 = validateParameter(valid_608040, JString, required = false,
                                 default = nil)
  if valid_608040 != nil:
    section.add "X-Amz-Date", valid_608040
  var valid_608041 = header.getOrDefault("X-Amz-Credential")
  valid_608041 = validateParameter(valid_608041, JString, required = false,
                                 default = nil)
  if valid_608041 != nil:
    section.add "X-Amz-Credential", valid_608041
  var valid_608042 = header.getOrDefault("X-Amz-Security-Token")
  valid_608042 = validateParameter(valid_608042, JString, required = false,
                                 default = nil)
  if valid_608042 != nil:
    section.add "X-Amz-Security-Token", valid_608042
  var valid_608043 = header.getOrDefault("X-Amz-Algorithm")
  valid_608043 = validateParameter(valid_608043, JString, required = false,
                                 default = nil)
  if valid_608043 != nil:
    section.add "X-Amz-Algorithm", valid_608043
  var valid_608044 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608044 = validateParameter(valid_608044, JString, required = false,
                                 default = nil)
  if valid_608044 != nil:
    section.add "X-Amz-SignedHeaders", valid_608044
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608045: Call_DescribeEventConfigurations_608035; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes event configurations.
  ## 
  let valid = call_608045.validator(path, query, header, formData, body)
  let scheme = call_608045.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608045.url(scheme.get, call_608045.host, call_608045.base,
                         call_608045.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608045, url, valid)

proc call*(call_608046: Call_DescribeEventConfigurations_608035): Recallable =
  ## describeEventConfigurations
  ## Describes event configurations.
  result = call_608046.call(nil, nil, nil, nil, nil)

var describeEventConfigurations* = Call_DescribeEventConfigurations_608035(
    name: "describeEventConfigurations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/event-configurations",
    validator: validate_DescribeEventConfigurations_608036, base: "/",
    url: url_DescribeEventConfigurations_608037,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateEventConfigurations_608047 = ref object of OpenApiRestCall_605589
proc url_UpdateEventConfigurations_608049(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateEventConfigurations_608048(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the event configurations.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608050 = header.getOrDefault("X-Amz-Signature")
  valid_608050 = validateParameter(valid_608050, JString, required = false,
                                 default = nil)
  if valid_608050 != nil:
    section.add "X-Amz-Signature", valid_608050
  var valid_608051 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608051 = validateParameter(valid_608051, JString, required = false,
                                 default = nil)
  if valid_608051 != nil:
    section.add "X-Amz-Content-Sha256", valid_608051
  var valid_608052 = header.getOrDefault("X-Amz-Date")
  valid_608052 = validateParameter(valid_608052, JString, required = false,
                                 default = nil)
  if valid_608052 != nil:
    section.add "X-Amz-Date", valid_608052
  var valid_608053 = header.getOrDefault("X-Amz-Credential")
  valid_608053 = validateParameter(valid_608053, JString, required = false,
                                 default = nil)
  if valid_608053 != nil:
    section.add "X-Amz-Credential", valid_608053
  var valid_608054 = header.getOrDefault("X-Amz-Security-Token")
  valid_608054 = validateParameter(valid_608054, JString, required = false,
                                 default = nil)
  if valid_608054 != nil:
    section.add "X-Amz-Security-Token", valid_608054
  var valid_608055 = header.getOrDefault("X-Amz-Algorithm")
  valid_608055 = validateParameter(valid_608055, JString, required = false,
                                 default = nil)
  if valid_608055 != nil:
    section.add "X-Amz-Algorithm", valid_608055
  var valid_608056 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608056 = validateParameter(valid_608056, JString, required = false,
                                 default = nil)
  if valid_608056 != nil:
    section.add "X-Amz-SignedHeaders", valid_608056
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_608058: Call_UpdateEventConfigurations_608047; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the event configurations.
  ## 
  let valid = call_608058.validator(path, query, header, formData, body)
  let scheme = call_608058.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608058.url(scheme.get, call_608058.host, call_608058.base,
                         call_608058.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608058, url, valid)

proc call*(call_608059: Call_UpdateEventConfigurations_608047; body: JsonNode): Recallable =
  ## updateEventConfigurations
  ## Updates the event configurations.
  ##   body: JObject (required)
  var body_608060 = newJObject()
  if body != nil:
    body_608060 = body
  result = call_608059.call(nil, nil, nil, nil, body_608060)

var updateEventConfigurations* = Call_UpdateEventConfigurations_608047(
    name: "updateEventConfigurations", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com", route: "/event-configurations",
    validator: validate_UpdateEventConfigurations_608048, base: "/",
    url: url_UpdateEventConfigurations_608049,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeIndex_608061 = ref object of OpenApiRestCall_605589
proc url_DescribeIndex_608063(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "indexName" in path, "`indexName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/indices/"),
               (kind: VariableSegment, value: "indexName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeIndex_608062(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a search index.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   indexName: JString (required)
  ##            : The index name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `indexName` field"
  var valid_608064 = path.getOrDefault("indexName")
  valid_608064 = validateParameter(valid_608064, JString, required = true,
                                 default = nil)
  if valid_608064 != nil:
    section.add "indexName", valid_608064
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608065 = header.getOrDefault("X-Amz-Signature")
  valid_608065 = validateParameter(valid_608065, JString, required = false,
                                 default = nil)
  if valid_608065 != nil:
    section.add "X-Amz-Signature", valid_608065
  var valid_608066 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608066 = validateParameter(valid_608066, JString, required = false,
                                 default = nil)
  if valid_608066 != nil:
    section.add "X-Amz-Content-Sha256", valid_608066
  var valid_608067 = header.getOrDefault("X-Amz-Date")
  valid_608067 = validateParameter(valid_608067, JString, required = false,
                                 default = nil)
  if valid_608067 != nil:
    section.add "X-Amz-Date", valid_608067
  var valid_608068 = header.getOrDefault("X-Amz-Credential")
  valid_608068 = validateParameter(valid_608068, JString, required = false,
                                 default = nil)
  if valid_608068 != nil:
    section.add "X-Amz-Credential", valid_608068
  var valid_608069 = header.getOrDefault("X-Amz-Security-Token")
  valid_608069 = validateParameter(valid_608069, JString, required = false,
                                 default = nil)
  if valid_608069 != nil:
    section.add "X-Amz-Security-Token", valid_608069
  var valid_608070 = header.getOrDefault("X-Amz-Algorithm")
  valid_608070 = validateParameter(valid_608070, JString, required = false,
                                 default = nil)
  if valid_608070 != nil:
    section.add "X-Amz-Algorithm", valid_608070
  var valid_608071 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608071 = validateParameter(valid_608071, JString, required = false,
                                 default = nil)
  if valid_608071 != nil:
    section.add "X-Amz-SignedHeaders", valid_608071
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608072: Call_DescribeIndex_608061; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a search index.
  ## 
  let valid = call_608072.validator(path, query, header, formData, body)
  let scheme = call_608072.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608072.url(scheme.get, call_608072.host, call_608072.base,
                         call_608072.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608072, url, valid)

proc call*(call_608073: Call_DescribeIndex_608061; indexName: string): Recallable =
  ## describeIndex
  ## Describes a search index.
  ##   indexName: string (required)
  ##            : The index name.
  var path_608074 = newJObject()
  add(path_608074, "indexName", newJString(indexName))
  result = call_608073.call(path_608074, nil, nil, nil, nil)

var describeIndex* = Call_DescribeIndex_608061(name: "describeIndex",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/indices/{indexName}", validator: validate_DescribeIndex_608062,
    base: "/", url: url_DescribeIndex_608063, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeJobExecution_608075 = ref object of OpenApiRestCall_605589
proc url_DescribeJobExecution_608077(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeJobExecution_608076(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a job execution.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   thingName: JString (required)
  ##            : The name of the thing on which the job execution is running.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_608078 = path.getOrDefault("jobId")
  valid_608078 = validateParameter(valid_608078, JString, required = true,
                                 default = nil)
  if valid_608078 != nil:
    section.add "jobId", valid_608078
  var valid_608079 = path.getOrDefault("thingName")
  valid_608079 = validateParameter(valid_608079, JString, required = true,
                                 default = nil)
  if valid_608079 != nil:
    section.add "thingName", valid_608079
  result.add "path", section
  ## parameters in `query` object:
  ##   executionNumber: JInt
  ##                  : A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
  section = newJObject()
  var valid_608080 = query.getOrDefault("executionNumber")
  valid_608080 = validateParameter(valid_608080, JInt, required = false, default = nil)
  if valid_608080 != nil:
    section.add "executionNumber", valid_608080
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608081 = header.getOrDefault("X-Amz-Signature")
  valid_608081 = validateParameter(valid_608081, JString, required = false,
                                 default = nil)
  if valid_608081 != nil:
    section.add "X-Amz-Signature", valid_608081
  var valid_608082 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608082 = validateParameter(valid_608082, JString, required = false,
                                 default = nil)
  if valid_608082 != nil:
    section.add "X-Amz-Content-Sha256", valid_608082
  var valid_608083 = header.getOrDefault("X-Amz-Date")
  valid_608083 = validateParameter(valid_608083, JString, required = false,
                                 default = nil)
  if valid_608083 != nil:
    section.add "X-Amz-Date", valid_608083
  var valid_608084 = header.getOrDefault("X-Amz-Credential")
  valid_608084 = validateParameter(valid_608084, JString, required = false,
                                 default = nil)
  if valid_608084 != nil:
    section.add "X-Amz-Credential", valid_608084
  var valid_608085 = header.getOrDefault("X-Amz-Security-Token")
  valid_608085 = validateParameter(valid_608085, JString, required = false,
                                 default = nil)
  if valid_608085 != nil:
    section.add "X-Amz-Security-Token", valid_608085
  var valid_608086 = header.getOrDefault("X-Amz-Algorithm")
  valid_608086 = validateParameter(valid_608086, JString, required = false,
                                 default = nil)
  if valid_608086 != nil:
    section.add "X-Amz-Algorithm", valid_608086
  var valid_608087 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608087 = validateParameter(valid_608087, JString, required = false,
                                 default = nil)
  if valid_608087 != nil:
    section.add "X-Amz-SignedHeaders", valid_608087
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608088: Call_DescribeJobExecution_608075; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a job execution.
  ## 
  let valid = call_608088.validator(path, query, header, formData, body)
  let scheme = call_608088.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608088.url(scheme.get, call_608088.host, call_608088.base,
                         call_608088.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608088, url, valid)

proc call*(call_608089: Call_DescribeJobExecution_608075; jobId: string;
          thingName: string; executionNumber: int = 0): Recallable =
  ## describeJobExecution
  ## Describes a job execution.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   executionNumber: int
  ##                  : A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
  ##   thingName: string (required)
  ##            : The name of the thing on which the job execution is running.
  var path_608090 = newJObject()
  var query_608091 = newJObject()
  add(path_608090, "jobId", newJString(jobId))
  add(query_608091, "executionNumber", newJInt(executionNumber))
  add(path_608090, "thingName", newJString(thingName))
  result = call_608089.call(path_608090, query_608091, nil, nil, nil)

var describeJobExecution* = Call_DescribeJobExecution_608075(
    name: "describeJobExecution", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs/{jobId}",
    validator: validate_DescribeJobExecution_608076, base: "/",
    url: url_DescribeJobExecution_608077, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DescribeThingRegistrationTask_608092 = ref object of OpenApiRestCall_605589
proc url_DescribeThingRegistrationTask_608094(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DescribeThingRegistrationTask_608093(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The task ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_608095 = path.getOrDefault("taskId")
  valid_608095 = validateParameter(valid_608095, JString, required = true,
                                 default = nil)
  if valid_608095 != nil:
    section.add "taskId", valid_608095
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608096 = header.getOrDefault("X-Amz-Signature")
  valid_608096 = validateParameter(valid_608096, JString, required = false,
                                 default = nil)
  if valid_608096 != nil:
    section.add "X-Amz-Signature", valid_608096
  var valid_608097 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608097 = validateParameter(valid_608097, JString, required = false,
                                 default = nil)
  if valid_608097 != nil:
    section.add "X-Amz-Content-Sha256", valid_608097
  var valid_608098 = header.getOrDefault("X-Amz-Date")
  valid_608098 = validateParameter(valid_608098, JString, required = false,
                                 default = nil)
  if valid_608098 != nil:
    section.add "X-Amz-Date", valid_608098
  var valid_608099 = header.getOrDefault("X-Amz-Credential")
  valid_608099 = validateParameter(valid_608099, JString, required = false,
                                 default = nil)
  if valid_608099 != nil:
    section.add "X-Amz-Credential", valid_608099
  var valid_608100 = header.getOrDefault("X-Amz-Security-Token")
  valid_608100 = validateParameter(valid_608100, JString, required = false,
                                 default = nil)
  if valid_608100 != nil:
    section.add "X-Amz-Security-Token", valid_608100
  var valid_608101 = header.getOrDefault("X-Amz-Algorithm")
  valid_608101 = validateParameter(valid_608101, JString, required = false,
                                 default = nil)
  if valid_608101 != nil:
    section.add "X-Amz-Algorithm", valid_608101
  var valid_608102 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608102 = validateParameter(valid_608102, JString, required = false,
                                 default = nil)
  if valid_608102 != nil:
    section.add "X-Amz-SignedHeaders", valid_608102
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608103: Call_DescribeThingRegistrationTask_608092; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes a bulk thing provisioning task.
  ## 
  let valid = call_608103.validator(path, query, header, formData, body)
  let scheme = call_608103.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608103.url(scheme.get, call_608103.host, call_608103.base,
                         call_608103.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608103, url, valid)

proc call*(call_608104: Call_DescribeThingRegistrationTask_608092; taskId: string): Recallable =
  ## describeThingRegistrationTask
  ## Describes a bulk thing provisioning task.
  ##   taskId: string (required)
  ##         : The task ID.
  var path_608105 = newJObject()
  add(path_608105, "taskId", newJString(taskId))
  result = call_608104.call(path_608105, nil, nil, nil, nil)

var describeThingRegistrationTask* = Call_DescribeThingRegistrationTask_608092(
    name: "describeThingRegistrationTask", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks/{taskId}",
    validator: validate_DescribeThingRegistrationTask_608093, base: "/",
    url: url_DescribeThingRegistrationTask_608094,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_DisableTopicRule_608106 = ref object of OpenApiRestCall_605589
proc url_DisableTopicRule_608108(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName"),
               (kind: ConstantSegment, value: "/disable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DisableTopicRule_608107(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Disables the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the rule to disable.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_608109 = path.getOrDefault("ruleName")
  valid_608109 = validateParameter(valid_608109, JString, required = true,
                                 default = nil)
  if valid_608109 != nil:
    section.add "ruleName", valid_608109
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608110 = header.getOrDefault("X-Amz-Signature")
  valid_608110 = validateParameter(valid_608110, JString, required = false,
                                 default = nil)
  if valid_608110 != nil:
    section.add "X-Amz-Signature", valid_608110
  var valid_608111 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608111 = validateParameter(valid_608111, JString, required = false,
                                 default = nil)
  if valid_608111 != nil:
    section.add "X-Amz-Content-Sha256", valid_608111
  var valid_608112 = header.getOrDefault("X-Amz-Date")
  valid_608112 = validateParameter(valid_608112, JString, required = false,
                                 default = nil)
  if valid_608112 != nil:
    section.add "X-Amz-Date", valid_608112
  var valid_608113 = header.getOrDefault("X-Amz-Credential")
  valid_608113 = validateParameter(valid_608113, JString, required = false,
                                 default = nil)
  if valid_608113 != nil:
    section.add "X-Amz-Credential", valid_608113
  var valid_608114 = header.getOrDefault("X-Amz-Security-Token")
  valid_608114 = validateParameter(valid_608114, JString, required = false,
                                 default = nil)
  if valid_608114 != nil:
    section.add "X-Amz-Security-Token", valid_608114
  var valid_608115 = header.getOrDefault("X-Amz-Algorithm")
  valid_608115 = validateParameter(valid_608115, JString, required = false,
                                 default = nil)
  if valid_608115 != nil:
    section.add "X-Amz-Algorithm", valid_608115
  var valid_608116 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608116 = validateParameter(valid_608116, JString, required = false,
                                 default = nil)
  if valid_608116 != nil:
    section.add "X-Amz-SignedHeaders", valid_608116
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608117: Call_DisableTopicRule_608106; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Disables the rule.
  ## 
  let valid = call_608117.validator(path, query, header, formData, body)
  let scheme = call_608117.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608117.url(scheme.get, call_608117.host, call_608117.base,
                         call_608117.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608117, url, valid)

proc call*(call_608118: Call_DisableTopicRule_608106; ruleName: string): Recallable =
  ## disableTopicRule
  ## Disables the rule.
  ##   ruleName: string (required)
  ##           : The name of the rule to disable.
  var path_608119 = newJObject()
  add(path_608119, "ruleName", newJString(ruleName))
  result = call_608118.call(path_608119, nil, nil, nil, nil)

var disableTopicRule* = Call_DisableTopicRule_608106(name: "disableTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}/disable", validator: validate_DisableTopicRule_608107,
    base: "/", url: url_DisableTopicRule_608108,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_EnableTopicRule_608120 = ref object of OpenApiRestCall_605589
proc url_EnableTopicRule_608122(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "ruleName" in path, "`ruleName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/rules/"),
               (kind: VariableSegment, value: "ruleName"),
               (kind: ConstantSegment, value: "/enable")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_EnableTopicRule_608121(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Enables the rule.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ruleName: JString (required)
  ##           : The name of the topic rule to enable.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ruleName` field"
  var valid_608123 = path.getOrDefault("ruleName")
  valid_608123 = validateParameter(valid_608123, JString, required = true,
                                 default = nil)
  if valid_608123 != nil:
    section.add "ruleName", valid_608123
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608124 = header.getOrDefault("X-Amz-Signature")
  valid_608124 = validateParameter(valid_608124, JString, required = false,
                                 default = nil)
  if valid_608124 != nil:
    section.add "X-Amz-Signature", valid_608124
  var valid_608125 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608125 = validateParameter(valid_608125, JString, required = false,
                                 default = nil)
  if valid_608125 != nil:
    section.add "X-Amz-Content-Sha256", valid_608125
  var valid_608126 = header.getOrDefault("X-Amz-Date")
  valid_608126 = validateParameter(valid_608126, JString, required = false,
                                 default = nil)
  if valid_608126 != nil:
    section.add "X-Amz-Date", valid_608126
  var valid_608127 = header.getOrDefault("X-Amz-Credential")
  valid_608127 = validateParameter(valid_608127, JString, required = false,
                                 default = nil)
  if valid_608127 != nil:
    section.add "X-Amz-Credential", valid_608127
  var valid_608128 = header.getOrDefault("X-Amz-Security-Token")
  valid_608128 = validateParameter(valid_608128, JString, required = false,
                                 default = nil)
  if valid_608128 != nil:
    section.add "X-Amz-Security-Token", valid_608128
  var valid_608129 = header.getOrDefault("X-Amz-Algorithm")
  valid_608129 = validateParameter(valid_608129, JString, required = false,
                                 default = nil)
  if valid_608129 != nil:
    section.add "X-Amz-Algorithm", valid_608129
  var valid_608130 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608130 = validateParameter(valid_608130, JString, required = false,
                                 default = nil)
  if valid_608130 != nil:
    section.add "X-Amz-SignedHeaders", valid_608130
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608131: Call_EnableTopicRule_608120; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the rule.
  ## 
  let valid = call_608131.validator(path, query, header, formData, body)
  let scheme = call_608131.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608131.url(scheme.get, call_608131.host, call_608131.base,
                         call_608131.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608131, url, valid)

proc call*(call_608132: Call_EnableTopicRule_608120; ruleName: string): Recallable =
  ## enableTopicRule
  ## Enables the rule.
  ##   ruleName: string (required)
  ##           : The name of the topic rule to enable.
  var path_608133 = newJObject()
  add(path_608133, "ruleName", newJString(ruleName))
  result = call_608132.call(path_608133, nil, nil, nil, nil)

var enableTopicRule* = Call_EnableTopicRule_608120(name: "enableTopicRule",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/rules/{ruleName}/enable", validator: validate_EnableTopicRule_608121,
    base: "/", url: url_EnableTopicRule_608122, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCardinality_608134 = ref object of OpenApiRestCall_605589
proc url_GetCardinality_608136(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCardinality_608135(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Returns the approximate count of unique values that match the query.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608137 = header.getOrDefault("X-Amz-Signature")
  valid_608137 = validateParameter(valid_608137, JString, required = false,
                                 default = nil)
  if valid_608137 != nil:
    section.add "X-Amz-Signature", valid_608137
  var valid_608138 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608138 = validateParameter(valid_608138, JString, required = false,
                                 default = nil)
  if valid_608138 != nil:
    section.add "X-Amz-Content-Sha256", valid_608138
  var valid_608139 = header.getOrDefault("X-Amz-Date")
  valid_608139 = validateParameter(valid_608139, JString, required = false,
                                 default = nil)
  if valid_608139 != nil:
    section.add "X-Amz-Date", valid_608139
  var valid_608140 = header.getOrDefault("X-Amz-Credential")
  valid_608140 = validateParameter(valid_608140, JString, required = false,
                                 default = nil)
  if valid_608140 != nil:
    section.add "X-Amz-Credential", valid_608140
  var valid_608141 = header.getOrDefault("X-Amz-Security-Token")
  valid_608141 = validateParameter(valid_608141, JString, required = false,
                                 default = nil)
  if valid_608141 != nil:
    section.add "X-Amz-Security-Token", valid_608141
  var valid_608142 = header.getOrDefault("X-Amz-Algorithm")
  valid_608142 = validateParameter(valid_608142, JString, required = false,
                                 default = nil)
  if valid_608142 != nil:
    section.add "X-Amz-Algorithm", valid_608142
  var valid_608143 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608143 = validateParameter(valid_608143, JString, required = false,
                                 default = nil)
  if valid_608143 != nil:
    section.add "X-Amz-SignedHeaders", valid_608143
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_608145: Call_GetCardinality_608134; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the approximate count of unique values that match the query.
  ## 
  let valid = call_608145.validator(path, query, header, formData, body)
  let scheme = call_608145.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608145.url(scheme.get, call_608145.host, call_608145.base,
                         call_608145.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608145, url, valid)

proc call*(call_608146: Call_GetCardinality_608134; body: JsonNode): Recallable =
  ## getCardinality
  ## Returns the approximate count of unique values that match the query.
  ##   body: JObject (required)
  var body_608147 = newJObject()
  if body != nil:
    body_608147 = body
  result = call_608146.call(nil, nil, nil, nil, body_608147)

var getCardinality* = Call_GetCardinality_608134(name: "getCardinality",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/cardinality", validator: validate_GetCardinality_608135,
    base: "/", url: url_GetCardinality_608136, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEffectivePolicies_608148 = ref object of OpenApiRestCall_605589
proc url_GetEffectivePolicies_608150(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEffectivePolicies_608149(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   thingName: JString
  ##            : The thing name.
  section = newJObject()
  var valid_608151 = query.getOrDefault("thingName")
  valid_608151 = validateParameter(valid_608151, JString, required = false,
                                 default = nil)
  if valid_608151 != nil:
    section.add "thingName", valid_608151
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608152 = header.getOrDefault("X-Amz-Signature")
  valid_608152 = validateParameter(valid_608152, JString, required = false,
                                 default = nil)
  if valid_608152 != nil:
    section.add "X-Amz-Signature", valid_608152
  var valid_608153 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608153 = validateParameter(valid_608153, JString, required = false,
                                 default = nil)
  if valid_608153 != nil:
    section.add "X-Amz-Content-Sha256", valid_608153
  var valid_608154 = header.getOrDefault("X-Amz-Date")
  valid_608154 = validateParameter(valid_608154, JString, required = false,
                                 default = nil)
  if valid_608154 != nil:
    section.add "X-Amz-Date", valid_608154
  var valid_608155 = header.getOrDefault("X-Amz-Credential")
  valid_608155 = validateParameter(valid_608155, JString, required = false,
                                 default = nil)
  if valid_608155 != nil:
    section.add "X-Amz-Credential", valid_608155
  var valid_608156 = header.getOrDefault("X-Amz-Security-Token")
  valid_608156 = validateParameter(valid_608156, JString, required = false,
                                 default = nil)
  if valid_608156 != nil:
    section.add "X-Amz-Security-Token", valid_608156
  var valid_608157 = header.getOrDefault("X-Amz-Algorithm")
  valid_608157 = validateParameter(valid_608157, JString, required = false,
                                 default = nil)
  if valid_608157 != nil:
    section.add "X-Amz-Algorithm", valid_608157
  var valid_608158 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608158 = validateParameter(valid_608158, JString, required = false,
                                 default = nil)
  if valid_608158 != nil:
    section.add "X-Amz-SignedHeaders", valid_608158
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_608160: Call_GetEffectivePolicies_608148; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ## 
  let valid = call_608160.validator(path, query, header, formData, body)
  let scheme = call_608160.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608160.url(scheme.get, call_608160.host, call_608160.base,
                         call_608160.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608160, url, valid)

proc call*(call_608161: Call_GetEffectivePolicies_608148; body: JsonNode;
          thingName: string = ""): Recallable =
  ## getEffectivePolicies
  ## Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.
  ##   thingName: string
  ##            : The thing name.
  ##   body: JObject (required)
  var query_608162 = newJObject()
  var body_608163 = newJObject()
  add(query_608162, "thingName", newJString(thingName))
  if body != nil:
    body_608163 = body
  result = call_608161.call(nil, query_608162, nil, nil, body_608163)

var getEffectivePolicies* = Call_GetEffectivePolicies_608148(
    name: "getEffectivePolicies", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/effective-policies",
    validator: validate_GetEffectivePolicies_608149, base: "/",
    url: url_GetEffectivePolicies_608150, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateIndexingConfiguration_608176 = ref object of OpenApiRestCall_605589
proc url_UpdateIndexingConfiguration_608178(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateIndexingConfiguration_608177(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the search configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608179 = header.getOrDefault("X-Amz-Signature")
  valid_608179 = validateParameter(valid_608179, JString, required = false,
                                 default = nil)
  if valid_608179 != nil:
    section.add "X-Amz-Signature", valid_608179
  var valid_608180 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608180 = validateParameter(valid_608180, JString, required = false,
                                 default = nil)
  if valid_608180 != nil:
    section.add "X-Amz-Content-Sha256", valid_608180
  var valid_608181 = header.getOrDefault("X-Amz-Date")
  valid_608181 = validateParameter(valid_608181, JString, required = false,
                                 default = nil)
  if valid_608181 != nil:
    section.add "X-Amz-Date", valid_608181
  var valid_608182 = header.getOrDefault("X-Amz-Credential")
  valid_608182 = validateParameter(valid_608182, JString, required = false,
                                 default = nil)
  if valid_608182 != nil:
    section.add "X-Amz-Credential", valid_608182
  var valid_608183 = header.getOrDefault("X-Amz-Security-Token")
  valid_608183 = validateParameter(valid_608183, JString, required = false,
                                 default = nil)
  if valid_608183 != nil:
    section.add "X-Amz-Security-Token", valid_608183
  var valid_608184 = header.getOrDefault("X-Amz-Algorithm")
  valid_608184 = validateParameter(valid_608184, JString, required = false,
                                 default = nil)
  if valid_608184 != nil:
    section.add "X-Amz-Algorithm", valid_608184
  var valid_608185 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608185 = validateParameter(valid_608185, JString, required = false,
                                 default = nil)
  if valid_608185 != nil:
    section.add "X-Amz-SignedHeaders", valid_608185
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_608187: Call_UpdateIndexingConfiguration_608176; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the search configuration.
  ## 
  let valid = call_608187.validator(path, query, header, formData, body)
  let scheme = call_608187.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608187.url(scheme.get, call_608187.host, call_608187.base,
                         call_608187.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608187, url, valid)

proc call*(call_608188: Call_UpdateIndexingConfiguration_608176; body: JsonNode): Recallable =
  ## updateIndexingConfiguration
  ## Updates the search configuration.
  ##   body: JObject (required)
  var body_608189 = newJObject()
  if body != nil:
    body_608189 = body
  result = call_608188.call(nil, nil, nil, nil, body_608189)

var updateIndexingConfiguration* = Call_UpdateIndexingConfiguration_608176(
    name: "updateIndexingConfiguration", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/indexing/config",
    validator: validate_UpdateIndexingConfiguration_608177, base: "/",
    url: url_UpdateIndexingConfiguration_608178,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetIndexingConfiguration_608164 = ref object of OpenApiRestCall_605589
proc url_GetIndexingConfiguration_608166(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetIndexingConfiguration_608165(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the indexing configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608167 = header.getOrDefault("X-Amz-Signature")
  valid_608167 = validateParameter(valid_608167, JString, required = false,
                                 default = nil)
  if valid_608167 != nil:
    section.add "X-Amz-Signature", valid_608167
  var valid_608168 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608168 = validateParameter(valid_608168, JString, required = false,
                                 default = nil)
  if valid_608168 != nil:
    section.add "X-Amz-Content-Sha256", valid_608168
  var valid_608169 = header.getOrDefault("X-Amz-Date")
  valid_608169 = validateParameter(valid_608169, JString, required = false,
                                 default = nil)
  if valid_608169 != nil:
    section.add "X-Amz-Date", valid_608169
  var valid_608170 = header.getOrDefault("X-Amz-Credential")
  valid_608170 = validateParameter(valid_608170, JString, required = false,
                                 default = nil)
  if valid_608170 != nil:
    section.add "X-Amz-Credential", valid_608170
  var valid_608171 = header.getOrDefault("X-Amz-Security-Token")
  valid_608171 = validateParameter(valid_608171, JString, required = false,
                                 default = nil)
  if valid_608171 != nil:
    section.add "X-Amz-Security-Token", valid_608171
  var valid_608172 = header.getOrDefault("X-Amz-Algorithm")
  valid_608172 = validateParameter(valid_608172, JString, required = false,
                                 default = nil)
  if valid_608172 != nil:
    section.add "X-Amz-Algorithm", valid_608172
  var valid_608173 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608173 = validateParameter(valid_608173, JString, required = false,
                                 default = nil)
  if valid_608173 != nil:
    section.add "X-Amz-SignedHeaders", valid_608173
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608174: Call_GetIndexingConfiguration_608164; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the indexing configuration.
  ## 
  let valid = call_608174.validator(path, query, header, formData, body)
  let scheme = call_608174.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608174.url(scheme.get, call_608174.host, call_608174.base,
                         call_608174.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608174, url, valid)

proc call*(call_608175: Call_GetIndexingConfiguration_608164): Recallable =
  ## getIndexingConfiguration
  ## Gets the indexing configuration.
  result = call_608175.call(nil, nil, nil, nil, nil)

var getIndexingConfiguration* = Call_GetIndexingConfiguration_608164(
    name: "getIndexingConfiguration", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/indexing/config",
    validator: validate_GetIndexingConfiguration_608165, base: "/",
    url: url_GetIndexingConfiguration_608166, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetJobDocument_608190 = ref object of OpenApiRestCall_605589
proc url_GetJobDocument_608192(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/job-document")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetJobDocument_608191(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets a job document.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_608193 = path.getOrDefault("jobId")
  valid_608193 = validateParameter(valid_608193, JString, required = true,
                                 default = nil)
  if valid_608193 != nil:
    section.add "jobId", valid_608193
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608194 = header.getOrDefault("X-Amz-Signature")
  valid_608194 = validateParameter(valid_608194, JString, required = false,
                                 default = nil)
  if valid_608194 != nil:
    section.add "X-Amz-Signature", valid_608194
  var valid_608195 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608195 = validateParameter(valid_608195, JString, required = false,
                                 default = nil)
  if valid_608195 != nil:
    section.add "X-Amz-Content-Sha256", valid_608195
  var valid_608196 = header.getOrDefault("X-Amz-Date")
  valid_608196 = validateParameter(valid_608196, JString, required = false,
                                 default = nil)
  if valid_608196 != nil:
    section.add "X-Amz-Date", valid_608196
  var valid_608197 = header.getOrDefault("X-Amz-Credential")
  valid_608197 = validateParameter(valid_608197, JString, required = false,
                                 default = nil)
  if valid_608197 != nil:
    section.add "X-Amz-Credential", valid_608197
  var valid_608198 = header.getOrDefault("X-Amz-Security-Token")
  valid_608198 = validateParameter(valid_608198, JString, required = false,
                                 default = nil)
  if valid_608198 != nil:
    section.add "X-Amz-Security-Token", valid_608198
  var valid_608199 = header.getOrDefault("X-Amz-Algorithm")
  valid_608199 = validateParameter(valid_608199, JString, required = false,
                                 default = nil)
  if valid_608199 != nil:
    section.add "X-Amz-Algorithm", valid_608199
  var valid_608200 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608200 = validateParameter(valid_608200, JString, required = false,
                                 default = nil)
  if valid_608200 != nil:
    section.add "X-Amz-SignedHeaders", valid_608200
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608201: Call_GetJobDocument_608190; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a job document.
  ## 
  let valid = call_608201.validator(path, query, header, formData, body)
  let scheme = call_608201.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608201.url(scheme.get, call_608201.host, call_608201.base,
                         call_608201.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608201, url, valid)

proc call*(call_608202: Call_GetJobDocument_608190; jobId: string): Recallable =
  ## getJobDocument
  ## Gets a job document.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  var path_608203 = newJObject()
  add(path_608203, "jobId", newJString(jobId))
  result = call_608202.call(path_608203, nil, nil, nil, nil)

var getJobDocument* = Call_GetJobDocument_608190(name: "getJobDocument",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/jobs/{jobId}/job-document", validator: validate_GetJobDocument_608191,
    base: "/", url: url_GetJobDocument_608192, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetLoggingOptions_608216 = ref object of OpenApiRestCall_605589
proc url_SetLoggingOptions_608218(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetLoggingOptions_608217(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608219 = header.getOrDefault("X-Amz-Signature")
  valid_608219 = validateParameter(valid_608219, JString, required = false,
                                 default = nil)
  if valid_608219 != nil:
    section.add "X-Amz-Signature", valid_608219
  var valid_608220 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608220 = validateParameter(valid_608220, JString, required = false,
                                 default = nil)
  if valid_608220 != nil:
    section.add "X-Amz-Content-Sha256", valid_608220
  var valid_608221 = header.getOrDefault("X-Amz-Date")
  valid_608221 = validateParameter(valid_608221, JString, required = false,
                                 default = nil)
  if valid_608221 != nil:
    section.add "X-Amz-Date", valid_608221
  var valid_608222 = header.getOrDefault("X-Amz-Credential")
  valid_608222 = validateParameter(valid_608222, JString, required = false,
                                 default = nil)
  if valid_608222 != nil:
    section.add "X-Amz-Credential", valid_608222
  var valid_608223 = header.getOrDefault("X-Amz-Security-Token")
  valid_608223 = validateParameter(valid_608223, JString, required = false,
                                 default = nil)
  if valid_608223 != nil:
    section.add "X-Amz-Security-Token", valid_608223
  var valid_608224 = header.getOrDefault("X-Amz-Algorithm")
  valid_608224 = validateParameter(valid_608224, JString, required = false,
                                 default = nil)
  if valid_608224 != nil:
    section.add "X-Amz-Algorithm", valid_608224
  var valid_608225 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608225 = validateParameter(valid_608225, JString, required = false,
                                 default = nil)
  if valid_608225 != nil:
    section.add "X-Amz-SignedHeaders", valid_608225
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_608227: Call_SetLoggingOptions_608216; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ## 
  let valid = call_608227.validator(path, query, header, formData, body)
  let scheme = call_608227.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608227.url(scheme.get, call_608227.host, call_608227.base,
                         call_608227.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608227, url, valid)

proc call*(call_608228: Call_SetLoggingOptions_608216; body: JsonNode): Recallable =
  ## setLoggingOptions
  ## <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
  ##   body: JObject (required)
  var body_608229 = newJObject()
  if body != nil:
    body_608229 = body
  result = call_608228.call(nil, nil, nil, nil, body_608229)

var setLoggingOptions* = Call_SetLoggingOptions_608216(name: "setLoggingOptions",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/loggingOptions",
    validator: validate_SetLoggingOptions_608217, base: "/",
    url: url_SetLoggingOptions_608218, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetLoggingOptions_608204 = ref object of OpenApiRestCall_605589
proc url_GetLoggingOptions_608206(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetLoggingOptions_608205(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608207 = header.getOrDefault("X-Amz-Signature")
  valid_608207 = validateParameter(valid_608207, JString, required = false,
                                 default = nil)
  if valid_608207 != nil:
    section.add "X-Amz-Signature", valid_608207
  var valid_608208 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608208 = validateParameter(valid_608208, JString, required = false,
                                 default = nil)
  if valid_608208 != nil:
    section.add "X-Amz-Content-Sha256", valid_608208
  var valid_608209 = header.getOrDefault("X-Amz-Date")
  valid_608209 = validateParameter(valid_608209, JString, required = false,
                                 default = nil)
  if valid_608209 != nil:
    section.add "X-Amz-Date", valid_608209
  var valid_608210 = header.getOrDefault("X-Amz-Credential")
  valid_608210 = validateParameter(valid_608210, JString, required = false,
                                 default = nil)
  if valid_608210 != nil:
    section.add "X-Amz-Credential", valid_608210
  var valid_608211 = header.getOrDefault("X-Amz-Security-Token")
  valid_608211 = validateParameter(valid_608211, JString, required = false,
                                 default = nil)
  if valid_608211 != nil:
    section.add "X-Amz-Security-Token", valid_608211
  var valid_608212 = header.getOrDefault("X-Amz-Algorithm")
  valid_608212 = validateParameter(valid_608212, JString, required = false,
                                 default = nil)
  if valid_608212 != nil:
    section.add "X-Amz-Algorithm", valid_608212
  var valid_608213 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608213 = validateParameter(valid_608213, JString, required = false,
                                 default = nil)
  if valid_608213 != nil:
    section.add "X-Amz-SignedHeaders", valid_608213
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608214: Call_GetLoggingOptions_608204; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  ## 
  let valid = call_608214.validator(path, query, header, formData, body)
  let scheme = call_608214.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608214.url(scheme.get, call_608214.host, call_608214.base,
                         call_608214.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608214, url, valid)

proc call*(call_608215: Call_GetLoggingOptions_608204): Recallable =
  ## getLoggingOptions
  ## <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
  result = call_608215.call(nil, nil, nil, nil, nil)

var getLoggingOptions* = Call_GetLoggingOptions_608204(name: "getLoggingOptions",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/loggingOptions",
    validator: validate_GetLoggingOptions_608205, base: "/",
    url: url_GetLoggingOptions_608206, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPercentiles_608230 = ref object of OpenApiRestCall_605589
proc url_GetPercentiles_608232(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetPercentiles_608231(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Groups the aggregated values that match the query into percentile groupings. The default percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own when you call <code>GetPercentiles</code>. This function returns a value for each percentile group specified (or the default percentile groupings). The percentile group "1" contains the aggregated field value that occurs in approximately one percent of the values that match the query. The percentile group "5" contains the aggregated field value that occurs in approximately five percent of the values that match the query, and so on. The result is an approximation, the more values that match the query, the more accurate the percentile values.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608233 = header.getOrDefault("X-Amz-Signature")
  valid_608233 = validateParameter(valid_608233, JString, required = false,
                                 default = nil)
  if valid_608233 != nil:
    section.add "X-Amz-Signature", valid_608233
  var valid_608234 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608234 = validateParameter(valid_608234, JString, required = false,
                                 default = nil)
  if valid_608234 != nil:
    section.add "X-Amz-Content-Sha256", valid_608234
  var valid_608235 = header.getOrDefault("X-Amz-Date")
  valid_608235 = validateParameter(valid_608235, JString, required = false,
                                 default = nil)
  if valid_608235 != nil:
    section.add "X-Amz-Date", valid_608235
  var valid_608236 = header.getOrDefault("X-Amz-Credential")
  valid_608236 = validateParameter(valid_608236, JString, required = false,
                                 default = nil)
  if valid_608236 != nil:
    section.add "X-Amz-Credential", valid_608236
  var valid_608237 = header.getOrDefault("X-Amz-Security-Token")
  valid_608237 = validateParameter(valid_608237, JString, required = false,
                                 default = nil)
  if valid_608237 != nil:
    section.add "X-Amz-Security-Token", valid_608237
  var valid_608238 = header.getOrDefault("X-Amz-Algorithm")
  valid_608238 = validateParameter(valid_608238, JString, required = false,
                                 default = nil)
  if valid_608238 != nil:
    section.add "X-Amz-Algorithm", valid_608238
  var valid_608239 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608239 = validateParameter(valid_608239, JString, required = false,
                                 default = nil)
  if valid_608239 != nil:
    section.add "X-Amz-SignedHeaders", valid_608239
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_608241: Call_GetPercentiles_608230; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Groups the aggregated values that match the query into percentile groupings. The default percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own when you call <code>GetPercentiles</code>. This function returns a value for each percentile group specified (or the default percentile groupings). The percentile group "1" contains the aggregated field value that occurs in approximately one percent of the values that match the query. The percentile group "5" contains the aggregated field value that occurs in approximately five percent of the values that match the query, and so on. The result is an approximation, the more values that match the query, the more accurate the percentile values.
  ## 
  let valid = call_608241.validator(path, query, header, formData, body)
  let scheme = call_608241.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608241.url(scheme.get, call_608241.host, call_608241.base,
                         call_608241.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608241, url, valid)

proc call*(call_608242: Call_GetPercentiles_608230; body: JsonNode): Recallable =
  ## getPercentiles
  ## Groups the aggregated values that match the query into percentile groupings. The default percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own when you call <code>GetPercentiles</code>. This function returns a value for each percentile group specified (or the default percentile groupings). The percentile group "1" contains the aggregated field value that occurs in approximately one percent of the values that match the query. The percentile group "5" contains the aggregated field value that occurs in approximately five percent of the values that match the query, and so on. The result is an approximation, the more values that match the query, the more accurate the percentile values.
  ##   body: JObject (required)
  var body_608243 = newJObject()
  if body != nil:
    body_608243 = body
  result = call_608242.call(nil, nil, nil, nil, body_608243)

var getPercentiles* = Call_GetPercentiles_608230(name: "getPercentiles",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/percentiles", validator: validate_GetPercentiles_608231,
    base: "/", url: url_GetPercentiles_608232, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetStatistics_608244 = ref object of OpenApiRestCall_605589
proc url_GetStatistics_608246(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetStatistics_608245(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the count, average, sum, minimum, maximum, sum of squares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type <code>String</code>, only the count statistic is returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608247 = header.getOrDefault("X-Amz-Signature")
  valid_608247 = validateParameter(valid_608247, JString, required = false,
                                 default = nil)
  if valid_608247 != nil:
    section.add "X-Amz-Signature", valid_608247
  var valid_608248 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608248 = validateParameter(valid_608248, JString, required = false,
                                 default = nil)
  if valid_608248 != nil:
    section.add "X-Amz-Content-Sha256", valid_608248
  var valid_608249 = header.getOrDefault("X-Amz-Date")
  valid_608249 = validateParameter(valid_608249, JString, required = false,
                                 default = nil)
  if valid_608249 != nil:
    section.add "X-Amz-Date", valid_608249
  var valid_608250 = header.getOrDefault("X-Amz-Credential")
  valid_608250 = validateParameter(valid_608250, JString, required = false,
                                 default = nil)
  if valid_608250 != nil:
    section.add "X-Amz-Credential", valid_608250
  var valid_608251 = header.getOrDefault("X-Amz-Security-Token")
  valid_608251 = validateParameter(valid_608251, JString, required = false,
                                 default = nil)
  if valid_608251 != nil:
    section.add "X-Amz-Security-Token", valid_608251
  var valid_608252 = header.getOrDefault("X-Amz-Algorithm")
  valid_608252 = validateParameter(valid_608252, JString, required = false,
                                 default = nil)
  if valid_608252 != nil:
    section.add "X-Amz-Algorithm", valid_608252
  var valid_608253 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608253 = validateParameter(valid_608253, JString, required = false,
                                 default = nil)
  if valid_608253 != nil:
    section.add "X-Amz-SignedHeaders", valid_608253
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_608255: Call_GetStatistics_608244; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the count, average, sum, minimum, maximum, sum of squares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type <code>String</code>, only the count statistic is returned.
  ## 
  let valid = call_608255.validator(path, query, header, formData, body)
  let scheme = call_608255.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608255.url(scheme.get, call_608255.host, call_608255.base,
                         call_608255.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608255, url, valid)

proc call*(call_608256: Call_GetStatistics_608244; body: JsonNode): Recallable =
  ## getStatistics
  ## Returns the count, average, sum, minimum, maximum, sum of squares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type <code>String</code>, only the count statistic is returned.
  ##   body: JObject (required)
  var body_608257 = newJObject()
  if body != nil:
    body_608257 = body
  result = call_608256.call(nil, nil, nil, nil, body_608257)

var getStatistics* = Call_GetStatistics_608244(name: "getStatistics",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/indices/statistics", validator: validate_GetStatistics_608245,
    base: "/", url: url_GetStatistics_608246, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetV2LoggingOptions_608270 = ref object of OpenApiRestCall_605589
proc url_SetV2LoggingOptions_608272(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetV2LoggingOptions_608271(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Sets the logging options for the V2 logging service.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608273 = header.getOrDefault("X-Amz-Signature")
  valid_608273 = validateParameter(valid_608273, JString, required = false,
                                 default = nil)
  if valid_608273 != nil:
    section.add "X-Amz-Signature", valid_608273
  var valid_608274 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608274 = validateParameter(valid_608274, JString, required = false,
                                 default = nil)
  if valid_608274 != nil:
    section.add "X-Amz-Content-Sha256", valid_608274
  var valid_608275 = header.getOrDefault("X-Amz-Date")
  valid_608275 = validateParameter(valid_608275, JString, required = false,
                                 default = nil)
  if valid_608275 != nil:
    section.add "X-Amz-Date", valid_608275
  var valid_608276 = header.getOrDefault("X-Amz-Credential")
  valid_608276 = validateParameter(valid_608276, JString, required = false,
                                 default = nil)
  if valid_608276 != nil:
    section.add "X-Amz-Credential", valid_608276
  var valid_608277 = header.getOrDefault("X-Amz-Security-Token")
  valid_608277 = validateParameter(valid_608277, JString, required = false,
                                 default = nil)
  if valid_608277 != nil:
    section.add "X-Amz-Security-Token", valid_608277
  var valid_608278 = header.getOrDefault("X-Amz-Algorithm")
  valid_608278 = validateParameter(valid_608278, JString, required = false,
                                 default = nil)
  if valid_608278 != nil:
    section.add "X-Amz-Algorithm", valid_608278
  var valid_608279 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608279 = validateParameter(valid_608279, JString, required = false,
                                 default = nil)
  if valid_608279 != nil:
    section.add "X-Amz-SignedHeaders", valid_608279
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_608281: Call_SetV2LoggingOptions_608270; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the logging options for the V2 logging service.
  ## 
  let valid = call_608281.validator(path, query, header, formData, body)
  let scheme = call_608281.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608281.url(scheme.get, call_608281.host, call_608281.base,
                         call_608281.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608281, url, valid)

proc call*(call_608282: Call_SetV2LoggingOptions_608270; body: JsonNode): Recallable =
  ## setV2LoggingOptions
  ## Sets the logging options for the V2 logging service.
  ##   body: JObject (required)
  var body_608283 = newJObject()
  if body != nil:
    body_608283 = body
  result = call_608282.call(nil, nil, nil, nil, body_608283)

var setV2LoggingOptions* = Call_SetV2LoggingOptions_608270(
    name: "setV2LoggingOptions", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/v2LoggingOptions",
    validator: validate_SetV2LoggingOptions_608271, base: "/",
    url: url_SetV2LoggingOptions_608272, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetV2LoggingOptions_608258 = ref object of OpenApiRestCall_605589
proc url_GetV2LoggingOptions_608260(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetV2LoggingOptions_608259(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets the fine grained logging options.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608261 = header.getOrDefault("X-Amz-Signature")
  valid_608261 = validateParameter(valid_608261, JString, required = false,
                                 default = nil)
  if valid_608261 != nil:
    section.add "X-Amz-Signature", valid_608261
  var valid_608262 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608262 = validateParameter(valid_608262, JString, required = false,
                                 default = nil)
  if valid_608262 != nil:
    section.add "X-Amz-Content-Sha256", valid_608262
  var valid_608263 = header.getOrDefault("X-Amz-Date")
  valid_608263 = validateParameter(valid_608263, JString, required = false,
                                 default = nil)
  if valid_608263 != nil:
    section.add "X-Amz-Date", valid_608263
  var valid_608264 = header.getOrDefault("X-Amz-Credential")
  valid_608264 = validateParameter(valid_608264, JString, required = false,
                                 default = nil)
  if valid_608264 != nil:
    section.add "X-Amz-Credential", valid_608264
  var valid_608265 = header.getOrDefault("X-Amz-Security-Token")
  valid_608265 = validateParameter(valid_608265, JString, required = false,
                                 default = nil)
  if valid_608265 != nil:
    section.add "X-Amz-Security-Token", valid_608265
  var valid_608266 = header.getOrDefault("X-Amz-Algorithm")
  valid_608266 = validateParameter(valid_608266, JString, required = false,
                                 default = nil)
  if valid_608266 != nil:
    section.add "X-Amz-Algorithm", valid_608266
  var valid_608267 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608267 = validateParameter(valid_608267, JString, required = false,
                                 default = nil)
  if valid_608267 != nil:
    section.add "X-Amz-SignedHeaders", valid_608267
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608268: Call_GetV2LoggingOptions_608258; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the fine grained logging options.
  ## 
  let valid = call_608268.validator(path, query, header, formData, body)
  let scheme = call_608268.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608268.url(scheme.get, call_608268.host, call_608268.base,
                         call_608268.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608268, url, valid)

proc call*(call_608269: Call_GetV2LoggingOptions_608258): Recallable =
  ## getV2LoggingOptions
  ## Gets the fine grained logging options.
  result = call_608269.call(nil, nil, nil, nil, nil)

var getV2LoggingOptions* = Call_GetV2LoggingOptions_608258(
    name: "getV2LoggingOptions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/v2LoggingOptions",
    validator: validate_GetV2LoggingOptions_608259, base: "/",
    url: url_GetV2LoggingOptions_608260, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListActiveViolations_608284 = ref object of OpenApiRestCall_605589
proc url_ListActiveViolations_608286(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListActiveViolations_608285(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the active violations for a given Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   securityProfileName: JString
  ##                      : The name of the Device Defender security profile for which violations are listed.
  ##   thingName: JString
  ##            : The name of the thing whose active violations are listed.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_608287 = query.getOrDefault("nextToken")
  valid_608287 = validateParameter(valid_608287, JString, required = false,
                                 default = nil)
  if valid_608287 != nil:
    section.add "nextToken", valid_608287
  var valid_608288 = query.getOrDefault("securityProfileName")
  valid_608288 = validateParameter(valid_608288, JString, required = false,
                                 default = nil)
  if valid_608288 != nil:
    section.add "securityProfileName", valid_608288
  var valid_608289 = query.getOrDefault("thingName")
  valid_608289 = validateParameter(valid_608289, JString, required = false,
                                 default = nil)
  if valid_608289 != nil:
    section.add "thingName", valid_608289
  var valid_608290 = query.getOrDefault("maxResults")
  valid_608290 = validateParameter(valid_608290, JInt, required = false, default = nil)
  if valid_608290 != nil:
    section.add "maxResults", valid_608290
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608291 = header.getOrDefault("X-Amz-Signature")
  valid_608291 = validateParameter(valid_608291, JString, required = false,
                                 default = nil)
  if valid_608291 != nil:
    section.add "X-Amz-Signature", valid_608291
  var valid_608292 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608292 = validateParameter(valid_608292, JString, required = false,
                                 default = nil)
  if valid_608292 != nil:
    section.add "X-Amz-Content-Sha256", valid_608292
  var valid_608293 = header.getOrDefault("X-Amz-Date")
  valid_608293 = validateParameter(valid_608293, JString, required = false,
                                 default = nil)
  if valid_608293 != nil:
    section.add "X-Amz-Date", valid_608293
  var valid_608294 = header.getOrDefault("X-Amz-Credential")
  valid_608294 = validateParameter(valid_608294, JString, required = false,
                                 default = nil)
  if valid_608294 != nil:
    section.add "X-Amz-Credential", valid_608294
  var valid_608295 = header.getOrDefault("X-Amz-Security-Token")
  valid_608295 = validateParameter(valid_608295, JString, required = false,
                                 default = nil)
  if valid_608295 != nil:
    section.add "X-Amz-Security-Token", valid_608295
  var valid_608296 = header.getOrDefault("X-Amz-Algorithm")
  valid_608296 = validateParameter(valid_608296, JString, required = false,
                                 default = nil)
  if valid_608296 != nil:
    section.add "X-Amz-Algorithm", valid_608296
  var valid_608297 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608297 = validateParameter(valid_608297, JString, required = false,
                                 default = nil)
  if valid_608297 != nil:
    section.add "X-Amz-SignedHeaders", valid_608297
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608298: Call_ListActiveViolations_608284; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the active violations for a given Device Defender security profile.
  ## 
  let valid = call_608298.validator(path, query, header, formData, body)
  let scheme = call_608298.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608298.url(scheme.get, call_608298.host, call_608298.base,
                         call_608298.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608298, url, valid)

proc call*(call_608299: Call_ListActiveViolations_608284; nextToken: string = "";
          securityProfileName: string = ""; thingName: string = ""; maxResults: int = 0): Recallable =
  ## listActiveViolations
  ## Lists the active violations for a given Device Defender security profile.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string
  ##                      : The name of the Device Defender security profile for which violations are listed.
  ##   thingName: string
  ##            : The name of the thing whose active violations are listed.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_608300 = newJObject()
  add(query_608300, "nextToken", newJString(nextToken))
  add(query_608300, "securityProfileName", newJString(securityProfileName))
  add(query_608300, "thingName", newJString(thingName))
  add(query_608300, "maxResults", newJInt(maxResults))
  result = call_608299.call(nil, query_608300, nil, nil, nil)

var listActiveViolations* = Call_ListActiveViolations_608284(
    name: "listActiveViolations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/active-violations",
    validator: validate_ListActiveViolations_608285, base: "/",
    url: url_ListActiveViolations_608286, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAttachedPolicies_608301 = ref object of OpenApiRestCall_605589
proc url_ListAttachedPolicies_608303(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "target" in path, "`target` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/attached-policies/"),
               (kind: VariableSegment, value: "target")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListAttachedPolicies_608302(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the policies attached to the specified thing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   target: JString (required)
  ##         : The group or principal for which the policies will be listed.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `target` field"
  var valid_608304 = path.getOrDefault("target")
  valid_608304 = validateParameter(valid_608304, JString, required = true,
                                 default = nil)
  if valid_608304 != nil:
    section.add "target", valid_608304
  result.add "path", section
  ## parameters in `query` object:
  ##   pageSize: JInt
  ##           : The maximum number of results to be returned per request.
  ##   recursive: JBool
  ##            : When true, recursively list attached policies.
  ##   marker: JString
  ##         : The token to retrieve the next set of results.
  section = newJObject()
  var valid_608305 = query.getOrDefault("pageSize")
  valid_608305 = validateParameter(valid_608305, JInt, required = false, default = nil)
  if valid_608305 != nil:
    section.add "pageSize", valid_608305
  var valid_608306 = query.getOrDefault("recursive")
  valid_608306 = validateParameter(valid_608306, JBool, required = false, default = nil)
  if valid_608306 != nil:
    section.add "recursive", valid_608306
  var valid_608307 = query.getOrDefault("marker")
  valid_608307 = validateParameter(valid_608307, JString, required = false,
                                 default = nil)
  if valid_608307 != nil:
    section.add "marker", valid_608307
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608308 = header.getOrDefault("X-Amz-Signature")
  valid_608308 = validateParameter(valid_608308, JString, required = false,
                                 default = nil)
  if valid_608308 != nil:
    section.add "X-Amz-Signature", valid_608308
  var valid_608309 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608309 = validateParameter(valid_608309, JString, required = false,
                                 default = nil)
  if valid_608309 != nil:
    section.add "X-Amz-Content-Sha256", valid_608309
  var valid_608310 = header.getOrDefault("X-Amz-Date")
  valid_608310 = validateParameter(valid_608310, JString, required = false,
                                 default = nil)
  if valid_608310 != nil:
    section.add "X-Amz-Date", valid_608310
  var valid_608311 = header.getOrDefault("X-Amz-Credential")
  valid_608311 = validateParameter(valid_608311, JString, required = false,
                                 default = nil)
  if valid_608311 != nil:
    section.add "X-Amz-Credential", valid_608311
  var valid_608312 = header.getOrDefault("X-Amz-Security-Token")
  valid_608312 = validateParameter(valid_608312, JString, required = false,
                                 default = nil)
  if valid_608312 != nil:
    section.add "X-Amz-Security-Token", valid_608312
  var valid_608313 = header.getOrDefault("X-Amz-Algorithm")
  valid_608313 = validateParameter(valid_608313, JString, required = false,
                                 default = nil)
  if valid_608313 != nil:
    section.add "X-Amz-Algorithm", valid_608313
  var valid_608314 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608314 = validateParameter(valid_608314, JString, required = false,
                                 default = nil)
  if valid_608314 != nil:
    section.add "X-Amz-SignedHeaders", valid_608314
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608315: Call_ListAttachedPolicies_608301; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the policies attached to the specified thing group.
  ## 
  let valid = call_608315.validator(path, query, header, formData, body)
  let scheme = call_608315.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608315.url(scheme.get, call_608315.host, call_608315.base,
                         call_608315.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608315, url, valid)

proc call*(call_608316: Call_ListAttachedPolicies_608301; target: string;
          pageSize: int = 0; recursive: bool = false; marker: string = ""): Recallable =
  ## listAttachedPolicies
  ## Lists the policies attached to the specified thing group.
  ##   pageSize: int
  ##           : The maximum number of results to be returned per request.
  ##   recursive: bool
  ##            : When true, recursively list attached policies.
  ##   target: string (required)
  ##         : The group or principal for which the policies will be listed.
  ##   marker: string
  ##         : The token to retrieve the next set of results.
  var path_608317 = newJObject()
  var query_608318 = newJObject()
  add(query_608318, "pageSize", newJInt(pageSize))
  add(query_608318, "recursive", newJBool(recursive))
  add(path_608317, "target", newJString(target))
  add(query_608318, "marker", newJString(marker))
  result = call_608316.call(path_608317, query_608318, nil, nil, nil)

var listAttachedPolicies* = Call_ListAttachedPolicies_608301(
    name: "listAttachedPolicies", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/attached-policies/{target}",
    validator: validate_ListAttachedPolicies_608302, base: "/",
    url: url_ListAttachedPolicies_608303, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditFindings_608319 = ref object of OpenApiRestCall_605589
proc url_ListAuditFindings_608321(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditFindings_608320(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608322 = header.getOrDefault("X-Amz-Signature")
  valid_608322 = validateParameter(valid_608322, JString, required = false,
                                 default = nil)
  if valid_608322 != nil:
    section.add "X-Amz-Signature", valid_608322
  var valid_608323 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608323 = validateParameter(valid_608323, JString, required = false,
                                 default = nil)
  if valid_608323 != nil:
    section.add "X-Amz-Content-Sha256", valid_608323
  var valid_608324 = header.getOrDefault("X-Amz-Date")
  valid_608324 = validateParameter(valid_608324, JString, required = false,
                                 default = nil)
  if valid_608324 != nil:
    section.add "X-Amz-Date", valid_608324
  var valid_608325 = header.getOrDefault("X-Amz-Credential")
  valid_608325 = validateParameter(valid_608325, JString, required = false,
                                 default = nil)
  if valid_608325 != nil:
    section.add "X-Amz-Credential", valid_608325
  var valid_608326 = header.getOrDefault("X-Amz-Security-Token")
  valid_608326 = validateParameter(valid_608326, JString, required = false,
                                 default = nil)
  if valid_608326 != nil:
    section.add "X-Amz-Security-Token", valid_608326
  var valid_608327 = header.getOrDefault("X-Amz-Algorithm")
  valid_608327 = validateParameter(valid_608327, JString, required = false,
                                 default = nil)
  if valid_608327 != nil:
    section.add "X-Amz-Algorithm", valid_608327
  var valid_608328 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608328 = validateParameter(valid_608328, JString, required = false,
                                 default = nil)
  if valid_608328 != nil:
    section.add "X-Amz-SignedHeaders", valid_608328
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_608330: Call_ListAuditFindings_608319; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ## 
  let valid = call_608330.validator(path, query, header, formData, body)
  let scheme = call_608330.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608330.url(scheme.get, call_608330.host, call_608330.base,
                         call_608330.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608330, url, valid)

proc call*(call_608331: Call_ListAuditFindings_608319; body: JsonNode): Recallable =
  ## listAuditFindings
  ## Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)
  ##   body: JObject (required)
  var body_608332 = newJObject()
  if body != nil:
    body_608332 = body
  result = call_608331.call(nil, nil, nil, nil, body_608332)

var listAuditFindings* = Call_ListAuditFindings_608319(name: "listAuditFindings",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/audit/findings",
    validator: validate_ListAuditFindings_608320, base: "/",
    url: url_ListAuditFindings_608321, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditMitigationActionsExecutions_608333 = ref object of OpenApiRestCall_605589
proc url_ListAuditMitigationActionsExecutions_608335(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditMitigationActionsExecutions_608334(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the status of audit mitigation action tasks that were executed.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   actionStatus: JString
  ##               : Specify this filter to limit results to those with a specific status.
  ##   taskId: JString (required)
  ##         : Specify this filter to limit results to actions for a specific audit mitigation actions task.
  ##   findingId: JString (required)
  ##            : Specify this filter to limit results to those that were applied to a specific audit finding.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  var valid_608336 = query.getOrDefault("nextToken")
  valid_608336 = validateParameter(valid_608336, JString, required = false,
                                 default = nil)
  if valid_608336 != nil:
    section.add "nextToken", valid_608336
  var valid_608337 = query.getOrDefault("actionStatus")
  valid_608337 = validateParameter(valid_608337, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_608337 != nil:
    section.add "actionStatus", valid_608337
  assert query != nil, "query argument is necessary due to required `taskId` field"
  var valid_608338 = query.getOrDefault("taskId")
  valid_608338 = validateParameter(valid_608338, JString, required = true,
                                 default = nil)
  if valid_608338 != nil:
    section.add "taskId", valid_608338
  var valid_608339 = query.getOrDefault("findingId")
  valid_608339 = validateParameter(valid_608339, JString, required = true,
                                 default = nil)
  if valid_608339 != nil:
    section.add "findingId", valid_608339
  var valid_608340 = query.getOrDefault("maxResults")
  valid_608340 = validateParameter(valid_608340, JInt, required = false, default = nil)
  if valid_608340 != nil:
    section.add "maxResults", valid_608340
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608341 = header.getOrDefault("X-Amz-Signature")
  valid_608341 = validateParameter(valid_608341, JString, required = false,
                                 default = nil)
  if valid_608341 != nil:
    section.add "X-Amz-Signature", valid_608341
  var valid_608342 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608342 = validateParameter(valid_608342, JString, required = false,
                                 default = nil)
  if valid_608342 != nil:
    section.add "X-Amz-Content-Sha256", valid_608342
  var valid_608343 = header.getOrDefault("X-Amz-Date")
  valid_608343 = validateParameter(valid_608343, JString, required = false,
                                 default = nil)
  if valid_608343 != nil:
    section.add "X-Amz-Date", valid_608343
  var valid_608344 = header.getOrDefault("X-Amz-Credential")
  valid_608344 = validateParameter(valid_608344, JString, required = false,
                                 default = nil)
  if valid_608344 != nil:
    section.add "X-Amz-Credential", valid_608344
  var valid_608345 = header.getOrDefault("X-Amz-Security-Token")
  valid_608345 = validateParameter(valid_608345, JString, required = false,
                                 default = nil)
  if valid_608345 != nil:
    section.add "X-Amz-Security-Token", valid_608345
  var valid_608346 = header.getOrDefault("X-Amz-Algorithm")
  valid_608346 = validateParameter(valid_608346, JString, required = false,
                                 default = nil)
  if valid_608346 != nil:
    section.add "X-Amz-Algorithm", valid_608346
  var valid_608347 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608347 = validateParameter(valid_608347, JString, required = false,
                                 default = nil)
  if valid_608347 != nil:
    section.add "X-Amz-SignedHeaders", valid_608347
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608348: Call_ListAuditMitigationActionsExecutions_608333;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the status of audit mitigation action tasks that were executed.
  ## 
  let valid = call_608348.validator(path, query, header, formData, body)
  let scheme = call_608348.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608348.url(scheme.get, call_608348.host, call_608348.base,
                         call_608348.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608348, url, valid)

proc call*(call_608349: Call_ListAuditMitigationActionsExecutions_608333;
          taskId: string; findingId: string; nextToken: string = "";
          actionStatus: string = "IN_PROGRESS"; maxResults: int = 0): Recallable =
  ## listAuditMitigationActionsExecutions
  ## Gets the status of audit mitigation action tasks that were executed.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   actionStatus: string
  ##               : Specify this filter to limit results to those with a specific status.
  ##   taskId: string (required)
  ##         : Specify this filter to limit results to actions for a specific audit mitigation actions task.
  ##   findingId: string (required)
  ##            : Specify this filter to limit results to those that were applied to a specific audit finding.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_608350 = newJObject()
  add(query_608350, "nextToken", newJString(nextToken))
  add(query_608350, "actionStatus", newJString(actionStatus))
  add(query_608350, "taskId", newJString(taskId))
  add(query_608350, "findingId", newJString(findingId))
  add(query_608350, "maxResults", newJInt(maxResults))
  result = call_608349.call(nil, query_608350, nil, nil, nil)

var listAuditMitigationActionsExecutions* = Call_ListAuditMitigationActionsExecutions_608333(
    name: "listAuditMitigationActionsExecutions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/executions#taskId&findingId",
    validator: validate_ListAuditMitigationActionsExecutions_608334, base: "/",
    url: url_ListAuditMitigationActionsExecutions_608335,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditMitigationActionsTasks_608351 = ref object of OpenApiRestCall_605589
proc url_ListAuditMitigationActionsTasks_608353(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditMitigationActionsTasks_608352(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endTime: JString (required)
  ##          : Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : Specify this filter to limit results to tasks that began on or after a specific date and time.
  ##   findingId: JString
  ##            : Specify this filter to limit results to tasks that were applied to a specific audit finding.
  ##   taskStatus: JString
  ##             : Specify this filter to limit results to tasks that are in a specific state.
  ##   auditTaskId: JString
  ##              : Specify this filter to limit results to tasks that were applied to results for a specific audit.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_608354 = query.getOrDefault("endTime")
  valid_608354 = validateParameter(valid_608354, JString, required = true,
                                 default = nil)
  if valid_608354 != nil:
    section.add "endTime", valid_608354
  var valid_608355 = query.getOrDefault("nextToken")
  valid_608355 = validateParameter(valid_608355, JString, required = false,
                                 default = nil)
  if valid_608355 != nil:
    section.add "nextToken", valid_608355
  var valid_608356 = query.getOrDefault("startTime")
  valid_608356 = validateParameter(valid_608356, JString, required = true,
                                 default = nil)
  if valid_608356 != nil:
    section.add "startTime", valid_608356
  var valid_608357 = query.getOrDefault("findingId")
  valid_608357 = validateParameter(valid_608357, JString, required = false,
                                 default = nil)
  if valid_608357 != nil:
    section.add "findingId", valid_608357
  var valid_608358 = query.getOrDefault("taskStatus")
  valid_608358 = validateParameter(valid_608358, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_608358 != nil:
    section.add "taskStatus", valid_608358
  var valid_608359 = query.getOrDefault("auditTaskId")
  valid_608359 = validateParameter(valid_608359, JString, required = false,
                                 default = nil)
  if valid_608359 != nil:
    section.add "auditTaskId", valid_608359
  var valid_608360 = query.getOrDefault("maxResults")
  valid_608360 = validateParameter(valid_608360, JInt, required = false, default = nil)
  if valid_608360 != nil:
    section.add "maxResults", valid_608360
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608361 = header.getOrDefault("X-Amz-Signature")
  valid_608361 = validateParameter(valid_608361, JString, required = false,
                                 default = nil)
  if valid_608361 != nil:
    section.add "X-Amz-Signature", valid_608361
  var valid_608362 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608362 = validateParameter(valid_608362, JString, required = false,
                                 default = nil)
  if valid_608362 != nil:
    section.add "X-Amz-Content-Sha256", valid_608362
  var valid_608363 = header.getOrDefault("X-Amz-Date")
  valid_608363 = validateParameter(valid_608363, JString, required = false,
                                 default = nil)
  if valid_608363 != nil:
    section.add "X-Amz-Date", valid_608363
  var valid_608364 = header.getOrDefault("X-Amz-Credential")
  valid_608364 = validateParameter(valid_608364, JString, required = false,
                                 default = nil)
  if valid_608364 != nil:
    section.add "X-Amz-Credential", valid_608364
  var valid_608365 = header.getOrDefault("X-Amz-Security-Token")
  valid_608365 = validateParameter(valid_608365, JString, required = false,
                                 default = nil)
  if valid_608365 != nil:
    section.add "X-Amz-Security-Token", valid_608365
  var valid_608366 = header.getOrDefault("X-Amz-Algorithm")
  valid_608366 = validateParameter(valid_608366, JString, required = false,
                                 default = nil)
  if valid_608366 != nil:
    section.add "X-Amz-Algorithm", valid_608366
  var valid_608367 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608367 = validateParameter(valid_608367, JString, required = false,
                                 default = nil)
  if valid_608367 != nil:
    section.add "X-Amz-SignedHeaders", valid_608367
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608368: Call_ListAuditMitigationActionsTasks_608351;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ## 
  let valid = call_608368.validator(path, query, header, formData, body)
  let scheme = call_608368.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608368.url(scheme.get, call_608368.host, call_608368.base,
                         call_608368.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608368, url, valid)

proc call*(call_608369: Call_ListAuditMitigationActionsTasks_608351;
          endTime: string; startTime: string; nextToken: string = "";
          findingId: string = ""; taskStatus: string = "IN_PROGRESS";
          auditTaskId: string = ""; maxResults: int = 0): Recallable =
  ## listAuditMitigationActionsTasks
  ## Gets a list of audit mitigation action tasks that match the specified filters.
  ##   endTime: string (required)
  ##          : Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : Specify this filter to limit results to tasks that began on or after a specific date and time.
  ##   findingId: string
  ##            : Specify this filter to limit results to tasks that were applied to a specific audit finding.
  ##   taskStatus: string
  ##             : Specify this filter to limit results to tasks that are in a specific state.
  ##   auditTaskId: string
  ##              : Specify this filter to limit results to tasks that were applied to results for a specific audit.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_608370 = newJObject()
  add(query_608370, "endTime", newJString(endTime))
  add(query_608370, "nextToken", newJString(nextToken))
  add(query_608370, "startTime", newJString(startTime))
  add(query_608370, "findingId", newJString(findingId))
  add(query_608370, "taskStatus", newJString(taskStatus))
  add(query_608370, "auditTaskId", newJString(auditTaskId))
  add(query_608370, "maxResults", newJInt(maxResults))
  result = call_608369.call(nil, query_608370, nil, nil, nil)

var listAuditMitigationActionsTasks* = Call_ListAuditMitigationActionsTasks_608351(
    name: "listAuditMitigationActionsTasks", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/audit/mitigationactions/tasks#startTime&endTime",
    validator: validate_ListAuditMitigationActionsTasks_608352, base: "/",
    url: url_ListAuditMitigationActionsTasks_608353,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuditTasks_608371 = ref object of OpenApiRestCall_605589
proc url_ListAuditTasks_608373(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuditTasks_608372(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the Device Defender audits that have been performed during a given time period.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endTime: JString (required)
  ##          : The end of the time period.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
  ##   taskStatus: JString
  ##             : A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
  ##   taskType: JString
  ##           : A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_608374 = query.getOrDefault("endTime")
  valid_608374 = validateParameter(valid_608374, JString, required = true,
                                 default = nil)
  if valid_608374 != nil:
    section.add "endTime", valid_608374
  var valid_608375 = query.getOrDefault("nextToken")
  valid_608375 = validateParameter(valid_608375, JString, required = false,
                                 default = nil)
  if valid_608375 != nil:
    section.add "nextToken", valid_608375
  var valid_608376 = query.getOrDefault("startTime")
  valid_608376 = validateParameter(valid_608376, JString, required = true,
                                 default = nil)
  if valid_608376 != nil:
    section.add "startTime", valid_608376
  var valid_608377 = query.getOrDefault("taskStatus")
  valid_608377 = validateParameter(valid_608377, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_608377 != nil:
    section.add "taskStatus", valid_608377
  var valid_608378 = query.getOrDefault("taskType")
  valid_608378 = validateParameter(valid_608378, JString, required = false,
                                 default = newJString("ON_DEMAND_AUDIT_TASK"))
  if valid_608378 != nil:
    section.add "taskType", valid_608378
  var valid_608379 = query.getOrDefault("maxResults")
  valid_608379 = validateParameter(valid_608379, JInt, required = false, default = nil)
  if valid_608379 != nil:
    section.add "maxResults", valid_608379
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608380 = header.getOrDefault("X-Amz-Signature")
  valid_608380 = validateParameter(valid_608380, JString, required = false,
                                 default = nil)
  if valid_608380 != nil:
    section.add "X-Amz-Signature", valid_608380
  var valid_608381 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608381 = validateParameter(valid_608381, JString, required = false,
                                 default = nil)
  if valid_608381 != nil:
    section.add "X-Amz-Content-Sha256", valid_608381
  var valid_608382 = header.getOrDefault("X-Amz-Date")
  valid_608382 = validateParameter(valid_608382, JString, required = false,
                                 default = nil)
  if valid_608382 != nil:
    section.add "X-Amz-Date", valid_608382
  var valid_608383 = header.getOrDefault("X-Amz-Credential")
  valid_608383 = validateParameter(valid_608383, JString, required = false,
                                 default = nil)
  if valid_608383 != nil:
    section.add "X-Amz-Credential", valid_608383
  var valid_608384 = header.getOrDefault("X-Amz-Security-Token")
  valid_608384 = validateParameter(valid_608384, JString, required = false,
                                 default = nil)
  if valid_608384 != nil:
    section.add "X-Amz-Security-Token", valid_608384
  var valid_608385 = header.getOrDefault("X-Amz-Algorithm")
  valid_608385 = validateParameter(valid_608385, JString, required = false,
                                 default = nil)
  if valid_608385 != nil:
    section.add "X-Amz-Algorithm", valid_608385
  var valid_608386 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608386 = validateParameter(valid_608386, JString, required = false,
                                 default = nil)
  if valid_608386 != nil:
    section.add "X-Amz-SignedHeaders", valid_608386
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608387: Call_ListAuditTasks_608371; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender audits that have been performed during a given time period.
  ## 
  let valid = call_608387.validator(path, query, header, formData, body)
  let scheme = call_608387.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608387.url(scheme.get, call_608387.host, call_608387.base,
                         call_608387.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608387, url, valid)

proc call*(call_608388: Call_ListAuditTasks_608371; endTime: string;
          startTime: string; nextToken: string = "";
          taskStatus: string = "IN_PROGRESS";
          taskType: string = "ON_DEMAND_AUDIT_TASK"; maxResults: int = 0): Recallable =
  ## listAuditTasks
  ## Lists the Device Defender audits that have been performed during a given time period.
  ##   endTime: string (required)
  ##          : The end of the time period.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
  ##   taskStatus: string
  ##             : A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
  ##   taskType: string
  ##           : A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_608389 = newJObject()
  add(query_608389, "endTime", newJString(endTime))
  add(query_608389, "nextToken", newJString(nextToken))
  add(query_608389, "startTime", newJString(startTime))
  add(query_608389, "taskStatus", newJString(taskStatus))
  add(query_608389, "taskType", newJString(taskType))
  add(query_608389, "maxResults", newJInt(maxResults))
  result = call_608388.call(nil, query_608389, nil, nil, nil)

var listAuditTasks* = Call_ListAuditTasks_608371(name: "listAuditTasks",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/audit/tasks#startTime&endTime", validator: validate_ListAuditTasks_608372,
    base: "/", url: url_ListAuditTasks_608373, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListAuthorizers_608390 = ref object of OpenApiRestCall_605589
proc url_ListAuthorizers_608392(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListAuthorizers_608391(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Lists the authorizers registered in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Return the list of authorizers in ascending alphabetical order.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   status: JString
  ##         : The status of the list authorizers request.
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  section = newJObject()
  var valid_608393 = query.getOrDefault("isAscendingOrder")
  valid_608393 = validateParameter(valid_608393, JBool, required = false, default = nil)
  if valid_608393 != nil:
    section.add "isAscendingOrder", valid_608393
  var valid_608394 = query.getOrDefault("pageSize")
  valid_608394 = validateParameter(valid_608394, JInt, required = false, default = nil)
  if valid_608394 != nil:
    section.add "pageSize", valid_608394
  var valid_608395 = query.getOrDefault("status")
  valid_608395 = validateParameter(valid_608395, JString, required = false,
                                 default = newJString("ACTIVE"))
  if valid_608395 != nil:
    section.add "status", valid_608395
  var valid_608396 = query.getOrDefault("marker")
  valid_608396 = validateParameter(valid_608396, JString, required = false,
                                 default = nil)
  if valid_608396 != nil:
    section.add "marker", valid_608396
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608397 = header.getOrDefault("X-Amz-Signature")
  valid_608397 = validateParameter(valid_608397, JString, required = false,
                                 default = nil)
  if valid_608397 != nil:
    section.add "X-Amz-Signature", valid_608397
  var valid_608398 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608398 = validateParameter(valid_608398, JString, required = false,
                                 default = nil)
  if valid_608398 != nil:
    section.add "X-Amz-Content-Sha256", valid_608398
  var valid_608399 = header.getOrDefault("X-Amz-Date")
  valid_608399 = validateParameter(valid_608399, JString, required = false,
                                 default = nil)
  if valid_608399 != nil:
    section.add "X-Amz-Date", valid_608399
  var valid_608400 = header.getOrDefault("X-Amz-Credential")
  valid_608400 = validateParameter(valid_608400, JString, required = false,
                                 default = nil)
  if valid_608400 != nil:
    section.add "X-Amz-Credential", valid_608400
  var valid_608401 = header.getOrDefault("X-Amz-Security-Token")
  valid_608401 = validateParameter(valid_608401, JString, required = false,
                                 default = nil)
  if valid_608401 != nil:
    section.add "X-Amz-Security-Token", valid_608401
  var valid_608402 = header.getOrDefault("X-Amz-Algorithm")
  valid_608402 = validateParameter(valid_608402, JString, required = false,
                                 default = nil)
  if valid_608402 != nil:
    section.add "X-Amz-Algorithm", valid_608402
  var valid_608403 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608403 = validateParameter(valid_608403, JString, required = false,
                                 default = nil)
  if valid_608403 != nil:
    section.add "X-Amz-SignedHeaders", valid_608403
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608404: Call_ListAuthorizers_608390; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the authorizers registered in your account.
  ## 
  let valid = call_608404.validator(path, query, header, formData, body)
  let scheme = call_608404.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608404.url(scheme.get, call_608404.host, call_608404.base,
                         call_608404.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608404, url, valid)

proc call*(call_608405: Call_ListAuthorizers_608390;
          isAscendingOrder: bool = false; pageSize: int = 0; status: string = "ACTIVE";
          marker: string = ""): Recallable =
  ## listAuthorizers
  ## Lists the authorizers registered in your account.
  ##   isAscendingOrder: bool
  ##                   : Return the list of authorizers in ascending alphabetical order.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   status: string
  ##         : The status of the list authorizers request.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  var query_608406 = newJObject()
  add(query_608406, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_608406, "pageSize", newJInt(pageSize))
  add(query_608406, "status", newJString(status))
  add(query_608406, "marker", newJString(marker))
  result = call_608405.call(nil, query_608406, nil, nil, nil)

var listAuthorizers* = Call_ListAuthorizers_608390(name: "listAuthorizers",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/authorizers/",
    validator: validate_ListAuthorizers_608391, base: "/", url: url_ListAuthorizers_608392,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListBillingGroups_608407 = ref object of OpenApiRestCall_605589
proc url_ListBillingGroups_608409(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListBillingGroups_608408(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Lists the billing groups you have created.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   namePrefixFilter: JString
  ##                   : Limit the results to billing groups whose names have the given prefix.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_608410 = query.getOrDefault("nextToken")
  valid_608410 = validateParameter(valid_608410, JString, required = false,
                                 default = nil)
  if valid_608410 != nil:
    section.add "nextToken", valid_608410
  var valid_608411 = query.getOrDefault("namePrefixFilter")
  valid_608411 = validateParameter(valid_608411, JString, required = false,
                                 default = nil)
  if valid_608411 != nil:
    section.add "namePrefixFilter", valid_608411
  var valid_608412 = query.getOrDefault("maxResults")
  valid_608412 = validateParameter(valid_608412, JInt, required = false, default = nil)
  if valid_608412 != nil:
    section.add "maxResults", valid_608412
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608413 = header.getOrDefault("X-Amz-Signature")
  valid_608413 = validateParameter(valid_608413, JString, required = false,
                                 default = nil)
  if valid_608413 != nil:
    section.add "X-Amz-Signature", valid_608413
  var valid_608414 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608414 = validateParameter(valid_608414, JString, required = false,
                                 default = nil)
  if valid_608414 != nil:
    section.add "X-Amz-Content-Sha256", valid_608414
  var valid_608415 = header.getOrDefault("X-Amz-Date")
  valid_608415 = validateParameter(valid_608415, JString, required = false,
                                 default = nil)
  if valid_608415 != nil:
    section.add "X-Amz-Date", valid_608415
  var valid_608416 = header.getOrDefault("X-Amz-Credential")
  valid_608416 = validateParameter(valid_608416, JString, required = false,
                                 default = nil)
  if valid_608416 != nil:
    section.add "X-Amz-Credential", valid_608416
  var valid_608417 = header.getOrDefault("X-Amz-Security-Token")
  valid_608417 = validateParameter(valid_608417, JString, required = false,
                                 default = nil)
  if valid_608417 != nil:
    section.add "X-Amz-Security-Token", valid_608417
  var valid_608418 = header.getOrDefault("X-Amz-Algorithm")
  valid_608418 = validateParameter(valid_608418, JString, required = false,
                                 default = nil)
  if valid_608418 != nil:
    section.add "X-Amz-Algorithm", valid_608418
  var valid_608419 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608419 = validateParameter(valid_608419, JString, required = false,
                                 default = nil)
  if valid_608419 != nil:
    section.add "X-Amz-SignedHeaders", valid_608419
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608420: Call_ListBillingGroups_608407; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the billing groups you have created.
  ## 
  let valid = call_608420.validator(path, query, header, formData, body)
  let scheme = call_608420.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608420.url(scheme.get, call_608420.host, call_608420.base,
                         call_608420.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608420, url, valid)

proc call*(call_608421: Call_ListBillingGroups_608407; nextToken: string = "";
          namePrefixFilter: string = ""; maxResults: int = 0): Recallable =
  ## listBillingGroups
  ## Lists the billing groups you have created.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   namePrefixFilter: string
  ##                   : Limit the results to billing groups whose names have the given prefix.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var query_608422 = newJObject()
  add(query_608422, "nextToken", newJString(nextToken))
  add(query_608422, "namePrefixFilter", newJString(namePrefixFilter))
  add(query_608422, "maxResults", newJInt(maxResults))
  result = call_608421.call(nil, query_608422, nil, nil, nil)

var listBillingGroups* = Call_ListBillingGroups_608407(name: "listBillingGroups",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/billing-groups",
    validator: validate_ListBillingGroups_608408, base: "/",
    url: url_ListBillingGroups_608409, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCACertificates_608423 = ref object of OpenApiRestCall_605589
proc url_ListCACertificates_608425(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListCACertificates_608424(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Determines the order of the results.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_608426 = query.getOrDefault("isAscendingOrder")
  valid_608426 = validateParameter(valid_608426, JBool, required = false, default = nil)
  if valid_608426 != nil:
    section.add "isAscendingOrder", valid_608426
  var valid_608427 = query.getOrDefault("pageSize")
  valid_608427 = validateParameter(valid_608427, JInt, required = false, default = nil)
  if valid_608427 != nil:
    section.add "pageSize", valid_608427
  var valid_608428 = query.getOrDefault("marker")
  valid_608428 = validateParameter(valid_608428, JString, required = false,
                                 default = nil)
  if valid_608428 != nil:
    section.add "marker", valid_608428
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608429 = header.getOrDefault("X-Amz-Signature")
  valid_608429 = validateParameter(valid_608429, JString, required = false,
                                 default = nil)
  if valid_608429 != nil:
    section.add "X-Amz-Signature", valid_608429
  var valid_608430 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608430 = validateParameter(valid_608430, JString, required = false,
                                 default = nil)
  if valid_608430 != nil:
    section.add "X-Amz-Content-Sha256", valid_608430
  var valid_608431 = header.getOrDefault("X-Amz-Date")
  valid_608431 = validateParameter(valid_608431, JString, required = false,
                                 default = nil)
  if valid_608431 != nil:
    section.add "X-Amz-Date", valid_608431
  var valid_608432 = header.getOrDefault("X-Amz-Credential")
  valid_608432 = validateParameter(valid_608432, JString, required = false,
                                 default = nil)
  if valid_608432 != nil:
    section.add "X-Amz-Credential", valid_608432
  var valid_608433 = header.getOrDefault("X-Amz-Security-Token")
  valid_608433 = validateParameter(valid_608433, JString, required = false,
                                 default = nil)
  if valid_608433 != nil:
    section.add "X-Amz-Security-Token", valid_608433
  var valid_608434 = header.getOrDefault("X-Amz-Algorithm")
  valid_608434 = validateParameter(valid_608434, JString, required = false,
                                 default = nil)
  if valid_608434 != nil:
    section.add "X-Amz-Algorithm", valid_608434
  var valid_608435 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608435 = validateParameter(valid_608435, JString, required = false,
                                 default = nil)
  if valid_608435 != nil:
    section.add "X-Amz-SignedHeaders", valid_608435
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608436: Call_ListCACertificates_608423; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ## 
  let valid = call_608436.validator(path, query, header, formData, body)
  let scheme = call_608436.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608436.url(scheme.get, call_608436.host, call_608436.base,
                         call_608436.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608436, url, valid)

proc call*(call_608437: Call_ListCACertificates_608423;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listCACertificates
  ## <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
  ##   isAscendingOrder: bool
  ##                   : Determines the order of the results.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_608438 = newJObject()
  add(query_608438, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_608438, "pageSize", newJInt(pageSize))
  add(query_608438, "marker", newJString(marker))
  result = call_608437.call(nil, query_608438, nil, nil, nil)

var listCACertificates* = Call_ListCACertificates_608423(
    name: "listCACertificates", meth: HttpMethod.HttpGet, host: "iot.amazonaws.com",
    route: "/cacertificates", validator: validate_ListCACertificates_608424,
    base: "/", url: url_ListCACertificates_608425,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListCertificatesByCA_608439 = ref object of OpenApiRestCall_605589
proc url_ListCertificatesByCA_608441(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "caCertificateId" in path, "`caCertificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates-by-ca/"),
               (kind: VariableSegment, value: "caCertificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListCertificatesByCA_608440(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List the device certificates signed by the specified CA certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   caCertificateId: JString (required)
  ##                  : The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `caCertificateId` field"
  var valid_608442 = path.getOrDefault("caCertificateId")
  valid_608442 = validateParameter(valid_608442, JString, required = true,
                                 default = nil)
  if valid_608442 != nil:
    section.add "caCertificateId", valid_608442
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_608443 = query.getOrDefault("isAscendingOrder")
  valid_608443 = validateParameter(valid_608443, JBool, required = false, default = nil)
  if valid_608443 != nil:
    section.add "isAscendingOrder", valid_608443
  var valid_608444 = query.getOrDefault("pageSize")
  valid_608444 = validateParameter(valid_608444, JInt, required = false, default = nil)
  if valid_608444 != nil:
    section.add "pageSize", valid_608444
  var valid_608445 = query.getOrDefault("marker")
  valid_608445 = validateParameter(valid_608445, JString, required = false,
                                 default = nil)
  if valid_608445 != nil:
    section.add "marker", valid_608445
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608446 = header.getOrDefault("X-Amz-Signature")
  valid_608446 = validateParameter(valid_608446, JString, required = false,
                                 default = nil)
  if valid_608446 != nil:
    section.add "X-Amz-Signature", valid_608446
  var valid_608447 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608447 = validateParameter(valid_608447, JString, required = false,
                                 default = nil)
  if valid_608447 != nil:
    section.add "X-Amz-Content-Sha256", valid_608447
  var valid_608448 = header.getOrDefault("X-Amz-Date")
  valid_608448 = validateParameter(valid_608448, JString, required = false,
                                 default = nil)
  if valid_608448 != nil:
    section.add "X-Amz-Date", valid_608448
  var valid_608449 = header.getOrDefault("X-Amz-Credential")
  valid_608449 = validateParameter(valid_608449, JString, required = false,
                                 default = nil)
  if valid_608449 != nil:
    section.add "X-Amz-Credential", valid_608449
  var valid_608450 = header.getOrDefault("X-Amz-Security-Token")
  valid_608450 = validateParameter(valid_608450, JString, required = false,
                                 default = nil)
  if valid_608450 != nil:
    section.add "X-Amz-Security-Token", valid_608450
  var valid_608451 = header.getOrDefault("X-Amz-Algorithm")
  valid_608451 = validateParameter(valid_608451, JString, required = false,
                                 default = nil)
  if valid_608451 != nil:
    section.add "X-Amz-Algorithm", valid_608451
  var valid_608452 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608452 = validateParameter(valid_608452, JString, required = false,
                                 default = nil)
  if valid_608452 != nil:
    section.add "X-Amz-SignedHeaders", valid_608452
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608453: Call_ListCertificatesByCA_608439; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the device certificates signed by the specified CA certificate.
  ## 
  let valid = call_608453.validator(path, query, header, formData, body)
  let scheme = call_608453.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608453.url(scheme.get, call_608453.host, call_608453.base,
                         call_608453.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608453, url, valid)

proc call*(call_608454: Call_ListCertificatesByCA_608439; caCertificateId: string;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listCertificatesByCA
  ## List the device certificates signed by the specified CA certificate.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: int
  ##           : The result page size.
  ##   caCertificateId: string (required)
  ##                  : The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
  ##   marker: string
  ##         : The marker for the next set of results.
  var path_608455 = newJObject()
  var query_608456 = newJObject()
  add(query_608456, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_608456, "pageSize", newJInt(pageSize))
  add(path_608455, "caCertificateId", newJString(caCertificateId))
  add(query_608456, "marker", newJString(marker))
  result = call_608454.call(path_608455, query_608456, nil, nil, nil)

var listCertificatesByCA* = Call_ListCertificatesByCA_608439(
    name: "listCertificatesByCA", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates-by-ca/{caCertificateId}",
    validator: validate_ListCertificatesByCA_608440, base: "/",
    url: url_ListCertificatesByCA_608441, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListDomainConfigurations_608457 = ref object of OpenApiRestCall_605589
proc url_ListDomainConfigurations_608459(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListDomainConfigurations_608458(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   pageSize: JInt
  ##           : The result page size.
  ##   serviceType: JString
  ##              : The type of service delivered by the endpoint.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_608460 = query.getOrDefault("pageSize")
  valid_608460 = validateParameter(valid_608460, JInt, required = false, default = nil)
  if valid_608460 != nil:
    section.add "pageSize", valid_608460
  var valid_608461 = query.getOrDefault("serviceType")
  valid_608461 = validateParameter(valid_608461, JString, required = false,
                                 default = newJString("DATA"))
  if valid_608461 != nil:
    section.add "serviceType", valid_608461
  var valid_608462 = query.getOrDefault("marker")
  valid_608462 = validateParameter(valid_608462, JString, required = false,
                                 default = nil)
  if valid_608462 != nil:
    section.add "marker", valid_608462
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608463 = header.getOrDefault("X-Amz-Signature")
  valid_608463 = validateParameter(valid_608463, JString, required = false,
                                 default = nil)
  if valid_608463 != nil:
    section.add "X-Amz-Signature", valid_608463
  var valid_608464 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608464 = validateParameter(valid_608464, JString, required = false,
                                 default = nil)
  if valid_608464 != nil:
    section.add "X-Amz-Content-Sha256", valid_608464
  var valid_608465 = header.getOrDefault("X-Amz-Date")
  valid_608465 = validateParameter(valid_608465, JString, required = false,
                                 default = nil)
  if valid_608465 != nil:
    section.add "X-Amz-Date", valid_608465
  var valid_608466 = header.getOrDefault("X-Amz-Credential")
  valid_608466 = validateParameter(valid_608466, JString, required = false,
                                 default = nil)
  if valid_608466 != nil:
    section.add "X-Amz-Credential", valid_608466
  var valid_608467 = header.getOrDefault("X-Amz-Security-Token")
  valid_608467 = validateParameter(valid_608467, JString, required = false,
                                 default = nil)
  if valid_608467 != nil:
    section.add "X-Amz-Security-Token", valid_608467
  var valid_608468 = header.getOrDefault("X-Amz-Algorithm")
  valid_608468 = validateParameter(valid_608468, JString, required = false,
                                 default = nil)
  if valid_608468 != nil:
    section.add "X-Amz-Algorithm", valid_608468
  var valid_608469 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608469 = validateParameter(valid_608469, JString, required = false,
                                 default = nil)
  if valid_608469 != nil:
    section.add "X-Amz-SignedHeaders", valid_608469
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608470: Call_ListDomainConfigurations_608457; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ## 
  let valid = call_608470.validator(path, query, header, formData, body)
  let scheme = call_608470.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608470.url(scheme.get, call_608470.host, call_608470.base,
                         call_608470.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608470, url, valid)

proc call*(call_608471: Call_ListDomainConfigurations_608457; pageSize: int = 0;
          serviceType: string = "DATA"; marker: string = ""): Recallable =
  ## listDomainConfigurations
  ## <p>Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note>
  ##   pageSize: int
  ##           : The result page size.
  ##   serviceType: string
  ##              : The type of service delivered by the endpoint.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_608472 = newJObject()
  add(query_608472, "pageSize", newJInt(pageSize))
  add(query_608472, "serviceType", newJString(serviceType))
  add(query_608472, "marker", newJString(marker))
  result = call_608471.call(nil, query_608472, nil, nil, nil)

var listDomainConfigurations* = Call_ListDomainConfigurations_608457(
    name: "listDomainConfigurations", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/domainConfigurations",
    validator: validate_ListDomainConfigurations_608458, base: "/",
    url: url_ListDomainConfigurations_608459, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListIndices_608473 = ref object of OpenApiRestCall_605589
proc url_ListIndices_608475(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListIndices_608474(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the search indices.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token used to get the next set of results, or <code>null</code> if there are no additional results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_608476 = query.getOrDefault("nextToken")
  valid_608476 = validateParameter(valid_608476, JString, required = false,
                                 default = nil)
  if valid_608476 != nil:
    section.add "nextToken", valid_608476
  var valid_608477 = query.getOrDefault("maxResults")
  valid_608477 = validateParameter(valid_608477, JInt, required = false, default = nil)
  if valid_608477 != nil:
    section.add "maxResults", valid_608477
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608478 = header.getOrDefault("X-Amz-Signature")
  valid_608478 = validateParameter(valid_608478, JString, required = false,
                                 default = nil)
  if valid_608478 != nil:
    section.add "X-Amz-Signature", valid_608478
  var valid_608479 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608479 = validateParameter(valid_608479, JString, required = false,
                                 default = nil)
  if valid_608479 != nil:
    section.add "X-Amz-Content-Sha256", valid_608479
  var valid_608480 = header.getOrDefault("X-Amz-Date")
  valid_608480 = validateParameter(valid_608480, JString, required = false,
                                 default = nil)
  if valid_608480 != nil:
    section.add "X-Amz-Date", valid_608480
  var valid_608481 = header.getOrDefault("X-Amz-Credential")
  valid_608481 = validateParameter(valid_608481, JString, required = false,
                                 default = nil)
  if valid_608481 != nil:
    section.add "X-Amz-Credential", valid_608481
  var valid_608482 = header.getOrDefault("X-Amz-Security-Token")
  valid_608482 = validateParameter(valid_608482, JString, required = false,
                                 default = nil)
  if valid_608482 != nil:
    section.add "X-Amz-Security-Token", valid_608482
  var valid_608483 = header.getOrDefault("X-Amz-Algorithm")
  valid_608483 = validateParameter(valid_608483, JString, required = false,
                                 default = nil)
  if valid_608483 != nil:
    section.add "X-Amz-Algorithm", valid_608483
  var valid_608484 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608484 = validateParameter(valid_608484, JString, required = false,
                                 default = nil)
  if valid_608484 != nil:
    section.add "X-Amz-SignedHeaders", valid_608484
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608485: Call_ListIndices_608473; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the search indices.
  ## 
  let valid = call_608485.validator(path, query, header, formData, body)
  let scheme = call_608485.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608485.url(scheme.get, call_608485.host, call_608485.base,
                         call_608485.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608485, url, valid)

proc call*(call_608486: Call_ListIndices_608473; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listIndices
  ## Lists the search indices.
  ##   nextToken: string
  ##            : The token used to get the next set of results, or <code>null</code> if there are no additional results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_608487 = newJObject()
  add(query_608487, "nextToken", newJString(nextToken))
  add(query_608487, "maxResults", newJInt(maxResults))
  result = call_608486.call(nil, query_608487, nil, nil, nil)

var listIndices* = Call_ListIndices_608473(name: "listIndices",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/indices",
                                        validator: validate_ListIndices_608474,
                                        base: "/", url: url_ListIndices_608475,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobExecutionsForJob_608488 = ref object of OpenApiRestCall_605589
proc url_ListJobExecutionsForJob_608490(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "jobId" in path, "`jobId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/jobs/"),
               (kind: VariableSegment, value: "jobId"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListJobExecutionsForJob_608489(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the job executions for a job.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   jobId: JString (required)
  ##        : The unique identifier you assigned to this job when it was created.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `jobId` field"
  var valid_608491 = path.getOrDefault("jobId")
  valid_608491 = validateParameter(valid_608491, JString, required = true,
                                 default = nil)
  if valid_608491 != nil:
    section.add "jobId", valid_608491
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : The status of the job.
  ##   maxResults: JInt
  ##             : The maximum number of results to be returned per request.
  section = newJObject()
  var valid_608492 = query.getOrDefault("nextToken")
  valid_608492 = validateParameter(valid_608492, JString, required = false,
                                 default = nil)
  if valid_608492 != nil:
    section.add "nextToken", valid_608492
  var valid_608493 = query.getOrDefault("status")
  valid_608493 = validateParameter(valid_608493, JString, required = false,
                                 default = newJString("QUEUED"))
  if valid_608493 != nil:
    section.add "status", valid_608493
  var valid_608494 = query.getOrDefault("maxResults")
  valid_608494 = validateParameter(valid_608494, JInt, required = false, default = nil)
  if valid_608494 != nil:
    section.add "maxResults", valid_608494
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608495 = header.getOrDefault("X-Amz-Signature")
  valid_608495 = validateParameter(valid_608495, JString, required = false,
                                 default = nil)
  if valid_608495 != nil:
    section.add "X-Amz-Signature", valid_608495
  var valid_608496 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608496 = validateParameter(valid_608496, JString, required = false,
                                 default = nil)
  if valid_608496 != nil:
    section.add "X-Amz-Content-Sha256", valid_608496
  var valid_608497 = header.getOrDefault("X-Amz-Date")
  valid_608497 = validateParameter(valid_608497, JString, required = false,
                                 default = nil)
  if valid_608497 != nil:
    section.add "X-Amz-Date", valid_608497
  var valid_608498 = header.getOrDefault("X-Amz-Credential")
  valid_608498 = validateParameter(valid_608498, JString, required = false,
                                 default = nil)
  if valid_608498 != nil:
    section.add "X-Amz-Credential", valid_608498
  var valid_608499 = header.getOrDefault("X-Amz-Security-Token")
  valid_608499 = validateParameter(valid_608499, JString, required = false,
                                 default = nil)
  if valid_608499 != nil:
    section.add "X-Amz-Security-Token", valid_608499
  var valid_608500 = header.getOrDefault("X-Amz-Algorithm")
  valid_608500 = validateParameter(valid_608500, JString, required = false,
                                 default = nil)
  if valid_608500 != nil:
    section.add "X-Amz-Algorithm", valid_608500
  var valid_608501 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608501 = validateParameter(valid_608501, JString, required = false,
                                 default = nil)
  if valid_608501 != nil:
    section.add "X-Amz-SignedHeaders", valid_608501
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608502: Call_ListJobExecutionsForJob_608488; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the job executions for a job.
  ## 
  let valid = call_608502.validator(path, query, header, formData, body)
  let scheme = call_608502.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608502.url(scheme.get, call_608502.host, call_608502.base,
                         call_608502.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608502, url, valid)

proc call*(call_608503: Call_ListJobExecutionsForJob_608488; jobId: string;
          nextToken: string = ""; status: string = "QUEUED"; maxResults: int = 0): Recallable =
  ## listJobExecutionsForJob
  ## Lists the job executions for a job.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   jobId: string (required)
  ##        : The unique identifier you assigned to this job when it was created.
  ##   status: string
  ##         : The status of the job.
  ##   maxResults: int
  ##             : The maximum number of results to be returned per request.
  var path_608504 = newJObject()
  var query_608505 = newJObject()
  add(query_608505, "nextToken", newJString(nextToken))
  add(path_608504, "jobId", newJString(jobId))
  add(query_608505, "status", newJString(status))
  add(query_608505, "maxResults", newJInt(maxResults))
  result = call_608503.call(path_608504, query_608505, nil, nil, nil)

var listJobExecutionsForJob* = Call_ListJobExecutionsForJob_608488(
    name: "listJobExecutionsForJob", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/jobs/{jobId}/things",
    validator: validate_ListJobExecutionsForJob_608489, base: "/",
    url: url_ListJobExecutionsForJob_608490, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobExecutionsForThing_608506 = ref object of OpenApiRestCall_605589
proc url_ListJobExecutionsForThing_608508(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/jobs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListJobExecutionsForThing_608507(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the job executions for the specified thing.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The thing name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_608509 = path.getOrDefault("thingName")
  valid_608509 = validateParameter(valid_608509, JString, required = true,
                                 default = nil)
  if valid_608509 != nil:
    section.add "thingName", valid_608509
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: JInt
  ##             : The maximum number of results to be returned per request.
  section = newJObject()
  var valid_608510 = query.getOrDefault("nextToken")
  valid_608510 = validateParameter(valid_608510, JString, required = false,
                                 default = nil)
  if valid_608510 != nil:
    section.add "nextToken", valid_608510
  var valid_608511 = query.getOrDefault("status")
  valid_608511 = validateParameter(valid_608511, JString, required = false,
                                 default = newJString("QUEUED"))
  if valid_608511 != nil:
    section.add "status", valid_608511
  var valid_608512 = query.getOrDefault("maxResults")
  valid_608512 = validateParameter(valid_608512, JInt, required = false, default = nil)
  if valid_608512 != nil:
    section.add "maxResults", valid_608512
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608513 = header.getOrDefault("X-Amz-Signature")
  valid_608513 = validateParameter(valid_608513, JString, required = false,
                                 default = nil)
  if valid_608513 != nil:
    section.add "X-Amz-Signature", valid_608513
  var valid_608514 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608514 = validateParameter(valid_608514, JString, required = false,
                                 default = nil)
  if valid_608514 != nil:
    section.add "X-Amz-Content-Sha256", valid_608514
  var valid_608515 = header.getOrDefault("X-Amz-Date")
  valid_608515 = validateParameter(valid_608515, JString, required = false,
                                 default = nil)
  if valid_608515 != nil:
    section.add "X-Amz-Date", valid_608515
  var valid_608516 = header.getOrDefault("X-Amz-Credential")
  valid_608516 = validateParameter(valid_608516, JString, required = false,
                                 default = nil)
  if valid_608516 != nil:
    section.add "X-Amz-Credential", valid_608516
  var valid_608517 = header.getOrDefault("X-Amz-Security-Token")
  valid_608517 = validateParameter(valid_608517, JString, required = false,
                                 default = nil)
  if valid_608517 != nil:
    section.add "X-Amz-Security-Token", valid_608517
  var valid_608518 = header.getOrDefault("X-Amz-Algorithm")
  valid_608518 = validateParameter(valid_608518, JString, required = false,
                                 default = nil)
  if valid_608518 != nil:
    section.add "X-Amz-Algorithm", valid_608518
  var valid_608519 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608519 = validateParameter(valid_608519, JString, required = false,
                                 default = nil)
  if valid_608519 != nil:
    section.add "X-Amz-SignedHeaders", valid_608519
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608520: Call_ListJobExecutionsForThing_608506; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the job executions for the specified thing.
  ## 
  let valid = call_608520.validator(path, query, header, formData, body)
  let scheme = call_608520.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608520.url(scheme.get, call_608520.host, call_608520.base,
                         call_608520.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608520, url, valid)

proc call*(call_608521: Call_ListJobExecutionsForThing_608506; thingName: string;
          nextToken: string = ""; status: string = "QUEUED"; maxResults: int = 0): Recallable =
  ## listJobExecutionsForThing
  ## Lists the job executions for the specified thing.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingName: string (required)
  ##            : The thing name.
  ##   status: string
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: int
  ##             : The maximum number of results to be returned per request.
  var path_608522 = newJObject()
  var query_608523 = newJObject()
  add(query_608523, "nextToken", newJString(nextToken))
  add(path_608522, "thingName", newJString(thingName))
  add(query_608523, "status", newJString(status))
  add(query_608523, "maxResults", newJInt(maxResults))
  result = call_608521.call(path_608522, query_608523, nil, nil, nil)

var listJobExecutionsForThing* = Call_ListJobExecutionsForThing_608506(
    name: "listJobExecutionsForThing", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/jobs",
    validator: validate_ListJobExecutionsForThing_608507, base: "/",
    url: url_ListJobExecutionsForThing_608508,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListJobs_608524 = ref object of OpenApiRestCall_605589
proc url_ListJobs_608526(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListJobs_608525(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists jobs.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: JString
  ##                 : A filter that limits the returned jobs to those for the specified group.
  ##   targetSelection: JString
  ##                  : Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. 
  ##   thingGroupId: JString
  ##               : A filter that limits the returned jobs to those for the specified group.
  ##   status: JString
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_608527 = query.getOrDefault("nextToken")
  valid_608527 = validateParameter(valid_608527, JString, required = false,
                                 default = nil)
  if valid_608527 != nil:
    section.add "nextToken", valid_608527
  var valid_608528 = query.getOrDefault("thingGroupName")
  valid_608528 = validateParameter(valid_608528, JString, required = false,
                                 default = nil)
  if valid_608528 != nil:
    section.add "thingGroupName", valid_608528
  var valid_608529 = query.getOrDefault("targetSelection")
  valid_608529 = validateParameter(valid_608529, JString, required = false,
                                 default = newJString("CONTINUOUS"))
  if valid_608529 != nil:
    section.add "targetSelection", valid_608529
  var valid_608530 = query.getOrDefault("thingGroupId")
  valid_608530 = validateParameter(valid_608530, JString, required = false,
                                 default = nil)
  if valid_608530 != nil:
    section.add "thingGroupId", valid_608530
  var valid_608531 = query.getOrDefault("status")
  valid_608531 = validateParameter(valid_608531, JString, required = false,
                                 default = newJString("IN_PROGRESS"))
  if valid_608531 != nil:
    section.add "status", valid_608531
  var valid_608532 = query.getOrDefault("maxResults")
  valid_608532 = validateParameter(valid_608532, JInt, required = false, default = nil)
  if valid_608532 != nil:
    section.add "maxResults", valid_608532
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608533 = header.getOrDefault("X-Amz-Signature")
  valid_608533 = validateParameter(valid_608533, JString, required = false,
                                 default = nil)
  if valid_608533 != nil:
    section.add "X-Amz-Signature", valid_608533
  var valid_608534 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608534 = validateParameter(valid_608534, JString, required = false,
                                 default = nil)
  if valid_608534 != nil:
    section.add "X-Amz-Content-Sha256", valid_608534
  var valid_608535 = header.getOrDefault("X-Amz-Date")
  valid_608535 = validateParameter(valid_608535, JString, required = false,
                                 default = nil)
  if valid_608535 != nil:
    section.add "X-Amz-Date", valid_608535
  var valid_608536 = header.getOrDefault("X-Amz-Credential")
  valid_608536 = validateParameter(valid_608536, JString, required = false,
                                 default = nil)
  if valid_608536 != nil:
    section.add "X-Amz-Credential", valid_608536
  var valid_608537 = header.getOrDefault("X-Amz-Security-Token")
  valid_608537 = validateParameter(valid_608537, JString, required = false,
                                 default = nil)
  if valid_608537 != nil:
    section.add "X-Amz-Security-Token", valid_608537
  var valid_608538 = header.getOrDefault("X-Amz-Algorithm")
  valid_608538 = validateParameter(valid_608538, JString, required = false,
                                 default = nil)
  if valid_608538 != nil:
    section.add "X-Amz-Algorithm", valid_608538
  var valid_608539 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608539 = validateParameter(valid_608539, JString, required = false,
                                 default = nil)
  if valid_608539 != nil:
    section.add "X-Amz-SignedHeaders", valid_608539
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608540: Call_ListJobs_608524; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists jobs.
  ## 
  let valid = call_608540.validator(path, query, header, formData, body)
  let scheme = call_608540.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608540.url(scheme.get, call_608540.host, call_608540.base,
                         call_608540.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608540, url, valid)

proc call*(call_608541: Call_ListJobs_608524; nextToken: string = "";
          thingGroupName: string = ""; targetSelection: string = "CONTINUOUS";
          thingGroupId: string = ""; status: string = "IN_PROGRESS"; maxResults: int = 0): Recallable =
  ## listJobs
  ## Lists jobs.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: string
  ##                 : A filter that limits the returned jobs to those for the specified group.
  ##   targetSelection: string
  ##                  : Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. 
  ##   thingGroupId: string
  ##               : A filter that limits the returned jobs to those for the specified group.
  ##   status: string
  ##         : An optional filter that lets you search for jobs that have the specified status.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var query_608542 = newJObject()
  add(query_608542, "nextToken", newJString(nextToken))
  add(query_608542, "thingGroupName", newJString(thingGroupName))
  add(query_608542, "targetSelection", newJString(targetSelection))
  add(query_608542, "thingGroupId", newJString(thingGroupId))
  add(query_608542, "status", newJString(status))
  add(query_608542, "maxResults", newJInt(maxResults))
  result = call_608541.call(nil, query_608542, nil, nil, nil)

var listJobs* = Call_ListJobs_608524(name: "listJobs", meth: HttpMethod.HttpGet,
                                  host: "iot.amazonaws.com", route: "/jobs",
                                  validator: validate_ListJobs_608525, base: "/",
                                  url: url_ListJobs_608526,
                                  schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListMitigationActions_608543 = ref object of OpenApiRestCall_605589
proc url_ListMitigationActions_608545(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListMitigationActions_608544(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   actionType: JString
  ##             : Specify a value to limit the result to mitigation actions with a specific action type.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  var valid_608546 = query.getOrDefault("nextToken")
  valid_608546 = validateParameter(valid_608546, JString, required = false,
                                 default = nil)
  if valid_608546 != nil:
    section.add "nextToken", valid_608546
  var valid_608547 = query.getOrDefault("actionType")
  valid_608547 = validateParameter(valid_608547, JString, required = false, default = newJString(
      "UPDATE_DEVICE_CERTIFICATE"))
  if valid_608547 != nil:
    section.add "actionType", valid_608547
  var valid_608548 = query.getOrDefault("maxResults")
  valid_608548 = validateParameter(valid_608548, JInt, required = false, default = nil)
  if valid_608548 != nil:
    section.add "maxResults", valid_608548
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608549 = header.getOrDefault("X-Amz-Signature")
  valid_608549 = validateParameter(valid_608549, JString, required = false,
                                 default = nil)
  if valid_608549 != nil:
    section.add "X-Amz-Signature", valid_608549
  var valid_608550 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608550 = validateParameter(valid_608550, JString, required = false,
                                 default = nil)
  if valid_608550 != nil:
    section.add "X-Amz-Content-Sha256", valid_608550
  var valid_608551 = header.getOrDefault("X-Amz-Date")
  valid_608551 = validateParameter(valid_608551, JString, required = false,
                                 default = nil)
  if valid_608551 != nil:
    section.add "X-Amz-Date", valid_608551
  var valid_608552 = header.getOrDefault("X-Amz-Credential")
  valid_608552 = validateParameter(valid_608552, JString, required = false,
                                 default = nil)
  if valid_608552 != nil:
    section.add "X-Amz-Credential", valid_608552
  var valid_608553 = header.getOrDefault("X-Amz-Security-Token")
  valid_608553 = validateParameter(valid_608553, JString, required = false,
                                 default = nil)
  if valid_608553 != nil:
    section.add "X-Amz-Security-Token", valid_608553
  var valid_608554 = header.getOrDefault("X-Amz-Algorithm")
  valid_608554 = validateParameter(valid_608554, JString, required = false,
                                 default = nil)
  if valid_608554 != nil:
    section.add "X-Amz-Algorithm", valid_608554
  var valid_608555 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608555 = validateParameter(valid_608555, JString, required = false,
                                 default = nil)
  if valid_608555 != nil:
    section.add "X-Amz-SignedHeaders", valid_608555
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608556: Call_ListMitigationActions_608543; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ## 
  let valid = call_608556.validator(path, query, header, formData, body)
  let scheme = call_608556.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608556.url(scheme.get, call_608556.host, call_608556.base,
                         call_608556.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608556, url, valid)

proc call*(call_608557: Call_ListMitigationActions_608543; nextToken: string = "";
          actionType: string = "UPDATE_DEVICE_CERTIFICATE"; maxResults: int = 0): Recallable =
  ## listMitigationActions
  ## Gets a list of all mitigation actions that match the specified filter criteria.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   actionType: string
  ##             : Specify a value to limit the result to mitigation actions with a specific action type.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_608558 = newJObject()
  add(query_608558, "nextToken", newJString(nextToken))
  add(query_608558, "actionType", newJString(actionType))
  add(query_608558, "maxResults", newJInt(maxResults))
  result = call_608557.call(nil, query_608558, nil, nil, nil)

var listMitigationActions* = Call_ListMitigationActions_608543(
    name: "listMitigationActions", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/mitigationactions/actions",
    validator: validate_ListMitigationActions_608544, base: "/",
    url: url_ListMitigationActions_608545, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListOTAUpdates_608559 = ref object of OpenApiRestCall_605589
proc url_ListOTAUpdates_608561(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListOTAUpdates_608560(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists OTA updates.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token used to retrieve the next set of results.
  ##   otaUpdateStatus: JString
  ##                  : The OTA update job status.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_608562 = query.getOrDefault("nextToken")
  valid_608562 = validateParameter(valid_608562, JString, required = false,
                                 default = nil)
  if valid_608562 != nil:
    section.add "nextToken", valid_608562
  var valid_608563 = query.getOrDefault("otaUpdateStatus")
  valid_608563 = validateParameter(valid_608563, JString, required = false,
                                 default = newJString("CREATE_PENDING"))
  if valid_608563 != nil:
    section.add "otaUpdateStatus", valid_608563
  var valid_608564 = query.getOrDefault("maxResults")
  valid_608564 = validateParameter(valid_608564, JInt, required = false, default = nil)
  if valid_608564 != nil:
    section.add "maxResults", valid_608564
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608565 = header.getOrDefault("X-Amz-Signature")
  valid_608565 = validateParameter(valid_608565, JString, required = false,
                                 default = nil)
  if valid_608565 != nil:
    section.add "X-Amz-Signature", valid_608565
  var valid_608566 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608566 = validateParameter(valid_608566, JString, required = false,
                                 default = nil)
  if valid_608566 != nil:
    section.add "X-Amz-Content-Sha256", valid_608566
  var valid_608567 = header.getOrDefault("X-Amz-Date")
  valid_608567 = validateParameter(valid_608567, JString, required = false,
                                 default = nil)
  if valid_608567 != nil:
    section.add "X-Amz-Date", valid_608567
  var valid_608568 = header.getOrDefault("X-Amz-Credential")
  valid_608568 = validateParameter(valid_608568, JString, required = false,
                                 default = nil)
  if valid_608568 != nil:
    section.add "X-Amz-Credential", valid_608568
  var valid_608569 = header.getOrDefault("X-Amz-Security-Token")
  valid_608569 = validateParameter(valid_608569, JString, required = false,
                                 default = nil)
  if valid_608569 != nil:
    section.add "X-Amz-Security-Token", valid_608569
  var valid_608570 = header.getOrDefault("X-Amz-Algorithm")
  valid_608570 = validateParameter(valid_608570, JString, required = false,
                                 default = nil)
  if valid_608570 != nil:
    section.add "X-Amz-Algorithm", valid_608570
  var valid_608571 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608571 = validateParameter(valid_608571, JString, required = false,
                                 default = nil)
  if valid_608571 != nil:
    section.add "X-Amz-SignedHeaders", valid_608571
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608572: Call_ListOTAUpdates_608559; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists OTA updates.
  ## 
  let valid = call_608572.validator(path, query, header, formData, body)
  let scheme = call_608572.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608572.url(scheme.get, call_608572.host, call_608572.base,
                         call_608572.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608572, url, valid)

proc call*(call_608573: Call_ListOTAUpdates_608559; nextToken: string = "";
          otaUpdateStatus: string = "CREATE_PENDING"; maxResults: int = 0): Recallable =
  ## listOTAUpdates
  ## Lists OTA updates.
  ##   nextToken: string
  ##            : A token used to retrieve the next set of results.
  ##   otaUpdateStatus: string
  ##                  : The OTA update job status.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_608574 = newJObject()
  add(query_608574, "nextToken", newJString(nextToken))
  add(query_608574, "otaUpdateStatus", newJString(otaUpdateStatus))
  add(query_608574, "maxResults", newJInt(maxResults))
  result = call_608573.call(nil, query_608574, nil, nil, nil)

var listOTAUpdates* = Call_ListOTAUpdates_608559(name: "listOTAUpdates",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/otaUpdates",
    validator: validate_ListOTAUpdates_608560, base: "/", url: url_ListOTAUpdates_608561,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListOutgoingCertificates_608575 = ref object of OpenApiRestCall_605589
proc url_ListOutgoingCertificates_608577(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListOutgoingCertificates_608576(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists certificates that are being transferred but not yet accepted.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_608578 = query.getOrDefault("isAscendingOrder")
  valid_608578 = validateParameter(valid_608578, JBool, required = false, default = nil)
  if valid_608578 != nil:
    section.add "isAscendingOrder", valid_608578
  var valid_608579 = query.getOrDefault("pageSize")
  valid_608579 = validateParameter(valid_608579, JInt, required = false, default = nil)
  if valid_608579 != nil:
    section.add "pageSize", valid_608579
  var valid_608580 = query.getOrDefault("marker")
  valid_608580 = validateParameter(valid_608580, JString, required = false,
                                 default = nil)
  if valid_608580 != nil:
    section.add "marker", valid_608580
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608581 = header.getOrDefault("X-Amz-Signature")
  valid_608581 = validateParameter(valid_608581, JString, required = false,
                                 default = nil)
  if valid_608581 != nil:
    section.add "X-Amz-Signature", valid_608581
  var valid_608582 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608582 = validateParameter(valid_608582, JString, required = false,
                                 default = nil)
  if valid_608582 != nil:
    section.add "X-Amz-Content-Sha256", valid_608582
  var valid_608583 = header.getOrDefault("X-Amz-Date")
  valid_608583 = validateParameter(valid_608583, JString, required = false,
                                 default = nil)
  if valid_608583 != nil:
    section.add "X-Amz-Date", valid_608583
  var valid_608584 = header.getOrDefault("X-Amz-Credential")
  valid_608584 = validateParameter(valid_608584, JString, required = false,
                                 default = nil)
  if valid_608584 != nil:
    section.add "X-Amz-Credential", valid_608584
  var valid_608585 = header.getOrDefault("X-Amz-Security-Token")
  valid_608585 = validateParameter(valid_608585, JString, required = false,
                                 default = nil)
  if valid_608585 != nil:
    section.add "X-Amz-Security-Token", valid_608585
  var valid_608586 = header.getOrDefault("X-Amz-Algorithm")
  valid_608586 = validateParameter(valid_608586, JString, required = false,
                                 default = nil)
  if valid_608586 != nil:
    section.add "X-Amz-Algorithm", valid_608586
  var valid_608587 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608587 = validateParameter(valid_608587, JString, required = false,
                                 default = nil)
  if valid_608587 != nil:
    section.add "X-Amz-SignedHeaders", valid_608587
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608588: Call_ListOutgoingCertificates_608575; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists certificates that are being transferred but not yet accepted.
  ## 
  let valid = call_608588.validator(path, query, header, formData, body)
  let scheme = call_608588.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608588.url(scheme.get, call_608588.host, call_608588.base,
                         call_608588.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608588, url, valid)

proc call*(call_608589: Call_ListOutgoingCertificates_608575;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listOutgoingCertificates
  ## Lists certificates that are being transferred but not yet accepted.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_608590 = newJObject()
  add(query_608590, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_608590, "pageSize", newJInt(pageSize))
  add(query_608590, "marker", newJString(marker))
  result = call_608589.call(nil, query_608590, nil, nil, nil)

var listOutgoingCertificates* = Call_ListOutgoingCertificates_608575(
    name: "listOutgoingCertificates", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/certificates-out-going",
    validator: validate_ListOutgoingCertificates_608576, base: "/",
    url: url_ListOutgoingCertificates_608577, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicies_608591 = ref object of OpenApiRestCall_605589
proc url_ListPolicies_608593(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPolicies_608592(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists your policies.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_608594 = query.getOrDefault("isAscendingOrder")
  valid_608594 = validateParameter(valid_608594, JBool, required = false, default = nil)
  if valid_608594 != nil:
    section.add "isAscendingOrder", valid_608594
  var valid_608595 = query.getOrDefault("pageSize")
  valid_608595 = validateParameter(valid_608595, JInt, required = false, default = nil)
  if valid_608595 != nil:
    section.add "pageSize", valid_608595
  var valid_608596 = query.getOrDefault("marker")
  valid_608596 = validateParameter(valid_608596, JString, required = false,
                                 default = nil)
  if valid_608596 != nil:
    section.add "marker", valid_608596
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608597 = header.getOrDefault("X-Amz-Signature")
  valid_608597 = validateParameter(valid_608597, JString, required = false,
                                 default = nil)
  if valid_608597 != nil:
    section.add "X-Amz-Signature", valid_608597
  var valid_608598 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608598 = validateParameter(valid_608598, JString, required = false,
                                 default = nil)
  if valid_608598 != nil:
    section.add "X-Amz-Content-Sha256", valid_608598
  var valid_608599 = header.getOrDefault("X-Amz-Date")
  valid_608599 = validateParameter(valid_608599, JString, required = false,
                                 default = nil)
  if valid_608599 != nil:
    section.add "X-Amz-Date", valid_608599
  var valid_608600 = header.getOrDefault("X-Amz-Credential")
  valid_608600 = validateParameter(valid_608600, JString, required = false,
                                 default = nil)
  if valid_608600 != nil:
    section.add "X-Amz-Credential", valid_608600
  var valid_608601 = header.getOrDefault("X-Amz-Security-Token")
  valid_608601 = validateParameter(valid_608601, JString, required = false,
                                 default = nil)
  if valid_608601 != nil:
    section.add "X-Amz-Security-Token", valid_608601
  var valid_608602 = header.getOrDefault("X-Amz-Algorithm")
  valid_608602 = validateParameter(valid_608602, JString, required = false,
                                 default = nil)
  if valid_608602 != nil:
    section.add "X-Amz-Algorithm", valid_608602
  var valid_608603 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608603 = validateParameter(valid_608603, JString, required = false,
                                 default = nil)
  if valid_608603 != nil:
    section.add "X-Amz-SignedHeaders", valid_608603
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608604: Call_ListPolicies_608591; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists your policies.
  ## 
  let valid = call_608604.validator(path, query, header, formData, body)
  let scheme = call_608604.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608604.url(scheme.get, call_608604.host, call_608604.base,
                         call_608604.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608604, url, valid)

proc call*(call_608605: Call_ListPolicies_608591; isAscendingOrder: bool = false;
          pageSize: int = 0; marker: string = ""): Recallable =
  ## listPolicies
  ## Lists your policies.
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_608606 = newJObject()
  add(query_608606, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_608606, "pageSize", newJInt(pageSize))
  add(query_608606, "marker", newJString(marker))
  result = call_608605.call(nil, query_608606, nil, nil, nil)

var listPolicies* = Call_ListPolicies_608591(name: "listPolicies",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/policies",
    validator: validate_ListPolicies_608592, base: "/", url: url_ListPolicies_608593,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPolicyPrincipals_608607 = ref object of OpenApiRestCall_605589
proc url_ListPolicyPrincipals_608609(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPolicyPrincipals_608608(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_608610 = query.getOrDefault("isAscendingOrder")
  valid_608610 = validateParameter(valid_608610, JBool, required = false, default = nil)
  if valid_608610 != nil:
    section.add "isAscendingOrder", valid_608610
  var valid_608611 = query.getOrDefault("pageSize")
  valid_608611 = validateParameter(valid_608611, JInt, required = false, default = nil)
  if valid_608611 != nil:
    section.add "pageSize", valid_608611
  var valid_608612 = query.getOrDefault("marker")
  valid_608612 = validateParameter(valid_608612, JString, required = false,
                                 default = nil)
  if valid_608612 != nil:
    section.add "marker", valid_608612
  result.add "query", section
  ## parameters in `header` object:
  ##   x-amzn-iot-policy: JString (required)
  ##                    : The policy name.
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-policy` field"
  var valid_608613 = header.getOrDefault("x-amzn-iot-policy")
  valid_608613 = validateParameter(valid_608613, JString, required = true,
                                 default = nil)
  if valid_608613 != nil:
    section.add "x-amzn-iot-policy", valid_608613
  var valid_608614 = header.getOrDefault("X-Amz-Signature")
  valid_608614 = validateParameter(valid_608614, JString, required = false,
                                 default = nil)
  if valid_608614 != nil:
    section.add "X-Amz-Signature", valid_608614
  var valid_608615 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608615 = validateParameter(valid_608615, JString, required = false,
                                 default = nil)
  if valid_608615 != nil:
    section.add "X-Amz-Content-Sha256", valid_608615
  var valid_608616 = header.getOrDefault("X-Amz-Date")
  valid_608616 = validateParameter(valid_608616, JString, required = false,
                                 default = nil)
  if valid_608616 != nil:
    section.add "X-Amz-Date", valid_608616
  var valid_608617 = header.getOrDefault("X-Amz-Credential")
  valid_608617 = validateParameter(valid_608617, JString, required = false,
                                 default = nil)
  if valid_608617 != nil:
    section.add "X-Amz-Credential", valid_608617
  var valid_608618 = header.getOrDefault("X-Amz-Security-Token")
  valid_608618 = validateParameter(valid_608618, JString, required = false,
                                 default = nil)
  if valid_608618 != nil:
    section.add "X-Amz-Security-Token", valid_608618
  var valid_608619 = header.getOrDefault("X-Amz-Algorithm")
  valid_608619 = validateParameter(valid_608619, JString, required = false,
                                 default = nil)
  if valid_608619 != nil:
    section.add "X-Amz-Algorithm", valid_608619
  var valid_608620 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608620 = validateParameter(valid_608620, JString, required = false,
                                 default = nil)
  if valid_608620 != nil:
    section.add "X-Amz-SignedHeaders", valid_608620
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608621: Call_ListPolicyPrincipals_608607; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ## 
  let valid = call_608621.validator(path, query, header, formData, body)
  let scheme = call_608621.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608621.url(scheme.get, call_608621.host, call_608621.base,
                         call_608621.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608621, url, valid)

proc call*(call_608622: Call_ListPolicyPrincipals_608607;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listPolicyPrincipals
  ## <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, the results are returned in ascending creation order.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_608623 = newJObject()
  add(query_608623, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_608623, "pageSize", newJInt(pageSize))
  add(query_608623, "marker", newJString(marker))
  result = call_608622.call(nil, query_608623, nil, nil, nil)

var listPolicyPrincipals* = Call_ListPolicyPrincipals_608607(
    name: "listPolicyPrincipals", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/policy-principals#x-amzn-iot-policy",
    validator: validate_ListPolicyPrincipals_608608, base: "/",
    url: url_ListPolicyPrincipals_608609, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPrincipalPolicies_608624 = ref object of OpenApiRestCall_605589
proc url_ListPrincipalPolicies_608626(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPrincipalPolicies_608625(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Specifies the order for results. If true, results are returned in ascending creation order.
  ##   pageSize: JInt
  ##           : The result page size.
  ##   marker: JString
  ##         : The marker for the next set of results.
  section = newJObject()
  var valid_608627 = query.getOrDefault("isAscendingOrder")
  valid_608627 = validateParameter(valid_608627, JBool, required = false, default = nil)
  if valid_608627 != nil:
    section.add "isAscendingOrder", valid_608627
  var valid_608628 = query.getOrDefault("pageSize")
  valid_608628 = validateParameter(valid_608628, JInt, required = false, default = nil)
  if valid_608628 != nil:
    section.add "pageSize", valid_608628
  var valid_608629 = query.getOrDefault("marker")
  valid_608629 = validateParameter(valid_608629, JString, required = false,
                                 default = nil)
  if valid_608629 != nil:
    section.add "marker", valid_608629
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   x-amzn-iot-principal: JString (required)
  ##                       : The principal.
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608630 = header.getOrDefault("X-Amz-Signature")
  valid_608630 = validateParameter(valid_608630, JString, required = false,
                                 default = nil)
  if valid_608630 != nil:
    section.add "X-Amz-Signature", valid_608630
  assert header != nil, "header argument is necessary due to required `x-amzn-iot-principal` field"
  var valid_608631 = header.getOrDefault("x-amzn-iot-principal")
  valid_608631 = validateParameter(valid_608631, JString, required = true,
                                 default = nil)
  if valid_608631 != nil:
    section.add "x-amzn-iot-principal", valid_608631
  var valid_608632 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608632 = validateParameter(valid_608632, JString, required = false,
                                 default = nil)
  if valid_608632 != nil:
    section.add "X-Amz-Content-Sha256", valid_608632
  var valid_608633 = header.getOrDefault("X-Amz-Date")
  valid_608633 = validateParameter(valid_608633, JString, required = false,
                                 default = nil)
  if valid_608633 != nil:
    section.add "X-Amz-Date", valid_608633
  var valid_608634 = header.getOrDefault("X-Amz-Credential")
  valid_608634 = validateParameter(valid_608634, JString, required = false,
                                 default = nil)
  if valid_608634 != nil:
    section.add "X-Amz-Credential", valid_608634
  var valid_608635 = header.getOrDefault("X-Amz-Security-Token")
  valid_608635 = validateParameter(valid_608635, JString, required = false,
                                 default = nil)
  if valid_608635 != nil:
    section.add "X-Amz-Security-Token", valid_608635
  var valid_608636 = header.getOrDefault("X-Amz-Algorithm")
  valid_608636 = validateParameter(valid_608636, JString, required = false,
                                 default = nil)
  if valid_608636 != nil:
    section.add "X-Amz-Algorithm", valid_608636
  var valid_608637 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608637 = validateParameter(valid_608637, JString, required = false,
                                 default = nil)
  if valid_608637 != nil:
    section.add "X-Amz-SignedHeaders", valid_608637
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608638: Call_ListPrincipalPolicies_608624; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ## 
  let valid = call_608638.validator(path, query, header, formData, body)
  let scheme = call_608638.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608638.url(scheme.get, call_608638.host, call_608638.base,
                         call_608638.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608638, url, valid)

proc call*(call_608639: Call_ListPrincipalPolicies_608624;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listPrincipalPolicies
  ## <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
  ##   isAscendingOrder: bool
  ##                   : Specifies the order for results. If true, results are returned in ascending creation order.
  ##   pageSize: int
  ##           : The result page size.
  ##   marker: string
  ##         : The marker for the next set of results.
  var query_608640 = newJObject()
  add(query_608640, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_608640, "pageSize", newJInt(pageSize))
  add(query_608640, "marker", newJString(marker))
  result = call_608639.call(nil, query_608640, nil, nil, nil)

var listPrincipalPolicies* = Call_ListPrincipalPolicies_608624(
    name: "listPrincipalPolicies", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/principal-policies#x-amzn-iot-principal",
    validator: validate_ListPrincipalPolicies_608625, base: "/",
    url: url_ListPrincipalPolicies_608626, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListPrincipalThings_608641 = ref object of OpenApiRestCall_605589
proc url_ListPrincipalThings_608643(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListPrincipalThings_608642(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  section = newJObject()
  var valid_608644 = query.getOrDefault("nextToken")
  valid_608644 = validateParameter(valid_608644, JString, required = false,
                                 default = nil)
  if valid_608644 != nil:
    section.add "nextToken", valid_608644
  var valid_608645 = query.getOrDefault("maxResults")
  valid_608645 = validateParameter(valid_608645, JInt, required = false, default = nil)
  if valid_608645 != nil:
    section.add "maxResults", valid_608645
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   x-amzn-principal: JString (required)
  ##                   : The principal.
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608646 = header.getOrDefault("X-Amz-Signature")
  valid_608646 = validateParameter(valid_608646, JString, required = false,
                                 default = nil)
  if valid_608646 != nil:
    section.add "X-Amz-Signature", valid_608646
  var valid_608647 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608647 = validateParameter(valid_608647, JString, required = false,
                                 default = nil)
  if valid_608647 != nil:
    section.add "X-Amz-Content-Sha256", valid_608647
  var valid_608648 = header.getOrDefault("X-Amz-Date")
  valid_608648 = validateParameter(valid_608648, JString, required = false,
                                 default = nil)
  if valid_608648 != nil:
    section.add "X-Amz-Date", valid_608648
  var valid_608649 = header.getOrDefault("X-Amz-Credential")
  valid_608649 = validateParameter(valid_608649, JString, required = false,
                                 default = nil)
  if valid_608649 != nil:
    section.add "X-Amz-Credential", valid_608649
  var valid_608650 = header.getOrDefault("X-Amz-Security-Token")
  valid_608650 = validateParameter(valid_608650, JString, required = false,
                                 default = nil)
  if valid_608650 != nil:
    section.add "X-Amz-Security-Token", valid_608650
  var valid_608651 = header.getOrDefault("X-Amz-Algorithm")
  valid_608651 = validateParameter(valid_608651, JString, required = false,
                                 default = nil)
  if valid_608651 != nil:
    section.add "X-Amz-Algorithm", valid_608651
  assert header != nil,
        "header argument is necessary due to required `x-amzn-principal` field"
  var valid_608652 = header.getOrDefault("x-amzn-principal")
  valid_608652 = validateParameter(valid_608652, JString, required = true,
                                 default = nil)
  if valid_608652 != nil:
    section.add "x-amzn-principal", valid_608652
  var valid_608653 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608653 = validateParameter(valid_608653, JString, required = false,
                                 default = nil)
  if valid_608653 != nil:
    section.add "X-Amz-SignedHeaders", valid_608653
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608654: Call_ListPrincipalThings_608641; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ## 
  let valid = call_608654.validator(path, query, header, formData, body)
  let scheme = call_608654.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608654.url(scheme.get, call_608654.host, call_608654.base,
                         call_608654.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608654, url, valid)

proc call*(call_608655: Call_ListPrincipalThings_608641; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listPrincipalThings
  ## Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. 
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  var query_608656 = newJObject()
  add(query_608656, "nextToken", newJString(nextToken))
  add(query_608656, "maxResults", newJInt(maxResults))
  result = call_608655.call(nil, query_608656, nil, nil, nil)

var listPrincipalThings* = Call_ListPrincipalThings_608641(
    name: "listPrincipalThings", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/principals/things#x-amzn-principal",
    validator: validate_ListPrincipalThings_608642, base: "/",
    url: url_ListPrincipalThings_608643, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListRoleAliases_608657 = ref object of OpenApiRestCall_605589
proc url_ListRoleAliases_608659(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListRoleAliases_608658(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Lists the role aliases registered in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   isAscendingOrder: JBool
  ##                   : Return the list of role aliases in ascending alphabetical order.
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  section = newJObject()
  var valid_608660 = query.getOrDefault("isAscendingOrder")
  valid_608660 = validateParameter(valid_608660, JBool, required = false, default = nil)
  if valid_608660 != nil:
    section.add "isAscendingOrder", valid_608660
  var valid_608661 = query.getOrDefault("pageSize")
  valid_608661 = validateParameter(valid_608661, JInt, required = false, default = nil)
  if valid_608661 != nil:
    section.add "pageSize", valid_608661
  var valid_608662 = query.getOrDefault("marker")
  valid_608662 = validateParameter(valid_608662, JString, required = false,
                                 default = nil)
  if valid_608662 != nil:
    section.add "marker", valid_608662
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608663 = header.getOrDefault("X-Amz-Signature")
  valid_608663 = validateParameter(valid_608663, JString, required = false,
                                 default = nil)
  if valid_608663 != nil:
    section.add "X-Amz-Signature", valid_608663
  var valid_608664 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608664 = validateParameter(valid_608664, JString, required = false,
                                 default = nil)
  if valid_608664 != nil:
    section.add "X-Amz-Content-Sha256", valid_608664
  var valid_608665 = header.getOrDefault("X-Amz-Date")
  valid_608665 = validateParameter(valid_608665, JString, required = false,
                                 default = nil)
  if valid_608665 != nil:
    section.add "X-Amz-Date", valid_608665
  var valid_608666 = header.getOrDefault("X-Amz-Credential")
  valid_608666 = validateParameter(valid_608666, JString, required = false,
                                 default = nil)
  if valid_608666 != nil:
    section.add "X-Amz-Credential", valid_608666
  var valid_608667 = header.getOrDefault("X-Amz-Security-Token")
  valid_608667 = validateParameter(valid_608667, JString, required = false,
                                 default = nil)
  if valid_608667 != nil:
    section.add "X-Amz-Security-Token", valid_608667
  var valid_608668 = header.getOrDefault("X-Amz-Algorithm")
  valid_608668 = validateParameter(valid_608668, JString, required = false,
                                 default = nil)
  if valid_608668 != nil:
    section.add "X-Amz-Algorithm", valid_608668
  var valid_608669 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608669 = validateParameter(valid_608669, JString, required = false,
                                 default = nil)
  if valid_608669 != nil:
    section.add "X-Amz-SignedHeaders", valid_608669
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608670: Call_ListRoleAliases_608657; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the role aliases registered in your account.
  ## 
  let valid = call_608670.validator(path, query, header, formData, body)
  let scheme = call_608670.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608670.url(scheme.get, call_608670.host, call_608670.base,
                         call_608670.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608670, url, valid)

proc call*(call_608671: Call_ListRoleAliases_608657;
          isAscendingOrder: bool = false; pageSize: int = 0; marker: string = ""): Recallable =
  ## listRoleAliases
  ## Lists the role aliases registered in your account.
  ##   isAscendingOrder: bool
  ##                   : Return the list of role aliases in ascending alphabetical order.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  var query_608672 = newJObject()
  add(query_608672, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_608672, "pageSize", newJInt(pageSize))
  add(query_608672, "marker", newJString(marker))
  result = call_608671.call(nil, query_608672, nil, nil, nil)

var listRoleAliases* = Call_ListRoleAliases_608657(name: "listRoleAliases",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/role-aliases",
    validator: validate_ListRoleAliases_608658, base: "/", url: url_ListRoleAliases_608659,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListScheduledAudits_608673 = ref object of OpenApiRestCall_605589
proc url_ListScheduledAudits_608675(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListScheduledAudits_608674(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists all of your scheduled audits.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time. The default is 25.
  section = newJObject()
  var valid_608676 = query.getOrDefault("nextToken")
  valid_608676 = validateParameter(valid_608676, JString, required = false,
                                 default = nil)
  if valid_608676 != nil:
    section.add "nextToken", valid_608676
  var valid_608677 = query.getOrDefault("maxResults")
  valid_608677 = validateParameter(valid_608677, JInt, required = false, default = nil)
  if valid_608677 != nil:
    section.add "maxResults", valid_608677
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608678 = header.getOrDefault("X-Amz-Signature")
  valid_608678 = validateParameter(valid_608678, JString, required = false,
                                 default = nil)
  if valid_608678 != nil:
    section.add "X-Amz-Signature", valid_608678
  var valid_608679 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608679 = validateParameter(valid_608679, JString, required = false,
                                 default = nil)
  if valid_608679 != nil:
    section.add "X-Amz-Content-Sha256", valid_608679
  var valid_608680 = header.getOrDefault("X-Amz-Date")
  valid_608680 = validateParameter(valid_608680, JString, required = false,
                                 default = nil)
  if valid_608680 != nil:
    section.add "X-Amz-Date", valid_608680
  var valid_608681 = header.getOrDefault("X-Amz-Credential")
  valid_608681 = validateParameter(valid_608681, JString, required = false,
                                 default = nil)
  if valid_608681 != nil:
    section.add "X-Amz-Credential", valid_608681
  var valid_608682 = header.getOrDefault("X-Amz-Security-Token")
  valid_608682 = validateParameter(valid_608682, JString, required = false,
                                 default = nil)
  if valid_608682 != nil:
    section.add "X-Amz-Security-Token", valid_608682
  var valid_608683 = header.getOrDefault("X-Amz-Algorithm")
  valid_608683 = validateParameter(valid_608683, JString, required = false,
                                 default = nil)
  if valid_608683 != nil:
    section.add "X-Amz-Algorithm", valid_608683
  var valid_608684 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608684 = validateParameter(valid_608684, JString, required = false,
                                 default = nil)
  if valid_608684 != nil:
    section.add "X-Amz-SignedHeaders", valid_608684
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608685: Call_ListScheduledAudits_608673; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all of your scheduled audits.
  ## 
  let valid = call_608685.validator(path, query, header, formData, body)
  let scheme = call_608685.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608685.url(scheme.get, call_608685.host, call_608685.base,
                         call_608685.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608685, url, valid)

proc call*(call_608686: Call_ListScheduledAudits_608673; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listScheduledAudits
  ## Lists all of your scheduled audits.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time. The default is 25.
  var query_608687 = newJObject()
  add(query_608687, "nextToken", newJString(nextToken))
  add(query_608687, "maxResults", newJInt(maxResults))
  result = call_608686.call(nil, query_608687, nil, nil, nil)

var listScheduledAudits* = Call_ListScheduledAudits_608673(
    name: "listScheduledAudits", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/audit/scheduledaudits",
    validator: validate_ListScheduledAudits_608674, base: "/",
    url: url_ListScheduledAudits_608675, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListSecurityProfiles_608688 = ref object of OpenApiRestCall_605589
proc url_ListSecurityProfiles_608690(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListSecurityProfiles_608689(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_608691 = query.getOrDefault("nextToken")
  valid_608691 = validateParameter(valid_608691, JString, required = false,
                                 default = nil)
  if valid_608691 != nil:
    section.add "nextToken", valid_608691
  var valid_608692 = query.getOrDefault("maxResults")
  valid_608692 = validateParameter(valid_608692, JInt, required = false, default = nil)
  if valid_608692 != nil:
    section.add "maxResults", valid_608692
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608693 = header.getOrDefault("X-Amz-Signature")
  valid_608693 = validateParameter(valid_608693, JString, required = false,
                                 default = nil)
  if valid_608693 != nil:
    section.add "X-Amz-Signature", valid_608693
  var valid_608694 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608694 = validateParameter(valid_608694, JString, required = false,
                                 default = nil)
  if valid_608694 != nil:
    section.add "X-Amz-Content-Sha256", valid_608694
  var valid_608695 = header.getOrDefault("X-Amz-Date")
  valid_608695 = validateParameter(valid_608695, JString, required = false,
                                 default = nil)
  if valid_608695 != nil:
    section.add "X-Amz-Date", valid_608695
  var valid_608696 = header.getOrDefault("X-Amz-Credential")
  valid_608696 = validateParameter(valid_608696, JString, required = false,
                                 default = nil)
  if valid_608696 != nil:
    section.add "X-Amz-Credential", valid_608696
  var valid_608697 = header.getOrDefault("X-Amz-Security-Token")
  valid_608697 = validateParameter(valid_608697, JString, required = false,
                                 default = nil)
  if valid_608697 != nil:
    section.add "X-Amz-Security-Token", valid_608697
  var valid_608698 = header.getOrDefault("X-Amz-Algorithm")
  valid_608698 = validateParameter(valid_608698, JString, required = false,
                                 default = nil)
  if valid_608698 != nil:
    section.add "X-Amz-Algorithm", valid_608698
  var valid_608699 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608699 = validateParameter(valid_608699, JString, required = false,
                                 default = nil)
  if valid_608699 != nil:
    section.add "X-Amz-SignedHeaders", valid_608699
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608700: Call_ListSecurityProfiles_608688; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ## 
  let valid = call_608700.validator(path, query, header, formData, body)
  let scheme = call_608700.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608700.url(scheme.get, call_608700.host, call_608700.base,
                         call_608700.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608700, url, valid)

proc call*(call_608701: Call_ListSecurityProfiles_608688; nextToken: string = "";
          maxResults: int = 0): Recallable =
  ## listSecurityProfiles
  ## Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_608702 = newJObject()
  add(query_608702, "nextToken", newJString(nextToken))
  add(query_608702, "maxResults", newJInt(maxResults))
  result = call_608701.call(nil, query_608702, nil, nil, nil)

var listSecurityProfiles* = Call_ListSecurityProfiles_608688(
    name: "listSecurityProfiles", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/security-profiles",
    validator: validate_ListSecurityProfiles_608689, base: "/",
    url: url_ListSecurityProfiles_608690, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListSecurityProfilesForTarget_608703 = ref object of OpenApiRestCall_605589
proc url_ListSecurityProfilesForTarget_608705(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListSecurityProfilesForTarget_608704(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   recursive: JBool
  ##            : If true, return child groups too.
  ##   securityProfileTargetArn: JString (required)
  ##                           : The ARN of the target (thing group) whose attached security profiles you want to get.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_608706 = query.getOrDefault("nextToken")
  valid_608706 = validateParameter(valid_608706, JString, required = false,
                                 default = nil)
  if valid_608706 != nil:
    section.add "nextToken", valid_608706
  var valid_608707 = query.getOrDefault("recursive")
  valid_608707 = validateParameter(valid_608707, JBool, required = false, default = nil)
  if valid_608707 != nil:
    section.add "recursive", valid_608707
  assert query != nil, "query argument is necessary due to required `securityProfileTargetArn` field"
  var valid_608708 = query.getOrDefault("securityProfileTargetArn")
  valid_608708 = validateParameter(valid_608708, JString, required = true,
                                 default = nil)
  if valid_608708 != nil:
    section.add "securityProfileTargetArn", valid_608708
  var valid_608709 = query.getOrDefault("maxResults")
  valid_608709 = validateParameter(valid_608709, JInt, required = false, default = nil)
  if valid_608709 != nil:
    section.add "maxResults", valid_608709
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608710 = header.getOrDefault("X-Amz-Signature")
  valid_608710 = validateParameter(valid_608710, JString, required = false,
                                 default = nil)
  if valid_608710 != nil:
    section.add "X-Amz-Signature", valid_608710
  var valid_608711 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608711 = validateParameter(valid_608711, JString, required = false,
                                 default = nil)
  if valid_608711 != nil:
    section.add "X-Amz-Content-Sha256", valid_608711
  var valid_608712 = header.getOrDefault("X-Amz-Date")
  valid_608712 = validateParameter(valid_608712, JString, required = false,
                                 default = nil)
  if valid_608712 != nil:
    section.add "X-Amz-Date", valid_608712
  var valid_608713 = header.getOrDefault("X-Amz-Credential")
  valid_608713 = validateParameter(valid_608713, JString, required = false,
                                 default = nil)
  if valid_608713 != nil:
    section.add "X-Amz-Credential", valid_608713
  var valid_608714 = header.getOrDefault("X-Amz-Security-Token")
  valid_608714 = validateParameter(valid_608714, JString, required = false,
                                 default = nil)
  if valid_608714 != nil:
    section.add "X-Amz-Security-Token", valid_608714
  var valid_608715 = header.getOrDefault("X-Amz-Algorithm")
  valid_608715 = validateParameter(valid_608715, JString, required = false,
                                 default = nil)
  if valid_608715 != nil:
    section.add "X-Amz-Algorithm", valid_608715
  var valid_608716 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608716 = validateParameter(valid_608716, JString, required = false,
                                 default = nil)
  if valid_608716 != nil:
    section.add "X-Amz-SignedHeaders", valid_608716
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608717: Call_ListSecurityProfilesForTarget_608703; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ## 
  let valid = call_608717.validator(path, query, header, formData, body)
  let scheme = call_608717.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608717.url(scheme.get, call_608717.host, call_608717.base,
                         call_608717.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608717, url, valid)

proc call*(call_608718: Call_ListSecurityProfilesForTarget_608703;
          securityProfileTargetArn: string; nextToken: string = "";
          recursive: bool = false; maxResults: int = 0): Recallable =
  ## listSecurityProfilesForTarget
  ## Lists the Device Defender security profiles attached to a target (thing group).
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   recursive: bool
  ##            : If true, return child groups too.
  ##   securityProfileTargetArn: string (required)
  ##                           : The ARN of the target (thing group) whose attached security profiles you want to get.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_608719 = newJObject()
  add(query_608719, "nextToken", newJString(nextToken))
  add(query_608719, "recursive", newJBool(recursive))
  add(query_608719, "securityProfileTargetArn",
      newJString(securityProfileTargetArn))
  add(query_608719, "maxResults", newJInt(maxResults))
  result = call_608718.call(nil, query_608719, nil, nil, nil)

var listSecurityProfilesForTarget* = Call_ListSecurityProfilesForTarget_608703(
    name: "listSecurityProfilesForTarget", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/security-profiles-for-target#securityProfileTargetArn",
    validator: validate_ListSecurityProfilesForTarget_608704, base: "/",
    url: url_ListSecurityProfilesForTarget_608705,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListStreams_608720 = ref object of OpenApiRestCall_605589
proc url_ListStreams_608722(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListStreams_608721(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all of the streams in your AWS account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token used to get the next set of results.
  ##   isAscendingOrder: JBool
  ##                   : Set to true to return the list of streams in ascending order.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at a time.
  section = newJObject()
  var valid_608723 = query.getOrDefault("nextToken")
  valid_608723 = validateParameter(valid_608723, JString, required = false,
                                 default = nil)
  if valid_608723 != nil:
    section.add "nextToken", valid_608723
  var valid_608724 = query.getOrDefault("isAscendingOrder")
  valid_608724 = validateParameter(valid_608724, JBool, required = false, default = nil)
  if valid_608724 != nil:
    section.add "isAscendingOrder", valid_608724
  var valid_608725 = query.getOrDefault("maxResults")
  valid_608725 = validateParameter(valid_608725, JInt, required = false, default = nil)
  if valid_608725 != nil:
    section.add "maxResults", valid_608725
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608726 = header.getOrDefault("X-Amz-Signature")
  valid_608726 = validateParameter(valid_608726, JString, required = false,
                                 default = nil)
  if valid_608726 != nil:
    section.add "X-Amz-Signature", valid_608726
  var valid_608727 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608727 = validateParameter(valid_608727, JString, required = false,
                                 default = nil)
  if valid_608727 != nil:
    section.add "X-Amz-Content-Sha256", valid_608727
  var valid_608728 = header.getOrDefault("X-Amz-Date")
  valid_608728 = validateParameter(valid_608728, JString, required = false,
                                 default = nil)
  if valid_608728 != nil:
    section.add "X-Amz-Date", valid_608728
  var valid_608729 = header.getOrDefault("X-Amz-Credential")
  valid_608729 = validateParameter(valid_608729, JString, required = false,
                                 default = nil)
  if valid_608729 != nil:
    section.add "X-Amz-Credential", valid_608729
  var valid_608730 = header.getOrDefault("X-Amz-Security-Token")
  valid_608730 = validateParameter(valid_608730, JString, required = false,
                                 default = nil)
  if valid_608730 != nil:
    section.add "X-Amz-Security-Token", valid_608730
  var valid_608731 = header.getOrDefault("X-Amz-Algorithm")
  valid_608731 = validateParameter(valid_608731, JString, required = false,
                                 default = nil)
  if valid_608731 != nil:
    section.add "X-Amz-Algorithm", valid_608731
  var valid_608732 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608732 = validateParameter(valid_608732, JString, required = false,
                                 default = nil)
  if valid_608732 != nil:
    section.add "X-Amz-SignedHeaders", valid_608732
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608733: Call_ListStreams_608720; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all of the streams in your AWS account.
  ## 
  let valid = call_608733.validator(path, query, header, formData, body)
  let scheme = call_608733.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608733.url(scheme.get, call_608733.host, call_608733.base,
                         call_608733.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608733, url, valid)

proc call*(call_608734: Call_ListStreams_608720; nextToken: string = "";
          isAscendingOrder: bool = false; maxResults: int = 0): Recallable =
  ## listStreams
  ## Lists all of the streams in your AWS account.
  ##   nextToken: string
  ##            : A token used to get the next set of results.
  ##   isAscendingOrder: bool
  ##                   : Set to true to return the list of streams in ascending order.
  ##   maxResults: int
  ##             : The maximum number of results to return at a time.
  var query_608735 = newJObject()
  add(query_608735, "nextToken", newJString(nextToken))
  add(query_608735, "isAscendingOrder", newJBool(isAscendingOrder))
  add(query_608735, "maxResults", newJInt(maxResults))
  result = call_608734.call(nil, query_608735, nil, nil, nil)

var listStreams* = Call_ListStreams_608720(name: "listStreams",
                                        meth: HttpMethod.HttpGet,
                                        host: "iot.amazonaws.com",
                                        route: "/streams",
                                        validator: validate_ListStreams_608721,
                                        base: "/", url: url_ListStreams_608722,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTagsForResource_608736 = ref object of OpenApiRestCall_605589
proc url_ListTagsForResource_608738(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListTagsForResource_608737(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the tags (metadata) you have assigned to the resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   resourceArn: JString (required)
  ##              : The ARN of the resource.
  section = newJObject()
  var valid_608739 = query.getOrDefault("nextToken")
  valid_608739 = validateParameter(valid_608739, JString, required = false,
                                 default = nil)
  if valid_608739 != nil:
    section.add "nextToken", valid_608739
  assert query != nil,
        "query argument is necessary due to required `resourceArn` field"
  var valid_608740 = query.getOrDefault("resourceArn")
  valid_608740 = validateParameter(valid_608740, JString, required = true,
                                 default = nil)
  if valid_608740 != nil:
    section.add "resourceArn", valid_608740
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608741 = header.getOrDefault("X-Amz-Signature")
  valid_608741 = validateParameter(valid_608741, JString, required = false,
                                 default = nil)
  if valid_608741 != nil:
    section.add "X-Amz-Signature", valid_608741
  var valid_608742 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608742 = validateParameter(valid_608742, JString, required = false,
                                 default = nil)
  if valid_608742 != nil:
    section.add "X-Amz-Content-Sha256", valid_608742
  var valid_608743 = header.getOrDefault("X-Amz-Date")
  valid_608743 = validateParameter(valid_608743, JString, required = false,
                                 default = nil)
  if valid_608743 != nil:
    section.add "X-Amz-Date", valid_608743
  var valid_608744 = header.getOrDefault("X-Amz-Credential")
  valid_608744 = validateParameter(valid_608744, JString, required = false,
                                 default = nil)
  if valid_608744 != nil:
    section.add "X-Amz-Credential", valid_608744
  var valid_608745 = header.getOrDefault("X-Amz-Security-Token")
  valid_608745 = validateParameter(valid_608745, JString, required = false,
                                 default = nil)
  if valid_608745 != nil:
    section.add "X-Amz-Security-Token", valid_608745
  var valid_608746 = header.getOrDefault("X-Amz-Algorithm")
  valid_608746 = validateParameter(valid_608746, JString, required = false,
                                 default = nil)
  if valid_608746 != nil:
    section.add "X-Amz-Algorithm", valid_608746
  var valid_608747 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608747 = validateParameter(valid_608747, JString, required = false,
                                 default = nil)
  if valid_608747 != nil:
    section.add "X-Amz-SignedHeaders", valid_608747
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608748: Call_ListTagsForResource_608736; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the tags (metadata) you have assigned to the resource.
  ## 
  let valid = call_608748.validator(path, query, header, formData, body)
  let scheme = call_608748.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608748.url(scheme.get, call_608748.host, call_608748.base,
                         call_608748.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608748, url, valid)

proc call*(call_608749: Call_ListTagsForResource_608736; resourceArn: string;
          nextToken: string = ""): Recallable =
  ## listTagsForResource
  ## Lists the tags (metadata) you have assigned to the resource.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   resourceArn: string (required)
  ##              : The ARN of the resource.
  var query_608750 = newJObject()
  add(query_608750, "nextToken", newJString(nextToken))
  add(query_608750, "resourceArn", newJString(resourceArn))
  result = call_608749.call(nil, query_608750, nil, nil, nil)

var listTagsForResource* = Call_ListTagsForResource_608736(
    name: "listTagsForResource", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/tags#resourceArn",
    validator: validate_ListTagsForResource_608737, base: "/",
    url: url_ListTagsForResource_608738, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTargetsForPolicy_608751 = ref object of OpenApiRestCall_605589
proc url_ListTargetsForPolicy_608753(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "policyName" in path, "`policyName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/policy-targets/"),
               (kind: VariableSegment, value: "policyName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListTargetsForPolicy_608752(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List targets for the specified policy.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   policyName: JString (required)
  ##             : The policy name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `policyName` field"
  var valid_608754 = path.getOrDefault("policyName")
  valid_608754 = validateParameter(valid_608754, JString, required = true,
                                 default = nil)
  if valid_608754 != nil:
    section.add "policyName", valid_608754
  result.add "path", section
  ## parameters in `query` object:
  ##   pageSize: JInt
  ##           : The maximum number of results to return at one time.
  ##   marker: JString
  ##         : A marker used to get the next set of results.
  section = newJObject()
  var valid_608755 = query.getOrDefault("pageSize")
  valid_608755 = validateParameter(valid_608755, JInt, required = false, default = nil)
  if valid_608755 != nil:
    section.add "pageSize", valid_608755
  var valid_608756 = query.getOrDefault("marker")
  valid_608756 = validateParameter(valid_608756, JString, required = false,
                                 default = nil)
  if valid_608756 != nil:
    section.add "marker", valid_608756
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608757 = header.getOrDefault("X-Amz-Signature")
  valid_608757 = validateParameter(valid_608757, JString, required = false,
                                 default = nil)
  if valid_608757 != nil:
    section.add "X-Amz-Signature", valid_608757
  var valid_608758 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608758 = validateParameter(valid_608758, JString, required = false,
                                 default = nil)
  if valid_608758 != nil:
    section.add "X-Amz-Content-Sha256", valid_608758
  var valid_608759 = header.getOrDefault("X-Amz-Date")
  valid_608759 = validateParameter(valid_608759, JString, required = false,
                                 default = nil)
  if valid_608759 != nil:
    section.add "X-Amz-Date", valid_608759
  var valid_608760 = header.getOrDefault("X-Amz-Credential")
  valid_608760 = validateParameter(valid_608760, JString, required = false,
                                 default = nil)
  if valid_608760 != nil:
    section.add "X-Amz-Credential", valid_608760
  var valid_608761 = header.getOrDefault("X-Amz-Security-Token")
  valid_608761 = validateParameter(valid_608761, JString, required = false,
                                 default = nil)
  if valid_608761 != nil:
    section.add "X-Amz-Security-Token", valid_608761
  var valid_608762 = header.getOrDefault("X-Amz-Algorithm")
  valid_608762 = validateParameter(valid_608762, JString, required = false,
                                 default = nil)
  if valid_608762 != nil:
    section.add "X-Amz-Algorithm", valid_608762
  var valid_608763 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608763 = validateParameter(valid_608763, JString, required = false,
                                 default = nil)
  if valid_608763 != nil:
    section.add "X-Amz-SignedHeaders", valid_608763
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608764: Call_ListTargetsForPolicy_608751; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List targets for the specified policy.
  ## 
  let valid = call_608764.validator(path, query, header, formData, body)
  let scheme = call_608764.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608764.url(scheme.get, call_608764.host, call_608764.base,
                         call_608764.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608764, url, valid)

proc call*(call_608765: Call_ListTargetsForPolicy_608751; policyName: string;
          pageSize: int = 0; marker: string = ""): Recallable =
  ## listTargetsForPolicy
  ## List targets for the specified policy.
  ##   policyName: string (required)
  ##             : The policy name.
  ##   pageSize: int
  ##           : The maximum number of results to return at one time.
  ##   marker: string
  ##         : A marker used to get the next set of results.
  var path_608766 = newJObject()
  var query_608767 = newJObject()
  add(path_608766, "policyName", newJString(policyName))
  add(query_608767, "pageSize", newJInt(pageSize))
  add(query_608767, "marker", newJString(marker))
  result = call_608765.call(path_608766, query_608767, nil, nil, nil)

var listTargetsForPolicy* = Call_ListTargetsForPolicy_608751(
    name: "listTargetsForPolicy", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/policy-targets/{policyName}",
    validator: validate_ListTargetsForPolicy_608752, base: "/",
    url: url_ListTargetsForPolicy_608753, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTargetsForSecurityProfile_608768 = ref object of OpenApiRestCall_605589
proc url_ListTargetsForSecurityProfile_608770(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "securityProfileName" in path,
        "`securityProfileName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/security-profiles/"),
               (kind: VariableSegment, value: "securityProfileName"),
               (kind: ConstantSegment, value: "/targets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListTargetsForSecurityProfile_608769(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   securityProfileName: JString (required)
  ##                      : The security profile.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `securityProfileName` field"
  var valid_608771 = path.getOrDefault("securityProfileName")
  valid_608771 = validateParameter(valid_608771, JString, required = true,
                                 default = nil)
  if valid_608771 != nil:
    section.add "securityProfileName", valid_608771
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_608772 = query.getOrDefault("nextToken")
  valid_608772 = validateParameter(valid_608772, JString, required = false,
                                 default = nil)
  if valid_608772 != nil:
    section.add "nextToken", valid_608772
  var valid_608773 = query.getOrDefault("maxResults")
  valid_608773 = validateParameter(valid_608773, JInt, required = false, default = nil)
  if valid_608773 != nil:
    section.add "maxResults", valid_608773
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608774 = header.getOrDefault("X-Amz-Signature")
  valid_608774 = validateParameter(valid_608774, JString, required = false,
                                 default = nil)
  if valid_608774 != nil:
    section.add "X-Amz-Signature", valid_608774
  var valid_608775 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608775 = validateParameter(valid_608775, JString, required = false,
                                 default = nil)
  if valid_608775 != nil:
    section.add "X-Amz-Content-Sha256", valid_608775
  var valid_608776 = header.getOrDefault("X-Amz-Date")
  valid_608776 = validateParameter(valid_608776, JString, required = false,
                                 default = nil)
  if valid_608776 != nil:
    section.add "X-Amz-Date", valid_608776
  var valid_608777 = header.getOrDefault("X-Amz-Credential")
  valid_608777 = validateParameter(valid_608777, JString, required = false,
                                 default = nil)
  if valid_608777 != nil:
    section.add "X-Amz-Credential", valid_608777
  var valid_608778 = header.getOrDefault("X-Amz-Security-Token")
  valid_608778 = validateParameter(valid_608778, JString, required = false,
                                 default = nil)
  if valid_608778 != nil:
    section.add "X-Amz-Security-Token", valid_608778
  var valid_608779 = header.getOrDefault("X-Amz-Algorithm")
  valid_608779 = validateParameter(valid_608779, JString, required = false,
                                 default = nil)
  if valid_608779 != nil:
    section.add "X-Amz-Algorithm", valid_608779
  var valid_608780 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608780 = validateParameter(valid_608780, JString, required = false,
                                 default = nil)
  if valid_608780 != nil:
    section.add "X-Amz-SignedHeaders", valid_608780
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608781: Call_ListTargetsForSecurityProfile_608768; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ## 
  let valid = call_608781.validator(path, query, header, formData, body)
  let scheme = call_608781.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608781.url(scheme.get, call_608781.host, call_608781.base,
                         call_608781.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608781, url, valid)

proc call*(call_608782: Call_ListTargetsForSecurityProfile_608768;
          securityProfileName: string; nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listTargetsForSecurityProfile
  ## Lists the targets (thing groups) associated with a given Device Defender security profile.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   securityProfileName: string (required)
  ##                      : The security profile.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_608783 = newJObject()
  var query_608784 = newJObject()
  add(query_608784, "nextToken", newJString(nextToken))
  add(path_608783, "securityProfileName", newJString(securityProfileName))
  add(query_608784, "maxResults", newJInt(maxResults))
  result = call_608782.call(path_608783, query_608784, nil, nil, nil)

var listTargetsForSecurityProfile* = Call_ListTargetsForSecurityProfile_608768(
    name: "listTargetsForSecurityProfile", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/security-profiles/{securityProfileName}/targets",
    validator: validate_ListTargetsForSecurityProfile_608769, base: "/",
    url: url_ListTargetsForSecurityProfile_608770,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingGroups_608785 = ref object of OpenApiRestCall_605589
proc url_ListThingGroups_608787(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThingGroups_608786(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List the thing groups in your account.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   recursive: JBool
  ##            : If true, return child groups as well.
  ##   parentGroup: JString
  ##              : A filter that limits the results to those with the specified parent group.
  ##   namePrefixFilter: JString
  ##                   : A filter that limits the results to those with the specified name prefix.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_608788 = query.getOrDefault("nextToken")
  valid_608788 = validateParameter(valid_608788, JString, required = false,
                                 default = nil)
  if valid_608788 != nil:
    section.add "nextToken", valid_608788
  var valid_608789 = query.getOrDefault("recursive")
  valid_608789 = validateParameter(valid_608789, JBool, required = false, default = nil)
  if valid_608789 != nil:
    section.add "recursive", valid_608789
  var valid_608790 = query.getOrDefault("parentGroup")
  valid_608790 = validateParameter(valid_608790, JString, required = false,
                                 default = nil)
  if valid_608790 != nil:
    section.add "parentGroup", valid_608790
  var valid_608791 = query.getOrDefault("namePrefixFilter")
  valid_608791 = validateParameter(valid_608791, JString, required = false,
                                 default = nil)
  if valid_608791 != nil:
    section.add "namePrefixFilter", valid_608791
  var valid_608792 = query.getOrDefault("maxResults")
  valid_608792 = validateParameter(valid_608792, JInt, required = false, default = nil)
  if valid_608792 != nil:
    section.add "maxResults", valid_608792
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608793 = header.getOrDefault("X-Amz-Signature")
  valid_608793 = validateParameter(valid_608793, JString, required = false,
                                 default = nil)
  if valid_608793 != nil:
    section.add "X-Amz-Signature", valid_608793
  var valid_608794 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608794 = validateParameter(valid_608794, JString, required = false,
                                 default = nil)
  if valid_608794 != nil:
    section.add "X-Amz-Content-Sha256", valid_608794
  var valid_608795 = header.getOrDefault("X-Amz-Date")
  valid_608795 = validateParameter(valid_608795, JString, required = false,
                                 default = nil)
  if valid_608795 != nil:
    section.add "X-Amz-Date", valid_608795
  var valid_608796 = header.getOrDefault("X-Amz-Credential")
  valid_608796 = validateParameter(valid_608796, JString, required = false,
                                 default = nil)
  if valid_608796 != nil:
    section.add "X-Amz-Credential", valid_608796
  var valid_608797 = header.getOrDefault("X-Amz-Security-Token")
  valid_608797 = validateParameter(valid_608797, JString, required = false,
                                 default = nil)
  if valid_608797 != nil:
    section.add "X-Amz-Security-Token", valid_608797
  var valid_608798 = header.getOrDefault("X-Amz-Algorithm")
  valid_608798 = validateParameter(valid_608798, JString, required = false,
                                 default = nil)
  if valid_608798 != nil:
    section.add "X-Amz-Algorithm", valid_608798
  var valid_608799 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608799 = validateParameter(valid_608799, JString, required = false,
                                 default = nil)
  if valid_608799 != nil:
    section.add "X-Amz-SignedHeaders", valid_608799
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608800: Call_ListThingGroups_608785; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the thing groups in your account.
  ## 
  let valid = call_608800.validator(path, query, header, formData, body)
  let scheme = call_608800.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608800.url(scheme.get, call_608800.host, call_608800.base,
                         call_608800.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608800, url, valid)

proc call*(call_608801: Call_ListThingGroups_608785; nextToken: string = "";
          recursive: bool = false; parentGroup: string = "";
          namePrefixFilter: string = ""; maxResults: int = 0): Recallable =
  ## listThingGroups
  ## List the thing groups in your account.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   recursive: bool
  ##            : If true, return child groups as well.
  ##   parentGroup: string
  ##              : A filter that limits the results to those with the specified parent group.
  ##   namePrefixFilter: string
  ##                   : A filter that limits the results to those with the specified name prefix.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_608802 = newJObject()
  add(query_608802, "nextToken", newJString(nextToken))
  add(query_608802, "recursive", newJBool(recursive))
  add(query_608802, "parentGroup", newJString(parentGroup))
  add(query_608802, "namePrefixFilter", newJString(namePrefixFilter))
  add(query_608802, "maxResults", newJInt(maxResults))
  result = call_608801.call(nil, query_608802, nil, nil, nil)

var listThingGroups* = Call_ListThingGroups_608785(name: "listThingGroups",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/thing-groups",
    validator: validate_ListThingGroups_608786, base: "/", url: url_ListThingGroups_608787,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingGroupsForThing_608803 = ref object of OpenApiRestCall_605589
proc url_ListThingGroupsForThing_608805(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/thing-groups")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingGroupsForThing_608804(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List the thing groups to which the specified thing belongs.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The thing name.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_608806 = path.getOrDefault("thingName")
  valid_608806 = validateParameter(valid_608806, JString, required = true,
                                 default = nil)
  if valid_608806 != nil:
    section.add "thingName", valid_608806
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_608807 = query.getOrDefault("nextToken")
  valid_608807 = validateParameter(valid_608807, JString, required = false,
                                 default = nil)
  if valid_608807 != nil:
    section.add "nextToken", valid_608807
  var valid_608808 = query.getOrDefault("maxResults")
  valid_608808 = validateParameter(valid_608808, JInt, required = false, default = nil)
  if valid_608808 != nil:
    section.add "maxResults", valid_608808
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608809 = header.getOrDefault("X-Amz-Signature")
  valid_608809 = validateParameter(valid_608809, JString, required = false,
                                 default = nil)
  if valid_608809 != nil:
    section.add "X-Amz-Signature", valid_608809
  var valid_608810 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608810 = validateParameter(valid_608810, JString, required = false,
                                 default = nil)
  if valid_608810 != nil:
    section.add "X-Amz-Content-Sha256", valid_608810
  var valid_608811 = header.getOrDefault("X-Amz-Date")
  valid_608811 = validateParameter(valid_608811, JString, required = false,
                                 default = nil)
  if valid_608811 != nil:
    section.add "X-Amz-Date", valid_608811
  var valid_608812 = header.getOrDefault("X-Amz-Credential")
  valid_608812 = validateParameter(valid_608812, JString, required = false,
                                 default = nil)
  if valid_608812 != nil:
    section.add "X-Amz-Credential", valid_608812
  var valid_608813 = header.getOrDefault("X-Amz-Security-Token")
  valid_608813 = validateParameter(valid_608813, JString, required = false,
                                 default = nil)
  if valid_608813 != nil:
    section.add "X-Amz-Security-Token", valid_608813
  var valid_608814 = header.getOrDefault("X-Amz-Algorithm")
  valid_608814 = validateParameter(valid_608814, JString, required = false,
                                 default = nil)
  if valid_608814 != nil:
    section.add "X-Amz-Algorithm", valid_608814
  var valid_608815 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608815 = validateParameter(valid_608815, JString, required = false,
                                 default = nil)
  if valid_608815 != nil:
    section.add "X-Amz-SignedHeaders", valid_608815
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608816: Call_ListThingGroupsForThing_608803; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the thing groups to which the specified thing belongs.
  ## 
  let valid = call_608816.validator(path, query, header, formData, body)
  let scheme = call_608816.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608816.url(scheme.get, call_608816.host, call_608816.base,
                         call_608816.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608816, url, valid)

proc call*(call_608817: Call_ListThingGroupsForThing_608803; thingName: string;
          nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listThingGroupsForThing
  ## List the thing groups to which the specified thing belongs.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingName: string (required)
  ##            : The thing name.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_608818 = newJObject()
  var query_608819 = newJObject()
  add(query_608819, "nextToken", newJString(nextToken))
  add(path_608818, "thingName", newJString(thingName))
  add(query_608819, "maxResults", newJInt(maxResults))
  result = call_608817.call(path_608818, query_608819, nil, nil, nil)

var listThingGroupsForThing* = Call_ListThingGroupsForThing_608803(
    name: "listThingGroupsForThing", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/thing-groups",
    validator: validate_ListThingGroupsForThing_608804, base: "/",
    url: url_ListThingGroupsForThing_608805, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingPrincipals_608820 = ref object of OpenApiRestCall_605589
proc url_ListThingPrincipals_608822(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingName" in path, "`thingName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/things/"),
               (kind: VariableSegment, value: "thingName"),
               (kind: ConstantSegment, value: "/principals")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingPrincipals_608821(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingName: JString (required)
  ##            : The name of the thing.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `thingName` field"
  var valid_608823 = path.getOrDefault("thingName")
  valid_608823 = validateParameter(valid_608823, JString, required = true,
                                 default = nil)
  if valid_608823 != nil:
    section.add "thingName", valid_608823
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608824 = header.getOrDefault("X-Amz-Signature")
  valid_608824 = validateParameter(valid_608824, JString, required = false,
                                 default = nil)
  if valid_608824 != nil:
    section.add "X-Amz-Signature", valid_608824
  var valid_608825 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608825 = validateParameter(valid_608825, JString, required = false,
                                 default = nil)
  if valid_608825 != nil:
    section.add "X-Amz-Content-Sha256", valid_608825
  var valid_608826 = header.getOrDefault("X-Amz-Date")
  valid_608826 = validateParameter(valid_608826, JString, required = false,
                                 default = nil)
  if valid_608826 != nil:
    section.add "X-Amz-Date", valid_608826
  var valid_608827 = header.getOrDefault("X-Amz-Credential")
  valid_608827 = validateParameter(valid_608827, JString, required = false,
                                 default = nil)
  if valid_608827 != nil:
    section.add "X-Amz-Credential", valid_608827
  var valid_608828 = header.getOrDefault("X-Amz-Security-Token")
  valid_608828 = validateParameter(valid_608828, JString, required = false,
                                 default = nil)
  if valid_608828 != nil:
    section.add "X-Amz-Security-Token", valid_608828
  var valid_608829 = header.getOrDefault("X-Amz-Algorithm")
  valid_608829 = validateParameter(valid_608829, JString, required = false,
                                 default = nil)
  if valid_608829 != nil:
    section.add "X-Amz-Algorithm", valid_608829
  var valid_608830 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608830 = validateParameter(valid_608830, JString, required = false,
                                 default = nil)
  if valid_608830 != nil:
    section.add "X-Amz-SignedHeaders", valid_608830
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608831: Call_ListThingPrincipals_608820; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ## 
  let valid = call_608831.validator(path, query, header, formData, body)
  let scheme = call_608831.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608831.url(scheme.get, call_608831.host, call_608831.base,
                         call_608831.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608831, url, valid)

proc call*(call_608832: Call_ListThingPrincipals_608820; thingName: string): Recallable =
  ## listThingPrincipals
  ## Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.
  ##   thingName: string (required)
  ##            : The name of the thing.
  var path_608833 = newJObject()
  add(path_608833, "thingName", newJString(thingName))
  result = call_608832.call(path_608833, nil, nil, nil, nil)

var listThingPrincipals* = Call_ListThingPrincipals_608820(
    name: "listThingPrincipals", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/things/{thingName}/principals",
    validator: validate_ListThingPrincipals_608821, base: "/",
    url: url_ListThingPrincipals_608822, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingRegistrationTaskReports_608834 = ref object of OpenApiRestCall_605589
proc url_ListThingRegistrationTaskReports_608836(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/reports#reportType")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingRegistrationTaskReports_608835(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Information about the thing registration tasks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The id of the task.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_608837 = path.getOrDefault("taskId")
  valid_608837 = validateParameter(valid_608837, JString, required = true,
                                 default = nil)
  if valid_608837 != nil:
    section.add "taskId", valid_608837
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   reportType: JString (required)
  ##             : The type of task report.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_608838 = query.getOrDefault("nextToken")
  valid_608838 = validateParameter(valid_608838, JString, required = false,
                                 default = nil)
  if valid_608838 != nil:
    section.add "nextToken", valid_608838
  var valid_608839 = query.getOrDefault("reportType")
  valid_608839 = validateParameter(valid_608839, JString, required = true,
                                 default = newJString("ERRORS"))
  if valid_608839 != nil:
    section.add "reportType", valid_608839
  var valid_608840 = query.getOrDefault("maxResults")
  valid_608840 = validateParameter(valid_608840, JInt, required = false, default = nil)
  if valid_608840 != nil:
    section.add "maxResults", valid_608840
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608841 = header.getOrDefault("X-Amz-Signature")
  valid_608841 = validateParameter(valid_608841, JString, required = false,
                                 default = nil)
  if valid_608841 != nil:
    section.add "X-Amz-Signature", valid_608841
  var valid_608842 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608842 = validateParameter(valid_608842, JString, required = false,
                                 default = nil)
  if valid_608842 != nil:
    section.add "X-Amz-Content-Sha256", valid_608842
  var valid_608843 = header.getOrDefault("X-Amz-Date")
  valid_608843 = validateParameter(valid_608843, JString, required = false,
                                 default = nil)
  if valid_608843 != nil:
    section.add "X-Amz-Date", valid_608843
  var valid_608844 = header.getOrDefault("X-Amz-Credential")
  valid_608844 = validateParameter(valid_608844, JString, required = false,
                                 default = nil)
  if valid_608844 != nil:
    section.add "X-Amz-Credential", valid_608844
  var valid_608845 = header.getOrDefault("X-Amz-Security-Token")
  valid_608845 = validateParameter(valid_608845, JString, required = false,
                                 default = nil)
  if valid_608845 != nil:
    section.add "X-Amz-Security-Token", valid_608845
  var valid_608846 = header.getOrDefault("X-Amz-Algorithm")
  valid_608846 = validateParameter(valid_608846, JString, required = false,
                                 default = nil)
  if valid_608846 != nil:
    section.add "X-Amz-Algorithm", valid_608846
  var valid_608847 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608847 = validateParameter(valid_608847, JString, required = false,
                                 default = nil)
  if valid_608847 != nil:
    section.add "X-Amz-SignedHeaders", valid_608847
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608848: Call_ListThingRegistrationTaskReports_608834;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Information about the thing registration tasks.
  ## 
  let valid = call_608848.validator(path, query, header, formData, body)
  let scheme = call_608848.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608848.url(scheme.get, call_608848.host, call_608848.base,
                         call_608848.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608848, url, valid)

proc call*(call_608849: Call_ListThingRegistrationTaskReports_608834;
          taskId: string; nextToken: string = ""; reportType: string = "ERRORS";
          maxResults: int = 0): Recallable =
  ## listThingRegistrationTaskReports
  ## Information about the thing registration tasks.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   taskId: string (required)
  ##         : The id of the task.
  ##   reportType: string (required)
  ##             : The type of task report.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var path_608850 = newJObject()
  var query_608851 = newJObject()
  add(query_608851, "nextToken", newJString(nextToken))
  add(path_608850, "taskId", newJString(taskId))
  add(query_608851, "reportType", newJString(reportType))
  add(query_608851, "maxResults", newJInt(maxResults))
  result = call_608849.call(path_608850, query_608851, nil, nil, nil)

var listThingRegistrationTaskReports* = Call_ListThingRegistrationTaskReports_608834(
    name: "listThingRegistrationTaskReports", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com",
    route: "/thing-registration-tasks/{taskId}/reports#reportType",
    validator: validate_ListThingRegistrationTaskReports_608835, base: "/",
    url: url_ListThingRegistrationTaskReports_608836,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartThingRegistrationTask_608868 = ref object of OpenApiRestCall_605589
proc url_StartThingRegistrationTask_608870(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_StartThingRegistrationTask_608869(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608871 = header.getOrDefault("X-Amz-Signature")
  valid_608871 = validateParameter(valid_608871, JString, required = false,
                                 default = nil)
  if valid_608871 != nil:
    section.add "X-Amz-Signature", valid_608871
  var valid_608872 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608872 = validateParameter(valid_608872, JString, required = false,
                                 default = nil)
  if valid_608872 != nil:
    section.add "X-Amz-Content-Sha256", valid_608872
  var valid_608873 = header.getOrDefault("X-Amz-Date")
  valid_608873 = validateParameter(valid_608873, JString, required = false,
                                 default = nil)
  if valid_608873 != nil:
    section.add "X-Amz-Date", valid_608873
  var valid_608874 = header.getOrDefault("X-Amz-Credential")
  valid_608874 = validateParameter(valid_608874, JString, required = false,
                                 default = nil)
  if valid_608874 != nil:
    section.add "X-Amz-Credential", valid_608874
  var valid_608875 = header.getOrDefault("X-Amz-Security-Token")
  valid_608875 = validateParameter(valid_608875, JString, required = false,
                                 default = nil)
  if valid_608875 != nil:
    section.add "X-Amz-Security-Token", valid_608875
  var valid_608876 = header.getOrDefault("X-Amz-Algorithm")
  valid_608876 = validateParameter(valid_608876, JString, required = false,
                                 default = nil)
  if valid_608876 != nil:
    section.add "X-Amz-Algorithm", valid_608876
  var valid_608877 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608877 = validateParameter(valid_608877, JString, required = false,
                                 default = nil)
  if valid_608877 != nil:
    section.add "X-Amz-SignedHeaders", valid_608877
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_608879: Call_StartThingRegistrationTask_608868; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a bulk thing provisioning task.
  ## 
  let valid = call_608879.validator(path, query, header, formData, body)
  let scheme = call_608879.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608879.url(scheme.get, call_608879.host, call_608879.base,
                         call_608879.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608879, url, valid)

proc call*(call_608880: Call_StartThingRegistrationTask_608868; body: JsonNode): Recallable =
  ## startThingRegistrationTask
  ## Creates a bulk thing provisioning task.
  ##   body: JObject (required)
  var body_608881 = newJObject()
  if body != nil:
    body_608881 = body
  result = call_608880.call(nil, nil, nil, nil, body_608881)

var startThingRegistrationTask* = Call_StartThingRegistrationTask_608868(
    name: "startThingRegistrationTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks",
    validator: validate_StartThingRegistrationTask_608869, base: "/",
    url: url_StartThingRegistrationTask_608870,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingRegistrationTasks_608852 = ref object of OpenApiRestCall_605589
proc url_ListThingRegistrationTasks_608854(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThingRegistrationTasks_608853(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List bulk thing provisioning tasks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   status: JString
  ##         : The status of the bulk thing provisioning task.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_608855 = query.getOrDefault("nextToken")
  valid_608855 = validateParameter(valid_608855, JString, required = false,
                                 default = nil)
  if valid_608855 != nil:
    section.add "nextToken", valid_608855
  var valid_608856 = query.getOrDefault("status")
  valid_608856 = validateParameter(valid_608856, JString, required = false,
                                 default = newJString("InProgress"))
  if valid_608856 != nil:
    section.add "status", valid_608856
  var valid_608857 = query.getOrDefault("maxResults")
  valid_608857 = validateParameter(valid_608857, JInt, required = false, default = nil)
  if valid_608857 != nil:
    section.add "maxResults", valid_608857
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608858 = header.getOrDefault("X-Amz-Signature")
  valid_608858 = validateParameter(valid_608858, JString, required = false,
                                 default = nil)
  if valid_608858 != nil:
    section.add "X-Amz-Signature", valid_608858
  var valid_608859 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608859 = validateParameter(valid_608859, JString, required = false,
                                 default = nil)
  if valid_608859 != nil:
    section.add "X-Amz-Content-Sha256", valid_608859
  var valid_608860 = header.getOrDefault("X-Amz-Date")
  valid_608860 = validateParameter(valid_608860, JString, required = false,
                                 default = nil)
  if valid_608860 != nil:
    section.add "X-Amz-Date", valid_608860
  var valid_608861 = header.getOrDefault("X-Amz-Credential")
  valid_608861 = validateParameter(valid_608861, JString, required = false,
                                 default = nil)
  if valid_608861 != nil:
    section.add "X-Amz-Credential", valid_608861
  var valid_608862 = header.getOrDefault("X-Amz-Security-Token")
  valid_608862 = validateParameter(valid_608862, JString, required = false,
                                 default = nil)
  if valid_608862 != nil:
    section.add "X-Amz-Security-Token", valid_608862
  var valid_608863 = header.getOrDefault("X-Amz-Algorithm")
  valid_608863 = validateParameter(valid_608863, JString, required = false,
                                 default = nil)
  if valid_608863 != nil:
    section.add "X-Amz-Algorithm", valid_608863
  var valid_608864 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608864 = validateParameter(valid_608864, JString, required = false,
                                 default = nil)
  if valid_608864 != nil:
    section.add "X-Amz-SignedHeaders", valid_608864
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608865: Call_ListThingRegistrationTasks_608852; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List bulk thing provisioning tasks.
  ## 
  let valid = call_608865.validator(path, query, header, formData, body)
  let scheme = call_608865.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608865.url(scheme.get, call_608865.host, call_608865.base,
                         call_608865.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608865, url, valid)

proc call*(call_608866: Call_ListThingRegistrationTasks_608852;
          nextToken: string = ""; status: string = "InProgress"; maxResults: int = 0): Recallable =
  ## listThingRegistrationTasks
  ## List bulk thing provisioning tasks.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   status: string
  ##         : The status of the bulk thing provisioning task.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_608867 = newJObject()
  add(query_608867, "nextToken", newJString(nextToken))
  add(query_608867, "status", newJString(status))
  add(query_608867, "maxResults", newJInt(maxResults))
  result = call_608866.call(nil, query_608867, nil, nil, nil)

var listThingRegistrationTasks* = Call_ListThingRegistrationTasks_608852(
    name: "listThingRegistrationTasks", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks",
    validator: validate_ListThingRegistrationTasks_608853, base: "/",
    url: url_ListThingRegistrationTasks_608854,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingTypes_608882 = ref object of OpenApiRestCall_605589
proc url_ListThingTypes_608884(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThingTypes_608883(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the existing thing types.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   thingTypeName: JString
  ##                : The name of the thing type.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  section = newJObject()
  var valid_608885 = query.getOrDefault("nextToken")
  valid_608885 = validateParameter(valid_608885, JString, required = false,
                                 default = nil)
  if valid_608885 != nil:
    section.add "nextToken", valid_608885
  var valid_608886 = query.getOrDefault("thingTypeName")
  valid_608886 = validateParameter(valid_608886, JString, required = false,
                                 default = nil)
  if valid_608886 != nil:
    section.add "thingTypeName", valid_608886
  var valid_608887 = query.getOrDefault("maxResults")
  valid_608887 = validateParameter(valid_608887, JInt, required = false, default = nil)
  if valid_608887 != nil:
    section.add "maxResults", valid_608887
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608888 = header.getOrDefault("X-Amz-Signature")
  valid_608888 = validateParameter(valid_608888, JString, required = false,
                                 default = nil)
  if valid_608888 != nil:
    section.add "X-Amz-Signature", valid_608888
  var valid_608889 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608889 = validateParameter(valid_608889, JString, required = false,
                                 default = nil)
  if valid_608889 != nil:
    section.add "X-Amz-Content-Sha256", valid_608889
  var valid_608890 = header.getOrDefault("X-Amz-Date")
  valid_608890 = validateParameter(valid_608890, JString, required = false,
                                 default = nil)
  if valid_608890 != nil:
    section.add "X-Amz-Date", valid_608890
  var valid_608891 = header.getOrDefault("X-Amz-Credential")
  valid_608891 = validateParameter(valid_608891, JString, required = false,
                                 default = nil)
  if valid_608891 != nil:
    section.add "X-Amz-Credential", valid_608891
  var valid_608892 = header.getOrDefault("X-Amz-Security-Token")
  valid_608892 = validateParameter(valid_608892, JString, required = false,
                                 default = nil)
  if valid_608892 != nil:
    section.add "X-Amz-Security-Token", valid_608892
  var valid_608893 = header.getOrDefault("X-Amz-Algorithm")
  valid_608893 = validateParameter(valid_608893, JString, required = false,
                                 default = nil)
  if valid_608893 != nil:
    section.add "X-Amz-Algorithm", valid_608893
  var valid_608894 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608894 = validateParameter(valid_608894, JString, required = false,
                                 default = nil)
  if valid_608894 != nil:
    section.add "X-Amz-SignedHeaders", valid_608894
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608895: Call_ListThingTypes_608882; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the existing thing types.
  ## 
  let valid = call_608895.validator(path, query, header, formData, body)
  let scheme = call_608895.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608895.url(scheme.get, call_608895.host, call_608895.base,
                         call_608895.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608895, url, valid)

proc call*(call_608896: Call_ListThingTypes_608882; nextToken: string = "";
          thingTypeName: string = ""; maxResults: int = 0): Recallable =
  ## listThingTypes
  ## Lists the existing thing types.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingTypeName: string
  ##                : The name of the thing type.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  var query_608897 = newJObject()
  add(query_608897, "nextToken", newJString(nextToken))
  add(query_608897, "thingTypeName", newJString(thingTypeName))
  add(query_608897, "maxResults", newJInt(maxResults))
  result = call_608896.call(nil, query_608897, nil, nil, nil)

var listThingTypes* = Call_ListThingTypes_608882(name: "listThingTypes",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/thing-types",
    validator: validate_ListThingTypes_608883, base: "/", url: url_ListThingTypes_608884,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterThing_608916 = ref object of OpenApiRestCall_605589
proc url_RegisterThing_608918(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RegisterThing_608917(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608919 = header.getOrDefault("X-Amz-Signature")
  valid_608919 = validateParameter(valid_608919, JString, required = false,
                                 default = nil)
  if valid_608919 != nil:
    section.add "X-Amz-Signature", valid_608919
  var valid_608920 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608920 = validateParameter(valid_608920, JString, required = false,
                                 default = nil)
  if valid_608920 != nil:
    section.add "X-Amz-Content-Sha256", valid_608920
  var valid_608921 = header.getOrDefault("X-Amz-Date")
  valid_608921 = validateParameter(valid_608921, JString, required = false,
                                 default = nil)
  if valid_608921 != nil:
    section.add "X-Amz-Date", valid_608921
  var valid_608922 = header.getOrDefault("X-Amz-Credential")
  valid_608922 = validateParameter(valid_608922, JString, required = false,
                                 default = nil)
  if valid_608922 != nil:
    section.add "X-Amz-Credential", valid_608922
  var valid_608923 = header.getOrDefault("X-Amz-Security-Token")
  valid_608923 = validateParameter(valid_608923, JString, required = false,
                                 default = nil)
  if valid_608923 != nil:
    section.add "X-Amz-Security-Token", valid_608923
  var valid_608924 = header.getOrDefault("X-Amz-Algorithm")
  valid_608924 = validateParameter(valid_608924, JString, required = false,
                                 default = nil)
  if valid_608924 != nil:
    section.add "X-Amz-Algorithm", valid_608924
  var valid_608925 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608925 = validateParameter(valid_608925, JString, required = false,
                                 default = nil)
  if valid_608925 != nil:
    section.add "X-Amz-SignedHeaders", valid_608925
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_608927: Call_RegisterThing_608916; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.
  ## 
  let valid = call_608927.validator(path, query, header, formData, body)
  let scheme = call_608927.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608927.url(scheme.get, call_608927.host, call_608927.base,
                         call_608927.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608927, url, valid)

proc call*(call_608928: Call_RegisterThing_608916; body: JsonNode): Recallable =
  ## registerThing
  ## Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.
  ##   body: JObject (required)
  var body_608929 = newJObject()
  if body != nil:
    body_608929 = body
  result = call_608928.call(nil, nil, nil, nil, body_608929)

var registerThing* = Call_RegisterThing_608916(name: "registerThing",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/things",
    validator: validate_RegisterThing_608917, base: "/", url: url_RegisterThing_608918,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThings_608898 = ref object of OpenApiRestCall_605589
proc url_ListThings_608900(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListThings_608899(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   attributeName: JString
  ##                : The attribute name used to search for things.
  ##   thingTypeName: JString
  ##                : The name of the thing type used to search for things.
  ##   attributeValue: JString
  ##                 : The attribute value used to search for things.
  ##   maxResults: JInt
  ##             : The maximum number of results to return in this operation.
  section = newJObject()
  var valid_608901 = query.getOrDefault("nextToken")
  valid_608901 = validateParameter(valid_608901, JString, required = false,
                                 default = nil)
  if valid_608901 != nil:
    section.add "nextToken", valid_608901
  var valid_608902 = query.getOrDefault("attributeName")
  valid_608902 = validateParameter(valid_608902, JString, required = false,
                                 default = nil)
  if valid_608902 != nil:
    section.add "attributeName", valid_608902
  var valid_608903 = query.getOrDefault("thingTypeName")
  valid_608903 = validateParameter(valid_608903, JString, required = false,
                                 default = nil)
  if valid_608903 != nil:
    section.add "thingTypeName", valid_608903
  var valid_608904 = query.getOrDefault("attributeValue")
  valid_608904 = validateParameter(valid_608904, JString, required = false,
                                 default = nil)
  if valid_608904 != nil:
    section.add "attributeValue", valid_608904
  var valid_608905 = query.getOrDefault("maxResults")
  valid_608905 = validateParameter(valid_608905, JInt, required = false, default = nil)
  if valid_608905 != nil:
    section.add "maxResults", valid_608905
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608906 = header.getOrDefault("X-Amz-Signature")
  valid_608906 = validateParameter(valid_608906, JString, required = false,
                                 default = nil)
  if valid_608906 != nil:
    section.add "X-Amz-Signature", valid_608906
  var valid_608907 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608907 = validateParameter(valid_608907, JString, required = false,
                                 default = nil)
  if valid_608907 != nil:
    section.add "X-Amz-Content-Sha256", valid_608907
  var valid_608908 = header.getOrDefault("X-Amz-Date")
  valid_608908 = validateParameter(valid_608908, JString, required = false,
                                 default = nil)
  if valid_608908 != nil:
    section.add "X-Amz-Date", valid_608908
  var valid_608909 = header.getOrDefault("X-Amz-Credential")
  valid_608909 = validateParameter(valid_608909, JString, required = false,
                                 default = nil)
  if valid_608909 != nil:
    section.add "X-Amz-Credential", valid_608909
  var valid_608910 = header.getOrDefault("X-Amz-Security-Token")
  valid_608910 = validateParameter(valid_608910, JString, required = false,
                                 default = nil)
  if valid_608910 != nil:
    section.add "X-Amz-Security-Token", valid_608910
  var valid_608911 = header.getOrDefault("X-Amz-Algorithm")
  valid_608911 = validateParameter(valid_608911, JString, required = false,
                                 default = nil)
  if valid_608911 != nil:
    section.add "X-Amz-Algorithm", valid_608911
  var valid_608912 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608912 = validateParameter(valid_608912, JString, required = false,
                                 default = nil)
  if valid_608912 != nil:
    section.add "X-Amz-SignedHeaders", valid_608912
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608913: Call_ListThings_608898; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ## 
  let valid = call_608913.validator(path, query, header, formData, body)
  let scheme = call_608913.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608913.url(scheme.get, call_608913.host, call_608913.base,
                         call_608913.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608913, url, valid)

proc call*(call_608914: Call_ListThings_608898; nextToken: string = "";
          attributeName: string = ""; thingTypeName: string = "";
          attributeValue: string = ""; maxResults: int = 0): Recallable =
  ## listThings
  ## Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. 
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   attributeName: string
  ##                : The attribute name used to search for things.
  ##   thingTypeName: string
  ##                : The name of the thing type used to search for things.
  ##   attributeValue: string
  ##                 : The attribute value used to search for things.
  ##   maxResults: int
  ##             : The maximum number of results to return in this operation.
  var query_608915 = newJObject()
  add(query_608915, "nextToken", newJString(nextToken))
  add(query_608915, "attributeName", newJString(attributeName))
  add(query_608915, "thingTypeName", newJString(thingTypeName))
  add(query_608915, "attributeValue", newJString(attributeValue))
  add(query_608915, "maxResults", newJInt(maxResults))
  result = call_608914.call(nil, query_608915, nil, nil, nil)

var listThings* = Call_ListThings_608898(name: "listThings",
                                      meth: HttpMethod.HttpGet,
                                      host: "iot.amazonaws.com", route: "/things",
                                      validator: validate_ListThings_608899,
                                      base: "/", url: url_ListThings_608900,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingsInBillingGroup_608930 = ref object of OpenApiRestCall_605589
proc url_ListThingsInBillingGroup_608932(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "billingGroupName" in path,
        "`billingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/billing-groups/"),
               (kind: VariableSegment, value: "billingGroupName"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingsInBillingGroup_608931(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the things you have added to the given billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   billingGroupName: JString (required)
  ##                   : The name of the billing group.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `billingGroupName` field"
  var valid_608933 = path.getOrDefault("billingGroupName")
  valid_608933 = validateParameter(valid_608933, JString, required = true,
                                 default = nil)
  if valid_608933 != nil:
    section.add "billingGroupName", valid_608933
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   maxResults: JInt
  ##             : The maximum number of results to return per request.
  section = newJObject()
  var valid_608934 = query.getOrDefault("nextToken")
  valid_608934 = validateParameter(valid_608934, JString, required = false,
                                 default = nil)
  if valid_608934 != nil:
    section.add "nextToken", valid_608934
  var valid_608935 = query.getOrDefault("maxResults")
  valid_608935 = validateParameter(valid_608935, JInt, required = false, default = nil)
  if valid_608935 != nil:
    section.add "maxResults", valid_608935
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608936 = header.getOrDefault("X-Amz-Signature")
  valid_608936 = validateParameter(valid_608936, JString, required = false,
                                 default = nil)
  if valid_608936 != nil:
    section.add "X-Amz-Signature", valid_608936
  var valid_608937 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608937 = validateParameter(valid_608937, JString, required = false,
                                 default = nil)
  if valid_608937 != nil:
    section.add "X-Amz-Content-Sha256", valid_608937
  var valid_608938 = header.getOrDefault("X-Amz-Date")
  valid_608938 = validateParameter(valid_608938, JString, required = false,
                                 default = nil)
  if valid_608938 != nil:
    section.add "X-Amz-Date", valid_608938
  var valid_608939 = header.getOrDefault("X-Amz-Credential")
  valid_608939 = validateParameter(valid_608939, JString, required = false,
                                 default = nil)
  if valid_608939 != nil:
    section.add "X-Amz-Credential", valid_608939
  var valid_608940 = header.getOrDefault("X-Amz-Security-Token")
  valid_608940 = validateParameter(valid_608940, JString, required = false,
                                 default = nil)
  if valid_608940 != nil:
    section.add "X-Amz-Security-Token", valid_608940
  var valid_608941 = header.getOrDefault("X-Amz-Algorithm")
  valid_608941 = validateParameter(valid_608941, JString, required = false,
                                 default = nil)
  if valid_608941 != nil:
    section.add "X-Amz-Algorithm", valid_608941
  var valid_608942 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608942 = validateParameter(valid_608942, JString, required = false,
                                 default = nil)
  if valid_608942 != nil:
    section.add "X-Amz-SignedHeaders", valid_608942
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608943: Call_ListThingsInBillingGroup_608930; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things you have added to the given billing group.
  ## 
  let valid = call_608943.validator(path, query, header, formData, body)
  let scheme = call_608943.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608943.url(scheme.get, call_608943.host, call_608943.base,
                         call_608943.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608943, url, valid)

proc call*(call_608944: Call_ListThingsInBillingGroup_608930;
          billingGroupName: string; nextToken: string = ""; maxResults: int = 0): Recallable =
  ## listThingsInBillingGroup
  ## Lists the things you have added to the given billing group.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   billingGroupName: string (required)
  ##                   : The name of the billing group.
  ##   maxResults: int
  ##             : The maximum number of results to return per request.
  var path_608945 = newJObject()
  var query_608946 = newJObject()
  add(query_608946, "nextToken", newJString(nextToken))
  add(path_608945, "billingGroupName", newJString(billingGroupName))
  add(query_608946, "maxResults", newJInt(maxResults))
  result = call_608944.call(path_608945, query_608946, nil, nil, nil)

var listThingsInBillingGroup* = Call_ListThingsInBillingGroup_608930(
    name: "listThingsInBillingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/billing-groups/{billingGroupName}/things",
    validator: validate_ListThingsInBillingGroup_608931, base: "/",
    url: url_ListThingsInBillingGroup_608932, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListThingsInThingGroup_608947 = ref object of OpenApiRestCall_605589
proc url_ListThingsInThingGroup_608949(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "thingGroupName" in path, "`thingGroupName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-groups/"),
               (kind: VariableSegment, value: "thingGroupName"),
               (kind: ConstantSegment, value: "/things")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_ListThingsInThingGroup_608948(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the things in the specified group.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   thingGroupName: JString (required)
  ##                 : The thing group name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `thingGroupName` field"
  var valid_608950 = path.getOrDefault("thingGroupName")
  valid_608950 = validateParameter(valid_608950, JString, required = true,
                                 default = nil)
  if valid_608950 != nil:
    section.add "thingGroupName", valid_608950
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token to retrieve the next set of results.
  ##   recursive: JBool
  ##            : When true, list things in this thing group and in all child groups as well.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_608951 = query.getOrDefault("nextToken")
  valid_608951 = validateParameter(valid_608951, JString, required = false,
                                 default = nil)
  if valid_608951 != nil:
    section.add "nextToken", valid_608951
  var valid_608952 = query.getOrDefault("recursive")
  valid_608952 = validateParameter(valid_608952, JBool, required = false, default = nil)
  if valid_608952 != nil:
    section.add "recursive", valid_608952
  var valid_608953 = query.getOrDefault("maxResults")
  valid_608953 = validateParameter(valid_608953, JInt, required = false, default = nil)
  if valid_608953 != nil:
    section.add "maxResults", valid_608953
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608954 = header.getOrDefault("X-Amz-Signature")
  valid_608954 = validateParameter(valid_608954, JString, required = false,
                                 default = nil)
  if valid_608954 != nil:
    section.add "X-Amz-Signature", valid_608954
  var valid_608955 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608955 = validateParameter(valid_608955, JString, required = false,
                                 default = nil)
  if valid_608955 != nil:
    section.add "X-Amz-Content-Sha256", valid_608955
  var valid_608956 = header.getOrDefault("X-Amz-Date")
  valid_608956 = validateParameter(valid_608956, JString, required = false,
                                 default = nil)
  if valid_608956 != nil:
    section.add "X-Amz-Date", valid_608956
  var valid_608957 = header.getOrDefault("X-Amz-Credential")
  valid_608957 = validateParameter(valid_608957, JString, required = false,
                                 default = nil)
  if valid_608957 != nil:
    section.add "X-Amz-Credential", valid_608957
  var valid_608958 = header.getOrDefault("X-Amz-Security-Token")
  valid_608958 = validateParameter(valid_608958, JString, required = false,
                                 default = nil)
  if valid_608958 != nil:
    section.add "X-Amz-Security-Token", valid_608958
  var valid_608959 = header.getOrDefault("X-Amz-Algorithm")
  valid_608959 = validateParameter(valid_608959, JString, required = false,
                                 default = nil)
  if valid_608959 != nil:
    section.add "X-Amz-Algorithm", valid_608959
  var valid_608960 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608960 = validateParameter(valid_608960, JString, required = false,
                                 default = nil)
  if valid_608960 != nil:
    section.add "X-Amz-SignedHeaders", valid_608960
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608961: Call_ListThingsInThingGroup_608947; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the things in the specified group.
  ## 
  let valid = call_608961.validator(path, query, header, formData, body)
  let scheme = call_608961.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608961.url(scheme.get, call_608961.host, call_608961.base,
                         call_608961.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608961, url, valid)

proc call*(call_608962: Call_ListThingsInThingGroup_608947; thingGroupName: string;
          nextToken: string = ""; recursive: bool = false; maxResults: int = 0): Recallable =
  ## listThingsInThingGroup
  ## Lists the things in the specified group.
  ##   nextToken: string
  ##            : The token to retrieve the next set of results.
  ##   thingGroupName: string (required)
  ##                 : The thing group name.
  ##   recursive: bool
  ##            : When true, list things in this thing group and in all child groups as well.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var path_608963 = newJObject()
  var query_608964 = newJObject()
  add(query_608964, "nextToken", newJString(nextToken))
  add(path_608963, "thingGroupName", newJString(thingGroupName))
  add(query_608964, "recursive", newJBool(recursive))
  add(query_608964, "maxResults", newJInt(maxResults))
  result = call_608962.call(path_608963, query_608964, nil, nil, nil)

var listThingsInThingGroup* = Call_ListThingsInThingGroup_608947(
    name: "listThingsInThingGroup", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/thing-groups/{thingGroupName}/things",
    validator: validate_ListThingsInThingGroup_608948, base: "/",
    url: url_ListThingsInThingGroup_608949, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListTopicRules_608965 = ref object of OpenApiRestCall_605589
proc url_ListTopicRules_608967(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListTopicRules_608966(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Lists the rules for the specific topic.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : A token used to retrieve the next value.
  ##   topic: JString
  ##        : The topic.
  ##   ruleDisabled: JBool
  ##               : Specifies whether the rule is disabled.
  ##   maxResults: JInt
  ##             : The maximum number of results to return.
  section = newJObject()
  var valid_608968 = query.getOrDefault("nextToken")
  valid_608968 = validateParameter(valid_608968, JString, required = false,
                                 default = nil)
  if valid_608968 != nil:
    section.add "nextToken", valid_608968
  var valid_608969 = query.getOrDefault("topic")
  valid_608969 = validateParameter(valid_608969, JString, required = false,
                                 default = nil)
  if valid_608969 != nil:
    section.add "topic", valid_608969
  var valid_608970 = query.getOrDefault("ruleDisabled")
  valid_608970 = validateParameter(valid_608970, JBool, required = false, default = nil)
  if valid_608970 != nil:
    section.add "ruleDisabled", valid_608970
  var valid_608971 = query.getOrDefault("maxResults")
  valid_608971 = validateParameter(valid_608971, JInt, required = false, default = nil)
  if valid_608971 != nil:
    section.add "maxResults", valid_608971
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608972 = header.getOrDefault("X-Amz-Signature")
  valid_608972 = validateParameter(valid_608972, JString, required = false,
                                 default = nil)
  if valid_608972 != nil:
    section.add "X-Amz-Signature", valid_608972
  var valid_608973 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608973 = validateParameter(valid_608973, JString, required = false,
                                 default = nil)
  if valid_608973 != nil:
    section.add "X-Amz-Content-Sha256", valid_608973
  var valid_608974 = header.getOrDefault("X-Amz-Date")
  valid_608974 = validateParameter(valid_608974, JString, required = false,
                                 default = nil)
  if valid_608974 != nil:
    section.add "X-Amz-Date", valid_608974
  var valid_608975 = header.getOrDefault("X-Amz-Credential")
  valid_608975 = validateParameter(valid_608975, JString, required = false,
                                 default = nil)
  if valid_608975 != nil:
    section.add "X-Amz-Credential", valid_608975
  var valid_608976 = header.getOrDefault("X-Amz-Security-Token")
  valid_608976 = validateParameter(valid_608976, JString, required = false,
                                 default = nil)
  if valid_608976 != nil:
    section.add "X-Amz-Security-Token", valid_608976
  var valid_608977 = header.getOrDefault("X-Amz-Algorithm")
  valid_608977 = validateParameter(valid_608977, JString, required = false,
                                 default = nil)
  if valid_608977 != nil:
    section.add "X-Amz-Algorithm", valid_608977
  var valid_608978 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608978 = validateParameter(valid_608978, JString, required = false,
                                 default = nil)
  if valid_608978 != nil:
    section.add "X-Amz-SignedHeaders", valid_608978
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608979: Call_ListTopicRules_608965; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the rules for the specific topic.
  ## 
  let valid = call_608979.validator(path, query, header, formData, body)
  let scheme = call_608979.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608979.url(scheme.get, call_608979.host, call_608979.base,
                         call_608979.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608979, url, valid)

proc call*(call_608980: Call_ListTopicRules_608965; nextToken: string = "";
          topic: string = ""; ruleDisabled: bool = false; maxResults: int = 0): Recallable =
  ## listTopicRules
  ## Lists the rules for the specific topic.
  ##   nextToken: string
  ##            : A token used to retrieve the next value.
  ##   topic: string
  ##        : The topic.
  ##   ruleDisabled: bool
  ##               : Specifies whether the rule is disabled.
  ##   maxResults: int
  ##             : The maximum number of results to return.
  var query_608981 = newJObject()
  add(query_608981, "nextToken", newJString(nextToken))
  add(query_608981, "topic", newJString(topic))
  add(query_608981, "ruleDisabled", newJBool(ruleDisabled))
  add(query_608981, "maxResults", newJInt(maxResults))
  result = call_608980.call(nil, query_608981, nil, nil, nil)

var listTopicRules* = Call_ListTopicRules_608965(name: "listTopicRules",
    meth: HttpMethod.HttpGet, host: "iot.amazonaws.com", route: "/rules",
    validator: validate_ListTopicRules_608966, base: "/", url: url_ListTopicRules_608967,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_SetV2LoggingLevel_608998 = ref object of OpenApiRestCall_605589
proc url_SetV2LoggingLevel_609000(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SetV2LoggingLevel_608999(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Sets the logging level.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609001 = header.getOrDefault("X-Amz-Signature")
  valid_609001 = validateParameter(valid_609001, JString, required = false,
                                 default = nil)
  if valid_609001 != nil:
    section.add "X-Amz-Signature", valid_609001
  var valid_609002 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609002 = validateParameter(valid_609002, JString, required = false,
                                 default = nil)
  if valid_609002 != nil:
    section.add "X-Amz-Content-Sha256", valid_609002
  var valid_609003 = header.getOrDefault("X-Amz-Date")
  valid_609003 = validateParameter(valid_609003, JString, required = false,
                                 default = nil)
  if valid_609003 != nil:
    section.add "X-Amz-Date", valid_609003
  var valid_609004 = header.getOrDefault("X-Amz-Credential")
  valid_609004 = validateParameter(valid_609004, JString, required = false,
                                 default = nil)
  if valid_609004 != nil:
    section.add "X-Amz-Credential", valid_609004
  var valid_609005 = header.getOrDefault("X-Amz-Security-Token")
  valid_609005 = validateParameter(valid_609005, JString, required = false,
                                 default = nil)
  if valid_609005 != nil:
    section.add "X-Amz-Security-Token", valid_609005
  var valid_609006 = header.getOrDefault("X-Amz-Algorithm")
  valid_609006 = validateParameter(valid_609006, JString, required = false,
                                 default = nil)
  if valid_609006 != nil:
    section.add "X-Amz-Algorithm", valid_609006
  var valid_609007 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609007 = validateParameter(valid_609007, JString, required = false,
                                 default = nil)
  if valid_609007 != nil:
    section.add "X-Amz-SignedHeaders", valid_609007
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_609009: Call_SetV2LoggingLevel_608998; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets the logging level.
  ## 
  let valid = call_609009.validator(path, query, header, formData, body)
  let scheme = call_609009.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609009.url(scheme.get, call_609009.host, call_609009.base,
                         call_609009.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609009, url, valid)

proc call*(call_609010: Call_SetV2LoggingLevel_608998; body: JsonNode): Recallable =
  ## setV2LoggingLevel
  ## Sets the logging level.
  ##   body: JObject (required)
  var body_609011 = newJObject()
  if body != nil:
    body_609011 = body
  result = call_609010.call(nil, nil, nil, nil, body_609011)

var setV2LoggingLevel* = Call_SetV2LoggingLevel_608998(name: "setV2LoggingLevel",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/v2LoggingLevel",
    validator: validate_SetV2LoggingLevel_608999, base: "/",
    url: url_SetV2LoggingLevel_609000, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListV2LoggingLevels_608982 = ref object of OpenApiRestCall_605589
proc url_ListV2LoggingLevels_608984(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListV2LoggingLevels_608983(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists logging levels.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   nextToken: JString
  ##            : The token used to get the next set of results, or <b>null</b> if there are no additional results.
  ##   targetType: JString
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  var valid_608985 = query.getOrDefault("nextToken")
  valid_608985 = validateParameter(valid_608985, JString, required = false,
                                 default = nil)
  if valid_608985 != nil:
    section.add "nextToken", valid_608985
  var valid_608986 = query.getOrDefault("targetType")
  valid_608986 = validateParameter(valid_608986, JString, required = false,
                                 default = newJString("DEFAULT"))
  if valid_608986 != nil:
    section.add "targetType", valid_608986
  var valid_608987 = query.getOrDefault("maxResults")
  valid_608987 = validateParameter(valid_608987, JInt, required = false, default = nil)
  if valid_608987 != nil:
    section.add "maxResults", valid_608987
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_608988 = header.getOrDefault("X-Amz-Signature")
  valid_608988 = validateParameter(valid_608988, JString, required = false,
                                 default = nil)
  if valid_608988 != nil:
    section.add "X-Amz-Signature", valid_608988
  var valid_608989 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_608989 = validateParameter(valid_608989, JString, required = false,
                                 default = nil)
  if valid_608989 != nil:
    section.add "X-Amz-Content-Sha256", valid_608989
  var valid_608990 = header.getOrDefault("X-Amz-Date")
  valid_608990 = validateParameter(valid_608990, JString, required = false,
                                 default = nil)
  if valid_608990 != nil:
    section.add "X-Amz-Date", valid_608990
  var valid_608991 = header.getOrDefault("X-Amz-Credential")
  valid_608991 = validateParameter(valid_608991, JString, required = false,
                                 default = nil)
  if valid_608991 != nil:
    section.add "X-Amz-Credential", valid_608991
  var valid_608992 = header.getOrDefault("X-Amz-Security-Token")
  valid_608992 = validateParameter(valid_608992, JString, required = false,
                                 default = nil)
  if valid_608992 != nil:
    section.add "X-Amz-Security-Token", valid_608992
  var valid_608993 = header.getOrDefault("X-Amz-Algorithm")
  valid_608993 = validateParameter(valid_608993, JString, required = false,
                                 default = nil)
  if valid_608993 != nil:
    section.add "X-Amz-Algorithm", valid_608993
  var valid_608994 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_608994 = validateParameter(valid_608994, JString, required = false,
                                 default = nil)
  if valid_608994 != nil:
    section.add "X-Amz-SignedHeaders", valid_608994
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_608995: Call_ListV2LoggingLevels_608982; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists logging levels.
  ## 
  let valid = call_608995.validator(path, query, header, formData, body)
  let scheme = call_608995.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_608995.url(scheme.get, call_608995.host, call_608995.base,
                         call_608995.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_608995, url, valid)

proc call*(call_608996: Call_ListV2LoggingLevels_608982; nextToken: string = "";
          targetType: string = "DEFAULT"; maxResults: int = 0): Recallable =
  ## listV2LoggingLevels
  ## Lists logging levels.
  ##   nextToken: string
  ##            : The token used to get the next set of results, or <b>null</b> if there are no additional results.
  ##   targetType: string
  ##             : The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_608997 = newJObject()
  add(query_608997, "nextToken", newJString(nextToken))
  add(query_608997, "targetType", newJString(targetType))
  add(query_608997, "maxResults", newJInt(maxResults))
  result = call_608996.call(nil, query_608997, nil, nil, nil)

var listV2LoggingLevels* = Call_ListV2LoggingLevels_608982(
    name: "listV2LoggingLevels", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/v2LoggingLevel",
    validator: validate_ListV2LoggingLevels_608983, base: "/",
    url: url_ListV2LoggingLevels_608984, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ListViolationEvents_609012 = ref object of OpenApiRestCall_605589
proc url_ListViolationEvents_609014(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ListViolationEvents_609013(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   endTime: JString (required)
  ##          : The end time for the alerts to be listed.
  ##   nextToken: JString
  ##            : The token for the next set of results.
  ##   startTime: JString (required)
  ##            : The start time for the alerts to be listed.
  ##   securityProfileName: JString
  ##                      : A filter to limit results to those alerts generated by the specified security profile.
  ##   thingName: JString
  ##            : A filter to limit results to those alerts caused by the specified thing.
  ##   maxResults: JInt
  ##             : The maximum number of results to return at one time.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `endTime` field"
  var valid_609015 = query.getOrDefault("endTime")
  valid_609015 = validateParameter(valid_609015, JString, required = true,
                                 default = nil)
  if valid_609015 != nil:
    section.add "endTime", valid_609015
  var valid_609016 = query.getOrDefault("nextToken")
  valid_609016 = validateParameter(valid_609016, JString, required = false,
                                 default = nil)
  if valid_609016 != nil:
    section.add "nextToken", valid_609016
  var valid_609017 = query.getOrDefault("startTime")
  valid_609017 = validateParameter(valid_609017, JString, required = true,
                                 default = nil)
  if valid_609017 != nil:
    section.add "startTime", valid_609017
  var valid_609018 = query.getOrDefault("securityProfileName")
  valid_609018 = validateParameter(valid_609018, JString, required = false,
                                 default = nil)
  if valid_609018 != nil:
    section.add "securityProfileName", valid_609018
  var valid_609019 = query.getOrDefault("thingName")
  valid_609019 = validateParameter(valid_609019, JString, required = false,
                                 default = nil)
  if valid_609019 != nil:
    section.add "thingName", valid_609019
  var valid_609020 = query.getOrDefault("maxResults")
  valid_609020 = validateParameter(valid_609020, JInt, required = false, default = nil)
  if valid_609020 != nil:
    section.add "maxResults", valid_609020
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609021 = header.getOrDefault("X-Amz-Signature")
  valid_609021 = validateParameter(valid_609021, JString, required = false,
                                 default = nil)
  if valid_609021 != nil:
    section.add "X-Amz-Signature", valid_609021
  var valid_609022 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609022 = validateParameter(valid_609022, JString, required = false,
                                 default = nil)
  if valid_609022 != nil:
    section.add "X-Amz-Content-Sha256", valid_609022
  var valid_609023 = header.getOrDefault("X-Amz-Date")
  valid_609023 = validateParameter(valid_609023, JString, required = false,
                                 default = nil)
  if valid_609023 != nil:
    section.add "X-Amz-Date", valid_609023
  var valid_609024 = header.getOrDefault("X-Amz-Credential")
  valid_609024 = validateParameter(valid_609024, JString, required = false,
                                 default = nil)
  if valid_609024 != nil:
    section.add "X-Amz-Credential", valid_609024
  var valid_609025 = header.getOrDefault("X-Amz-Security-Token")
  valid_609025 = validateParameter(valid_609025, JString, required = false,
                                 default = nil)
  if valid_609025 != nil:
    section.add "X-Amz-Security-Token", valid_609025
  var valid_609026 = header.getOrDefault("X-Amz-Algorithm")
  valid_609026 = validateParameter(valid_609026, JString, required = false,
                                 default = nil)
  if valid_609026 != nil:
    section.add "X-Amz-Algorithm", valid_609026
  var valid_609027 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609027 = validateParameter(valid_609027, JString, required = false,
                                 default = nil)
  if valid_609027 != nil:
    section.add "X-Amz-SignedHeaders", valid_609027
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609028: Call_ListViolationEvents_609012; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ## 
  let valid = call_609028.validator(path, query, header, formData, body)
  let scheme = call_609028.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609028.url(scheme.get, call_609028.host, call_609028.base,
                         call_609028.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609028, url, valid)

proc call*(call_609029: Call_ListViolationEvents_609012; endTime: string;
          startTime: string; nextToken: string = ""; securityProfileName: string = "";
          thingName: string = ""; maxResults: int = 0): Recallable =
  ## listViolationEvents
  ## Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).
  ##   endTime: string (required)
  ##          : The end time for the alerts to be listed.
  ##   nextToken: string
  ##            : The token for the next set of results.
  ##   startTime: string (required)
  ##            : The start time for the alerts to be listed.
  ##   securityProfileName: string
  ##                      : A filter to limit results to those alerts generated by the specified security profile.
  ##   thingName: string
  ##            : A filter to limit results to those alerts caused by the specified thing.
  ##   maxResults: int
  ##             : The maximum number of results to return at one time.
  var query_609030 = newJObject()
  add(query_609030, "endTime", newJString(endTime))
  add(query_609030, "nextToken", newJString(nextToken))
  add(query_609030, "startTime", newJString(startTime))
  add(query_609030, "securityProfileName", newJString(securityProfileName))
  add(query_609030, "thingName", newJString(thingName))
  add(query_609030, "maxResults", newJInt(maxResults))
  result = call_609029.call(nil, query_609030, nil, nil, nil)

var listViolationEvents* = Call_ListViolationEvents_609012(
    name: "listViolationEvents", meth: HttpMethod.HttpGet,
    host: "iot.amazonaws.com", route: "/violation-events#startTime&endTime",
    validator: validate_ListViolationEvents_609013, base: "/",
    url: url_ListViolationEvents_609014, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterCACertificate_609031 = ref object of OpenApiRestCall_605589
proc url_RegisterCACertificate_609033(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RegisterCACertificate_609032(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   allowAutoRegistration: JBool
  ##                        : Allows this CA certificate to be used for auto registration of device certificates.
  ##   setAsActive: JBool
  ##              : A boolean value that specifies if the CA certificate is set to active.
  section = newJObject()
  var valid_609034 = query.getOrDefault("allowAutoRegistration")
  valid_609034 = validateParameter(valid_609034, JBool, required = false, default = nil)
  if valid_609034 != nil:
    section.add "allowAutoRegistration", valid_609034
  var valid_609035 = query.getOrDefault("setAsActive")
  valid_609035 = validateParameter(valid_609035, JBool, required = false, default = nil)
  if valid_609035 != nil:
    section.add "setAsActive", valid_609035
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609036 = header.getOrDefault("X-Amz-Signature")
  valid_609036 = validateParameter(valid_609036, JString, required = false,
                                 default = nil)
  if valid_609036 != nil:
    section.add "X-Amz-Signature", valid_609036
  var valid_609037 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609037 = validateParameter(valid_609037, JString, required = false,
                                 default = nil)
  if valid_609037 != nil:
    section.add "X-Amz-Content-Sha256", valid_609037
  var valid_609038 = header.getOrDefault("X-Amz-Date")
  valid_609038 = validateParameter(valid_609038, JString, required = false,
                                 default = nil)
  if valid_609038 != nil:
    section.add "X-Amz-Date", valid_609038
  var valid_609039 = header.getOrDefault("X-Amz-Credential")
  valid_609039 = validateParameter(valid_609039, JString, required = false,
                                 default = nil)
  if valid_609039 != nil:
    section.add "X-Amz-Credential", valid_609039
  var valid_609040 = header.getOrDefault("X-Amz-Security-Token")
  valid_609040 = validateParameter(valid_609040, JString, required = false,
                                 default = nil)
  if valid_609040 != nil:
    section.add "X-Amz-Security-Token", valid_609040
  var valid_609041 = header.getOrDefault("X-Amz-Algorithm")
  valid_609041 = validateParameter(valid_609041, JString, required = false,
                                 default = nil)
  if valid_609041 != nil:
    section.add "X-Amz-Algorithm", valid_609041
  var valid_609042 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609042 = validateParameter(valid_609042, JString, required = false,
                                 default = nil)
  if valid_609042 != nil:
    section.add "X-Amz-SignedHeaders", valid_609042
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_609044: Call_RegisterCACertificate_609031; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ## 
  let valid = call_609044.validator(path, query, header, formData, body)
  let scheme = call_609044.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609044.url(scheme.get, call_609044.host, call_609044.base,
                         call_609044.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609044, url, valid)

proc call*(call_609045: Call_RegisterCACertificate_609031; body: JsonNode;
          allowAutoRegistration: bool = false; setAsActive: bool = false): Recallable =
  ## registerCACertificate
  ## Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.
  ##   allowAutoRegistration: bool
  ##                        : Allows this CA certificate to be used for auto registration of device certificates.
  ##   setAsActive: bool
  ##              : A boolean value that specifies if the CA certificate is set to active.
  ##   body: JObject (required)
  var query_609046 = newJObject()
  var body_609047 = newJObject()
  add(query_609046, "allowAutoRegistration", newJBool(allowAutoRegistration))
  add(query_609046, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_609047 = body
  result = call_609045.call(nil, query_609046, nil, nil, body_609047)

var registerCACertificate* = Call_RegisterCACertificate_609031(
    name: "registerCACertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/cacertificate",
    validator: validate_RegisterCACertificate_609032, base: "/",
    url: url_RegisterCACertificate_609033, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RegisterCertificate_609048 = ref object of OpenApiRestCall_605589
proc url_RegisterCertificate_609050(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RegisterCertificate_609049(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   setAsActive: JBool
  ##              : A boolean value that specifies if the certificate is set to active.
  section = newJObject()
  var valid_609051 = query.getOrDefault("setAsActive")
  valid_609051 = validateParameter(valid_609051, JBool, required = false, default = nil)
  if valid_609051 != nil:
    section.add "setAsActive", valid_609051
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609052 = header.getOrDefault("X-Amz-Signature")
  valid_609052 = validateParameter(valid_609052, JString, required = false,
                                 default = nil)
  if valid_609052 != nil:
    section.add "X-Amz-Signature", valid_609052
  var valid_609053 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609053 = validateParameter(valid_609053, JString, required = false,
                                 default = nil)
  if valid_609053 != nil:
    section.add "X-Amz-Content-Sha256", valid_609053
  var valid_609054 = header.getOrDefault("X-Amz-Date")
  valid_609054 = validateParameter(valid_609054, JString, required = false,
                                 default = nil)
  if valid_609054 != nil:
    section.add "X-Amz-Date", valid_609054
  var valid_609055 = header.getOrDefault("X-Amz-Credential")
  valid_609055 = validateParameter(valid_609055, JString, required = false,
                                 default = nil)
  if valid_609055 != nil:
    section.add "X-Amz-Credential", valid_609055
  var valid_609056 = header.getOrDefault("X-Amz-Security-Token")
  valid_609056 = validateParameter(valid_609056, JString, required = false,
                                 default = nil)
  if valid_609056 != nil:
    section.add "X-Amz-Security-Token", valid_609056
  var valid_609057 = header.getOrDefault("X-Amz-Algorithm")
  valid_609057 = validateParameter(valid_609057, JString, required = false,
                                 default = nil)
  if valid_609057 != nil:
    section.add "X-Amz-Algorithm", valid_609057
  var valid_609058 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609058 = validateParameter(valid_609058, JString, required = false,
                                 default = nil)
  if valid_609058 != nil:
    section.add "X-Amz-SignedHeaders", valid_609058
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_609060: Call_RegisterCertificate_609048; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ## 
  let valid = call_609060.validator(path, query, header, formData, body)
  let scheme = call_609060.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609060.url(scheme.get, call_609060.host, call_609060.base,
                         call_609060.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609060, url, valid)

proc call*(call_609061: Call_RegisterCertificate_609048; body: JsonNode;
          setAsActive: bool = false): Recallable =
  ## registerCertificate
  ## Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.
  ##   setAsActive: bool
  ##              : A boolean value that specifies if the certificate is set to active.
  ##   body: JObject (required)
  var query_609062 = newJObject()
  var body_609063 = newJObject()
  add(query_609062, "setAsActive", newJBool(setAsActive))
  if body != nil:
    body_609063 = body
  result = call_609061.call(nil, query_609062, nil, nil, body_609063)

var registerCertificate* = Call_RegisterCertificate_609048(
    name: "registerCertificate", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/certificate/register",
    validator: validate_RegisterCertificate_609049, base: "/",
    url: url_RegisterCertificate_609050, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RejectCertificateTransfer_609064 = ref object of OpenApiRestCall_605589
proc url_RejectCertificateTransfer_609066(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/reject-certificate-transfer/"),
               (kind: VariableSegment, value: "certificateId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_RejectCertificateTransfer_609065(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_609067 = path.getOrDefault("certificateId")
  valid_609067 = validateParameter(valid_609067, JString, required = true,
                                 default = nil)
  if valid_609067 != nil:
    section.add "certificateId", valid_609067
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609068 = header.getOrDefault("X-Amz-Signature")
  valid_609068 = validateParameter(valid_609068, JString, required = false,
                                 default = nil)
  if valid_609068 != nil:
    section.add "X-Amz-Signature", valid_609068
  var valid_609069 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609069 = validateParameter(valid_609069, JString, required = false,
                                 default = nil)
  if valid_609069 != nil:
    section.add "X-Amz-Content-Sha256", valid_609069
  var valid_609070 = header.getOrDefault("X-Amz-Date")
  valid_609070 = validateParameter(valid_609070, JString, required = false,
                                 default = nil)
  if valid_609070 != nil:
    section.add "X-Amz-Date", valid_609070
  var valid_609071 = header.getOrDefault("X-Amz-Credential")
  valid_609071 = validateParameter(valid_609071, JString, required = false,
                                 default = nil)
  if valid_609071 != nil:
    section.add "X-Amz-Credential", valid_609071
  var valid_609072 = header.getOrDefault("X-Amz-Security-Token")
  valid_609072 = validateParameter(valid_609072, JString, required = false,
                                 default = nil)
  if valid_609072 != nil:
    section.add "X-Amz-Security-Token", valid_609072
  var valid_609073 = header.getOrDefault("X-Amz-Algorithm")
  valid_609073 = validateParameter(valid_609073, JString, required = false,
                                 default = nil)
  if valid_609073 != nil:
    section.add "X-Amz-Algorithm", valid_609073
  var valid_609074 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609074 = validateParameter(valid_609074, JString, required = false,
                                 default = nil)
  if valid_609074 != nil:
    section.add "X-Amz-SignedHeaders", valid_609074
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_609076: Call_RejectCertificateTransfer_609064; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ## 
  let valid = call_609076.validator(path, query, header, formData, body)
  let scheme = call_609076.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609076.url(scheme.get, call_609076.host, call_609076.base,
                         call_609076.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609076, url, valid)

proc call*(call_609077: Call_RejectCertificateTransfer_609064; body: JsonNode;
          certificateId: string): Recallable =
  ## rejectCertificateTransfer
  ## <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
  ##   body: JObject (required)
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_609078 = newJObject()
  var body_609079 = newJObject()
  if body != nil:
    body_609079 = body
  add(path_609078, "certificateId", newJString(certificateId))
  result = call_609077.call(path_609078, nil, nil, nil, body_609079)

var rejectCertificateTransfer* = Call_RejectCertificateTransfer_609064(
    name: "rejectCertificateTransfer", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/reject-certificate-transfer/{certificateId}",
    validator: validate_RejectCertificateTransfer_609065, base: "/",
    url: url_RejectCertificateTransfer_609066,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveThingFromBillingGroup_609080 = ref object of OpenApiRestCall_605589
proc url_RemoveThingFromBillingGroup_609082(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RemoveThingFromBillingGroup_609081(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes the given thing from the billing group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609083 = header.getOrDefault("X-Amz-Signature")
  valid_609083 = validateParameter(valid_609083, JString, required = false,
                                 default = nil)
  if valid_609083 != nil:
    section.add "X-Amz-Signature", valid_609083
  var valid_609084 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609084 = validateParameter(valid_609084, JString, required = false,
                                 default = nil)
  if valid_609084 != nil:
    section.add "X-Amz-Content-Sha256", valid_609084
  var valid_609085 = header.getOrDefault("X-Amz-Date")
  valid_609085 = validateParameter(valid_609085, JString, required = false,
                                 default = nil)
  if valid_609085 != nil:
    section.add "X-Amz-Date", valid_609085
  var valid_609086 = header.getOrDefault("X-Amz-Credential")
  valid_609086 = validateParameter(valid_609086, JString, required = false,
                                 default = nil)
  if valid_609086 != nil:
    section.add "X-Amz-Credential", valid_609086
  var valid_609087 = header.getOrDefault("X-Amz-Security-Token")
  valid_609087 = validateParameter(valid_609087, JString, required = false,
                                 default = nil)
  if valid_609087 != nil:
    section.add "X-Amz-Security-Token", valid_609087
  var valid_609088 = header.getOrDefault("X-Amz-Algorithm")
  valid_609088 = validateParameter(valid_609088, JString, required = false,
                                 default = nil)
  if valid_609088 != nil:
    section.add "X-Amz-Algorithm", valid_609088
  var valid_609089 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609089 = validateParameter(valid_609089, JString, required = false,
                                 default = nil)
  if valid_609089 != nil:
    section.add "X-Amz-SignedHeaders", valid_609089
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_609091: Call_RemoveThingFromBillingGroup_609080; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes the given thing from the billing group.
  ## 
  let valid = call_609091.validator(path, query, header, formData, body)
  let scheme = call_609091.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609091.url(scheme.get, call_609091.host, call_609091.base,
                         call_609091.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609091, url, valid)

proc call*(call_609092: Call_RemoveThingFromBillingGroup_609080; body: JsonNode): Recallable =
  ## removeThingFromBillingGroup
  ## Removes the given thing from the billing group.
  ##   body: JObject (required)
  var body_609093 = newJObject()
  if body != nil:
    body_609093 = body
  result = call_609092.call(nil, nil, nil, nil, body_609093)

var removeThingFromBillingGroup* = Call_RemoveThingFromBillingGroup_609080(
    name: "removeThingFromBillingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com",
    route: "/billing-groups/removeThingFromBillingGroup",
    validator: validate_RemoveThingFromBillingGroup_609081, base: "/",
    url: url_RemoveThingFromBillingGroup_609082,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveThingFromThingGroup_609094 = ref object of OpenApiRestCall_605589
proc url_RemoveThingFromThingGroup_609096(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_RemoveThingFromThingGroup_609095(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove the specified thing from the specified group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609097 = header.getOrDefault("X-Amz-Signature")
  valid_609097 = validateParameter(valid_609097, JString, required = false,
                                 default = nil)
  if valid_609097 != nil:
    section.add "X-Amz-Signature", valid_609097
  var valid_609098 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609098 = validateParameter(valid_609098, JString, required = false,
                                 default = nil)
  if valid_609098 != nil:
    section.add "X-Amz-Content-Sha256", valid_609098
  var valid_609099 = header.getOrDefault("X-Amz-Date")
  valid_609099 = validateParameter(valid_609099, JString, required = false,
                                 default = nil)
  if valid_609099 != nil:
    section.add "X-Amz-Date", valid_609099
  var valid_609100 = header.getOrDefault("X-Amz-Credential")
  valid_609100 = validateParameter(valid_609100, JString, required = false,
                                 default = nil)
  if valid_609100 != nil:
    section.add "X-Amz-Credential", valid_609100
  var valid_609101 = header.getOrDefault("X-Amz-Security-Token")
  valid_609101 = validateParameter(valid_609101, JString, required = false,
                                 default = nil)
  if valid_609101 != nil:
    section.add "X-Amz-Security-Token", valid_609101
  var valid_609102 = header.getOrDefault("X-Amz-Algorithm")
  valid_609102 = validateParameter(valid_609102, JString, required = false,
                                 default = nil)
  if valid_609102 != nil:
    section.add "X-Amz-Algorithm", valid_609102
  var valid_609103 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609103 = validateParameter(valid_609103, JString, required = false,
                                 default = nil)
  if valid_609103 != nil:
    section.add "X-Amz-SignedHeaders", valid_609103
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_609105: Call_RemoveThingFromThingGroup_609094; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Remove the specified thing from the specified group.
  ## 
  let valid = call_609105.validator(path, query, header, formData, body)
  let scheme = call_609105.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609105.url(scheme.get, call_609105.host, call_609105.base,
                         call_609105.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609105, url, valid)

proc call*(call_609106: Call_RemoveThingFromThingGroup_609094; body: JsonNode): Recallable =
  ## removeThingFromThingGroup
  ## Remove the specified thing from the specified group.
  ##   body: JObject (required)
  var body_609107 = newJObject()
  if body != nil:
    body_609107 = body
  result = call_609106.call(nil, nil, nil, nil, body_609107)

var removeThingFromThingGroup* = Call_RemoveThingFromThingGroup_609094(
    name: "removeThingFromThingGroup", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/removeThingFromThingGroup",
    validator: validate_RemoveThingFromThingGroup_609095, base: "/",
    url: url_RemoveThingFromThingGroup_609096,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_SearchIndex_609108 = ref object of OpenApiRestCall_605589
proc url_SearchIndex_609110(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_SearchIndex_609109(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## The query search index.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609111 = header.getOrDefault("X-Amz-Signature")
  valid_609111 = validateParameter(valid_609111, JString, required = false,
                                 default = nil)
  if valid_609111 != nil:
    section.add "X-Amz-Signature", valid_609111
  var valid_609112 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609112 = validateParameter(valid_609112, JString, required = false,
                                 default = nil)
  if valid_609112 != nil:
    section.add "X-Amz-Content-Sha256", valid_609112
  var valid_609113 = header.getOrDefault("X-Amz-Date")
  valid_609113 = validateParameter(valid_609113, JString, required = false,
                                 default = nil)
  if valid_609113 != nil:
    section.add "X-Amz-Date", valid_609113
  var valid_609114 = header.getOrDefault("X-Amz-Credential")
  valid_609114 = validateParameter(valid_609114, JString, required = false,
                                 default = nil)
  if valid_609114 != nil:
    section.add "X-Amz-Credential", valid_609114
  var valid_609115 = header.getOrDefault("X-Amz-Security-Token")
  valid_609115 = validateParameter(valid_609115, JString, required = false,
                                 default = nil)
  if valid_609115 != nil:
    section.add "X-Amz-Security-Token", valid_609115
  var valid_609116 = header.getOrDefault("X-Amz-Algorithm")
  valid_609116 = validateParameter(valid_609116, JString, required = false,
                                 default = nil)
  if valid_609116 != nil:
    section.add "X-Amz-Algorithm", valid_609116
  var valid_609117 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609117 = validateParameter(valid_609117, JString, required = false,
                                 default = nil)
  if valid_609117 != nil:
    section.add "X-Amz-SignedHeaders", valid_609117
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_609119: Call_SearchIndex_609108; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The query search index.
  ## 
  let valid = call_609119.validator(path, query, header, formData, body)
  let scheme = call_609119.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609119.url(scheme.get, call_609119.host, call_609119.base,
                         call_609119.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609119, url, valid)

proc call*(call_609120: Call_SearchIndex_609108; body: JsonNode): Recallable =
  ## searchIndex
  ## The query search index.
  ##   body: JObject (required)
  var body_609121 = newJObject()
  if body != nil:
    body_609121 = body
  result = call_609120.call(nil, nil, nil, nil, body_609121)

var searchIndex* = Call_SearchIndex_609108(name: "searchIndex",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com",
                                        route: "/indices/search",
                                        validator: validate_SearchIndex_609109,
                                        base: "/", url: url_SearchIndex_609110,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartOnDemandAuditTask_609122 = ref object of OpenApiRestCall_605589
proc url_StartOnDemandAuditTask_609124(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_StartOnDemandAuditTask_609123(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts an on-demand Device Defender audit.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609125 = header.getOrDefault("X-Amz-Signature")
  valid_609125 = validateParameter(valid_609125, JString, required = false,
                                 default = nil)
  if valid_609125 != nil:
    section.add "X-Amz-Signature", valid_609125
  var valid_609126 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609126 = validateParameter(valid_609126, JString, required = false,
                                 default = nil)
  if valid_609126 != nil:
    section.add "X-Amz-Content-Sha256", valid_609126
  var valid_609127 = header.getOrDefault("X-Amz-Date")
  valid_609127 = validateParameter(valid_609127, JString, required = false,
                                 default = nil)
  if valid_609127 != nil:
    section.add "X-Amz-Date", valid_609127
  var valid_609128 = header.getOrDefault("X-Amz-Credential")
  valid_609128 = validateParameter(valid_609128, JString, required = false,
                                 default = nil)
  if valid_609128 != nil:
    section.add "X-Amz-Credential", valid_609128
  var valid_609129 = header.getOrDefault("X-Amz-Security-Token")
  valid_609129 = validateParameter(valid_609129, JString, required = false,
                                 default = nil)
  if valid_609129 != nil:
    section.add "X-Amz-Security-Token", valid_609129
  var valid_609130 = header.getOrDefault("X-Amz-Algorithm")
  valid_609130 = validateParameter(valid_609130, JString, required = false,
                                 default = nil)
  if valid_609130 != nil:
    section.add "X-Amz-Algorithm", valid_609130
  var valid_609131 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609131 = validateParameter(valid_609131, JString, required = false,
                                 default = nil)
  if valid_609131 != nil:
    section.add "X-Amz-SignedHeaders", valid_609131
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_609133: Call_StartOnDemandAuditTask_609122; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts an on-demand Device Defender audit.
  ## 
  let valid = call_609133.validator(path, query, header, formData, body)
  let scheme = call_609133.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609133.url(scheme.get, call_609133.host, call_609133.base,
                         call_609133.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609133, url, valid)

proc call*(call_609134: Call_StartOnDemandAuditTask_609122; body: JsonNode): Recallable =
  ## startOnDemandAuditTask
  ## Starts an on-demand Device Defender audit.
  ##   body: JObject (required)
  var body_609135 = newJObject()
  if body != nil:
    body_609135 = body
  result = call_609134.call(nil, nil, nil, nil, body_609135)

var startOnDemandAuditTask* = Call_StartOnDemandAuditTask_609122(
    name: "startOnDemandAuditTask", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/audit/tasks",
    validator: validate_StartOnDemandAuditTask_609123, base: "/",
    url: url_StartOnDemandAuditTask_609124, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StopThingRegistrationTask_609136 = ref object of OpenApiRestCall_605589
proc url_StopThingRegistrationTask_609138(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "taskId" in path, "`taskId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/thing-registration-tasks/"),
               (kind: VariableSegment, value: "taskId"),
               (kind: ConstantSegment, value: "/cancel")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_StopThingRegistrationTask_609137(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Cancels a bulk thing provisioning task.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   taskId: JString (required)
  ##         : The bulk thing provisioning task ID.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `taskId` field"
  var valid_609139 = path.getOrDefault("taskId")
  valid_609139 = validateParameter(valid_609139, JString, required = true,
                                 default = nil)
  if valid_609139 != nil:
    section.add "taskId", valid_609139
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609140 = header.getOrDefault("X-Amz-Signature")
  valid_609140 = validateParameter(valid_609140, JString, required = false,
                                 default = nil)
  if valid_609140 != nil:
    section.add "X-Amz-Signature", valid_609140
  var valid_609141 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609141 = validateParameter(valid_609141, JString, required = false,
                                 default = nil)
  if valid_609141 != nil:
    section.add "X-Amz-Content-Sha256", valid_609141
  var valid_609142 = header.getOrDefault("X-Amz-Date")
  valid_609142 = validateParameter(valid_609142, JString, required = false,
                                 default = nil)
  if valid_609142 != nil:
    section.add "X-Amz-Date", valid_609142
  var valid_609143 = header.getOrDefault("X-Amz-Credential")
  valid_609143 = validateParameter(valid_609143, JString, required = false,
                                 default = nil)
  if valid_609143 != nil:
    section.add "X-Amz-Credential", valid_609143
  var valid_609144 = header.getOrDefault("X-Amz-Security-Token")
  valid_609144 = validateParameter(valid_609144, JString, required = false,
                                 default = nil)
  if valid_609144 != nil:
    section.add "X-Amz-Security-Token", valid_609144
  var valid_609145 = header.getOrDefault("X-Amz-Algorithm")
  valid_609145 = validateParameter(valid_609145, JString, required = false,
                                 default = nil)
  if valid_609145 != nil:
    section.add "X-Amz-Algorithm", valid_609145
  var valid_609146 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609146 = validateParameter(valid_609146, JString, required = false,
                                 default = nil)
  if valid_609146 != nil:
    section.add "X-Amz-SignedHeaders", valid_609146
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609147: Call_StopThingRegistrationTask_609136; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a bulk thing provisioning task.
  ## 
  let valid = call_609147.validator(path, query, header, formData, body)
  let scheme = call_609147.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609147.url(scheme.get, call_609147.host, call_609147.base,
                         call_609147.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609147, url, valid)

proc call*(call_609148: Call_StopThingRegistrationTask_609136; taskId: string): Recallable =
  ## stopThingRegistrationTask
  ## Cancels a bulk thing provisioning task.
  ##   taskId: string (required)
  ##         : The bulk thing provisioning task ID.
  var path_609149 = newJObject()
  add(path_609149, "taskId", newJString(taskId))
  result = call_609148.call(path_609149, nil, nil, nil, nil)

var stopThingRegistrationTask* = Call_StopThingRegistrationTask_609136(
    name: "stopThingRegistrationTask", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-registration-tasks/{taskId}/cancel",
    validator: validate_StopThingRegistrationTask_609137, base: "/",
    url: url_StopThingRegistrationTask_609138,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_TagResource_609150 = ref object of OpenApiRestCall_605589
proc url_TagResource_609152(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_TagResource_609151(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609153 = header.getOrDefault("X-Amz-Signature")
  valid_609153 = validateParameter(valid_609153, JString, required = false,
                                 default = nil)
  if valid_609153 != nil:
    section.add "X-Amz-Signature", valid_609153
  var valid_609154 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609154 = validateParameter(valid_609154, JString, required = false,
                                 default = nil)
  if valid_609154 != nil:
    section.add "X-Amz-Content-Sha256", valid_609154
  var valid_609155 = header.getOrDefault("X-Amz-Date")
  valid_609155 = validateParameter(valid_609155, JString, required = false,
                                 default = nil)
  if valid_609155 != nil:
    section.add "X-Amz-Date", valid_609155
  var valid_609156 = header.getOrDefault("X-Amz-Credential")
  valid_609156 = validateParameter(valid_609156, JString, required = false,
                                 default = nil)
  if valid_609156 != nil:
    section.add "X-Amz-Credential", valid_609156
  var valid_609157 = header.getOrDefault("X-Amz-Security-Token")
  valid_609157 = validateParameter(valid_609157, JString, required = false,
                                 default = nil)
  if valid_609157 != nil:
    section.add "X-Amz-Security-Token", valid_609157
  var valid_609158 = header.getOrDefault("X-Amz-Algorithm")
  valid_609158 = validateParameter(valid_609158, JString, required = false,
                                 default = nil)
  if valid_609158 != nil:
    section.add "X-Amz-Algorithm", valid_609158
  var valid_609159 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609159 = validateParameter(valid_609159, JString, required = false,
                                 default = nil)
  if valid_609159 != nil:
    section.add "X-Amz-SignedHeaders", valid_609159
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_609161: Call_TagResource_609150; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ## 
  let valid = call_609161.validator(path, query, header, formData, body)
  let scheme = call_609161.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609161.url(scheme.get, call_609161.host, call_609161.base,
                         call_609161.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609161, url, valid)

proc call*(call_609162: Call_TagResource_609150; body: JsonNode): Recallable =
  ## tagResource
  ## Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
  ##   body: JObject (required)
  var body_609163 = newJObject()
  if body != nil:
    body_609163 = body
  result = call_609162.call(nil, nil, nil, nil, body_609163)

var tagResource* = Call_TagResource_609150(name: "tagResource",
                                        meth: HttpMethod.HttpPost,
                                        host: "iot.amazonaws.com", route: "/tags",
                                        validator: validate_TagResource_609151,
                                        base: "/", url: url_TagResource_609152,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_TestAuthorization_609164 = ref object of OpenApiRestCall_605589
proc url_TestAuthorization_609166(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_TestAuthorization_609165(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   clientId: JString
  ##           : The MQTT client ID.
  section = newJObject()
  var valid_609167 = query.getOrDefault("clientId")
  valid_609167 = validateParameter(valid_609167, JString, required = false,
                                 default = nil)
  if valid_609167 != nil:
    section.add "clientId", valid_609167
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609168 = header.getOrDefault("X-Amz-Signature")
  valid_609168 = validateParameter(valid_609168, JString, required = false,
                                 default = nil)
  if valid_609168 != nil:
    section.add "X-Amz-Signature", valid_609168
  var valid_609169 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609169 = validateParameter(valid_609169, JString, required = false,
                                 default = nil)
  if valid_609169 != nil:
    section.add "X-Amz-Content-Sha256", valid_609169
  var valid_609170 = header.getOrDefault("X-Amz-Date")
  valid_609170 = validateParameter(valid_609170, JString, required = false,
                                 default = nil)
  if valid_609170 != nil:
    section.add "X-Amz-Date", valid_609170
  var valid_609171 = header.getOrDefault("X-Amz-Credential")
  valid_609171 = validateParameter(valid_609171, JString, required = false,
                                 default = nil)
  if valid_609171 != nil:
    section.add "X-Amz-Credential", valid_609171
  var valid_609172 = header.getOrDefault("X-Amz-Security-Token")
  valid_609172 = validateParameter(valid_609172, JString, required = false,
                                 default = nil)
  if valid_609172 != nil:
    section.add "X-Amz-Security-Token", valid_609172
  var valid_609173 = header.getOrDefault("X-Amz-Algorithm")
  valid_609173 = validateParameter(valid_609173, JString, required = false,
                                 default = nil)
  if valid_609173 != nil:
    section.add "X-Amz-Algorithm", valid_609173
  var valid_609174 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609174 = validateParameter(valid_609174, JString, required = false,
                                 default = nil)
  if valid_609174 != nil:
    section.add "X-Amz-SignedHeaders", valid_609174
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_609176: Call_TestAuthorization_609164; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  let valid = call_609176.validator(path, query, header, formData, body)
  let scheme = call_609176.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609176.url(scheme.get, call_609176.host, call_609176.base,
                         call_609176.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609176, url, valid)

proc call*(call_609177: Call_TestAuthorization_609164; body: JsonNode;
          clientId: string = ""): Recallable =
  ## testAuthorization
  ## Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.
  ##   clientId: string
  ##           : The MQTT client ID.
  ##   body: JObject (required)
  var query_609178 = newJObject()
  var body_609179 = newJObject()
  add(query_609178, "clientId", newJString(clientId))
  if body != nil:
    body_609179 = body
  result = call_609177.call(nil, query_609178, nil, nil, body_609179)

var testAuthorization* = Call_TestAuthorization_609164(name: "testAuthorization",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com",
    route: "/test-authorization", validator: validate_TestAuthorization_609165,
    base: "/", url: url_TestAuthorization_609166,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_TestInvokeAuthorizer_609180 = ref object of OpenApiRestCall_605589
proc url_TestInvokeAuthorizer_609182(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "authorizerName" in path, "`authorizerName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/authorizer/"),
               (kind: VariableSegment, value: "authorizerName"),
               (kind: ConstantSegment, value: "/test")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_TestInvokeAuthorizer_609181(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   authorizerName: JString (required)
  ##                 : The custom authorizer name.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `authorizerName` field"
  var valid_609183 = path.getOrDefault("authorizerName")
  valid_609183 = validateParameter(valid_609183, JString, required = true,
                                 default = nil)
  if valid_609183 != nil:
    section.add "authorizerName", valid_609183
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609184 = header.getOrDefault("X-Amz-Signature")
  valid_609184 = validateParameter(valid_609184, JString, required = false,
                                 default = nil)
  if valid_609184 != nil:
    section.add "X-Amz-Signature", valid_609184
  var valid_609185 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609185 = validateParameter(valid_609185, JString, required = false,
                                 default = nil)
  if valid_609185 != nil:
    section.add "X-Amz-Content-Sha256", valid_609185
  var valid_609186 = header.getOrDefault("X-Amz-Date")
  valid_609186 = validateParameter(valid_609186, JString, required = false,
                                 default = nil)
  if valid_609186 != nil:
    section.add "X-Amz-Date", valid_609186
  var valid_609187 = header.getOrDefault("X-Amz-Credential")
  valid_609187 = validateParameter(valid_609187, JString, required = false,
                                 default = nil)
  if valid_609187 != nil:
    section.add "X-Amz-Credential", valid_609187
  var valid_609188 = header.getOrDefault("X-Amz-Security-Token")
  valid_609188 = validateParameter(valid_609188, JString, required = false,
                                 default = nil)
  if valid_609188 != nil:
    section.add "X-Amz-Security-Token", valid_609188
  var valid_609189 = header.getOrDefault("X-Amz-Algorithm")
  valid_609189 = validateParameter(valid_609189, JString, required = false,
                                 default = nil)
  if valid_609189 != nil:
    section.add "X-Amz-Algorithm", valid_609189
  var valid_609190 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609190 = validateParameter(valid_609190, JString, required = false,
                                 default = nil)
  if valid_609190 != nil:
    section.add "X-Amz-SignedHeaders", valid_609190
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_609192: Call_TestInvokeAuthorizer_609180; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ## 
  let valid = call_609192.validator(path, query, header, formData, body)
  let scheme = call_609192.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609192.url(scheme.get, call_609192.host, call_609192.base,
                         call_609192.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609192, url, valid)

proc call*(call_609193: Call_TestInvokeAuthorizer_609180; authorizerName: string;
          body: JsonNode): Recallable =
  ## testInvokeAuthorizer
  ## Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.
  ##   authorizerName: string (required)
  ##                 : The custom authorizer name.
  ##   body: JObject (required)
  var path_609194 = newJObject()
  var body_609195 = newJObject()
  add(path_609194, "authorizerName", newJString(authorizerName))
  if body != nil:
    body_609195 = body
  result = call_609193.call(path_609194, nil, nil, nil, body_609195)

var testInvokeAuthorizer* = Call_TestInvokeAuthorizer_609180(
    name: "testInvokeAuthorizer", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/authorizer/{authorizerName}/test",
    validator: validate_TestInvokeAuthorizer_609181, base: "/",
    url: url_TestInvokeAuthorizer_609182, schemes: {Scheme.Https, Scheme.Http})
type
  Call_TransferCertificate_609196 = ref object of OpenApiRestCall_605589
proc url_TransferCertificate_609198(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/transfer-certificate/"),
               (kind: VariableSegment, value: "certificateId"),
               (kind: ConstantSegment, value: "#targetAwsAccount")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_TransferCertificate_609197(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_609199 = path.getOrDefault("certificateId")
  valid_609199 = validateParameter(valid_609199, JString, required = true,
                                 default = nil)
  if valid_609199 != nil:
    section.add "certificateId", valid_609199
  result.add "path", section
  ## parameters in `query` object:
  ##   targetAwsAccount: JString (required)
  ##                   : The AWS account.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `targetAwsAccount` field"
  var valid_609200 = query.getOrDefault("targetAwsAccount")
  valid_609200 = validateParameter(valid_609200, JString, required = true,
                                 default = nil)
  if valid_609200 != nil:
    section.add "targetAwsAccount", valid_609200
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609201 = header.getOrDefault("X-Amz-Signature")
  valid_609201 = validateParameter(valid_609201, JString, required = false,
                                 default = nil)
  if valid_609201 != nil:
    section.add "X-Amz-Signature", valid_609201
  var valid_609202 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609202 = validateParameter(valid_609202, JString, required = false,
                                 default = nil)
  if valid_609202 != nil:
    section.add "X-Amz-Content-Sha256", valid_609202
  var valid_609203 = header.getOrDefault("X-Amz-Date")
  valid_609203 = validateParameter(valid_609203, JString, required = false,
                                 default = nil)
  if valid_609203 != nil:
    section.add "X-Amz-Date", valid_609203
  var valid_609204 = header.getOrDefault("X-Amz-Credential")
  valid_609204 = validateParameter(valid_609204, JString, required = false,
                                 default = nil)
  if valid_609204 != nil:
    section.add "X-Amz-Credential", valid_609204
  var valid_609205 = header.getOrDefault("X-Amz-Security-Token")
  valid_609205 = validateParameter(valid_609205, JString, required = false,
                                 default = nil)
  if valid_609205 != nil:
    section.add "X-Amz-Security-Token", valid_609205
  var valid_609206 = header.getOrDefault("X-Amz-Algorithm")
  valid_609206 = validateParameter(valid_609206, JString, required = false,
                                 default = nil)
  if valid_609206 != nil:
    section.add "X-Amz-Algorithm", valid_609206
  var valid_609207 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609207 = validateParameter(valid_609207, JString, required = false,
                                 default = nil)
  if valid_609207 != nil:
    section.add "X-Amz-SignedHeaders", valid_609207
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_609209: Call_TransferCertificate_609196; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ## 
  let valid = call_609209.validator(path, query, header, formData, body)
  let scheme = call_609209.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609209.url(scheme.get, call_609209.host, call_609209.base,
                         call_609209.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609209, url, valid)

proc call*(call_609210: Call_TransferCertificate_609196; body: JsonNode;
          certificateId: string; targetAwsAccount: string): Recallable =
  ## transferCertificate
  ## <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
  ##   body: JObject (required)
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  ##   targetAwsAccount: string (required)
  ##                   : The AWS account.
  var path_609211 = newJObject()
  var query_609212 = newJObject()
  var body_609213 = newJObject()
  if body != nil:
    body_609213 = body
  add(path_609211, "certificateId", newJString(certificateId))
  add(query_609212, "targetAwsAccount", newJString(targetAwsAccount))
  result = call_609210.call(path_609211, query_609212, nil, nil, body_609213)

var transferCertificate* = Call_TransferCertificate_609196(
    name: "transferCertificate", meth: HttpMethod.HttpPatch,
    host: "iot.amazonaws.com",
    route: "/transfer-certificate/{certificateId}#targetAwsAccount",
    validator: validate_TransferCertificate_609197, base: "/",
    url: url_TransferCertificate_609198, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UntagResource_609214 = ref object of OpenApiRestCall_605589
proc url_UntagResource_609216(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UntagResource_609215(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes the given tags (metadata) from the resource.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609217 = header.getOrDefault("X-Amz-Signature")
  valid_609217 = validateParameter(valid_609217, JString, required = false,
                                 default = nil)
  if valid_609217 != nil:
    section.add "X-Amz-Signature", valid_609217
  var valid_609218 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609218 = validateParameter(valid_609218, JString, required = false,
                                 default = nil)
  if valid_609218 != nil:
    section.add "X-Amz-Content-Sha256", valid_609218
  var valid_609219 = header.getOrDefault("X-Amz-Date")
  valid_609219 = validateParameter(valid_609219, JString, required = false,
                                 default = nil)
  if valid_609219 != nil:
    section.add "X-Amz-Date", valid_609219
  var valid_609220 = header.getOrDefault("X-Amz-Credential")
  valid_609220 = validateParameter(valid_609220, JString, required = false,
                                 default = nil)
  if valid_609220 != nil:
    section.add "X-Amz-Credential", valid_609220
  var valid_609221 = header.getOrDefault("X-Amz-Security-Token")
  valid_609221 = validateParameter(valid_609221, JString, required = false,
                                 default = nil)
  if valid_609221 != nil:
    section.add "X-Amz-Security-Token", valid_609221
  var valid_609222 = header.getOrDefault("X-Amz-Algorithm")
  valid_609222 = validateParameter(valid_609222, JString, required = false,
                                 default = nil)
  if valid_609222 != nil:
    section.add "X-Amz-Algorithm", valid_609222
  var valid_609223 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609223 = validateParameter(valid_609223, JString, required = false,
                                 default = nil)
  if valid_609223 != nil:
    section.add "X-Amz-SignedHeaders", valid_609223
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_609225: Call_UntagResource_609214; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes the given tags (metadata) from the resource.
  ## 
  let valid = call_609225.validator(path, query, header, formData, body)
  let scheme = call_609225.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609225.url(scheme.get, call_609225.host, call_609225.base,
                         call_609225.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609225, url, valid)

proc call*(call_609226: Call_UntagResource_609214; body: JsonNode): Recallable =
  ## untagResource
  ## Removes the given tags (metadata) from the resource.
  ##   body: JObject (required)
  var body_609227 = newJObject()
  if body != nil:
    body_609227 = body
  result = call_609226.call(nil, nil, nil, nil, body_609227)

var untagResource* = Call_UntagResource_609214(name: "untagResource",
    meth: HttpMethod.HttpPost, host: "iot.amazonaws.com", route: "/untag",
    validator: validate_UntagResource_609215, base: "/", url: url_UntagResource_609216,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateCertificate_609228 = ref object of OpenApiRestCall_605589
proc url_UpdateCertificate_609230(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "certificateId" in path, "`certificateId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/certificates/"),
               (kind: VariableSegment, value: "certificateId"),
               (kind: ConstantSegment, value: "#newStatus")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_UpdateCertificate_609229(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   certificateId: JString (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `certificateId` field"
  var valid_609231 = path.getOrDefault("certificateId")
  valid_609231 = validateParameter(valid_609231, JString, required = true,
                                 default = nil)
  if valid_609231 != nil:
    section.add "certificateId", valid_609231
  result.add "path", section
  ## parameters in `query` object:
  ##   newStatus: JString (required)
  ##            : <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  section = newJObject()
  var valid_609232 = query.getOrDefault("newStatus")
  valid_609232 = validateParameter(valid_609232, JString, required = true,
                                 default = newJString("ACTIVE"))
  if valid_609232 != nil:
    section.add "newStatus", valid_609232
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609233 = header.getOrDefault("X-Amz-Signature")
  valid_609233 = validateParameter(valid_609233, JString, required = false,
                                 default = nil)
  if valid_609233 != nil:
    section.add "X-Amz-Signature", valid_609233
  var valid_609234 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609234 = validateParameter(valid_609234, JString, required = false,
                                 default = nil)
  if valid_609234 != nil:
    section.add "X-Amz-Content-Sha256", valid_609234
  var valid_609235 = header.getOrDefault("X-Amz-Date")
  valid_609235 = validateParameter(valid_609235, JString, required = false,
                                 default = nil)
  if valid_609235 != nil:
    section.add "X-Amz-Date", valid_609235
  var valid_609236 = header.getOrDefault("X-Amz-Credential")
  valid_609236 = validateParameter(valid_609236, JString, required = false,
                                 default = nil)
  if valid_609236 != nil:
    section.add "X-Amz-Credential", valid_609236
  var valid_609237 = header.getOrDefault("X-Amz-Security-Token")
  valid_609237 = validateParameter(valid_609237, JString, required = false,
                                 default = nil)
  if valid_609237 != nil:
    section.add "X-Amz-Security-Token", valid_609237
  var valid_609238 = header.getOrDefault("X-Amz-Algorithm")
  valid_609238 = validateParameter(valid_609238, JString, required = false,
                                 default = nil)
  if valid_609238 != nil:
    section.add "X-Amz-Algorithm", valid_609238
  var valid_609239 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609239 = validateParameter(valid_609239, JString, required = false,
                                 default = nil)
  if valid_609239 != nil:
    section.add "X-Amz-SignedHeaders", valid_609239
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_609240: Call_UpdateCertificate_609228; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ## 
  let valid = call_609240.validator(path, query, header, formData, body)
  let scheme = call_609240.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609240.url(scheme.get, call_609240.host, call_609240.base,
                         call_609240.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609240, url, valid)

proc call*(call_609241: Call_UpdateCertificate_609228; certificateId: string;
          newStatus: string = "ACTIVE"): Recallable =
  ## updateCertificate
  ## <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
  ##   newStatus: string (required)
  ##            : <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
  ##   certificateId: string (required)
  ##                : The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
  var path_609242 = newJObject()
  var query_609243 = newJObject()
  add(query_609243, "newStatus", newJString(newStatus))
  add(path_609242, "certificateId", newJString(certificateId))
  result = call_609241.call(path_609242, query_609243, nil, nil, nil)

var updateCertificate* = Call_UpdateCertificate_609228(name: "updateCertificate",
    meth: HttpMethod.HttpPut, host: "iot.amazonaws.com",
    route: "/certificates/{certificateId}#newStatus",
    validator: validate_UpdateCertificate_609229, base: "/",
    url: url_UpdateCertificate_609230, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateThingGroupsForThing_609244 = ref object of OpenApiRestCall_605589
proc url_UpdateThingGroupsForThing_609246(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_UpdateThingGroupsForThing_609245(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the groups to which the thing belongs.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609247 = header.getOrDefault("X-Amz-Signature")
  valid_609247 = validateParameter(valid_609247, JString, required = false,
                                 default = nil)
  if valid_609247 != nil:
    section.add "X-Amz-Signature", valid_609247
  var valid_609248 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609248 = validateParameter(valid_609248, JString, required = false,
                                 default = nil)
  if valid_609248 != nil:
    section.add "X-Amz-Content-Sha256", valid_609248
  var valid_609249 = header.getOrDefault("X-Amz-Date")
  valid_609249 = validateParameter(valid_609249, JString, required = false,
                                 default = nil)
  if valid_609249 != nil:
    section.add "X-Amz-Date", valid_609249
  var valid_609250 = header.getOrDefault("X-Amz-Credential")
  valid_609250 = validateParameter(valid_609250, JString, required = false,
                                 default = nil)
  if valid_609250 != nil:
    section.add "X-Amz-Credential", valid_609250
  var valid_609251 = header.getOrDefault("X-Amz-Security-Token")
  valid_609251 = validateParameter(valid_609251, JString, required = false,
                                 default = nil)
  if valid_609251 != nil:
    section.add "X-Amz-Security-Token", valid_609251
  var valid_609252 = header.getOrDefault("X-Amz-Algorithm")
  valid_609252 = validateParameter(valid_609252, JString, required = false,
                                 default = nil)
  if valid_609252 != nil:
    section.add "X-Amz-Algorithm", valid_609252
  var valid_609253 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609253 = validateParameter(valid_609253, JString, required = false,
                                 default = nil)
  if valid_609253 != nil:
    section.add "X-Amz-SignedHeaders", valid_609253
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_609255: Call_UpdateThingGroupsForThing_609244; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the groups to which the thing belongs.
  ## 
  let valid = call_609255.validator(path, query, header, formData, body)
  let scheme = call_609255.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609255.url(scheme.get, call_609255.host, call_609255.base,
                         call_609255.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609255, url, valid)

proc call*(call_609256: Call_UpdateThingGroupsForThing_609244; body: JsonNode): Recallable =
  ## updateThingGroupsForThing
  ## Updates the groups to which the thing belongs.
  ##   body: JObject (required)
  var body_609257 = newJObject()
  if body != nil:
    body_609257 = body
  result = call_609256.call(nil, nil, nil, nil, body_609257)

var updateThingGroupsForThing* = Call_UpdateThingGroupsForThing_609244(
    name: "updateThingGroupsForThing", meth: HttpMethod.HttpPut,
    host: "iot.amazonaws.com", route: "/thing-groups/updateThingGroupsForThing",
    validator: validate_UpdateThingGroupsForThing_609245, base: "/",
    url: url_UpdateThingGroupsForThing_609246,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ValidateSecurityProfileBehaviors_609258 = ref object of OpenApiRestCall_605589
proc url_ValidateSecurityProfileBehaviors_609260(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_ValidateSecurityProfileBehaviors_609259(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validates a Device Defender security profile behaviors specification.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_609261 = header.getOrDefault("X-Amz-Signature")
  valid_609261 = validateParameter(valid_609261, JString, required = false,
                                 default = nil)
  if valid_609261 != nil:
    section.add "X-Amz-Signature", valid_609261
  var valid_609262 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_609262 = validateParameter(valid_609262, JString, required = false,
                                 default = nil)
  if valid_609262 != nil:
    section.add "X-Amz-Content-Sha256", valid_609262
  var valid_609263 = header.getOrDefault("X-Amz-Date")
  valid_609263 = validateParameter(valid_609263, JString, required = false,
                                 default = nil)
  if valid_609263 != nil:
    section.add "X-Amz-Date", valid_609263
  var valid_609264 = header.getOrDefault("X-Amz-Credential")
  valid_609264 = validateParameter(valid_609264, JString, required = false,
                                 default = nil)
  if valid_609264 != nil:
    section.add "X-Amz-Credential", valid_609264
  var valid_609265 = header.getOrDefault("X-Amz-Security-Token")
  valid_609265 = validateParameter(valid_609265, JString, required = false,
                                 default = nil)
  if valid_609265 != nil:
    section.add "X-Amz-Security-Token", valid_609265
  var valid_609266 = header.getOrDefault("X-Amz-Algorithm")
  valid_609266 = validateParameter(valid_609266, JString, required = false,
                                 default = nil)
  if valid_609266 != nil:
    section.add "X-Amz-Algorithm", valid_609266
  var valid_609267 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_609267 = validateParameter(valid_609267, JString, required = false,
                                 default = nil)
  if valid_609267 != nil:
    section.add "X-Amz-SignedHeaders", valid_609267
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_609269: Call_ValidateSecurityProfileBehaviors_609258;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Validates a Device Defender security profile behaviors specification.
  ## 
  let valid = call_609269.validator(path, query, header, formData, body)
  let scheme = call_609269.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_609269.url(scheme.get, call_609269.host, call_609269.base,
                         call_609269.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_609269, url, valid)

proc call*(call_609270: Call_ValidateSecurityProfileBehaviors_609258;
          body: JsonNode): Recallable =
  ## validateSecurityProfileBehaviors
  ## Validates a Device Defender security profile behaviors specification.
  ##   body: JObject (required)
  var body_609271 = newJObject()
  if body != nil:
    body_609271 = body
  result = call_609270.call(nil, nil, nil, nil, body_609271)

var validateSecurityProfileBehaviors* = Call_ValidateSecurityProfileBehaviors_609258(
    name: "validateSecurityProfileBehaviors", meth: HttpMethod.HttpPost,
    host: "iot.amazonaws.com", route: "/security-profile-behaviors/validate",
    validator: validate_ValidateSecurityProfileBehaviors_609259, base: "/",
    url: url_ValidateSecurityProfileBehaviors_609260,
    schemes: {Scheme.Https, Scheme.Http})
export
  rest

type
  EnvKind = enum
    BakeIntoBinary = "Baking $1 into the binary",
    FetchFromEnv = "Fetch $1 from the environment"
template sloppyConst(via: EnvKind; name: untyped): untyped =
  import
    macros

  const
    name {.strdefine.}: string = case via
    of BakeIntoBinary:
      getEnv(astToStr(name), "")
    of FetchFromEnv:
      ""
  static :
    let msg = block:
      if name == "":
        "Missing $1 in the environment"
      else:
        $via
    warning msg % [astToStr(name)]

sloppyConst FetchFromEnv, AWS_ACCESS_KEY_ID
sloppyConst FetchFromEnv, AWS_SECRET_ACCESS_KEY
sloppyConst BakeIntoBinary, AWS_REGION
sloppyConst FetchFromEnv, AWS_ACCOUNT_ID
proc atozSign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", AWS_ACCESS_KEY_ID)
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", AWS_SECRET_ACCESS_KEY)
    region = os.getEnv("AWS_REGION", AWS_REGION)
  assert secret != "", "need $AWS_SECRET_ACCESS_KEY in environment"
  assert access != "", "need $AWS_ACCESS_KEY_ID in environment"
  assert region != "", "need $AWS_REGION in environment"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  recall.headers.del "Host"
  recall.url = $url

method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  ## the hook is a terrible earworm
  var headers = newHttpHeaders(massageHeaders(input.getOrDefault("header")))
  let
    body = input.getOrDefault("body")
    text = if body == nil:
      "" elif body.kind == JString:
      body.getStr else:
      $body
  if body != nil and body.kind != JString:
    if not headers.hasKey("content-type"):
      headers["content-type"] = "application/x-amz-json-1.0"
  const
    XAmzSecurityToken = "X-Amz-Security-Token"
  if not headers.hasKey(XAmzSecurityToken):
    let session = getEnv("AWS_SESSION_TOKEN", "")
    if session != "":
      headers[XAmzSecurityToken] = session
  result = newRecallable(call, url, headers, text)
  result.atozSign(input.getOrDefault("query"), SHA256)
